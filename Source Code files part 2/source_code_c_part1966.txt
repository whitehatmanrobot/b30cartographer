s 
*/

/**********************************************************************
** Function:    DRM_LST_Open
** Synopsis:    Initialize the license store at szDataStoreName
** Arguments:   [pbLicContext] -- user given licstore context buffer
**              [pcbLicContext] -- pointer to the size of pbLicContext
** Returns:     
** Notes:
***********************************************************************/
DRM_RESULT DRM_API DRM_LST_Open( 
    OUT DRM_LICSTORE_CONTEXT *pbLicContext,
    IN  DRM_HDS_CONTEXT      *poHdsContext ); 


/**********************************************************************
** Function:    DRM_LST_Close
** Synopsis:    Close the license store.  This will also Commit before close
** Arguments:   [pbLicContext] -- user given licstore context buffer
** Returns:     
** Notes:
***********************************************************************/
DRM_RESULT DRM_API DRM_LST_Close( 
    IN DRM_LICSTORE_CONTEXT *pbLicContext);


/**********************************************************************
** Function:    DRM_LST_AddLicense
** Synopsis:    Add a license to the store 
** Arguments:   [pbLicContext] -- user given licstore context buffer
**              [cbLicense] -- size of license xml string in bytes.
**              [pbLicense] -- byte pointer of given license xml string
** Returns:     
** Notes:
***********************************************************************/
DRM_RESULT DRM_API DRM_LST_AddLicense(
    IN DRM_LICSTORE_CONTEXT *pbLicContext,
    IN DRM_DWORD             cbLicense,
    IN DRM_BYTE             *pbLicense,
    IN DRM_KID              *pkid,
    IN DRM_LID              *plid,
    IN DRM_DWORD             dwPriority );


/**********************************************************************
** Function:    DRM_LST_GetLicense
** Synopsis:    Get a license from the store using KID and LID
** Arguments:   [pbLicContext] -- user given licstore context buffer
**              [bKID] -- given license's KID
**              [bLID] -- given license's LID
**              [pbLicense] -- user given buffer to receive license
**              [pcbLicense] -- size of pbLicense in bytes
** Returns:     
** Notes:
***********************************************************************/
DRM_RESULT DRM_API DRM_LST_GetLicense( 
    IN     DRM_LICSTORE_CONTEXT *pbLicContext,
    IN     DRM_KID              *pKID,      /* key to use for the query */
    IN     DRM_LID              *pLID, 
    IN     DRM_HDS_SLOT_HINT    *pSlotHint,
       OUT DRM_BYTE             *pbLicense, 
    IN OUT DRM_DWORD            *pcbLicense);

DRM_RESULT DRM_API DRM_LST_DeleteLicense(
    DRM_LICSTORE_CONTEXT *pcontextLS,
    DRM_KID              *pkid,
    DRM_LID              *plid, 
    DRM_HDS_SLOT_HINT    *pslotHint );

/**********************************************************************
** Function:    DRM_LST_InitEnum
** Synopsis:    un-indexed enumeration of the license store
** Arguments:   [pbLicContext] -- user given licstore context buffer
**              [pKID] -- KID filter to be used. if not specified, all license will be enum'ed
**              [fPrioritized] -- Ignored if pKID is NULL. TRUE to prioritize returned licenses 
**                           with highest priority first. FALSE to enum in nature order.
**              [pLicEnumContext] -- user given Enumeration context
** Returns:     
** Notes:
***********************************************************************/
DRM_RESULT DRM_API DRM_LST_InitEnum(
    IN  DRM_LICSTORE_CONTEXT     *pbLicContext, 
    IN  DRM_KID                  *pKID,           /* if NULL, all licenses will be enum'ed */
    IN  DRM_BOOL                  fPrioritized,   /* ignored if pKID is NULL */
    OUT DRM_LICSTOREENUM_CONTEXT *pLicEnumContext); 

DRM_RESULT DRM_API DRM_LST_EnumNext( 
    IN DRM_LICSTOREENUM_CONTEXT *pLicEnumContext,    /* setup by DRM_LST_InitEnum() */
    OUT DRM_KID                 *pKID,               /* if priortized or pKID is given, this is optional */
    OUT DRM_LID                 *pLID,
    OUT DRM_HDS_SLOT_HINT       *pSlotHint,
    OUT DRM_DWORD               *pcbLicense);        /* License size */

/* delete current enumerated license */
DRM_RESULT DRM_API DRM_LST_EnumDelete( 
    IN DRM_LICSTOREENUM_CONTEXT *pLicEnumContext);

/*--------------------------------------------------------------------
** 
** Function :   DRM_LST_LicCount
** 
** Synopsis :   Counts the number of licenses in the store
** 
** Arguments :  [pLicEnumCtxt]: context setup by DRM_LST_InitEnum
**              [pcLicenses]: pointer to DWORD recieving number of
**                  licenses in store
** 
** Returns :    
** 
** Notes :      BUGBUG: Investigate whether it can be more efficient
**              by doing the enumeration within the HDS layer
** 
--------------------------------------------------------------------*/
DRM_RESULT DRM_API DRM_LST_LicCount( 
    IN  DRM_LICSTOREENUM_CONTEXT *pLicEnumCtxt, 
    OUT DRM_DWORD                *pcLicenses );

/* Callback function to report progress during License store cleanup */
typedef DRM_RESULT ( DRM_API *pfnStoreCleanupProgress )( 
    IN  const DRM_VOID    *pvCallerData, 
    IN        DRM_DWORD   cLicensesProcessed,
    IN        DRM_DWORD   cTotalLicenses  /*  # of licenses */
    );

/*--------------------------------------------------------------------
** 
** Function :   DRM_LST_Clean
** 
** Synopsis :   Cleanup the license store at szDataStoreName. It 
**              cleans up the license store by removing expired or 
**              unusable licenses, and defragmenting the license data 
**              store
** 
** Arguments :  [pbLicEvalCtxt] - Preinitialized License eval context
**              [pbLicStoreCtxt] - Preinitialized LicStore context
**              [pbBuffer] - Buffer supplied by user
**              [cbBuffer] - Size of pbBuffer
**              [pvCallerData] -- Opaque context data to be funnelled
**                  back to caller during callback. Could be NULL.
**              [dwCallbackInterval] -- % completion after which 
**                  Callback (if any) should be invoked. 
**                  e.g. if dwCallbackInterval = 5, callback will be 
**                  invoked after 5%, 10%, 15%...completion
**              [pfnCallback] -- optional caller supplied callback 
**                  function - can be NULL.

** Returns :    DRM_RESULT
** 
** Notes :      
** 
--------------------------------------------------------------------*/
DRM_RESULT DRM_API DRM_LST_Clean (
    IN       DRM_BYTE                *pbLicEvalCtxt,
    IN       DRM_BYTE                *pbLicStoreCtxt,
    IN       DRM_BYTE                *pbBuffer,
    IN       DRM_DWORD                cbBuffer,
    IN const DRM_VOID                *pvCallerData,
    IN       DRM_DWORD                dwCallbackInterval,
    IN       pfnStoreCleanupProgress  pfnCallback,
    IN       DRM_HDS_CONTEXT         *poHdsContext);



#ifdef __cplusplus
}
#endif

#endif  /* __DRM_LICSTORE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmlicenseparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMLICENSEPARSER_H__
#define __DRMLICENSEPARSER_H__


#ifdef __cplusplus
extern "C" {
#endif

/* Possible drmresults. */
#define LIC_BASECODE                         0x1200
#define LIC_NOERROR                          hrOK
#define LIC_INIT_FAILURE                     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LIC_BASECODE+1)
#define LIC_LICENSE_NOTSET                   MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LIC_BASECODE+2)
#define LIC_PARAM_NOT_OPTIONAL               MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LIC_BASECODE+3)
#define LIC_MEMORY_ALLOCATION_ERROR          MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LIC_BASECODE+4)
#define LIC_INVALID_LICENSE                  MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LIC_BASECODE+5)
#define LIC_FIELD_MISSING                    MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LIC_BASECODE+6)
#define LIC_UNSUPPORTED_VALUE                MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LIC_BASECODE+7)
#define LIC_UNKNOWN_ERROR                    MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LIC_BASECODE+8)
#define LIC_INVALID_REVLIST                  MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LIC_BASECODE+9)
#define LIC_EXPIRED_CERT                     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LIC_BASECODE+10)

typedef enum
{
    DRM_LICENSE_ATTRIB_VERSION        =  1,
    DRM_LICENSE_ATTRIB_KID            =  2,
    DRM_LICENSE_ATTRIB_LID            =  3,
    DRM_LICENSE_ATTRIB_REVOCATION     =  4,
    DRM_LICENSE_ATTRIB_ISSUEDATE      =  5,
    DRM_LICENSE_ATTRIB_CONTENTPUBKEY  =  6,
    DRM_LICENSE_ATTRIB_META_ATTRIBUTE =  7,
    DRM_LICENSE_ATTRIB_OTHER          =  8,
    DRM_LICENSE_ATTRIB_PRIORITY       =  9,
    DRM_LICENSE_ATTRIB_METERING_ID    = 10,
    DRM_LICENSE_ATTRIB_CHAINEDKID     = 11,
    DRM_LICENSE_ATTRIB_REVINFO        = 12,
    DRM_LICENSE_ATTRIB_SOURCEID       = 13
} eDRM_LICENSE_ATTRIBUTES;

DRM_RESULT DRM_API DRM_LIC_GetAttribute(
    IN const DRM_CONST_STRING        *pdstrLicense, 
    IN const DRM_CONST_STRING        *pdstrAttrName,
    IN       eDRM_LICENSE_ATTRIBUTES  eAttribute,
    IN  OUT  DRM_CONST_STRING        *pdstrLIData,
        OUT  DRM_CONST_STRING        *pdstrValue,
    IN       DRM_WCHAR                chXPathSeparator);

DRM_RESULT DRM_API DRM_LIC_GetEvent(
    IN const DRM_CONST_STRING *pdstrLicense, 
    IN const DRM_CONST_STRING *pdstrEvent, 
    IN const DRM_CONST_STRING *pdstrTypeValue, 
    IN  OUT  DRM_CONST_STRING *pdstrLIData,
    OUT      DRM_CONST_STRING *pdstrCondition,     
    OUT      DRM_CONST_STRING *pdstrAction,
    OUT      DRM_CONST_STRING *pdstrRestriction); /* OPTIONAL */


/*--------------------------------------------------------------------
** 
** Function :   DRM_LIC_GetNextActionEvent
** 
** Synopsis :   Gets the next ONACTION event from the license buffer
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
--------------------------------------------------------------------*/
DRM_RESULT DRM_API DRM_LIC_GetNextActionEvent(
    IN OUT      DRM_CONST_STRING *pdstrLicBuffer, 
    OUT         DRM_CONST_STRING *pdstrCondition );

DRM_RESULT DRM_API DRM_LIC_GetEnablingBits(
    IN const DRM_CONST_STRING   *pdstrLicense,
    IN       DRM_DWORD           dwIndex,
    OUT      DRM_DWORD          *pdwAlgorithm,
    OUT      PUBKEY             *pPubKey, 
    OUT      DRM_BYTE           *pbValue, 
    OUT      DRM_DWORD          *pdValueLen, 
    OUT      PUBKEY             *pVerPubKey, 
    OUT      DRM_BYTE           *pbSignature,
    OUT      DRM_BYTE            rgbChainedChecksum[__CB_DECL(CHECKSUM_LENGTH)],
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto);

DRM_RESULT DRM_API DRM_LIC_VerifySignature(
    IN const DRM_CONST_STRING   *pdstrLicense,
    IN       DRM_BB_CONTEXT     *pcontextBBX,
    OUT      DRM_LONG           *plResult);

DRM_RESULT DRM_API DRM_LIC_VerifyCertChain(
    IN const DRM_CONST_STRING    *pdstrLicense, 
    IN       DRM_BOOL             fCheckExpiry,
    IN       DRM_LICEVAL_CONTEXT *pcontextLEVL,
    OUT      DRM_LONG            *plResult);

#if DRM_SUPPORT_CONTENT_REVOCATION

DRM_RESULT DRM_API DRM_LIC_VerifyContentRevocation(
    IN const DRM_CONST_STRING   *pdstrContentRevocation, 
    OUT      DRM_CONST_STRING   *pdstrLSPubKey,
    OUT      DRM_DWORD          *pdwSequenceNumber,
    OUT      DRM_CONST_STRING   *pdstrContentOwnerPubKey,
    OUT      DRM_CONST_STRING   *pdstrCondition,
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto);

DRM_RESULT DRM_API DRM_LIC_GetContentRevocation(
    IN const DRM_CONST_STRING   *pdstrLicense,
    IN       DRM_DWORD           dwSequenceNumber,
    OUT      DRM_DWORD          *pdwSequenceNumber,
    OUT      DRM_CONST_STRING   *pdstrContentRevocation,
    OUT      DRM_CONST_STRING   *pdstrContentOwnerPubKey,
    OUT      DRM_CONST_STRING   *pdstrCondition,
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto);

#endif

#ifdef __cplusplus
}
#endif

#endif /* __DRMLICENSEPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmliceval.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmexpreval.h>
#include <drmliceval.h>
#include <drmheaderparser.h>
#include <drmlicenseparser.h>
#include <drmsecurestore.h>
#include <drmxmlparser.h>
#include <drmlicreason.h>

#if DRM_SUPPORT_CONTENT_REVOCATION

static DRM_BOOL IsLicenseRevoked( 
    DRM_LICEVAL_CONTEXT *pcontextLicenseEval,
    DRM_HDS_CONTEXT     *poHdsContext );

static DRM_RESULT SetOrUpdateContentRevocation( 
    DRM_LICEVAL_CONTEXT *pcontextLicenseEval,
    DRM_HDS_CONTEXT     *poHdsContext);

#endif

static DRM_RESULT Eval(
          DRM_LICEVAL_CONTEXT *pcontextLicenseEval,
          DRM_CONST_STRING    *pdstrLIData,
    const DRM_CONST_STRING    *pdstrEvent, 
    const DRM_CONST_STRING    *pdstrAttrValue,
          DRM_BOOL             fCondition, 
          DRM_BOOL            *pfResult, 
          DRM_BOOL            *pfExisted );


/******************************************************************************
** 
** Function :   _IsCachedEvent
** 
** Synopsis :   Check whether we already have this event cached, and find the 
**              index of the entry in cache, if found
** 
** Arguments :  f_pdstrEvent    - Event string
**              f_pdstrType     - Type string if it is a "ONACTION" event
**              f_rgCachedEvents- Cache of events
**              f_piEvent       - Index of entry in cache. If event is not found 
**                                in cache, this returns -1
** 
** Returns :    TRUE - if event found in cache
**              FALSE- if not
** 
** Notes :      
** 
******************************************************************************/
DRM_BOOL _IsCachedEvent(
    IN  const   DRM_CONST_STRING    *f_pdstrEvent, 
    IN  const   DRM_CONST_STRING    *f_pdstrType,
    IN          DRM_CACHED_EVENT     f_rgCachedEvents[],
    IN          DRM_DWORD            f_cCachedEvents,
        OUT     DRM_LONG            *f_piEvent )
{
    DRM_DWORD   iEvent = 0;
    
    if ( DRM_UTL_DSTRStringsEqual( f_pdstrEvent, &g_dstrLicEvalOnAction) )
    {
        /* We might have already parsed this event  */        
        while ( iEvent < f_cCachedEvents)
        {
            if ( DRM_UTL_DSTRStringsEqual( f_pdstrType, &f_rgCachedEvents[iEvent].dstrType) )
            {
                *f_piEvent = iEvent;
                return TRUE;
            }
            iEvent++;
        }
    } 
    
    *f_piEvent = -1;
    return FALSE;
}

/* Secure store variable accessor/mutator functions.  These will be given to the Expression evaluator via it's context
   structure.  The implementation lives in exprvariable.c */

extern DRM_RESULT DRM_API GlobalSetVariable(
    const DRM_CONST_STRING *pStringToken, 
    const TOKEN            *pNewValue, 
          TOKEN            *pResult, 
          DRM_VOID         *pvOpaqueData);

extern DRM_RESULT DRM_API GlobalGetVariable(
    const DRM_CONST_STRING *pStringToken,
          TOKEN            *pResult,
          DRM_VOID         *pvOpaqueData);

DRM_RESULT DRM_API DRM_LEVL_EvaluateExpression(
    IN       DRM_LICEVAL_CONTEXT *pcontextLicenseEval,
    IN const DRM_CONST_STRING    *pdstrExpression,
    IN       DRM_BOOL            *pfValue)
{
    DRM_RESULT dr = DRM_SUCCESS;
    TOKEN tResult;

    ChkArg( pcontextLicenseEval && pfValue );
    ChkDRMString( pdstrExpression );

    pcontextLicenseEval->contextEXPR.GetVariable  = GlobalGetVariable;
    pcontextLicenseEval->contextEXPR.SetVariable  = GlobalSetVariable;
    pcontextLicenseEval->contextEXPR.pvOpaqueData = pcontextLicenseEval;
    pcontextLicenseEval->contextEXPR.pLicStoreEnumContext = pcontextLicenseEval->pLicStoreEnumContext;
    ChkDR( DRM_EXPR_EvaluateExpression( pdstrExpression, 
                                      &(pcontextLicenseEval->contextEXPR), 
                                       &tResult ) );
    if (tResult.TokenType == TOKEN_LONG)
    {
        *pfValue = ( tResult.val.lValue != 0);
    }

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_LEVL_PerformOperations(
    IN  DRM_LICEVAL_CONTEXT          *pcontextLicenseEval,
    IN  eDRM_LICEVAL_OPERATIONS       eOperation,
    IN  eDRM_LICEVAL_OPERATION_STATE  eOperationState,
    IN  const DRM_CONST_STRING       *pdstrAction,     /* Only required if DRM_LICENSE_EVAL_ACTION is passed as eOperation */
    OUT DRM_BOOL                     *pfPerform,
    OUT DRM_BOOL                     *pfActionExisted,
    IN  DRM_HDS_CONTEXT              *pcontextHDS)
{
    DRM_RESULT          dr          = DRM_SUCCESS;
    DRM_LONG            lResult     = 0;
    DRM_CONST_STRING    dstrAction  = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrLIData  = EMPTY_DRM_STRING;
    DRM_BOOL            fCondition  = TRUE;
    DRM_CONST_STRING    dstrKID     = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_LEVL_PerformOperations", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
                
    ChkArg( pcontextLicenseEval                        != NULL
         && pcontextLicenseEval->pcontextBBX           != NULL /* The other pointers in the context structure *may* not be needed so don't fail just yet for those */
         && pcontextHDS                                != NULL );
    
    switch( eOperationState )
    {
    case DRM_LICENSE_EVAL_CAN_DO_OPERATION:
        fCondition = TRUE;
        break;
    case DRM_LICENSE_EVAL_DONE_WITH_OPERATION:
        fCondition = FALSE;
        break;
    default:
        ChkDR( DRM_E_INVALIDARG );
    }

    if( fCondition && NULL == pfPerform )
    {
        ChkDR( DRM_E_INVALIDARG );
    }

    if( pcontextLicenseEval->dwFlags & 
        ~(  LICEVAL_VERIFY_IGNORE_VERIFICATION
          | LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK
          | LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK
          | LICEVAL_VERIFY_SIGNATURE ) )
    {
        /* Some flag we don't recognize was given. */
        ChkDR( DRM_E_INVALIDARG );
    }

    if( !(pcontextLicenseEval->dwFlags & LICEVAL_VERIFY_SIGNATURE)
     &&  (  pcontextLicenseEval->dwFlags & LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK
         || pcontextLicenseEval->dwFlags & LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK ) )
    {
        /* If you are checking the cert chain you must also check the signature */
        ChkDR( DRM_E_INVALIDARG );
    }

    if( pfPerform )
    {
        *pfPerform = FALSE;
    }

    if (!pcontextLicenseEval->fReserved)
    {
        if ( pcontextLicenseEval->dstrContentLicense.pwszString == NULL )
        {
            ChkDR( LICEVAL_LICENSE_NOT_SUPPLIED );
        }
        
        if( (pcontextLicenseEval->dwFlags & LICEVAL_VERIFY_IGNORE_VERIFICATION) == 0 )
        {
            /*
            **  Some XML optimizations can be done here as well. Ignoring for
            **  now since the XML operations in here are relatively inexpensive.
            */
            ChkDR( DRM_LIC_VerifySignature( &pcontextLicenseEval->dstrContentLicense, 
                                             pcontextLicenseEval->pcontextBBX, 
                                            &lResult) );
            if (lResult == 0)
            {
                ChkDR(LICEVAL_INVALID_LICENSE);
            }
            
#if !DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
            if ( (pcontextLicenseEval->dwFlags & LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK) 
              || (pcontextLicenseEval->dwFlags & LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK) )
            {
                /* During storing, we normally should check expiry of license server certificates. */
                ChkDR( DRM_LIC_VerifyCertChain( &pcontextLicenseEval->dstrContentLicense,
                                                ( pcontextLicenseEval->dwFlags & LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK ) ? TRUE : FALSE,
                                                 pcontextLicenseEval, 
                                                &lResult) );
                if (lResult == 0)
                {
                    ChkDR(LICEVAL_INVALID_LICENSE);
                }
            }
#endif
        }

#if DRM_SUPPORT_CONTENT_REVOCATION
        /* Process content revocation lists if any from this license. */
        dr = SetOrUpdateContentRevocation( pcontextLicenseEval, pcontextHDS );
        if ( DRM_FAILED( dr ) || IsLicenseRevoked( pcontextLicenseEval, pcontextHDS ) )
        {
            /* Treat as failure and revoke this license. */
            /* Set a value in the ExprControl  */
            /* mpExprControl->m_lReasonForUnusable = LR_LICENSE_CONTENT_REVOKED; */
            dr = LICEVAL_LICENSE_REVOKED;        
            goto ErrorExit;
        }
#endif        
        pcontextLicenseEval->fReserved = TRUE; 
    }

    if ( !pcontextLicenseEval->fUseCachedAttribs )
    {
        ChkDR( DRM_LIC_GetAttribute( &(pcontextLicenseEval->dstrContentLicense), NULL, DRM_LICENSE_ATTRIB_LID, &dstrLIData, &dstrAction, 0 ) );
        ChkDR( DRM_UTL_StringToGuid( &dstrAction, (DRM_GUID*)pcontextLicenseEval->LID.rgb ) );
        ChkDR( DRM_LIC_GetAttribute( &(pcontextLicenseEval->dstrContentLicense), NULL, DRM_LICENSE_ATTRIB_KID, &dstrLIData, &dstrKID, 0 ) );
        ChkDR( DRM_UTL_DecodeKID( &dstrKID, &pcontextLicenseEval->KID ) );        
    }
    ZEROMEM( &(pcontextLicenseEval->PMExpiryDate), SIZEOF( pcontextLicenseEval->PMExpiryDate ) );
    pcontextLicenseEval->PMExpiryDate.wYear  = 9999; /* unlimited expiry */
    pcontextLicenseEval->PMExpiryDate.wMonth = 12;
    pcontextLicenseEval->PMExpiryDate.wDay   = 31;
    pcontextLicenseEval->lPMRights           = 0;

#if DRM_SUPPORT_PMLICENSE
    pcontextLicenseEval->pwszPMLicVersion = &g_dstrPMLicenseVersionString;
#else
    pcontextLicenseEval->pwszPMLicVersion = NULL;
#endif

    /* Actually can do action stuff here.  */
    switch(eOperation)
    {
        case DRM_LICENSE_EVAL_SELECT:
        {
            if( eOperationState == DRM_LICENSE_EVAL_CAN_DO_OPERATION )
            {
                /* Fetch KID, ISSUEDATE, and CONTENTPUBKEY from the license. */
                DRM_CONST_STRING dstrHeaderKID = EMPTY_DRM_STRING;                

#if DRM_SUPPORT_CONTENT_REVOCATION
                if (pcontextLicenseEval->dstrContentHeader.pwszString!=NULL && 
                    pcontextLicenseEval->dstrContentHeader.cchString>0 &&
                    pcontextLicenseEval->dwChainDepth == 0)
                {
                    dr = DRM_HDR_GetAttribute( &(pcontextLicenseEval->dstrContentHeader), NULL, DRM_HEADER_ATTRIB_KID, &dstrHeaderKID, 0 );
                    if (dr == DRM_SUCCESS)
                    {
                        /* Match KID only if it can be retrieved from header. Thus, any license can be selected for an empty content header */
                        /* as long as the condition allows. If the condition refers to content data, then it will fail. */
                        /* Compare the KID */
                        
                        if ( !pcontextLicenseEval->fUseCachedAttribs )
                        {
                            if ( !DRM_UTL_DSTRStringsEqual( &dstrKID, &dstrHeaderKID ) )
                            {
                                dr = LICEVAL_KID_MISMATCH;
                                goto ErrorExit;
                            }
                        
                            (void)DRM_LIC_GetAttribute( &(pcontextLicenseEval->dstrContentLicense), 
                                                        NULL, 
                                                        DRM_LICENSE_ATTRIB_CONTENTPUBKEY, 
                                                        &dstrLIData, 
                                                        &pcontextLicenseEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY], 
                                                        0 );
                        }
                        else
                        {
                            if ( !DRM_UTL_DSTRStringsEqual( &pcontextLicenseEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_KID], 
                                                            &dstrHeaderKID ) )
                            {
                                dr = LICEVAL_KID_MISMATCH;
                                goto ErrorExit;
                            }                            
                        }

                        if ( pcontextLicenseEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY].cchString != 0 )
                        {
                            ChkDR( DRM_HDR_Verify( &(pcontextLicenseEval->dstrContentHeader), 
                                                   &(pcontextLicenseEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY]), 
                                                   &pcontextLicenseEval->pcontextBBX->CryptoContext, 
                                                   &lResult ) );                        
                            if (lResult == 0)
                            {
                                dr = LICEVAL_CONTENT_SIGNATURE_FAILURE;
                                goto ErrorExit;
                            }
                        }
                    }
                }
#endif                
            }

            dstrAction.cchString  = g_dstrLicEvalOnSelect.cchString;
            dstrAction.pwszString = g_dstrLicEvalOnSelect.pwszString;
        }
            break;
        case DRM_LICENSE_EVAL_DELETE:
                dstrAction.cchString  = g_dstrLicEvalOnDelete.cchString;
                dstrAction.pwszString = g_dstrLicEvalOnDelete.pwszString;
            break;
        case DRM_LICENSE_EVAL_STORE:
            fCondition = FALSE;
            dstrAction.cchString  = g_dstrLicEvalOnStore.cchString;
            dstrAction.pwszString = g_dstrLicEvalOnStore.pwszString;
            break;
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK             
        case DRM_LICENSE_EVAL_REPORTCLOCK_ROLLBACK:
            if (fCondition)
            {
                ChkDR(DRM_E_INVALIDARG);
            }
            ASSIGN_DRM_STRING(dstrAction, g_dstrLicEvalOnClockRollback);
            break;
#endif
        case DRM_LICENSE_EVAL_ACTION:
            {
                ChkArg(pdstrAction != NULL);
                dstrAction.cchString  = g_dstrLicEvalOnAction.cchString;
                dstrAction.pwszString = g_dstrLicEvalOnAction.pwszString;
            }
            break;
        default: 
            ChkDR(DRM_E_INVALIDARG); 
    }

    pcontextLicenseEval->contextEXPR.GetVariable  = GlobalGetVariable;
    pcontextLicenseEval->contextEXPR.SetVariable  = GlobalSetVariable;
    pcontextLicenseEval->contextEXPR.pvOpaqueData = pcontextLicenseEval;
    pcontextLicenseEval->contextEXPR.pLicStoreEnumContext = pcontextLicenseEval->pLicStoreEnumContext;
    MEMCPY(&pcontextLicenseEval->contextEXPR.KID, &pcontextLicenseEval->KID, SIZEOF(DRM_KID));
    MEMCPY(&pcontextLicenseEval->contextEXPR.LID, &pcontextLicenseEval->LID, SIZEOF(DRM_LID));

    dr = Eval( pcontextLicenseEval, 
               &dstrLIData, 
               &dstrAction, 
               pdstrAction, 
               fCondition, 
               pfPerform, 
               pfActionExisted );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_LEVL_PerformOperations", g_pwszLeavingFunction);
                
    return dr;
}


/*--------------------------------------------------------------------
** 
** Function :   DRM_LEVL_IsLicenseReadyForDeletion
** 
** Synopsis :   Checks if this license has expired 
** 
** Arguments :  [pcontextLicenseEval] - License eval context
**              [pfDelete] - Pointer to bool which is set to true if 
**                  this license can be deleted
** 
** Returns :    
** 
** Notes :      TODO:   For now this function is mostly a CUT&PASTE
**              job from DRM_LEVL_PerformOperations, with a lot of 
**              duplicate code. The common sections should be factored
**              out into a separate subroutine
** 
--------------------------------------------------------------------*/
DRM_RESULT DRM_API DRM_LEVL_IsLicenseReadyForDeletion( 
    DRM_LICEVAL_CONTEXT *pcontextLicenseEval,
    DRM_BOOL            *pfDelete 
    )
{
    DRM_RESULT          dr         = DRM_SUCCESS;
    DRM_CONST_STRING    dstrBuffer = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrLIData = EMPTY_DRM_STRING;
    DRM_BOOL            fResult    = FALSE;

    /*  The other pointers in the context structure *may* not be 
        needed so don't fail just yet for those */
    ChkArg(  pcontextLicenseEval              != NULL
          && pfDelete                         != NULL    
          && pcontextLicenseEval->pcontextBBX != NULL );

    /*  Clear output */
    *pfDelete = FALSE;

    ChkDR( DRM_LIC_GetAttribute( &(pcontextLicenseEval->dstrContentLicense), 
                                 NULL, 
                                 DRM_LICENSE_ATTRIB_LID, 
                                 &dstrLIData,
                                 &dstrBuffer, 
                                 0 ) );
    ChkDR(DRM_UTL_StringToGuid( &dstrBuffer, (DRM_GUID*)pcontextLicenseEval->LID.rgb ) );
    ChkDR(DRM_LIC_GetAttribute( &pcontextLicenseEval->dstrContentLicense, 
                                NULL, 
                                DRM_LICENSE_ATTRIB_KID, 
                                &dstrLIData,
                                &dstrBuffer, 
                                0 ) );
    ChkDR( DRM_UTL_DecodeKID( &dstrBuffer, &pcontextLicenseEval->KID ) );

#if DRM_SUPPORT_PMLICENSE
    pcontextLicenseEval->pwszPMLicVersion = &g_dstrPMLicenseVersionString;
#else
    pcontextLicenseEval->pwszPMLicVersion = NULL;
#endif

    MEMCPY(
        &pcontextLicenseEval->contextEXPR.KID, 
        &pcontextLicenseEval->KID, 
        SIZEOF(DRM_KID)
        );
    MEMCPY(
        &pcontextLicenseEval->contextEXPR.LID, 
        &pcontextLicenseEval->LID, 
        SIZEOF(DRM_LID)
        ); 
    /*  Is license selectable   */
    ChkDR(DRM_LEVL_PerformOperations( 
            pcontextLicenseEval, 
            DRM_LICENSE_EVAL_SELECT, 
            DRM_LICENSE_EVAL_CAN_DO_OPERATION, 
            NULL, 
            &fResult, 
            NULL, 
            pcontextLicenseEval->pcontextHDS));        
    if( !fResult && pcontextLicenseEval->lReasonForFail == LR_LICENSE_EXPIRED )
    {
        /* License cannot be selected because it is expired */
        *pfDelete = TRUE;
    }

ErrorExit:
    return ( dr );
}

#if DRM_SUPPORT_CONTENT_REVOCATION

static DRM_RESULT GetContentRevocationInStore(
    IN const DRM_LICEVAL_CONTEXT *pcontextLEVL,
    IN const DRM_CONST_STRING    *pdstrContentOwnerPubKey,
       OUT   DRM_CONST_STRING    *pdstrContentRevocation,
    IN       DRM_HDS_CONTEXT     *pcontextHDS )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD    cbBuffer = 0;
    DRM_LID      lid = { 0 };
    SHA_CONTEXT  contextSHA;
    DRM_BYTE     rgbPassword[__CB_DECL(SHA_DIGEST_LEN)];


    ChkArg( pcontextLEVL != NULL
         && pcontextHDS  != NULL 
         && pdstrContentRevocation != NULL );

    ChkDRMString( pdstrContentOwnerPubKey );
    
    DRM_SHA_Init     (&contextSHA);
    DRM_SHA_Update   (PB_DSTR (pdstrContentOwnerPubKey), 
                      CB_DSTR (pdstrContentOwnerPubKey), 
                     &contextSHA);
    DRM_SHA_Finalize (&contextSHA, lid.rgb);

    ChkDR( DRM_SST_CreateLicenseStatePassword( &lid, rgbPassword, (DRM_BYTE*)pcontextLEVL->pcontextBBX ) );

    cbBuffer = pcontextLEVL->cbRevocationBuffer;

    ChkDR( DRM_SST_GetData( pcontextLEVL->pcontextSSTRevocation, 
                           &lid, 
                            NULL,
                            rgbPassword,
                            SECURE_STORE_REVOCATION_DATA,
                            pcontextHDS, 
                            pcontextLEVL->pbRevocationBuffer, 
                           &cbBuffer));

    DSTR_FROM_PB(pdstrContentRevocation, pcontextLEVL->pbRevocationBuffer, cbBuffer);
        
    dr = DRM_SUCCESS;
ErrorExit:
    return(dr);
}

static DRM_RESULT SetContentRevocationInStore(
    IN const DRM_LICEVAL_CONTEXT *pcontextLEVL,
    IN const DRM_CONST_STRING    *pdstrContentOwnerPubKey, 
    IN const DRM_CONST_STRING    *pdstrContentRevocation,
    IN       DRM_HDS_CONTEXT     *pcontextHDS )
{
    DRM_RESULT   dr  = DRM_SUCCESS;    
    DRM_LID      lid = { 0 };
    SHA_CONTEXT  contextSHA;
    DRM_BYTE     rgbPassword [__CB_DECL(SHA_DIGEST_LEN)];
            
    ChkArg( pcontextLEVL != NULL
         && pcontextHDS  != NULL );
    ChkDRMString( pdstrContentOwnerPubKey );
    ChkDRMString( pdstrContentRevocation  );
   
    DRM_SHA_Init     (&contextSHA);
    DRM_SHA_Update   (PB_DSTR (pdstrContentOwnerPubKey), 
                      CB_DSTR (pdstrContentOwnerPubKey), 
                     &contextSHA);
    DRM_SHA_Finalize (&contextSHA, lid.rgb);

    ChkDR( DRM_SST_CreateLicenseStatePassword( &lid, rgbPassword, (DRM_BYTE*)pcontextLEVL->pcontextBBX ) );

    ChkDR( DRM_SST_SetData (pcontextLEVL->pcontextSSTRevocation, 
                           &lid, 
                            NULL,
                            rgbPassword,
                            SECURE_STORE_REVOCATION_DATA,
                            pcontextHDS, 
                            PB_DSTR(pdstrContentRevocation),
                            CB_DSTR(pdstrContentRevocation)));
    
    dr = DRM_SUCCESS;
ErrorExit:
    if( DRM_FAILED( dr ) )
    {
        dr = LICEVAL_UPDATE_FAILURE;
    }
    return ( dr );
}

static DRM_RESULT SetOrUpdateContentRevocation( 
    DRM_LICEVAL_CONTEXT *pcontextLicenseEval,
    DRM_HDS_CONTEXT     *poHdsContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrContentRev                = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrContentOwnerPubkey        = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSecStateContentRevocation = EMPTY_DRM_STRING;
    DRM_DWORD dwLicSequenceNumber = 0;
    DRM_DWORD dwSecStateSequenceNumber = 0;
    DRM_DWORD dwIndex = 0;


    /* Retrieve content revocation from the license one by one and process. */
    while( DRM_SUCCESS == dr )
    {        
        dr = DRM_LIC_GetContentRevocation( &(pcontextLicenseEval->dstrContentLicense),
                                            dwIndex,
                                           &dwLicSequenceNumber,
                                           &dstrContentRev,
                                           &dstrContentOwnerPubkey,
                                            NULL,
                                           &pcontextLicenseEval->pcontextBBX->CryptoContext );
        if ( DRM_SUCCESS == dr )
        {
            if( DRM_SUCCESS != GetContentRevocationInStore(pcontextLicenseEval, &dstrContentOwnerPubkey, &dstrSecStateContentRevocation, poHdsContext ) 
             || DRM_SUCCESS != DRM_LIC_VerifyContentRevocation( &dstrSecStateContentRevocation, 
                                                                 NULL, 
                                                                &dwSecStateSequenceNumber, 
                                                                 NULL, 
                                                                 NULL, 
                                                                &pcontextLicenseEval->pcontextBBX->CryptoContext)
             || dwSecStateSequenceNumber < dwLicSequenceNumber )
            {
                /* The one in secure state seems older. Write the new one */
                dr = SetContentRevocationInStore(pcontextLicenseEval, &dstrContentOwnerPubkey, &dstrContentRev, poHdsContext );
            }
        }
        dwIndex++;
    }

    return ( dr );
}

static DRM_BOOL IsLicenseRevoked(
    DRM_LICEVAL_CONTEXT *pcontextLicenseEval,
    DRM_HDS_CONTEXT     *poHdsContext )
{
    DRM_RESULT dr                                   = DRM_SUCCESS;    
    DRM_CONST_STRING dstrContentPubKey              = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSecStateContentRevocation  = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrCondition                  = EMPTY_DRM_STRING;
    DRM_BOOL         fResult                        = FALSE;    
    
    /* Check if the license has public key. If not, it cannot be revoked. */
    dr = DRM_LIC_GetAttribute( &(pcontextLicenseEval->dstrContentLicense), 
                               NULL, 
                               DRM_LICENSE_ATTRIB_CONTENTPUBKEY,
                               NULL,
                               &dstrContentPubKey, 0); /* optional. Don't check for errors. */
    if ( dr == DRM_SUCCESS && dstrContentPubKey.pwszString )
    {
        /* License contains content owner public key. Retrieve content revocation section for this public key, if any. */
        dr = GetContentRevocationInStore(pcontextLicenseEval, &dstrContentPubKey, &dstrSecStateContentRevocation, poHdsContext);
        if (dr == DRM_SUCCESS)
        {
            dr = DRM_LIC_VerifyContentRevocation( &dstrSecStateContentRevocation, 
                                                   NULL, 
                                                   NULL, 
                                                   NULL, 
                                                  &dstrCondition, 
                                                  &pcontextLicenseEval->pcontextBBX->CryptoContext);
            if (dr == DRM_SUCCESS)
            {
                /* It look like a good one. Evaluate the condition to determine if it allows the use of license. */
                if ( NULL == dstrCondition.pwszString || 0 == dstrCondition.cchString )
                {
                    goto ErrorExit; /* missing condition is treated as the one that allows use of license. */
                }

                /* DRM_LEVL_EvaluateExpression will return FALSE if the expression evaluates correctly and the license is revoked
                ** So we can set fResult to TRUE intialy and then invert it (if fResult is TRUE on the way out of DRM_LEVL_EvaluateExpression
                ** then the license IS NOT revoked.  If it is false then the license IS revoked
                */
                fResult = TRUE;
                ChkDR( DRM_LEVL_EvaluateExpression( pcontextLicenseEval, &dstrCondition, &fResult ) );
                fResult = !fResult;
            }
        }
    }

ErrorExit:
    return fResult;
}

#endif

static DRM_RESULT Eval(
          DRM_LICEVAL_CONTEXT *pcontextLicenseEval,
          DRM_CONST_STRING    *pdstrLIData,
    const DRM_CONST_STRING    *pdstrEvent, 
    const DRM_CONST_STRING    *pdstrAttrValue,
          DRM_BOOL             fCondition, 
          DRM_BOOL            *pfResult, 
          DRM_BOOL            *pfExisted)
{
    DRM_RESULT          dr          = DRM_SUCCESS; 
    DRM_LONG            iEvents     = 0;
    DRM_CONST_STRING    dstrExpr    = EMPTY_DRM_STRING;
    TOKEN               tResult;    
    
    ChkArg( pdstrEvent && ( !fCondition || pfResult ) );

    /* Set the default value for missing event or condition */
    if ( DRM_UTL_DSTRStringsEqual( pdstrEvent, &g_dstrLicEvalOnAction ) )
    {
        *pfResult = FALSE;   /* An action is missing => that right is not allowed. */
    }
    else
    {
        *pfResult = TRUE;    /* For other events, the default is to assume true. */
    }

    if (   pcontextLicenseEval->fUseCachedAttribs
        && _IsCachedEvent( pdstrEvent, 
                           pdstrAttrValue, 
                           pcontextLicenseEval->rgCachedEvents, 
                           pcontextLicenseEval->cCachedEvents,
                           &iEvents ) )
    {
        if (fCondition)
        {
            ASSIGN_DRM_STRING( dstrExpr, pcontextLicenseEval->rgCachedEvents[iEvents].dstrCondition );
        }
        else
        {
            ASSIGN_DRM_STRING( dstrExpr, pcontextLicenseEval->rgCachedEvents[iEvents].dstrAction );
        } 
        if ( dstrExpr.cchString == 0 )
        {
            dr = DRM_E_XMLNOTFOUND;
        }
    }
    else
    {
        if (fCondition)
        {
            dr = DRM_LIC_GetEvent(&(pcontextLicenseEval->dstrContentLicense), pdstrEvent, pdstrAttrValue, pdstrLIData, &dstrExpr, NULL, NULL);
        }
        else
        {
            dr = DRM_LIC_GetEvent(&(pcontextLicenseEval->dstrContentLicense), pdstrEvent, pdstrAttrValue, pdstrLIData, NULL, &dstrExpr, NULL);
        }
    }
    if( DRM_FAILED( dr ) )
    {
        dr = DRM_SUCCESS;
        if( pfExisted )
        {
            *pfExisted = FALSE;
        }
        goto ErrorExit;
    }
    
    if ( dstrExpr.cchString == 0)
    {
        if (pfResult)
        {
            *pfResult = TRUE; /* A missing CONDITION or missing expression in CONDITION. */
        }
        if( pfExisted )
        {
            *pfExisted = FALSE;
        }
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }    
    
    if( pfExisted )
    {
        *pfExisted = TRUE;
    }

    dr = DRM_EXPR_EvaluateExpression( &dstrExpr, &pcontextLicenseEval->contextEXPR, &tResult );

    if( !fCondition )
    {
        /* It's an action.  Eat the errors */
        dr = DRM_SUCCESS;
        if( pfResult )
        {
            *pfResult = TRUE;
        }
    }
    else
    {
        ChkDR( dr );
        /* It's a condition */
        if( tResult.TokenType == TOKEN_LONG )
        {
            if( pfResult != NULL )
            {
                *pfResult = ( tResult.val.lValue != 0);
            }
        }
    }

ErrorExit:
    return ( dr );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmmetercertprivkey.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMMETER_CERT_PRIV_KEY_H__
#define __DRMMETER_CERT_PRIV_KEY_H__

#ifdef __cplusplus
extern "C" {
#endif

PRIVKEY g_privkeyMeterCert = 
{
//    TWO_ZEROES, TWO_ZEROES, TWO_ZEROES, TWO_ZEROES, TWO_ZEROES, 
//    TWO_ZEROES, TWO_ZEROES, TWO_ZEROES, TWO_ZEROES, TWO_ZEROES
	0xB6, 0x18, 0xCA, 0x39, 0xCF, 0xD6, 0x09, 0x8E, 
	0xCC, 0x1A, 0x43, 0xA6, 0x25, 0xD4, 0xFF, 0xC0, 
	0xE4, 0x52, 0x23, 0x5E
};

#ifdef __cplusplus
}
#endif

#endif /* __DRMMETER_CERT_PRIV_KEY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmmd5.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcrt.h>
#include <drmmd5.h>

static const DRM_DWORD MD5_cons[64] =
/* Round 1 */
 {0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,

/* Round 2 */
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,

/* Round 3 */
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,

/* Round 4 */
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};

static const DRM_DWORD magic_md5 = 0x2035444DUL;
                          /* "MD5 " in ASCII */


/*
** Update the MD5 hash from a fresh 64 bytes of data.
*/

static DRM_VOID _MD5_block( IN OUT DRM_MD5_CTX *f_contextMD5)
{
    DRM_DWORD a = f_contextMD5->partial_hash[0];
    DRM_DWORD b = f_contextMD5->partial_hash[1]; 
    DRM_DWORD c = f_contextMD5->partial_hash[2];
    DRM_DWORD d = f_contextMD5->partial_hash[3];
    DRM_DWORD msg16[32];   /* Two copies of message */
    const DRM_DWORD *cons = MD5_cons;
    DRM_INT i;

    for (i = 0; i != 16; i++) 
    {
        /*
        ** Copy to local array, zero original
        ** Make two copies, to simplify indexing
        */
        msg16[i] = msg16[i+16] = f_contextMD5->awaiting_data[i];
        f_contextMD5->awaiting_data[i] = 0;
    }


    /* Round 1 */
    for (i = -16; i != 0; i += 4) 
    {      
        /*
        ** Rewrite (X & Y) | (~X & Z)  as  Z ^ (X & (Y ^ Z))
        ** [Easily validated by checking X = 0 and X = 1 cases.]
        ** This avoids ANDNOT (which X86 lacks) and needs only 
        ** one temporary register.
        ** On register-rich architectures, the Y ^ Z computation
        ** can start early, before X is computed.
        */

        a += msg16[i+16] + cons[0] + (d ^ (b & (c ^ d)));
        a = b + ROTATE_LEFT(a, 7);

        d += msg16[i+17] + cons[1] + (c ^ (a & (b ^ c)));
        d = a + ROTATE_LEFT(d, 12);

        c += msg16[i+18] + cons[2] + (b ^ (d & (a ^ b)));
        c = d + ROTATE_LEFT(c, 17);

        b += msg16[i+19] + cons[3] + (a ^ (c & (d ^ a)));
        b = c + ROTATE_LEFT(b, 22);

        cons += 4;
    }

    /* Round 2 */
    for (i = -16; i != 0; i += 4) 
    {
        /* Rewrite (Z & X) | (~Z & Y)  as  Y ^ (Z & (X ^ Y)) */
        a += msg16[i+17] + cons[0] + (c ^ (d & (b ^ c)));
        a = b + ROTATE_LEFT(a, 5);

        d += msg16[i+22] + cons[1] + (b ^ (c & (a ^ b)));
        d = a + ROTATE_LEFT(d, 9);

        c += msg16[i+27] + cons[2] + (a ^ (b & (d ^ a))); 
        c = d + ROTATE_LEFT(c, 14);

        b += msg16[i+16] + cons[3] + (d ^ (a & (c ^ d)));
        b = c + ROTATE_LEFT(b, 20);

        cons += 4;
    }

    /* Round 3 */
    for (i = 16; i != 0; i -= 4) 
    { 
        a += msg16[i+5]  + cons[0] + ((b ^ c) ^ d);
        a = b + ROTATE_LEFT(a, 4);
        
        d += msg16[i+8]  + cons[1] + (a ^ (b ^ c));
        d = a + ROTATE_LEFT(d, 11);
        
        c += msg16[i+11] + cons[2] + ((d ^ a) ^ b);
        c = d + ROTATE_LEFT(c, 16);

        b += msg16[i+14] + cons[3] + (c ^ (d ^ a));
        b = c + ROTATE_LEFT(b, 23);

        cons += 4;
    }

    /* Round 4 */
    for (i = 16; i != 0; i -= 4) 
    {
        a += msg16[i  ]  + cons[0] + (c ^ (~d | b));
        a = b + ROTATE_LEFT(a, 6);

        d += msg16[i+7]  + cons[1] + (b ^ (~c | a));
        d = a + ROTATE_LEFT(d, 10);

        c += msg16[i+14] + cons[2] + (a ^ (~b | d));
        c = d + ROTATE_LEFT(c, 15);

        b += msg16[i+5]  + cons[3] + (d ^ (~a | c));
        b = c + ROTATE_LEFT(b, 21);

        cons += 4;
    }

    f_contextMD5->partial_hash[0] += a;
    f_contextMD5->partial_hash[1] += b;
    f_contextMD5->partial_hash[2] += c;
    f_contextMD5->partial_hash[3] += d;
} /* end _MD5_block */


DRM_VOID DRM_API DRM_MD5_Init( IN OUT DRM_MD5_CTX *f_contextMD5)
{
    DRM_DWORD i;

    f_contextMD5->nbit_total[0] = f_contextMD5->nbit_total[1] = 0;
    for (i = 0; i != 16; i++) 
    {
        f_contextMD5->awaiting_data[i] = 0;
    }
   
     /* 
     **  Initialize hash variables.
     **    
     **  The initial values in RFC 1321 appear
     **  in byte-reversed order.  Bruce Schneier's 
     **  2nd edition neglects to rearrange them.
     */

    f_contextMD5->partial_hash[0] = 0x67452301;
    f_contextMD5->partial_hash[1] = 0xefcdab89;
    f_contextMD5->partial_hash[2] = ~f_contextMD5->partial_hash[0];
    f_contextMD5->partial_hash[3] = ~f_contextMD5->partial_hash[1];
}


/*
**  Append data to a partially hashed MD5 message.
*/
DRM_VOID DRM_API DRM_MD5_Update(
    IN OUT   DRM_MD5_CTX *f_contextMD5,
    IN const DRM_BYTE     f_rgbData[],
    IN       DRM_DWORD    f_cbData )
{
    const DRM_BYTE *rgbData  = f_rgbData;
    DRM_DWORD cbData         = f_cbData;
    DRM_DWORD iData          = 0;
    DRM_DWORD nbit_occupied  = f_contextMD5->nbit_total[0] & 511;
    DRM_DWORD *awaiting_data = NULL;
    DRM_DWORD nbitnew_low    = 8 * f_cbData;

    f_contextMD5->nbit_total[0] += nbitnew_low;
    f_contextMD5->nbit_total[1] += (DRM_DWORD)(f_cbData >> 29) 
                                 + (f_contextMD5->nbit_total[0] < nbitnew_low);

    /* Advance to word boundary in waiting_data */
    
    if ((nbit_occupied & 31) != 0) 
    {        
        awaiting_data = f_contextMD5->awaiting_data + nbit_occupied/32;

        while ((nbit_occupied & 31) != 0 && cbData != 0) 
        {
            *awaiting_data |= (DRM_DWORD)GET_BYTE(rgbData, iData) << (nbit_occupied & 31);
            iData++;
            cbData--;
            nbit_occupied += 8;
        }
    }

    /* Transfer 4 bytes at a time */
    do 
    {
        DRM_DWORD nword_occupied = nbit_occupied/32;
        DRM_DWORD nwcopy         = min(cbData/4, 16 - nword_occupied);

        awaiting_data  = f_contextMD5->awaiting_data 
                       + nword_occupied;
        cbData        -=  4 * nwcopy;
        nbit_occupied += 32 * nwcopy;

        while (nwcopy != 0) 
        {
            DRM_BYTE rgbDWORD[__CB_DECL( 4 )];
            
            PUT_BYTE( rgbDWORD, 0, GET_BYTE( rgbData, iData++ ) );
            PUT_BYTE( rgbDWORD, 1, GET_BYTE( rgbData, iData++ ) );
            PUT_BYTE( rgbDWORD, 2, GET_BYTE( rgbData, iData++ ) );
            PUT_BYTE( rgbDWORD, 3, GET_BYTE( rgbData, iData++ ) );

            BYTES_TO_DWORD( *awaiting_data, rgbDWORD );
            awaiting_data++;            
            nwcopy--;
        } 

        if (nbit_occupied == 512) 
        {
            _MD5_block( f_contextMD5 );
            nbit_occupied  = 0;
            awaiting_data -= 16;
        }
    } while (cbData >= 4); 

    while (cbData != 0) 
    {        
        DRM_DWORD new_byte = (DRM_DWORD)GET_BYTE( rgbData, iData++ );

        *awaiting_data |= new_byte << (nbit_occupied & 31);
        nbit_occupied  += 8;
        cbData--;
    }
}



/*
** Finish an MD5 hash.
*/
DRM_VOID DRM_API DRM_MD5_Final( IN OUT DRM_MD5_CTX *f_contextMD5)
{
    DRM_DWORD nbit0 = f_contextMD5->nbit_total[0];
    DRM_DWORD nbit1 = f_contextMD5->nbit_total[1];
    DRM_DWORD nbit_occupied = nbit0 & 511;
    DRM_DWORD i;

    f_contextMD5->awaiting_data[nbit_occupied/32] |= (DRM_DWORD)0x80 << (nbit_occupied & 31);
                          /* Append a 1 bit */
    nbit_occupied += 8;

    /*
    ** Append zero bits until length (in bits) is 448 mod 512.
    ** Then append the length, in bits.
    ** Here we assume the buffer was zeroed earlier.
    */

    if (nbit_occupied > 448)
    {   /* If fewer than 64 bits left */
        _MD5_block( f_contextMD5 );
        nbit_occupied = 0;
    }

    f_contextMD5->awaiting_data[14] = nbit0;
    f_contextMD5->awaiting_data[15] = nbit1;
    
    _MD5_block(f_contextMD5);

    /* Copy final digest to byte array */

    for (i = 0; i != 4; i++) 
    {
        DRM_BYTE rgbDWORD[__CB_DECL( 4 )];
        
        DWORD_TO_BYTES( rgbDWORD, f_contextMD5->partial_hash[i] );
        DRM_BYT_CopyBytes( f_contextMD5->digest, 4 * i, rgbDWORD, 0, 4 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmmanager.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcontextsizes.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmmanager.h>
#include <drmblackbox.h>
#include <drmpkcrypto.h>
#include <drmheaderparser.h>
#include <drmlicenseparser.h>
#include <drmlicacq.h>
#include <drmcipher.h>
#include <drmviewprops.h>
#include <drmchain.h>
#include <drmsecureclock.h>
#include <drmsyncstore.h>
#include <drmsecurestore.h>
#include <drmlicreason.h>
#include <oemimpl.h>
#include <drmxmlparser.h>
#include <drmopcodes.h>
#if DRM_SUPPORT_REVOCATION 
#include <drmrevocation.h>
#endif

#if DRM_SUPPORT_DATASTORE_PREALLOC == 1
#define DATASTORE_INITSIZE      512     /* prealloc 512 K for initial datastore size */
#define DATASTORE_GROWSIZE      512     /* grow 512 K for each datastore expansion */
#endif



DRM_VOID drmmanager_casserts (DRM_VOID)
{
    
    /* If any of these compile time asserts fire it is because size of internal contexts don't match */
    DRMSIZEASSERT (SIZEOF (DRM_MANAGER_DECRYPT_CONTEXT),  SIZEOF (DRM_CIPHER_CONTEXT));
    DRMSIZEASSERT (SIZEOF (DRM_MANAGER_ENCRYPT_CONTEXT),  SIZEOF (DRM_CIPHER_CONTEXT));    
    DRMSIZEASSERT (SIZEOF (DRM_MANAGER_CONTEXT),          SIZEOF (DRM_MANAGER_CONTEXT_INTERNAL));

    /* If any of these compile time asserts fire it is because buffers aren't aligned as they should and could cause data type misalignment errors */
#if !SIXTEEN_BIT_ADDRESSING
    DRMCASSERT    ((DRM_OFFSET_OF (DRM_MANAGER_CONTEXT_INTERNAL, rgbDRMHeaderData) % SIZEOF (DRM_WCHAR)) == 0);
    DRMCASSERT    ((DRM_OFFSET_OF (DRM_MANAGER_CONTEXT_INTERNAL, rgbDRMLicense)    % SIZEOF (DRM_WCHAR)) == 0);        

    /* If any of these compile time asserts fire it is because buffers in the DRM manager context have been moved
       and we rely on them being adjacent. */
    DRMCASSERT( ENSURE_MEMBERS_ADJACENT(DRM_MANAGER_CONTEXT_INTERNAL, rgbDRMHeaderData, rgbDRMLicense) );    
#endif
    
}

static DRM_VOID _FreeDrmManagerInternalContexts( DRM_MANAGER_CONTEXT_INTERNAL *pContext )
{
    if( pContext )
    {
        if( pContext->fLicStoreOpen )
        {
            DRM_LST_Close( &pContext->oLicStoreContext ); 
            pContext->fLicStoreOpen = FALSE; 
        }
        if( pContext->fSecStoreGlobalContextOpen ) 
        { 
            DRM_SST_CloseKey( &pContext->oSecStoreGlobalContext, &( pContext->oHdsContext )  ); 
            pContext->fSecStoreGlobalContextOpen = FALSE; 
        } 
    }
}    

static DRM_WORD      _dwDeviceStoreBlockSize  =32*1024;
static DRM_HDSBLKNUM _eDeviceStoreBlockNumType=eDRM_HDSBLKNUM_DWORD;

/* 
** Create the Deivce store
*/
static DRM_RESULT DRM_API _CreateDeviceStore( 
    const DRM_WCHAR       *pwszDeviceStoreName, 
          DRM_HDS_CONTEXT *poHdsContext )
{
    DRM_RESULT dr=DRM_SUCCESS;

#if DRM_SUPPORT_DATASTORE_PREALLOC == 1
    dr = DRM_HDS_CreateStore2(pwszDeviceStoreName, 
                              _dwDeviceStoreBlockSize, 
                              _eDeviceStoreBlockNumType, 
                              poHdsContext, 
                              TRUE,
                              DATASTORE_INITSIZE);
#else
    dr = DRM_HDS_CreateStore(pwszDeviceStoreName, 
                             _dwDeviceStoreBlockSize, 
                             _eDeviceStoreBlockNumType, 
                             poHdsContext, 
                             TRUE);
#endif

    if ( dr ==  DRM_E_FILEWRITEERROR)
    {
        /*
        **  Some other process created the store concurrently. We can consider
        **  this operation as successful as store has been created. In the worst
        **  subsequent call to Open store will fail
        */
        dr = DRM_SUCCESS;
    }
    ChkDR(dr);

ErrorExit:
    if( DRM_FAILED( dr ) )
    {
        TRACE(("_CreateDeviceStore(): Device store '%S' cannot be created.\n", 
            pwszDeviceStoreName));
    }
    return dr;
}

static DRM_RESULT _SetupLicEvalObjectToShare( 
    DRM_MANAGER_CONTEXT_INTERNAL *pContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE bBBVer[__CB_DECL(VERSION_LEN)];


    ZEROMEM(&(pContext->oLicEvalContext), SIZEOF( DRM_LICEVAL_CONTEXT ) );
    MEMCPY(bBBVer, 
           pContext->oBlackBoxContext.cachedCertValues.m_BBCompatibilityCert.pk.version, 
           VERSION_LEN);
    ChkDR(DRM_UTL_GetVersionAsString(bBBVer, pContext->wszBBVerString));

    pContext->oLicEvalContext.dstrBBVer.pwszString =        pContext->wszBBVerString;
    pContext->oLicEvalContext.dstrBBVer.cchString  = wcslen(pContext->wszBBVerString);
    pContext->oLicEvalContext.dstrDRMVer           = g_dstrDRM_VERSION_STRING;
    INIT_DRM_STRING( pContext->oLicEvalContext.dstrContentHeader );

    if (pContext->eHeaderInContext==eHeaderIsV2)
    {    
        DRM_CONST_STRING dstrKID = EMPTY_DRM_STRING;
        
        DSTR_FROM_PB( &pContext->oLicEvalContext.dstrContentHeader, 
                       pContext->rgbDRMHeaderData,
                       pContext->cbHeaderData );

        ChkDR( DRM_HDR_GetAttribute( &(pContext->oLicEvalContext.dstrContentHeader), 
                                     NULL, 
                                     DRM_HEADER_ATTRIB_KID, 
                                     &dstrKID, 
                                     0 ) );

        ChkDR( DRM_UTL_DecodeKID( &dstrKID, &pContext->KID ) );
    }
    else if (pContext->eHeaderInContext==eHeaderIsV1)
    {
        DRM_WCHAR wszKID[CCH_BASE64_EQUIV(SIZEOF(DRM_KID))] = { 0 };
        DRM_CONST_STRING dstrKID   = EMPTY_DRM_STRING;
        DRM_SUBSTRING    dasstrKID = { 0 };
        DRM_V1Header    *pV1Header = (DRM_V1Header*)pContext->rgbDRMHeaderData;

        /* make sure the size of encoded KID is no more than CCH_BASE64_EQUIV(SIZEOF(DRM_KID)) */
        dasstrKID.m_ich = 0;
        dasstrKID.m_cch = ( pV1Header->cbKeyID <= CCH_BASE64_EQUIV(SIZEOF(DRM_KID)) )? 
                            pV1Header->cbKeyID : 
                            CCH_BASE64_EQUIV(SIZEOF(DRM_KID));
        
        dstrKID.cchString = CCH_BASE64_EQUIV(SIZEOF(DRM_KID));
        dstrKID.pwszString = wszKID;
        
        DRM_UTL_PromoteANSItoUNICODE((DRM_CHAR*)(pV1Header->pbKeyID), &dasstrKID, (DRM_STRING*)&dstrKID);

        ChkDR( DRM_UTL_DecodeKID( &dstrKID, &pContext->KID ) );
    }
    else if (pContext->eHeaderInContext==eKidOnly)
    {
        DRM_CONST_STRING dstrKID   = EMPTY_DRM_STRING;
        DSTR_FROM_PB( &dstrKID, 
                       pContext->rgbDRMHeaderData,
                       pContext->cbHeaderData );
        
        ChkDR( DRM_UTL_DecodeKID( &dstrKID, &pContext->KID ) );
    }
    else
    {
        /* no content header is given */
        ZEROMEM(pContext->KID.rgb, SIZEOF( pContext->KID.rgb ) );
    }
    
    ChkDR( DRM_LST_Open(&pContext->oLicStoreContext, &( pContext->oHdsContext ) ) );
    pContext->fLicStoreOpen = TRUE;

    /* Result is first SHA_DIGEST_LEN bytes of rgbDRMLicense */
    ChkDR(DRM_SST_CreateGlobalStorePassword(pContext->rgbDRMLicense, 
                                            (DRM_BYTE *) &pContext->oBlackBoxContext)); 

    /* Open the global key */
    ChkDR( DRM_SST_OpenKeyTokens( &pContext->oSecStoreGlobalContext, 
                        (DRM_ID *)&g_rgbSecStoreGlobalName, 
                                   NULL,
                                   pContext->rgbDRMLicense, 
                                   DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS,
                                   SECURE_STORE_GLOBAL_DATA, 
                                  &pContext->oHdsContext ) );
    pContext->fSecStoreGlobalContextOpen = TRUE;
    
    pContext->oLicEvalContext.dwFlags     = LICEVAL_OPEN_CHECK_SETTINGS;    
    pContext->oLicEvalContext.pcontextBBX = &pContext->oBlackBoxContext;

    if (pContext->eHeaderInContext==eHeaderIsV2)
    {
        DSTR_FROM_PB( &pContext->oLicEvalContext.dstrContentHeader,
                       pContext->rgbDRMHeaderData,
                       pContext->cbHeaderData );
    }
    else
    {
        /* either V1 header or no header is given */
        INIT_DRM_STRING( pContext->oLicEvalContext.dstrContentHeader );
    }

#if DRM_SUPPORT_REVOCATION
    pContext->oLicEvalContext.fUpdatedRevocationList    =  FALSE;
    pContext->oLicEvalContext.idCRLsCurrent             =  pContext->idCRLsCurrent;
#endif
    pContext->oLicEvalContext.pbRevocationBuffer        =  pContext->pbRevocationBuffer;
    pContext->oLicEvalContext.cbRevocationBuffer        =  pContext->cbRevocationBuffer;
    pContext->oLicEvalContext.pcontextHDS               = &pContext->oHdsContext;
    pContext->oLicEvalContext.pcontextSSTGlobal         = &pContext->oSecStoreGlobalContext;
    pContext->oLicEvalContext.pcontextSSTLicense        = &pContext->rgcontextSST[0];
#if DRM_SUPPORT_CERTIFICATE_CACHING
    pContext->oLicEvalContext.pcontextSSTRevocation     = &pContext->contextSSTCertCache;
#else
    pContext->oLicEvalContext.pcontextSSTRevocation     =  NULL;
#endif    
    pContext->oLicEvalContext.fGlobalSecStoreWritable   =  FALSE;
    pContext->oLicEvalContext.fAppInfoValid             =  TRUE;
    pContext->oLicEvalContext.certinfoApp.appSec        =  pContext->oBlackBoxContext.cachedCertValues.appSec;
    pContext->oLicEvalContext.certinfoApp.appcd_subject =  pContext->oBlackBoxContext.cachedCertValues.appcd_subject;
    pContext->oLicEvalContext.certinfoSDK.appSec        =  3000;
    pContext->oLicEvalContext.certinfoSDK.appcd_subject =  0;
    pContext->oLicEvalContext.pLicStoreEnumContext      = &(pContext->oLicEnum [0]);

ErrorExit:
    return dr;
}

#if DRM_SUPPORT_DLA
static DRM_RESULT _PrepareForClientInfo( 
    DRM_MANAGER_CONTEXT_INTERNAL *pContext )
{
    DRM_RESULT       dr          = DRM_SUCCESS;
    DRM_CONST_STRING dstrValue   = EMPTY_DRM_STRING;
    
    /* Get the device certificate */
    DSTR_FROM_PB( &pContext->licensechallenge.dstrDeviceCert, pContext->rgbDRMLicense, SIZEOF( pContext->rgbDRMLicense ) );
    
    ChkDR( DRM_DDC_GetDeviceCertificate(
            (DRM_STRING*)&pContext->licensechallenge.dstrDeviceCert, 
            0,
            &pContext->oBlackBoxContext.CryptoContext) );

    /* Get the security level */
    ChkDR (DRM_DCP_GetAttribute (&pContext->licensechallenge.dstrDeviceCert,
                                 DRM_DEVCERT_GROUPSECURITYLEVEL, 
                                 NULL,
                                 &dstrValue));

    ChkDR (wcsntol( dstrValue.pwszString, 
                    dstrValue.cchString, 
      (DRM_LONG *) &pContext->licensechallenge.levelAppSecurity));

    /* Get the subject id */

    ChkDR (DRM_DCP_GetAttribute (&pContext->licensechallenge.dstrDeviceCert, 
                                 DRM_DEVCERT_SUBJECTID, 
                                 NULL, 
                                 &dstrValue));

    ChkDR (wcsntol( dstrValue.pwszString, 
                    dstrValue.cchString, 
      (DRM_LONG *) &pContext->licensechallenge.idSubject));

    ChkDR( DRM_BBX_GetClientId(&pContext->licensechallenge.clientid, &pContext->oBlackBoxContext));

    pContext->licensechallenge.pwszBBVer    =  pContext->oBlackBoxContext.cachedCertValues.wszLegacyVersion;
    pContext->licensechallenge.pcontextBBX  = &pContext->oBlackBoxContext;
ErrorExit:
    return ( dr );

}
#endif  /* DRM_SUPPORT_DLA */


#if DRM_SUPPORT_SECURE_CLOCK
static DRM_RESULT _CheckSecureClock( DRM_MANAGER_CONTEXT_INTERNAL *pContext );
#endif

static DRM_RESULT _MapDRMError(
    DRM_RESULT dr)
{
    return dr;
}

static DRM_RESULT _CompareMachineId( 
    DRM_CONST_STRING *pdstrMachineId )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    DRM_WCHAR        wchUniqueId[MAX_UNIQUEID_LEN];
    DRM_CONST_STRING dstrID = EMPTY_DRM_STRING;

    ChkDRMString( pdstrMachineId );
    
    dstrID.cchString  = NO_OF( wchUniqueId );
    dstrID.pwszString =        wchUniqueId;
    
    ChkDR( OEM_GetUniqueID( wchUniqueId, &dstrID.cchString ) );    
    ChkBOOL( DRM_UTL_DSTRStringsEqual( pdstrMachineId, &dstrID ), DRM_E_MACHINEIDMISMATCH );

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_MGR_Initialize( 
    IN       DRM_MANAGER_CONTEXT  *pDrmContext,
    IN const DRM_CONST_STRING     *pdstrDeviceStoreName )
{
    DRM_RESULT       dr                    = DRM_SUCCESS;
    DRM_LONG         lValue                = 0;
    DRM_CONST_STRING dstrValue             = EMPTY_DRM_STRING;    
    DRM_STRING       dstrDeviceCert        = EMPTY_DRM_STRING;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_Initialize", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);

    ChkArg(pDrmContext);
    ChkDRMString(pdstrDeviceStoreName);
    ZEROMEM(pDrmContext, SIZEOF (DRM_MANAGER_CONTEXT));

    pContext->fStoreOpened = FALSE;

    /* Copy Device Store file name in DRM Manager Context */
    if(pdstrDeviceStoreName->cchString > DRM_MAX_PATH)
    {
        ChkDR( DRM_E_INVALIDARG );
    }

    DSTR_FROM_PB( &dstrDeviceCert, pContext->rgbDRMLicense, SIZEOF( pContext->rgbDRMLicense ) );
    
    ChkDR( DRM_DDC_GetDeviceCertificate( 
            &dstrDeviceCert, 
            DRM_DCP_CREATE_DEVCERT_IF_NOT_EXISTING | DRM_DCP_VERIFY_DEVCERT,
            &pContext->oBlackBoxContext.CryptoContext) );

    ChkDR( DRM_DCP_LoadPropertiesCache(
            (DRM_CONST_STRING*)&dstrDeviceCert,
            &pContext->oBlackBoxContext.cachedCertValues,
            &pContext->oBlackBoxContext.CryptoContext));
    
    /* Compare UniqueID */
    ChkDR( DRM_DCP_GetAttribute(
            (DRM_CONST_STRING*)&dstrDeviceCert, 
            DRM_DEVCERT_SERIALNUMBER, 
            NULL,
            &dstrValue) );

    ChkDR( _CompareMachineId( &dstrValue ) );

    ChkDR( DRM_BBX_Initialize( &pContext->oBlackBoxContext ) );

    pContext->eHeaderInContext = eHeaderNotSet;

    wcsncpy( (DRM_WCHAR*)pContext->rgbDRMLicense, 
             pdstrDeviceStoreName->pwszString, 
             pdstrDeviceStoreName->cchString );

    
    ((DRM_WCHAR*)pContext->rgbDRMLicense)[pdstrDeviceStoreName->cchString] = g_wchNull;

    /* Initialize device store. Open if not yet opened. Create if not yet created. */
    ChkDR( DRM_HDS_Init( &( pContext->oHdsContext ) ) );

#if DRM_SUPPORT_DATASTORE_PREALLOC == 1
    dr = DRM_HDS_OpenStore2(((DRM_WCHAR*)pContext->rgbDRMLicense), 
                            &( pContext->oHdsContext ),
                            DATASTORE_GROWSIZE);
#else
    dr = DRM_HDS_OpenStore(((DRM_WCHAR*)pContext->rgbDRMLicense), 
                           &( pContext->oHdsContext ));
#endif
    
    if ( dr == DRM_E_FILENOTFOUND )   /* store does not exist */
    {
        ChkDR(_CreateDeviceStore(((DRM_WCHAR*)pContext->rgbDRMLicense), &( pContext->oHdsContext ) ) );
        
#if DRM_SUPPORT_DATASTORE_PREALLOC == 1
        dr = DRM_HDS_OpenStore2(((DRM_WCHAR*)pContext->rgbDRMLicense), 
                                &( pContext->oHdsContext ),
                                DATASTORE_GROWSIZE);
#else
        dr = DRM_HDS_OpenStore(((DRM_WCHAR*)pContext->rgbDRMLicense), 
                               &( pContext->oHdsContext ));
#endif
    }
    ChkDR(dr);

    pContext->fStoreOpened = TRUE;

    ChkDR(_SetupLicEvalObjectToShare( pContext ));

    /* Explicitly make the global secure store writeabele */
    pContext->oLicEvalContext.fGlobalSecStoreWritable = TRUE;

#if DRM_SUPPORT_SECURE_CLOCK
    if ( pContext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_SECURE_CLOCK )
    {
        ChkDR( _CheckSecureClock( pContext ) );
    }
#endif

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
    if ( pContext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_ANTI_ROLLBACK_CLOCK )
    {
        ChkDR(DRM_LIC_CheckClockRollback(
                &pContext->oLicEvalContext,
                &pContext->oLicStoreContext,
                &pContext->oLicEnum[0],
                pContext->rgbDRMHeaderData + __CB_DECL(pContext->cbHeaderData),
                SIZEOF( pContext->rgbDRMHeaderData ) - pContext->cbHeaderData + SIZEOF(pContext->rgbDRMLicense),
                &( pContext->oHdsContext ) ) );
    }
#endif

#if DRM_SUPPORT_LICENSE_SYNC
    ChkDR( DRM_SNC_OpenStore( &pContext->oHdsContext, &pContext->contextSync ) );
#endif

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_Initialize", g_pwszLeavingFunction);

    _FreeDrmManagerInternalContexts( pContext );

    if( DRM_FAILED( dr )
        && pContext != NULL )
    {
        DRM_MGR_Uninitialize( pDrmContext );
    }
        
    return ( dr );
}


DRM_VOID DRM_API DRM_MGR_Uninitialize( 
    IN DRM_MANAGER_CONTEXT *pDrmContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;
    DRM_RESULT dr2 = DRM_SUCCESS;
    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_Uninitialize", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    ChkArg( pDrmContext );

    if (pContext->fBindThenCommit)
    {
        pContext->fBindThenCommit = FALSE;
    }

#if DRM_SUPPORT_LICENSE_SYNC
    (void)DRM_SNC_CloseStore(&pContext->contextSync);
#endif

    if ( pContext->fStoreOpened )
    {
        (void)DRM_HDS_CloseStore( &( pContext->oHdsContext ) );
    }
    (void)DRM_HDS_Uninit( &pContext->oHdsContext );
    ZEROMEM(&( pContext->oHdsContext ), SIZEOF( pContext->oHdsContext ) );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_Uninitialize", g_pwszLeavingFunction);
    DRM_PRO_StopProfiling();
    return ;    
}

DRM_RESULT DRM_API DRM_MGR_Reinitialize( 
    IN       DRM_MANAGER_CONTEXT  *pDrmContext )
{
    DRM_RESULT                    dr        = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext  = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;

    ChkArg( pDrmContext != NULL );

    pContext->eHeaderInContext = eHeaderNotSet;
    ZEROMEM( pContext->rgbDRMHeaderData, SIZEOF( pContext->rgbDRMHeaderData ) );
    pContext->cbHeaderData = 0;

ErrorExit:
    return dr;
}

#if DRM_SUPPORT_REVOCATION
DRM_RESULT DRM_API DRM_MGR_SetRevocationBuffer( 
    IN       DRM_MANAGER_CONTEXT  *pDrmContext,
    IN       DRM_BYTE             *pbRevocationBuffer,
    IN       DRM_DWORD             cbRevocationBuffer )
{
    DRM_RESULT       dr                    = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;

    ChkArg( pDrmContext != NULL );

    pContext->pbRevocationBuffer = pbRevocationBuffer;
    pContext->cbRevocationBuffer = cbRevocationBuffer;
    pContext->oLicEvalContext.pbRevocationBuffer = pbRevocationBuffer;
    pContext->oLicEvalContext.cbRevocationBuffer = cbRevocationBuffer;


ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_MGR_GetRevocationBuffer( 
    IN       DRM_MANAGER_CONTEXT  *pDrmContext,
    OUT      DRM_BYTE             **ppbRevocationBuffer,
    OUT      DRM_DWORD             *pcbRevocationBuffer )
{
    DRM_RESULT       dr                    = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;

    ChkArg( pDrmContext != NULL
        && ppbRevocationBuffer != NULL 
        && pcbRevocationBuffer != NULL );

    *ppbRevocationBuffer = pContext->pbRevocationBuffer;
    *pcbRevocationBuffer = pContext->cbRevocationBuffer;

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_MGR_UpdateRevocationVersionsCache( 
 IN OUT DRM_MANAGER_CONTEXT          *pDrmContext,
    OUT DRM_BOOL                     *pfUpdated)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL *)pDrmContext;

    ChkArg( pDrmContext != NULL );
    
    /* Result is first SHA_DIGEST_LEN bytes of rgbDRMLicense */
    ChkDR(DRM_SST_CreateGlobalStorePassword(pContext->rgbDRMLicense, 
                                            (DRM_BYTE *) &pContext->oBlackBoxContext)); 

    /* Open the global key */
    ChkDR( DRM_SST_OpenKeyTokens( &pContext->oSecStoreGlobalContext, 
                        (DRM_ID *)&g_rgbSecStoreGlobalName, 
                                   NULL,
                                   pContext->rgbDRMLicense, 
                                   DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS,
                                   SECURE_STORE_GLOBAL_DATA, 
                                  &pContext->oHdsContext ) );
    pContext->fSecStoreGlobalContextOpen = TRUE;

    ChkDR( DRM_RVK_UpdateRevocationVersionsCache( pContext, 
                                                    pfUpdated ) );

ErrorExit:

    _FreeDrmManagerInternalContexts( pContext );
    
    return dr;
}
#endif

DRM_RESULT DRM_API DRM_MGR_SetV2Header(
    IN       DRM_MANAGER_CONTEXT *pDrmContext,
    IN const DRM_BYTE            *pbHeader,
    IN       DRM_DWORD            cbHeader )
{
    DRM_RESULT                    dr        = DRM_SUCCESS;
    DRM_DWORD                     cchHeader = 0;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext  = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;

    ChkArg (pDrmContext                    != NULL
         && pbHeader                       != NULL 
         && cbHeader                        > 0 
         && (cbHeader % SIZEOF (DRM_WCHAR) == 0)); /* cbHeader must be even */

    if (pContext->fBindThenCommit)
    {
        pContext->fBindThenCommit = FALSE;
    }

    if( cbHeader > SIZEOF( pContext->rgbDRMHeaderData ) )
    {
        dr = DRM_E_INVALIDARG;  /* The header is too big for our buffer. */
        goto ErrorExit;
    }
    
    MEMCPY(pContext->rgbDRMHeaderData, pbHeader, cbHeader);
    pContext->cbHeaderData = cbHeader;
    cchHeader              = cbHeader / SIZEOF (DRM_WCHAR);
    
    if (((DRM_WCHAR*) (pContext->rgbDRMHeaderData)) [cchHeader - 1] == g_wchNull)
    {
        /* Strip off the NULL terminating character if it is there */
        pContext->cbHeaderData -= SIZEOF (DRM_WCHAR);
    }

    pContext->eHeaderInContext = eHeaderIsV2;

ErrorExit:
    return _MapDRMError(dr);
}

DRM_RESULT DRM_API DRM_MGR_SetV1Header(
    IN       DRM_MANAGER_CONTEXT *pDrmContext,
    IN const DRM_BYTE            *pbKeyID,
    IN       DRM_DWORD            cbKeyID,
    IN const DRM_BYTE            *pbSecretData,
    IN       DRM_DWORD            cbSecretData,
    IN const DRM_BYTE            *pbURL,
    IN       DRM_DWORD            cbURL)
{
    DRM_RESULT                    dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;
    DRM_V1Header                 *pV1Header = NULL;
    DRM_DWORD                     dwEncKidSize=0;

    ChkArg(pDrmContext);

    if (pContext->fBindThenCommit)
    {
        pContext->fBindThenCommit = FALSE;
    }

    if ( pContext->eHeaderInContext == eHeaderIsV2 )
    {
        goto ErrorExit; /* ignore this call if we already have a V2 header */
    }
    ChkArg( pbKeyID      != NULL && cbKeyID      > 0 );
    ChkArg( pbSecretData != NULL && cbSecretData > 0 );
    ChkArg( pbURL        != NULL && cbURL        > 0 );
    ChkArg( cbURL + cbKeyID + cbSecretData + SIZEOF(DRM_V1Header) <= SIZEOF(pContext->rgbDRMHeaderData) );

    pV1Header = (DRM_V1Header*)pContext->rgbDRMHeaderData;

    pV1Header->cbKeyID = 4 * (cbKeyID / 4);  /* KeyID length must be mutilple of 4 bytes. */
    pV1Header->pbKeyID = pV1Header->bBuffer;
    MEMCPY(pV1Header->pbKeyID, pbKeyID, cbKeyID);

    pV1Header->cbSecretData = cbSecretData;
    /* For 16-bit addressing the key ID must lie on a word boundary */
    DRMASSERT( cbKeyID % CB_NATIVE_BYTE == 0 );
    pV1Header->pbSecretData = &(pV1Header->bBuffer[ __CB_DECL(cbKeyID) ]);
    MEMCPY(pV1Header->pbSecretData, pbSecretData, cbSecretData);

    pV1Header->cbURL = cbURL;
    /* For 16-bit addressing the URL must lie on a word boundary */
    DRMASSERT( ( cbKeyID + cbSecretData ) % CB_NATIVE_BYTE == 0 );
    pV1Header->pbURL = &(pV1Header->bBuffer[ __CB_DECL(cbKeyID + cbSecretData) ]);
    MEMCPY(pV1Header->pbURL, pbURL, cbURL);

    pContext->cbHeaderData     = cbURL + cbKeyID + cbSecretData + SIZEOF(DRM_V1Header);
    pContext->eHeaderInContext = eHeaderIsV1;

ErrorExit:
    return _MapDRMError(dr);
}

#if DRM_SUPPORT_DLA

static DRM_RESULT _GetUplinkState( 
    IN const DRM_CONST_STRING        *f_pdstrAction,
    IN       DRM_DWORD                f_iKID,
    IN OUT   DRM_LICENSE_CHALLENGE   *f_plicensechallenge,
    IN       DRM_VIEW_RIGHTS_CONTEXT *f_pcontextVR,
    IN       DRM_HDS_CONTEXT         *f_pcontextHDS )
{
    DRM_RESULT dr = DRM_SUCCESS;
    const DRM_CONST_STRING *rgpdstrRights [1] = { NULL };

    rgpdstrRights [0] = f_pdstrAction;       

    ChkDR( DRM_UTL_DecodeKID( &f_plicensechallenge->rgdstrUplinkKID [f_iKID], 
                              &f_pcontextVR->KID ) );
            
    ChkDR( DRM_ASD_GetLicenseAggregateData( rgpdstrRights, 
                                           &f_plicensechallenge->rglicensestatedata[f_iKID], 
                                            1, 
                                            f_pcontextVR, 
                                            f_pcontextHDS,
                                            FALSE ) );
ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_MGR_GenerateLicenseChallenge(
    IN       DRM_MANAGER_CONTEXT  *pDrmContext,
    IN const DRM_CONST_STRING    **ppdstrRights, /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD             cRights,
       OUT   DRM_WCHAR            *pwszURL,
    IN OUT   DRM_DWORD            *pcchURL,
       OUT   DRM_CHAR             *pszChallenge,
    IN OUT   DRM_DWORD            *pcchChallenge )
{
    DRM_MANAGER_CONTEXT_INTERNAL *pcontextMGR       = (DRM_MANAGER_CONTEXT_INTERNAL *) pDrmContext;
    DRM_CONST_STRING              dstrLAINFO        = EMPTY_DRM_STRING;
    DRM_CONST_STRING              dstrdevcert       = EMPTY_DRM_STRING;
    DRM_DWORD  cbKID      = 0;
    DRM_DWORD  cbChallenge= 0;
    DRM_DWORD  cbRequired = 0;
    DRM_BOOL   fTooSmall  = FALSE;
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_BOOL   fInit      = FALSE;           

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_GenerateLicenseChallenge", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);

    ChkArg (pDrmContext   != NULL
        &&  pcchChallenge != NULL);

    ChkArg ((cRights  > 0 && ppdstrRights != NULL)
        ||  (cRights == 0 && ppdstrRights == NULL));

    if (pcontextMGR->fBindThenCommit)
    {
        pcontextMGR->fBindThenCommit = FALSE;
    }

    if (pcontextMGR->eHeaderInContext == eHeaderIsV1)
    {
        ChkDR (DRM_E_V1_NOT_SUPPORTED);  /* V1 Lic Acq not supported */
    }
    ZEROMEM(&(pcontextMGR->licensechallenge), SIZEOF (DRM_LICENSE_CHALLENGE));

    if (pcontextMGR->eHeaderInContext == eHeaderIsV2)
    {

        DSTR_FROM_PB( &pcontextMGR->licensechallenge.dstrHeader,
                       pcontextMGR->rgbDRMHeaderData,
                       pcontextMGR->cbHeaderData );

        dr = DRM_HDR_GetAttribute ( &pcontextMGR->licensechallenge.dstrHeader, 
                                     NULL, 
                                     DRM_HEADER_ATTRIB_LAINFO, 
                                    &dstrLAINFO, 
                                     0);
        if (DRM_FAILED(dr))
        {
            /*Make sure this string is empty*/
            dr = DRM_SUCCESS;
            dstrLAINFO.cchString = 0;
            dstrLAINFO.pwszString = NULL;            
        }

        pcontextMGR->oViewRightsContext.pBBContext       = &pcontextMGR->oBlackBoxContext;
        pcontextMGR->oViewRightsContext.pLicQueryContext =  pcontextMGR->oLicEnum;
        pcontextMGR->oViewRightsContext.pbGlobalSecStore = &pcontextMGR->oSecStoreGlobalContext;
        pcontextMGR->oViewRightsContext.pbLIDSecStore    = &pcontextMGR->rgcontextSST[0];
        pcontextMGR->oViewRightsContext.pbLicenseStore   = &pcontextMGR->oLicStoreContext;
        pcontextMGR->oViewRightsContext.pLicEval         = &pcontextMGR->oLicEvalContext;
        pcontextMGR->oViewRightsContext.pbBuffer         =  pcontextMGR->rgbDRMHeaderData 
                                                         +  __CB_DECL(pcontextMGR->cbHeaderData);
        pcontextMGR->oViewRightsContext.cbBuffer         =  SIZEOF (pcontextMGR->rgbDRMHeaderData) 
                                                         -          pcontextMGR->cbHeaderData 
                                                         +  SIZEOF (pcontextMGR->rgbDRMLicense);

        /* Start at index 1.  If we actaully find an uplink index 0 will hold the data for the KID of the header itself */
        pcontextMGR->licensechallenge.cUplinks = 1;
        while (DRM_SUCCEEDED (DRM_HDR_GetUplink( &pcontextMGR->licensechallenge.dstrHeader,
                                                  pcontextMGR->licensechallenge.cUplinks - 1,
                                                 &pcontextMGR->licensechallenge.rgdstrUplinkKID [pcontextMGR->licensechallenge.cUplinks])))
        {
            if (!fInit)
            {
                ChkDR( _SetupLicEvalObjectToShare( pcontextMGR ) );
                fInit = TRUE; 
            }

            ChkDR( _GetUplinkState( ppdstrRights[0],
                                    pcontextMGR->licensechallenge.cUplinks,
                                   &pcontextMGR->licensechallenge,
                                   &pcontextMGR->oViewRightsContext,
                                   &pcontextMGR->oHdsContext) );
            
            if( ++pcontextMGR->licensechallenge.cUplinks >= NO_OF (pcontextMGR->licensechallenge.rgdstrUplinkKID) )
            {
                break;
            }
        }
        if( fInit )
        {
            /*
            ** fInit is TRUE if we processed an UPLINK so we know they are there.
            ** Now add ASD for the KID in the header
            */
            ChkDR( DRM_HDR_GetAttribute( &pcontextMGR->licensechallenge.dstrHeader,
                                          NULL,
                                          DRM_HEADER_ATTRIB_KID,
                                         &pcontextMGR->licensechallenge.rgdstrUplinkKID[0],
                                          0 ) );
            ChkDR( _GetUplinkState( ppdstrRights[0],
                                    0,
                                   &pcontextMGR->licensechallenge,
                                   &pcontextMGR->oViewRightsContext,
                                   &pcontextMGR->oHdsContext) );
        }
        else
        {
            pcontextMGR->licensechallenge.cUplinks = 0;
        }
    }
    /*Check for the URL. If user asked for it and we dont have it, return an error*/    
    if (dstrLAINFO.cchString == 0 && pcchURL != NULL)
    {
        ChkDR(DRM_E_NO_URL);
    }

    /*
    ** It will prepare context for Client info node. 
    ** Devcert will loaded into the license buffer.
    */
    ChkDR( _PrepareForClientInfo( pcontextMGR ) );

    pcontextMGR->licensechallenge.ppdstrRights = ppdstrRights;
    pcontextMGR->licensechallenge.cRights      = cRights;

    /* request data now complete and cached in plicensechallenge; query for the required sizes */ 
    dr = DRM_LA_CreateChallenge(
            &pcontextMGR->licensechallenge,
            NULL, 
            &cbChallenge);

    if (dr != DRM_E_BUFFERTOOSMALL)
    {
        ChkDR (dr);
        
        dr = DRM_SUCCESS;
    }
    
    cbRequired = cbChallenge;
    if (pszChallenge == NULL
    || *pcchChallenge < (cbRequired + SIZEOF (DRM_CHAR)))
    {
        fTooSmall = TRUE;
    }
    
    if (pcchURL != NULL   
    && *pcchURL <  dstrLAINFO.cchString + SIZEOF (DRM_CHAR))
    {
        fTooSmall = TRUE;
    }
    
    if (pcchURL != NULL   
    &&  pwszURL == NULL)
    {
        fTooSmall = TRUE;
    }

    /* if any of the above conditionals evaluate TRUE,
       return the required size(s) */
    
    if (fTooSmall != FALSE)
    {
        if (pcchURL != NULL)
        {
            *pcchURL = dstrLAINFO.cchString + SIZEOF(DRM_CHAR);
        }

        *pcchChallenge = cbRequired + SIZEOF(DRM_CHAR);
        
        ChkDR (DRM_E_BUFFERTOOSMALL);
    }

    /* challenge buffer holds ANSI chars, no need to align it */
    ChkDR (DRM_LA_CreateChallenge (&pcontextMGR->licensechallenge,
                                    pszChallenge,
                                   &cbChallenge));

    if (pwszURL != NULL)
    {
        /*
        **  The buffer in pwszURL is the same size as the encoded URL.
        **  Hence no need to check for DRM_E_BUFFERTOOSMALL
        */
        ChkDR( DRM_UTL_XMLDecode( dstrLAINFO.pwszString, 
                                  dstrLAINFO.cchString, 
                                  pwszURL,
                                  pcchURL ) );
                    
        pwszURL[ *pcchURL ] = g_wchNull;
        *pcchURL = *pcchURL  + 1;        
    }

    *pcchChallenge = cbChallenge;    
    
    PUT_CHAR(pszChallenge, *pcchChallenge, '\0');

ErrorExit:
    _FreeDrmManagerInternalContexts (pcontextMGR);
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_GenerateLicenseChallenge", g_pwszLeavingFunction);

    return dr;
}

/******************************************************************************
** 
** Function :   DRM_MGR_GetDeviceProperty
** 
** Synopsis :   Gets the device property.
** 
** Arguments :  f_pDrmContext           - pointer to DRM_MANAGER_CONTEXT
**              f_eProperty             - property type
**              f_pbProperties          - Output buffer for property
**              f_pcbProperties         - Size of output buffer; If this is too 
**                                        small, it is updated with the required
**                                        size.
** 
** Returns :    DRM_E_BUFFERTOOSMALL - output buffer too small
**              other errors

** Notes :      WM_DRM_CLIENTINFO is UNICODE blob which is NOT NULL terminated
**              WM_DRM_DRMVERSION is UNICODE blob which is NOT NULL terminated
**              WM_DRM_SECURITYVERSION is UNICODE blob which is NOT NULL terminated
**              WM_DRM_V2_HEADER_KID is base64 encoded KID UNICODE blob which is NOT NULL terminated
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetDeviceProperty(
    IN       DRM_MANAGER_CONTEXT  *f_pDrmContext,
    IN       DRM_DEVICE_PROPERTY   f_eProperty, 
       OUT   DRM_BYTE             *f_pbProperty,
    IN OUT   DRM_DWORD            *f_pcbProperty )
{
    DRM_MANAGER_CONTEXT_INTERNAL *pcontextMGR       = (DRM_MANAGER_CONTEXT_INTERNAL *) f_pDrmContext;
    DRM_RESULT       dr             = DRM_SUCCESS;
    DRM_DWORD        cchEncoded     = 0; 
    DRM_CONST_STRING dstrScratch    = EMPTY_DRM_STRING;    
    DRM_DWORD        cbMinRequired  = 0;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_GetDeviceProperty", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);

    ChkArg (f_pDrmContext != NULL
        &&  f_pcbProperty != NULL);

    if (pcontextMGR->fBindThenCommit)
    {
        pcontextMGR->fBindThenCommit = FALSE;
    }

    switch(f_eProperty)
    {
        case WM_DRM_CLIENTINFO:
        {
            ZEROMEM(&(pcontextMGR->licensechallenge), SIZEOF (DRM_LICENSE_CHALLENGE));

            cchEncoded = SIZEOF(pcontextMGR->licensechallenge.rgbStack);
            
            /*It will prepare context for Client info node.*/
            ChkDR( _PrepareForClientInfo( pcontextMGR ) );
            dstrScratch.pwszString =         pcontextMGR->licensechallenge.pwszBBVer;
            dstrScratch.cchString  = wcslen (pcontextMGR->licensechallenge.pwszBBVer);

            dr = DRM_LA_GetClientInfo(
                    &pcontextMGR->licensechallenge.clientid,
                    pcontextMGR->licensechallenge.rgbStack,
                    &cchEncoded,
                    (DRM_CONST_STRING *)  &g_dstrReqTagClientVersionData,
                    &dstrScratch,
                    pcontextMGR->licensechallenge.levelAppSecurity,
                    pcontextMGR->licensechallenge.idSubject,
                    0,
                    NULL,
                    &pcontextMGR->licensechallenge.dstrDeviceCert,
                    NULL,
                    &cbMinRequired,
                    &pcontextMGR->oBlackBoxContext.CryptoContext,
                    TRUE);
            
            if (dr != DRM_E_BUFFERTOOSMALL)
            {
                ChkDR (dr);
                
                dr = DRM_SUCCESS;
            }
            if ( f_pbProperty == NULL 
            ||  *f_pcbProperty < cbMinRequired )
            {
                *f_pcbProperty = cbMinRequired;
                ChkDR(DRM_E_BUFFERTOOSMALL);
            }

            ChkDR( DRM_LA_GetClientInfo(
                    &pcontextMGR->licensechallenge.clientid,
                    pcontextMGR->licensechallenge.rgbStack,
                    &cchEncoded,
                    (DRM_CONST_STRING *)  &g_dstrReqTagClientVersionData,
                    &dstrScratch,
                    pcontextMGR->licensechallenge.levelAppSecurity,
                    pcontextMGR->licensechallenge.idSubject,
                    0,
                    NULL,
                    &pcontextMGR->licensechallenge.dstrDeviceCert,
                    f_pbProperty,
                    f_pcbProperty,
                    &pcontextMGR->oBlackBoxContext.CryptoContext,
                    TRUE));
        }
        break;
        case WM_DRM_DRMVERSION:
        {
            cbMinRequired = CB_DSTR(&g_dstrReqTagClientVersionData);

            if ( f_pbProperty == NULL 
            ||  *f_pcbProperty < cbMinRequired )
            {
                *f_pcbProperty = cbMinRequired;
                ChkDR(DRM_E_BUFFERTOOSMALL);
            }
            MEMCPY(f_pbProperty, PB_DSTR(&g_dstrReqTagClientVersionData), cbMinRequired );
            *f_pcbProperty = cbMinRequired;
        }
        break;
        case WM_DRM_SECURITYVERSION:
        {        
            cbMinRequired = wcslen(pcontextMGR->oBlackBoxContext.cachedCertValues.wszLegacyVersion) * SIZEOF(DRM_WCHAR);

            if ( f_pbProperty == NULL 
            ||  *f_pcbProperty < cbMinRequired )
            {
                *f_pcbProperty = cbMinRequired;
                ChkDR(DRM_E_BUFFERTOOSMALL);
            }
            MEMCPY(f_pbProperty, pcontextMGR->oBlackBoxContext.cachedCertValues.wszLegacyVersion, cbMinRequired );
            *f_pcbProperty = cbMinRequired;
        }
        break;
        case WM_DRM_V2_HEADER_KID:
        {        
            cbMinRequired = 0;

            if (pcontextMGR->eHeaderInContext == eHeaderIsV2)
            {
                DRM_CONST_STRING dstrKID = EMPTY_DRM_STRING;

                DSTR_FROM_PB( &pcontextMGR->oLicEvalContext.dstrContentHeader, 
                               pcontextMGR->rgbDRMHeaderData,
                               pcontextMGR->cbHeaderData );

                ChkDR( DRM_HDR_GetAttribute( &(pcontextMGR->oLicEvalContext.dstrContentHeader), 
                                             NULL, 
                                             DRM_HEADER_ATTRIB_KID, 
                                             &dstrKID, 
                                             0 ) );
                cbMinRequired = CB_DSTR (&dstrKID);
                if ( f_pbProperty == NULL 
                ||  *f_pcbProperty < cbMinRequired )
                {
                    *f_pcbProperty = cbMinRequired;
                    ChkDR(DRM_E_BUFFERTOOSMALL);
                }
                
                MEMCPY(f_pbProperty, PB_DSTR (&dstrKID), cbMinRequired );
                *f_pcbProperty = cbMinRequired;

            }
            else
            {

                ChkDR(DRM_E_HEADER_NOT_SET);
            }

        }
        break;
        default:
        {
            ChkDR(DRM_E_UNKNOWN_PROPERTY);
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_GetDeviceProperty", g_pwszLeavingFunction);
    return dr;
}

#endif     /* DRM_SUPPORT_DLA */


DRM_RESULT DRM_API DRM_MGR_ProcessLicenseResponse(
    IN DRM_MANAGER_CONTEXT     *f_pDrmContext,
    IN pfnStoreLicenseCallback  f_pfnCallback,
    IN DRM_VOID                *f_pvCallbackContext,
    IN DRM_BYTE                *f_pbResponse,
    IN DRM_DWORD                f_cbResponse )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext           = (DRM_MANAGER_CONTEXT_INTERNAL*) f_pDrmContext;
    DRM_VIEW_RIGHTS_CONTEXT      *pcontextViewRights = &pContext->oViewRightsContext;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_ProcessLicenseResponse", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);

    ChkArg (f_pDrmContext != NULL);
    if(!pContext->fStoreOpened)
    {
        ChkDR (DRM_E_DRMNOTINIT);
    }
    
    if (pContext->fBindThenCommit)
    {
        pContext->fBindThenCommit = FALSE;
    }

    ChkDR (_SetupLicEvalObjectToShare (pContext));    
    
    pcontextViewRights->pBBContext       = &pContext->oBlackBoxContext;
    pcontextViewRights->pLicQueryContext =  pContext->oLicEnum;
    pcontextViewRights->pbGlobalSecStore = &pContext->oSecStoreGlobalContext;
    pcontextViewRights->pbLIDSecStore    = &pContext->rgcontextSST[0];
    pcontextViewRights->pbLicenseStore   = &pContext->oLicStoreContext;
    pcontextViewRights->pLicEval         = &pContext->oLicEvalContext;
    pcontextViewRights->pbBuffer         =  pContext->rgbDRMHeaderData 
                                         +  __CB_DECL(pContext->cbHeaderData);
    pcontextViewRights->cbBuffer         =  SIZEOF (pContext->rgbDRMHeaderData) 
                                         +  SIZEOF (pContext->rgbDRMLicense)
                                         -  pContext->cbHeaderData;    
    
#if DRM_SUPPORT_APP_REVOCATION
    pContext->oLicEvalContext.idCRLsCurrent.app = DRM_APP_REVOCATION_VERSION_NONE;
    pContext->oLicEvalContext.fUpdatedRevocationList = FALSE;
    dr = DRM_MGR_GetRevocationListVersion( (DRM_MANAGER_CONTEXT*)pContext,
                                           WM_DRM_REVOCATION_TYPE_APP,
                                          &pContext->oLicEvalContext.idCRLsCurrent.app );
    if( DRM_FAILED(dr) && dr == DRM_E_FILENOTFOUND )
    {
        dr = DRM_SUCCESS;
    }
    else
    {
        ChkDR( dr );
    }
#endif

#if DRM_SUPPORT_REVOCATION
    {
        DRM_ANSI_CONST_STRING dastrRevocationInfoData;

        DASTR_FROM_PB(&dastrRevocationInfoData, f_pbResponse, f_cbResponse);

        ChkDR( DRM_RVK_ProcessRevocationInfo(&pContext->oLicEvalContext,
                                             &pContext->oHdsContext,
                                             &pContext->oSecStoreGlobalContext,
                                             &pContext->oBlackBoxContext,
                                             &dastrRevocationInfoData) );
    }
#endif /* DRM_SUPPORT_REVOCATION */
    dr = DRM_LA_ProcessResponse( f_pbResponse, 
                                 f_cbResponse, 
                                &pContext->oLicEvalContext,
                                &pContext->oLicStoreContext,
                                 f_pfnCallback, 
                                 f_pvCallbackContext,
                                &pContext->oHdsContext,
                                 pcontextViewRights,
                                 pContext->rgbDRMLicense,
#if DRM_SUPPORT_LICENSE_SYNC
                                &pContext->contextSync,
#else
                                 NULL,
#endif
                                 NULL);

#if DRM_SUPPORT_REVOCATION
    if( pContext->oLicEvalContext.fUpdatedRevocationList )
    {
        pContext->idCRLsCurrent = pContext->oLicEvalContext.idCRLsCurrent;
        pContext->oFFLicense.idCRLsCurrent = pContext->oLicEvalContext.idCRLsCurrent;
        pContext->oFFLicense.fUpdatedRevocationList = TRUE;
    }
#endif

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_ProcessLicenseResponse", g_pwszLeavingFunction);
    _FreeDrmManagerInternalContexts( pContext );
    return dr;
}

#if DRM_SUPPORT_METERING
typedef struct __tagBindCommit
{
    DRM_BYTE                rgbPassword  [__CB_DECL(SHA_DIGEST_LEN)];
    const DRM_CONST_STRING *rgpdstrActions [DRM_MAX_ACTIONS];
    DRM_DWORD               cActions;
} DRM_BIND_COMMIT_DATA;
#endif


/*****************************************************************************
** Function: DRM_MGR_Bind
**
** Synopsis: enumerate the passed-in license list and chain through, reporting
**           actions
** Arguments:
**           [f_pDrmContext]   -- initialized DRM_MANAGER context
**           [f_rgpdstrRights] -- array of constant strings (must not be stack
**                                variables) representing rights
**           [f_cRights]       -- size of f_rgpdstrRights array
**           [f_pfnOutputLevelsCallback]  -- callback for OPL
**           [f_pv]            -- passed through to f_pfnOutputLevelsCallback
*****************************************************************************/

DRM_RESULT DRM_API DRM_MGR_Bind(
    IN       DRM_MANAGER_CONTEXT         *f_pDrmContext,
    IN const DRM_CONST_STRING            *f_rgpdstrRights [],
    IN       DRM_DWORD                    f_cRights,
    IN       DRMPFNOUTPUTLEVELSCALLBACK   f_pfnOutputLevelsCallback,
    IN const DRM_VOID                    *f_pv,
       OUT   DRM_MANAGER_DECRYPT_CONTEXT *f_pcontextDCRY )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_RESULT dr2 = DRM_SUCCESS;
    DRM_DWORD  cbLicContext = 0;
    DRM_BOOL   fEvalResult  = FALSE;    
#if DRM_SUPPORT_METERING
    DRM_BIND_COMMIT_DATA *pbcd   = NULL;
    DRM_DWORD             iRight = 0;
#endif
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) f_pDrmContext;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_Bind", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);

    ChkArg(f_pDrmContext  != NULL );

    ChkArg ( (f_rgpdstrRights != NULL && f_cRights  > 0 && f_cRights <= DRM_MAX_ACTIONS)
        ||   (f_rgpdstrRights == NULL && f_cRights == 0) );

    if (pContext->fBindThenCommit)
    {
        pContext->fBindThenCommit = FALSE;
    }

    if (!pContext->fStoreOpened)
    {
        ChkDR (DRM_E_DRMNOTINIT);
    }

    for( cbLicContext = 0; cbLicContext < f_cRights; cbLicContext++ )
    {
        ChkDRMString( f_rgpdstrRights[cbLicContext] );
    }
    
    if( pContext->cbHeaderData     == 0 
     || pContext->eHeaderInContext == eHeaderNotSet ) 
    {
        dr = DRM_E_HEADER_NOT_SET;
        goto ErrorExit;
    }

    if (pContext->eHeaderInContext != eKidOnly)
    {
        ChkArg(f_pcontextDCRY != NULL );
    }


    pContext->dwChainDepth = 0;
    pContext->dwSourceid   = 0;
    /* v2 header is unicode, # of bytes must be a even number. */
    DRMASSERT( (pContext->eHeaderInContext == eHeaderIsV2) && 
               !ISODD(pContext->cbHeaderData) );

    ChkDR(_SetupLicEvalObjectToShare( pContext ));

    if ( pContext->eHeaderInContext==eHeaderIsV2 )
    {
        DRM_CONST_STRING dstrCheckSum = EMPTY_DRM_STRING;

        /* Extract all the other pieces to fill the bindinginfo structure.  If they don't exists in the header */
        ChkDR( DRM_HDR_GetAttribute(
                &pContext->oLicEvalContext.dstrContentHeader, 
                NULL, 
                DRM_HEADER_ATTRIB_CHECKSUM, 
                &dstrCheckSum, 
                0) );

        /* If the following base64 decode fails because the buffer isn't big enough then it isn't a valid checksum anyway. */
        cbLicContext = CHECKSUM_LENGTH;
        ZEROMEM(pContext->oBindInfo[0].m_rgbChecksum, CHECKSUM_LENGTH );
        ChkDR(DRM_B64_DecodeW(&dstrCheckSum, &cbLicContext, pContext->oBindInfo[0].m_rgbChecksum, 0));
        if( cbLicContext != CHECKSUM_LENGTH )
        {
            dr = DRM_E_INVALIDLICENSE;
            goto ErrorExit;
        }
    }


    /* Fill the FindFirstLicense structure */
    ZEROMEM(&pContext->oFFLicense, SIZEOF( pContext->oFFLicense ) );

#if DRM_SUPPORT_REVOCATION
    pContext->oFFLicense.idCRLsCurrent     =  pContext->idCRLsCurrent;
#endif
    pContext->oFFLicense.pLicEval          = &pContext->oLicEvalContext;
    pContext->oFFLicense.pLicStore         = &pContext->oLicStoreContext;
    pContext->oFFLicense.pLicStoreEnum     =  pContext->oLicEnum;
    pContext->oFFLicense.pbBuffer          =  pContext->rgbDRMHeaderData 
                                           +  __CB_DECL(pContext->cbHeaderData); 
    pContext->oFFLicense.cbBuffer          =  SIZEOF (pContext->rgbDRMHeaderData)
                                           +  SIZEOF (pContext->rgbDRMLicense) 
                                           -  pContext->cbHeaderData;
    pContext->oFFLicense.pBindingInfo      =  pContext->oBindInfo;
    pContext->oFFLicense.pSecStoreLicense  =  pContext->rgcontextSST;
    pContext->oFFLicense.dwPolicyFlags     = 0;

    if (pContext->eHeaderInContext == eKidOnly)
    {
        pContext->oFFLicense.fCanBind = TRUE;
    }

    
    ChkDR(DRM_UTL_EnsureDataAlignment(
            pContext->oFFLicense.pbBuffer, 
            pContext->oFFLicense.cbBuffer, 
           &pContext->oFFLicense.pbBuffer, 
           &pContext->oFFLicense.cbBuffer, 
            SIZEOF (DRM_DWORD_PTR), 
            NULL));

    /* Query for licenses based on KID 
    ** Note: pContext->KID should be set up at this point 
    */
    ChkDR( DRM_LST_InitEnum(&pContext->oLicStoreContext, &pContext->KID, TRUE, &pContext->oLicEnum[0]) );
    while( TRUE )
    {   
        dr = DRM_LST_EnumNext( 
                &pContext->oLicEnum                 [0],
                &pContext->oFFLicense.rgkid         [0], 
                &pContext->oFFLicense.rglid         [0], 
                &(pContext->oFFLicense.rgslotHint   [0]),
                NULL); 

        if (dr == DRM_E_NOMORE)
        {
            dr = DRM_E_LICENSENOTFOUND;
            goto ErrorExit;
        }
        ChkDR( dr );

        if ( pContext->eHeaderInContext == eHeaderIsV1 )
        {                
            pContext->oFFLicense.pV1Header = (DRM_V1Header*)pContext->rgbDRMHeaderData;
        }
        else
        {
            pContext->oFFLicense.pV1Header = NULL;
        }
#if DRM_SUPPORT_SECURE_CLOCK
        if ( (pContext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_SECURE_CLOCK) 
          && !pContext->fClockSet )
        {
           pContext->oLicEvalContext.fIgnoreTimeBoundLicense = TRUE;
        }
#endif            
        if ( (pContext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_SECURE_CLOCK) == 0 
          && (pContext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_ANTI_ROLLBACK_CLOCK) == 0 )
        {
           pContext->oLicEvalContext.fIgnoreTimeBoundLicense = TRUE;
        }

        dr = DRM_LIC_CompleteLicenseChain(&pContext->oFFLicense, 
                                           f_rgpdstrRights, 
                                           f_cRights,
                                          &pContext->dwChainDepth, 
                                          &pContext->oHdsContext,
                                           f_pfnOutputLevelsCallback,
                                           f_pv);

#if DRM_SUPPORT_REVOCATION
        /* If the call failed due to revocation, we should make sure the
        *  revocation version cache in the DRM_MANAGER_CONTEXT is up to date.
        *  If there have been any changes we should try again.
        */
        if(    dr == DRM_E_RIV_TOO_SMALL
            || dr == DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE )
        {
            DRM_BOOL revocationUpdated = FALSE;
            
            DRM_RVK_UpdateRevocationVersionsCache( pContext, &revocationUpdated );

            if( revocationUpdated )
            {
                pContext->oFFLicense.idCRLsCurrent = pContext->idCRLsCurrent;
                
                ChkDR( DRM_LIC_CompleteLicenseChain(&pContext->oFFLicense, 
                                                   f_rgpdstrRights, 
                                                   f_cRights,
                                                  &pContext->dwChainDepth, 
                                                  &pContext->oHdsContext,
                                                   f_pfnOutputLevelsCallback,
                                                   f_pv) );
            }
        }
#endif

        if( pContext->oFFLicense.fCanBind )
        {
            goto ErrorExit;
        }

        if( DRM_SUCCEEDED( dr ) )
        {   /* 
            ** update the dwSourceid in DRM_MANAGER_CONTEXT_INTERNAL from 
            ** DRM_FFLICENSE
            */
            pContext->dwSourceid = pContext->oFFLicense.dwSourceid;
            
            /*
            ** A license was found.  The license chain has a depth of dwChainDepth.  
            ** Send all the binding info to the blackbox 
            */

            if ( pContext->eHeaderInContext == eHeaderIsV1 )
            {
                DRM_V1Header *pV1Header = (DRM_V1Header*)pContext->rgbDRMHeaderData;

                dr = DRM_BBX_LegacyCipherKeySetup(
                        pContext->oFFLicense.pBindingInfo,
                        pV1Header->pbKeyID, 
                        pV1Header->cbKeyID, 
                        pV1Header->pbSecretData, 
                        pV1Header->cbSecretData,
                        (DRM_CIPHER_CONTEXT*)f_pcontextDCRY,
                       &pContext->oBlackBoxContext );
            }
            else
            {
                dr = DRM_BBX_CipherKeySetup(
                        pContext->oFFLicense.pBindingInfo, 
                        pContext->dwChainDepth, 
                        (DRM_CIPHER_CONTEXT*)f_pcontextDCRY, 
                       &pContext->oBlackBoxContext );
            }
            
            if( DRM_SUCCEEDED( dr ) )
            {
                dr = DRM_LIC_ReportActions(&pContext->oFFLicense,
                                            f_rgpdstrRights,
                                            f_cRights,
                                            pContext->dwChainDepth,
                                           &pContext->oHdsContext );


                if (DRM_SUCCEEDED(dr))
                {
                    dr = DRM_SUCCESS;
                    break;
                }
            }
        }
        else if ( pContext->oLicEvalContext.lReasonForFail == LR_LICENSE_CLOCK_NOT_SET )
        {
            dr2 = DRM_E_CLK_NOT_SET;
        }
        else if ( pContext->oLicEvalContext.lReasonForFail == LR_LICENSE_EXPIRED )
        {
            dr = DRM_E_LICENSEEXPIRED;
        }
    }

#if DRM_SUPPORT_METERING
    /* cache the actions/rights to pass to the Commit call */

    pbcd = (DRM_BIND_COMMIT_DATA *) pContext->rgbDRMLicense;

    pbcd->cActions = f_cRights;

    for (iRight = 0; iRight < f_cRights; iRight++)
    {
        pbcd->rgpdstrActions [iRight] = f_rgpdstrRights [iRight];
    }
#endif

    pContext->fBindThenCommit = TRUE;

ErrorExit:
    

    if( DRM_FAILED( dr ) )
    {
        if ( dr2 == DRM_E_CLK_NOT_SET )
        {
            if (pContext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_SECURE_CLOCK)
            {
                dr = DRM_E_CLK_NOT_SET;
            }
            else
            {
               dr = DRM_E_NO_CLK_SUPPORTED;
            }

        }
    }
    _FreeDrmManagerInternalContexts( pContext );
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_Bind", g_pwszLeavingFunction);
    return _MapDRMError(dr);
}


/*****************************************************************************
** Function: DRM_MGR_GetSourceID
**
** Synopsis: This function should be called after DRM_MGR_Bind returns successfully. 
**           It returns the SourceID in the DRM_MANAGER_CONTEXT that was set in 
**           DRM_MGR_Bind.
** Arguments:
**           IN  *f_pDrmContext    -- initialized DRM_MANAGER context 
**           OUT *f_pdwSourceID
** Returns:
**           DRM_SUCCESS           -- On success
**           DRM_E_INVALIDARG      -- if any argument is invalid
*****************************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetSourceID ( 
    IN     DRM_MANAGER_CONTEXT  *f_pDrmContext,
       OUT DRM_DWORD            *f_pdwSourceID )
{
    DRM_RESULT                    dr       = DRM_SUCCESS;    
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) f_pDrmContext;
    
    ChkArg( f_pDrmContext != NULL 
         && f_pdwSourceID != NULL );

    *f_pdwSourceID = pContext->dwSourceid;
    
ErrorExit:
    return dr;
}



DRM_RESULT DRM_API DRM_MGR_Commit( 
    IN     DRM_MANAGER_CONTEXT         *f_pcontextMGR )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pcontextMGR = (DRM_MANAGER_CONTEXT_INTERNAL*) f_pcontextMGR;
#if DRM_SUPPORT_METERING
    DRM_BIND_COMMIT_DATA         *pbcd = NULL;
#endif

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_Commit", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);
        
    ChkArg( f_pcontextMGR  != NULL );
    ChkArg(pcontextMGR->fBindThenCommit);

#if DRM_SUPPORT_METERING
    pbcd = (DRM_BIND_COMMIT_DATA *) pcontextMGR->rgbDRMLicense;
#endif

    if(!pcontextMGR->fStoreOpened)
    {
        ChkDR(DRM_E_DRMNOTINIT);
    }

    if(pcontextMGR->dwChainDepth == 0)
    {
        ChkDR(DRM_E_LICENSENOTBOUND);
    }

    for( ; pcontextMGR->dwChainDepth > 0; )
    {
        /* shift from cardinal to ordinal */
        
        pcontextMGR->dwChainDepth--;

        ChkDR( DRM_SST_CloseKey( &pcontextMGR->rgcontextSST[pcontextMGR->dwChainDepth], 
                                 &pcontextMGR->oHdsContext ) );

#if DRM_SUPPORT_METERING
        if (pcontextMGR->oFFLicense.rgfHasMetering [pcontextMGR->dwChainDepth])
        {             
            ChkDR(DRM_MTR_UpdateData(&pcontextMGR->oFFLicense.rgmid [pcontextMGR->dwChainDepth], 
                                     &pcontextMGR->oFFLicense.rglid [pcontextMGR->dwChainDepth],
                                     &pcontextMGR->oFFLicense.rgkid [pcontextMGR->dwChainDepth],
                                      pbcd->rgpdstrActions,
                                      pbcd->cActions,
            (DRM_METERING_CONTEXT *) &pcontextMGR->rgcontextSST [pcontextMGR->dwChainDepth],
                                     &pcontextMGR->oHdsContext,                                    
                                     (DRM_BYTE *) &pcontextMGR->oBlackBoxContext)); 
        }
#endif        
        if (pcontextMGR->oFFLicense.rgfDeleteLicense[pcontextMGR->dwChainDepth])
        {
            ChkDR(DRM_LST_Open(pcontextMGR->oFFLicense.pLicStore,
                               &pcontextMGR->oHdsContext));
            
            dr = DRM_LST_DeleteLicense( pcontextMGR->oFFLicense.pLicStore,
                                       &pcontextMGR->oFFLicense.rgkid[pcontextMGR->dwChainDepth],
                                       &pcontextMGR->oFFLicense.rglid[pcontextMGR->dwChainDepth],
                                       &(pcontextMGR->oFFLicense.rgslotHint[pcontextMGR->dwChainDepth]) );

            if (DRM_FAILED(dr))
            {
                /* try to close the lic store in case of failure */
                (void)DRM_LST_Close(pcontextMGR->oFFLicense.pLicStore);
                ChkDR(dr);
            }
#if DRM_SUPPORT_LICENSE_SYNC            
            dr = DRM_SNC_UpdateKID(&pcontextMGR->contextSync, 
                                   NULL, 
                                   &pcontextMGR->oFFLicense.rgkid[pcontextMGR->dwChainDepth]);

            if (DRM_FAILED(dr))
            {
                /* try to close the lic store in case of failure */
                ChkDR( DRM_LST_Close(pcontextMGR->oFFLicense.pLicStore) );                
            }
#endif

            ChkDR(DRM_LST_Close(pcontextMGR->oFFLicense.pLicStore));
        }
    }

ErrorExit:


    if( pcontextMGR != NULL )
    {
        pcontextMGR->fBindThenCommit = FALSE;
        pcontextMGR->dwChainDepth = 0;
    }
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_Commit", g_pwszLeavingFunction);
    return dr;
}



DRM_RESULT DRM_API DRM_MGR_InitDecrypt(
    IN DRM_MANAGER_DECRYPT_CONTEXT  *f_pDecryptContext,
    IN DRM_BYTE                     *f_pbLast15,
    IN DRM_DWORD                     f_cbData )
{
    return DRM_BBX_InitDecrypt( 
            (DRM_CIPHER_CONTEXT*)f_pDecryptContext,
            f_pbLast15,
            f_cbData);
}



DRM_RESULT DRM_API DRM_MGR_Decrypt(
    IN DRM_MANAGER_DECRYPT_CONTEXT *pDecryptContext,
    IN OUT DRM_BYTE                *pbData,
    IN DRM_DWORD                    cbData )
{
    return DRM_BBX_Decrypt(cbData, pbData, (DRM_CIPHER_CONTEXT *) pDecryptContext);
}



DRM_RESULT DRM_API DRM_MGR_GetLicenseData(
    IN       DRM_MANAGER_CONTEXT    *pDrmContext,
    IN const DRM_CONST_STRING       *rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    OUT      DRM_LICENSE_STATE_DATA  rgStateData[], /* array of DRM_LICENSE_STATE_DATAs */
    IN       DRM_DWORD               cRightsQueried )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_GetLicenseData", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);
    
    ChkArg( rgpdstrRights != NULL
         && rgStateData   != NULL
         && cRightsQueried > 0 
         && pDrmContext   != NULL );

    if (pContext->fBindThenCommit)
    {
        pContext->fBindThenCommit = FALSE;
    }

    if (!pContext->fStoreOpened)
    {
        ChkDR (DRM_E_DRMNOTINIT);
    }
    if ( pContext->eHeaderInContext==eHeaderNotSet )
    {
        ChkDR(DRM_E_HEADER_NOT_SET);  /* no v1 or V2 header is setup */
    }
    ChkDR( _SetupLicEvalObjectToShare( pContext ) );

    /* Setup the stuff that GetProperties needs */
    MEMCPY(&pContext->oViewRightsContext.KID, &pContext->KID, SIZEOF(DRM_KID));

    pContext->oViewRightsContext.pBBContext       = &pContext->oBlackBoxContext;
    pContext->oViewRightsContext.pLicQueryContext = &pContext->oLicEnum [0];
    pContext->oViewRightsContext.pbGlobalSecStore = &pContext->oSecStoreGlobalContext;
    pContext->oViewRightsContext.pbLIDSecStore    = &pContext->rgcontextSST[0];
    pContext->oViewRightsContext.pbLicenseStore   = &pContext->oLicStoreContext;
    pContext->oViewRightsContext.pLicEval         = &(pContext->oLicEvalContext);
    pContext->oViewRightsContext.pbBuffer         =  pContext->rgbDRMHeaderData + __CB_DECL(pContext->cbHeaderData);
    pContext->oViewRightsContext.cbBuffer         =  SIZEOF( pContext->rgbDRMHeaderData ) - 
                                                     pContext->cbHeaderData + 
                                                     SIZEOF(pContext->rgbDRMLicense);

    ChkDR( DRM_ASD_GetLicenseAggregateData( rgpdstrRights, 
                                            rgStateData, 
                                            cRightsQueried, 
                                           &pContext->oViewRightsContext,
                                           &pContext->oHdsContext,
                                            FALSE ) );
ErrorExit:
    _FreeDrmManagerInternalContexts( pContext );

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_GetLicenseData", g_pwszLeavingFunction);

    return dr;
}



#if DRM_SUPPORT_METERING

DRM_RESULT DRM_API DRM_MGR_GenerateMeterChallenge(
    IN       DRM_MANAGER_CONTEXT *pcontextMGR,
    IN const DRM_CONST_STRING    *pdstrMeterCert,
       OUT   DRM_WCHAR           *pwszURL,
    IN OUT   DRM_DWORD           *pcchURL,
       OUT   DRM_BYTE            *pbChallenge,
    IN OUT   DRM_DWORD           *pcbChallenge)
{
    DRM_MANAGER_CONTEXT_INTERNAL *pcontext = (DRM_MANAGER_CONTEXT_INTERNAL *) pcontextMGR;
    DRM_RESULT                    dr       = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_GenerateMeterChallenge", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);

    ChkArg (pcontextMGR    != NULL
         && pdstrMeterCert != NULL
         && pcbChallenge   != NULL);

    if (pcontext->fBindThenCommit)
    {
        pcontext->fBindThenCommit = FALSE;
    }

    if (!pcontext->fStoreOpened)
    {
        ChkDR (DRM_E_DRMNOTINIT);
    }

    if ( (pcontext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_METERING) == 0)
    {
        ChkDR (DRM_E_METERING_NOT_SUPPORTED);
    }

    ChkDR( _SetupLicEvalObjectToShare( pcontext ) );

    ChkDR(DRM_MTR_GenerateMeterChallenge( &pcontext->oLicEvalContext,
                                           pcontext->rgbDRMLicense,
                                   SIZEOF( pcontext->rgbDRMLicense ),
                                           pdstrMeterCert,
                                           pbChallenge,
                                           pcbChallenge,
                                           pwszURL,
                                           pcchURL ) );
    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_GenerateMeterChallenge", g_pwszLeavingFunction);

    return dr;                                           
}

                    
DRM_RESULT DRM_API DRM_MGR_ProcessMeterResponse(
    IN   DRM_MANAGER_CONTEXT  *pcontextMGR,
    IN   DRM_BYTE             *pbData,
    IN   DRM_DWORD             cbData,
    OUT  DRM_DWORD            *pfFlagsOut)
{
    DRM_MANAGER_CONTEXT_INTERNAL *pcontext = (DRM_MANAGER_CONTEXT_INTERNAL *) pcontextMGR;
    DRM_RESULT                    dr       = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_ProcessMeterResponse", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);
    
    ChkArg (pcontextMGR   != NULL
         && pbData        != NULL
         && pfFlagsOut    != NULL
         && cbData         > 0);
        
    if (pcontext->fBindThenCommit)
    {
        pcontext->fBindThenCommit = FALSE;
    }

    if(!pcontext->fStoreOpened)
    {
        ChkDR (DRM_E_DRMNOTINIT);
    }

    if ((pcontext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_METERING) == 0)
    {
        ChkDR (DRM_E_METERING_NOT_SUPPORTED);
    }

    ChkDR( _SetupLicEvalObjectToShare( pcontext ) );
         
    dr = DRM_MTR_ProcessMeterResponse( &pcontext->oLicEvalContext,
                                        pcontext->rgbDRMLicense,
                                SIZEOF( pcontext->rgbDRMLicense ),
                                        pbData,
                                        cbData,
                                        pfFlagsOut);

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_ProcessMeterResponse", g_pwszLeavingFunction);
    return dr;                                         
}
#endif /* DRM_SUPPORT_METERING */



#if DRM_SUPPORT_LICENSE_SYNC 

DRM_RESULT DRM_API DRM_MGR_GenerateSyncChallenge(
    IN     DRM_MANAGER_CONTEXT *pcontextMGR,
    IN     DRM_DWORD            cMaxCount,
    IN     DRM_DWORD            cMaxHours,
    IN     DRM_DWORD            f_iKIDStart,
    IN     DRM_DWORD            f_cKIDs,
       OUT DRM_DWORD           *f_piKIDNext,
       OUT DRM_DWORD           *f_pcKIDs,
       OUT DRM_BYTE            *pbData,
    IN OUT DRM_DWORD           *pcbData)
{
    DRM_MANAGER_CONTEXT_INTERNAL *pcontextManager    = (DRM_MANAGER_CONTEXT_INTERNAL *) pcontextMGR;
    DRM_VIEW_RIGHTS_CONTEXT      *pcontextViewRights = NULL;
    DRM_STACK_ALLOCATOR_CONTEXT   contextStack       = { 0 };
    DRM_HDS_CONTEXT *pcontextHDS  = NULL;
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_DWORD        cbStack      = 0,
                     cbViewRights = 0;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_GenerateSyncChallenge", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);
    
    ChkArg (pcontextMGR != NULL
         && pcbData     != NULL);

    if (pcontextManager->fBindThenCommit)
    {
        pcontextManager->fBindThenCommit = FALSE;
    }

    /* caller must do DRM_MGR_Initialize before DRM_MGR_GenerateSyncChallenge */

    if(!pcontextManager->fStoreOpened)
    {
        ChkDR (DRM_E_DRMNOTINIT);
    }
    
    pcontextHDS        = &pcontextManager->oHdsContext;
    pcontextViewRights = &pcontextManager->oViewRightsContext;

    /* neither view rights nor GenerateSyncChallenge need a 
    ** lot of stack; split this one between both  
    ** | rgbLicense .... |
    **   ^ stack
    **          ^ viewrights
    ** 
    */

    cbStack      = SIZEOF (DRM_SYNC_CONTEXT)
                 + SIZEOF (DRM_SYNC_ENUM_CONTEXT)
                 + 20;

    cbViewRights = SIZEOF (pcontextManager->rgbDRMLicense)
                 - cbStack;

    contextStack.pbStack = pcontextManager->rgbDRMLicense;
    contextStack.cbStack = cbStack;

    pcontextViewRights->pbBuffer =  contextStack.pbStack
                                 +  __CB_DECL(contextStack.cbStack);
    pcontextViewRights->cbBuffer =  cbViewRights;

    /* set up view rights context for license store query */

    pcontextViewRights->pBBContext       = &pcontextManager->oBlackBoxContext;
    pcontextViewRights->pLicQueryContext = &pcontextManager->oLicEnum [0];
    pcontextViewRights->pbGlobalSecStore = &pcontextManager->oSecStoreGlobalContext;
    pcontextViewRights->pbLIDSecStore    = &pcontextManager->rgcontextSST [0];
    pcontextViewRights->pbLicenseStore   = &pcontextManager->oLicStoreContext;
    pcontextViewRights->pLicEval         = &pcontextManager->oLicEvalContext;

    dr = DRM_SNC_GenerateSyncChallenge(
            pcontextViewRights,
            pcontextHDS,
           &contextStack,
            cMaxCount,
            cMaxHours,
            f_iKIDStart,
            f_cKIDs,
            f_piKIDNext,
            f_pcKIDs,
            pbData,
            pcbData);

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_GenerateSyncChallenge", g_pwszLeavingFunction);
    return dr;                                           
}
#endif   /* DRM_SUPPORT_LICENSE_SYNC */



#if DRM_SUPPORT_SECURE_CLOCK

/*******************************************************************
 * Internal function to be called at DRM_MGR_Init for Secure
 * Clock.
 *******************************************************************/
 
static DRM_RESULT _CheckSecureClock( 
    DRM_MANAGER_CONTEXT_INTERNAL *pContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SECSTORE_CONTEXT    *poSecureStoreContext = NULL;

    /* Result is first SHA_DIGEST_LEN bytes of rgbDRMLicense */
    ChkDR(DRM_SST_CreateGlobalStorePassword(
            pContext->rgbDRMLicense, 
            (DRM_BYTE *)&pContext->oBlackBoxContext)); 

    /* As only SHA_DIGEST_LEN bytes are getting used for password, 
      other bytes can be used for DRM_SECSTORE_CONTEXT */
    poSecureStoreContext = ( DRM_SECSTORE_CONTEXT * )(pContext->rgbDRMLicense + __CB_DECL(SHA_DIGEST_LEN) );

    ChkDR( DRM_CLK_InitCheckSecureClock( 
            pContext->rgbDRMLicense,
            &( pContext->oBlackBoxContext.CryptoContext ),
            &( pContext->oHdsContext ),
            &( pContext->fClockSet ),
            poSecureStoreContext,
            &( pContext->oLicEvalContext ) ) );


ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_MGR_ClkProcessResponse(
    IN  DRM_MANAGER_CONTEXT *pDrmContext,
    IN  DRM_BYTE            *pbResponse,
    IN  DRM_DWORD            cbResponse,
    OUT DRM_RESULT          *pResult)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;
    DRM_SECSTORE_CONTEXT    *poSecureStoreContext = NULL;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_ClkProcessResponse", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);

    ChkArg( pDrmContext != NULL
         && pbResponse  != NULL
         && cbResponse  != 0
         && pResult     != NULL );
    
    if (pContext->fBindThenCommit)
    {
        pContext->fBindThenCommit = FALSE;
    }

    if( (pContext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_SECURE_CLOCK) == 0 )
    {
        ChkDR( DRM_E_CLK_NOT_SUPPORTED );
    }

    /* Result is first SHA_DIGEST_LEN bytes of rgbDRMLicense */
    ChkDR(DRM_SST_CreateGlobalStorePassword(pContext->rgbDRMLicense, 
                                           (DRM_BYTE *) &pContext->oBlackBoxContext)); 

   /* As only SHA_DIGEST_LEN bytes are getting used for password, 
      other bytes can be used for DRM_SECSTORE_CONTEXT */
    poSecureStoreContext = ( DRM_SECSTORE_CONTEXT * )(pContext->rgbDRMLicense + __CB_DECL(SHA_DIGEST_LEN) );

    ChkDR(_SetupLicEvalObjectToShare( pContext ));

    /* Explicitly make the global secure store writeabele */
    pContext->oLicEvalContext.fGlobalSecStoreWritable = TRUE;

    /* Call DRM_CLK_ProcessResponse */
    ChkDR( DRM_CLK_ProcessResponse(
           &pContext->oBlackBoxContext.cachedCertValues.pubkeySecureClockServer,
            pbResponse, 
            cbResponse, 
            pContext->rgbDRMLicense,  
            pResult,
           &pContext->oBlackBoxContext.CryptoContext,
           &pContext->oHdsContext,
            poSecureStoreContext,
           &pContext->oLicEvalContext) );

    /*After successful processing response, Set DRM Manager Clock flag*/
    pContext->fClockSet = TRUE;
    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_ClkProcessResponse", g_pwszEnteringFunction);

    _FreeDrmManagerInternalContexts( pContext );
    return dr;
}


DRM_RESULT DRM_API DRM_MGR_ClkGenerateChallenge(
    IN     DRM_MANAGER_CONTEXT  *pDrmContext,
       OUT DRM_WCHAR            *pwszURL,
    IN OUT DRM_DWORD            *pcchURL,
       OUT DRM_BYTE             *pbChallenge,
    IN OUT DRM_DWORD            *pcbChallenge )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;    
    DRM_CONST_STRING dstrURL        = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDeviceCert = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_ClkGenerateChallenge", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);

    ChkArg( pDrmContext  != NULL
         && pcbChallenge != NULL );
    
    if (pContext->fBindThenCommit)
    {
        pContext->fBindThenCommit = FALSE;
    }

    if( (pContext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_SECURE_CLOCK) == 0 )
    {
        ChkDR( DRM_E_CLK_NOT_SUPPORTED );
    }

    DSTR_FROM_PB( &dstrDeviceCert, pContext->rgbDRMLicense, SIZEOF( pContext->rgbDRMLicense ) );
    
    ChkDR( DRM_DDC_GetDeviceCertificate( 
            (DRM_STRING*)&dstrDeviceCert, 
            0,
            &pContext->oBlackBoxContext.CryptoContext) );
    
    ChkDR( DRM_DCP_GetAttribute( 
            &dstrDeviceCert,
            DRM_DEVCERT_SECURECLOCKURL,
            NULL,
            &dstrURL) );
    
    /* Result is first SHA_DIGEST_LEN bytes of oSecStoreGlobalContext */
    ChkDR(DRM_SST_CreateGlobalStorePassword(
            (DRM_BYTE*)&pContext->oSecStoreGlobalContext, 
            (DRM_BYTE *)&pContext->oBlackBoxContext)); 

    dr = DRM_CLK_CreateChallenge(
            &dstrURL, 
 (DRM_BYTE*)&pContext->oSecStoreGlobalContext,
            &pContext->oBlackBoxContext.CryptoContext,
            &pContext->oHdsContext,
            &pContext->rgcontextSST[0],
             pwszURL,
             pcchURL,
             pbChallenge,
             pcbChallenge);

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_ClkGenerateChallenge", g_pwszLeavingFunction);

    return dr;
}

DRM_RESULT DRM_API DRM_MGR_GetSecureClock(
    IN     DRM_MANAGER_CONTEXT  *pDrmContext,
    IN     DRM_WCHAR            *pwszSecureTime,
    IN OUT DRM_DWORD            *pcchSecureTime, 
    IN     DRM_DWORD            *pdwFlags,
    IN     DRM_BYTE             *pbSecureTimeWithStatus,
    IN OUT  DRM_DWORD           *pcbSecureTimeWithStatus  )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) pDrmContext;
    DRM_SECSTORE_CONTEXT    *poSecureStoreContext = NULL;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_GetSecureClock", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);
    
    ChkArg( pDrmContext != NULL );

    if (pContext->fBindThenCommit)
    {
        pContext->fBindThenCommit = FALSE;
    }

    if( (pContext->oBlackBoxContext.cachedCertValues.dwFeatureFlags & DRM_FEATURE_SECURE_CLOCK) == 0 )
    {
        ChkDR( DRM_E_CLK_NOT_SUPPORTED );
    }

    /* Result is first SHA_DIGEST_LEN bytes of rgbDRMLicense */
    ChkDR(DRM_SST_CreateGlobalStorePassword(
            pContext->rgbDRMLicense, 
            (DRM_BYTE *) &pContext->oBlackBoxContext)); 

   /* As only SHA_DIGEST_LEN bytes are getting used for password, 
      other bytes can be used for DRM_SECSTORE_CONTEXT */
    poSecureStoreContext = ( DRM_SECSTORE_CONTEXT * )(pContext->rgbDRMLicense + __CB_DECL(SHA_DIGEST_LEN) );

    /* Call DRM_CLK_GetSecureClock */

    dr = DRM_CLK_GetSecureClock(  
            pwszSecureTime,
            pcchSecureTime, 
            pdwFlags,
            pbSecureTimeWithStatus,
            pcbSecureTimeWithStatus,
            pContext->rgbDRMLicense,  
            &( pContext->oBlackBoxContext.CryptoContext ),
            &( pContext->oHdsContext ),
            poSecureStoreContext);
    

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_GetSecureClock", g_pwszLeavingFunction);
    
    return dr;
}
#endif    /* DRM_SUPPORT_SECURE_CLOCK */



#if DRM_SUPPORT_ENCRYPTION

DRM_RESULT DRM_API DRM_MGR_CreateEncryptContext(
    IN const DRM_BYTE                     rgbKey[__CB_DECL(DRMCIPHERKEYLEN)],
    OUT      DRM_MANAGER_ENCRYPT_CONTEXT *pEncryptContext )
{
    return DRM_CPHR_Init((DRM_CIPHER_CONTEXT*) pEncryptContext, DRMCIPHERKEYLEN, rgbKey );
}

DRM_RESULT DRM_API DRM_MGR_Encrypt(
    IN     DRM_MANAGER_ENCRYPT_CONTEXT *pEncryptContext,
    IN OUT DRM_BYTE                    *pbData,
    IN     DRM_DWORD                    cbData )
{
    return DRM_CPHR_Encrypt( (DRM_CIPHER_CONTEXT*) pEncryptContext, cbData, pbData);
}

#endif  /* DRM_SUPPORT_ENCRYPTION */



DRM_RESULT DRM_API DRM_MGR_CleanupLicenseStore(
    IN       DRM_MANAGER_CONTEXT     *pDrmContext,
    IN const DRM_VOID                *pvCallerData,
    IN       DRM_DWORD                dwCallbackInterval,
    IN       pfnStoreCleanupProgress  pfnCallback )
{
    DRM_RESULT                    dr       =  DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL *) pDrmContext;
    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_CleanupLicenseStore", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);
    
    ChkArg ( pDrmContext != NULL );

    if (pContext->fBindThenCommit)
    {
        pContext->fBindThenCommit = FALSE;
    }

    ChkDR( _SetupLicEvalObjectToShare( pContext ) ); 
    
    dr = DRM_LST_Clean ( 
            (DRM_BYTE *)&pContext->oLicEvalContext,
            (DRM_BYTE *)&pContext->oLicStoreContext,
            pContext->rgbDRMLicense,
            DRM_MAX_LICENSESIZE,
            pvCallerData,
            dwCallbackInterval,
            pfnCallback,
            &( pContext->oHdsContext ) );
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_CleanupLicenseStore", g_pwszLeavingFunction);
    _FreeDrmManagerInternalContexts( pContext );
    return dr;                                           
}


DRM_RESULT DRM_API DRM_MGR_GetLicenseState(
    IN       DRM_MANAGER_CONTEXT            *pDrmContext,
    IN  const DRM_CONST_STRING              *pdstrQuery,
    OUT      DRM_LICENSE_STATE_CATEGORY     *pCategory,
    OUT      DRM_DWORD                      *pdwReserved1,
    OUT      DRM_DWORD                      *pdwReserved2,
    OUT      DRM_DWORD                      *pdwReserved3)
{
    DRM_RESULT          dr              =  DRM_SUCCESS;
    DRM_LONG            lCanBind        = 0;
    DRM_CONST_STRING    dstrRoot        = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrData        = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrValue       = EMPTY_DRM_STRING;
    DRM_CONST_STRING   *pdstrRights [1];
    DRM_MANAGER_CONTEXT_INTERNAL *pContext   = (DRM_MANAGER_CONTEXT_INTERNAL *) pDrmContext;
    DRM_PROFILING_ENTER_SCOPE(L"DRM_MGR_GetLicenseState", g_pwszEnteringFunction, DRM_PROFILING_START_IF_NOT_STARTED);
  
    ChkArg ( pDrmContext != NULL 
        &&   pCategory   != NULL);

    ChkDRMString( pdstrQuery );

    /*Init the out parameter*/

    if(pdwReserved1)
    {
        *pdwReserved1 = 0;
    }
    if(pdwReserved2)
    {
        *pdwReserved2 = 0;
    }
    if(pdwReserved3)
    {
        *pdwReserved3 = 0;
    }


    *pCategory = WM_DRM_LICENSE_STATE_NORIGHT;

/*
<LICENSESTATE type = challenge>
    <DATA>
        <ACTION>Play</ACTION> 
        <KID>KID directly from license</KID>
        <CANBIND>1</CANBIND> 
    </DATA>
</LICENSESTATE >
*/
    
    ChkDR( DRM_XML_GetNode( pdstrQuery, &g_dstrTagLicenseStateRequestRoot,  NULL, NULL, 0, NULL, &dstrRoot    ) );
    ChkDR( DRM_XML_GetNode( &dstrRoot,  &g_dstrTagData,                    NULL, NULL, 0, NULL, &dstrData    ) );
    ChkDR( DRM_XML_GetNode( &dstrData,  &g_dstrTagAction,                  NULL, NULL, 0, NULL, &dstrValue   ) );

    if (!DRM_UTL_DSTRStringsEqual( &dstrValue, &g_dstrWMDRM_RIGHT_PLAYBACK ))
    {
        ChkDR(DRM_E_INVALIDRIGHT);
    }
    ChkDR( DRM_XML_GetNode( &dstrData,  &g_dstrTagCanBind,                 NULL, NULL, 0, NULL, &dstrValue   ) );

    ChkDR( wcsntol( dstrValue.pwszString, dstrValue.cchString, &lCanBind ) );
    if (lCanBind != 1)
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    ChkDR( DRM_XML_GetNode( &dstrData,  &g_dstrTagKID,                     NULL, NULL, 0, NULL, &dstrValue   ) );

    if ( CB_DSTR(&dstrValue) >  DRM_MAX_HEADERDATASIZE 
      || CB_DSTR(&dstrValue) == 0)
    {
        ChkDR(DRM_E_INVALIDARG);
    }
    MEMCPY(pContext->rgbDRMHeaderData, PB_DSTR(&dstrValue), CB_DSTR(&dstrValue));
    pContext->cbHeaderData     = CB_DSTR(&dstrValue);
    pContext->eHeaderInContext = eKidOnly;

    pdstrRights [0] = (DRM_CONST_STRING *) &g_dstrWMDRM_RIGHT_PLAYBACK;

    dr = DRM_MGR_Bind( pDrmContext, 
                       pdstrRights,
                       NO_OF(pdstrRights),
                       NULL,
                       NULL,
                       NULL);

    if( DRM_FAILED( dr ) )
    {
        if ( dr == DRM_E_CLK_NOT_SET )
        {
            *pCategory = WM_DRM_LICENSE_STATE_UNLIM;
        }
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }
   *pCategory = WM_DRM_LICENSE_STATE_UNLIM;
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MGR_GetLicenseState", g_pwszLeavingFunction);
    return dr;                                           

}

static DRM_RESULT _DeleteLicenses(
    IN       DRM_MANAGER_CONTEXT_INTERNAL *f_pContext,
    IN       DRM_CONST_STRING             *f_pdstrLGPubKey,
    IN       DRM_KID                      *f_pKID,
        OUT  DRM_DWORD                    *f_pcLicDeleted)
{
    DRM_RESULT          dr           = DRM_SUCCESS;
    DRM_DWORD           cbLicSize    = 0;
    DRM_CONST_STRING    dstrLicense  = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrLGPubkey = EMPTY_DRM_STRING;

    ChkArg( f_pContext       != NULL
         && f_pdstrLGPubKey  != NULL
         && f_pKID           != NULL
         && f_pcLicDeleted   != NULL);

    *f_pcLicDeleted = 0;

    dr = DRM_LST_InitEnum(&f_pContext->oLicStoreContext, f_pKID, FALSE,  &f_pContext->oLicEnum[0]);

    if (DRM_SUCCEEDED(dr))
    {
        while( TRUE )
        {   
            DRM_HDS_SLOT_HINT slotHint;

            dr = DRM_LST_EnumNext( &f_pContext->oLicEnum[0],
                                    NULL, 
                                   &f_pContext->oFFLicense.rglid [0], 
                                   &slotHint,
                                   &cbLicSize); 

            if (dr == DRM_E_NOMORE)
            {
                dr = DRM_SUCCESS;
                goto ErrorExit;
            }
            ChkDR( dr );

            if (cbLicSize > SIZEOF(f_pContext->rgbDRMLicense))
            {
                /*Can't read the license. Just continue...*/
                continue;
            }

            ChkDRContinue( DRM_LST_GetLicense( &f_pContext->oLicStoreContext,
                                                f_pKID,
                                               &f_pContext->oFFLicense.rglid [0],
                                               &slotHint, 
                                                f_pContext->rgbDRMLicense,
                                               &cbLicSize) );

            DSTR_FROM_PB(&dstrLicense, f_pContext->rgbDRMLicense, cbLicSize);

            ChkDRContinue( DRM_LIC_GetAttribute( &dstrLicense, 
                                                 &g_dstrTagRevocationPubKey, 
                                                  DRM_LICENSE_ATTRIB_META_ATTRIBUTE, 
                                                  NULL, 
                                                 &dstrLGPubkey, 
                                                  0 ) );

            if (DRM_UTL_DSTRStringsEqual( &dstrLGPubkey, f_pdstrLGPubKey) )
            {
                dr = DRM_LST_EnumDelete(&f_pContext->oLicEnum[0]);
                if (DRM_SUCCEEDED(dr))
                {
                    (*f_pcLicDeleted)++;  
                }

#if DRM_SUPPORT_LICENSE_SYNC
                (void) DRM_SNC_DeleteKID( &f_pContext->contextSync, f_pKID);
#endif
            }
        }
    }

ErrorExit:
    return dr;                                           
}


/*
<RESPONSE type="dlrb"> 
<DATA>
    <VERSION value="verionval"/>
    <LGPUBKEY value="lgapubkeyval"/>
    <KID value="kid1"/>
    <KID value="kid2"/>
    <!-- ...-->
</DATA>
<SIGNATURE>
    <HASHALGORITH type="SHA"/>
    <SIGNALGORITHM type="MSDRM"/>
    <VALUE>...</VALUE>
</SIGNATURE>
</RESPONSE>
*/


static DRM_RESULT _ProcessLicenseRevocationList(
    IN       DRM_MANAGER_CONTEXT_INTERNAL *f_pContext,
    IN       DRM_DWORD                     f_iKids,
    IN       DRM_DWORD                     f_cKids,
    IN       DRM_BYTE                     *f_pbList,
    IN       DRM_DWORD                     f_cbList,
        OUT  DRM_DWORD                    *f_piKids,
        OUT  DRM_DWORD                    *f_pcLicDeleted)
{
    DRM_DWORD           iKids       = 0;
    DRM_DWORD           cbBuffer    = 0;
    DRM_RESULT          dr          = DRM_SUCCESS;
    DRM_CONST_STRING    dstrRoot    = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrData    = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrPubKey  = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrSign    = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrBlob    = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrValue   = EMPTY_DRM_STRING;
    

    ChkArg( f_pContext     != NULL
         && f_pbList       != NULL
         && f_piKids       != NULL
         && f_pcLicDeleted != NULL
         && f_cbList       > 0);

    *f_piKids       = 0;
    *f_pcLicDeleted = 0;

    if(f_cKids == 0)
    {
        goto ErrorExit;
    }

    DSTR_FROM_PB(&dstrBlob, f_pbList, f_cbList);

    ChkDR( DRM_XML_GetNode( &dstrBlob, &g_dstrTagDeviceLicenseRevocationRoot,  NULL, NULL, 0, NULL,       &dstrRoot    ) );
    ChkDR( DRM_XML_GetNode( &dstrRoot, &g_dstrTagData,                         NULL, NULL, 0, NULL,       &dstrData    ) );
    ChkDR( DRM_XML_GetNode( &dstrData, &g_dstrTagRevocationPubKey,             NULL, NULL, 0, &dstrValue, NULL         ) );

    ChkDR( DRM_XML_GetNodeAttribute( &dstrValue, &g_dstrLabelValue, &dstrPubKey ) );


    /*Check the signature first*/
    
    ChkDR( DRM_XML_GetNode( &dstrRoot, &g_dstrTagSignature, NULL, NULL, 0, NULL, &dstrSign  ) );
    ChkDR( DRM_XML_GetNode( &dstrSign, &g_dstrTagValue,     NULL, NULL, 0, NULL, &dstrValue ) );

    /*Base64 decode Pubkey and this signature*/
    cbBuffer = SIZEOF(PUBKEY);
    ChkDR(DRM_B64_DecodeW( &dstrPubKey, &cbBuffer, (DRM_BYTE *)&f_pContext->oBlackBoxContext.CryptoContext.pubKey, 0) );

    cbBuffer = SIZEOF(f_pContext->oBlackBoxContext.CryptoContext.signature);
    ChkDR(DRM_B64_DecodeW( &dstrValue, &cbBuffer, f_pContext->oBlackBoxContext.CryptoContext.signature, 0) );

    ChkDR( DRM_XML_GetNode( &dstrRoot, &g_dstrTagData, NULL, NULL, 0, &dstrValue, NULL ) );
    
    
    if (! DRM_PK_Verify( f_pContext->oBlackBoxContext.CryptoContext.rgbCryptoContext, 
                        &f_pContext->oBlackBoxContext.CryptoContext.pubKey, 
                         PB_DSTR(&dstrValue), 
                         CB_DSTR(&dstrValue), 
                         f_pContext->oBlackBoxContext.CryptoContext.signature))
    {
        ChkDR(DRM_E_INVALID_SIGNATURE);
    }

    f_pContext->fLicStoreOpen = FALSE;
    ChkDR( DRM_LST_Open( &f_pContext->oLicStoreContext, &f_pContext->oHdsContext ) ); 
    f_pContext->fLicStoreOpen = TRUE;


    for (iKids = f_iKids; iKids < f_iKids + f_cKids; iKids++, (*f_piKids)++)
    {
       DRM_DWORD  nDeleted = 0;
        
        /*reuse dstrBlob*/

        dr = DRM_XML_GetNode( &dstrData, &g_dstrTagKID, NULL, NULL, iKids, &dstrBlob, NULL );
        
        if ( DRM_SUCCEEDED( dr ) )
        {

             /*Call function to delete licenses*/
            ChkDRContinue( DRM_XML_GetNodeAttribute( &dstrBlob, &g_dstrLabelValue, &dstrValue ) );

            ChkDRContinue( DRM_UTL_DecodeKID( &dstrValue, &f_pContext->KID ) );

            (void)_DeleteLicenses( f_pContext, 
                                  &dstrPubKey,
                                  &f_pContext->KID,
                                  &nDeleted);

            *f_pcLicDeleted += nDeleted;
        }
        else
        {
            if (dr == DRM_E_XMLNOTFOUND)
            {
                /* no more KIDS found */
                dr = DRM_SUCCESS;
                break;
            }
            ChkDR(dr);  /* other errors */
        }

    }


ErrorExit:

    if (f_pContext->fLicStoreOpen)
    {
        (void) DRM_LST_Close( &f_pContext->oLicStoreContext );
    }
   
    return dr;                                           
}


/*****************************************************************************
** Function:    DRM_MGR_GetRevocationList
**
** Synopsis:    open the secure store and get the version number and buffer containing the 
**              revocation list currently stored based upon the type of revocation list
**              specified
**
** Arguments:   [f_pDrmContext]        -- Opaque DRM Manager context initialized by a call to 
**                                        DRM_MGR_Initialize.
**              [f_eRevType]           -- Type of Revocation List and Version to retrieve.
**              [f_pbBuffer]           --
**              [f_pcbBuffer]          -- size of f_pbBuffer, in bytes, returns size of  
**                                        revocation list
**              [f_pdwVersion]         -- Returns version of revocation list.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              DRM_E_PRIVKEYREADERROR if BB context not initialized or
**              DRM_E_FILENOTFOUND if revocation list doesn't exist in secure store or
**              DRM_E_BUFFERTOOSMALL if *f_pcbBuffer smaller than required buffer size to return 
**                                     revocation list or
**              any return code as defined in drmresults.h
*****************************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetRevocationList(
    IN        DRM_MANAGER_CONTEXT        *f_pDrmContext,
    IN        DRM_REVOCATION_TYPE_ENUM    f_eRevType,
    OUT       DRM_BYTE                   *f_pbBuffer,
    IN OUT    DRM_DWORD                  *f_pcbBuffer,
    OUT       DRM_DWORD                  *f_pdwVersion)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*) f_pDrmContext;
    DRM_BYTE   rgbPassword [__CB_DECL(SHA_DIGEST_LEN)] = { 0x00 };   
    DRM_SECSTORE_CONTEXT oSecStoreContext;
    DRM_BB_CONTEXT *poBlackBoxContext = NULL;
    DRM_SECSTORE_CONTEXT *poSecStoreContext = NULL;
    DRM_DWORD cbRevocationBuffer = 0;
   
    ChkArg( f_pDrmContext && f_pdwVersion );

    poBlackBoxContext = &pContext->oBlackBoxContext;
    poSecStoreContext = &pContext->oSecStoreGlobalContext;

#if DRM_SUPPORT_REVOCATION
    ChkDR( DRM_SST_CreateGlobalStorePassword( rgbPassword, (DRM_BYTE*)poBlackBoxContext ) );

    ChkDR( DRM_SST_OpenKeyTokens(  poSecStoreContext, 
                        (DRM_ID *)&g_rgbSecStoreGlobalName, 
                                   NULL,
                                   rgbPassword, 
                                   DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS,
                                   SECURE_STORE_GLOBAL_DATA, 
                                  &pContext->oHdsContext ) );

    ChkDR( _CreateRevocationStorePassword( poBlackBoxContext, rgbPassword ) );

    cbRevocationBuffer = pContext->cbRevocationBuffer;
    switch(f_eRevType)
    {
    case WM_DRM_REVOCATION_TYPE_APP:
        {
#if DRM_SUPPORT_APP_REVOCATION
            if( f_pcbBuffer == NULL )
            {
                /* The caller is likely only interested in the version */
                dr = DRM_RVK_GetCurrentAppRevocationList(
                    poSecStoreContext,
                    rgbPassword,
                    pContext->pbRevocationBuffer,
                    &cbRevocationBuffer,
                    &pContext->oHdsContext,
                    f_pdwVersion );
                if( dr == DRM_E_BUFFERTOOSMALL )
                {
                    dr = DRM_E_REVOCATION_BUFFERTOOSMALL;
                }
                ChkDR( dr );
            }
            else
            {
                ChkDR( DRM_RVK_GetCurrentAppRevocationList(
                    poSecStoreContext,
                    rgbPassword,
                    f_pbBuffer,
                    f_pcbBuffer,
                    &pContext->oHdsContext,
                    f_pdwVersion ) );
            }
#else
            ChkDR( DRM_E_NOTIMPL );
#endif /* DRM_SUPPORT_APP_REVOCATION */
        }
        break;
    case WM_DRM_REVOCATION_TYPE_WMDRMPD:
        {
#if DRM_SUPPORT_DEVICE_REVOCATION
            if( f_pcbBuffer == NULL )
            {
                /* The caller is likely only interested in the version */
                dr = DRM_RVK_GetDeviceRevocationList(
                    &poBlackBoxContext->CryptoContext,
                    poSecStoreContext,
                    &pContext->oHdsContext,
                    rgbPassword,
                    pContext->pbRevocationBuffer,
                    &cbRevocationBuffer,
                    f_pdwVersion );
                if( dr == DRM_E_BUFFERTOOSMALL )
                {
                    dr = DRM_E_REVOCATION_BUFFERTOOSMALL;
                }
                ChkDR( dr );
            }
            else
            {
                ChkDR( DRM_RVK_GetDeviceRevocationList(
                    &poBlackBoxContext->CryptoContext,
                    poSecStoreContext,
                    &pContext->oHdsContext,
                    rgbPassword,
                    f_pbBuffer,
                    f_pcbBuffer,
                    f_pdwVersion ) );
            }
#else
            ChkDR( DRM_E_NOTIMPL );
#endif  /* DRM_SUPPORT_DEVICE_REVOCATION */
        }
        break;
    case WM_DRM_REVOCATION_TYPE_WMDRMND:
        {
#if DRM_SUPPORT_WMDRMNET
            if( f_pcbBuffer == NULL )
            {
                dr = DRM_RVK_GetWMDRMNETList(
                    &poBlackBoxContext->CryptoContext,
                    poSecStoreContext,
                    &pContext->oHdsContext,
                    rgbPassword,
                    pContext->pbRevocationBuffer,
                    &cbRevocationBuffer,
                    f_pdwVersion );
                if( dr == DRM_E_BUFFERTOOSMALL )
                {
                    dr = DRM_E_REVOCATION_BUFFERTOOSMALL;
                }
                ChkDR( dr );
            }
            else
            {
                ChkDR( DRM_RVK_GetWMDRMNETList(
                    &poBlackBoxContext->CryptoContext,
                    poSecStoreContext,
                    &pContext->oHdsContext,
                    rgbPassword,
                    f_pbBuffer,
                    f_pcbBuffer,
                    f_pdwVersion ) );
            }
#else
            ChkDR( DRM_E_NOTIMPL );
#endif /* DRM_SUPPORT_WMDRMNET */
        }
        break;
    default:
        ChkDR(DRM_E_INVALIDARG);
        break;
    }

#else
    ChkDR( DRM_E_NOTIMPL );
#endif /* DRM_SUPPORT_REVOCATION */


ErrorExit:
    poSecStoreContext->fInited = TRUE;
    DRM_SST_CloseKey( poSecStoreContext, &pContext->oHdsContext );
    return dr;
}

/*****************************************************************************
** Function:    DRM_MGR_GetRevocationListVersion
**
** Synopsis:    open the secure store and get the version number for the 
**              revocation list currently stored based upon the type of revocation list
**              specified
**
** Arguments:   [f_pDrmContext]        -- Opaque DRM Manager context initialized by a call to 
**                                        DRM_MGR_Initialize.
**              [f_eRevType]           -- Type of Revocation List and Version to retrieve.
**              [f_pdwVersion]         -- Returns version of revocation list.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              DRM_E_PRIVKEYREADERROR if BB context not initialized or
**              DRM_E_FILENOTFOUND if revocation list doesn't exist in secure store or
**              any return code as defined in drmresults.h
*****************************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetRevocationListVersion(
    IN        DRM_MANAGER_CONTEXT        *f_pDrmContext,
    IN        DRM_REVOCATION_TYPE_ENUM    f_eRevType,
    OUT       DRM_DWORD                  *f_pdwVersion)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL*)f_pDrmContext;
    
    ChkArg( f_pDrmContext && f_pdwVersion );

    ChkDR( DRM_MGR_GetRevocationList( f_pDrmContext, 
                            f_eRevType, 
                            NULL, 
                            NULL, 
                            f_pdwVersion ) );

ErrorExit:

    return dr;
}


#if DRM_SUPPORT_REVOCATION
/*****************************************************************************
** Function:    DRM_MGR_GetRevInfo
**
** Synopsis:    open the secure store and get the RevInfo structure
**
** Arguments:   [f_pDrmContext]        -- Opaque DRM Manager context initialized by a call to 
**                                        DRM_MGR_Initialize.
**              [f_eRevType]           -- Type of Revocation List and Version to retrieve.
**              [f_pdwVersion]         -- Returns version of revocation list.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              DRM_E_PRIVKEYREADERROR if BB context not initialized or
**              DRM_E_FILENOTFOUND if revocation list doesn't exist in secure store or
**              any return code as defined in drmresults.h
*****************************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetRevInfo(
    IN     DRM_MANAGER_CONTEXT *f_pDrmContext,
       OUT DRM_BYTE            *f_pbRevInfo,
    IN OUT DRM_DWORD           *f_pcbRevInfo)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_RLVI   RLVI;
    DRM_DWORD  cbRevocationBuffer = 0;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL *) f_pDrmContext;

    MEMSET( &RLVI, 0, SIZEOF( DRM_RLVI ) );

    ChkArg( f_pDrmContext != NULL
            && f_pcbRevInfo != NULL );

    cbRevocationBuffer = pContext->cbRevocationBuffer;
    dr = DRM_RVK_GetCurrentRevocationInfo(&pContext->oSecStoreGlobalContext,
                                            &pContext->oBlackBoxContext,
                                            &pContext->oHdsContext,
                                            pContext->pbRevocationBuffer,
                                            &cbRevocationBuffer,
                                            &RLVI);
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        dr = DRM_E_REVOCATION_BUFFERTOOSMALL;
    }
    ChkDR( dr );

    if( cbRevocationBuffer > 0 )
    {
        /* Base64 encode expects the number of unicode characters in the buffer, not bytes */
        *f_pcbRevInfo /= SIZEOF( DRM_WCHAR );
        
        dr = DRM_B64_EncodeW( pContext->pbRevocationBuffer,
                            cbRevocationBuffer,
                (DRM_WCHAR*)f_pbRevInfo,
                            f_pcbRevInfo,
                            0 );
        
        *f_pcbRevInfo *= SIZEOF( DRM_WCHAR );
        ChkDR( dr );
    }
    else
    {
        *f_pcbRevInfo = 0;
    }


ErrorExit:

    return dr;
}
#endif /* DRM_SUPPORT_REVOCATION */



/**********************************************************************
**
** Function:    DRM_MGR_GetWMDRMNETMinAppSec
**
** Synopsis:    Gets License minimum application security level.  Must be called
**              after a successful bind via DRM_MGR_Bind and prior to DRM_MGR_Commit.
**
** Arguments:   [f_pDrmContext]        -- Opaque DRM Manager context initialized by a call to 
**                                        DRM_MGR_Initialize
**              [f_pdwMinAppSec]       -- Returns License Chains minimum app security level. 
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              DRM_E_LICENSENOTBOUND if license hasn't been bound by calling DRM_MGR_Bind successfully
**              any return code as defined in drmrestults.h
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetWMDRMNETMinAppSec(
    IN        DRM_MANAGER_CONTEXT        *f_pDrmContext,
    OUT       DRM_DWORD                  *f_pdwMinAppSec)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext = (DRM_MANAGER_CONTEXT_INTERNAL *)f_pDrmContext;

#ifndef DRM_SUPPORT_WMDRMNET
    ChkDR( DRM_E_NOTIMPL );
#else

    ChkArg( f_pDrmContext && f_pdwMinAppSec );

    if( !pContext->fBindThenCommit )
    {
        ChkDR( DRM_E_LICENSENOTBOUND );
    }

    *f_pdwMinAppSec = pContext->oFFLicense.dwMinimumRequiredAppSec;

#endif /* DRM_SUPPORT_WMDRMNET */

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_MGR_ProcessCommand(
    IN       DRM_MANAGER_CONTEXT   *f_pcontextMGR,
    IN       DRM_DWORD              f_dwOperationCode,
    IN       DRM_DWORD              f_dwRequestArgument1,
    IN       DRM_DWORD              f_dwRequestArgument2,
    IN       DRM_DWORD              f_dwRequestArgument3,
    IN       DRM_DWORD              f_dwRequestArgument4,
    IN       DRM_BYTE              *f_pbRequestData,
    IN       DRM_DWORD              f_dwRequestDataLength,
        OUT  DRM_DWORD             *f_pdwResponseResult1,
        OUT  DRM_DWORD             *f_pdwResponseResult2,
        OUT  DRM_DWORD             *f_pdwResponseResult3,
        OUT  DRM_DWORD             *f_pdwResponseResult4)
{

    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT_INTERNAL *pContext   = (DRM_MANAGER_CONTEXT_INTERNAL *) f_pcontextMGR;

    ChkArg( f_pcontextMGR != NULL);

      

    switch( f_dwOperationCode )
    {
        case OpGetVersion:
        {
           ChkArg(f_pdwResponseResult1 != NULL 
               && f_pdwResponseResult2 != NULL);

          *f_pdwResponseResult1 = JANUS_MAJOR_VERSION;   /* 10 */
          *f_pdwResponseResult2 = JANUS_MINOR_VERSION;   /* 1  */
           dr = DRM_SUCCESS;
           break;
       }
       case OpProcessLicenseRevocationList:
       {
          ChkDR(_ProcessLicenseRevocationList( pContext, 
                                               f_dwRequestArgument1, 
                                               f_dwRequestArgument2,
                                               f_pbRequestData,
                                               f_dwRequestDataLength,
                                               f_pdwResponseResult1,
                                               f_pdwResponseResult2));
          
          break;
       }
       default:
          dr = DRM_E_NOTIMPL;
    }

ErrorExit:

    return dr;           
}

DRM_RESULT DRM_API DRM_MGR_ProcessRequest( 
    IN       DRM_MANAGER_CONTEXT   *f_pcontextMGR,
    IN       DRM_DWORD              f_dwOperationCode,
    IN       DRM_DWORD              f_dwRequestArgument1,
    IN       DRM_DWORD              f_dwRequestArgument2,
    IN       DRM_DWORD              f_dwRequestArgument3,
    IN       DRM_DWORD              f_dwRequestArgument4,
        OUT  DRM_DWORD             *f_pdwResponseResult1,
        OUT  DRM_DWORD             *f_pdwResponseResult2,
        OUT  DRM_DWORD             *f_pdwResponseResult3,
        OUT  DRM_DWORD             *f_pdwResponseResult4,
        OUT  DRM_BYTE              *f_pbResponseData,
        OUT  DRM_DWORD             *f_pdwResponseDataLength)

{
      return DRM_E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmmeterimpl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMMETERIMPL_H__
#define __DRMMETERIMPL_H__

#ifdef __cplusplus
extern "C" {
#endif

DRM_RESULT DRM_API DRM_MTR_GetAllData (
    IN     DRM_METERING_CONTEXT *pcontextMetering,
       OUT DRM_BYTE             *pbData,
    IN OUT DRM_DWORD            *pcbData);

DRM_RESULT DRM_API DRM_MTR_InitEnum (
    IN const DRM_MID                   *pmid,
       OUT   DRM_METERINGENUM_CONTEXT  *pcontextMeteringEnum,
    IN       DRM_HDS_CONTEXT           *pcontextHDS);

DRM_RESULT DRM_API DRM_MTR_EnumNext ( 
    IN     DRM_METERINGENUM_CONTEXT *pcontextMeteringEnum,
       OUT DRM_KID                  *pkid,
       OUT DRM_DWORD                *pcbData);

#ifdef __cplusplus
}
#endif

#endif /* __DRMMETERIMPL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmmanager.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMMANAGER_H__
#define __DRMMANAGER_H__

#include <drmrevocation.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct __tagDRM_MANAGER_DECRYPT_CONTEXT
{
    DRM_BYTE rgbBuffer[ __CB_DECL( SIZEOF( DRM_CIPHER_CONTEXT) ) ];
}DRM_MANAGER_DECRYPT_CONTEXT;

typedef struct __tagDRM_MANAGER_ENCRYPT_CONTEXT
{
    DRM_BYTE rgbBuffer[ __CB_DECL( SIZEOF( DRM_CIPHER_CONTEXT) )];
}DRM_MANAGER_ENCRYPT_CONTEXT;


#if !DRM_LICENSE_STATE_TYPES_DEFINED
#define DRM_LICENSE_STATE_TYPES_DEFINED 1
/* Enum and structure for license properties queries */
typedef enum DRM_LICENSE_STATE_CATEGORY
{
    WM_DRM_LICENSE_STATE_NORIGHT = 0,
    WM_DRM_LICENSE_STATE_UNLIM,
    WM_DRM_LICENSE_STATE_COUNT,
    WM_DRM_LICENSE_STATE_FROM,
    WM_DRM_LICENSE_STATE_UNTIL,
    WM_DRM_LICENSE_STATE_FROM_UNTIL,
    WM_DRM_LICENSE_STATE_COUNT_FROM,
    WM_DRM_LICENSE_STATE_COUNT_UNTIL,
    WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL,
    WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE,
    WM_DRM_LICENSE_STATE_FORCE_SYNC
} DRM_LICENSE_STATE_CATEGORY;

typedef struct _DRM_LICENSE_STATE_DATA
{
    DRM_DWORD dwStreamId;                       /* 0 -> All streams, != 0 -> A particular stream. */
    DRM_DWORD dwCategory;                       /* Indicates the category of string to be displayed. */
    DRM_DWORD dwNumCounts;                      /* Number of items supplied in dwCount. */
    DRM_DWORD dwCount[4];                       /* Up to 4 counts. */
    DRM_DWORD dwNumDates;                       /* Number of items supplied in dwDate. */
    DRMFILETIME datetime[4];                    /* Up to 4 dates. */
    DRM_DWORD dwVague;                          /* 0 -> certain, 1 -> atleast.  (There could be more */
                                                /*               licenses. Aggregation not possible.) */
} DRM_LICENSE_STATE_DATA;

#endif

typedef enum DRM_DEVICE_PROPERTY
{
    WM_DRM_CLIENTINFO = 0,
    WM_DRM_DRMVERSION,
    WM_DRM_SECURITYVERSION,
    WM_DRM_V2_HEADER_KID
} DRM_DEVICE_PROPERTY;

#define JANUS_MAJOR_VERSION                 10
#define JANUS_MINOR_VERSION                 1

/* Strings to be used from DRMManager */
extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_PLAYBACK;

#include <drmviewprops.h>

typedef struct __tagDRM_MANAGER_CONTEXT
{
    /* This data is Opaque.  Do not set any value in it. */
    DRM_BYTE rgbOpaqueBuffer[ __CB_DECL( DRM_DRMMANAGER_CONTEXT_BUFFER_SIZE ) ];
} DRM_MANAGER_CONTEXT;

#define DRM_METER_RESPONSE_PARTIAL 0x00000001

/**********************************************************************
**
** Function:    DRM_MGR_Initialize
**
** Synopsis:    Initializes DRM.  The context that is initialized after this call can be used in later calls
**              to most DRM functions to perform a varety of DRM related tasks.
**
** Arguments:   [pDrmContext]          -- Opaque DRM Manager context
**              [pdstrDeviceStoreName] -- Path DRM should use as the current store.
**
** Returns:     DRM_SUCCESS on success or failed with,
**              DRM_E_NEEDDEVCERTINDIV if the device needs to be individualized
**              DRM_E_INVALIDARG if either parameter is incorrect or 
**              other errors found in drmresults.h
**
** Notes:       The pDrmContext should be uninitialized with a call to DRM_MGR_Uninitialize
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_Initialize( 
    IN       DRM_MANAGER_CONTEXT  *pDrmContext,
    IN const DRM_CONST_STRING     *pdstrDeviceStoreName );

/**********************************************************************
**
** Function:    DRM_MGR_Uninitialize
**
** Synopsis:    Allows DRM to shutdown any allocated resources.
**
** Arguments:   [pDrmContext] -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**
** Returns:     None.
**
**********************************************************************/
DRM_VOID DRM_API DRM_MGR_Uninitialize( 
    IN DRM_MANAGER_CONTEXT *pDrmContext );


/**********************************************************************
**
** Function:    DRM_MGR_Reinitialize
**
** Synopsis:    Cleans up the header information stored in the DRM context.
**              Useful when loading a mix of content with v1 and v2 headers. Call this
**              function in between calls to SetV1Header or SetV2Header.
**
** Arguments:   [pDrmContext] -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the argument is invalid.
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_Reinitialize( 
    IN       DRM_MANAGER_CONTEXT  *pDrmContext );


/**********************************************************************
**
** Function:    DRM_MGR_SetRevocationBuffer
**
** Synopsis:    Passes in a temporary buffer to be used by revocation code
**
** Arguments:   [pDrmContext]          -- Opaque DRM Manager context
**              [pbRevocationBuffer]   -- Pointer to a buffer
**              [cbRevocationBuffer]   -- Size of the buffer in bytes
**
** Returns:     DRM_SUCCESS on success or failed with,
**              DRM_E_INVALIDARG if a parameter is incorrect or 
**              other errors found in drmresults.h
**
** Notes:       
**
**********************************************************************/

DRM_RESULT DRM_API DRM_MGR_SetRevocationBuffer( 
    IN       DRM_MANAGER_CONTEXT  *pDrmContext,
    IN       DRM_BYTE             *pbRevocationBuffer,
    IN       DRM_DWORD             cbRevocationBuffer );

/* Recommeded revocation buffer size */
#define REVOCATION_BUFFER_SIZE 30*1024


/**********************************************************************
**
** Function:    DRM_MGR_GetRevocationBuffer
**
** Synopsis:    Gets the temporary buffer to be used by revocation code
**
** Arguments:   [pDrmContext]          -- Opaque DRM Manager context
**              [ppbRevocationBuffer]   -- Pointer to a pointer that will point to the revocation buffer
**              [pcbRevocationBuffer]   -- Pointer to a DWORD to hold the size of the revocation buffer in bytes
**
** Returns:     DRM_SUCCESS on success or failed with,
**              DRM_E_INVALIDARG if a parameter is incorrect or 
**              other errors found in drmresults.h
**
** Notes:       
**
**********************************************************************/

DRM_RESULT DRM_API DRM_MGR_GetRevocationBuffer( 
    IN       DRM_MANAGER_CONTEXT  *pDrmContext,
    OUT      DRM_BYTE            **ppbRevocationBuffer,
    OUT      DRM_DWORD            *pcbRevocationBuffer );


/**********************************************************************
**
** Function:    DRM_MGR_UpdateRevocationVersionsCache
**
** Synopsis:    Loads revocation versions from the HDS and caches them for use in DRM_MGR_Bind
**
** Arguments:   [pDrmContext]          -- Opaque DRM Manager context
**              [pfUpdated]            -- Optional pointer to hold a boolean indication of whether any revocation 
**                                        data in the cache was updated
**
** Returns:     DRM_SUCCESS on success or failed with,
**              DRM_E_INVALIDARG if a parameter is incorrect or 
**              other errors found in drmresults.h
**
** Notes:       
**
**********************************************************************/

DRM_RESULT DRM_API DRM_MGR_UpdateRevocationVersionsCache( 
 IN OUT DRM_MANAGER_CONTEXT          *pDrmContext,
    OUT DRM_BOOL                     *pfUpdated);

/**********************************************************************
**
** Function:    DRM_MGR_SetV2Header
**
** Synopsis:    Sets the DRM XML header blob.  This allows the DRM runtime to have enough information to attempt to
**              perform DRM tasks that related to specific peices of content, such as Bind and GetLicenseStateData.
**
** Arguments:   [pDrmContext] -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [pbHeader]    -- Pointer to the DRM header.  For ASF content this is found in the ContentEncryptionObjEx ASF header.
**              [cbHeader]    -- Count of bytes in pbHeader
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_SetV2Header(
    IN       DRM_MANAGER_CONTEXT *pDrmContext,
    IN const DRM_BYTE            *pbHeader,
    IN       DRM_DWORD            cbHeader );

/**********************************************************************
**
** Function:    DRM_MGR_SetV1Header
**
** Synopsis:    Set the DRMv1 content header information that may have been found in the ASF header.
**
** Arguments:   [pDrmContext]  -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [pbKeyID]      -- Array of bytes that contains the KeyID from the V1 ASF header object.
**              [cbKeyID]      -- Count of bytes in pbKeyID
**              [pbSecretData] -- Array of bytes that contains the SecretData from the V1 ASF header
**              [cbSecretData] -- COunt of bytes in pbSecretData
**              [pbURL]        -- Array of bytes that contains the license acquisition URL from the V1 ASF header
**              [cbURL]        -- Count of bytes in pbURL
**
** Returns:     DRM_SUCCESS on success or DRM_E_INVALIDARG if the arguments are invalid.
**
** Notes:       WM Device DRM doesn't understand the DRMv1 header data enough to acquire licenses and use those licenses.
**              It is possible however that DRMv1 content was transferred to a device with a V2 license and thus we must
**              understand enough about it's header to use it.
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_SetV1Header(
    IN       DRM_MANAGER_CONTEXT *pDrmContext,
    IN const DRM_BYTE            *pbKeyID,
    IN       DRM_DWORD            cbKeyID,
    IN const DRM_BYTE            *pbSecretData,
    IN       DRM_DWORD            cbSecretData,
    IN const DRM_BYTE            *pbURL,
    IN       DRM_DWORD            cbURL);

#if DRM_SUPPORT_DLA
/**********************************************************************
**
** Function:    DRM_MGR_GenerateLicenseChallenge
**
** Synopsis:    Using the current DRM header set by SetV2Header DRM will generate a liecense challenge that can be sent
**              to a license server.  The license server generally issues a response that should be passed to 
**              DRM_MGR_ProcessLicenseResponse.
**
** Arguments:   [pDrmContext]   -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [ppdstrRights]  -- An array of DSTR*s representing rights that the caller would like to access the content with.
**              [cRights]       -- Count of the pointers in the rgpdstrRights array.
**              [pwszUrl]       -- user allocated buffer to get URL in WCHAR. Null Terminated.
**              [pcchUrl]       -- character count of pwszUrl. Can be NULL if URL is not required.
**              [pszChallenge]  -- The license challenge will be copied into this string buffer
**              [pcchChallenge] -- Length in characters of the pcchChallenge buffer.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_V1_NOT_SUPPORTED if a V1 content header was only set,
**              DRM_E_HEADER_NOT_SET if no content header was set,
**              DRM_E_BUFFERTOOSMALL if the input pszURL or pszChallenge buffers were too small,
**              or other error codes as defined in drmresults.h
**
** Notes:       DRM_MGR_SetV2Header must be called prior to this function.  On return from this function the character
**              count parameters will be updated with the number of characters copied to the buffer if successful
**              or the required length of the buffer if the current buffer size is too small.
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_GenerateLicenseChallenge(
    IN       DRM_MANAGER_CONTEXT  *pDrmContext,
    IN const DRM_CONST_STRING    **ppdstrRights, /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD             cRights,
       OUT   DRM_WCHAR            *pwszUrl,
    IN OUT   DRM_DWORD            *pcchUrl,
       OUT   DRM_CHAR             *pszChallenge,
    IN OUT   DRM_DWORD            *pcchChallenge );


/**********************************************************************
**
** Function:    DRM_MGR_GetDeviceProperty
**
** Synopsis:    Retrieves clients properties.  Available properties are defined in the enum DRM_DEVICE_PROPERTY.
**
** Arguments:   [pDrmContext]   -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [eProperty]     -- The property to retrieve.  Must be a value from the DRM_DEVICE_PROPERTY enum
**              [pbProperty]    -- Buffer to receive the property value.  The format of the data depends upon the property.
**              [pcbProperty]   -- Count of bytes in pbProperty
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_HEADER_NOT_SET if no content header was set,
**              DRM_E_BUFFERTOOSMALL if the input pbProperty buffer is too small,
**              or other error codes as defined in drmresults.h
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetDeviceProperty(
    IN       DRM_MANAGER_CONTEXT  *pDrmContext,
    IN       DRM_DEVICE_PROPERTY   eProperty, 
       OUT   DRM_BYTE             *pbProperty,
    IN OUT   DRM_DWORD            *pcbProperty );
#endif

/**********************************************************************
**
** Function:    DRM_MGR_ProcessLicenseResponse
**
** Synopsis:    Process a response from a license server.  Usually this is a series of licenses that will ultimately be
**              stored in the device license store.
**
** Arguments:   [f_pDrmContext]       -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [f_pfnCallback]       -- Pointer to a callback function which is called for each license in response. Can be NULL.
**              [f_pvCallbackContext] -- User context returned in callback function. Can be NULL
**              [f_pbResponse]        -- Pointer to a response blob from a license server
**              [f_cbResponse]        -- Count of bytes in pbResponse
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if the arguments are invalid
**              or any other value as defined in drmresults.h
**
** Notes:       pbResponse is not declared as const.  This buffer will be modified in place to conserve device memory.
**              If caller needs a copy unmodified they should copy it elsewhere first.
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_ProcessLicenseResponse(
    IN DRM_MANAGER_CONTEXT     *f_pDrmContext,
    IN pfnStoreLicenseCallback  f_pfnCallback,
    IN DRM_VOID                *f_pvCallbackContext,
    IN DRM_BYTE                *f_pbResponse,
    IN DRM_DWORD                f_cbResponse );

/**********************************************************************
**
** Function:    DRM_MGR_Bind
**
** Synopsis:    Ask DRM to a complete search for a license that can be used to render the content matching the header
**              set in a call to DRM_MGR_SetV2Header.
**
** Arguments:   [pDrmContext]             -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [rgpdstrRights]           -- An array of strings representing rights that the caller would like to access the content with.
**              [cRights]                 -- Count of the pointers in the rgpdstrRights array.
**              [pfnOutputLevelsCallback] -- A pointer to a callback function that provides information to the caller about output restrictions in licenses.
**              [pv]                      -- A void pointer that will be passed through to the callback function.
**              [pDecryptContext]         -- A context that may be used to decrypt data.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if and of the arguments are invalid
**              DRM_E_HEADER_NOT_SET if DRM_MGR_SetV1Header or DRM_MGR_SetV2Header haven't been called
**              DRM_E_LICENSENOTFOUND if a usuable license could not be found 
**              any other return code as defined in drmresults.h
**
** Notes:       If DRM_MGR_Bind fails with DRM_E_LICENSENOTFOUND the caller should call DRM_MGR_GenerateLicenseChallenge
**              and attempt to acquire a license if that functionality is available to the device.
**              If success the caller should call DRM_MGR_Commit to get a decryption context.
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_Bind(
    IN       DRM_MANAGER_CONTEXT         *pDrmContext,
    IN const DRM_CONST_STRING            *rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD                    cRights,
    IN       DRMPFNOUTPUTLEVELSCALLBACK   pfnOutputLevelsCallback,
    IN const DRM_VOID                    *pv,
       OUT   DRM_MANAGER_DECRYPT_CONTEXT *pDecryptContext );


/*****************************************************************************
** Function: DRM_MGR_GetSourceID
**
** Synopsis: This function should be called after DRM_MGR_Bind returns successfully. 
**           It returns the SourceID in the DRM_MANAGER_CONTEXT that was set 
**           in DRM_MGR_Bind.
** Arguments:
**           IN  *f_pDrmContext    -- initialized DRM_MANAGER context 
**           OUT *f_pdwSourceID    -- pointer to return the source ID
** Returns:
**           DRM_SUCCESS           -- On success
**           DRM_E_INVALIDARG      -- if any argument is invalid
** Notes  :  Call this API only after DRM_MGR_Bind() returns successfully
*****************************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetSourceID ( 
    IN     DRM_MANAGER_CONTEXT  *f_pDrmContext,
       OUT DRM_DWORD            *f_pdwSourceID );

/**********************************************************************
**
** Function:    DRM_MGR_Commit
**
** Synopsis:    Commits all metering and secure store transactions to the store file.
**
** Arguments:   [pDrmContext] -- Opaque DRM Manager context that has been bound to a license by DRM_MGR_Bind.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if the arguement is invalid
**              any other return code as defined in drmresults.h
**
** Notes:       If this function fails the app ( which may already be decrypting and playing back content ) should stop
**              all content rendering.
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_Commit( 
    IN     DRM_MANAGER_CONTEXT         *pDrmContext );

/******************************************************************************
**
** Function :   DRM_MGR_InitDecrypt
** 
** Synopsis :   Initializes state for phased decryption
** 
** Arguments :  [f_pDecryptContext] -- decrypt context 
**              [f_pbLast15]        -- Last 15 bytes of ciphertext
**              [f_cbData]          -- # of bytes in ENTIRE ciphertext              
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_MGR_InitDecrypt(
    IN DRM_MANAGER_DECRYPT_CONTEXT  *f_pDecryptContext,
    IN DRM_BYTE                     *f_pbLast15,
    IN DRM_DWORD                     f_cbData );

/******************************************************************************
** 
** Function :   DRM_MGR_Decrypt
** 
** Synopsis :   Decrypts part of the ciphertext. 
** 
** Arguments :  [pDecryptContext] -- Decrypt context setup in DRM_MGR_Bind
**              [pbData]          -- # of bytes of data to be decrypted
**              [cbData]          -- Pointer to encrypted buffer
** 
** Returns :    
** 
** Notes :      IMPORTANT: Phased decrypt should be called on segments of 
**              encrypted data sequentially, i.e. if encrypted data is divided 
**              four segments, the order of decryption should be segment 1,
**              followed by 2, 3, 4.
**              Content is decrypted in place.  Clear output is the same length 
**              as the encrypted input.
**              To remove complexity we do not handle the case where
**              a packet is split somewhere in the middle of the last 15 bytes.
**              The caller is responsible to ensure that the last 15 bytes never
**              straddle multiple calls to Decrypt.
**
******************************************************************************/
DRM_RESULT DRM_API DRM_MGR_Decrypt(
    IN     DRM_MANAGER_DECRYPT_CONTEXT *pDecryptContext,
    IN OUT DRM_BYTE                    *pbData,
    IN     DRM_DWORD                    cbData );


/**********************************************************************
**
** Function:    DRM_MGR_GetLicenseData
**
** Synopsis:    Retrieves data about the usability of content.  This is data that is aggregated across all licenses that match
**              the header speficied by DRM_MGR_SetV1Header or DRM_MGR_SetV2Header
**
** Arguments:    
**              [pDrmContext]    -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [rgpdstrRights]  -- An array of strings representing rights that the caller would like license state information about.
**              [rgStateData]    -- Array of DRM_LICENSE_STATE_DATA structures that will hold the results of the queires.
**              [cRightsQueried] -- Number of elements in the rgpdstrRights array and the rgStateData array.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any of the arguments are invalid or
**              DRM_E_HEADER_NOT_SET if a header has not been set or
**              any of the return codes as defined in drmresults.h
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetLicenseData(
    IN       DRM_MANAGER_CONTEXT    *pDrmContext,
    IN const DRM_CONST_STRING       *rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
       OUT   DRM_LICENSE_STATE_DATA  rgStateData[], /* array of DRM_LICENSE_STATE_DATAs */
    IN       DRM_DWORD               cRightsQueried );


#if DRM_SUPPORT_METERING
/**********************************************************************
**
** Function:    DRM_MGR_GenerateMeterChallenge
**
** Synopsis:    Generates a challenge that includes all the metering information for a specific MAS identified by the
**              metering certificate.
**
** Arguments:   [pDrmContext]    -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [pdstrMeterCert] -- Metering certificate that identifies the metering ID that wants to collect data.  This is an XML string.
**              [pwszUrl]        -- user allocated buffer to get URL in WCHAR.
**              [pcchUrl]        -- character count of pwszUrl. Can be NULL if URL is not required.
**              [pbChallenge]    -- Buffer to hold the metering challenge
**              [pcbChallenge]   -- Size in bytes of pbData on input.  Number of bytes copied to pbData on return or length required if the buffer was too small.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any of the parameters are invalid or
**              any of the return codes as defined in drmresults.h
**
**********************************************************************/

DRM_RESULT DRM_API DRM_MGR_GenerateMeterChallenge(
    IN        DRM_MANAGER_CONTEXT *pDrmContext,
    IN  const DRM_CONST_STRING    *pdstrMeterCert,
       OUT    DRM_WCHAR           *pwszUrl,
    IN OUT    DRM_DWORD           *pcchUrl,
       OUT    DRM_BYTE            *pbChallenge,
    IN OUT    DRM_DWORD           *pcbChallenge);

/**********************************************************************
**
** Function:    DRM_MGR_ProcessMeterResponse
**
** Synopsis:    A meter repsonse is sent to the device after a sever process the challenge.  This response is handled
**              by DRM here to possible reset the metering data just reported.
**
** Arguments:   [pDrmContext] -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [pbData]      -- Input buffer containing the response to process.
**              [cbData]      -- Count of bytes in pbData
**              [pfFlagsOut]  -- Status output flags.  Either 0 or DRM_METER_RESPONSE_PARTIAL
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if the argument is invalid or
**              any return code as defined in drmresults.h
**
** Notes:       If DRM_METER_RESPONSE_PARTIAL is returned in pfFlagsOut it indicates that the challenge/response
**              round trip was successful but only a partial amout of the entire metering data was sent.  The application
**              should perform the entire DRM_MGR_GenerateMeterChallenge/DRM_MGR_ProcessMeterReponse cycle again.
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_ProcessMeterResponse(
    IN      DRM_MANAGER_CONTEXT  *pDrmContext,
    IN      DRM_BYTE             *pbData,
    IN      DRM_DWORD             cbData,
       OUT  DRM_DWORD            *pfFlagsOut);
#endif   /* DRM_SUPPORT_METERING  */


#define DRM_SYNC_IGNORE_THRESHOLD_PARAMETER    0xFFFFFFFF

#if DRM_SUPPORT_LICENSE_SYNC
/**********************************************************************
**
** Function:    DRM_MGR_GenerateSyncChallenge
**
** Synopsis:    Creates a license synchronization challenge in multiple session.
**
** Arguments:   [pDrmContext]  -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [cMaxCount]    -- maximum remaining playcount before license expiration to use evaluating licenses with
**                                count-based expirations.  Use DRM_SYNC_IGNORE_THRESHOLD_PARAMETER (0xFFFFFFFF) to
**                                ignore this parameter and always sync count-based licenses
**              [cMaxHours]    -- maximum number of hours before license expiration to use evaluating licenses with
**                                date-based expirations.  Use DRM_SYNC_IGNORE_THRESHOLD_PARAMETER (0xFFFFFFFF) to
**                                ignore this parameter and always sync date-based licenses
**              [iStart]       -- starting index for challenge
**              [cItemsToProcess]   -- total number items to be processed 
**              [piNextStart]       -- Starting index for next challenge 
**              [pcProcessed]       -- total number of item processed

**              [pbData]       -- user-allocated buffer to be used as output buffer
**              [pcbData]      -- size of pbChallenge
**
** Returns:     DRM_SUCCESS on success. On failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL
**
** Notes:       To get the minimum size required, first call with pbChallenge = NULL and
**              *pcbChallenge =0.  This will return DRM_E_BUFFERTOOSMALL and the pcbChallenge 
**              will point to the required buffer size.
**
**********************************************************************/

DRM_RESULT DRM_API DRM_MGR_GenerateSyncChallenge(
    IN     DRM_MANAGER_CONTEXT *pDrmContext,
    IN     DRM_DWORD            cMaxCount,
    IN     DRM_DWORD            cMaxHours,
    IN     DRM_DWORD            iStart,
    IN     DRM_DWORD            cItemsToProcess,
       OUT DRM_DWORD           *piNextStart,
       OUT DRM_DWORD           *pcProcessed,
       OUT DRM_BYTE            *pbData,
    IN OUT DRM_DWORD           *pcbData);


#endif /* DRM_SUPPORT_LICENSE_SYNC */

#if DRM_SUPPORT_SECURE_CLOCK
/**********************************************************************
**
** Function:    DRM_MGR_ClkProcessResponse
**
** Synopsis:    Process Secure clockrequest response received from server
**
** Arguments:   [pDrmContext] -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [pbResponse]  -- Response string received from server
**              [cbResponse]  -- size of pbResponse in bytes.
**              [pResult]     -- pointer to DRM_RESULT to get error from server included in response
**
** Returns:     DRM_SUCCESS on success, or failed with 
**              DRM_E_INVALIDARG,
**              DRM_E_CLK_INVALID_RESPONSE
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_ClkProcessResponse(
    IN     DRM_MANAGER_CONTEXT *pDrmContext,
    IN     DRM_BYTE            *pbResponse,
    IN     DRM_DWORD            cbResponse,
       OUT DRM_RESULT          *pResult);

/**********************************************************************
**
** Function:    DRM_MGR_ClkGenerateChallenge
**
** Synopsis:    Creates a Secure Clock challenge.
**
** Arguments:   [pDrmContext]  -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [pwszUrl]      -- user allocated buffer to get URL in WCHAR. Null Terminated.
**              [pcchUrl]      -- character count of pwszUrl. Can be NULL if URL is not required.
**              [pbChallenge]  -- user allocated buffer to be used as output buffer
**              [pcbChallenge] -- size of pbChallenge
**
** Returns:     DRM_SUCCESS on success. On failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL
**
** Notes:       To get the minimum size required, first call with pbChallenge=NULL,
**              *pcbChallenge =0.  
**              This will return DRM_E_BUFFERTOOSMALL and pcchUrl and pcbChallenge 
**              will point to a value of minimum context size.
**
**********************************************************************/

DRM_RESULT DRM_API DRM_MGR_ClkGenerateChallenge(
    IN     DRM_MANAGER_CONTEXT  *pDrmContext,
       OUT DRM_WCHAR            *pwszUrl,
    IN OUT DRM_DWORD            *pcchUrl,
       OUT DRM_BYTE             *pbChallenge,
    IN OUT DRM_DWORD            *pcbChallenge );

/**********************************************************************
**
** Function:    DRM_MGR_GetSecureClock
**
** Synopsis:    Get Secure clock state
**
** Arguments:   [pDrmContext]             -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [pwszSecureTime]          -- pointer to WCHAR buffer to get Secure time. Optional 
**              [pcchSecureTime]          -- size of buffer in WCHAR. Optioanl
**              [pdwFlags]                -- Pointer to DWORD. Optional
**              [pbSecureTimeWithStatus]  -- pointer to BYTE buffer to get Secure time and flag status in XML format. Optional 
**              [pcbSecureTimeWithStatus] -- size of buffer. Optioanl
**
** Returns:     DRM_SUCCESS on success. 
**
** Notes:       There are 2 forms in which the secure clock data is being returned. Either in
**              poSecureTime and pdwFlags or in pbSecureTimeWithStatus. The second one in in XML format
**              which contains both information as in poSecureTime and pdwFlags. You can choose either format.
**              To get minimum buffer size, this API should be called with *pcchSecureTime =0 (or *pcbSecureTimeWithStatus =0)
**              This will return DRM_E_BUFFERTOOSMALL and pcchSecureTime and pcbSecureTimeWithStatus 
**              will point to a value of minimum context size.
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetSecureClock(
    IN     DRM_MANAGER_CONTEXT  *pDrmContext,
    IN     DRM_WCHAR            *pwszSecureTime,
    IN OUT DRM_DWORD            *pcchSecureTime, 
    IN     DRM_DWORD            *pdwFlags,
    IN     DRM_BYTE             *pbSecureTimeWithStatus,
    IN OUT  DRM_DWORD           *pcbSecureTimeWithStatus  );

#endif /* DRM_SUPPORT_SECURE_CLOCK */



#if DRM_SUPPORT_ENCRYPTION
/**********************************************************************
**
** Function:    DRM_MGR_CreateEncryptContext
**
** Synopsis:    Creates an encryption context that can be used to encrypt clear text data with the DRM content encryption
**              algorithm.  A device that wants to create DRM protected content would use this to do so.
**
** Arguments:   [rgbKey]          -- The content key the caller wants the content encrypted with.
**              [pEncryptContext] -- A context that will be initialzied internally with the content key.
**
** Returns:     DRM_SUCCESS on success or 
**              DRM_E_INVALIDARG if any of the arguments are invalid or
**              any return code as defined in drmresults.h
**
** Notes:       This is very light wieght.  Content can be encrypted without call DRM_MGR_Initialize
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_CreateEncryptContext(
    IN const DRM_BYTE                     rgbKey[__CB_DECL(DRMCIPHERKEYLEN)],
       OUT   DRM_MANAGER_ENCRYPT_CONTEXT *pEncryptContext );

/**********************************************************************
**
** Function:    DRM_MGR_Encrypt
**
** Synopsis:    Encrypts cleartext content using the DRM content encryption algorithm and the given encryption context.
**
** Arguments:   [pEncryptContext] -- Encryption context previously initialized by DRM_MGR_CreateEncryptContext.
**              [pbData]          -- Input data that is encrypted in place
**              [cbData]          -- Count of bytes in pbData
**
** Returns:     DRM_SUCECSS on succes or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              any return code as defined in drmresults.h
**
** Notes:       Content is encrypted in place.  The input buffer will be modified.
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_Encrypt(
    IN     DRM_MANAGER_ENCRYPT_CONTEXT *pEncryptContext,
    IN OUT DRM_BYTE                    *pbData,
    IN     DRM_DWORD                    cbData );
#endif  /* DRM_SUPPORT_ENCRYPTION */


/**********************************************************************
**
** Function:    DRM_MGR_CleanupLicenseStore
**
** Synopsis:    Instructs DRM to delete all unusable licenses from the license store and perform maintaince functions 
**              on the data store file.
**
** Arguments:   [pDrmContext]        -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [pvCallerData]       -- Opaque context data to be funnelled back to caller during callback. Could be NULL.
**              [dwCallbackInterval] -- % completion after which Callback (if any) should be invoked. 
**                                      e.g. if dwCallbackInterval = 5, callback will be invoked after 5%, 10%, 15%...completion
**              [pfnCallback]        -- optional caller supplied callback function - can be NULL.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              any return code as defined in drmrestults.h
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_CleanupLicenseStore(
    IN       DRM_MANAGER_CONTEXT     *pDrmContext,
    IN const DRM_VOID                *pvCallerData,
    IN       DRM_DWORD                dwCallbackInterval,
    IN       pfnStoreCleanupProgress  pfnCallback );


/**********************************************************************
**
** Function:    DRM_MGR_GetLicenseState
**
** Synopsis:    Gets License state for the KID included in pdstrQuery. 
**              Currently it tells whether license is usable for Play action.
**
** Arguments:   [pDrmContext]        -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [pdstrQuery]         -- Query containing KID, Action etc. 
**              [pCategory]          -- returns DRM_LICENSE_STATE_CATEGORY. 
**              [pdwReserved1]       -- Reserved for future use. Must be NULL. 
**              [pdwReserved2]       -- Reserved for future use. Must be NULL. 
**              [pdwReserved3]       -- Reserved for future use. Must be NULL. 
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              any return code as defined in drmrestults.h
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetLicenseState(
    IN        DRM_MANAGER_CONTEXT        *pDrmContext,
    IN  const DRM_CONST_STRING           *pdstrQuery,
        OUT   DRM_LICENSE_STATE_CATEGORY *pCategory,
        OUT   DRM_DWORD                  *pdwReserved1,
        OUT   DRM_DWORD                  *pdwReserved2,
        OUT   DRM_DWORD                  *pdwReserved3);

/*****************************************************************************
** Function:    DRM_MGR_GetRevocationList
**
** Synopsis:    open the secure store and get the version number and buffer containing the 
**              revocation list currently stored based upon the type of revocation list
**              specified
**
** Arguments:   [f_pDrmContext]        -- Opaque DRM Manager context initialized by a call to 
**                                        DRM_MGR_Initialize.
**              [f_eRevType]           -- Type of Revocation List and Version to retrieve.
**              [f_pbBuffer]           --
**              [f_pcbBuffer]          -- size of f_pbBuffer, in bytes, returns size of  
**                                        revocation list
**              [f_pdwVersion]         -- Returns version of revocation list.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              DRM_E_PRIVKEYREADERROR if BB context not initialized or
**              DRM_E_FILENOTFOUND if revocation list doesn't exist in secure store or
**              DRM_E_BUFFERTOOSMALL if *f_pcbBuffer smaller than required buffer size to return 
**                                     revocation list or
**              any return code as defined in drmresults.h
*****************************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetRevocationList(
    IN        DRM_MANAGER_CONTEXT        *f_pDrmContext,
    IN        DRM_REVOCATION_TYPE_ENUM    f_eRevType,
    OUT       DRM_BYTE                   *f_pbBuffer,
    IN OUT    DRM_DWORD                  *f_pcbBuffer,
    OUT       DRM_DWORD                  *f_pdwVersion);

/*****************************************************************************
** Function:    DRM_MGR_GetRevocationListVersion
**
** Synopsis:    open the secure store and get the version number for the 
**              revocation list currently stored based upon the type of revocation list
**              specified
**
** Arguments:   [f_pDrmContext]        -- Opaque DRM Manager context initialized by a call to 
**                                        DRM_MGR_Initialize.
**              [f_eRevType]           -- Type of Revocation List and Version to retrieve.
**              [f_pdwVersion]         -- Returns version of revocation list.
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              DRM_E_PRIVKEYREADERROR if BB context not initialized or
**              DRM_E_FILENOTFOUND if revocation list doesn't exist in secure store or
**              any return code as defined in drmresults.h
*****************************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetRevocationListVersion(
    IN        DRM_MANAGER_CONTEXT        *f_pDrmContext,
    IN        DRM_REVOCATION_TYPE_ENUM    f_eRevType,
    OUT       DRM_DWORD                  *f_pdwVersion);

/*****************************************************************************
** Function:    DRM_MGR_GetRevInfo
**
** Synopsis:    open the secure store and get the revocation information structu
re for
**              revocation lists currently stored.
**
** Arguments:   [f_pDrmContext]        -- Opaque DRM Manager context initialized
 by a call to
**                                        DRM_MGR_Initialize.
**              [f_pbRevInfo]          -- Pointer to Revocation Info buffer
**              [f_cbRevInfo]          -- Size of Revocation info buffer
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              DRM_E_PRIVKEYREADERROR if BB context not initialized or
**              DRM_E_FILENOTFOUND if revocation info doesn't exist in secure st
ore or
**              DRM_E_BUFFERTOOSMALL if cbRevinfo isn't large enough to hold rev
 info or
#               DRM_E_NOTIMPL if DRM_SUPPORT_REVOCATION is not defined or
**              any return code as defined in drmresults.h
*****************************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetRevInfo(
    IN        DRM_MANAGER_CONTEXT   *f_pDrmContext,
    IN        DRM_BYTE              *f_pbRevInfo,
    IN  OUT   DRM_DWORD             *f_pcbRevInfo);

/**********************************************************************
**
** Function:    DRM_MGR_GetWMDRMNETMinAppSec
**
** Synopsis:    Gets License minimum application security level.  Must be called
**              after a successful bind via DRM_MGR_Bind and prior to DRM_MGR_Commit.
**
** Arguments:   [f_pDrmContext]        -- Opaque DRM Manager context initialized by a call to DRM_MGR_Initialize
**              [f_pdwMinAppSec]          -- Returns License Chains minimum app security level. 
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any parameter is invalid or
**              DRM_E_LICENSENOTBOUND if license hasn't been bound by calling DRM_MGR_Bind successfully
**              any return code as defined in drmrestults.h
**
**********************************************************************/
DRM_RESULT DRM_API DRM_MGR_GetWMDRMNETMinAppSec(
    IN        DRM_MANAGER_CONTEXT        *f_pDrmContext,
    OUT       DRM_DWORD                  *f_pdwMinAppSec);

/**********************************************************************
**
** Function:    DRM_MGR_ProcessCommand
**
**
**********************************************************************/


DRM_RESULT DRM_API DRM_MGR_ProcessCommand(
    IN       DRM_MANAGER_CONTEXT   *f_pcontextMGR,
    IN       DRM_DWORD              f_dwOperationCode,
    IN       DRM_DWORD              f_dwRequestArgument1,
    IN       DRM_DWORD              f_dwRequestArgument2,
    IN       DRM_DWORD              f_dwRequestArgument3,
    IN       DRM_DWORD              f_dwRequestArgument4,
    IN       DRM_BYTE              *f_pbRequestData,
    IN       DRM_DWORD              f_dwRequestDataLength,
        OUT  DRM_DWORD             *f_pdwResponseResult1,
        OUT  DRM_DWORD             *f_pdwResponseResult2,
        OUT  DRM_DWORD             *f_pdwResponseResult3,
        OUT  DRM_DWORD             *f_pdwResponseResult4);

/**********************************************************************
**
** Function:    DRM_MGR_ProcessRequest
**
**
**********************************************************************/

DRM_RESULT DRM_API DRM_MGR_ProcessRequest( 
    IN       DRM_MANAGER_CONTEXT   *f_pcontextMGR,
    IN       DRM_DWORD              f_dwOperationCode,
    IN       DRM_DWORD              f_dwRequestArgument1,
    IN       DRM_DWORD              f_dwRequestArgument2,
    IN       DRM_DWORD              f_dwRequestArgument3,
    IN       DRM_DWORD              f_dwRequestArgument4,
        OUT  DRM_DWORD             *f_pdwResponseResult1,
        OUT  DRM_DWORD             *f_pdwResponseResult2,
        OUT  DRM_DWORD             *f_pdwResponseResult3,
        OUT  DRM_DWORD             *f_pdwResponseResult4,
        OUT  DRM_BYTE              *f_pbResponseData,
        OUT  DRM_DWORD             *f_pdwResponseDataLength);




#ifdef __cplusplus      
}
#endif

#endif /* __DRMMANAGER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmmd5.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMMD5_H__
#define __DRMMD5_H__ 1

#ifdef __cplusplus
extern "C" {
#endif

#define MD5DIGESTLEN 16

typedef struct __tagDRM_MD5_CTX {
    DRM_DWORD awaiting_data[16];
                             /* Data awaiting full 512-bit block.       */
                             /* Length (nbit_total[0] % 512) bits.      */
                             /* Unused part of buffer (at end) is zero. */
    DRM_DWORD partial_hash[4];
                             /* Hash through last full block            */
    DRM_DWORD nbit_total[2];       
                             /* Total length of message so far          */
                             /* (bits, mod 2^64)                        */
    DRM_BYTE digest[__CB_DECL(MD5DIGESTLEN)];
                             /* Actual digest after MD5Final completes  */
} DRM_MD5_CTX;

DRM_VOID DRM_API DRM_MD5_Init( IN OUT DRM_MD5_CTX *f_contextMD5);

DRM_VOID DRM_API DRM_MD5_Update(
    IN OUT   DRM_MD5_CTX *f_contextMD5, 
    IN const DRM_BYTE    *f_pbData, 
    IN       DRM_DWORD    f_cbData);

DRM_VOID DRM_API DRM_MD5_Final( IN OUT DRM_MD5_CTX *f_contextMD5);

#ifdef __cplusplus
}
#endif


#endif /* __DRMMD5_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmmetering.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmsecurestore.h>
#include <drmmetering.h>


DRM_RESULT DRM_API DRM_MTR_OpenId (
    IN       DRM_METERING_CONTEXT *f_pcontextMTR,
    IN const DRM_MID              *f_pmid,
    IN const DRM_KID              *f_pkid,
    IN const DRM_BYTE              f_rgbPasswordMTR [__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_HDS_CONTEXT      *f_pcontextHDS)
{
    DRM_RESULT       dr    = DRM_E_LOGICERR;
    DRM_WORD         cbKid = 0;
    
    ChkArg (f_pcontextMTR    != NULL
         && f_pmid           != NULL
         && f_pkid           != NULL
         && f_rgbPasswordMTR != NULL
         && f_pcontextHDS    != NULL);
    
    DRMCASSERT(SIZEOF(DRM_METERING_CONTEXT) == SIZEOF(DRM_SECSTORE_CONTEXT));

    ChkDR (DRM_SST_OpenKeyTokens(f_pcontextMTR, 
                      (DRM_ID *) f_pmid,
                      (DRM_ID *) f_pkid,
                                 f_rgbPasswordMTR,
                                 DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS,
                                 SECURE_STORE_METERING_DATA,
                                 f_pcontextHDS));

 
    /* Metering context is setup successfully */
    dr = DRM_SUCCESS;

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_MTR_IncrementCount( 
    IN       DRM_METERING_CONTEXT *f_pcontextMTR, 
    IN const DRM_CONST_STRING     *f_pdstrAction )
{
    DRM_RESULT dr = DRM_E_LOGICERR;
    TOKEN      token;

    ChkArg(f_pcontextMTR);
    ChkDRMString(f_pdstrAction);

    /* Store entry has been opened/created.  Try to read the KID.  If it doesn't exist add it. */    
    dr = DRM_SST_GetTokenValue(f_pcontextMTR, f_pdstrAction , &token);
    if (DRM_FAILED(dr))
    {
        dr = DRM_E_METERING_STORE_CORRUPT;
        goto ErrorExit;
    }

    if (dr == DRM_S_FALSE)
    {        
        /* Action doesn't exist.  Initialize the count to 0*/
        token.val.lValue = 0;
        token.TokenType  = TOKEN_LONG;
    }

    /* Increment it and write it back */
    token.val.lValue++;    
    ChkDR(DRM_SST_SetTokenValue(f_pcontextMTR, f_pdstrAction , &token));
    dr = DRM_SUCCESS;

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_MTR_GetAllData (
    IN     DRM_METERING_CONTEXT *f_pcontextMTR,
    OUT    DRM_BYTE             *f_pbData,
    IN OUT DRM_DWORD            *f_pcbData)
{
    return DRM_SST_GetAllData (f_pcontextMTR, f_pbData, f_pcbData);
}

DRM_RESULT DRM_API DRM_MTR_CloseContext( 
    IN DRM_METERING_CONTEXT *f_pcontextMTR,
    IN DRM_HDS_CONTEXT      *f_pcontextHDS)
{
    return DRM_SST_CloseKey( f_pcontextMTR, f_pcontextHDS );
}

DRM_RESULT DRM_API DRM_MTR_InitEnum (
    IN  const DRM_MID                   *f_pmid,
    OUT       DRM_METERINGENUM_CONTEXT  *f_pcontextMTREnum,
    IN        DRM_HDS_CONTEXT           *f_pcontextHDS)
{
    return DRM_SST_OpenEnumerator ( SECURE_STORE_METERING_DATA, f_pmid, f_pcontextMTREnum, f_pcontextHDS, TRUE);
}

DRM_RESULT DRM_API DRM_MTR_EnumNext ( 
    IN  DRM_METERINGENUM_CONTEXT *f_pcontextMTREnum,
    OUT DRM_KID                  *f_pkid,
    OUT DRM_DWORD                *f_pcbData)
{
    return DRM_SST_EnumNext( f_pcontextMTREnum, f_pkid, f_pcbData);
}

DRM_RESULT DRM_API DRM_MTR_EnumLoadCurrent ( 
    IN       DRM_METERINGENUM_CONTEXT *f_pcontextMTREnum,
    IN       DRM_METERING_CONTEXT     *f_pcontextMTR,
    IN const DRM_BYTE                  f_rgbPasswordMTR[__CB_DECL(SHA_DIGEST_LEN)],
       OUT   DRM_KID                  *f_pkid,
       OUT   DRM_DWORD                *f_pcbData)
{
    return DRM_SST_EnumLoadCurrent(f_pcontextMTREnum, 
                                   f_pcontextMTR,
                                   f_rgbPasswordMTR,
                                   f_pkid,
                                   f_pcbData);
}


DRM_RESULT DRM_API DRM_MTR_EnumDeleteCurrent ( 
    IN       DRM_METERINGENUM_CONTEXT *f_pcontextMTREnum,
    IN       DRM_METERING_CONTEXT     *f_pcontextMTR)
{
    return DRM_SST_EnumDeleteCurrent(f_pcontextMTREnum, 
                                     f_pcontextMTR);
}
DRM_RESULT DRM_API DRM_MTR_UpdateData(
    DRM_MID                 *f_pmid,
    DRM_LID                 *f_plid,
    DRM_KID                 *f_pkid,
    const DRM_CONST_STRING **f_ppdstrActions,
    DRM_DWORD                f_cActions,
    DRM_METERING_CONTEXT    *f_pcontextMTR,
    DRM_HDS_CONTEXT         *f_pcontextHDS,
    DRM_BYTE                *f_pbcontextBBX)
{
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_DWORD  iAction    = 0;
    DRM_DWORD  cchMeterID =            CCH_BASE64_EQUIV(SIZEOF(DRM_MID));
    DRM_WCHAR  rgwchMeterID [CCH_BASE64_EQUIV(SIZEOF(DRM_MID))] = { 0 };
    DRM_BYTE   rgbPassword  [__CB_DECL(SHA_DIGEST_LEN)];

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MTR_UpdateData", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
                            
    ChkDR(DRM_B64_EncodeW((DRM_BYTE *) f_pmid, 
                          SIZEOF(DRM_MID), 
                          rgwchMeterID, 
                         &cchMeterID, 
                          0));

    ChkDR(DRM_BBX_HashValue((DRM_BYTE *) rgwchMeterID, 
                             cchMeterID * SIZEOF(DRM_WCHAR),
                             rgbPassword,
                            (DRM_BB_CONTEXT *) f_pbcontextBBX));
    
    ChkDR( DRM_MTR_OpenId(f_pcontextMTR,
                          f_pmid,
                          f_pkid,
                          rgbPassword,
                          f_pcontextHDS));

    for (iAction = 0; iAction < f_cActions; iAction++)
    {            
        ChkDR(DRM_MTR_IncrementCount(f_pcontextMTR, 
                                     f_ppdstrActions [iAction]));
    }
    
    ChkDR(DRM_MTR_CloseContext(f_pcontextMTR,
                               f_pcontextHDS));

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MTR_UpdateData", g_pwszLeavingFunction);

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmmetercertpubkey.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMMETER_CERT_PUBLIC_KEY_H__
#define __DRMMETER_CERT_PUBLIC_KEY_H__

#ifdef __cplusplus
extern "C" {
#endif

PUBKEY g_pubkeyMeteringCertVerify =
{
    TWO_BYTES(0xAE, 0xF2), TWO_BYTES(0x91, 0xD5), TWO_BYTES(0xDA, 0xBE), TWO_BYTES(0x13, 0x37), 
    TWO_BYTES(0x46, 0x0F), TWO_BYTES(0xC3, 0x43), TWO_BYTES(0xD8, 0x88), TWO_BYTES(0x64, 0x9F), 
    TWO_BYTES(0x43, 0x8F), TWO_BYTES(0x12, 0x85), TWO_BYTES(0x99, 0x64), TWO_BYTES(0xA0, 0xB0), 
    TWO_BYTES(0x82, 0x27), TWO_BYTES(0x69, 0xED), TWO_BYTES(0x8E, 0x52), TWO_BYTES(0x1D, 0x1F), 
    TWO_BYTES(0x8D, 0x14), TWO_BYTES(0x92, 0x5A), TWO_BYTES(0xCD, 0xD3), TWO_BYTES(0xD6, 0x7C)
};

PUBKEY g_pubkeyRootMeteringCert = /* "pub" */
{
    TWO_BYTES(0x45, 0xB1), TWO_BYTES(0xA7, 0xE1), TWO_BYTES(0x90, 0x81), TWO_BYTES(0x98, 0x37), 
    TWO_BYTES(0x00, 0xCC), TWO_BYTES(0x89, 0xA7), TWO_BYTES(0x57, 0x24), TWO_BYTES(0x72, 0xB9), 
    TWO_BYTES(0xC1, 0x29), TWO_BYTES(0xA3, 0x62), TWO_BYTES(0xD9, 0x55), TWO_BYTES(0x74, 0x04), 
    TWO_BYTES(0x02, 0x7D), TWO_BYTES(0x6E, 0x69), TWO_BYTES(0x79, 0xE9), TWO_BYTES(0x6A, 0xD9), 
    TWO_BYTES(0x7A, 0x92), TWO_BYTES(0xE4, 0xF3), TWO_BYTES(0x4B, 0x6B), TWO_BYTES(0x42, 0x6C)
};

#ifdef __cplusplus
}
#endif

#endif /* __DRMMETER_CERT_PUBLIC_KEY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmoutputlevels.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_OUTPUTLEVELS_H__
#define __DRM_OUTPUTLEVELS_H__

#ifdef __cplusplus
extern "C" {
#endif

DRM_RESULT DRM_API DRM_OPL_ProcessPlayOutputLevelData( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_PLAY_OPL                 *f_pPlayOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack );

DRM_RESULT DRM_API DRM_OPL_ProcessCopyOutputLevelData( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_COPY_OPL                 *f_pCopyOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack );

#ifdef __cplusplus
}
#endif


#endif /* __DRM_OUTPUTLEVELS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmopcodes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMOPCODES_H__
#define __DRMOPCODES_H__

#ifdef __cplusplus
extern "C" {
#endif

/*Defines for generic function call thru MTP/RAPI*/
#define OpGetVersion                        1
#define OpProcessLicenseRevocationList      2

#ifdef __cplusplus
}
#endif

#endif /*__DRMOPCODES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmoutputleveltypes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_OUTPUTLEVELTYPES_H__
#define __DRM_OUTPUTLEVELTYPES_H__

#ifdef __cplusplus
extern "C" {
#endif

enum DRM_OPL_CALLBACK_TYPE
{
    DRM_PLAY_OPL_CALLBACK = 0x1,
    DRM_COPY_OPL_CALLBACK = 0x2
};

typedef DRM_RESULT (DRM_API* DRMPFNOUTPUTLEVELSCALLBACK)( 
    IN const DRM_VOID  *f_pvOutputLevelsData,
    IN       DRM_DWORD  f_dwCallbackType,
    IN const DRM_VOID  *f_pv );

#ifndef DRM_OPL_TYPES
#define DRM_OPL_TYPES 1

typedef struct __tagDRM_MINIMUM_OUTPUT_PROTECTION_LEVELS
{
    DRM_WORD wCompressedDigitalVideo;
    DRM_WORD wUncompressedDigitalVideo;
    DRM_WORD wAnalogVideo;
    DRM_WORD wCompressedDigitalAudio;
    DRM_WORD wUncompressedDigitalAudio;
    
} DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS;

typedef struct __tagDRM_OPL_OUTPUT_IDS
{
    DRM_WORD  cIds;
    DRM_GUID  *rgIds;
    
} DRM_OPL_OUTPUT_IDS;

typedef struct __tagDRM_VIDEO_OUTPUT_PROTECTION
{
    DRM_GUID guidId;
    DRM_BYTE bConfigData;

} DRM_VIDEO_OUTPUT_PROTECTION;

typedef struct __tagDRM_VIDEO_OUTPUT_PROTECTION_IDS
{
    DRM_WORD cEntries;
    DRM_VIDEO_OUTPUT_PROTECTION *rgVop;

} DRM_VIDEO_OUTPUT_PROTECTION_IDS;

typedef struct __tagDRM_PLAY_OPL
{
    DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS minOPL;
    DRM_OPL_OUTPUT_IDS                   oplIdReserved;
    DRM_VIDEO_OUTPUT_PROTECTION_IDS      vopi;

} DRM_PLAY_OPL;

typedef struct __tagDRM_COPY_OPL
{
    DRM_WORD           wMinimumCopyLevel;
    DRM_OPL_OUTPUT_IDS oplIdIncludes;
    DRM_OPL_OUTPUT_IDS oplIdExcludes;
    
} DRM_COPY_OPL;

#endif


#ifdef __cplusplus
}
#endif


#endif /* __DRM_OUTPUTLEVELS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmmgrmeter.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmlicense.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmsyncstore.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <drmmeterimpl.h>
#include <drmmetercertpubkey.h>
#include <drmcrt.h>
#include <oemimpl.h>
#include <drmprofile.h>

/* minimum characters required for a KID expressed as XML*/
/* <KID value="16byteasBase64*filler=="><ACTION type="play">0</ACTION></KID> */

#define CCH_KID_REQUIRED_MINIMUM         75

/* minimum size of an operation entry e.g. "Play" in the metering store 
   |2|"p"|2|4| */

#define CB_OPERATION_MINIMUM  (SIZEOF (DRM_WORD) * 2  \
                             + SIZEOF (DRM_WCHAR)     \
                             + SIZEOF (DRM_DWORD))

/* pseudo-hash to read/write TIDs in the metering store */

const DRM_KID g_kidTID = 
{ 
    TWO_BYTES('K',  0), 
    TWO_BYTES('I',  0), 
    TWO_BYTES('D',  0), 
    TWO_BYTES('4',  0), 
    TWO_BYTES('T',  0), 
    TWO_BYTES('I',  0), 
    TWO_BYTES('D',  0), 
    TWO_BYTES('\0', 0) 
};
const DRM_KID g_kidTIDPrev = 
{ 
    TWO_BYTES('K',  0), 
    TWO_BYTES('I',  0), 
    TWO_BYTES('D',  0), 
    TWO_BYTES('P',  0), 
    TWO_BYTES('R',  0), 
    TWO_BYTES('E',  0), 
    TWO_BYTES('V',  0), 
    TWO_BYTES('\0', 0) 
};

static DRM_DWORD _RequiredCharsForBinary (const DRM_CONST_STRING *pdstrTag,
                                          DRM_WORD                cbBinary)
{
    return DRM_XMB_RequiredCharsForTag (pdstrTag->cchString, 
                                        0, 
                                        g_dstrAttributeType.cchString, 
                                        CCH_BASE64_EQUIV (cbBinary));
}

/*******************************************************************
 *              PRIVATE FUNCTION _RequiredCharsForKID
 *
 * purpose: determine the number of XML characters required to
 *          express this KID
 *  params: f_pbBuffer is the HDS storage image of the KID, a
 *          heterogeneous array of actions and counts
 ******************************************************************/
 
static DRM_RESULT _RequiredCharsForKID (DRM_BYTE  *f_pbBuffer,
                                        DRM_DWORD  f_cbBuffer,
                                        DRM_DWORD *f_pcchRequired)
{
    DRM_DWORD        cchKID     = 0;
    DRM_DWORD        ibCurr     = 0;
    DRM_CONST_STRING dstrOper   = EMPTY_DRM_STRING,
                     dstrCount  = EMPTY_DRM_STRING;

    DRMASSERT (f_pbBuffer     != NULL);
    DRMASSERT (f_pcchRequired != NULL);

    /*          <KID> */

    cchKID += _RequiredCharsForBinary (&g_dstrTagKID, SIZEOF (DRM_KID));

    /* read action/count entries */

    while ((ibCurr + CB_OPERATION_MINIMUM - 1) < f_cbBuffer)
    {
        DRM_WORD  cbCurr = 0;
        DRM_DWORD cOps   = 0;
        DRM_WCHAR awchNum [16];
        TOKEN     token;
        DRM_BYTE *pbAction = NULL;
        
        /* string size */
    
        DRM_BYT_CopyBytes(&cbCurr, 0, f_pbBuffer, ibCurr, SIZEOF (DRM_WORD));
        
        FIX_ENDIAN_WORD( cbCurr );
        ibCurr += SIZEOF (DRM_WORD);        
        
        /* string "Play" or whatever */
        
        if ((ibCurr % CB_NATIVE_BYTE) != 0)
        {
            /* if the UNICODE string isn't aligned in the packed buffer then move the string one 
               char to the left (this is safe, the data won't be reparsed) */
               
            pbAction = (f_pbBuffer + __CB_DECL((ibCurr & ~CB_NATIVE_BYTE)));
        
            DRM_BYT_CopyBytes(pbAction, 0, f_pbBuffer, ibCurr, cbCurr);
        }
        else
        {
            pbAction = f_pbBuffer + __CB_DECL((ibCurr));
        }

        DSTR_FROM_PB(&dstrOper, pbAction, cbCurr);
        
        ibCurr += cbCurr;
        
        /* Token */
    
        DRM_BYT_CopyBytes(&token, 0, f_pbBuffer, ibCurr, SIZEOF (token));
        
        FIX_ENDIAN_DWORD( token.val.lValue );
        ibCurr += SIZEOF (TOKEN);
        
        /*              <ACTION type="Play">1</ACTION> */

        dstrCount.cchString  = DRM_UTL_NumberToString (token.val.lValue, awchNum, NO_OF (awchNum));
        dstrCount.pwszString = awchNum;

        cchKID += DRM_XMB_RequiredCharsForTag (g_dstrTagAction .cchString, 
                                               dstrCount       .cchString, 
                                               g_dstrLabelValue.cchString, 
                                               dstrOper        .cchString);
    }

    *f_pcchRequired = cchKID + 1;

    return DRM_SUCCESS;
}

/*********************************************************************
 *                    PRIVATE FUNCTION _GetKIDData                   
 *                                                                   
 * initial state: context is in a chosen KID                         
 *      function: determines required buffer size for KID data       
 *                allocates buffer                                   
 *                copies data into buffer                            
 *                caller must release buffer                         
 ********************************************************************/

static DRM_RESULT _GetKIDData (IN  DRM_METERING_CONTEXT        *f_pmeterstore,
                               IN  DRM_STACK_ALLOCATOR_CONTEXT *f_pstack,
                               OUT DRM_BYTE                   **f_ppbDataOut, 
                               OUT DRM_DWORD                   *f_pcbDataOut)
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_BYTE   *pbData = NULL; 
    DRM_DWORD   cbData = 0;

    DRMASSERT (f_pmeterstore != NULL);
    DRMASSERT (f_pstack      != NULL);
    DRMASSERT (f_ppbDataOut  != NULL);
    DRMASSERT (f_pcbDataOut  != NULL);

    ChkArg(f_pmeterstore != NULL
        && f_pstack      != NULL
        && f_ppbDataOut  != NULL
        && f_pcbDataOut  != NULL);

    *f_ppbDataOut = NULL;
    *f_pcbDataOut = 0;

    dr = DRM_MTR_GetAllData (f_pmeterstore, NULL, &cbData);
    
    if (DRM_SUCCEEDED (dr)
    ||  dr == DRM_E_BUFFERTOOSMALL)
    {
        if (cbData > 0)
        {
            if (DRM_SUCCEEDED (dr = DRM_STK_Alloc (f_pstack, cbData, (DRM_VOID**) &pbData)))
            {
                if (DRM_SUCCEEDED (dr = DRM_MTR_GetAllData (f_pmeterstore, pbData, &cbData)))
                {
                    *f_ppbDataOut = pbData;
                    *f_pcbDataOut = cbData;
                }
                else
                {
                    DRM_STK_Free (f_pstack, pbData);
                }
            }
        }
        else
        {
            dr = DRM_SUCCESS;
            *f_ppbDataOut = NULL;
            *f_pcbDataOut = 0;
        }
    }

ErrorExit:
    return dr;
} /* _GetKIDData */


/*******************************************************************
 *              PRIVATE FUNCTION _CreateNewTID
 *
 * purpose: create a new TID-sized blob of random bytes
 *******************************************************************/

static DRM_RESULT _CreateNewTID (DRM_TID *f_ptid)
{
    return OEM_GenRandomBytes ((DRM_BYTE *)f_ptid, SIZEOF(DRM_TID));
}

/*******************************************************************
 *   PRIVATE FUNCTIONS _ReadTIDFromMeteringStore 
 *                 AND _WriteTIDToMeteringStore
 *
 * purpose: manage the reading and writing of TIDs
 *******************************************************************/

static DRM_RESULT _ReadTIDFromMeteringStore (DRM_METERING_CONTEXT   *f_pmeterstore,
                                             DRM_BYTE                f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)],
                                             const DRM_MID          *f_pmid,
                                             DRM_TID                *f_ptid,
                                             DRM_CONST_STRING       *f_pdstrTidBase64,
                                             IN DRM_HDS_CONTEXT     *f_pcontextHDS)
{
    DRM_RESULT dr    = DRM_SUCCESS;
    DRM_BYTE   rgbSlotMinimum [__CB_DECL(DRM_SST_SLOT_V0_HEADER_SIZE)];
    DRM_DWORD  cbSlot = SIZEOF (rgbSlotMinimum);

    ChkArg (f_pmeterstore    != NULL
        &&  f_rgbPasswordSST != NULL
        &&  f_pmid           != NULL
        &&  f_ptid           != NULL
        &&  f_pcontextHDS    != NULL);
        
    ChkDR(DRM_SST_GetData (f_pmeterstore, 
                           f_pmid, 
                          &g_kidTID, 
                           f_rgbPasswordSST, 
                           SECURE_STORE_METERING_DATA,
                           f_pcontextHDS,
                           rgbSlotMinimum, 
                          &cbSlot));

    MEMCPY((DRM_BYTE *) f_ptid, rgbSlotMinimum, SIZEOF(DRM_TID));

    if (f_pdstrTidBase64 != NULL)
    {
        ChkArg(f_pdstrTidBase64->cchString >= CCH_BASE64_EQUIV (SIZEOF (DRM_TID)));

        ChkDR  (DRM_B64_EncodeW((DRM_BYTE *) f_ptid, 
                          SIZEOF(DRM_TID), 
                    (DRM_WCHAR *) f_pdstrTidBase64->pwszString, 
                                 &f_pdstrTidBase64->cchString,
                                 0));
    }

ErrorExit:
    return dr;
} /* _ReadTIDFromMeteringStore */

static DRM_RESULT _WriteTIDToMeteringStore (IN  DRM_METERING_CONTEXT *f_pmeterstore,
                                            IN  DRM_BYTE              f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)],
                                            IN  const DRM_MID        *f_pmid,
                                            IN  DRM_TID              *f_ptid,
                                            IN DRM_HDS_CONTEXT       *f_pcontextHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE rgbSlotMinimum [__CB_DECL(DRM_SST_SLOT_V0_HEADER_SIZE)];

    /* must write at least 24 bytes or SST slot code will fail */

    ZEROMEM(rgbSlotMinimum, SIZEOF(rgbSlotMinimum));
    MEMCPY (rgbSlotMinimum, f_ptid, SIZEOF(DRM_TID));

    ChkDR(DRM_SST_SetData(f_pmeterstore, 
                          f_pmid, 
                         &g_kidTID, 
                          f_rgbPasswordSST, 
                          SECURE_STORE_METERING_DATA,
                          f_pcontextHDS,
                          rgbSlotMinimum, 
                   SIZEOF(rgbSlotMinimum)));
ErrorExit:
    return dr;
} /* _WriteTIDToMeteringStore */

/*******************************************************************
 *              PRIVATE FUNCTION _VerifySignature
 *
 * purpose: given the <DATA> block, the base64-encoded signature and
 *          certificate (singular at the time of this writing), 
 *          verify that the certificate and signed block match the 
 *          public key
 *******************************************************************/

static DRM_RESULT _VerifySignature (const DRM_CONST_STRING    *f_pdstrListDataIn, 
                                    const DRM_CONST_STRING    *f_pdstrDataSignIn,
                                    const DRM_CONST_STRING    *f_pdstrDataCertificateIn,
                                          DRM_LICEVAL_CONTEXT *f_pcontextLEVL)
{
    CERT         cert;
    DRM_BYTE     rgbSignature [__CB_DECL(PK_ENC_SIGNATURE_LEN)],
                *pbData      = PB_DSTR(f_pdstrListDataIn);
    DRM_DWORD    cbData      = CB_DSTR(f_pdstrListDataIn),
                 cbSignature = SIZEOF (rgbSignature),
                 cbCert      = SIZEOF (cert);
    DRM_RESULT   dr          = DRM_SUCCESS;

    /* decode the base64-encoded signature and certificate */

    ChkDR(DRM_B64_DecodeW(f_pdstrDataSignIn,        &cbSignature, rgbSignature,       0));
    ChkDR(DRM_B64_DecodeW(f_pdstrDataCertificateIn, &cbCert,      (DRM_BYTE *) &cert, 0));
    
    /* verify the certificate chain */
    ChkDR(DRM_UTL_CheckCert(&cert, 
                            &g_pubkeyRootMeteringCert, 
                             FALSE, 
                             f_pcontextLEVL));

    /* verify the signature */

    if (DRM_PK_Verify(&f_pcontextLEVL->pcontextBBX->CryptoContext, 
                      &cert.cd.pk, 
                       pbData, 
                       cbData, 
                       rgbSignature) == FALSE)
    {
        ChkDR(DRM_E_INVALID_SIGNATURE);
    }
    
ErrorExit:    

    return dr;
} /* _VerifySignature */

/*******************************************************************
 *              PRIVATE FUNCTION _DecryptRecords
 *
 * purpose: Decrypts-in-place 
 *******************************************************************/

static DRM_BOOL _DecryptRecords (IN OUT DRM_CONST_STRING *f_pdstrRecords, 
                                 IN     DRM_BYTE          f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)])
{
    RC4_KEYSTRUCT keystruct   = { 0 }; 
    DRM_RESULT    dr          = DRM_SUCCESS;
    DRM_DWORD     cbReqd      = 0;

    /* pdstrRecords now holds a B64 representation of encrypted <KID> tags */                       

    ChkDR(DRM_B64_DecodeW(f_pdstrRecords, 
                         &cbReqd, 
                          NULL, 
                          DRM_BASE64_DECODE_IN_PLACE));
    
    DRM_RC4_KeySetup(&keystruct, 
                      SHA_DIGEST_LEN, 
                      f_rgbPasswordSST);
                       
    DRM_RC4_Cipher(&keystruct, 
                    CB_DSTR(f_pdstrRecords), 
                    PB_DSTR(f_pdstrRecords));
                       
    /* pdstrRecords now holds the decrypted string: <KID value="ABCdef123=="/> */                       

ErrorExit:    
    return DRM_SUCCEEDED(dr);
}


/*****************************************************************************
** Function: _CreateMeterStorePassword
**
** Synopsis: use the MID to create the hash used as the secure store password 
**           for this MID
**
** Arguments:
**           [f_pdstrMID]       -- the MID as base64
**           [f_rgbPasswordSST] -- buffer to receive the password
**           [f_pcontextBBX]    -- initialized BBX context
*****************************************************************************/

static DRM_RESULT _CreateMeterStorePassword(
    IN     DRM_CONST_STRING *f_pdstrMID,
       OUT DRM_BYTE          f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)],
    IN     DRM_BB_CONTEXT   *f_pcontextBBX)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR(DRM_BBX_HashValue(PB_DSTR(f_pdstrMID), 
                            CB_DSTR(f_pdstrMID),
                            f_rgbPasswordSST,
                            f_pcontextBBX));

ErrorExit:
    return dr;
}


static DRM_RESULT _ParseControlData(
    IN const DRM_CONST_STRING    *f_pdstrMeterCert,
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
       OUT   PUBKEY              *f_ppubkeyMAS,
       OUT   DRM_CONST_STRING    *f_pdstrDataMID,
       OUT   DRM_MID             *f_pmid,
       OUT   DRM_CONST_STRING    *f_pdstrDataURL)
{
    DRM_RESULT       dr                  = DRM_SUCCESS;
    DRM_CONST_STRING dstrListTop         = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrListData        = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrListSignature   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrListCertChain   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNodeData        = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataPublicKey   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataSignature   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataCertificate = EMPTY_DRM_STRING;    
    DRM_DWORD        cbMID               = SIZEOF(DRM_MID);
    DRM_DWORD        cbPublicKey         = SIZEOF(PUBKEY);

    /* some processors require WORD-alignment; FAIL if this string is unaligned */
    ChkArg(((DRM_DWORD_PTR) f_pdstrMeterCert->pwszString) % SIZEOF (DRM_WCHAR) == 0);

    ChkDR(DRM_XML_GetNode(f_pdstrMeterCert,   &g_dstrTagMeterCert,        NULL, NULL, 0, NULL,          &dstrListTop));
    ChkDR(DRM_XML_GetNode(&dstrListTop,       &g_dstrTagData,             NULL, NULL, 0, &dstrNodeData, &dstrListData));
    ChkDR(DRM_XML_GetNode(&dstrListTop,       &g_dstrTagSignature,        NULL, NULL, 0, NULL,          &dstrListSignature));
    ChkDR(DRM_XML_GetNode(&dstrListTop,       &g_dstrTagCertificateChain, NULL, NULL, 0, NULL,          &dstrListCertChain))
    ChkDR(DRM_XML_GetNode(&dstrListData,      &g_dstrTagMID,              NULL, NULL, 0, NULL,          f_pdstrDataMID));
    ChkDR(DRM_XML_GetNode(&dstrListData,      &g_dstrTagURL,              NULL, NULL, 0, NULL,          f_pdstrDataURL));
    ChkDR(DRM_XML_GetNode(&dstrListData,      &g_dstrTagDataPubKey,       NULL, NULL, 0, NULL,          &dstrDataPublicKey));
    ChkDR(DRM_XML_GetNode(&dstrListSignature, &g_dstrTagValue,            NULL, NULL, 0, NULL,          &dstrDataSignature));
    ChkDR(DRM_XML_GetNode(&dstrListCertChain, &g_dstrTagCertificate,      NULL, NULL, 0, NULL,          &dstrDataCertificate));

    /* verify the certificate and signature against the metering public key */
    ChkDR(_VerifySignature(&dstrNodeData, &dstrDataSignature, &dstrDataCertificate, f_pcontextLEVL));

    /* base 64 decode the necessary fields */
    ChkDR(DRM_B64_DecodeW(&dstrDataPublicKey, &cbPublicKey, (DRM_BYTE *)f_ppubkeyMAS, 0));
    ChkDR(DRM_B64_DecodeW(f_pdstrDataMID,     &cbMID,       (DRM_BYTE *)f_pmid,       0));    

ErrorExit:
    return dr;
}


/*****************************************************************************
** Function: _ProcessOneKid
**
** Synopsis: read action/count entries - this test is to avoid accidentally 
**           parsing any "scrap" at the end of the buffer
**
** Arguments:
*****************************************************************************/
static DRM_RESULT _ProcessOneKid(
    IN     DRM_DWORD         f_cbDataKID,
    IN     DRM_BYTE         *f_pbDataKID,
       OUT DRM_CONST_STRING *f_pdstrData,
    IN OUT DRM_BYTE         *f_pbAlignedBuffer)
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_DWORD  ibCurr = 0;

    while ( ((ibCurr + CB_OPERATION_MINIMUM - 1) < f_cbDataKID)  &&  DRM_SUCCEEDED(dr) )
    {
        DRM_CONST_STRING  dstrOper = EMPTY_DRM_STRING;
        DRM_BYTE         *pbAction = NULL;
        DRM_WORD          cbCurr   = 0;
        DRM_WCHAR         awchNum[16];
        TOKEN             token;

        /* string size */
        DRM_BYT_CopyBytes(&cbCurr, 0, f_pbDataKID, ibCurr, SIZEOF (DRM_WORD));
        FIX_ENDIAN_WORD( cbCurr );
        ibCurr += SIZEOF (DRM_WORD);        

        
        /* string "Play" or whatever */
        if ((ibCurr % CB_NATIVE_BYTE) != 0)
        {
            /* if the UNICODE string isn't aligned in the packed buffer then move the string one 
               char to the left (this is safe, the data won't be reparsed) */
            pbAction = (f_pbDataKID + __CB_DECL((ibCurr & ~CB_NATIVE_BYTE)));
            DRM_BYT_CopyBytes(pbAction, 0, f_pbDataKID, ibCurr, cbCurr);
        }
        else
        {
            pbAction = f_pbDataKID + __CB_DECL(ibCurr);
        }

        DSTR_FROM_PB(&dstrOper, pbAction, cbCurr);
        ibCurr += cbCurr;

        
        /* count size */
        DRM_BYT_CopyBytes(&token, 0, f_pbDataKID, ibCurr, SIZEOF (token));
        FIX_ENDIAN_DWORD( token.val.lValue );
        ibCurr += SIZEOF (TOKEN);        
        
        f_pdstrData->cchString  = DRM_UTL_NumberToString (token.val.lValue, awchNum, NO_OF (awchNum));
        f_pdstrData->pwszString = awchNum;

        
        /* got all the data for this KID; write its XML node: <ACTION value="play">1</ACTION> */
        dr = DRM_XMB_WriteTag(
                 f_pbAlignedBuffer, 
                 &g_dstrTagAction, 
                 f_pdstrData, 
                 &g_dstrLabelValue, 
                 &dstrOper, 
                 wttClosed);
    } /* end while operations and counts */

    return dr;
}


/*****************************************************************************
** Function: _ProcessAllKIDs
**
** Synopsis: Process all KIDs for the challenge that can fit 
**           
**
** Arguments:
*****************************************************************************/
static DRM_RESULT _ProcessAllKIDs(
    IN       DRM_METERINGENUM_CONTEXT    *f_pmeterenum,
    IN       DRM_METERING_CONTEXT        *f_pmeterstore,
    IN const DRM_MID                     *f_pmid,
    IN       DRM_BYTE                     f_rgbPasswordSST[__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_HDS_CONTEXT             *f_pcontextHDS,
    IN       DRM_STACK_ALLOCATOR_CONTEXT *f_pcontextStack,
       OUT   DRM_BYTE                    *f_pbAlignedBuffer,
       OUT   DRM_DWORD                   *f_pcKIDs,
       OUT   DRM_BOOL                    *f_pfPartial)
{
    DRM_RESULT        dr        = DRM_SUCCESS;
    DRM_RESULT        drXMB     = DRM_SUCCESS;
    DRM_KID           kid       = { 0 };
    DRM_BYTE         *pbDataKID = NULL;
    DRM_WCHAR        *pwchKID   = NULL;
    DRM_CONST_STRING  dstrData  = EMPTY_DRM_STRING;

    ChkArg(f_pmeterenum     != NULL
        && f_pmeterstore    != NULL
        && f_pmid           != NULL
        && f_rgbPasswordSST != NULL
        && f_pcontextHDS    != NULL
        && f_pcontextStack  != NULL
        && f_pbAlignedBuffer!= NULL
        && f_pcKIDs         != NULL
        && f_pfPartial      != NULL);

    *f_pfPartial = FALSE;

    ChkDR(DRM_STK_Alloc(f_pcontextStack, (CCH_BASE64_EQUIV (SIZEOF (kid)) * SIZEOF (DRM_WCHAR)), (DRM_VOID **) &pwchKID));

    while( DRM_SUCCEEDED(drXMB) )
    {
        DRM_DWORD cchKID    = 0;
        DRM_DWORD cbDataKID = 0; 
        DRM_DWORD ibCurr    = 0;
        XMBState  xmbState  = {0};
    
        dr = DRM_MTR_EnumNext (f_pmeterenum, &kid, &cbDataKID);

        if (dr == DRM_E_NOMORE)
        {
            dr = DRM_SUCCESS;
            break;
        }
        ChkDR(dr);
        
        /* don't try to read the pseudo-KID representing the current transaction */

        if (MEMCMP(&kid, &g_kidTID,     SIZEOF (DRM_KID)) == 0
        ||  MEMCMP(&kid, &g_kidTIDPrev, SIZEOF (DRM_TID)) == 0)
        {
            continue;
        }

        dr = DRM_MTR_EnumLoadCurrent(f_pmeterenum, 
                                     f_pmeterstore, 
                                     f_rgbPasswordSST, 
                                    &kid, 
                                    &cbDataKID);

        if (dr == DRM_E_NOMORE)
        {
            dr = DRM_SUCCESS;
            break;
        }

        ChkDR(dr);

        dr = _GetKIDData(f_pmeterstore, 
                         f_pcontextStack, 
                        &pbDataKID, 
                        &cbDataKID);

        if (DRM_FAILED(dr))
        {
            break;
        }

        if (cbDataKID == 0
        ||  pbDataKID == NULL)
        {
            continue;    /* skip this empty slot */
        }
        
        /* set up for parsing KID data, _RequiredCharsForKID validates the stream integrity */

        dr = _RequiredCharsForKID (pbDataKID, cbDataKID, &cchKID);

        if (DRM_FAILED(dr))        
        {
            break;
        }

        /* open <KID value="base64encoded kid"> node */

        cchKID = CCH_BASE64_EQUIV (SIZEOF(DRM_KID));                    
        
        ChkDR(DRM_B64_EncodeW((DRM_BYTE *) &kid, SIZEOF(kid), pwchKID, &cchKID, 0));
        
        dstrData.pwszString = pwchKID;
        dstrData.cchString  = cchKID;

        /* save the xml builder state and build the KID node */

        drXMB = DRM_XMB_SaveState(f_pbAlignedBuffer, &xmbState);
        drXMB = DRM_XMB_WriteTag (f_pbAlignedBuffer, &g_dstrTagKID, NULL, &g_dstrLabelValue, &dstrData, wttOpen);

        /* read action/count entries 
        ** this test is to avoid accidentally parsing any "scrap" at the end of the buffer */

        if (DRM_SUCCEEDED(drXMB))
        {
            drXMB = _ProcessOneKid(cbDataKID, pbDataKID, &dstrData, f_pbAlignedBuffer);

            SAFE_STK_FREE(f_pcontextStack, pbDataKID);

            if (DRM_SUCCEEDED(drXMB))
            {
                drXMB = DRM_XMB_CloseCurrNode(f_pbAlignedBuffer,  NULL);          /* </KID> */

                if (DRM_SUCCEEDED(drXMB))
                {
                    (*f_pcKIDs)++;   /* count # of KIDs processed */
                }
            }
        }
        
        if (DRM_FAILED(drXMB))
        {
            /* restore XMB state to where it was before adding the current <KID> node */
            
            drXMB        = DRM_XMB_RestoreState(f_pbAlignedBuffer, &xmbState);
            *f_pfPartial = TRUE;
            break;
        }
    } /* end while more KIDs */

ErrorExit:

    SAFE_STK_FREE(f_pcontextStack, pbDataKID);
    SAFE_STK_FREE(f_pcontextStack, pwchKID);
    return dr;
}


/*****************************************************************************
** Function: _BuildChallenge
**
** Synopsis: Build a challenge for sizeonly, overhead only or real
**           - if *f_pcbChallenge, a sizeonly will be processed
**           - if f_pcwchTrailsize != NULL, no kid will be included
**           
**
** Arguments:
*****************************************************************************/
static DRM_RESULT _BuildChallenge(
    IN OUT   DRM_BYTE                    *f_pbAlignedBuffer,
    IN OUT   DRM_DWORD                   *f_pcbChallenge,
       OUT   DRM_STRING                  *f_pdstrXML,
    IN       DRM_CONST_STRING            *f_pdstrDataMID,
    IN const DRM_CONST_STRING            *f_pdstrDataURL,
    IN       DRM_CONST_STRING            *f_pdstrDataTID,
    IN       DRM_METERINGENUM_CONTEXT    *f_pmeterenum,
    IN       DRM_STACK_ALLOCATOR_CONTEXT *f_pcontextStack,
    IN       DRM_METERING_CONTEXT        *f_pmeterstore,
    IN const DRM_MID                     *f_pmid,
    IN       DRM_BYTE                     f_rgbPasswordSST[__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_HDS_CONTEXT             *f_pcontextHDS,
    IN       DRM_BB_CONTEXT              *f_pcontextBlackBox,
    IN       PUBKEY                      *f_ppubkeyMAS,
    IN       PKCERT                      *f_pBBCert,
       OUT   DRM_DWORD                   *f_pcwchTrailsize) 
{
    DRM_RESULT  dr          = DRM_SUCCESS;
    DRM_DWORD   cbEffBuffer = 0;
    DRM_DWORD   cKIDs       = 0;
    XMBState    stateXMB    = { 0 };
    DRM_DWORD   iwchXMB     = 0;
    DRM_BOOL    fPartial    = FALSE;
    DRM_STRING  dstrRecordsNode  = EMPTY_DRM_STRING;
    DRM_WCHAR  *pwszB64Signature = NULL;
    DRM_WCHAR  *pwszB64FallbackCert = NULL;

    /* <METERDATA type="challenge"> */
    ChkDR(DRM_XMB_AddAttribute(f_pbAlignedBuffer, &g_dstrAttributeType, &g_dstrChallenge));

    /* add other nodes 
    */
    ChkDR(DRM_XMB_WriteTag(f_pbAlignedBuffer, &g_dstrTagData, NULL,           NULL, NULL, wttOpen));   /*       <DATA> */
    ChkDR(DRM_XMB_WriteTag(f_pbAlignedBuffer, &g_dstrTagURL,  f_pdstrDataURL, NULL, NULL, wttClosed)); /*        <URL>...</URL> */
    ChkDR(DRM_XMB_WriteTag(f_pbAlignedBuffer, &g_dstrTagMID,  f_pdstrDataMID, NULL, NULL, wttClosed)); /*        <MID>...</MID> */
    ChkDR(DRM_XMB_WriteTag(f_pbAlignedBuffer, &g_dstrTagTID,  f_pdstrDataTID, NULL, NULL, wttClosed)); /*        <TID>base64-encode</TID> */

    /* Open the <RECORDS> node and enumerate the Key IDs for this Metering ID */
    ChkDR(DRM_XMB_WriteTag(f_pbAlignedBuffer, &g_dstrTagRecords, NULL, NULL, NULL, wttOpen));   /*        <RECORDS> */

    if ( f_pcwchTrailsize == NULL )
    {
        /* from this point on, if buffer too small, do a partial one */

        ChkDR(_ProcessAllKIDs(f_pmeterenum,
                              f_pmeterstore,
                              f_pmid,
                              f_rgbPasswordSST,
                              f_pcontextHDS,
                              f_pcontextStack,
                              f_pbAlignedBuffer,
                             &cKIDs,
                             &fPartial));
        
        /* conclude the challenge */

        if (cKIDs == 0 
        &&  fPartial)
        {
            /* we do not have enough buffer to do one KID. */
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
    }

    if (*f_pcbChallenge > 0)
    {
        /* use actual buffer size if this is a real run */
        ChkDR( DRM_XMB_ReallocDocument(f_pbAlignedBuffer, *f_pcbChallenge, f_pbAlignedBuffer) );
    }

    /* save current state of XMB for the purpose of marking the begining of XML trailer */
    if ( f_pcwchTrailsize != NULL )
    {
        ChkDR(DRM_XMB_SaveState(f_pbAlignedBuffer, &stateXMB));
    }

    /* encrypt and base64-encode the entire RECORDS section in place: </RECORDS> */
    ChkDR(DRM_XMB_EncryptAndCloseCurrNode(
                f_pbAlignedBuffer, 
                &f_pcontextBlackBox->CryptoContext, 
                f_ppubkeyMAS, 
                &dstrRecordsNode)); 

    /* if not all KIDs could fit in the output buffer, add a tag indicating that there is more to do */

    if (fPartial)
    {
        /* <PARTIALDATA>1</PARTIALDATA> */
        ChkDR(DRM_XMB_WriteTag(f_pbAlignedBuffer, &g_dstrTagPartialData, &g_dstr1, NULL, NULL, wttClosed)); 
    }

    /* Close and Sign the <DATA> node with device private key */
    {
        DRM_CONST_STRING dstrData   = EMPTY_DRM_STRING;
        DRM_DWORD        cbRequired = PK_ENC_SIGNATURE_B64LEN;


        /* alloc memory from local stack */
        ChkDR(DRM_STK_Alloc(f_pcontextStack, 
                            PK_ENC_SIGNATURE_B64LEN * SIZEOF (DRM_WCHAR), 
             (DRM_VOID **) &pwszB64Signature));
        
        ChkDR(DRM_XMB_CloseCurrNode(f_pbAlignedBuffer, (DRM_STRING *)&dstrData));

        if (*f_pcbChallenge > 0)
        {
            ChkDR(DRM_BBX_SignData(f_pcontextBlackBox, 
                                   PB_DSTR(&dstrData),
                                   CB_DSTR(&dstrData), 
                                   eBBX_PRIVKEY_MACHINE,
                                   (DRM_BYTE *) pwszB64Signature));
        }              

        /* encode in-place */

        ChkDR(DRM_B64_EncodeW((DRM_BYTE *)pwszB64Signature,  /* encode in-place */
                               PK_ENC_SIGNATURE_LEN, 
                               pwszB64Signature, 
                               &cbRequired,
                               0));

        /* <MSDRM_SIGNATURE_VALUE>base64</MSDRM_SIGNATURE_VALUE> */    
        dstrData.cchString  = PK_ENC_SIGNATURE_B64LEN;
        dstrData.pwszString = pwszB64Signature;

        ChkDR(DRM_XMB_WriteTag(f_pbAlignedBuffer, &g_dstrTagMSDRMSignature,  &dstrData, NULL, NULL, wttClosed)); 
    }

    /* <CERTIFICATE private="1">B64-fallback cert</CERTIFICATE> */
    {
        DRM_CONST_STRING dstrFallbackCert = EMPTY_DRM_STRING;

        /* alloc memory from local stack */
        ChkDR(DRM_STK_Alloc(f_pcontextStack, 
                            (CCH_BASE64_EQUIV(SIZEOF(PKCERT)) * SIZEOF(DRM_WCHAR)), 
                            (DRM_VOID **) &pwszB64FallbackCert));
        
        dstrFallbackCert.cchString  = CCH_BASE64_EQUIV(SIZEOF(PKCERT));
        dstrFallbackCert.pwszString = pwszB64FallbackCert;

        ChkDR(DRM_B64_EncodeW((DRM_BYTE *)f_pBBCert, SIZEOF(PKCERT), pwszB64FallbackCert, &dstrFallbackCert.cchString, 0));

        ChkDR(DRM_XMB_WriteTag(f_pbAlignedBuffer, &g_dstrTagCertificate, &dstrFallbackCert, &g_dstrRootSigValueVersionTag, &g_dstrRootSigValueVersionVal, wttClosed));

        /* </METERDATA> */
        ChkDR(DRM_XMB_CloseDocument(f_pbAlignedBuffer, f_pdstrXML)); 

        if ( f_pcwchTrailsize != NULL )
        {
            *f_pcwchTrailsize = f_pdstrXML->cchString - stateXMB.iwchNextStringPos;
        }
    }

ErrorExit:

    SAFE_STK_FREE(f_pcontextStack, pwszB64FallbackCert);
    SAFE_STK_FREE(f_pcontextStack, pwszB64Signature);
    
    return dr;
}



/*****************************************************************************
** Function: _AttemptGenerateMeterChallenge
**
** Synopsis: open the secure store for a given MID and create a metering 
**           challenge XML blob.  A two-stage call, one to get required
**           sizes and another to fill in allocated buffers
**
** Arguments:
**           [f_pcontextBB]     -- initialized blackbox context
**           [f_pcontextHDS]    -- initialized HDS context
**           [f_pBBCert]        -- pointer to fallback cert
**           [f_pbStack]           
**           [f_cbStack]        -- pointer and size to a buffer to use for allocations
**           [f_eMode]          -- enumerative type indicating the "state" of this call
**           [f_pbChallenge]    -- buffer that will receive XML; NULL to
**                                 request buffer size
**           [f_pcbChallenge]   -- points to DWORD filled in with buffer
**                                 size, or to receive requested size
**           [f_pcKIDs]         -- (optional) to specify # of KIDs to be in the challenge. 
**                                 use NULL or value 0 to get a full challenge.
**                                 Returns count of KIDs available in query mode
**           [f_pcbRecords]     -- (optional) to return the count of byte in the <RECORDS> node
**           [f_ppubkeyMAS]     -- metering authority public key extracted from the meter cert
**           [f_pdstrDataMID]   -- metering ID extracted from the meter cert
**           [f_pmid]           -- metering ID extracted from the meter cert as binary
**           [f_pdstrDataURL]   -- metering URL to write to challenge
*****************************************************************************/

static DRM_RESULT _AttemptGenerateMeterChallenge(
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN       DRM_BYTE            *f_pbStack,
    IN       DRM_DWORD            f_cbStack,
       OUT   DRM_BYTE            *f_pbChallenge,
    IN OUT   DRM_DWORD           *f_pcbChallenge,
    IN       PUBKEY              *f_ppubkeyMAS,
    IN       DRM_CONST_STRING    *f_pdstrDataMID,
    IN const DRM_MID             *f_pmid,
    IN const DRM_CONST_STRING    *f_pdstrDataURL)
{
    DRM_RESULT                   dr = DRM_SUCCESS;
    DRM_METERING_CONTEXT        *pmeterstore      = NULL;
    DRM_METERINGENUM_CONTEXT    *pmeterenum       = NULL;
    DRM_STACK_ALLOCATOR_CONTEXT  contextStack     = { 0, 0, NULL };
    DRM_KID                      kid              = { 0 };
    DRM_TID                      tid              = { 0 };
    DRM_BYTE                     rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)] = { 0 };
    
    DRM_WCHAR        *pwchTID          = NULL;
    DRM_WCHAR        *pwchKID          = NULL;
    DRM_STRING        dstrRecordsNode  = EMPTY_DRM_STRING;
    DRM_STRING        strXML           = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrData         = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrFallbackCert = EMPTY_DRM_STRING;
    DRM_BYTE         *pbAlignedBuffer  = f_pbChallenge;
    DRM_BYTE         *pbTempBuff       = NULL;
    DRM_DWORD         cbAdjustment     = 0;
    DRM_BYTE         *pbBuffer      = NULL;
    DRM_DWORD         cwchTrailsize    = 0;
    
    ChkArg(f_pcontextLEVL != NULL
        && f_pcontextLEVL->pcontextBBX != NULL
        && f_pcontextLEVL->pcontextHDS != NULL
        && f_ppubkeyMAS   != NULL
        && f_pdstrDataMID != NULL
        && f_pmid         != NULL
        && f_pdstrDataURL != NULL
        && f_pcbChallenge != NULL
        && f_pbStack      != NULL
        && f_cbStack       > 0);

#if SIXTEEN_BIT_ADDRESSING
    pbAlignedBuffer = f_pbChallenge;
#else

    /* since this buffer is passed in as bytes, misalignment should not be regarded as a FAIL;
    ** adjust the buffer pointer for the duration 
    */
    if (f_pbChallenge != NULL)
    {
        ChkDR(DRM_UTL_EnsureDataAlignment(f_pbChallenge, *f_pcbChallenge, &pbAlignedBuffer, f_pcbChallenge, SIZEOF (DRM_DWORD), &cbAdjustment));
    }
#endif
    
    contextStack.cbStack = f_cbStack;
    contextStack.pbStack = f_pbStack;

    /* allocate large variables off the local stack 
    */
    if ( f_pbChallenge == NULL  ||  *f_pcbChallenge == 0)    
    {
        ChkDR(DRM_STK_Alloc(&contextStack, DRM_SIMXMLDOC_BUFFSIZE, (DRM_VOID **)&pbTempBuff));
        pbAlignedBuffer = pbTempBuff;
    }

    ChkDR(DRM_STK_Alloc(&contextStack, (CCH_BASE64_EQUIV (SIZEOF (tid)) * SIZEOF (DRM_WCHAR)), (DRM_VOID **) &pwchTID));
    ChkDR(DRM_STK_Alloc(&contextStack, (CCH_BASE64_EQUIV (SIZEOF (kid)) * SIZEOF (DRM_WCHAR)), (DRM_VOID **) &pwchKID));

    ChkDR(DRM_STK_Alloc(&contextStack, SIZEOF(DRM_METERING_CONTEXT),     (DRM_VOID **) &pmeterstore));
    ChkDR(DRM_STK_Alloc(&contextStack, SIZEOF(DRM_METERINGENUM_CONTEXT), (DRM_VOID **) &pmeterenum));

    /* create the password that will be used to access the secure store
    ** note: the use of the B64 as the key rather than the decoded MID is by design 
    */
    ChkDR(_CreateMeterStorePassword(f_pdstrDataMID, rgbPasswordSST, f_pcontextLEVL->pcontextBBX));
  
    /* 
    ** get the TID from the metering store 
    ** if there is no TID in the meter store for this MID, create it now 
    */

    dstrData.cchString  = CCH_BASE64_EQUIV (SIZEOF (DRM_TID));
    dstrData.pwszString = pwchTID;

    dr = _ReadTIDFromMeteringStore( pmeterstore,
                                    rgbPasswordSST,
                                    f_pmid,
                                   &tid,
                                   &dstrData,
                                    f_pcontextLEVL->pcontextHDS );

    if (DRM_FAILED(dr))
    {
    ChkDR(_CreateNewTID (&tid));
    ChkDR(_WriteTIDToMeteringStore(pmeterstore, rgbPasswordSST, f_pmid, &tid, f_pcontextLEVL->pcontextHDS));
    ChkDR(DRM_B64_EncodeW((DRM_BYTE *)&tid, SIZEOF(tid), (DRM_WCHAR *)dstrData.pwszString, &dstrData.cchString, 0));
    }

    /* start creating the meter challenge 
    ** enumerate the storages 
    */
    ChkDR( DRM_MTR_InitEnum(f_pmid, pmeterenum, f_pcontextLEVL->pcontextHDS) );

    /* this is a query for the required buffer size; fake it */
    if ( *f_pcbChallenge == 0  ||  f_pbChallenge == NULL )
    {
        /* <METERDATA type="challenge"> */
        ChkDR(DRM_XMB_SimulateCreateDocument(DRM_SIMXMLDOC_BUFFSIZE, pbAlignedBuffer, &g_dstrTagMetering));
        *f_pcbChallenge = 0;
    }
    else
    {
        /* calculate overhead size */
        DRM_DWORD cbEffBuffer = 0;
        DRM_DWORD cbRequired  = 0;

        ChkDR(DRM_STK_Alloc(&contextStack, DRM_SIMXMLDOC_BUFFSIZE, (DRM_VOID **)&pbBuffer));
        ChkDR(DRM_XMB_SimulateCreateDocument(DRM_SIMXMLDOC_BUFFSIZE, pbBuffer, &g_dstrTagMetering));

        /* calculate the buffer requirements without KIDs */

        ChkDR(_BuildChallenge(pbBuffer,
                             &cbEffBuffer,
                             &strXML,
                              f_pdstrDataMID,
                              f_pdstrDataURL,
                             &dstrData,
                              pmeterenum,
                             &contextStack,
                              pmeterstore,
                              f_pmid,
                              rgbPasswordSST,
                              f_pcontextLEVL->pcontextHDS,
                              f_pcontextLEVL->pcontextBBX,
                              f_ppubkeyMAS,
                             &f_pcontextLEVL->pcontextBBX->cachedCertValues.m_BBCompatibilityCert,
                             &cwchTrailsize));
        SAFE_STK_FREE(&contextStack, pbBuffer);

        /* calculate effective buffer size before encryption and b64 encode: 
        ** encryption will increase the XML blob by PK_ENC_CIPHERTEXT_LEN bytes
        ** B64 encode increase the XML blob by 8/3 of the encrypted content: 4/3 for B64 encode and 2 (sizeof(WCHAR) bytes for unicode */

        cbRequired = (CB_DSTR(&strXML) 
                   + cbAdjustment 
                   + DRM_XMB_OVERHEAD 
                   + DRM_SIMXMLDOC_BUFFSIZE)
                   + CCH_BASE64_ENC_LARGE_WCH(DRM_SIMXMLDOC_BUFFSIZE);
        
        if (*f_pcbChallenge < cbRequired)
        {
            *f_pcbChallenge = cbRequired;
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* max allowable buffer size for KIDS 
        ** available KIDs data = buffersize - XML builder overhead - challenge string overhead
        */
        cbEffBuffer = (((*f_pcbChallenge - DRM_XMB_OVERHEAD - CB_DSTR(&strXML)) / (4 * SIZEOF(DRM_WCHAR))) * 3)
                    - PK_ENC_CIPHERTEXT_LEN;

        /* adjusted size for XMB context */
        cbEffBuffer += SIZEOF(_XMBContext) + CB_DSTR(&strXML) - (cwchTrailsize * SIZEOF(DRM_WCHAR));

        /* <METERDATA type="challenge"> */            
        ChkDR(DRM_XMB_CreateDocument(cbEffBuffer, pbAlignedBuffer, &g_dstrTagMetering)); 
    }

    ChkDR(_BuildChallenge(pbAlignedBuffer,
                          f_pcbChallenge,
                         &strXML,
                          f_pdstrDataMID,
                          f_pdstrDataURL,
                         &dstrData,
                          pmeterenum,
                         &contextStack,
                          pmeterstore,
                          f_pmid,
                          rgbPasswordSST,
                          f_pcontextLEVL->pcontextHDS,
                          f_pcontextLEVL->pcontextBBX,
                          f_ppubkeyMAS,
                         &f_pcontextLEVL->pcontextBBX->cachedCertValues.m_BBCompatibilityCert,
                          NULL));

    /* 
    ** if we are building a challenge then report the actual usage and copy into the head of the buffer 
    */

    if (f_pbChallenge != NULL)
    {
        *f_pcbChallenge = CB_DSTR(&strXML);

        strXML.pwszString [strXML.cchString] = g_wchNull;

        /* save the results in output buffers */

        MEMMOVE(f_pbChallenge, strXML.pwszString, *f_pcbChallenge + SIZEOF(DRM_WCHAR));
    }
    else
    {
	    /*
	    ** if we're querying for required size include the overhead requirements 
	    */

        *f_pcbChallenge = CB_DSTR(&strXML) 
                        + cbAdjustment 
                        + DRM_XMB_OVERHEAD 
                        + DRM_SIMXMLDOC_BUFFSIZE
                        + CCH_BASE64_ENC_LARGE_WCH(DRM_SIMXMLDOC_BUFFSIZE);
    }

ErrorExit:

    SAFE_STK_FREE(&contextStack, pbBuffer);
    SAFE_STK_FREE(&contextStack, pmeterenum);
    SAFE_STK_FREE(&contextStack, pmeterstore);
    SAFE_STK_FREE(&contextStack, pwchKID);
    SAFE_STK_FREE(&contextStack, pwchTID);
    SAFE_STK_FREE(&contextStack, pbTempBuff);

    return dr;
} /* _AttemptGenerateMeterChallenge */




/*****************************************************************************
** Function: DRM_MTR_GenerateMeterChallenge 
**
** Synopsis: open the secure store for a given MID and create a metering 
**           challenge XML blob.  A two-stage call, one to get required
**           sizes and another to fill in allocated buffers
**
** Arguments:
**           [f_pcontextLEVL]   -- initialized license evaluator context
**           [f_pbStack]           
**           [f_cbStack]        -- pointer and size to a buffer to use for allocations
**           [f_pdstrMeterCert] -- XML blob representing the metering
**                                 certificate for the MAS that will 
**                                 receive the metering challenge
**           [f_pbChallenge]    -- buffer that will receive XML; NULL to
**                                 request buffer size
**           [f_pcbChallenge]   -- points to DWORD filled in with buffer
**                                 size, or to receive requested size
**           [f_pwszURL]        -- optional buffer to receive metering URL; 
**                                 NULL to request buffer size
**           [f_pcchURL]        -- points to DWORD filled in with URL length
**                                 (in characters, not bytes) or to receive requested size
*****************************************************************************/

DRM_RESULT DRM_API DRM_MTR_GenerateMeterChallenge(
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN       DRM_BYTE            *f_pbStack,
    IN       DRM_DWORD            f_cbStack,
    IN const DRM_CONST_STRING    *f_pdstrMeterCert,
       OUT   DRM_BYTE            *f_pbChallenge,
    IN OUT   DRM_DWORD           *f_pcbChallenge,
       OUT   DRM_WCHAR           *f_pwszURL,
    IN OUT   DRM_DWORD           *f_pcchURL)
{
    DRM_RESULT        dr = DRM_SUCCESS;
    PUBKEY            pubkeyMAS;
    DRM_MID           mid;
    DRM_CONST_STRING  dstrDataMID = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrDataURL = EMPTY_DRM_STRING;

    ChkArg(f_pcontextLEVL   != NULL
        && f_pbStack        != NULL
        && f_cbStack         > 0
        && f_pdstrMeterCert != NULL
        && f_pcbChallenge   != NULL);

    ChkDR(_ParseControlData(f_pdstrMeterCert, f_pcontextLEVL, &pubkeyMAS, &dstrDataMID, &mid, &dstrDataURL));

    /* 
    ** get sizes when: 
    ** challenge buffer is NULL or
    ** challenge size is NULL or
    ** URL size is not NULL and (URL size < actual size + 1  or  URL buffer is NULL)
    */
    if (f_pbChallenge  == NULL  
    || *f_pcbChallenge == 0 
    || (f_pcchURL      != NULL  
     && (*f_pcchURL < dstrDataURL.cchString + 1 
       || f_pwszURL == NULL)))
    {
        ChkDR(_AttemptGenerateMeterChallenge( f_pcontextLEVL,
                                              f_pbStack,
                                              f_cbStack,
                                              NULL, 
                                              f_pcbChallenge,
                                             &pubkeyMAS,
                                             &dstrDataMID,
                                             &mid, 
                                             &dstrDataURL));

        ChkDR(DRM_E_BUFFERTOOSMALL)
    }

    /* copy URL to buffer */

    if (f_pwszURL != NULL 
    &&  f_pcchURL != NULL)
    {
        MEMCPY(f_pwszURL, PB_DSTR(&dstrDataURL), CB_DSTR(&dstrDataURL));
        f_pwszURL [dstrDataURL.cchString] = g_wchNull;
    }

    /* generate the challenge */
    ChkDR(_AttemptGenerateMeterChallenge( f_pcontextLEVL,
                                          f_pbStack,
                                          f_cbStack,
                                          f_pbChallenge, 
                                          f_pcbChallenge,
                                         &pubkeyMAS,
                                         &dstrDataMID,
                                         &mid, 
                                         &dstrDataURL));

ErrorExit:

    if ( f_pcchURL != NULL )
    {
        *f_pcchURL = dstrDataURL.cchString + 1;
    }

    return dr;
} /* DRM_MTR_GenerateMeterChallenge */



static DRM_RESULT _LocateKIDInMeterStore(DRM_MID                  *f_pmid,
                                         DRM_METERING_CONTEXT     *f_pmeterstore,
                                         DRM_METERINGENUM_CONTEXT *f_pmeterenum,
                                         DRM_HDS_CONTEXT          *f_pcontextHDS,
                                         DRM_KID                  *f_pkid)
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_KID     kid     = { 0 };
    DRM_DWORD   cbData  =   0;
    DRM_BOOL    fPass2  = FALSE;

    while (TRUE)
    {
        dr = DRM_MTR_EnumNext(f_pmeterenum, &kid, &cbData);

        if (DRM_SUCCEEDED(dr))
        {
            if (MEMCMP(&kid, f_pkid, SIZEOF(DRM_KID)) == 0)
            {
                dr = DRM_SUCCESS;
                break;
            }
        }

        /* if we reach the end without finding it then try a second pass but not a third 
        ** in any case leave the enumeration set up for the next one
        */

        else if (dr == DRM_E_NOMORE)
        {
            ChkDR(DRM_MTR_InitEnum(f_pmid,
                                   f_pmeterenum,
                                   f_pcontextHDS));

            if (fPass2)
            {
                ChkDR(DRM_E_NOMORE);
            }
            else
            {
                fPass2 = TRUE;
            }
        }
        else
        {
            ChkDR(dr);
        }
    }

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function: DRM_MTR_ProcessMeterResponse
**
** Synopsis: open the secure store for a given MID and delete the KIDs named
**           in the response XML
**
** Arguments:
**           [pvcontextBlackBoxIn] -- initialized blackbox context
**           [f_pbStack]           
**           [f_cbStack]  -- pointer and size to a buffer to use 
**                           for allocations
**           [f_pbData]   -- metering response XML
**           [f_cbData]   -- size of metering response XML in bytes
**           [f_pfFlags]-- points to DWORD filled in with any flags passed
**                           back to the caller.  
**           [f_pcontextHDS]-- initialized HDS context
**
** Notes: 
**         Currently defined flags:
**                           
**            DRM_METER_RESPONSE_PARTIAL - not all KIDs for this MID were sent
**                                         and another challenge should be 
**                                         generated
** Algorithm:
** After the <KID> areas are Base64 decoded and decrypted, it leaves 5/8 of the
** original size of the buffer at end. We can use that area to store all the 
** KIDs there for better retrieval performance. The KIDs found in the response 
** XML string are first Base64 decoded and the sorted and inserted in a list in
** ascending order. Then the list is reconciled with the Metering Store: the 
** store is enumerated for all KIDs associated with the MID, for each KIDs visited,
** it is matched with the list of sorted KIDs. When all the KIDs in the list is
** all matched or the metering stored is exhausted, we are done. 
*****************************************************************************/

DRM_RESULT DRM_API DRM_MTR_ProcessMeterResponse(
    IN     DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN     DRM_BYTE            *f_pbStack,
    IN     DRM_DWORD            f_cbStack,
    IN     DRM_BYTE            *f_pbData,
    IN     DRM_DWORD            f_cbData,
       OUT DRM_DWORD           *f_pfFlags)
{
    DRM_RESULT        dr             = DRM_SUCCESS;
    DRM_METERING_CONTEXT         *pmeterstore       = NULL;
    DRM_METERINGENUM_CONTEXT     *pmeterenum        = NULL;
    DRM_HDS_BLOCKSCAN_CONTEXT    *pcontextBlockScan = NULL;
    DRM_STACK_ALLOCATOR_CONTEXT   contextStack      = { 0, 0, NULL };
    DRM_MID           mid;
    DRM_KID           kid;
    DRM_TID           tid;
    DRM_KID          *pkids          = NULL;
    DRM_BYTE          rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)];
    DRM_WCHAR         awchTID [CCH_BASE64_EQUIV (SIZEOF (DRM_TID))];
    DRM_CONST_STRING  dstrXML        = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrListTop    = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrListData   = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrDataMID    = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrCertMID    = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrDataCmd    = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrKID        = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrTIDRequest = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrRecords    = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrTIDStore   = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrDataMore   = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrCertRoot   = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrCertSign   = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrCertChain  = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrCertData   = EMPTY_DRM_STRING;
    DRM_CONST_STRING  dstrCertPubkey = EMPTY_DRM_STRING;
    DRM_DWORD         cbDataTID      = 0; 
    DRM_DWORD         cbMID          = SIZEOF (mid);
    DRM_DWORD         cbBuffer       = 0;
    DRM_CONST_STRING dstrDataKID   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrAttrValue = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrTag       = EMPTY_DRM_STRING;
    DRM_BOOL         fIsLeaf       = FALSE;
    DRM_DWORD        cb            = 0;
    DRM_BYTE        *pbKIDs        = NULL;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_MTR_ProcessMeterResponse", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    /* must be WORD-aligned */

    ChkArg (((DRM_DWORD_PTR) f_pbData) % SIZEOF (DRM_WCHAR) == 0);
    
    ChkArg (f_pcontextLEVL != NULL
        &&  f_pbData       != NULL
        &&  f_pbStack      != NULL
        &&  f_pfFlags      != NULL
        &&  f_cbData        > 0
        &&  f_cbStack       > 0);

    *f_pfFlags = 0;

    contextStack.cbStack = f_cbStack;
    contextStack.pbStack = f_pbStack;

    DSTR_FROM_PB(&dstrXML, f_pbData, f_cbData);

    ChkDR(DRM_XML_GetNode (&dstrXML,      &g_dstrTagMetering, NULL, NULL, 0, NULL, &dstrListTop));

    /*
    ** First check the Meter cert signature
    ** Get the <DATA> with the tag
    ** Get the signature value
    */

    ChkDR( DRM_XML_GetNode( &dstrListTop,  &g_dstrTagMeterCert,         NULL, NULL, 0,  NULL,          &dstrCertRoot  ) );
    ChkDR( DRM_XML_GetNode( &dstrCertRoot, &g_dstrTagData,              NULL, NULL, 0, &dstrCertData,   NULL  ) );
    ChkDR( DRM_XML_GetNode( &dstrCertRoot, &g_dstrTagSignature,         NULL, NULL, 0, &dstrCertSign,   NULL  ) );
    ChkDR( DRM_XML_GetNode( &dstrCertRoot, &g_dstrTagCertificateChain,  NULL, NULL, 0, &dstrCertChain,  NULL  ) );
    ChkDR( DRM_UTL_VerifyXMLSignature( &dstrCertData, 
                                       &dstrCertSign, 
                                       &dstrCertChain, 
                                        FALSE, 
                                        TRUE, 
                                        WM_DRM_ROOTPUBKEY_MTR, 
                                        f_pcontextLEVL));  

    /* Now check the signature on Data portion of METERDATA */
    
    ChkDR( DRM_XML_GetNode( &dstrCertRoot, &g_dstrTagData,           NULL, NULL, 0, NULL,         &dstrCertData ) );   /* Get cert public key  */
    ChkDR( DRM_XML_GetNode( &dstrCertData, &g_dstrTagDataPubKey,     NULL, NULL, 0, NULL,         &dstrCertPubkey ) ); /* Get MID also to compare afterwards */
    ChkDR( DRM_XML_GetNode( &dstrCertData, &g_dstrTagMID,            NULL, NULL, 0, NULL,         &dstrCertMID ) );
    ChkDR( DRM_XML_GetNode( &dstrListTop,  &g_dstrTagData,           NULL, NULL, 0, &dstrListData, NULL ) );           /* Get the Meter <DATA> with the tag */
    ChkDR( DRM_XML_GetNode( &dstrListTop,  &g_dstrTagMSDRMSignature, NULL, NULL, 0, NULL,          &dstrCertSign ) );  /* Get Signature value */


    cbBuffer = SIZEOF(PUBKEY); 
    ChkDR(DRM_B64_DecodeW(&dstrCertPubkey, &cbBuffer,(DRM_BYTE*) &(f_pcontextLEVL->pcontextBBX->CryptoContext.pubKey), 0) );

    ChkDR(DRM_UTL_VerifyXMLSignatureEx(&dstrListData, &dstrCertSign, NULL, FALSE, FALSE, WM_DRM_ROOTPUBKEY_MTR, f_pcontextLEVL));

    cbBuffer = 0;

    /* get the MID, TID, and COMMAND data out of this XML blob */
    /* all are required */

    ChkDR(DRM_XML_GetNode (&dstrListTop,  &g_dstrTagData,     NULL, NULL, 0, NULL, &dstrListData));
    ChkDR(DRM_XML_GetNode (&dstrListData, &g_dstrTagMID,      NULL, NULL, 0, NULL, &dstrDataMID));
    ChkDR(DRM_XML_GetNode (&dstrListData, &g_dstrTagCmd,      NULL, NULL, 0, NULL, &dstrDataCmd));
    ChkDR(DRM_XML_GetNode (&dstrListData, &g_dstrTagTID,      NULL, NULL, 0, NULL, &dstrTIDRequest));
    ChkDR(DRM_XML_GetNode (&dstrListData, &g_dstrTagRecords,  NULL, NULL, 0, NULL, &dstrRecords));


    /*Verify MIDs*/
    if (! DRM_UTL_DSTRStringsEqual(&dstrCertMID,&dstrDataMID))
    {
        ChkDR(DRM_E_METERING_MID_MISMATCH);
    }
    
    
    /* get the optional PARTIALDATA tag */
    dr = DRM_XML_GetNode(&dstrListData,  &g_dstrTagPartialData, NULL, NULL, 0, NULL, &dstrDataMore);

    if (DRM_SUCCEEDED (dr)
    &&  dstrDataMore.cchString > 0)
    {
        *f_pfFlags = DRM_METER_RESPONSE_PARTIAL;
    }

    /* only the command "RESET" is supported */

    ChkBOOL(DRM_UTL_DSTRStringsEqual(&dstrDataCmd, &g_dstrReset), DRM_E_METERING_INVALID_COMMAND);

    ChkDR(_CreateMeterStorePassword(&dstrDataMID, rgbPasswordSST, f_pcontextLEVL->pcontextBBX));
    
    ChkDR(DRM_B64_DecodeW(&dstrDataMID, &cbMID, (DRM_BYTE *) &mid, 0));

    ChkDR(DRM_STK_Alloc(&contextStack, SIZEOF (DRM_METERING_CONTEXT),      (DRM_VOID **) &pmeterstore));
    ChkDR(DRM_STK_Alloc(&contextStack, SIZEOF (DRM_METERING_CONTEXT),      (DRM_VOID **) &pmeterenum));
    ChkDR(DRM_STK_Alloc(&contextStack, SIZEOF (DRM_HDS_BLOCKSCAN_CONTEXT), (DRM_VOID **) &pcontextBlockScan));

    /* get the TID from the metering store */

    dstrTIDStore.cchString  = NO_OF (awchTID);
    dstrTIDStore.pwszString =        awchTID;

    ChkDR(_ReadTIDFromMeteringStore(pmeterstore, 
                                    rgbPasswordSST, 
                                   &mid, 
                                   &tid, 
                                   &dstrTIDStore, 
                                    f_pcontextLEVL->pcontextHDS));

    /* verify that we have been passed the right TID */

    ChkBOOL(DRM_UTL_DSTRStringsEqual(&dstrTIDRequest, &dstrTIDStore), DRM_E_METERING_WRONG_TID);

    if (dstrRecords.cchString   > 0
    &&  dstrRecords.pwszString != NULL)
    {                                                                             
        DRM_CONST_STRING dstrDataInner = EMPTY_DRM_STRING;
        DRM_DWORD iKID          = 0;

        DRM_PROFILING_ENTER_SCOPE(L"Processing Records", NULL, FALSE);

        /* get each <KID> value from the request and try to open it in the metering store */
        if ( dstrRecords.cchString == 0 )
        {
            /* no records, this is not an error */
            dr = DRM_SUCCESS;
            goto ErrorExit;        
        }

        cbBuffer = CB_DSTR(&dstrRecords);
        ChkDR(DRM_B64_DecodeW(&dstrRecords, &cbBuffer, NULL, DRM_BASE64_DECODE_IN_PLACE));

        if (! DRM_BBX_DecryptLicense(PB_DSTR(&dstrRecords), 
                                     cbBuffer,
                                     NULL,  /* in-place */
                                     f_pcontextLEVL->pcontextBBX) )
        {
            ChkDR(DRM_E_METERING_RESPONSE_DECRYPT_FAILED);        
        }

        /* re-use the metering response buffer;
        ** after b64decoding and decryption we have 5/8 of the area.to work with and it
        ** is guaranteed to hold the decoded KIDs, so we decode directly into it
        */

        ChkFAIL(! ISODD(cbBuffer));

#if SIXTEEN_BIT_ADDRESSING
        if ((cbBuffer % SIZEOF(DRM_BYTE)) != 0)
        {
            cbBuffer++;
        }

        ChkFAIL(! ISODD(cbBuffer));
#endif
        /* pbKIDs is guaranteed to be BYTE16 aligned because it's UNICODE */

        pbKIDs    = PB_DSTR(&dstrRecords);
        pbKIDs   += __CB_DECL(cbBuffer);
        pkids = (DRM_KID *) pbKIDs;

        dr = DRM_XML_GetNode(&dstrRecords, &g_dstrTagData, NULL, NULL, 0, NULL, &dstrDataInner);

        if (dr == DRM_E_XMLNOTFOUND)
        {
            dr = DRM_SUCCESS;
            dstrDataInner = dstrRecords;
        }
        ChkDR(dr);

        if (dstrDataInner.cchString == 0)
        {
            dr = DRM_SUCCESS;    /* no KID found */
            goto ErrorExit;
        }

        ChkDR(DRM_MTR_InitEnum(&mid, pmeterenum, f_pcontextLEVL->pcontextHDS));

        while (TRUE)
        {
            INIT_DRM_STRING(dstrTag);
            INIT_DRM_STRING(dstrDataKID);
            INIT_DRM_STRING(dstrAttrValue);

            if (dstrDataInner.pwszString == NULL 
            ||  dstrDataInner.cchString  == 0)
            {
                break;
            }
                 
            dr = DRM_XML_EnumNextNode(&dstrDataInner, &dstrTag, &dstrDataKID, NULL, NULL, NULL, &fIsLeaf);

            if (dr == DRM_E_NOMORE
            ||  dr == DRM_E_XMLNOTFOUND)
            {
                dr = DRM_SUCCESS;
                break;
            }

            ChkDR(dr);

            /* if this is a KID tag */

            if (wcsncmp(g_dstrTagKID.pwszString, dstrTag.pwszString, g_dstrTagKID.cchString) == 0)
            {
                /* get the value attribute */

                dr = DRM_XML_GetNodeAttribute(&dstrDataKID, &g_dstrLabelValue, &dstrAttrValue);

                if (DRM_SUCCEEDED(dr))
                {
                    cb     =  CB_DSTR(&dstrAttrValue);

                    /* base64 decode the kid value */

                    ChkDR(DRM_B64_DecodeW(&dstrAttrValue, 
                                          &cb, 
                             (DRM_BYTE *) (pkids + iKID++), 
                                           0));
                }
            } /* endif is <KID> */

            /* advance dstrDataInner past the current <KID> node */

            dstrDataInner.cchString -= (DRM_DWORD)(dstrDataKID.pwszString - dstrDataInner.pwszString) + dstrDataKID.cchString;
            dstrDataInner.pwszString = dstrDataKID.pwszString                                         + dstrDataKID.cchString;
        } /* endwhile more KIDs in the response */

        if (iKID > 0)
        {
            ChkDR(DRM_HDS_BlockScanDelete(&pmeterenum->oNsContext,
                                          &mid,
                                           pkids,
                                           iKID,
                                           TRUE, /* Wait for locks */
                                           pcontextBlockScan));
        }

        DRM_PROFILING_LEAVE_SCOPE(L"Processing Records", NULL);
    } /* end if <RECORDS> isn't empty */

    /* Now create a new TID and write it to the metering store */
                                  
    ChkDR(_CreateNewTID (&tid));
    
    ChkDR(_WriteTIDToMeteringStore(pmeterstore, 
                                   rgbPasswordSST, 
                                  &mid, 
                                  &tid, 
                                   f_pcontextLEVL->pcontextHDS));

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_MTR_ProcessMeterResponse", g_pwszLeavingFunction);

    SAFE_STK_FREE(&contextStack, pcontextBlockScan);
    SAFE_STK_FREE(&contextStack, pmeterenum);
    SAFE_STK_FREE(&contextStack, pmeterstore);

    return dr;
} /* DRM_MTR_ProcessMeterResponse */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmmetering.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMMETERING_H__
#define __DRMMETERING_H__


#ifdef __cplusplus
extern "C" {
#endif

#define DRM_METERING_CONTEXT        DRM_SECSTORE_CONTEXT
#define DRM_METERINGENUM_CONTEXT    DRM_SECSTOREENUM_CONTEXT

#define DRM_METER_RESPONSE_PARTIAL 0x00000001


DRM_RESULT DRM_API DRM_MTR_GenerateMeterChallenge(
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN       DRM_BYTE            *f_pbStack,
    IN       DRM_DWORD            f_cbStack,
    IN const DRM_CONST_STRING    *f_pdstrMeterCert,
       OUT   DRM_BYTE            *f_pbChallenge,
    IN OUT   DRM_DWORD           *f_pcbChallenge,
       OUT   DRM_WCHAR           *f_pwszURL,
    IN OUT   DRM_DWORD           *f_pcchURL);

DRM_RESULT DRM_API DRM_MTR_ProcessMeterResponse(
    IN     DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN     DRM_BYTE            *f_pbStack,
    IN     DRM_DWORD            f_cbStack,
    IN     DRM_BYTE            *f_pbData,
    IN     DRM_DWORD            f_cbData,
       OUT DRM_DWORD           *f_pfFlags);

DRM_RESULT DRM_API DRM_MTR_CloseContext( 
    IN DRM_METERING_CONTEXT *pcontextMetering,
    IN DRM_HDS_CONTEXT      *pcontextHDS);

DRM_RESULT DRM_API DRM_MTR_OpenId(
    IN       DRM_METERING_CONTEXT *pcontextMetering,
    IN const DRM_MID              *pmid,
    IN const DRM_KID              *pkid,
    IN const DRM_BYTE              rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_HDS_CONTEXT      *pcontextHDS );

DRM_RESULT DRM_API DRM_MTR_IncrementCount( 
    IN       DRM_METERING_CONTEXT *pcontextMetering, 
    IN const DRM_CONST_STRING     *pdstrAction );

DRM_RESULT DRM_API DRM_MTR_CreateMeterStorePassword(
    IN     DRM_CONST_STRING *f_pdstrMID,
       OUT DRM_BYTE          f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)],
    IN     DRM_BYTE         *f_pbcontextBBX);

DRM_RESULT DRM_API DRM_MTR_UpdateData(
    DRM_MID                 *f_pmid,
    DRM_LID                 *f_plid,
    DRM_KID                 *f_pkid,
    const DRM_CONST_STRING **f_ppdstrActions,
    DRM_DWORD                f_cActions,
    DRM_METERING_CONTEXT    *f_pcontextMTR,
    DRM_HDS_CONTEXT         *f_pcontextHDS,
    IN     DRM_BYTE         *f_pbcontextBBX);

DRM_RESULT DRM_API DRM_MTR_EnumLoadCurrent ( 
    IN       DRM_METERINGENUM_CONTEXT *f_pcontextMTREnum,
    IN       DRM_METERING_CONTEXT     *f_pcontextMTR,
    IN const DRM_BYTE                  f_rgbPasswordMTR[__CB_DECL(SHA_DIGEST_LEN)],
       OUT   DRM_KID                  *f_pkid,
       OUT   DRM_DWORD                *f_pcbData);

DRM_RESULT DRM_API DRM_MTR_EnumDeleteCurrent( 
    IN       DRM_METERINGENUM_CONTEXT *f_pcontextMTREnum,
    IN       DRM_METERING_CONTEXT     *f_pcontextMTR);
#ifdef __cplusplus
}
#endif

#endif /* __DRMMETERING_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmoutputlevels.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmxmlparser.h>
#include <drmutilities.h>
#include <drmoutputleveltypes.h>
#include <drmoutputlevels.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmtoken.h>

static const DRM_WORD g_wDefaultMinimumLevel = 100;

/*************************************************************************
**
** Private functions
**
**************************************************************************/

/*********************************************************************
**
**  Function:  _GetOPLLevel
**
**  Synopsis:  Returns the level of a specific category as defined in the XML 
**             restriction blob.  If the category doesn't exist the default level
**             is returned.
**
**  Arguments:  
**     [f_pdstrRestrictions] -- XML blob that contains the RESTRICTIONS tag.  
**                              If not provided the default will be returned
**     [f_pdstrCategory]     -- Category to extract the level from
**
*********************************************************************/
static DRM_WORD _GetOPLLevel( 
    IN const DRM_CONST_STRING *f_pdstrRestrictions,
    IN const DRM_CONST_STRING *f_pdstrCategory )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrCategoryNode = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrLevel        = EMPTY_DRM_STRING;
    DRM_WORD level = g_wDefaultMinimumLevel;
    DRM_LONG lval  = 0;

    ChkDRMString( f_pdstrCategory );

    if( f_pdstrRestrictions != NULL )
    {

        ChkDR( DRM_XML_GetNode( f_pdstrRestrictions,
                                f_pdstrCategory,
                                NULL,
                                NULL,
                                0,
                            &dstrCategoryNode,
                                NULL ) );

        /* Get the level from the node */

        ChkDR( DRM_XML_GetNodeAttribute(&dstrCategoryNode,
                                        &g_dstrLabelLevel,
                                        &dstrLevel ) );

        ChkDR( wcsntol( dstrLevel.pwszString, dstrLevel.cchString, &lval ) );
        if( lval > 0 && lval <= (DRM_WORD) MAX_UNSIGNED_TYPE( DRM_WORD ) )
        {
            level = (DRM_WORD)lval;
        }
    }

ErrorExit:
    return level;
}


/*********************************************************************
**
**  Function:  _ProcessExtensions
**
**  Synopsis:  Process all EXTENSION tags from an output level XML block
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pPlayOPL]          -- Play OPL struct that will be filled in 
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the extensions
**
**  Notes:     Data may be allocated from the stack context.  This data will be returned in the
**             f_pPlayOPL.vopi.rgVop pointer.
**
*********************************************************************/
static DRM_RESULT _ProcessExtensions( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_PLAY_OPL                 *f_pPlayOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrAnalogAudio   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrExtensionList = EMPTY_DRM_STRING;
    DRM_VIDEO_OUTPUT_PROTECTION *rgVop = NULL;
    DRM_WORD iExtension  = 0;
    DRM_WORD cExtensions = 0;

    dr = DRM_XML_GetNode( f_pdstrRestrictions,
                         &g_dstrTagAnalogVideo,
                          NULL,
                          NULL,
                          0,
                          NULL,
                         &dstrAnalogAudio );

    if( DRM_FAILED( dr ) )
    {
        /* There is no Analog Video OPL */
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }

    dr = DRM_XML_GetNode( &dstrAnalogAudio,
                          &g_dstrTagExtensionList,
                           NULL,
                           NULL,
                           0,
                           NULL,
                          &dstrExtensionList );

    if( DRM_FAILED( dr ) )
    {
        /* There is no Analog Video OPL */
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }

    /* Count the number of extensions that exist in the license */
    for( iExtension = 0; DRM_SUCCEEDED( dr ); iExtension++ )
    {
        DRM_CONST_STRING dstrExtension = EMPTY_DRM_STRING;

        dr = DRM_XML_GetNode( &dstrExtensionList, 
                              &g_dstrTagExtension,
                               NULL,
                               NULL,
                               iExtension,
                              &dstrExtension,
                               NULL );
    }

    dr = DRM_SUCCESS;
    iExtension--;
    if( iExtension == 0 )
    {
        goto ErrorExit;
    }

    cExtensions = iExtension;
    ChkDR( DRM_STK_Alloc( f_pstack, cExtensions * SIZEOF( DRM_VIDEO_OUTPUT_PROTECTION ), (DRM_VOID*)&rgVop ) );
    ZEROMEM(rgVop, cExtensions * SIZEOF( DRM_VIDEO_OUTPUT_PROTECTION ) );

    /* Populate the data structure with data from the license */
    for( iExtension = 0; iExtension < cExtensions; iExtension++ )
    {
        DRM_CONST_STRING dstrExtension = EMPTY_DRM_STRING;
        DRM_CONST_STRING dstrGuid      = EMPTY_DRM_STRING;
        DRM_CONST_STRING dstrData      = EMPTY_DRM_STRING;
        TOKEN token = { TOKEN_VARIABLE };

        ChkDR( DRM_XML_GetNode( &dstrExtensionList, 
                                &g_dstrTagExtension,
                                 NULL,
                                 NULL,
                                 iExtension,
                                &dstrExtension,
                                 NULL ) );

        ChkDR( DRM_XML_GetNodeAttribute( &dstrExtension, &g_dstrLabelGuid,  &dstrGuid ) );
        ChkDR( DRM_XML_GetNodeAttribute( &dstrExtension, &g_dstrLabelValue, &dstrData ) );
        ChkDR( DRM_UTL_StringToGuid( &dstrGuid, &rgVop[iExtension].guidId ) );
        ChkDR( ExtractLongToken( &dstrData, &token ) );
        
        /* The extension data is limited to 1 byte */
        ChkArg( token.val.lValue >= 0 && token.val.lValue <= MAX_UNSIGNED_TYPE( DRM_BYTE ) );
        rgVop[iExtension].bConfigData = (DRM_BYTE) token.val.lValue;
    }

    f_pPlayOPL->vopi.cEntries = cExtensions;
    f_pPlayOPL->vopi.rgVop    = rgVop;
    rgVop = NULL;

ErrorExit:
    SAFE_STK_FREE( f_pstack, rgVop );
    return dr;
}


/*********************************************************************
**
**  Function:  _ProcessIdList
**
**  Synopsis:  Finds ID tags in a generic way and populates an ID struct with the enumerated
**             guids.
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pdstrType]         -- XML tag to be searched for in RESTRICTIONS
**     [f_pdstrTypeList]     -- LIST XML tag to be searched for in RESTRICTIONs
**     [f_pOPLIds]           -- A OPL_OUTPUT_IDS structure that will be filled in.
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the Ids
**
*********************************************************************/
static DRM_RESULT _ProcessIdList( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN const DRM_CONST_STRING             *f_pdstrType,
    IN const DRM_CONST_STRING             *f_pdstrTypeList,
    IN OUT   DRM_OPL_OUTPUT_IDS           *f_pOPLIds,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrIdList = EMPTY_DRM_STRING;
    DRM_GUID *rgIds         = NULL;
    DRM_WORD  iId   = 0;
    DRM_WORD  cIds = 0;

    dr = DRM_XML_GetNode( f_pdstrRestrictions,
                          f_pdstrTypeList,
                          NULL,
                          NULL,
                          0,
                          NULL,
                         &dstrIdList );

    if( DRM_FAILED( dr ) )
    {
        /* There is no Analog Video OPL */
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }

    /* Count the number of extensions that exist in the license */
    for( iId = 0; DRM_SUCCEEDED( dr ); iId++ )
    {
        DRM_CONST_STRING dstrId = EMPTY_DRM_STRING;

        dr = DRM_XML_GetNode( &dstrIdList, 
                               f_pdstrType,
                               NULL,
                               NULL,
                               iId,
                              &dstrId,
                               NULL );
    }

    dr = DRM_SUCCESS;
    iId--;

    if( iId == 0 )
    {
        goto ErrorExit;
    }

    cIds = iId;
    ChkDR( DRM_STK_Alloc( f_pstack, cIds * SIZEOF( DRM_GUID ), (DRM_VOID*)&rgIds ) );
    ZEROMEM( rgIds, cIds * SIZEOF( DRM_GUID ) );

    /* Populate the data structure with data from the license */
    for( iId = 0; iId < cIds; iId++ )
    {
        DRM_CONST_STRING dstrId   = EMPTY_DRM_STRING;
        DRM_CONST_STRING dstrGuid = EMPTY_DRM_STRING;

        ChkDR( DRM_XML_GetNode( &dstrIdList, 
                                 f_pdstrType,
                                 NULL,
                                 NULL,
                                 iId,
                                &dstrId,
                                 NULL ) );

        ChkDR( DRM_XML_GetNodeAttribute( &dstrId, &g_dstrLabelGuid, &dstrGuid ) );
        ChkDR( DRM_UTL_StringToGuid( &dstrGuid, &(rgIds[iId]) ) );
    }

    f_pOPLIds->cIds  = cIds;
    f_pOPLIds->rgIds = rgIds;
    rgIds = NULL;

ErrorExit:
    SAFE_STK_FREE( f_pstack, rgIds );
    return dr;
}

/*********************************************************************
**
**  Function:  _ProcessExclusions
**
**  Synopsis:  Finds exlude tags in the restrictions XML
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pOPLIds]           -- Id struct that will be populated
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the Ids
**
*********************************************************************/
static DRM_RESULT _ProcessExclusions( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_OPL_OUTPUT_IDS           *f_pOPLIds,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    return _ProcessIdList( f_pdstrRestrictions,
                          &g_dstrTagExclude,
                          &g_dstrTagExcludeList,
                           f_pOPLIds, 
                           f_pstack );
}


/*********************************************************************
**
**  Function:  _ProcessInclusions
**
**  Synopsis:  Finds include tags in the restrictions XML
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pOPLIds]           -- Id struct that will be populated
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the Ids
**
*********************************************************************/
static DRM_RESULT _ProcessInclusions( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_OPL_OUTPUT_IDS           *f_pOPLIds,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    return _ProcessIdList( f_pdstrRestrictions,
                          &g_dstrTagInclude,
                          &g_dstrTagIncludeList,
                           f_pOPLIds, 
                           f_pstack );
}




/*************************************************************************
**
** Public functions
**
**************************************************************************/


/*********************************************************************
**
**  Function:  DRM_OPL_ProcessPlayOutputLevelData
**
**  Synopsis:  
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pPlayOPL]          -- Play OPL struct that will be populated with output level data
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the Ids
**
**  Notes:  Caller should provide a clean, unused stack context.  Caller shouldn't free data directly from stack
**          context.  Instead just throw entire stack context away when finished with the OPL structures.
**
*********************************************************************/
DRM_RESULT DRM_API DRM_OPL_ProcessPlayOutputLevelData( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_PLAY_OPL                 *f_pPlayOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    DRM_RESULT dr = DRM_SUCCESS;

    if( f_pdstrRestrictions != NULL )
    {
        ChkDRMString( f_pdstrRestrictions );
    }
    ChkArg( f_pPlayOPL        != NULL 
         && f_pstack          != NULL 
         && f_pstack->pbStack != NULL
         && f_pstack->cbStack  > 0 );
        
    ZEROMEM( f_pPlayOPL, SIZEOF( *f_pPlayOPL ) );

    f_pPlayOPL->minOPL.wCompressedDigitalVideo   = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagCompressedDigitalVideo   );
    f_pPlayOPL->minOPL.wUncompressedDigitalVideo = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagUncompressedDigitalVideo );
    f_pPlayOPL->minOPL.wAnalogVideo              = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagAnalogVideo              );
    f_pPlayOPL->minOPL.wCompressedDigitalAudio   = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagCompressedDigitalAudio   );
    f_pPlayOPL->minOPL.wUncompressedDigitalAudio = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagUncompressedDigitalAudio );

    if( f_pdstrRestrictions != NULL )
    {
        ChkDR( _ProcessExtensions( f_pdstrRestrictions, f_pPlayOPL, f_pstack ) );
    }
ErrorExit:
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_OPL_ProcessCopyOutputLevelData
**
**  Synopsis:  
**
**  Arguments:  
**     [f_pdstrRestrictions] -- String from XML blob that contains the entire RESTRICTIONS section
**     [f_pCopyOPL]          -- Copy OPL struct that will be populated with output level data
**     [f_pstack]            -- Stack allocator context that will be used to allocate room for the Ids
**
**  Notes:  Caller should provide a clean, unused stack context.  Caller shouldn't free data directly from stack
**          context.  Instead just throw entire stack context away when finished with the OPL structures.
**
*********************************************************************/

DRM_RESULT DRM_API DRM_OPL_ProcessCopyOutputLevelData( 
    IN const DRM_CONST_STRING             *f_pdstrRestrictions,
    IN OUT   DRM_COPY_OPL                 *f_pCopyOPL,
    IN       DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack )
{
    DRM_RESULT dr = DRM_SUCCESS;

    if( f_pdstrRestrictions != NULL )
    {
        ChkDRMString( f_pdstrRestrictions );
    }
    ChkArg( f_pCopyOPL        != NULL 
         && f_pstack          != NULL 
         && f_pstack->pbStack != NULL
         && f_pstack->cbStack  > 0 );
        
    ZEROMEM( f_pCopyOPL, SIZEOF( *f_pCopyOPL ) );

    f_pCopyOPL->wMinimumCopyLevel = _GetOPLLevel( f_pdstrRestrictions, &g_dstrTagCopy );

    if( f_pdstrRestrictions != NULL )
    {
        /* Process exclusions first because the inclusion processing will expect exlusions to have been done first */
        ChkDR( _ProcessExclusions( f_pdstrRestrictions, &(f_pCopyOPL->oplIdExcludes), f_pstack ) );
        ChkDR( _ProcessInclusions( f_pdstrRestrictions, &(f_pCopyOPL->oplIdIncludes), f_pstack ) );
    }

ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmpkg.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


/* BUGBUG:  We are not inputing time value correctly.  They should be changed to Zulu format in the input file and just read a string in. */

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmcrt.h>
#include <drmresults.h>
#include <stdio.h>
#include <oemimpl.h>
#include <drmxmlparser.h>
#include <drmkeygenerator.h>
#include <drmhdrbuilder.h>
#include <drmcipher.h>
#include <drmcmdlnpars.h>
#include <drmmanager.h>

#include <drmtoolsconstants.h>
#include <drmtoolsmacros.h>
#include <drmtoolsutils.h>

/* move this to drmutilities.h later on */
void DRM_API set_random_seed(const DRM_UINT64 new_seed);


#define CallHeaderBuilder(context, fn)   {\
    while (TRUE)\
    {\
        dr = (fn);\
        if ( dr == DRM_E_BUFFERTOOSMALL )\
        {\
            ChkDR(_ReallocHBContext(&(context)));\
            continue;\
        }\
        ChkDR(dr);\
        break;\
    }\
}

const DRM_DWORD _majorVersion=1;
const DRM_DWORD _minorVersion=0;

static DRM_RESULT
_ReallocHBContext(
    DRM_BYTE **ppbHBContext)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD cbContext=0;
    DRM_BYTE *pbNewContext=NULL;

    ChkDR(DRM_HB_GetContextSize(*ppbHBContext, &cbContext));  /* get current size */
    ChkMem(pbNewContext = (DRM_BYTE*)OEM_malloc(2 * cbContext));  /* alloc double of the current size */
    ChkDR(DRM_HB_ReallocHeader(*ppbHBContext,    2 * cbContext, pbNewContext));
    OEM_free(*ppbHBContext);
    *ppbHBContext = pbNewContext;

ErrorExit:
    return dr;
}


static OEM_FILEHDL _DoFopen(
    const DRM_CONST_STRING* f_pdstrFile, 
          DRM_DWORD f_dwAccessMode, 
          DRM_DWORD f_dwShareMode,
          DRM_DWORD f_dwCreationDisposition)
{
    DRM_WCHAR *pwszFile = NULL; 
    OEM_FILEHDL fp      = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD   cbFile  = CB_DSTR(f_pdstrFile) + SIZEOF (DRM_WCHAR);
    
    pwszFile = (DRM_WCHAR *) OEM_malloc(cbFile);
    
    if (pwszFile != NULL)
    {
        ZEROMEM(pwszFile, cbFile);
        MEMCPY(pwszFile, f_pdstrFile->pwszString, CB_DSTR(f_pdstrFile));

        fp = OEM_OpenFile(pwszFile, f_dwAccessMode, f_dwShareMode, f_dwCreationDisposition, OEM_ATTRIBUTE_NORMAL);
        OEM_free(pwszFile);        
    }
    return fp;
}

/**********************************************************************
** Function:    _DoBuildHeader
** Synopsis:    
** Arguments:   [pCrypto] --        pointer to caller initialized Crypto context
**              [argc] --           argument count from command line
**              [argv] --           argument vector from command line
**              [pstrHeader] --     built header - caller is response to free the memory
**              [pstrContentKey] -- content key - caller is response to free the memory
**              [pcbChunk] --   Encode chunk/block size specified in PkgInit.xml
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/  
static DRM_RESULT
_DoBuildHeader(
    IN DRM_CRYPTO_CONTEXT *pCrypto,
    IN const DRM_CONST_STRING *pdstrFileInit,
    IN const DRM_CONST_STRING *pdstrContentID,
    OUT DRM_STRING            *pstrHeader,
    OUT DRM_STRING            *pstrContentKey,
    OUT DRM_DWORD             *pcbChunk)
{
    DRM_RESULT       dr                 = DRM_SUCCESS;
    DRM_BYTE        *pbContext          = NULL,
                    *pbHeaderXML        = NULL;
    DRM_CONST_STRING dstrSigningKey     = EMPTY_DRM_STRING,
                     dstrURLLicAcq      = EMPTY_DRM_STRING,
                     dstrPkgInitContent = EMPTY_DRM_STRING,
                     dstrEncBlkSize     = EMPTY_DRM_STRING;
    DRM_DWORD        cbRead             = 0,
                     iChunk             = 0,
                     cbHeaderXML        = 0,
                     cbContext          = 0;
    DRM_STRING       strPkgInit         = EMPTY_DRM_STRING,
                     strKeySeed         = EMPTY_DRM_STRING,
                     strKeyID           = EMPTY_DRM_STRING;
    OEM_FILEHDL      fp                 = OEM_INVALID_HANDLE_VALUE;
    DRM_BOOL         bParseError        = FALSE;

    ChkArg(pCrypto && pcbChunk && pstrHeader && pstrContentKey);

    /* parse option values in PkgInit.xml */
    fp = _DoFopen (pdstrFileInit, 
                   OEM_GENERIC_READ, 
                   OEM_FILE_SHARE_READ, 
                   OEM_OPEN_EXISTING);
        
    if (fp == OEM_INVALID_HANDLE_VALUE)
    {
        TRACE (("Error: failed to open %S\n", pdstrFileInit->pwszString));
        ChkDR (DRM_E_FILENOTFOUND);
    }
    
    /* load file content in memory */
    if (!OEM_GetFileSize (fp, &strPkgInit.cchString))
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    
    ChkMem (strPkgInit.pwszString = (DRM_WCHAR *) OEM_malloc (strPkgInit.cchString));
        
    if (OEM_ReadFile (fp, 
                        strPkgInit.pwszString, 
                        strPkgInit.cchString, 
                        &cbRead) == FALSE
    ||  cbRead != strPkgInit.cchString)
    {
        TRACE(("Error: failed to read PkgInit.xml\n"));
        ChkDR(DRM_E_FILEREADERROR);
    }

    /* use DrmXmlParser to parse it */
    strPkgInit.cchString /= SIZEOF(DRM_WCHAR);

    bParseError = TRUE;

    ChkDR (DRM_XML_GetNode ((DRM_CONST_STRING*)  &strPkgInit, &g_dstrTagRoot,      NULL, NULL, 0, NULL,                      &dstrPkgInitContent));
    ChkDR (DRM_XML_GetNode (&dstrPkgInitContent,              &g_dstrTagKeySeed,   NULL, NULL, 0, NULL, (DRM_CONST_STRING *) &strKeySeed));
    ChkDR (DRM_XML_GetNode (&dstrPkgInitContent,              &g_dstrSigningKey,   NULL, NULL, 0, NULL,                      &dstrSigningKey));
    ChkDR (DRM_XML_GetNode (&dstrPkgInitContent,              &g_dstrTagURLLicAcq, NULL, NULL, 0, NULL,                      &dstrURLLicAcq));
    ChkDR (DRM_XML_GetNode (&dstrPkgInitContent,              &g_dstrEncBlkSize,   NULL, NULL, 0, NULL,                      &dstrEncBlkSize));
                        
    bParseError = FALSE;

    /* get encrypt block size */
    ChkDR( wcsntol( dstrEncBlkSize.pwszString, dstrEncBlkSize.cchString, (DRM_LONG*)pcbChunk ) );
    
    /* generate KeyID */
    dr = DRM_KG_GenerateKeyID(NULL, &strKeyID.cchString);
    if ( dr != DRM_E_BUFFERTOOSMALL )
    {
        ChkDR(dr);
    }
    ChkMem(strKeyID.pwszString = (DRM_WCHAR*)OEM_malloc(strKeyID.cchString * SIZEOF(DRM_WCHAR)));
    ChkDR(DRM_KG_GenerateKeyID(strKeyID.pwszString, &strKeyID.cchString));
    strKeyID.cchString--; /* Drop off the NULL terminator */

    /* use DrmHdrBuilder to build the header */
    dr = DRM_HB_CreateHeader(NULL, &cbContext);
    if ( dr != DRM_E_BUFFERTOOSMALL )
        ChkDR(dr);
    
    ChkMem(pbContext=(DRM_BYTE*)OEM_malloc(cbContext));
    ChkDR(DRM_HB_CreateHeader(pbContext, &cbContext));
    CallHeaderBuilder(pbContext, DRM_HB_SetKeyID(pbContext, (DRM_CONST_STRING*)&strKeyID));
    CallHeaderBuilder(pbContext, DRM_HB_SetLicAcqUrl(pbContext, &dstrURLLicAcq));

    /* optional attributes */
    if ( pdstrContentID )
    {
        CallHeaderBuilder(pbContext, DRM_HB_SetAttribute(pbContext, &g_dstrCID, pdstrContentID));
    }

    /* generate the content key */
    dr = DRM_KG_GenerateContentKey(strKeySeed.pwszString, strKeySeed.cchString, 
        strKeyID.pwszString, strKeyID.cchString, NULL, &pstrContentKey->cchString);
    ChkMem(pstrContentKey->pwszString = 
        (DRM_WCHAR*)OEM_malloc(CB_DSTR(pstrContentKey)));
    ChkDR(DRM_KG_GenerateContentKey(strKeySeed.pwszString, strKeySeed.cchString, 
        strKeyID.pwszString, strKeyID.cchString, pstrContentKey->pwszString, 
        &pstrContentKey->cchString));
    pstrContentKey->cchString--; /* Drop off the NULL terminator */
    
    CallHeaderBuilder(pbContext, DRM_HB_SetChecksum(pbContext, 
        (DRM_CONST_STRING*)pstrContentKey));
    CallHeaderBuilder(pbContext, DRM_HB_SignHeader(pbContext, pCrypto, &dstrSigningKey, 
        &pbHeaderXML, &cbHeaderXML));

    /* allocate buffer for return */
    ChkMem(pstrHeader->pwszString = (DRM_WCHAR*)OEM_malloc(cbHeaderXML));
    MEMCPY(pstrHeader->pwszString, pbHeaderXML, cbHeaderXML);
    pstrHeader->cchString = cbHeaderXML / SIZEOF(DRM_WCHAR);
    
ErrorExit:

    if (bParseError)
    {
        TRACE (("Error: Failed in parsing package init XML\n"));        
    }

    if (pbContext != NULL)
    {
        OEM_free (pbContext);
    }
    
    if (strKeyID.pwszString != NULL)
    {
        OEM_free (strKeyID.pwszString);
    }
    
    if (strPkgInit.pwszString != NULL)
    {
        OEM_free (strPkgInit.pwszString);
    }
    
    if (fp != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile (fp);
    }

    return dr;
}




/**********************************************************************
** Function:    _DoPackage
** Synopsis:    
** Arguments:   [pCrypto] --         pointer to caller initialized Crypto context
**              [pdstrPathInput]  -- input pathname
**              [pdstrPathOutput] -- output pathname
**              [pstrHeader]      -- built header - caller is response to free the memory
**              [pstrContentKey]  -- content key - caller is response to free the memory
**              [cbChunk]         -- Encode chunk/block size specified in PkgInit.xml
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _DoPackage(
    DRM_CRYPTO_CONTEXT  *pCrypto,
    IN DRM_CONST_STRING *pdstrPathInput,
    IN DRM_CONST_STRING *pdstrPathOutput,
    IN DRM_STRING       *pstrHeader,
    IN DRM_STRING       *pstrContentKey,
    IN DRM_DWORD         cbChunk)
{
    DRM_RESULT  dr           = DRM_SUCCESS;
    OEM_FILEHDL fpOut        = OEM_INVALID_HANDLE_VALUE, 
                fpIn         = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD   cbRead       = 0, 
                cbWritten    = 0,
                cbContentKey = 0,
                cbXML        = 0;
    DRM_BYTE   *pbFileData   = NULL;
    DRM_BYTE   *pbContentKey = NULL;

    DRM_MANAGER_ENCRYPT_CONTEXT contextEncrypt = { 0x00 };

    ChkArg       (pCrypto && pdstrPathInput && pdstrPathOutput && cbChunk);
    ChkDRMString (pstrHeader);
    ChkDRMString (pstrContentKey);
        
    /*
    ** open the input content file for reading
    */
    fpIn = _DoFopen(pdstrPathInput, 
                    OEM_GENERIC_READ, 
                    OEM_FILE_SHARE_READ, 
                    OEM_OPEN_EXISTING);
    if (fpIn == OEM_INVALID_HANDLE_VALUE)
    {
        TRACE (("Unable to open input content file (%S) for writing\n", pdstrPathInput->pwszString));
        ChkDR(DRM_E_FILENOTFOUND);
    }

    /*
    ** open the output content file for writing
    */
    fpOut = _DoFopen (pdstrPathOutput, 
                      OEM_GENERIC_READ    | OEM_GENERIC_WRITE, 
                      OEM_FILE_SHARE_READ | OEM_FILE_SHARE_WRITE, 
                      OEM_CREATE_ALWAYS);
    if (fpOut == OEM_INVALID_HANDLE_VALUE)
    {
        TRACE(("Unable to open output content file (%S) for writing\n", pdstrPathOutput->pwszString));
        ChkDR(DRM_E_FILEWRITEERROR);
    }

    /* write generic header information to file: the chunk size */
    FIX_ENDIAN_DWORD( cbChunk );
    if (OEM_WriteFile (fpOut, 
                      &cbChunk, 
               SIZEOF (cbChunk), 
                      &cbWritten) == FALSE
    ||  cbWritten != SIZEOF (cbChunk))
    {
        TRACE(("Error writing DRM header to output file\n"));
        ChkDR(DRM_E_FILEWRITEERROR);
    }
    FIX_ENDIAN_DWORD( cbChunk );

    cbXML = CB_DSTR( pstrHeader );
        
    /* the XML size in bytes */
    FIX_ENDIAN_DWORD( cbXML );
    if (OEM_WriteFile (fpOut, 
                      &cbXML, 
               SIZEOF (cbXML), 
                      &cbWritten) == FALSE
    ||  cbWritten != SIZEOF (cbXML))
    {
        TRACE(("Error writing DRM header to output file\n"));
        ChkDR(DRM_E_FILEWRITEERROR);
    }
    FIX_ENDIAN_DWORD( cbXML );
    /* write WMRM header information to file */
    
    if (OEM_WriteFile (fpOut, 
                       PB_DSTR( pstrHeader ), 
                       CB_DSTR( pstrHeader ), 
                      &cbWritten) == FALSE
    ||  CB_DSTR( pstrHeader ) != cbWritten)
    {
        TRACE(("Error writing DRM header to output file\n"));
        ChkDR(DRM_E_FILEWRITEERROR);
    }

    /* base64 decode the content key */
    ChkMem(pbFileData = (DRM_BYTE*)OEM_malloc(cbChunk));
    dr = DRM_B64_DecodeW((DRM_CONST_STRING *) pstrContentKey, 
                        &cbContentKey, 
                         pbContentKey, 
                         0);
    if ( dr != DRM_E_BUFFERTOOSMALL )
    {
        ChkDR(dr);
    }
    ChkMem(pbContentKey = (DRM_BYTE*)OEM_malloc(cbContentKey));
    ChkDR(DRM_B64_DecodeW((DRM_CONST_STRING *)pstrContentKey, 
                         &cbContentKey, 
                         pbContentKey, 
                         0));

    /*
    ** write content to file, encrypting in cbChunk byte chunks
    */
    
    DRMASSERT (cbContentKey >= DRMCIPHERKEYLEN);

#if DRM_SUPPORT_ENCRYPTION
    ChkDR(DRM_MGR_CreateEncryptContext(pbContentKey, &contextEncrypt));
#else
    ChkDR(DRM_CPHR_Init((DRM_CIPHER_CONTEXT*)&contextEncrypt, DRMCIPHERKEYLEN, pbContentKey));
#endif

    while (TRUE) 
    {
        if (!OEM_ReadFile(fpIn, pbFileData, cbChunk, &cbRead))
        {
            ChkDR(DRM_E_FILEREADERROR);
        }
        if ( 0 == cbRead )
            break ;

        /* encrypt input data using the pbContentKey*/
#if DRM_SUPPORT_ENCRYPTION
        ChkDR (DRM_MGR_Encrypt(&contextEncrypt, pbFileData, cbRead));
#else
        ChkDR (DRM_CPHR_Encrypt((DRM_CIPHER_CONTEXT*)&contextEncrypt, cbRead, pbFileData));
#endif

        /* write encyrpted data to output file */
        if (!OEM_WriteFile(fpOut, pbFileData, cbRead, &cbWritten) || cbWritten != cbRead )
        {
            TRACE(("Error writing file data.\n"));
            ChkDR(DRM_E_FILEWRITEERROR);
        }
    }

ErrorExit:
    if (pbContentKey != NULL)
    {
        OEM_free (pbContentKey);
    }
    
    if (pbFileData != NULL)
    {
        OEM_free (pbFileData);
    }
    
    if (fpIn != OEM_INVALID_HANDLE_VALUE) 
    {
        OEM_CloseFile (fpIn);
    }
    
    if (fpOut != OEM_INVALID_HANDLE_VALUE) 
    {
        OEM_CloseFile (fpOut) ;
    }
    
    if ( DRM_FAILED(dr) )
    {
        printf("Package failed 0x%X\n", dr );
    }

    return dr;
}


/*
** 
*/
static void
_DoSyntax()
{
    printf("usage: package [-?] -d:PackageParams.xml [-i:ContentID] -c:ContentFile -p:Output.pkg\n");
}

/*
**
*/
static DRM_RESULT
Dispatch(
    DRM_INT argc, 
    DRM_WCHAR *argv[])
{
    DRM_WCHAR        wchOption        = 0;
    DRM_INT          i                = 0;
    DRM_CONST_STRING dstrInitFile     = EMPTY_DRM_STRING,
                     dstrParam        = EMPTY_DRM_STRING,
                     dstrContentID    = EMPTY_DRM_STRING,
                     dstrContentFile  = EMPTY_DRM_STRING,
                     dstrPackagedFile = EMPTY_DRM_STRING;
    DRM_STRING       strHeader        = EMPTY_DRM_STRING;
    DRM_STRING       strContentKey    = EMPTY_DRM_STRING;
    DRM_RESULT       dr               = DRM_SUCCESS;
    DRM_DWORD        cbChunk      = 0;
    DRM_CRYPTO_CONTEXT *pCrypto       = NULL;

    for (i = 1; i < argc; i++)
    {
        DRM_WCHAR wchOption = 0;
        if( !DRM_CMD_ParseCmdLine(argv[i], &wchOption, &dstrParam, NULL) )
        {
            goto ShowMenu;
        }
        
        wchOption = towlower( wchOption );
        switch( wchOption )
        {
        case WCHAR_CAST('d'):
            dstrInitFile = dstrParam;
            break;
        case WCHAR_CAST('i'):
            dstrContentID = dstrParam;
            break;
        case WCHAR_CAST('c'):
            dstrContentFile = dstrParam;
            break;
        case WCHAR_CAST('p'):
            dstrPackagedFile = dstrParam;
            break;
        case WCHAR_CAST('?'):
        default:
            goto ShowMenu;
        }
    }

    if( dstrInitFile    .cchString == 0
     || dstrContentFile .cchString == 0
     || dstrPackagedFile.cchString == 0 )
    {
        printf("\n\tmissing argument(s).\n\n");
        goto ShowMenu;
    }

    ChkMem( pCrypto = (DRM_CRYPTO_CONTEXT *)OEM_malloc(SIZEOF(DRM_CRYPTO_CONTEXT)) );

    ZEROMEM(pCrypto, SIZEOF(DRM_CRYPTO_CONTEXT));   

    ChkDR (_DoBuildHeader (pCrypto, 
                          &dstrInitFile, 
                          (dstrContentID.cchString!=0 ? &dstrContentID : NULL), 
                          &strHeader, 
                          &strContentKey, 
                          &cbChunk));
    
    ChkDR(_DoPackage(pCrypto, &dstrContentFile, &dstrPackagedFile, &strHeader, &strContentKey, cbChunk));
    goto ErrorExit;

ShowMenu:
    _DoSyntax();

ErrorExit:
    if (pCrypto != NULL)
    {
        OEM_free (pCrypto);
    }
    
    if (strHeader.pwszString != NULL)
    {
        OEM_free (strHeader.pwszString);
    }
    
    if (strContentKey.pwszString != NULL)
    {
        OEM_free (strContentKey.pwszString);
    }
    
    if (DRM_FAILED (dr))
    {
        printf ("\n\tFailed to generate packaged file.\n\tError: 0x%08X\n", dr);
    }
    
    return dr;
}

/*
**
*/
DRM_VOID DRM_API wmain(
    DRM_INT    argc, 
    DRM_WCHAR *argv[])
{
    DRMFILETIME FileTime;
    DRM_UINT64  u64;
    printf("Microsoft (R) Content Packager version %d.%d\n", _majorVersion, _minorVersion);
    printf("Copyright (C) Microsoft Corporation. All rights reserved.\n\n");

    OEM_GetDeviceTime (&FileTime);
    FILETIME_TO_UI64( FileTime, u64 );
    set_random_seed( u64 );
    
    Dispatch(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmpkcrypto.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMPKCRYPTO_H__
#define __DRMPKCRYPTO_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "drmstkalloc.h"

/* The following sizes are in BYTEs */
#define PK_ENC_PUBLIC_KEY_LEN	40
#define PK_ENC_PRIVATE_KEY_LEN	20
#define PK_ENC_PLAINTEXT_LEN	16
#define PK_ENC_CIPHERTEXT_LEN	80
#define PK_ENC_SIGNATURE_LEN	40
#define PK_ENC_SIGNATURE_B64LEN	56


#define PKSYMM_KEY_LEN_DRMV2	7
#define PKSYMM_ALG_TYPE_RC4		1

#ifdef DRM_SUPPORT_OPT_CRYPTO
#define DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE 5500 
#define DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE  (DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE + SIZEOF( DRM_STACK_ALLOCATOR_CONTEXT )) 
#else 
#define DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE 19600 
#define DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE  (DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE + SIZEOF(DRM_STACK_ALLOCATOR_CONTEXT))
#endif

typedef struct __tagPUBKEY
{
    DRM_BYTE y[ __CB_DECL(PK_ENC_PUBLIC_KEY_LEN) ];
} PUBKEY;

typedef struct __tagPRIVKEY
{
    DRM_BYTE x[ __CB_DECL(PK_ENC_PRIVATE_KEY_LEN) ];
} PRIVKEY;

typedef struct {
	PUBKEY pk;
	DRM_BYTE version[__CB_DECL(VERSION_LEN)];  
} PK;

typedef struct {
	PK pk;  /* pk.version indicates the pubkey needed to verify. */
	DRM_BYTE sign[__CB_DECL(PK_ENC_SIGNATURE_LEN)];
} PKCERT;


/* */
/*  A set of old keys. */
/* */
typedef struct __tagDRMKEYPAIR
{
    PRIVKEY PrivKey;     /*  an old private key */
    PUBKEY  PubKey;      /*  an old public key */
} DRMKEYPAIR;


/*********************************************************************
**
**  Function:  DRM_PK_GenKeyPair
**
**  Synopsis:  Generate a matched public and private key pair
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]  -- New public key
**     [f_pprivkey] -- New private key
**
*********************************************************************/
DRM_RESULT DRM_API DRM_PK_GenKeyPair( 
    IN     DRM_VOID *f_pContext,
       OUT PUBKEY   *f_ppubkey,
       OUT PRIVKEY  *f_pprivkey );

/*********************************************************************
**
**  Function:  DRM_PK_Encrypt
**
**  Synopsis:  Encrypt a block of data with a given public key.
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]  -- Public key to encrypt with
**     [f_rgbIn]    -- Data to be encrypted
**     [f_rgbOut]   -- Buffer to hold the encrypted data value.
**
**  Notes:  Data is not encrpyted in place.  It is put in the rgbOut buffer.
*********************************************************************/
DRM_RESULT DRM_API DRM_PK_Encrypt( 
    IN        DRM_VOID *f_pContext, 
    IN  const PUBKEY   *f_ppubkey,
    IN  const DRM_BYTE  f_rgbIn [__CB_DECL(PK_ENC_PLAINTEXT_LEN) ],
        OUT   DRM_BYTE  f_rgbOut[__CB_DECL(PK_ENC_CIPHERTEXT_LEN)] );


/*********************************************************************
**
**  Function:  DRM_PK_Decrypt
**
**  Synopsis:  
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_pprivkey] -- Private key to decrypt with
**     [f_rgbIn]    -- Encrypted bytes that are to be decrypted
**     [f_rgbOut]   -- Clear text result
**
**  Notes:  Data is not decrpyted in place.  It is put in the rgbOut buffer.
**
*********************************************************************/
DRM_RESULT DRM_API DRM_PK_Decrypt(
    IN        DRM_VOID *f_pContext,
    IN  const PRIVKEY  *f_pprivkey,
    IN  const DRM_BYTE  f_rgbIn [__CB_DECL(PK_ENC_CIPHERTEXT_LEN)],
        OUT   DRM_BYTE  f_rgbOut[__CB_DECL(PK_ENC_PLAINTEXT_LEN) ] );


/*********************************************************************
**
**  Function:  DRM_PK_Sign
**
**  Synopsis:  Generate a digital signature with a private key
**
**  Arguments:  
**     [f_pContext]     -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_privkey]      -- Private key to create a signature with
**     [f_pbData]       -- Array of bytes to create a signature over
**     [f_cbData]       -- Length of pbBuffer in bytes
**     [f_rgbSignature] -- Buffer to hold result signature
*********************************************************************/
DRM_RESULT DRM_API DRM_PK_Sign(
    IN       DRM_VOID  *f_pContext,
    IN const PRIVKEY   *f_privkey,
    IN const DRM_BYTE  *f_pbData,
    IN       DRM_DWORD  f_cbData,
       OUT   DRM_BYTE   f_rgbSignature[__CB_DECL(PK_ENC_SIGNATURE_LEN)] );

/*********************************************************************
**
**  Function:  DRM_PK_Verify
**
**  Synopsis:  Verify a digital signature created by DRM_PK_Sign.
**
**  Arguments:  
**     [f_pContext]     -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]      -- Pubkey to check the signature with
**     [f_pbData]       -- Data buffer that the signature was created over
**     [f_cbData]       -- Length of pbBuffer in bytes
**     [f_rgbSignature] -- The signature to verify
**
**  Returns:  TRUE if the signature verified correctly.  FALSE is it didn't
**
*********************************************************************/
DRM_BOOL DRM_API DRM_PK_Verify( 
    IN       DRM_VOID  *f_pContext,
    IN const PUBKEY    *f_ppubkey, 
    IN const DRM_BYTE  *f_pbData, 
    IN       DRM_DWORD  f_cbData, 
    IN const DRM_BYTE   f_rgbSignature[__CB_DECL(PK_ENC_SIGNATURE_LEN)] );

#define DRM_PK_MAX_SECRET_ARRAYS 5
#define DRM_PK_SECRET_FUNC_COUNT 7

typedef DRM_RESULT (*pfnSetSecretFunction)();
typedef pfnSetSecretFunction pfnSetSecretArray[DRM_PK_SECRET_FUNC_COUNT];
typedef pfnSetSecretArray   *ppfnSetSecretArray;

typedef struct __PK_SET_SECRET_FUNCS
{
    ppfnSetSecretArray secretArray[DRM_PK_MAX_SECRET_ARRAYS];
} PK_SET_SECRET_FUNCS;

extern PK_SET_SECRET_FUNCS g_SetSecretFuncs;


#ifdef __cplusplus
}
#endif /*__cplusplus */

#endif /* __DRMPKCRYPTO_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmprivkeydeviceexclusion.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_PRIVKEY_DEVICE_REVOCATION__
#define __DRM_PRIVKEY_DEVICE_REVOCATION__

#ifdef __cplusplus
extern "C" {
#endif

PRIVKEY g_privkeyDeviceRevocation = 
{
    TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0), 
    TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0), TWO_BYTES(0, 0)
};

#ifdef __cplusplus
}
#endif

#endif  /* __DRM_PRIVKEY_DEVICE_REVOCATION__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmpubkeydeviceexclusion.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_PUBKEY_DEVICE_REVOCATION__
#define __DRM_PUBKEY_DEVICE_REVOCATION__

#ifdef __cplusplus
extern "C" {
#endif

PUBKEY g_pubkeyDeviceRevocation = 
{
    TWO_BYTES(0x15, 0x66), TWO_BYTES(0x90, 0x16), TWO_BYTES(0x30, 0x8C), TWO_BYTES(0x5C, 0xED), TWO_BYTES(0xE9, 0x9F), 
    TWO_BYTES(0xF2, 0xC9), TWO_BYTES(0xC5, 0x39), TWO_BYTES(0x28, 0x00), TWO_BYTES(0x73, 0xD5), TWO_BYTES(0xE6, 0x2D), 
    TWO_BYTES(0xCB, 0x44), TWO_BYTES(0xA4, 0xE3), TWO_BYTES(0xFE, 0xA9), TWO_BYTES(0xAC, 0x2B), TWO_BYTES(0xB4, 0x0E), 
    TWO_BYTES(0x16, 0x6B), TWO_BYTES(0xFE, 0xA0), TWO_BYTES(0xF9, 0x95), TWO_BYTES(0x3D, 0x0A), TWO_BYTES(0x7A, 0x11)
};

PUBKEY g_pubkeyCardeaRevocation = 
{
    TWO_BYTES(0x17, 0xab), TWO_BYTES(0x8d, 0x43), TWO_BYTES(0xe6, 0x47), TWO_BYTES(0xef, 0xba), TWO_BYTES(0xbd, 0x23), 
    TWO_BYTES(0x44, 0x66), TWO_BYTES(0x9f, 0x64), TWO_BYTES(0x04, 0x84), TWO_BYTES(0xf8, 0xe7), TWO_BYTES(0x71, 0x39), 
    TWO_BYTES(0xc7, 0x07), TWO_BYTES(0x36, 0x25), TWO_BYTES(0x5d, 0xa6), TWO_BYTES(0x5f, 0xba), TWO_BYTES(0xb9, 0x00), 
    TWO_BYTES(0xef, 0x9c), TWO_BYTES(0x89, 0x6b), TWO_BYTES(0xf2, 0xc4), TWO_BYTES(0x81, 0x1d), TWO_BYTES(0xa2, 0x12)
};

#ifdef __cplusplus
}
#endif

#endif  /* __DRM_PUBKEY_DEVICE_REVOCATION__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmprofile.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMPROFILE_H__
#define __DRMPROFILE_H__

#include <drmcommon.h>
#include <drmresults.h>
#include <drmtypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#define DRM_PROFILE_USETICKCOUNT 0

/* The following defines allow individual profiling calls to be enabled or disabled */
#define DRM_PROFILE_DRIVESEEK 0
#define DRM_PROFILE_HDSGETPUT 0


#define DRM_PROFILE_BUFFER_SIZE 1024
typedef struct
{
    OEM_FILEHDL   hfile;
    DRM_BOOL      fRunning;
    DRM_DWORD     dwDepth;
    DRM_DWORD     dwNumSeeks;
    DRM_CHAR      rgchBuffer [__CB_DECL(DRM_PROFILE_BUFFER_SIZE)];
} DRM_PROFILE_CONTEXT;

typedef struct
{
#if DRM_PROFILE_USETICKCOUNT
    DRM_DWORD       dwTickCount;
#else
    DRMSYSTEMTIME   enterTime;
#endif
    DRM_DWORD       dwNumSeeks;

} DRM_SCOPE_CONTEXT;

extern DRM_PROFILE_CONTEXT g_contextPRO;

#if DRM_SUPPORT_PROFILING

DRM_RESULT DRM_API DRM_PRO_StartProfiling(void);

DRM_RESULT DRM_API DRM_PRO_StopProfiling(void);

#define DRM_PROFILING_START_IF_NOT_STARTED TRUE
#define DRM_PROFILING_DONT_START           FALSE

DRM_RESULT DRM_API DRM_PRO_EnterScope(
    IN DRM_SCOPE_CONTEXT *f_pScopeCtx,
    IN const DRM_WCHAR  *const f_pwszScope,
    IN const DRM_WCHAR  *const f_pwszComment,
    IN DRM_BOOL       f_fRunIfNot);

DRM_RESULT DRM_API DRM_PRO_LeaveScope(
    IN DRM_SCOPE_CONTEXT *f_pScopeCtx,
    IN const DRM_WCHAR  *const f_pwszScope,
    IN const DRM_WCHAR  *const f_pwszComment);

#define DRM_PROFILING_ENTER_SCOPE(s,c,r) \
    DRM_SCOPE_CONTEXT xqrK224; \
    DRM_PRO_EnterScope(&xqrK224,(const DRM_WCHAR *const)(s),(const DRM_WCHAR *const)(c),(r)); 

#define DRM_PROFILING_LEAVE_SCOPE(s,c) \
    DRM_PRO_LeaveScope(&xqrK224,(const DRM_WCHAR *const)(s),(const DRM_WCHAR *const)(c)); 

extern const DRM_WCHAR *const g_pwszEnteringFunction;
extern const DRM_WCHAR *const g_pwszLeavingFunction;

#else
#define DRM_PRO_StartProfiling()   
#define DRM_PRO_StopProfiling()
#define DRM_PRO_EnterScope(a,x,c,b)
#define DRM_PRO_LeaveScope(a,b,c)
#define DRM_PROFILING_ENTER_SCOPE(a,s,c) 
#define DRM_PROFILING_LEAVE_SCOPE(a,c) 
#endif

#ifdef __cplusplus
}
#endif

#endif      /* __XMLBUILDER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmprofile.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmbase64.h>
#include <drmcrt.h>
#include <drmutilities.h>
#include <drmprofile.h>

#if DRM_SUPPORT_PROFILING

DRM_PROFILE_CONTEXT g_contextPRO = { 0, 0, 0, 0, { 0 } };

const DRM_WCHAR *const g_pwszEnteringFunction = (const DRM_WCHAR *const)L"Entering Function";
const DRM_WCHAR *const g_pwszLeavingFunction  = (const DRM_WCHAR *const)L"Leaving Function";


#if !DRM_PROFILE_USETICKCOUNT
/* calculate the interval of time between  */

static void _CalculateInterval(DRMSYSTEMTIME *f_psystemtimeEnter,
                               DRMSYSTEMTIME *f_psystemtimeExit)
{
    DRM_WORD wHour         = 0;
    DRM_WORD wMinute       = 0;
    DRM_WORD wSecond       = 0;
    DRM_WORD wMilliseconds = 0;

    if (f_psystemtimeExit->wHour > f_psystemtimeEnter->wHour)
    {
        wMinute = 60 * (f_psystemtimeExit->wHour - f_psystemtimeEnter->wHour);
    }

    if (f_psystemtimeExit->wMinute > f_psystemtimeEnter->wMinute)
    {
        wMinute += (f_psystemtimeExit->wMinute - f_psystemtimeEnter->wMinute);
    }
    else
    {
        wMinute -= (f_psystemtimeEnter->wMinute - f_psystemtimeExit->wMinute);
    }

    if (f_psystemtimeExit->wSecond >= f_psystemtimeEnter->wSecond)
    {
        wSecond = (f_psystemtimeExit->wSecond - f_psystemtimeEnter->wSecond);
    }
    else
    {
        wMinute--;
        wSecond = ((f_psystemtimeExit->wSecond + 60) - f_psystemtimeEnter->wSecond);
    }

    if (f_psystemtimeExit->wMilliseconds >= f_psystemtimeEnter->wMilliseconds)
    {
        wMilliseconds = (f_psystemtimeExit->wMilliseconds - f_psystemtimeEnter->wMilliseconds);
    }
    else
    {
        wSecond--;
        wSecond = ((f_psystemtimeExit->wMilliseconds + 1000) - f_psystemtimeEnter->wMilliseconds);
    }

    ZEROMEM(f_psystemtimeExit, SIZEOF(DRMSYSTEMTIME));

    f_psystemtimeExit->wMinute       = wMinute;
    f_psystemtimeExit->wSecond       = wSecond;
    f_psystemtimeExit->wMilliseconds = wMilliseconds;
}
#endif

/*Entering: \t\t\t\tHH:MM:SS:mmm ScopeName [comment]*/
/*Exiting:  \t\t\t\tHH:MM:SS:mmm ScopeName MM:SS:mmm [comment]*/

static void _WriteProfileEntry(DRM_SCOPE_CONTEXT*f_pScopeCtx,
                         const DRM_WCHAR  *const f_pwszScope,
                         const DRM_WCHAR  *const f_pwszComment,
                               DRM_BOOL          f_fEntering)
{
    DRM_DWORD   ich         = 0;
    DRM_DWORD   iDepth      = 0;
    DRM_DWORD   dwSeeks     = 0;
    DRM_DWORD   i;
    DRM_DWORD   cch           = DRMCRT_wcslen(f_pwszScope);
#if !DRM_PROFILE_USETICKCOUNT
    DRM_WORD    wMilliseconds = f_pScopeCtx->enterTime.wMilliseconds;
#endif
    const DRM_CHAR chIndent      = (f_fEntering ? '>' : '<');
    DRMSYSTEMTIME *psystemtime   = NULL;
    DRMSYSTEMTIME  systemtimeExit;
#if DRM_PROFILE_USETICKCOUNT
    DRM_DWORD dwTotalTime;
#endif

    if (f_fEntering)
    {
#if !DRM_PROFILE_USETICKCOUNT
        OEM_GetDeviceDateTime(&systemtimeExit);
        psystemtime = &systemtimeExit;
#else
        psystemtime = &(f_pScopeCtx->enterTime);
#endif
        f_pScopeCtx->dwNumSeeks = g_contextPRO.dwNumSeeks;
    }
    else
    {
        OEM_GetDeviceDateTime(&systemtimeExit);
        psystemtime = &systemtimeExit;
        dwSeeks = g_contextPRO.dwNumSeeks - f_pScopeCtx->dwNumSeeks;

#if DRM_PROFILE_USETICKCOUNT
        dwTotalTime = OEM_GetTickCount() - f_pScopeCtx->dwTickCount;
#endif
    }

    if ( ( g_contextPRO.dwDepth * 2 ) + 14 >= DRM_PROFILE_BUFFER_SIZE )
    {
        return;
    }
    /* indent two chevrons per depth of call stack */

    for (iDepth = 0; iDepth < g_contextPRO.dwDepth; iDepth++)
    {
        PUT_CHAR(g_contextPRO.rgchBuffer, ich++, chIndent);
        PUT_CHAR(g_contextPRO.rgchBuffer, ich++, chIndent);
    }

    PUT_CHAR(g_contextPRO.rgchBuffer, ich++, ',');

    /* format the time */

    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  (psystemtime->wHour   / 10) + '0');
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  (psystemtime->wHour   % 10) + '0');
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  ':');
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  (psystemtime->wMinute / 10) + '0');
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  (psystemtime->wMinute % 10) + '0');
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  ':');
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  (psystemtime->wSecond / 10) + '0');
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  (psystemtime->wSecond % 10) + '0');

#if !DRM_PROFILE_USETICKCOUNT
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  ':');
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  (wMilliseconds / 100) + '0');
    wMilliseconds /= 100;
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  (wMilliseconds / 10) + '0');
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  (wMilliseconds % 10) + '0');
#endif
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++,  ',');

    /* if the scope name is too long for the buffer then write as much as we can
       we don't want to do multiple file writes because that will skew the timing*/

    if ( ( ich + cch + 2 ) >= DRM_PROFILE_BUFFER_SIZE )
    {
        cch = ich;
        
        for ( ; ich < DRM_PROFILE_BUFFER_SIZE; ich++)
        {
            PUT_CHAR(g_contextPRO.rgchBuffer, ich, (DRM_CHAR)f_pwszScope[ich - cch]);
        }

    }
    else
    {
        cch = ich;
        for ( ; f_pwszScope[ich - cch] != 0; ich++)
        {
            PUT_CHAR(g_contextPRO.rgchBuffer, ich, (DRM_CHAR)f_pwszScope[ich - cch]);
        }
    	
        /* if we are exiting the scope then write the duration spent in it */

        if (! f_fEntering)
        {
            /*  ...but only if we have room */

            if ((ich + (10 + 7)) < DRM_PROFILE_BUFFER_SIZE)
            {
                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, ',');

                
#if DRM_PROFILE_USETICKCOUNT
                for(i = 10000000;i > 0;i /= 10)
                {
                    PUT_CHAR(g_contextPRO.rgchBuffer, ich++, (char)((dwTotalTime / i) % 10) + '0');
                }
#else
                _CalculateInterval(&(f_pScopeCtx->enterTime), 
                                  &systemtimeExit);

                wMilliseconds = systemtimeExit.wMilliseconds;
                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, (systemtimeExit.wMinute / 10) + '0');
                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, (systemtimeExit.wMinute % 10) + '0');
                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, ':');
                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, (systemtimeExit.wSecond / 10) + '0');
                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, (systemtimeExit.wSecond % 10) + '0');


                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, ':');
                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, (wMilliseconds / 100) + '0');
                wMilliseconds /= 100;
                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, (wMilliseconds / 10) + '0');
                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, (wMilliseconds % 10) + '0');
#endif

                PUT_CHAR(g_contextPRO.rgchBuffer, ich++, ',');
                for(i = 100000;i > 0;i /= 10)
                {
                    PUT_CHAR(g_contextPRO.rgchBuffer, ich++, (char)((dwSeeks / i) % 10) + '0');
                }                
            }
        }
        else
        {
            PUT_CHAR(g_contextPRO.rgchBuffer, ich++, ',');
        }

        /* append the optional comment without overflowing the buffer */

        if (f_pwszComment != NULL)
        {
            PUT_CHAR(g_contextPRO.rgchBuffer, ich++, ',');
            
            cch = ich;
            for ( ; (f_pwszComment[ich - cch] != 0) 
                && (ich + 2) < DRM_PROFILE_BUFFER_SIZE; ich++)
            {
                PUT_CHAR(g_contextPRO.rgchBuffer, ich, (DRM_CHAR)f_pwszComment[ich - cch]);
            }
        }
    }

    /* end with a newline */

    PUT_CHAR(g_contextPRO.rgchBuffer, ich++, '\x0d');
    PUT_CHAR(g_contextPRO.rgchBuffer, ich++, '\x0a');

    OEM_WriteFile(g_contextPRO.hfile, g_contextPRO.rgchBuffer, ich, &cch);
}

DRM_RESULT DRM_API DRM_PRO_StartProfiling(void)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_WCHAR  rgwchPath [DRM_MAX_PATH];
    DRM_DWORD  cch = NO_OF(rgwchPath);
    DRM_SCOPE_CONTEXT xqrK224;
    
    g_contextPRO.dwDepth = 0;

    ChkDR(OEM_GetProfileLogPath(rgwchPath, &cch));

    g_contextPRO.hfile = OEM_OpenFile(rgwchPath, 
                                      OEM_GENERIC_WRITE, 
                                      OEM_FILE_SHARE_NONE, 
                                      OEM_OPEN_ALWAYS, 
                                      OEM_ATTRIBUTE_NORMAL);

    ChkBOOL(g_contextPRO.hfile != OEM_INVALID_HANDLE_VALUE, DRM_E_FILEOPEN);

    if (!OEM_SetFilePointer(g_contextPRO.hfile, 0, OEM_FILE_END, NULL))
    {
        ChkDR(DRM_E_FILESEEKERROR);
    }

    g_contextPRO.fRunning = TRUE;

    DRM_PRO_EnterScope(&xqrK224, (const DRM_WCHAR *const)L"--------- LOG SESSION BEGINS ---------", (const DRM_WCHAR *const)L"", DRM_PROFILING_DONT_START);
ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_PRO_StopProfiling(void)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SCOPE_CONTEXT xqrK224;
    
#if DRM_PROFILE_USETICKCOUNT
    xqrK224.dwTickCount = OEM_GetTickCount();
#else
    OEM_GetDeviceDateTime(&(xqrK224.enterTime));
#endif
    xqrK224.dwNumSeeks = g_contextPRO.dwNumSeeks;
    DRM_PRO_LeaveScope(&xqrK224, (const DRM_WCHAR *const)L"--------- LOG SESSION ENDS ---------", (const DRM_WCHAR *const)L"");

    if (g_contextPRO.hfile != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile(g_contextPRO.hfile);

        g_contextPRO.hfile    = OEM_INVALID_HANDLE_VALUE;
    }

    g_contextPRO.fRunning = FALSE;

    return dr;
}

DRM_RESULT DRM_API DRM_PRO_EnterScope(
    IN DRM_SCOPE_CONTEXT *f_pScopeCtx,
    IN const DRM_WCHAR  *const f_pwszScope,
    IN const DRM_WCHAR  *const f_pwszComment,
    IN DRM_BOOL                f_fStartIfNot)
{
    DRM_RESULT dr      = DRM_SUCCESS;

    ChkArg(f_pwszScope != NULL);

    if (f_fStartIfNot
    &&  ! g_contextPRO.fRunning)
    {
        ChkDR(DRM_PRO_StartProfiling());
    }

#if DRM_PROFILE_USETICKCOUNT
    f_pScopeCtx->dwTickCount = OEM_GetTickCount();
#else
    OEM_GetDeviceDateTime(&(f_pScopeCtx->enterTime));
#endif
    f_pScopeCtx->dwNumSeeks = g_contextPRO.dwNumSeeks;

    g_contextPRO.dwDepth++;

    if (g_contextPRO.fRunning)
    {
        _WriteProfileEntry(f_pScopeCtx,
                           f_pwszScope,
                           f_pwszComment,
                           TRUE);
    }

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_PRO_LeaveScope(
    IN DRM_SCOPE_CONTEXT *f_pScopeCtx,
    IN const DRM_WCHAR  *const f_pwszScope,
    IN const DRM_WCHAR  *const f_pwszComment)
{
    DRM_RESULT     dr = DRM_SUCCESS;

    if (g_contextPRO.fRunning)
    {
        _WriteProfileEntry(f_pScopeCtx,
                           f_pwszScope,
                           f_pwszComment,
                           FALSE);
    }

    g_contextPRO.dwDepth--;

    return dr;
}

#endif /* #if DRM_SUPPORT_PROFILING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmpubkeyrevocation.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_PUBKEY_REVOCATION__
#define __DRM_PUBKEY_REVOCATION__

#ifdef __cplusplus
extern "C" {
#endif

PUBKEY g_pubkeyRevocation = 
{
    TWO_BYTES(0x02, 0x14), TWO_BYTES(0xEF, 0x99), TWO_BYTES(0xD4, 0x80), TWO_BYTES(0x0C, 0x96), 
    TWO_BYTES(0x5E, 0xB4), TWO_BYTES(0x57, 0x5C), TWO_BYTES(0xE7, 0x16), TWO_BYTES(0x67, 0x60), 
    TWO_BYTES(0x40, 0x4E), TWO_BYTES(0x6D, 0x23), TWO_BYTES(0x30, 0x42), TWO_BYTES(0xBB, 0xBA), 
    TWO_BYTES(0x68, 0x35), TWO_BYTES(0x42, 0x30), TWO_BYTES(0xA1, 0xB6), TWO_BYTES(0x10, 0x95), 
    TWO_BYTES(0x4C, 0x40), TWO_BYTES(0xF9, 0xAA), TWO_BYTES(0x10, 0x85), TWO_BYTES(0xE5, 0x70)
};

#ifdef __cplusplus
}
#endif

#endif  /* __DRM_PUBKEY_REVOCATION__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmrc4.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_RC4_H__
#define __DRM_RC4_H__

#include <drmcommon.h>

#if DRM_USE_RSA_IMPL
#include <rc4.h>

#define DRM_RC4_KeySetup(ks,cb,pb) rc4_key((ks),(cb),(pb))
#define DRM_RC4_Cipher(ks,cb,pb) rc4((ks),(cb),(pb))


#else /* DRM_USE_RSA_IMPL */


#ifdef __cplusplus
extern "C" {
#endif

#define RC4_TABLESIZE 256

/* Key structure */
typedef struct __tagRC4_KEYSTRUCT
{
	DRM_BYTE S[__CB_DECL(RC4_TABLESIZE)];     /* State table */
	DRM_BYTE i, j;        /* Indices */
} RC4_KEYSTRUCT;

/*********************************************************************
**
**  Function:  DRM_RC4_KeySetup
**
**  Synopsis:  Generate the key control structure.  Key can be any size.
**
**  Arguments:  
**     [pKS] -- A KEYSTRUCT structure that will be initialized.
**     [cbKey] -- Size of the key, in bytes.
**     [pbKey] -- Pointer to the key.
**
**  Returns:  None
**
*********************************************************************/

DRM_VOID DRM_API DRM_RC4_KeySetup(
    OUT       RC4_KEYSTRUCT  *pKS,
    IN        DRM_DWORD       cbKey,
    IN  const DRM_BYTE       *pbKey );

/*********************************************************************
**
**  Function:  DRM_RC4_Cipher
**
**  Synopsis:  
**
**  Arguments:  
**     [pKS] -- Pointer to the KEYSTRUCT created using DRM_RC4_KeySetup.
**     [cbBuffer] -- Size of buffer, in bytes.
**     [pbBuffer] -- Buffer to be encrypted in place.
**
**  Returns:  None
*********************************************************************/

DRM_VOID DRM_API DRM_RC4_Cipher(
    IN OUT RC4_KEYSTRUCT *pKS,
    IN     DRM_UINT       cbBuffer,
    IN OUT DRM_BYTE      *pbBuffer );

#ifdef __cplusplus
}
#endif

#endif /* DRM_USE_RSA_IMPL */

#endif /* __DRM_RC4_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmresults.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMRESULTS_H__
#define __DRMRESULTS_H__

#ifdef __cplusplus
extern "C" {
#endif



/* These are DRM_RESULTS.  DRM_RESULTS is intended to mirror the use of HRESULTS */

#if SIXTEEN_BIT_ADDRESSING
#define DRM_FAILED(Status) (((DRM_RESULT)(Status)&0x80000000)!=0)
#define DRM_SUCCEEDED(Status) (((DRM_RESULT)(Status)&0x80000000)==0)
#else
#define DRM_FAILED(Status) ((DRM_RESULT)(Status)<0)
#define DRM_SUCCEEDED(Status) ((DRM_RESULT)(Status) >= 0)
#endif

/*Success return code */

/*
*	MessageId:	
*	Message Meaning:	
*	Hex Value:	
*/

/* Generic success return value */
#define DRM_SUCCESS ((DRM_RESULT)0x00000000L)
#define DRM_S_FALSE  ((DRM_RESULT)0x00000001L)


/* Fail return codes */
/* Standard return codes copied from winerror.h */
#define DRM_E_FAIL				((DRM_RESULT)0x80004005L)
#define DRM_E_INVALIDARG		((DRM_RESULT)0x80070057L)
#define DRM_E_OUTOFMEMORY		((DRM_RESULT)0x80000002L)
#define DRM_E_FILENOTFOUND		((DRM_RESULT)0x80030002L)
#define DRM_E_FILEOPEN          ((DRM_RESULT)0x8003006EL)    
#define DRM_E_BUFFERTOOSMALL	((DRM_RESULT)0x8007007AL)
#define DRM_E_NOTIMPL			((DRM_RESULT)0x80004001L)
#define DRM_E_NOMORE			((DRM_RESULT)0x80070103L) /* End of enum, or no more data available */
#define DRM_E_ARITHMETIC_OVERFLOW        DRM_RESULT_FROM_WIN32( 534L )

#define DRM_E_PARAMETERS_MISMATCHED     ((DRM_RESULT)0xC00D272FL)
#define DRM_E_FAILED_TO_STORE_LICENSE   ((DRM_RESULT)0xC00D2712L)
#define DRM_E_NOT_ALL_STORED            ((DRM_RESULT)0xC00D275FL)


#define DRM_SEVERITY_SUCCESS				0uL
#define DRM_SEVERITY_ERROR					1uL
#define DRM_FACILITY_ITF                    4uL
#define DRM_FACILITY_WIN32                  7uL
#define DRM_S_BASECODE		                0xC000
#define DRM_E_BASECODE						0xC000

#define MAKE_DRM_RESULT(sev,fac,code) \
    ((DRM_RESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )


#define DRM_RESULT_FROM_WIN32(x) ((DRM_RESULT)(x) <= 0 ? ((DRM_RESULT)(x)) : ((DRM_RESULT) (((x) & 0x0000FFFF) | (DRM_FACILITY_WIN32 << 16) | 0x80000000)))
/* DRM specific error codes */


/*
*	MessageId:	DRM_E_DEVICENOTINIT
*	Message Meaning:
*		This device has not been initialized against a DRM init service
*	Hex Value:	0x8004c001
*/

#define DRM_E_DEVICENOTINIT				MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+1)

/*
*	MessageId:	DRM_E_DRMNOTINIT
*	Message Meaning:	
*		The app has not call DRM_Init properly
*	Hex Value:	0x8004c002
*/

#define DRM_E_DRMNOTINIT					MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+2)


/* Errors related to problems with a license */

/*
*	MessageId:	DRM_E_INVALIDRIGHT
*	Message Meaning:	
*		A right in the license in invalid
*	Hex Value:	0x8004c003
*/

#define DRM_E_INVALIDRIGHT					MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+3)

/*
*	MessageId:	DRM_E_INCOMPATABLELICENSESIZE
*	Message Meaning:	
*		The size of the license is incompatable.  DRM doesn't understand this license
*	Hex Value:	0x8004c004
*/

#define DRM_E_INCOMPATABLELICENSESIZE	MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+4)

/*
*	MessageId:	DRM_E_INVALIDLICENSEFLAGS
*	Message Meaning:	
*		The flags in the license are invalid.  DRM either doesn't understand them or they are conflicting
*	Hex Value:	0x8004c005
*/


#define DRM_E_INVALIDLICENSEFLAGS			MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+5)

/*
*	MessageId:	DRM_E_INVALIDLICENSE
*	Message Meaning:	
*		 The license is invalid
*	Hex Value:	0x8004c006
*/

#define DRM_E_INVALIDLICENSE				MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+6)

/*
*	MessageId:	DRM_E_CONDITIONFAIL 
*	Message Meaning:	
*		A condition in the license failed to pass
*	Hex Value:	0x8004c007
*/

#define DRM_E_CONDITIONFAIL				MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+7)

/*
*	MessageId:	DRM_E_CONDITIONNOTSUPPORTED 
*	Message Meaning:	
*		A condition in the license is not supported by this verison of DRM
*	Hex Value:	0x8004c008
*/

#define DRM_E_CONDITIONNOTSUPPORTED		MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+8)

/*
*	MessageId:	DRM_E_LICENSEEXPIRED 
*	Message Meaning:	
*		The license has expired either by depleting a play count or via an end time.
*	Hex Value:	0x8004c009
*/

#define DRM_E_LICENSEEXPIRED				MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+9)

/*
*	MessageId:	DRM_E_LICENSENOTYETVALID 
*	Message Meaning:	
*		The license start time had not come to pass yet.
*	Hex Value:	0x8004c00a
*/

#define DRM_E_LICENSENOTYETVALID			MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+10)

/*
*	MessageId:	DRM_E_RIGHTSNOTAVAILABLE 
*	Message Meaning:	
*		The rights the app has requested are not available in the license
*	Hex Value:	0x8004c00b
*/

#define DRM_E_RIGHTSNOTAVAILABLE			MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+11)

/*
*	MessageId:	DRM_E_LICENSEMISMATCH 
*	Message Meaning:	
*		The license content id/ sku id doesn't match that requested by the app
*	Hex Value:	0x8004c00c
*/

#define DRM_E_LICENSEMISMATCH				MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+12)

/*
*	MessageId:	DRM_E_WRONGTOKENTYPE
*	Message Meaning:	
*		The token parameter was of an incompatible type.
*	Hex Value:	0x8004c00d
*/

#define DRM_E_WRONGTOKENTYPE	            MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+13)

/* Other errors */

/*
*	MessageId:	DRM_E_NORIGHTSREQUESTED 
*	Message Meaning:	
*		The app has not requested any rights before trying to bind
*	Hex Value:	0x8004c00e
*/

#define DRM_E_NORIGHTSREQUESTED			    MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+14)

/*
*	MessageId:	DRM_E_LICENSENOTBOUND 
*	Message Meaning:	
*		A license has not been bound to.  Decrypt can not happen without a successful bind call
*	Hex Value:	0x8004c00f
*/

#define DRM_E_LICENSENOTBOUND				MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+15)

/*
*	MessageId:	DRM_E_HASHMISMATCH 
*	Message Meaning:	
*		A Keyed Hash check failed.
*	Hex Value:	0x8004c010
*/

#define DRM_E_HASHMISMATCH				MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+16)

/*
*	MessageId:	DRM_E_INVALIDTIME
*	Message Meaning:	
*		A time structure is invalid 
*	Hex Value:	0x8004c011
*/

#define DRM_E_INVALIDTIME					MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+17)

/*
*	MessageId:	DRM_E_LICENSESTORENOTFOUND
*	Message Meaning:	
*		The external license store was not found
*	Hex Value:	0x8004c012
*/

#define DRM_E_LICENSESTORENOTFOUND		MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+18)

/*
*	MessageId:	DRM_E_LICENSENOTFOUND
*	Message Meaning:	
*		A license was not found in the external license store
*	Hex Value:	0x8004c013
*/

#define DRM_E_LICENSENOTFOUND				MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+19)

/*
*	MessageId:	DRM_E_LICENSEVERSIONNOTSUPPORTED
*	Message Meaning:	
*		The DRM license version is not supported by the DRM version on the device.
*	Hex Value:	0x8004c014
*/

#define DRM_E_LICENSEVERSIONNOTSUPPORTED	MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+20)

/*
*	MessageId:	DRM_E_INVALIDBINDID
*	Message Meaning:	
*		The bind id is invalid.
*	Hex Value:	0x8004c015
*/

#define DRM_E_INVALIDBINDID				MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+21)

/*
*	MessageId:	DRM_E_UNSUPPORTEDALGORITHM
*	Message Meaning:	
*		The encryption algorithm required for this operation is not supported.
*	Hex Value:	0x8004c016
*/

#define DRM_E_UNSUPPORTEDALGORITHM		MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+22)

/*
*	MessageId:	DRM_E_ALGORITHMNOTSET
*	Message Meaning:	
*		The encryption algorithm required for this operation is not supported.
*	Hex Value:	0x8004c017
*/

#define DRM_E_ALGORITHMNOTSET		MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+23)

/*
*	MessageId:	DRM_E_LICENSESERVERNEEDSKEY
*	Message Meaning:	
*		The license server needs a version of the device bind key from the init service.
*	Hex Value:	0x8004c018
*/

#define DRM_E_LICENSESERVERNEEDSKEY		MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+24)

/*
*	MessageId:	DRM_E_INVALIDLICENSESTORE
*	Message Meaning:	
*		The license store version number is incorrect, or the store is invalid in some other way.
*	Hex Value:	0x8004c019
*/

#define DRM_E_INVALIDLICENSESTORE   MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+25)

/*
*	MessageId:	DRM_E_FILEREADERROR
*	Message Meaning:	
*		There was an error reading a file.
*	Hex Value:	0x8004c01a
*/

#define DRM_E_FILEREADERROR         MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+26)

/*
*	MessageId:	DRM_E_FILEWRITEERROR
*	Message Meaning:	
*		There was an error writing a file.
*	Hex Value:	0x8004c01b
*/

#define DRM_E_FILEWRITEERROR        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+27)


/*
*	MessageId:	DRM_E_CLIENTTIMEINVALID
*	Message Meaning:	
*		The time/clock on the device is not in sync with the license server within tolerance.
*	Hex Value:	0x8004c01c
*/

#define DRM_E_CLIENTTIMEINVALID     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+28)

/*
*	MessageId:	DRM_E_HDSSTOREFULL
*	Message Meaning:	
*		HDS Data file is FULL.
*	Hex Value:	0x8004c01d
*/

#define DRM_E_HDSSTOREFULL     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+29)

/*
*	MessageId:	DRM_E_NOXMLOPENTAG
*	Message Meaning:	
*		XML open tag not found
*	Hex Value:	0x8004c01e
*/
#define DRM_E_NOXMLOPENTAG          MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+30)


/*
*	MessageId:	DRM_E_NOXMLCLOSETAG
*	Message Meaning:	
*		XML close tag not found
*	Hex Value:	0x8004c01f
*/
#define DRM_E_NOXMLCLOSETAG        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+31)

/*
*	MessageId:	DRM_E_INVALIDXMLTAG
*	Message Meaning:	
*		Invalid XML tag
*	Hex Value:	0x8004c020
*/
#define DRM_E_INVALIDXMLTAG			MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+32)

/*
*	MessageId:	DRM_E_NOXMLCDATA
*	Message Meaning:	
*		No XML CDATA found
*	Hex Value:	0x8004c021
*/
#define DRM_E_NOXMLCDATA			MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+33)

/*
*	MessageId:	DRM_E_HDSNAMESPACEFULL
*	Message Meaning:	
*		No more room for HDS Namespace
*	Hex Value:	0x8004c022
*/
#define DRM_E_HDSNAMESPACEFULL      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+34)

/*
*	MessageId:	DRM_E_HDSNAMESPACENOTFOUND
*	Message Meaning:	
*		No HDS Namespace found
*	Hex Value:	0x8004c023
*/
#define DRM_E_HDSNAMESPACENOTFOUND      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+35)

/*
*	MessageId:	DRM_E_HDSSLOTNOTFOUND
*	Message Meaning:	
*		No HDS HDS Dataslot not found
*	Hex Value:	0x8004c024
*/
#define DRM_E_HDSSLOTNOTFOUND      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+36)

/*
*	MessageId:	DRM_E_HDSSLOTEXIST
*	Message Meaning:	
*		No HDS HDS Dataslot already exist
*	Hex Value:	0x8004c025
*/
#define DRM_E_HDSSLOTEXIST      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+37)

/*
*	MessageId:	DRM_E_HDSFILECORRUPTED
*	Message Meaning:	
*		HDS File is corrupted
*	Hex Value:	0x8004c026
*/
#define DRM_E_HDSFILECORRUPTED      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+38)

/*
*	MessageId:	DRM_E_HDSSEEKERROR
*	Message Meaning:	
*		There was an error attempting to seek in the HDS file
*	Hex Value:	0x8004c027
*/
#define DRM_E_HDSSEEKERROR      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+39)

/*
*	MessageId:	DRM_E_HDSNAMESPACEINUSE
*	Message Meaning:	
*		No HDS Namespace in use
*	Hex Value:	0x8004c028
*/
#define DRM_E_HDSNAMESPACEINUSE      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+40)


/* Errors related to the secure store */

/*
*	MessageId:	DRM_E_INVALID_SECURESTORE_PASSWORD
*	Message Meaning:	
*		The password used to open the secure store key was not able to validate the secure store hash.
*	Hex Value:	0x8004c029
*/

#define DRM_E_INVALID_SECURESTORE_PASSWORD MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+41)

/*
*	MessageId:	DRM_E_SECURESTORE_CORRUPT
*	Message Meaning:	
*		The secure store is corrupt
*	Hex Value:	0x8004c02a
*/

#define DRM_E_SECURESTORE_CORRUPT MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+42)

/*
*	MessageId:	DRM_E_SECURESTORE_FULL
*	Message Meaning:	
*		The current secure store key is full.  No more data can be added.
*	Hex Value:	0x8004c02b
*/

#define DRM_E_SECURESTORE_FULL MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+43)


/*
*	MessageId:	DRM_E_NOACTIONINLICENSEREQUEST
*	Message Meaning:	
*		No action(s) added for license request
*	Hex Value:	0x8004c02c
*/
#define DRM_E_NOACTIONINLICENSEREQUEST     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+44)


/*
*	MessageId:	DRM_E_DUPLICATEDHEADERATTRIBUTE
*	Message Meaning:	
*		Duplicated attribute in Header
*	Hex Value:	0x8004c02d
*/
#define DRM_E_DUPLICATEDHEADERATTRIBUTE     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+45)

/*
*	MessageId:	DRM_E_NOKIDINHEADER
*	Message Meaning:	
*		No KID attribute in Header
*	Hex Value:	0x8004c02e
*/
#define DRM_E_NOKIDINHEADER     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+46)

/*
*	MessageId:	DRM_E_NOLAINFOINHEADER
*	Message Meaning:	
*		No LAINFO attribute in Header
*	Hex Value:	0x8004c02f
*/
#define DRM_E_NOLAINFOINHEADER     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+47)

/*
*	MessageId:	DRM_E_NOCHECKSUMINHEADER
*	Message Meaning:	
*		No Checksum attribute in Header
*	Hex Value:	0x8004c030
*/
#define DRM_E_NOCHECKSUMINHEADER     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+48)

/*
*	MessageId:	DRM_E_HDSBLOCKMISMATCH
*	Message Meaning:	
*		No Checksum attribute in Header
*	Hex Value:	0x8004c031
*/
#define DRM_E_HDSBLOCKMISMATCH     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+49)

/*
*   MessageId:  DRM_E_BACKUP_EXISTS
*   Message Meaning:    
*       Backup file already exist.
*   Hex Value:  0x8004c032
*/
#define DRM_E_BACKUP_EXISTS     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+50)

/*
*   MessageId:  DRM_E_LICENSE_TOOLONG
*   Message Meaning:    
*       License size is too long 
*   Hex Value:  0x8004c032
*/
#define DRM_E_LICENSE_TOOLONG     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+51)

/*
*	MessageId:	DRM_E_HDSFILEEXISTS
*	Message Meaning:	
*		HDS File already exists
*	Hex Value:	0x8004c034
*/
#define DRM_E_HDSFILEEXISTS      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+52)

/*
*	MessageId:	DRM_E_INVALIDDEVICECERTIFICATE
*	Message Meaning:	
*		The device certificate is invalid.
*	Hex Value:	0x8004c035
*/
#define DRM_E_INVALIDDEVICECERTIFICATE      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+53)

/*
*	MessageId:	DRM_E_HDSLOCKFAILED
*	Message Meaning:	
*		Locking a segement of the HDS file failed.
*	Hex Value:	0x8004c036
*/
#define DRM_E_HDSLOCKFAILED      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+54)

/*
*	MessageId:	DRM_E_FILESEEKERROR
*	Message Meaning:	
*		File Seek Error
*	Hex Value:	0x8004c037
*/
#define DRM_E_FILESEEKERROR      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+55)

/*
*	MessageId:	DRM_E_HDSNOTLOCKEDEXCLUSIVE
*	Message Meaning:	
*		existing lock is not exclusive
*	Hex Value:	0x8004c038
*/
#define DRM_E_HDSNOTLOCKEDEXCLUSIVE      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+56)

/*
*	MessageId:	DRM_E_HDSEXCLUSIVELOCKONLY
*	Message Meaning:	
*		only exclusive lock is accepted
*	Hex Value:	0x8004c039
*/
#define DRM_E_HDSEXCLUSIVELOCKONLY      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+57)


/*
*   MessageId:  DRM_E_HDSRESERVEDKEYDETECTED
*   Message Meaning:    
*       HDS reserved key value detected in UniqueKey
*   Hex Value:  0x8004c03A
*/
#define DRM_E_HDSRESERVEDKEYDETECTED      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+58)


/*
*   MessageId:  DRM_E_V1_NOT_SUPPORTED
*   Message Meaning:    
*       V1 Lic Acquisition is not supported
*   Hex Value:  0x8004c03B
*/
#define DRM_E_V1_NOT_SUPPORTED           MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+59)


/*
*   MessageId:  DRM_E_HEADER_NOT_SET
*   Message Meaning:    
*       A V2 content header is not set 
*   Hex Value:  0x8004c03C
*/
#define DRM_E_HEADER_NOT_SET           MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+60)

/*
*	MessageId:	DRM_E_NEEDDEVCERTINDIV
*	Message Meaning:	
*		The device certificate is template. It need Devcert Indiv
*	Hex Value:	0x8004c03d
*/

#define DRM_E_NEEDDEVCERTINDIV       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+61)

/*
*	MessageId:	DRM_E_MACHINEIDMISMATCH
*	Message Meaning:	
*		The device has Machine Id different from that in devcert.
*	Hex Value:	0x8004c03e
*/

#define DRM_E_MACHINEIDMISMATCH       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+62)

/*
*	MessageId:	DRM_E_CLK_INVALID_RESPONSE
*	Message Meaning:	
*		The secure clock response is invalid.
*	Hex Value:	0x8004c03f
*/

#define DRM_E_CLK_INVALID_RESPONSE       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+63)
/*
*	MessageId:	DRM_E_CLK_INVALID_DATE
*	Message Meaning:	
*		The secure clock response is invalid.
*	Hex Value:	0x8004c040
*/

#define DRM_E_CLK_INVALID_DATE       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+64)


/*
*	MessageId:	DRM_E_CLK_UNSUPPORTED_VALUE
*	Message Meaning:	
*		The secure clock response has unsupported value.
*	Hex Value:	0x8004c041
*/

#define DRM_E_CLK_UNSUPPORTED_VALUE       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+65)

/*
*	MessageId:	DRM_E_INVALIDDEVICECERTIFICATETEMPLATE
*	Message Meaning:	
*		The device certificate is invalid.
*	Hex Value:	0x8004c042
*/
#define DRM_E_INVALIDDEVICECERTIFICATETEMPLATE      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+66)

/*
*	MessageId:	DRM_E_DEVCERTEXCEEDSSIZELIMIT
*	Message Meaning:	
*		The device certificate exceeds max size
*	Hex Value:	0x8004c043
*/

#define DRM_E_DEVCERTEXCEEDSIZELIMIT       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+67)

/*
*	MessageId:	DRM_E_DEVCERTTEMPLATEEXCEEDSSIZELIMIT
*	Message Meaning:	
*		The device certificate template exceeds max size
*	Hex Value:	0x8004c044
*/

#define DRM_E_DEVCERTTEMPLATEEXCEEDSSIZELIMIT       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+68)

/*
*	MessageId:	DRM_E_DEVCERTREADERROR
*	Message Meaning:	
*		Can't get the device certificate
*	Hex Value:	0x8004c045
*/

#define DRM_E_DEVCERTREADERROR        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+69)
/*
*	MessageId:	DRM_E_DEVCERTWRITEERROR
*	Message Meaning:	
*		Can't store the device certificate
*	Hex Value:	0x8004c046
*/

#define DRM_E_DEVCERTWRITEERROR        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+70)

/*
*	MessageId:	DRM_E_PRIVKEYREADERROR
*	Message Meaning:	
*		Can't get device private key
*	Hex Value:	0x8004c047
*/

#define DRM_E_PRIVKEYREADERROR        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+71)

/*
*	MessageId:	DRM_E_PRIVKEYWRITEERROR
*	Message Meaning:	
*		Can't store device private key
*	Hex Value:	0x8004c048
*/

#define DRM_E_PRIVKEYWRITEERROR        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+72)

/*
*	MessageId:	DRM_E_DEVCERTTEMPLATEREADERROR
*	Message Meaning:	
*		Can't get the device certificate template
*	Hex Value:	0x8004c049
*/

#define DRM_E_DEVCERTTEMPLATEREADERROR        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+73)


/*
*	MessageId:	DRM_E_CLK_NOT_SUPPORTED
*	Message Meaning:	
*		The secure clock is not supported.
*	Hex Value:	0x8004c04a
*/

#define DRM_E_CLK_NOT_SUPPORTED       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+74)

/*
*	MessageId:	DRM_E_DEVCERTINDIV_NOT_SUPPORTED
*	Message Meaning:	
*		The Devcert Indiv is not supported.
*	Hex Value:	0x8004c04b
*/

#define DRM_E_DEVCERTINDIV_NOT_SUPPORTED       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+75)

/*
*	MessageId:	DRM_E_METERING_NOT_SUPPORTED
*	Message Meaning:	
*		The Metering is not supported.
*	Hex Value:	0x8004c04c
*/

#define DRM_E_METERING_NOT_SUPPORTED       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+76)

/*
*	MessageId:	DRM_E_CLK_RESETSTATEREADERROR
*	Message Meaning:	
*		Can not read Secure clock Reset State.
*	Hex Value:	0x8004c04d
*/

#define DRM_E_CLK_RESETSTATEREADERROR      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+77)

/*
*	MessageId:	DRM_E_CLK_RESETSTATEWRITEERROR
*	Message Meaning:	
*		Can not write Secure clock Reset State.
*	Hex Value:	0x8004c04e
*/

#define DRM_E_CLK_RESETSTATEWRITEERROR      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+78)

/*
*	MessageId:	DRM_E_XMLNOTFOUND
*	Message Meaning:	
*		a required XML tag was not found
*	Hex Value:	0X8004C04F
*/

#define DRM_E_XMLNOTFOUND                   MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+79)

/*
*   MessageId:  DRM_E_METERING_WRONG_TID
*   Message Meaning:    
*       wrong TID sent on metering response
*   Hex Value:  0X8004C050
*/
#define DRM_E_METERING_WRONG_TID            MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+80)

/*
*   MessageId:  DRM_E_METERING_INVALID_COMMAND
*   Message Meaning:    
*       wrong command sent on metering response
*   Hex Value:  0X8004C051
*/
#define DRM_E_METERING_INVALID_COMMAND      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+81)

/*
*   MessageId:  DRM_E_METERING_STORE_CORRUPT
*   Message Meaning:    
*       The metering store is corrupt
*   Hex Value:  0X8004C052
*/
#define DRM_E_METERING_STORE_CORRUPT        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+82)


/*
*   MessageId:  DRM_E_APPCERT_REVOKED
*   Message Meaning:    
*       The application certificate given to DRM is revoked.
*   Hex Value:  0X8004C053
*/
#define DRM_E_APPCERT_REVOKED               MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+83)


/*
*   MessageId:  DRM_E_CRYPTO_FAILED
*   Message Meaning:    
*       A cryptographic operation failed.
*   Hex Value:  0X8004C054
*/
#define DRM_E_CRYPTO_FAILED               MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+84)

/*
*   MessageId:  DRM_E_STACK_CORRUPT
*   Message Meaning:    
*       The stack allocator context is corrupt.  Likely a buffer overrun problem.
*   Hex Value:  0X8004C055
*/
#define DRM_E_STACK_CORRUPT               MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+85)

/*
*	MessageId:	DRM_E_UNKNOWN_BINDING_KEY
*	Message Meaning:	
*		A matching binding key could not be found for the license.
*	Hex Value:	0x8004C056
*/
#define DRM_E_UNKNOWN_BINDING_KEY         MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+86)

/*
*   MessageId:  DRM_E_V1_LICENSE_CHAIN_NOT_SUPPORTED
*   Message Meaning:    
*       License chaining with V1 content is not supported.
*   Hex Value:  0x8004C057
*/
#define DRM_E_V1_LICENSE_CHAIN_NOT_SUPPORTED           MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+87)


/*
*   MessageId:  DRM_E_WRONG_TOKEN_TYPE
*   Message Meaning:    
*       The wrong type of token was used.
*   Hex Value:  0x8004C058
*/
#define DRM_E_WRONG_TOKEN_TYPE           MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+88)


/*
*   MessageId:  DRM_E_POLICY_METERING_DISABLED
*   Message Meaning:    
*       Metering code was called but metering is disabled by group or user policy
*   Hex Value:  0x8004C059
*/
#define DRM_E_POLICY_METERING_DISABLED MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+89)


/*
*   MessageId:  DRM_E_POLICY_ONLINE_DISABLED
*   Message Meaning:    
*       online communication is disabled by group policy
*   Hex Value:  0x8004C05A
*/
#define DRM_E_POLICY_ONLINE_DISABLED MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+90)


/*
*    MessageId:    DRM_E_CLK_NOT_SET
*    Message Meaning:    
*        License may be there but can not be used as secure clock not set.
*    Hex Value:    0x8004C05B
*/

#define DRM_E_CLK_NOT_SET       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+91)

/*
*    MessageId:    DRM_E_NO_CLK_SUPPORTED
*    Message Meaning:    
*        This device does not support any Clock. So time bound licenses can not be played
*    Hex Value:    0x8004C05C
*/

#define DRM_E_NO_CLK_SUPPORTED       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+92)

/*
*    MessageId:    DRM_E_NO_URL
*    Message Meaning:    
*        Can not find URL info.
*    Hex Value:    0x8004C05D
*/

#define DRM_E_NO_URL       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+93)

/*
*    MessageId:    DRM_E_UNKNOWN_PROPERTY
*    Message Meaning:    
*        Unknown device property.
*    Hex Value:    0x8004C05E
*/

#define DRM_E_UNKNOWN_PROPERTY       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+94)

/*
*   MessageId:  DRM_E_METERING_MID_MISMATCH
*   Message Meaning:    
*       The metering ID is not same in Metering Cert and metering response data
*   Hex Value:  0X8004C05F
*/
#define DRM_E_METERING_MID_MISMATCH        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+95)

/*
*   MessageId:  DRM_E_METERING_RESPONSE_DECRYPT_FAILED
*   Message Meaning:    
*       The encrypted section of metering response can not be decrypted
*   Hex Value:  0X8004C060
*/
#define DRM_E_METERING_RESPONSE_DECRYPT_FAILED        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+96)

/*
*   MessageId:  DRM_E_RIV_TOO_SMALL
*   Message Meaning:
*       RIV on the machine is too small.
*   Hex Value:  0X8004C063
*/
#define DRM_E_RIV_TOO_SMALL               MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+99)

/*
**  License revocation errors; error codes from DRM_E_BASECODE+0xA0 to
**  DRM_E_BASECODE+0xA0 are reserved for license revocation errors
*/
#define DRM_E_LRB_BASECODE                      DRM_E_BASECODE+0xA0

/*
*    MessageId:    DRM_E_LRB_NOLGPUBKEY
*    Message Meaning:    
*        LRB does not contain a valid LGPUBKEY.
*    Hex Value:    0x8004c070
*/

#define DRM_E_LRB_NOLGPUBKEY                MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_LRB_BASECODE+0)

/*
*    MessageId:    DRM_E_LRB_INVALIDSIGNATURE
*    Message Meaning:    
*        Signature inside LRB is invalid.
*    Hex Value:    0x8004c071
*/

#define DRM_E_LRB_INVALIDSIGNATURE          MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_LRB_BASECODE+1)

/*
*    MessageId:    DRM_E_LRB_LGPUBKEY_MISMATCH
*    Message Meaning:    
*        LRB is signed with a pubkey different from LGPUBKEY
*    Hex Value:    0x8004c072
*/

#define DRM_E_LRB_LGPUBKEY_MISMATCH         MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_LRB_BASECODE+2)

/*
*    MessageId:    DRM_E_LRB_INVALIDLICENSEDATA
*    Message Meaning:    
*        LRB is signed with a pubkey different from LGPUBKEY
*    Hex Value:    0x8004c073
*/

#define DRM_E_LRB_INVALIDLICENSEDATA        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_LRB_BASECODE+3)

/*
**  Error codes returned from License evaluator
*/
#define DRM_E_LICEVAL_BASECODE                  DRM_E_BASECODE+0xC0

/*
*    MessageId:    DRM_E_LICEVAL_LICENSE_NOT_SUPPLIED
*    Message Meaning:  License not supplied in the liceval context  
*        
*    Hex Value:    0x8004c0c0
*/
#define DRM_E_LICEVAL_LICENSE_NOT_SUPPLIED      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_LICEVAL_BASECODE+0)

/*
*    MessageId:   DRM_E_LICEVAL_KID_MISMATCH 
*    Message Meaning:  Mismatch between KID from header and the one inside license  
*        
*    Hex Value:    0x8004c0c1
*/
#define DRM_E_LICEVAL_KID_MISMATCH              MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_LICEVAL_BASECODE+1)

/*
*    MessageId:   DRM_E_LICEVAL_LICENSE_REVOKED 
*    Message Meaning:  License for this content has been revoked  
*        
*    Hex Value:    0x8004c0c2
*/
#define DRM_E_LICEVAL_LICENSE_REVOKED           MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_LICEVAL_BASECODE+2)

/*
*    MessageId:    DRM_E_LICEVAL_UPDATE_FAILURE
*    Message Meaning:   Failed to update content revocation 
*        
*    Hex Value:    0x8004c0c3
*/
#define DRM_E_LICEVAL_UPDATE_FAILURE            MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_LICEVAL_BASECODE+3)

/*
*    MessageId:    DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE
*    Message Meaning:   Failed to update content revocation 
*        
*    Hex Value:    0x8004c0c4
*/
#define DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_LICEVAL_BASECODE+4)


/*
   IContentHeader Events
*/
#define DRM_E_CH_BASECODE                ((DRM_RESULT)0x80041100L)

/*
*   MessageId:  DRM_E_CH_VERSION_MISSING
*   Message Meaning:    
*       Missing content header version.
*   Hex Value:  0x80041103L
*/

#define DRM_E_CH_VERSION_MISSING         ((DRM_RESULT)0x80041103L)

/*
*   MessageId:  DRM_E_CH_KID_MISSING
*   Message Meaning:    
*       Missing KID attribute in content header.
*   Hex Value:  0x80041104L
*/
#define DRM_E_CH_KID_MISSING             ((DRM_RESULT)0x80041104L)

/*
*   MessageId:  DRM_E_CH_LAINFO_MISSING
*   Message Meaning:    
*       Missing LAINFO attribute in content header.
*   Hex Value:  0x80041105L
*/
#define DRM_E_CH_LAINFO_MISSING          ((DRM_RESULT)0x80041105L)

/*
*   MessageId:  DRM_E_CH_CHECKSUM_MISSING
*   Message Meaning:    
*       Missing content header checksum.
*   Hex Value:  0x80041106L
*/
#define DRM_E_CH_CHECKSUM_MISSING        ((DRM_RESULT)0x80041106L)

/*
*   MessageId:  DRM_E_CH_ATTR_MISSING
*   Message Meaning:    
*       Missing content header attribute.
*   Hex Value:  0x80041107L
*/
#define DRM_E_CH_ATTR_MISSING            ((DRM_RESULT)0x80041107L)

/*
*   MessageId:  DRM_E_CH_INVALID_HEADER
*   Message Meaning:    
*       Invalid content header.
*   Hex Value:  0x80041108L
*/
#define DRM_E_CH_INVALID_HEADER          ((DRM_RESULT)0x80041108L)

/*
*   MessageId:  DRM_E_CH_UNABLE_TO_VERIFY
*   Message Meaning:    
*       Unable to verify signature of content header.
*   Hex Value:  0x8004110AL
*/
#define DRM_E_CH_UNABLE_TO_VERIFY        ((DRM_RESULT)0x8004110AL)

/*
*   MessageId:  DRM_E_CH_UNSUPPORTED_VERSION
*   Message Meaning:    
*       Unsupported content header version.
*   Hex Value:  0x8004110BL
*/
#define DRM_E_CH_UNSUPPORTED_VERSION     ((DRM_RESULT)0x8004110BL)

/*
*   MessageId:  DRM_E_CH_UNSUPPORTED_HASH_ALGORITHM
*   Message Meaning:    
*       Unsupported hash algorithm.
*   Hex Value:  0x8004110CL
*/
#define DRM_E_CH_UNSUPPORTED_HASH_ALGORITHM ((DRM_RESULT)0x8004110CL)

/*
*   MessageId:  DRM_E_CH_UNSUPPORTED_SIGN_ALGORITHM
*   Message Meaning:    
*       Unsupported signature algorithm.
*   Hex Value:  0x8004110DL
*/
#define DRM_E_CH_UNSUPPORTED_SIGN_ALGORITHM ((DRM_RESULT)0x8004110DL)

/*
*   MessageId:  DRM_E_CH_BAD_KEY
*   Message Meaning:    
*       Invalid key
*   Hex Value:  0x8004110EL
*/
#define DRM_E_CH_BAD_KEY                 ((DRM_RESULT)0x8004110EL)

/*
*   MessageId:  DRM_E_CH_NOT_SIGNED
*   Message Meaning:    
*       The header was not signed
*   Hex Value:  0x80041113L
*/
#define DRM_E_CH_NOT_SIGNED              ((DRM_RESULT)0x80041113L)

/*
*   MessageId:  DRM_E_CH_UNKNOWN_ERROR
*   Message Meaning:    
*       Unknown Error
*   Hex Value:  0x80041116L
*/
#define DRM_E_CH_UNKNOWN_ERROR           ((DRM_RESULT)0x80041116L)


/*
*   MessageId:  DRM_E_LIC_KEY_DECODE_FAILURE
*   Message Meaning:    
*       Key decode failure.%0
*   Hex Value:  0x80048007L
*/
#define DRM_E_LIC_KEY_DECODE_FAILURE     0x80048007L


/*
*   MessageId:  DRM_E_LIC_SIGNATURE_FAILURE
*   Message Meaning:    
*       License signature failure.%0
*   Hex Value:  0x80048008L
*/
#define DRM_E_LIC_SIGNATURE_FAILURE      0x80048008L

/*
*   MessageId:  DRM_E_LIC_KEY_AND_CERT_MISMATCH
*   Message Meaning:    
*       Key and cert mismatch.%0
*   Hex Value:  0x80048013L
*/
#define DRM_E_LIC_KEY_AND_CERT_MISMATCH      0x80048013L

/*
*   MessageId:  DRM_E_KEY_MISMATCH
*   Message Meaning:    
*       A public/private keypair is mismatched.%0
*   Hex Value:  0x80048013L
*/
#define DRM_E_KEY_MISMATCH                   0x80048014L

/*
*   MessageId:  DRM_E_INVALID_SIGNATURE
*   Message Meaning:    
*       License signature failure.%0
*   Hex Value:  0x800480CFL
*/
#define DRM_E_INVALID_SIGNATURE      0x800480CFL

/*
*   MessageId:  DRM_E_SYNC_ENTRYNOTFOUND
*   Message Meaning:    
*       an entry was not found in the sync store
*   Hex Value:  0x800480D0L
*/

#define DRM_E_SYNC_ENTRYNOTFOUND     0x800480D0L

/*
*   MessageId:  DRM_E_STACKTOOSMALL
*   Message Meaning:    
*       The stack supplied to the DRM API was too small
*   Hex Value:  0x800480D1L
*/

#define DRM_E_STACKTOOSMALL     0x800480D1L

/*
*   MessageId:  DRM_E_CIPHER_NOTINITIALIZED
*   Message Meaning:    
*       The DRM Cipher routines were not correctly initialized before calling
*       encryption/decryption routines.
*   Hex Value:  0x800480D2L
*/

#define DRM_E_CIPHER_NOTINITIALIZED     0x800480D2L

/*
*   MessageId:  DRM_E_DECRYPT_NOTINITIALIZED
*   Message Meaning:    
*       The DRM decrypt routines were not correctly initialized before trying to
*       decrypt data.
*   Hex Value:  0x800480D3L
*/
#define DRM_E_DECRYPT_NOTINITIALIZED     0x800480D3L

/*
*   MessageId:  DRM_E_SECURESTORE_LOCKNOTOBTAINED
*   Message Meaning:    
*       Before reading or writing data to securestore in raw mode, first the 
*       lock must be obtained using DRM_SST_OpenData.
*   Hex Value:  0x800480D4L
*/
#define DRM_E_SECURESTORE_LOCKNOTOBTAINED     0x800480D4L

/*
*   MessageId:  DRM_E_PKCRYPTO_FAILURE
*   Message Meaning:    
*       An error occured in an asymmetric cryptographic operation.
*   Hex Value:  0x800480D5L
*/
#define DRM_E_PKCRYPTO_FAILURE     0x800480D5L

/*
*   MessageId:  DRM_E_INVALID_HDSSLOTSIZE
*   Message Meaning:    
*       Invald HDS slot size is specified.
*   Hex Value:  0x800480D6L
*/
#define DRM_E_INVALID_HDSSLOTSIZE     0x800480D6L


/*
*   MessageId:  DRM_E_VERIFICATION_FAILURE
*   Message Meaning:
*       Validation of a Longhorn certificate failed
*   Hex Value:  0x80040E80L
*/
#define DRM_E_VERIFICATION_FAILURE    0x80040E80L

/*
*   MessageId:  DRM_E_RSA_ERROR
*   Message Meaning:
*       Error in an RSA call
*   Hex Value:  0x80040E82L
*/
#define DRM_E_RSA_ERROR             0x80040E82L

/*
*   MessageId:  DRM_E_BAD_RSA_EXPONENT
*   Message Meaning:
*       An incorrect RSA exponent was supplied for a public key
*   Hex Value:  0x80040E86L
*/
#define DRM_E_BAD_RSA_EXPONENT       0x80040E86L

/*
*   MessageId:  DRM_E_LOGICERR
*   Message Meaning:    
*        DRM code has a logic error in it.  This result should never be returned.  There is an unhandled code path if it is returned
*   Hex Value:  0x8004c3e8
*/
#define DRM_E_LOGICERR                      MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+1000)

/*
*   MessageId:  DRM_E_INVALIDREVINFO
*   Message Meaning:    
*       The device certificate is invalid.
*   Hex Value:  0x8004c3e9
*/
#define DRM_E_INVALIDREVINFO                MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+1001)

/*
*   MessageId:  DRM_E_REVOCATION_BUFFERTOOSMALL
*   Message Meaning:    
*       The revocation buffer is too small, set a bigger one with DRM_MGR_SetRevocationBuffer
*   Hex Value:  0x8004c3eb
*/
#define DRM_E_REVOCATION_BUFFERTOOSMALL                MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRM_E_BASECODE+1003)

/* Range of expression evaluator results */

/*****************ERROR CODES ********************************/

#define CPRMEXP_BASECODE                        0x1400
#define CPRMEXP_NOERROR                         MAKE_DRM_RESULT(DRM_SEVERITY_SUCCESS,DRM_FACILITY_ITF, CPRMEXP_BASECODE)
#define CPRMEXP_PARAM_NOT_OPTIONAL              MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+1)
#define CPRMEXP_MEMORY_ALLOCATION_ERROR         MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+2)   
#define CPRMEXP_NO_OPERANDS_IN_EXPRESSION       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+3)
#define CPRMEXP_INVALID_TOKEN                   MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+4)
#define CPRMEXP_INVALID_CONSTANT                MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+5)   
#define CPRMEXP_INVALID_VARIABLE                MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+6)
#define CPRMEXP_INVALID_FUNCTION                MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+7)
#define CPRMEXP_INVALID_ARGUMENT                MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+8)
#define CPRMEXP_INVALID_CONTEXT                 MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+9)
#define CPRMEXP_ENDOFBUFFER                     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+10)
#define CPRMEXP_MISSING_OPERAND                 MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+11)
#define CPRMEXP_OVERFLOW                        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+12)
#define CPRMEXP_UNDERFLOW                       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+13)
#define CPRMEXP_INCORRECT_NUM_ARGS              MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+14)
#define CPRMEXP_VARIABLE_EXPECTED               MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+15)
#define CPRMEXP_RETRIEVAL_FAILURE               MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+16)
#define CPRMEXP_UPDATE_FAILURE                  MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+17)
#define CPRMEXP_STRING_UNTERMINATED             MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+18)   
#define CPRMEXP_UPDATE_UNSUPPORTED              MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+19)   
#define CPRMEXP_ISOLATED_OPERAND_OR_OPERATOR    MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+20)   
#define CPRMEXP_UNMATCHED                       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+21)
#define CPRMEXP_WRONG_TYPE_OPERAND              MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+22)
#define CPRMEXP_TOO_MANY_OPERANDS               MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+23)
#define CPRMEXP_UNKNOWN_PARSE_ERROR             MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+24)
#define CPRMEXP_UNSUPPORTED_FUNCTION            MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+25)
#define CPRMEXP_CLOCK_REQUIRED                  MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, CPRMEXP_BASECODE+26)


#define DRMUTIL_BASECODE            0x9000
#define DRMUTIL_UNSUPPORTED_VERSION MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRMUTIL_BASECODE+5)
#define DRMUTIL_EXPIRED_CERT        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRMUTIL_BASECODE+6)
#define DRMUTIL_INVALID_CERT        MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, DRMUTIL_BASECODE+7)

#ifdef __cplusplus
}
#endif


#endif /*__DRMRESULTS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmrevocation.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMREVOCATION_H__
#define __DRMREVOCATION_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _DRM_REVOCATION_TYPE_ENUM
{
    WM_DRM_REVOCATION_TYPE_APP = 0,
    WM_DRM_REVOCATION_TYPE_WMDRMPD,
    WM_DRM_REVOCATION_TYPE_WMDRMND,
} DRM_REVOCATION_TYPE_ENUM;

typedef struct __tagDRM_RLVI_RECORD
{
    DRM_GUID   listID;
    DRM_UINT64 qwVersion;
} DRM_RLVI_RECORD;

typedef struct __tagDRM_RLVI_HEAD
{
    DRM_DWORD   dwID;
    DRM_DWORD   cbSignedBytes;
    DRM_BYTE    bFormatVersion;
    DRM_BYTE    bReserved[3];
    DRM_DWORD   dwRIV;
    DRMFILETIME ftIssuedTime;
    DRM_DWORD   dwRecordCount;
} DRM_RLVI_HEAD;

typedef struct __tagDRM_RLVI_SIGNATURE
{
    DRM_BYTE  bSignatureType;
    DRM_DWORD ibSignature;
} DRM_RLVI_SIGNATURE;

typedef struct __tagDRM_RLVI_CERTCHAIN
{
    DRM_DWORD  cbCertChain;
    DRM_DWORD  ibCertChain;
} DRM_RLVI_CERTCHAIN;

typedef struct __tagDRM_RLVI
{
    DRM_RLVI_HEAD       head;
    DRM_DWORD           ibEntries;    
    DRM_RLVI_SIGNATURE  signature;
    DRM_RLVI_CERTCHAIN  certchain; 
} DRM_RLVI;

#define RLVI_MAGIC_NUM      ((DRM_DWORD) 0x524C5649) /* 'RLVI' */
#define RLVI_FORMAT_VERSION ((DRM_BYTE) 1)
#define RLVI_SIGNATURE_TYPE ((DRM_BYTE) 1)
#define RLVI_SIGNATURE_SIZE ((DRM_DWORD) 128)

#define DRM_NO_PREVIOUS_CRL 0xFFFFFFFF

#if DRM_SUPPORT_REVOCATION

#define DRM_ALL_REVOCATIONS NULL
DRM_RESULT DRM_API DRM_RVK_GetCurrentRevocationInfo(
    IN     DRM_SECSTORE_CONTEXT *f_pContextSST,
    IN     DRM_BB_CONTEXT       *f_pContextBB,
    IN     DRM_HDS_CONTEXT      *f_pContextHDS,
       OUT DRM_BYTE             *f_pbBuffer,
    IN OUT DRM_DWORD            *f_pcbBuffer,
       OUT DRM_RLVI             *f_pRLVI);

DRM_RESULT DRM_API DRM_RVK_ProcessRevocationInfo (
    IN DRM_LICEVAL_CONTEXT   *f_pContextLEVL,
    IN DRM_HDS_CONTEXT       *f_pContextHDS,
    IN DRM_SECSTORE_CONTEXT  *f_pContextSST,
    IN DRM_BB_CONTEXT        *f_pContextBB,
    IN DRM_ANSI_CONST_STRING *f_pdastrLicenseXML);


DRM_RESULT DRM_API DRM_RVK_UpdateRevocationVersionsCache( 
 IN OUT DRM_MANAGER_CONTEXT_INTERNAL  *f_pContext,
    OUT DRM_BOOL                     *f_pfUpdated);

#if DRM_SUPPORT_APP_REVOCATION

#define DRM_APP_REVOCATION_VERSION_NONE    0xFFFFFFFF

DRM_RESULT DRM_API DRM_RVK_GetCurrentAppRevocationList(
    IN      DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN      DRM_BYTE              f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)],
    IN      DRM_BYTE             *f_pbBuffer,
    IN  OUT DRM_DWORD            *f_pcbBuffer,
    IN      DRM_HDS_CONTEXT      *f_pcontextHDS,
    OUT     DRM_DWORD            *f_pidCRLApp);

DRM_RESULT DRM_API DRM_RVK_PerformAppRevocationCheck(
    IN  DRM_LICEVAL_CONTEXT  *f_pcontextLEVL,
    IN  DRM_HDS_CONTEXT      *f_pcontextHDS);

DRM_RESULT DRM_API DRM_RVK_CheckAppCertForRevocation(
    IN  DRM_BYTE             *f_pbBuffer,
    IN  DRM_DWORD             f_cbBuffer,
    IN  APPCERT              *f_pappcert);

DRM_RESULT DRM_API DRM_RVK_UpdateAppRevocationListA(
    IN  DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
    IN  DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN  DRM_BYTE              f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    IN  DRM_BYTE             *f_pbBuffer,
    IN  DRM_DWORD             f_cbBuffer,
    IN  DRM_CHAR             *f_rgchBase,
    IN  const DRM_SUBSTRING  *f_pdasstrRevocationList,
    IN  DRM_HDS_CONTEXT      *f_pcontextHDS,
    IN  APPCERT              *f_pappcert,
    IN  DRM_DWORD             f_idCRLAppCurrent,
    OUT DRM_BOOL             *f_pfUpdatedAppRevocationList);

DRM_RESULT DRM_API DRM_RVK_UpdateAppRevocationListW(
    DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
    DRM_SECSTORE_CONTEXT *f_pcontextSST,
    DRM_BYTE              f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    DRM_BYTE             *f_pbBuffer,
    DRM_DWORD             f_cbBuffer,
    DRM_CONST_STRING     *f_pdstrRevocationList,
    DRM_HDS_CONTEXT      *f_pcontextHDS,
    APPCERT              *f_pappcert,
    DRM_DWORD             f_idCRLAppCurrent,
    DRM_BOOL             *f_pfUpdatedAppRevocationList);

#endif

#if DRM_SUPPORT_DEVICE_REVOCATION

DRM_RESULT DRM_API DRM_RVK_GetDeviceRevocationList(
    IN     DRM_CRYPTO_CONTEXT   *f_pcontextCRYP, 
    IN     DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN     DRM_HDS_CONTEXT      *f_pcontextHDS,
    IN     DRM_BYTE              f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)],
    OUT    DRM_BYTE             *f_pbBuffer,
    IN OUT DRM_DWORD            *f_pcbBuffer,
    OUT    DRM_DWORD            *f_pidSerial);

DRM_RESULT DRM_API DRM_RVK_CheckDeviceRevocation(
    IN     DRM_CONST_STRING *f_pdstrdevcert,
    IN     DRM_CONST_STRING *f_pdstrXMLExclusion, 
       OUT DRM_BOOL         *f_pfExcluded);

#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

/*
** CRL defines
*/
#define WMDRMNET_CRL_ENTRY_SIZE                     SHA_DIGEST_LEN
#define WMDRMNET_CRL_SIGNATURE_TYPE_RSA_SHA1        2
#define WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1         128
#define WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1         128
    
typedef struct
{
    DRM_BYTE val[ __CB_DECL( WMDRMNET_CRL_ENTRY_SIZE ) ];
    
} WMDRMNET_CRL_ENTRY;

#if DRM_SUPPORT_WMDRMNET
DRM_RESULT DRM_API DRM_RVK_GetWMDRMNETList(
    IN     DRM_CRYPTO_CONTEXT   *f_pcontextCRYP, 
    IN     DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN     DRM_HDS_CONTEXT      *f_pcontextHDS,
    IN     DRM_BYTE              f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)],
    OUT    DRM_BYTE             *f_pbBuffer,
    IN OUT DRM_DWORD            *f_pcbBuffer,
    OUT    DRM_DWORD            *f_pidSerial);

#endif /* DRM_SUPPORT_WMDRMNET */


DRM_RESULT DRM_API _CreateRevocationStorePassword(
    IN  DRM_BB_CONTEXT *f_pcontextBBX,
    OUT DRM_BYTE        f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)]);


#endif /* DRM_SUPPORT_REVOCATION */

#ifdef __cplusplus
}
#endif

#endif /* __DRMREVOCATION_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\DrmRsa.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmresults.h>
#include <drmtypes.h>
#include <oemimpl.h>
#include <bignum.h>
#include "rsaimpl.h"


#define PUB_KEY_MARK 0
#define PRIV_KEY_MARK 1

/*
** The OEM_DrmRsaIdentifyKey identifies a pointer as a public key, private key, or not a key
**
** Parameters:
**
**      f_pvKey - pointer to either form of RSA key
*/
enum DRM_RSA_KEY_TYPE OEM_DrmRsaIdentifyKey(
    const DRM_VOID *f_pvKey)
{
    DRM_BYTE *helper = (DRM_BYTE*)f_pvKey;
    if (f_pvKey == 0) 
        return DRM_RSA_KEY_TYPE_UNKNOWN;
    if (GET_BYTE(helper, 0) == PRIV_KEY_MARK)
        return DRM_RSA_KEY_TYPE_PRIVATE;
    else if (GET_BYTE(helper,0) == PUB_KEY_MARK)
        return DRM_RSA_KEY_TYPE_PUBLIC;
    else
        return DRM_RSA_KEY_TYPE_UNKNOWN;
}

/*
 * The OEM_DrmRsaSetPublicKey function allocates an internal form of an RSA public key
 *
 * Parameters:
 *
 *      f_dwPubKeyExp - Specifies the exponent of the RSA public key
 *
 *      f_pbPubKeyMod - Specifies the modulus of the RSA public key
 *
 *      f_cbPubKeyMod - Specifies the size (in bytes) of the modulus of the RSA public key
 *
 *      f_ppPublicKey - Returns a pointer to the internal form of an RSA public key
 *          Buffer must be freed using OEM_free()
 *
 * Return Value:
 *  DRM_SUCCESS - Operation completed successfully
 *  DRM_E_OUTOFMEMORY - There is no enough memory to complete the operation
 */
DRM_RESULT DRM_API
OEM_DrmRsaSetPublicKey(
    IN DRM_DWORD f_dwPubKeyExp,
    IN DRM_BYTE *f_pbPubKeyMod,
    IN DRM_DWORD f_cbPubKeyMod,
    OUT DRM_RSA_PUBLIC_KEY** f_ppPublicKey
    )
{
    DRM_RESULT dr = DRM_SUCCESS;

    /* length of public exponent in bits */
    DRM_DWORD bitlen_pubexp = (DRM_DWORD)significant_bit_count( f_dwPubKeyExp );
    /* length of public expoenent in bytes */
    DRM_DWORD bytlen_pubexp = (bitlen_pubexp+7)/8;
    /* length of modulus in bytes */
    DRM_DWORD bytlen_mod = f_cbPubKeyMod;
    /* pointer to an external rsa key */
    DRM_BYTE *blobkey = 0;
    external_rsa_key_t *newkey = NULL;
#ifdef REVERSE_MODULUS
    DRM_DWORD i;
#endif

    ChkArg( f_pbPubKeyMod != NULL
         && f_ppPublicKey != NULL );

    blobkey = (DRM_BYTE*)OEM_malloc( SIZEOF(DRM_DWORD) + SIZEOF(external_rsa_key_t) );
    ChkMem( blobkey );

    PUT_BYTE(blobkey, 0, PUB_KEY_MARK);
    newkey = (external_rsa_key_t*)(&blobkey[sizeof(DRM_DWORD)]);
    /* figure out the length of the pubexp */
    newkey->bitlen_pubexp = bitlen_pubexp;
    /* figure out the length of the modulus (must be a multiple of 8) */
    newkey->bitlen_modulus = f_cbPubKeyMod * 8;
    /* allocate memory for the key */
#if __TMS320C55X__
    newkey->free_me = (DRM_BYTE*)OEM_malloc( (1 * bytlen_mod + bytlen_pubexp) * SIZEOF(DRM_BYTE) );
#else
    newkey->free_me = (DRM_BYTE*)OEM_malloc( (3 * bytlen_mod + bytlen_pubexp) * SIZEOF(DRM_BYTE) );
#endif
    /*
       DARKO: NOTE THAT 3*bytlen_mod ARE ALLOCATED. TWO OF THEM ARE NOT USED IN
       THE CURRENT CALLS OF DRM (USED TO STORE THE INDIVIDUAL PRIMES AND THEIR INVERSES)...
       IF SPACE IN OPERATING MEMORY IS PROBLEM, CONSIDER SHAVING OFF THIS DATA
       FROM THE EXTERNAL KEY!!!
    */
    ChkMem( newkey->free_me );
    /* arrange the pointers */
    newkey->pubexp = newkey->free_me;
    newkey->modulus = newkey->pubexp + __CB_DECL(bytlen_pubexp);
    /* store the public exponent */
    digits_to_big_endian_bytes( (digit_tc*)&f_dwPubKeyExp, bitlen_pubexp, newkey->pubexp );

#ifdef REVERSE_MODULUS
    /* Reverse the modulus */
    for (i = 0; i < f_cbPubKeyMod; ++i)
    {
        PUT_BYTE( (DRM_BYTE *)newkey->modulus,
            i,
            GET_BYTE( f_pbPubKeyMod, f_cbPubKeyMod - i - 1 ) );
    }
#else
    /* copy modulus  */
    MEMCPY( newkey->modulus, f_pbPubKeyMod, bytlen_mod );
#endif

    /* finally recast for the output */
    *f_ppPublicKey = (DRM_RSA_PUBLIC_KEY*)blobkey;

ErrorExit:

    if (DRM_FAILED(dr))
    {
        if (newkey != NULL)
        {
            if (newkey->free_me != NULL)
            {
                OEM_free( newkey->free_me );
            }
            OEM_free( newkey );
        }
    }

    return dr;

}

/*
 * The OEM_DrmRsaSetPrivateKey function allocates an internal form of an RSA private key
 *
 * Parameters:
 *
 *      f_pbPrivateKey - Specifies the RSA private key.
 *          This buffer is in an OEM specific format.
 *          The format of this buffer is not necessarily the same as the one returned.
 *
 *      f_cbPrivateKey - Specifies the size (in bytes) of the RSA private key
 *
 *      f_ppPrivateKey - Returns the RSA private key.
 *          Buffer must be freed using OEM_free()
 *
 * Return Value:
 *  DRM_SUCCESS - Operation completed successfully
 *  DRM_E_OUTOFMEMORY - There is no enough memory to complete the operation
 */

DRM_RESULT DRM_API
OEM_DrmRsaSetPrivateKey(
    IN DRM_BYTE *f_pbPrivateKey,
    IN DRM_DWORD f_cbPrivateKey,
    OUT DRM_RSA_PRIVATE_KEY **f_ppPrivateKey
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BOOL   OK = TRUE;
    DRM_BYTE  *help;
    DRM_BYTE  *blobkey = 0;
    DRM_DWORD  diglen_mod, primelen;
    digit_t   *dtemps = NULL;
    digit_t   *temp1 = NULL;
    digit_t   *temp2 = NULL;
    digit_t   *temp3 = NULL;
    internal_rsa_key_t *key = NULL;
    DRM_DWORD *prime = NULL;
    DRM_DWORD *primesrc;
    DRM_DWORD i;

    ChkArg( f_pbPrivateKey != NULL
         && f_ppPrivateKey != NULL );


    /* make sure that the buffer is at least the minimum size */
    ChkArg( f_cbPrivateKey >= 4 /* exponent */
                        + 4 /* bitlen modulus */
                        + 4 /* length of the primes */ );
    /* allocate the new private key */
    blobkey = (DRM_BYTE*)OEM_malloc( SIZEOF(DRM_DWORD) + SIZEOF(internal_rsa_key_t) );
    ChkMem( blobkey );
    PUT_BYTE(blobkey, 0, PRIV_KEY_MARK);
    key = (internal_rsa_key_t*)(&blobkey[sizeof(DRM_DWORD)]);
    /* how does the external structure look like? */
    /* diglen_pubexp has always length of one DWORD - DRM API says so! */
    key->diglen_pubexp = 1; 
    /* bitlen_modulus is stored in the 4-7th bytes of *f_pbPrivateKey */
    BYTES_TO_DWORD(key->bitlen_modulus, f_pbPrivateKey + __CB_DECL(4));
    /* length of primes is stored in the 8-11th bytes of *f_pbPrivateKey */
    /* both primes must be of equal length, i.e. 1/2 of modulus bitlen */
    BYTES_TO_DWORD(primelen, f_pbPrivateKey + __CB_DECL(8));
    /* make sure that the given buffer is the right size */
    ChkArg( f_cbPrivateKey >= 4 /* exponent */
                        + 4 /* bitlen modulus */
                        + 4 /* length of the primes */
                        + 2 * primelen * 4 /* primes */ );
    /* length of modulus */
    diglen_mod = 2 * primelen;
    /* allocate memory for private key structure... */
    dtemps = digit_allocate( 3 * diglen_mod + key->diglen_pubexp, "rsa_key_internalize", NULL);
    ChkMem( dtemps );
    /* set pointers appropriately */
    key->free_me = dtemps;
    key->pubexp = dtemps + 3 * diglen_mod;
    /* value of public exponent is stored in the 0-3rd bytes of *f_pbPrivateKey */
    /* the value can be only a single DWORD since key->diglen_pubexp must be one */
    BYTES_TO_DWORD(key->pubexp[0], &f_pbPrivateKey[0]);
    /* compute the modulus from the primes */
    key->modulus = dtemps;
    /* readjust pointer to second prime  */
    ChkMem( prime = OEM_malloc( primelen * SIZEOF(DRM_DWORD) * 2) );
    for(i = 0, primesrc = (DRM_DWORD *)&f_pbPrivateKey[__CB_DECL(12)]; i < primelen * 2; i++, primesrc++)
    {
        BYTES_TO_DWORD(prime[i], primesrc);
    }
    help = (DRM_BYTE *)&prime[primelen];

    /* compute the modulus */
    OK = OK && multiply((digit_tc *)prime, primelen,
        (digit_tc *)help, primelen, key->modulus, NULL);
    if(!OK)
    {
        TRACE(("multiply failed\n"));
    }

    if (OK)
    {
        /* temporary buffers to store intermediate results... */
        DWORDREG ip, moduli_created = 0;
        DWORDREG lgcd = 0;

        temp1 = (digit_t*)OEM_malloc(SIZEOF(digit_t)*primelen);    
        ChkMem( temp1 );
        temp2 = (digit_t*)OEM_malloc(SIZEOF(digit_t)*primelen);    
        ChkMem( temp2 );
        temp3 = (digit_t*)OEM_malloc(SIZEOF(digit_t)*primelen);    
        ChkMem( temp3 );

        /* for each prime */
        for (ip = 0; ip != 2; ip++) {
            /* pointer to the prime */
            digit_t *src;
			
            for(i = 0, src = (digit_t *)(&f_pbPrivateKey[__CB_DECL(12)]) + ip*primelen; i < primelen; i++, src++)
            {
                BYTES_TO_DWORD(temp1[i], src);
            }
            /* pointer to the private exponents */
            key->privexps[ip] = dtemps + diglen_mod + ip*primelen;
            /* pointer to chinese */
            key->chineses[ip] = key->privexps[ip] + diglen_mod;
            /* compute the modulus strucutre for each prime */
            OK = OK && create_modulus(temp1, primelen, FROM_RIGHT, &key->moduli[ip], NULL, NULL);

            if (OK)
                moduli_created++;
            /* compute the private exponent */
            sub_immediate(temp1, 1, temp2, primelen);    /* temp2 = p - 1 */
            OK = OK && mp_gcdex(key->pubexp, key->diglen_pubexp, temp2, primelen,
                        key->privexps[ip], digit_NULL, temp3,
                        digit_NULL, &lgcd, digit_NULL, NULL);

        } /* for ip */
        /* compute the chinese */
        OK = OK && mp_gcdex(key->moduli[0].modulus, primelen,
            key->moduli[1].modulus, primelen,
            key->chineses[1], key->chineses[0],
            temp2, digit_NULL, &lgcd, digit_NULL, NULL);

        /* chineses[0] = 1/p2 (mod p1).  chineses[1] = 1/p1 (mod p2) */
        if (OK && compare_immediate(temp2, 1, lgcd) != 0) {
            if(!OK)
            {
                TRACE(("compare_immediate failed\n"));
            }
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                "rsa_key_internalize, GCD(p1, p2) <> 1", NULL);
        }
        OEM_free(temp1);
        OEM_free(temp2);
        OEM_free(temp3);
    } /* if */
    /* recast the output */
    *f_ppPrivateKey = (DRM_RSA_PRIVATE_KEY*)blobkey;

ErrorExit:

    if(!OK)
    {
        dr = DRM_E_FAIL;
    }
    
    if (DRM_FAILED(dr))
    {
        if (blobkey != NULL)
        {
            OEM_free( blobkey );
        }
        if (dtemps != NULL)
        {
            OEM_free( dtemps );
        }
        if (temp2 != NULL)
        {
            OEM_free( temp2 );
        }
        if (temp3 != NULL)
        {
            OEM_free( temp3 );
        }
    }
    SAFE_OEM_FREE( prime );

    return dr;

}

/*
 * The OEM_DrmRsaKeySize routine determines the key size for the specific key.
 *
 * The key size is the size of the buffer used during encryption or decryption with the key.
 * A buffer of this size should be passed into the DrmRsaEncPublic and DrmRsaDecPrivate routines.
 *
 * Notice that this key size shouldn't be used for any other purpose.  Specifically,
 * note that this size may be larger then DrmRsaModulusSize.
 *
 * Parameters:
 *
 *      f_pvKey - Specifies the key to determine the size of
 *          This key must be either of type DRM_RSA_PUBLIC_KEY or DRM_RSA_PRIVATE_KEY.
 *          NULL indicates that the private key baked into the device should be used
 *
 * Return Value:
 *      Size of the key in bytes
 *      0 indicates that the key isn't properly formatted
 */

DRM_DWORD DRM_API
OEM_DrmRsaKeySize(
    const DRM_VOID *f_pvKey
    )
{
    DRM_BYTE *helper = (DRM_BYTE*)f_pvKey;
    if (f_pvKey == 0) 
        return 0;
    if (GET_BYTE(helper, 0) == PRIV_KEY_MARK)
    {
      internal_rsa_key_t *key = (internal_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);
        return (key->bitlen_modulus+7)/8;
    }
    else if (GET_BYTE(helper, 0) == PUB_KEY_MARK)
    {
      external_rsa_key_t *key = (external_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);
        return (key->bitlen_modulus+7)/8;
    }
    else
        return 0;
}

/*
 * The OEM_DrmRsaModulusSize routine determines the modulus size for the specific key.
 *
 * The modulus size represents the publicly visible strength of the key.
 *
 * Parameters:
 *
 *      f_pvKey - Specifies the key to determine the modulus size of
 *          This key must be either of type DRM_RSA_PUBLIC_KEY or DRM_RSA_PRIVATE_KEY.
 *          NULL indicates that the private key baked into the device should be used
 *
 * Return Value:
 *      Modulus size of the key in bytes
 *      0 indicates that the key isn't properly formatted
 */

DRM_DWORD DRM_API
OEM_DrmRsaModulusSize(
    DRM_VOID *f_pvKey
    )
{
    DRM_BYTE *helper = (DRM_BYTE*)f_pvKey;
    if (f_pvKey == 0) 
        return 0;
    if (GET_BYTE(helper, 0) == PRIV_KEY_MARK)
    {
        internal_rsa_key_t *key = (internal_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);
        return (key->bitlen_modulus+7)/8;
    }
    else if (GET_BYTE(helper, 0) == PUB_KEY_MARK)
    {
      external_rsa_key_t *key = (external_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);
        return (key->bitlen_modulus+7)/8;
    }
    else
    {
		TRACE(("Invalid key type %d\n", GET_BYTE(helper, 0)));
        return 0;
	}
}


/*
 * The OEM_DrmRsaGetBufferSize routine determines the size for the specific key.
 *
 * Parameters:
 *
 *      f_pvKey - Specifies the key to determine the size of
 *          This key must be either of type DRM_RSA_PUBLIC_KEY or DRM_RSA_PRIVATE_KEY.
 *
 *      f_pcbKey- on success this is filled in with the buffer size for the key
 *
 * Notes: while public keys are intrinsically self-describing, RSA private keys
 *        only reveal their total size by the implicit relationship between the 
 *        size of the public key modulus and the buffer size
 */
DRM_RESULT DRM_API
OEM_DrmRsaGetBufferSize (
    IN  const DRM_VOID  *f_pvKey,
    OUT       DRM_DWORD *f_pcbKey )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE *helper;

    ChkArg( f_pvKey  != NULL
         && f_pcbKey != NULL );

    helper = (DRM_BYTE*)f_pvKey;
    if (GET_BYTE(helper, 0) == PRIV_KEY_MARK)
    {
        internal_rsa_key_t *key = (internal_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);
        *f_pcbKey = (key->bitlen_modulus+7)/8;
    }
    else if (GET_BYTE(helper, 0) == PUB_KEY_MARK)
    {
        external_rsa_key_t *key = (external_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);
        *f_pcbKey = (key->bitlen_modulus+7)/8;
    }
    else
        ChkDR( DRM_E_FAIL );

ErrorExit:

    return dr;
}

/*
 * The OEM_DrmRsaEncPublic routine RSA encrypts a fixed size buffer with an RSA public key
 *
 * Parameters:
 *
 *      f_pKey - Specifies the public key
 *
 *      f_pbDataIn - Specifies the input data
 *          The array must be DrmRsaKeySize bytes long.  Any unused bytes in the
 *          array should be zeroed.
 *
 *      f_pbDataOut - Specifies the output data
 *          The array must be DrmRsaKeySize() bytes long.
 *
 * Return Value:
 *      TRUE - encryption succeeded.
 *      FALSE - encryption failed.
 */

DRM_BOOL DRM_API
OEM_DrmRsaEncPublic(
    IN DRM_RSA_PUBLIC_KEY *f_pKey,
    IN DRM_BYTE *f_pbDataIn,
    IN OUT DRM_BYTE *f_pbDataOut
    )
{
    if (f_pKey != 0 && f_pbDataIn != 0 && f_pbDataOut != 0)
    {
        DRM_BYTE *helper = (DRM_BYTE*)f_pKey;
        external_rsa_key_t *mf = (external_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);
        
        return ((DRM_BOOL) rsa_encryption(mf, 
            (DRM_BYTE*)f_pbDataIn, (DRM_BYTE*)f_pbDataOut)); 
    }
    else return FALSE;
}

/*
 * The OEM_DrmRsaDecPrivate routine RSA decrypts a fixed size buffer with an RSA private key
 *
 * Parameters:
 *
 *      f_pKey - Specifies the private key
 *          NULL indicates that the private key baked into the device should be used
 *
 *      f_pbDataIn - Specifies the input data
 *          The array must be DrmRsaKeySize bytes long.  Any unused bytes in the
 *          array should be zeroed.
 *
 *      f_pbDataOut - Specifies the output data
 *          The array must be DrmRsaKeySize() bytes long.
 *
 * Return Value:
 *      TRUE - decryption succeeded.
 *      FALSE - decryption failed.
 */

DRM_BOOL DRM_API
OEM_DrmRsaDecPrivate(
    IN DRM_RSA_PRIVATE_KEY *f_pKey,
    IN DRM_BYTE *f_pbDataIn,
    IN OUT DRM_BYTE *f_pbDataOut
    )
{
    DRM_BYTE *helper;
    internal_rsa_key_t *mf;

    if ( f_pKey      == NULL
      || f_pbDataIn  == NULL
      || f_pbDataOut == NULL )
    {
        return FALSE;
    }

    helper = (DRM_BYTE*)f_pKey;
    mf = (internal_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);
    return rsa_decryption( mf, (DRM_BYTE*)f_pbDataIn, (DRM_BYTE*)f_pbDataOut );
}

/* parsing the public key */
DRM_RESULT DRM_API OEM_DrmRsaParsePublicKey(
    IN    DRM_RSA_PUBLIC_KEY *f_pkeyRSAPublic,
    OUT         DRM_DWORD    *f_pdwExponent,
    OUT         DRM_BYTE     **f_ppbModulus,
    OUT         DRM_DWORD    *f_pcbModulus)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE *helper;
    external_rsa_key_t *key;
    DRM_DWORD cbModulus;

    ChkArg( f_pkeyRSAPublic != NULL );

    /* cast the key into bignum's internal structure */
    helper = (DRM_BYTE*)f_pkeyRSAPublic;
    key = (external_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);    

    /* figure out how large the contents are in bytes */
    cbModulus = (key->bitlen_modulus + 7)/8;

    if ( f_pcbModulus != NULL )
    {
        *f_pcbModulus = cbModulus;
    }

    if ( f_pdwExponent != NULL )
    {
        /* copy contents of exponent */
        big_endian_bytes_to_digits(key->pubexp, key->bitlen_pubexp, (digit_t*)f_pdwExponent);
    }

    if (f_ppbModulus != NULL)
    {
        *f_ppbModulus = key->modulus;
    }

ErrorExit:

    return dr;
}

/* parsing the private key */
DRM_RESULT DRM_API OEM_DrmRsaParsePrivateKey(
    IN    DRM_RSA_PRIVATE_KEY *f_pkeyRSAPrivate,
    OUT   DRM_DWORD           *f_pdwExponent,
    OUT   DRM_BYTE           **f_ppbModulus,
    OUT   DRM_DWORD           *f_pcbModulus,
    OUT   DRM_BYTE           **f_ppbPrivate,
    OUT   DRM_DWORD           *f_pcbPrivate)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD bytlen_modulus;
    DRM_BYTE *help;
    DRM_BYTE *helper;
    internal_rsa_key_t *key;

    ChkArg( f_pdwExponent != NULL
         && f_ppbModulus  != NULL
         && f_pcbModulus  != NULL
         && f_ppbPrivate  != NULL
         && f_pcbPrivate  != NULL );

    helper = (DRM_BYTE*)f_pkeyRSAPrivate;
    key = (internal_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);    
    /* fix pointer to key */
    /* figure out length of pub-key exponent */
    *f_pdwExponent = key->pubexp[0];
    /* length of modulus in bits */
    *f_pcbModulus = key->bitlen_modulus;
    bytlen_modulus = ((*f_pcbModulus)+7)/8;
    /* copy the modulus */
    *f_ppbModulus = (DRM_BYTE*)OEM_malloc(SIZEOF(DRM_BYTE) * bytlen_modulus);
    ChkMem( f_ppbModulus );
    MEMCPY(*f_ppbModulus, key->modulus, bytlen_modulus);
    /* copy the prime lengths */
    if (key->moduli[0].length != key->moduli[1].length)
    {
        OEM_free(*f_ppbModulus);
        *f_ppbModulus = 0;
        ChkDR( DRM_E_FAIL );
    }
    *f_pcbPrivate = (DRM_DWORD)key->moduli[0].length;
    /* allocate memory for the primes */
    *f_ppbPrivate = (DRM_BYTE*)OEM_malloc(SIZEOF(DRM_BYTE) * bytlen_modulus);
    if (*f_ppbPrivate == NULL)
    {
        OEM_free(*f_ppbModulus);
        *f_ppbModulus = 0;
        ChkDR( DRM_E_FAIL );
    }
    /* copy the first prime */
    MEMCPY(*f_ppbPrivate, key->moduli[0].modulus, (*f_pcbPrivate)*4);
    /* then the second prime */
    help = (*f_ppbPrivate)+(*f_pcbPrivate)*4;
    MEMCPY(help, key->moduli[1].modulus, (*f_pcbPrivate)*4);

ErrorExit:

    return dr;
}


/*
 * The OEM_DrmRsaReleaseKey routines free keys created with OEM_DrmRsaSetPublicKey and OEM_DrmRsaSetPrivateKey
 *
 * Parameters:
 *
 *      f_pvKey - Specifies the key
 *
 * Return Value:
 *      DRM_E_INVALIDARG - the given pointer does not point to a valid RSA key struct
 */
DRM_RESULT DRM_API OEM_DrmRsaReleaseKey(
       IN DRM_VOID *f_pvKey)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE *helper;

    if ( f_pvKey != NULL )
    {
        helper = (DRM_BYTE*) f_pvKey;

        if (GET_BYTE(helper, 0) == PUB_KEY_MARK)
        {
            external_rsa_key_t *prsaext = (external_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);
            Free_Temporaries(prsaext->free_me, NULL);
            OEM_SecureZeroMemory( (DRM_BYTE *) prsaext, SIZEOF(external_rsa_key_t) );
            OEM_free( f_pvKey );
        }
        else if (GET_BYTE(helper, 0) == PRIV_KEY_MARK)
        {
            internal_rsa_key_t *prsaint = (internal_rsa_key_t*)(&helper[sizeof(DRM_DWORD)]);
            uncreate_modulus(&prsaint->moduli[0], NULL);
            uncreate_modulus(&prsaint->moduli[1], NULL);
            Free_Temporaries(prsaint->free_me, NULL);
            OEM_SecureZeroMemory( (DRM_BYTE *) prsaint, SIZEOF(internal_rsa_key_t) );
            OEM_free( f_pvKey );
        }
        else
            ChkDR( DRM_E_FAIL );
    }

ErrorExit:

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmrevocation.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmpkcrypto.h>
#include <drmcipher.h>
#include <drmsha1.h>
#include <drmsecurestore.h>
#include <drmrevocation.h>
#include <drmlicenseparser.h>
#include <drmxmlparser.h>
#include <drmxmlutilities.h>
#include <drmcrt.h>
#include <oemimpl.h>
#include <byteorder.h>
#include <drmint64.h>
#include <drmcert.h>
#include <drmbase64.h>
#include <drmcertparser.h>
#include <drmrsaex.h>

/* keypair for device exclusion; the private key is cloaked and must be uncloaked to compile */

#include <drmpubkeydeviceexclusion.h>

/* pubkey for app revocation */

#include <drmpubkeyrevocation.h>

#if DRM_SUPPORT_WMDRMNET
static DRM_RESULT DRM_API _VerifyBinaryWMDRMNETSignature(
    IN     DRM_BYTE  *f_pbBinary,
    IN     DRM_DWORD  f_cbBinary,
    IN OUT DRM_DWORD *f_pidSerial);

static DRM_RESULT _VerifyWMDRMNETRevocationList(
    IN  DRM_CONST_STRING   *f_pdstrList,
    OUT DRM_DWORD          *f_pdwVersion );
#endif

DRM_RESULT
_ValidateCertificate(
    IN DRM_CHAR          *f_rgchBase,
    IN DRM_SUBSTRING      f_dasstrCertificate,
    IN OUT DRM_SUBSTRING *f_pdasstrWMDRMNDCertificate);

DRM_RESULT _UpdateAppRevocationList(
    DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
    DRM_SECSTORE_CONTEXT *f_pcontextSST,
    DRM_BYTE              f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    DRM_BYTE             *f_pbRevocationList,
    DRM_DWORD             f_cbRevocationList,
    DRM_HDS_CONTEXT      *f_pcontextHDS,
    APPCERT              *f_pappcert,
    DRM_DWORD             f_idCRLAppCurrent,
    DRM_BOOL             *f_pfUpdatedAppRevocationList);

/*****************************************************************************
** Function: _CreateRevocationStorePassword
**
** Synopsis: create the one-byte-zero hash to open the revocations secure store
**
** Arguments:
**            [f_pcontextBBX] -- blackbox context
**            [f_rgbPassword] -- output buffer
*****************************************************************************/

DRM_RESULT DRM_API _CreateRevocationStorePassword(
    IN  DRM_BB_CONTEXT *f_pcontextBBX,
    OUT DRM_BYTE        f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)])
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE bZero = 0x00;
    static DRM_BOOL fInitedPassword = FALSE;
    static DRM_BYTE rgbPassword [__CB_DECL(SHA_DIGEST_LEN)];

    if( !fInitedPassword )
    {
        /* If we've never calculated the password before, do it now */
        ChkDR( DRM_BBX_HashValue(&bZero, SIZEOF (bZero), rgbPassword, f_pcontextBBX) );
        fInitedPassword = TRUE;
    }

    /* Copy the cached password, it will never change. */
    MEMCPY( f_rgbPassword, rgbPassword, SHA_DIGEST_LEN );

ErrorExit:
    return dr;
}

#if DRM_SUPPORT_APP_REVOCATION
/************************ APP REVOCATION ************************/

const DRM_DWORD CURRENT_REVOCATION_VERSION = 2;

typedef DRM_DWORD DRM_CERT_TYPE;
#define CERTTYPE_V1APP 0

typedef struct __tagDRM_REVOCATION_LIST_ELEMENT
{
    DRM_CERT_TYPE certificatetype;
    DRM_DWORD     cbCert;
    DRM_BYTE      rgbCert [1];
}DRM_REVOCATION_LIST_ELEMENT;

typedef struct __tagDRM_REVOCATION_LIST
{
    DRM_BYTE  rgbSignature [__CB_DECL( PK_ENC_SIGNATURE_LEN) ];
    DRM_DWORD dwVersion;
    DRM_DWORD cb;
    DRM_DWORD idSerial;
    DRM_BYTE  rgbData [1]; /* An array of DRM_REVOCATION_LIST_ELEMENT structs which are variable length */
} DRM_REVOCATION_LIST;


static DRM_RESULT _CheckCertInRevocationList(
    DRM_CERT_TYPE        f_certificatetype,
    DRM_BYTE            *f_pbCertData,
    DRM_DWORD            f_cbCertData,
    DRM_REVOCATION_LIST *f_prevocationlist)
{
    DRM_BYTE  *pbElt    = f_prevocationlist->rgbData;
    DRM_DWORD  cbElt    = 0;
    DRM_DWORD  ibElt    = 0;
    DRM_RESULT dr       = DRM_SUCCESS;
    
    cbElt = f_prevocationlist->cb;
    FIX_ENDIAN_DWORD( cbElt );

    /* The revocation list is an array of DRM_REVOCATION_LIST_ELEMENT structs, so lets check them */
    while ( ibElt < cbElt )
    {
        DRM_CERT_TYPE  ecertType = 0;
        DRM_DWORD      cbCert    = 0;
        
        DRM_BYT_CopyBytes( &ecertType, 0, pbElt, ibElt, SIZEOF( DRM_DWORD ) );
        FIX_ENDIAN_DWORD( ecertType );
        ibElt += SIZEOF( DRM_CERT_TYPE );

        DRM_BYT_CopyBytes( &cbCert, 0, pbElt, ibElt, SIZEOF( DRM_DWORD ) );
        FIX_ENDIAN_DWORD( cbCert );
        ibElt += SIZEOF( DRM_DWORD );
        
        if ((ecertType == f_certificatetype) 
         && (cbCert    == f_cbCertData) 
         && (DRM_BYT_CompareBytes(f_pbCertData, 0, pbElt, ibElt, f_cbCertData) == 0))
        {
            ChkDR(DRM_E_APPCERT_REVOKED);
        }

        ibElt += cbCert;
    }

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function - DRM_RVK_PerformAppRevocationCheck
**
** Synopsis - calls app revocation operation 
**
** Arguments
** [f_pcontextLEVL] -- initialized liceval context
** [f_pcontextBBX]  -- initialized blackbox context
** [f_pcontextHDS]  -- initialized HDS context
*****************************************************************************/

#if DRM_SUPPORT_REVOCATION
DRM_RESULT DRM_API DRM_RVK_PerformAppRevocationCheck(
    IN DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN DRM_HDS_CONTEXT     *f_pcontextHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   rgbPassword [__CB_DECL(SHA_DIGEST_LEN)] = { 0x00 };
    DRM_CONST_STRING dstrAttributeData = EMPTY_DRM_STRING;

    ChkArg (f_pcontextLEVL != NULL
        &&  f_pcontextHDS  != NULL);

    dr = DRM_LIC_GetAttribute( &f_pcontextLEVL->dstrContentLicense, 
                               &g_dstrAppRevocation,
                               DRM_LICENSE_ATTRIB_REVOCATION, 
                               NULL,
                               &dstrAttributeData, 
                               0 );
                                
    if (dr == DRM_E_XMLNOTFOUND)
    {
        dr = DRM_SUCCESS; 
        goto ErrorExit;
    }

    ChkDR(dr);  /* other errors */
     
    ChkDR(_CreateRevocationStorePassword (f_pcontextLEVL->pcontextBBX, rgbPassword));
    
    ChkDR(DRM_RVK_UpdateAppRevocationListW( &f_pcontextLEVL->pcontextBBX->CryptoContext, 
                                            f_pcontextLEVL->pcontextSSTRevocation,
                                            rgbPassword,
                                            f_pcontextLEVL->pbRevocationBuffer,
                                            f_pcontextLEVL->cbRevocationBuffer,
                                           &dstrAttributeData,
                                            f_pcontextHDS,
                                           &f_pcontextLEVL->appcert,
                                            f_pcontextLEVL->idCRLsCurrent.app,
                                           &f_pcontextLEVL->fUpdatedRevocationList));

ErrorExit:    
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        dr = DRM_E_REVOCATION_BUFFERTOOSMALL;
    }
    
    return dr;

}
#endif /* DRM_SUPPORT_REVOCATION */
/*****************************************************************************
** Function: DRM_RVK_GetCurrentAppRevocationList
**
** Synopsis: open the secure store and get the version number of the 
**           app revocation list currently stored
**
** Parameters:
**
** [f_pcontextSST]    -- secure store context
** [f_rgbPasswordSST] -- password used to retrieve secure store data
** [f_pbBuffer]       -- working buffer
** [f_pcbBuffer]      -- pointer to variable to receive app revocation list size
** [f_pcontextHDS]    -- initialized HDS context
** [f_pidCRLApp]      -- pointer to variable to receive app revocation list index
*****************************************************************************/
#if DRM_SUPPORT_REVOCATION
DRM_RESULT DRM_API DRM_RVK_GetCurrentAppRevocationList(
    IN      DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN      DRM_BYTE              f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)],
    IN      DRM_BYTE             *f_pbBuffer,
    IN  OUT DRM_DWORD            *f_pcbBuffer,
    IN      DRM_HDS_CONTEXT      *f_pcontextHDS,
    OUT     DRM_DWORD            *f_pidCRLApp)
{
    DRM_RESULT dr    = DRM_SUCCESS;        

    ChkArg (f_pcontextSST    != NULL
        &&  f_rgbPasswordSST != NULL
        &&  f_pcontextHDS    != NULL
        &&  f_pidCRLApp      != NULL
        &&  f_pcbBuffer      != NULL);

    dr =  DRM_SST_GetData(f_pcontextSST,  
                         &g_lidAppRevocation, 
                          NULL,
                          f_rgbPasswordSST,
                          SECURE_STORE_REVOCATION_DATA,
                          f_pcontextHDS, 
                          f_pbBuffer, 
                          f_pcbBuffer);

    if (DRM_SUCCEEDED(dr))
    {
        ChkBOOL( f_pbBuffer != NULL,                        DRM_E_LOGICERR);
        ChkBOOL(*f_pcbBuffer > SIZEOF(DRM_REVOCATION_LIST), DRM_E_BUFFERTOOSMALL);
        
        *f_pidCRLApp = ((DRM_REVOCATION_LIST *) f_pbBuffer)->idSerial;

        FIX_ENDIAN_DWORD(*f_pidCRLApp);
    }
    else if (dr == DRM_E_BUFFERTOOSMALL)
    {
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }
    else if (dr == DRM_E_FILENOTFOUND
          || dr == DRM_E_HDSSLOTNOTFOUND)
    {
        dr          = DRM_SUCCESS;
       *f_pidCRLApp = DRM_APP_REVOCATION_VERSION_NONE;
       *f_pcbBuffer = 0;
    }
    
ErrorExit:

    return dr;
}
#endif /* DRM_SUPPORT_REVOCATION */
/*****************************************************************************
** Function DRM_RVK_CheckAppCertForRevocation
**
** f_pbAppCRL -- DRM_REVOCATION_LIST passed in as byte buffer
** f_cbAppCRL -- size of the App CRL in bytes
** f_pappcert -- app certificate to check against what is in the store.
*****************************************************************************/
#if DRM_SUPPORT_REVOCATION
DRM_RESULT DRM_API DRM_RVK_CheckAppCertForRevocation(
    DRM_BYTE             *f_pbAppCRL,
    DRM_DWORD             f_cbAppCRL,
    APPCERT              *f_pappcert)
{
    DRM_RESULT dr = DRM_SUCCESS;        

    ChkArg(f_pbAppCRL    != NULL
        && f_pappcert    != NULL
        && f_cbAppCRL     > 0);
    
    ChkDR(_CheckCertInRevocationList(CERTTYPE_V1APP,
                       (DRM_BYTE *) &f_pappcert->appcd.pk.pk,
                             SIZEOF (f_pappcert->appcd.pk.pk),
            (DRM_REVOCATION_LIST *)  f_pbAppCRL));

ErrorExit:
    return dr;
}
#endif /* DRM_SUPPORT_REVOCATION */
/*****************************************************************************
** Function: DRM_RVK_UpdateAppRevocationListA
**
** Synopsis: Expanded version of DRM_RVK_PerformAppRevocationCheck.  Allows an 
**           app to query for app revocation without the lic eval context.
**
** Parameters:
**
** [pcontextCRYP]         -- Crypto buffer
** [f_pcontextSST]        -- secure store context
** [f_rgbPassword]        -- password that used to secure and validate the secure store data
** [f_pbBuffer]           -- working buffer
** [f_cbBuffer]           -- size of f_pbBuffer in bytes
** [f_pdstrRevocationList]-- Revocation list string that will be updated in the store 
** [f_pcontextHDS]        -- initialized HDS context
** [f_pappcert]           -- app certificate to check against what is in the store.
** [f_idCRLAppCurrent]    -- version number/index of the currently stored App CRL
** [f_pfUpdatedAppRevocationList] -- optional pointer to a bool variable to be set TRUE
**                           if the stored App CRL was updated.  PC-side callers
**                           should update cached global App CRL
 ****************************************************************************/

DRM_RESULT DRM_API DRM_RVK_UpdateAppRevocationListA(
        DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
        DRM_SECSTORE_CONTEXT *f_pcontextSST,
        DRM_BYTE              f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
        DRM_BYTE             *f_pbBuffer,
        DRM_DWORD             f_cbBuffer,
        DRM_CHAR             *f_rgchBase,
  const DRM_SUBSTRING        *f_pdasstrRevocationList,
        DRM_HDS_CONTEXT      *f_pcontextHDS,
        APPCERT              *f_pappcert,
        DRM_DWORD             f_idCRLAppCurrent,
        DRM_BOOL             *f_pfUpdatedAppRevocationList)
{
    DRM_RESULT            dr              = DRM_SUCCESS;        

    ChkArg(f_pcontextCRY != NULL
        && f_pcontextSST != NULL
        && f_rgbPassword != NULL
        && f_pcontextHDS != NULL
        && f_pappcert    != NULL
        && f_cbBuffer     > 0
        && f_rgchBase     != NULL
        && f_pdasstrRevocationList != NULL );
    

    if (f_pfUpdatedAppRevocationList != NULL)
    {
       *f_pfUpdatedAppRevocationList = FALSE;
    }


    /* If they don't pass us a buffer, it's a signal to just decode in place */
    if( f_pbBuffer == NULL )
    {

        /* pbOffset will point within the base64 revocation list we were passed,
           such that after base64 decoding the end of the decoded data will co-incide with
           the end of the buffer we were given, minus one byte.

           This is because we are giving the B64 decoder overlapping memory for source and desitination,
           and we can't use the DECODE_IN_PLACE flag because this is ANSI where the offset may not coincide
           with a word boundary as required on 16-bit platforms.
         */

        f_pbBuffer = (DRM_BYTE*)f_rgchBase
                            + __CB_DECL( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) - 1 )
                            + ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );
 		
 		f_cbBuffer = CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) + 1 - ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

        ChkDR( DRM_B64_DecodeA( f_rgchBase,
                    f_pdasstrRevocationList,
                   &f_cbBuffer, 
                    f_pbBuffer, 
                    0 ) );
    }
    else
    {
        ChkDR( DRM_B64_DecodeA( f_rgchBase,
                    f_pdasstrRevocationList,
                   &f_cbBuffer, 
                    f_pbBuffer, 
                    0 ) );
    }

    ChkDR( _UpdateAppRevocationList( f_pcontextCRY,
                f_pcontextSST,
                f_rgbPassword,
                f_pbBuffer,
                f_cbBuffer,
                f_pcontextHDS,
                f_pappcert,
                f_idCRLAppCurrent,
                f_pfUpdatedAppRevocationList ) );


ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_RVK_UpdateAppRevocationListW(
    DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
    DRM_SECSTORE_CONTEXT *f_pcontextSST,
    DRM_BYTE              f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    DRM_BYTE             *f_pbBuffer,
    DRM_DWORD             f_cbBuffer,
    DRM_CONST_STRING     *f_pdstrRevocationList,
    DRM_HDS_CONTEXT      *f_pcontextHDS,
    APPCERT              *f_pappcert,
    DRM_DWORD             f_idCRLAppCurrent,
    DRM_BOOL             *f_pfUpdatedAppRevocationList)
{
    DRM_RESULT            dr              = DRM_SUCCESS;        

    ChkArg(f_pcontextCRY             != NULL
        && f_pcontextSST              != NULL
        && f_rgbPassword              != NULL
        && f_pcontextHDS              != NULL
        && f_pappcert                 != NULL
        && f_cbBuffer                  > 0
        && f_pdstrRevocationList     != NULL );
    

    if (f_pfUpdatedAppRevocationList != NULL)
    {
       *f_pfUpdatedAppRevocationList = FALSE;
    }

    if( f_pbBuffer == NULL )
    {
        /* If they don't pass us a buffer, it's a signal to just decode in place */

        ChkDR( DRM_B64_DecodeW(f_pdstrRevocationList, 
                       &f_cbBuffer, 
                        NULL, 
                        DRM_BASE64_DECODE_IN_PLACE ) );
        
        f_pbBuffer = (DRM_BYTE*)f_pdstrRevocationList->pwszString;
    }
    else
    {
        ChkDR( DRM_B64_DecodeW(f_pdstrRevocationList, 
                       &f_cbBuffer, 
                        f_pbBuffer, 
                        0 ) );
    }
    
    ChkDR( _UpdateAppRevocationList( f_pcontextCRY,
                f_pcontextSST,
                f_rgbPassword,
                f_pbBuffer,
                f_cbBuffer,
                f_pcontextHDS,
                f_pappcert,
                f_idCRLAppCurrent,
                f_pfUpdatedAppRevocationList ) );


ErrorExit:
    return dr;
}

DRM_RESULT _UpdateAppRevocationList(
    DRM_CRYPTO_CONTEXT   *f_pcontextCRY,
    DRM_SECSTORE_CONTEXT *f_pcontextSST,
    DRM_BYTE              f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    DRM_BYTE             *f_pbRevocationList,
    DRM_DWORD             f_cbRevocationList,
    DRM_HDS_CONTEXT      *f_pcontextHDS,
    APPCERT              *f_pappcert,
    DRM_DWORD             f_idCRLAppCurrent,
    DRM_BOOL             *f_pfUpdatedAppRevocationList)
{
    DRM_RESULT            dr              = DRM_SUCCESS;        
    DRM_DWORD             idCRLAppNew     = 0;
    DRM_REVOCATION_LIST  *prevocationlist = NULL;
    DRM_DWORD             cbSigned         = 0;
    DRM_DWORD             dwVersion        = 0;


    ChkArg(f_pcontextCRY != NULL
        && f_pcontextSST != NULL
        && f_rgbPassword != NULL
        && f_pcontextHDS != NULL
        && f_pappcert    != NULL
        && f_pbRevocationList     != NULL
        && f_cbRevocationList > 0 );


    if (f_pfUpdatedAppRevocationList != NULL)
    {
       *f_pfUpdatedAppRevocationList = FALSE;
    }

    prevocationlist = (DRM_REVOCATION_LIST *)  f_pbRevocationList;
    dwVersion           = prevocationlist->dwVersion;
    
    FIX_ENDIAN_DWORD( dwVersion ); 
    
    if (dwVersion != CURRENT_REVOCATION_VERSION)
    {
        ChkDR(DRM_E_NOTIMPL);
    }

    idCRLAppNew = prevocationlist->idSerial;
    FIX_ENDIAN_DWORD( idCRLAppNew );

    if (f_idCRLAppCurrent == DRM_APP_REVOCATION_VERSION_NONE
    ||  f_idCRLAppCurrent  < idCRLAppNew)
    {
        /* Verify & store the new list. */

        cbSigned = prevocationlist->cb;
        FIX_ENDIAN_DWORD(cbSigned);

        cbSigned += ( 3 * SIZEOF( DRM_DWORD ) );

        if (DRM_PK_Verify(f_pcontextCRY, 
                         &g_pubkeyRevocation, 
            (DRM_BYTE *) &prevocationlist->dwVersion,
                          cbSigned,
                          prevocationlist->rgbSignature))
        {
            /* The new list is verified.  Store it. */
            
            ChkDR(DRM_SST_SetData(f_pcontextSST, 
                                 &g_lidAppRevocation, 
                                  NULL,
                                  f_rgbPassword,
                                  SECURE_STORE_REVOCATION_DATA,
                                  f_pcontextHDS, 
                                  f_pbRevocationList, 
                                  f_cbRevocationList));

            if (f_pfUpdatedAppRevocationList != NULL)
            {
                *f_pfUpdatedAppRevocationList = TRUE;
            }                                  
        }

        ChkDR(_CheckCertInRevocationList(CERTTYPE_V1APP,
                        (DRM_BYTE *) &f_pappcert->appcd.pk.pk,
                                SIZEOF (f_pappcert->appcd.pk.pk),
                                        prevocationlist));
    }

ErrorExit:
    return dr;

}
#endif


#if DRM_SUPPORT_REVOCATION
/******************************************************************************
** 
** Function :   DRM_RVK_UpdateRevocationVersionsCache
** 
** Synopsis :   Loads the revinfo and CRL versions from the secure store
**              and caches them in the DRM_MANAGER_CONTEXT for use when
**              evaluting licenses with revocation requirements
**              
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_RVK_UpdateRevocationVersionsCache( 
 IN OUT DRM_MANAGER_CONTEXT_INTERNAL  *f_pContext,
    OUT DRM_BOOL                     *f_pfUpdated)
{
    DRM_RESULT       dr             = DRM_SUCCESS;
    DRM_DWORD        cbBuffer       = 0;
    DRM_RLVI         RLVI;
    DRM_DWORD        dwVersion      = 0;
    DRM_BYTE         rgbPassword [__CB_DECL(SHA_DIGEST_LEN)];

    ChkArg( f_pContext                           != NULL
        &&  f_pContext->fSecStoreGlobalContextOpen );

    MEMSET( &RLVI, 0, SIZEOF( DRM_RLVI ) );
    if( f_pfUpdated != NULL )
    {
        *f_pfUpdated = FALSE;
    }

    cbBuffer = f_pContext->oLicEvalContext.cbRevocationBuffer;
    /* Update the revocation info version */
    ChkDR( DRM_RVK_GetCurrentRevocationInfo( &f_pContext->oSecStoreGlobalContext,
                                           &f_pContext->oBlackBoxContext,
                                           &f_pContext->oHdsContext,
                                            f_pContext->oLicEvalContext.pbRevocationBuffer,
                                           &cbBuffer,
                                           &RLVI ) );


    if( f_pContext->idCRLsCurrent.riv != RLVI.head.dwRIV )
    {
        if( f_pfUpdated != NULL )
        {
            *f_pfUpdated = TRUE;
        }
        f_pContext->idCRLsCurrent.riv = RLVI.head.dwRIV;
    }


#if DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET
    ChkDR(_CreateRevocationStorePassword (&f_pContext->oBlackBoxContext, rgbPassword));
#endif


#if DRM_SUPPORT_DEVICE_REVOCATION
    cbBuffer = f_pContext->oLicEvalContext.cbRevocationBuffer;
    /* Update the device CRL version */
    ChkDR( DRM_RVK_GetDeviceRevocationList(&f_pContext->oBlackBoxContext.CryptoContext,
                                        &f_pContext->oSecStoreGlobalContext,
                                        &f_pContext->oHdsContext,
                                         rgbPassword,
                                         f_pContext->oLicEvalContext.pbRevocationBuffer,
                                        &cbBuffer,
                                        &dwVersion) );


    if( f_pContext->idCRLsCurrent.device != dwVersion )
    {
        if( f_pfUpdated != NULL )
        {
            *f_pfUpdated = TRUE;
        }
        f_pContext->idCRLsCurrent.device = dwVersion;
    }
#endif

#if DRM_SUPPORT_WMDRMNET
    cbBuffer = f_pContext->oLicEvalContext.cbRevocationBuffer;
    /* Update the WMDRMNET CRL version */
    ChkDR( DRM_RVK_GetWMDRMNETList(&f_pContext->oBlackBoxContext.CryptoContext,
                                        &f_pContext->oSecStoreGlobalContext,
                                        &f_pContext->oHdsContext,
                                         rgbPassword,
                                         f_pContext->oLicEvalContext.pbRevocationBuffer,
                                        &cbBuffer,
                                        &dwVersion) );


    if( f_pContext->idCRLsCurrent.wmdrmnet != dwVersion )
    {
        if( f_pfUpdated != NULL )
        {
            *f_pfUpdated = TRUE;
        }
        f_pContext->idCRLsCurrent.wmdrmnet = dwVersion;
    }
#endif

ErrorExit:

    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        dr = DRM_E_REVOCATION_BUFFERTOOSMALL;
    }

    return dr;  
}
#endif /* DRM_SUPPORT_REVOCATION */



#if DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET

/*****************************************************************************
** Function: IsWrappedCRL
**
** Synopsis: Checks if the CRL is wrapped with <DATA> tag or not. Used to find
**           out if the WMDRMNET CRL is with wrappers.
**
** [f_pdstrRevocationList]  -- Revocation list
*****************************************************************************/
static DRM_BOOL IsWrappedCRL( IN DRM_CONST_STRING *f_pdstrRevocationList )
{
    DRM_RESULT       dr       = DRM_SUCCESS;
    DRM_CONST_STRING dstrData = EMPTY_DRM_STRING;    

    /*Check if the revocation list contains <DATA> tag */
    dr = DRM_XML_GetNode( f_pdstrRevocationList,
                          &g_dstrTagData,
                          NULL,
                          NULL,
                          0,
                          NULL,
                          &dstrData );
    if ( dr == DRM_E_XMLNOTFOUND )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

/*****************************************************************************
** Function: _ExtractRevocationListA
**
** Synopsis: calls app revocation operation 
**
** [f_pdstrLicenseXML]      -- entire license response XML 
** [f_pbBuffer]             -- buffer
** [f_pcbBuffer]            -- pointer to buffer size
** [f_pdstrRevocationType]  -- the revocation attribute type
** [f_pdstrAttributeData]   -- on success contains the substring for the given
**                             revocation type
*****************************************************************************/
static DRM_RESULT _ExtractRevocationList(
    IN       DRM_ANSI_CONST_STRING *f_pdastrLicenseResponse,
    IN const DRM_ANSI_CONST_STRING *f_pdastrRevocationType, 
    OUT      DRM_SUBSTRING         *f_pdasstrAttributeData)
{
    DRM_RESULT    dr                      = DRM_SUCCESS;
    DRM_SUBSTRING dasstrLicenseResponse = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrList             = EMPTY_DRM_SUBSTRING;


    ChkArg(f_pdastrLicenseResponse     != NULL
        && f_pdastrRevocationType       != NULL 
        && f_pdasstrAttributeData       != NULL);

    /* get the uppermost license list */
    
    dasstrLicenseResponse.m_ich = 0;
    dasstrLicenseResponse.m_cch = f_pdastrLicenseResponse->cchString;
    
    ChkDR( DRM_XML_GetNodeA( f_pdastrLicenseResponse->pszString,
                             &dasstrLicenseResponse,
                             &g_adstrLicenseRespTag,    
                             NULL, 
                             NULL, 
                             0, 
                             NULL, 
                             &dasstrList ) );

    /* get the node for this revocation type */
                          
    ChkDR( DRM_XML_GetNodeA( f_pdastrLicenseResponse->pszString,
                             &dasstrList,       
                             &g_dastrTagRevocation, 
                             &g_dastrAttributeType, 
                             f_pdastrRevocationType, 
                             0, 
                             NULL,
                             f_pdasstrAttributeData ) );
    
ErrorExit:
    return dr;    
}    

/******************************************************************************
** 
** Function :   _VerifyRevocationList
** 
** Synopsis :   Verify signature on the revocation list
** 
** Arguments :  f_pcontextCRYP  - Crypto context
**              f_pdstrList     - Revocation list
**              f_ppubkey       - Public key for verifying signature on 
**                                revocation list
**              f_pidSerial     - Serial number on revocation list
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT _VerifyRevocationList(
    IN          DRM_CRYPTO_CONTEXT *f_pcontextCRYP, 
    IN          DRM_CONST_STRING   *f_pdstrList,
    IN  const   PUBKEY             *f_ppubkey,
        OUT     DRM_DWORD          *f_pidSerial)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrListData      = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrListSignature = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNodeHashAlg   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNodeSignAlg   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataHashAlg   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataSignature = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataSignAlg   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataIndex     = EMPTY_DRM_STRING;

    /* verify the signature attributes and get the value */

    ChkDR(DRM_XML_GetNode(f_pdstrList,        &g_dstrTagSignature, NULL, NULL, 0,  NULL,            &dstrListSignature));
    ChkDR(DRM_XML_GetNode(&dstrListSignature, &g_dstrTagHashAlg,   NULL, NULL, 0, &dstrNodeHashAlg,  NULL));
    ChkDR(DRM_XML_GetNode(&dstrListSignature, &g_dstrTagSignAlg,   NULL, NULL, 0, &dstrNodeSignAlg,  NULL));
    ChkDR(DRM_XML_GetNode(&dstrListSignature, &g_dstrTagValue,     NULL, NULL, 0,  NULL,            &dstrDataSignature));

    ChkDR(DRM_XML_GetNodeAttribute(&dstrNodeHashAlg, &g_dstrAttributeType, &dstrDataHashAlg));
    ChkDR(DRM_XML_GetNodeAttribute(&dstrNodeSignAlg, &g_dstrAttributeType, &dstrDataSignAlg));

    ChkFAIL(DRM_UTL_DSTRStringsEqual(&dstrDataHashAlg, &g_dstrSHA));
    ChkFAIL(DRM_UTL_DSTRStringsEqual(&dstrDataSignAlg, &g_dstrMSDRM)); 

    /* verify the signature against the <DATA> section */

    ChkDR( DRM_XML_GetAndVerifyNode( f_pdstrList, 
                                     &g_dstrTagData,
                                     NULL,
                                     NULL,
                                     0,
                                     f_pcontextCRYP,
                                     f_ppubkey,
                                     TRUE,
                                     &dstrDataSignature,
                                     NULL,
                                     &dstrListData ) );

    /* verification successful; get the index (version) of this list */

    ChkDR( DRM_XML_GetNode( &dstrListData,            /*    <INDEX> */
                            &g_dstrTagIndex,
                            NULL,
                            NULL,
                            0,
                            NULL,
                            &dstrDataIndex ) );

    ChkDR( wcsntol( dstrDataIndex.pwszString,
                    dstrDataIndex.cchString,
                    (DRM_LONG *) f_pidSerial ) );
#if DRM_SUPPORT_WMDRMNET
    if( MEMCMP( f_ppubkey, &g_pubkeyCardeaRevocation, sizeof( *f_ppubkey ) ) == 0 )
    {
        DRM_CONST_STRING dstrTemplate = EMPTY_DRM_STRING;

        ChkDR( DRM_XML_GetSubNode(  f_pdstrList, 
                                   &g_dstrTemplate, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                    NULL,
                                   &dstrTemplate,
                                    1 ) );

        /*
        ** If this is a WMDRMNET revocation list use the OEM function to 
        ** validate the internal representation of the list
        */

        ChkDR(_VerifyWMDRMNETRevocationList(&dstrTemplate,
                                          f_pidSerial));

    }
#endif
                          
ErrorExit:
    return dr;
} 

/******************************************************************************
** 
** Function :   _GetSSTRevocationList
** 
** Synopsis :   Get and verify revocation list from Secure store
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT _GetSSTRevocationList(
    IN  const   DRM_LID              *f_plid,
    IN          DRM_CRYPTO_CONTEXT   *f_pcontextCRYP, 
    IN          DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN          DRM_HDS_CONTEXT      *f_pcontextHDS,
    IN          DRM_BYTE              f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    IN  const   PUBKEY               *f_ppubkey,
        OUT     DRM_BYTE             *f_pbBuffer,
    IN  OUT     DRM_DWORD            *f_pcbBuffer,
        OUT     DRM_DWORD            *f_pidSerial)
{
    DRM_RESULT dr            = DRM_SUCCESS;        
    DRM_BYTE  *pbAligned     = NULL;
    DRM_DWORD  cbAligned     = 0;                    
    DRM_CONST_STRING dstrXML = EMPTY_DRM_STRING;
        
    ChkArg(f_plid         != NULL  
       &&  f_pcontextCRYP != NULL
       &&  f_pcontextSST  != NULL
       &&  f_rgbPassword  != NULL
       &&  f_ppubkey      != NULL
       &&  f_pcontextHDS  != NULL
       &&  f_pcbBuffer    != NULL);

    *f_pidSerial = DRM_NO_PREVIOUS_CRL;
    
    /* get the current SST image */

    if (f_pbBuffer != NULL)
    {
        ChkDR( DRM_UTL_EnsureDataAlignment( f_pbBuffer, 
                                            *f_pcbBuffer, 
                                            &pbAligned, 
                                            &cbAligned, 
                                            SIZEOF (DRM_WCHAR),
                                            NULL ) );
    }
    
    dr = DRM_SST_GetData( f_pcontextSST, 
                          f_plid, 
                          NULL,
                          f_rgbPassword,
                          SECURE_STORE_GLOBAL_DATA,
                          f_pcontextHDS, 
                          pbAligned, 
                          &cbAligned );    

    *f_pcbBuffer = cbAligned;    

    /* includes the DRM_E_BUFFERTOOSMALL case */

    ChkDR(dr);
    
    DSTR_FROM_PB( &dstrXML, pbAligned, cbAligned );

    /* verify the signature and extract the index of this exclusion list */
    if ( IsWrappedCRL( &dstrXML ) )
    {
        ChkDR( _VerifyRevocationList( f_pcontextCRYP, 
                                      &dstrXML, 
                                      f_ppubkey, 
                                      f_pidSerial ) );    
    }
    else
    {
#if DRM_SUPPORT_WMDRMNET
        ChkDR( _VerifyBinaryWMDRMNETSignature( pbAligned,
                                              cbAligned,
                                              f_pidSerial ) );
#else
        ChkDR( DRM_E_NOTIMPL );
#endif
    }

                                           
ErrorExit:

    return dr;
}

#endif /* #if DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET */

#if DRM_SUPPORT_DEVICE_REVOCATION

/******************************************************************************
** 
** Function :   _UpdateRevocationList
** 
** Synopsis :   updates the revocation list in the secure store
** 
** Arguments :  
** [f_pcontextCrypto]      -- 
** [f_pcontextSST]         -- 
** [f_rgbPasswordSST]      -- created with the BBX hash
** [f_pbRevocationList]    -- input buffer for exclusion list
** [f_cbRevocationList]    -- buffer size
** [f_pdstrRevocationList] -- the new DCRL
** [f_pID]                 -- DRM_ID used to store this list in secure store
** [f_pcontextHDS]         -- initialized HDS context

** Returns :    
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT _UpdateRevocationList(
    IN          DRM_CRYPTO_CONTEXT   *f_pcontextCrypto,
    IN          DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN          DRM_BYTE              f_rgbPassword[__CB_DECL(SHA_DIGEST_LEN)],
    IN          DRM_CHAR             *f_rgchBase,
    IN  const   DRM_SUBSTRING        *f_pdasstrRevocationList,
    IN          DRM_BYTE             *f_pbRevocationBuffer,
    IN          DRM_DWORD             f_cbRevocationBuffer,
    IN  const   DRM_ID               *f_pID,
    IN  const   PUBKEY               *f_ppubkey,
    IN          DRM_HDS_CONTEXT      *f_pcontextHDS )
{
    DRM_RESULT dr          = DRM_SUCCESS;        
    DRM_DWORD  idSerialNew = 0,
               idSerialOld = 0,
               cbDecoded   = 0,
               cbReturned  = 0;
    DRM_BYTE   *pbDecoded  = NULL;
    DRM_STRING dstrRevocationList = EMPTY_DRM_STRING;
    
    ChkArg(   f_pcontextCrypto  != NULL
           && f_pcontextSST      != NULL
           && f_rgbPassword      != NULL
           && f_pID               != NULL
           && f_pcontextHDS      != NULL
           && f_rgchBase            != NULL
           && f_pbRevocationBuffer != NULL
           && f_cbRevocationBuffer > 0
           && f_pdasstrRevocationList != NULL
           && f_pdasstrRevocationList->m_cch > 0 );  



    /* pbOffset will point within the base64 revocation list we were passed,
       such that after base64 decoding the end of the decoded data will co-incide with
       the end of the buffer we were given, minus one byte.

       This is because we are giving the B64 decoder overlapping memory for source and desitination,
       and we can't use the DECODE_IN_PLACE flag because this is ANSI where the offset may not coincide
       with a word boundary as required on 16-bit platforms.
     */
    pbDecoded = (DRM_BYTE*)f_rgchBase
                        + __CB_DECL( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) - 1 )
                        + ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

	cbDecoded = CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) + 1 - ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

    /* decode the XML for the new exclusion list */
    ChkDR( DRM_B64_DecodeA( f_rgchBase,
                            f_pdasstrRevocationList, 
                            &cbDecoded, 
                            pbDecoded, 
                            0 ) );
    DSTR_FROM_PB( &dstrRevocationList, pbDecoded, cbDecoded );

    idSerialNew = DRM_NO_PREVIOUS_CRL;
    idSerialOld = DRM_NO_PREVIOUS_CRL;


    ChkDR( _VerifyRevocationList( f_pcontextCrypto, 
                  (DRM_CONST_STRING*)&dstrRevocationList, 
                                      f_ppubkey,
                                     &idSerialNew ) );

    cbReturned = f_cbRevocationBuffer;    
    /* get and verify the current SST image
     */
    dr = _GetSSTRevocationList( f_pID, 
                                f_pcontextCrypto, 
                                f_pcontextSST,
                                f_pcontextHDS,
                                f_rgbPassword,
                                f_ppubkey,
                                f_pbRevocationBuffer,
                               &cbReturned,
                               &idSerialOld );


    /* This can be the first Revocation list */

    if ( dr == DRM_E_FILENOTFOUND 
        || ( ( idSerialOld == DRM_NO_PREVIOUS_CRL ) && DRM_SUCCEEDED( dr ) )
        || ( ( idSerialOld < idSerialNew ) && DRM_SUCCEEDED( dr ) ) )
    {
        cbReturned = f_cbRevocationBuffer;
        
        /* Store the list as a wrapped CRL */
        ChkDR(DRM_SST_SetData( f_pcontextSST, 
                               f_pID, 
                               NULL,
                               f_rgbPassword,
                               SECURE_STORE_GLOBAL_DATA,
                               f_pcontextHDS, 
                               pbDecoded, 
                               cbDecoded ) );
    }
    else
    {
        ChkDR( dr );    
    }

ErrorExit:
    if( ( f_rgchBase != NULL ) 
        && ( f_pdasstrRevocationList != NULL )
        && ( f_pdasstrRevocationList->m_cch != 0 ) )
    {
        /* Since we decoded in-place, we need to clean up otherwise the XML parsing may
         * not work properly later on. So we have to overwrite our binary with spaces.
         *
         * NOTE: This means that we CANNOT process the same revocation list in the same
         * license response buffer twice since we're overwriting the buffer we were given
         */
        DRM_BYT_SetBytes( f_rgchBase, f_pdasstrRevocationList->m_ich, f_pdasstrRevocationList->m_cch, ' ');
    }
    
    return dr;
} 

/*****************************************************************************
** Function: _UpdateDeviceRevocationList
**
** Synopsis: updates the device exclusion list in the secure store
**
** Arguments:
** [f_pcontextCRYP]        -- just a buffer
** [f_pcontextSST]         -- just a buffer
** [f_rgbPasswordSST]      -- created with the BBX hash
** [f_pbBuffer]            -- input buffer for exclusion list
** [f_cbBuffer]            -- buffer size
** [f_pdstrDeviceRevocationList] -- the new DCRL
** [f_pcontextHDS]         -- initialized* HDS context
*****************************************************************************/
static DRM_RESULT _UpdateDeviceRevocationList(
    IN DRM_CRYPTO_CONTEXT   *f_pcontextCRYP,
    IN DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN DRM_BYTE              f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    IN DRM_CHAR             *f_rgchBase,
    IN DRM_SUBSTRING        *f_pdasstrRevocationList,
    IN DRM_BYTE             *f_pbRevocationBuffer,
    IN DRM_DWORD             f_cbRevocationBuffer,
    IN DRM_HDS_CONTEXT      *f_pcontextHDS )
{
    return _UpdateRevocationList( f_pcontextCRYP,
                                  f_pcontextSST,
                                  f_rgbPassword,
                                  f_rgchBase,
                                  f_pdasstrRevocationList,
                                  f_pbRevocationBuffer,
                                  f_cbRevocationBuffer,
                                  &g_lidDeviceRevocation,
                                  &g_pubkeyDeviceRevocation,
                                  f_pcontextHDS );
} 


/*****************************************************************************
** Function: DRM_RVK_GetDeviceRevocationList
**
** Synopsis: gets the current device exclusion list from the secure store
**
** Arguments:
** [f_pcontextCRYP]      -- just a buffer
** [f_pcontextSST]       -- just a buffer
** [f_pcontextHDS]       -- initialized* HDS context
** [f_rgbPasswordSST]    -- created with the BBX hash
** [f_pbBuffer]          -- output buffer for exclusion list; NULL to request 
**                          required size
** [f_pcbBuffer]         -- DRM_DWORD to hold max buffer size on in, bytes actually 
**                          used on out
** [f_pidSerial]         -- receives numerical representation of <INDEX> tag
*****************************************************************************/
#if DRM_SUPPORT_REVOCATION
DRM_RESULT DRM_API DRM_RVK_GetDeviceRevocationList(
    IN     DRM_CRYPTO_CONTEXT   *f_pcontextCRYP, 
    IN     DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN     DRM_HDS_CONTEXT      *f_pcontextHDS,
    IN     DRM_BYTE              f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    OUT    DRM_BYTE             *f_pbRevocationData,
    IN OUT DRM_DWORD            *f_pcbRevocationData,
    OUT    DRM_DWORD            *f_pidSerial)
{
    DRM_RESULT  dr = DRM_SUCCESS;
    ChkArg(   f_pcontextCRYP        != NULL
           && f_pcontextSST         != NULL
           && f_pcontextHDS         != NULL
           && f_rgbPassword         != NULL
           && f_pcbRevocationData   != NULL
           && f_pidSerial           != NULL );
    
    dr = _GetSSTRevocationList( &g_lidDeviceRevocation, 
                                  f_pcontextCRYP, 
                                  f_pcontextSST,
                                  f_pcontextHDS,
                                  f_rgbPassword,
                                  &g_pubkeyDeviceRevocation,
                                  f_pbRevocationData,
                                  f_pcbRevocationData,
                                  f_pidSerial );
    if ( dr == DRM_E_FILENOTFOUND
      || dr == DRM_E_HDSSLOTNOTFOUND )
    {
        dr                   = DRM_SUCCESS;
        *f_pidSerial         = 0;
        *f_pcbRevocationData = 0;
        goto ErrorExit;
    }
    ChkDR(dr);
    
ErrorExit:
    return dr;
}
#endif /* DRM_SUPPORT_REVOCATION */

/*****************************************************************************
** Function: DRM_RVK_CheckDeviceRevocation
**
** Synopsis: compare a devcert to an exclusion entry and seek a match result
**
** Arguments:
** [f_pdevcert]          -- a DEVICE_CERT struct pointing to the devcert XML
** [f_pdstrXMLExclusion] -- a DSTR pointing to an exclusion list entry with the 
** [f_pfExcluded]        -- pointer to a boolean variable to hold the match
**                          result
** Returns: - DRM_SUCCESS regardless of match 
**          - error code on XML or numerical translation failure
**
** Notes:   TODO: Just take this function out. Leaving it here for now as
**          the overall checkin is becoming too unwieldy
**
*****************************************************************************/
DRM_RESULT DRM_API DRM_RVK_CheckDeviceRevocation(
    IN     DRM_CONST_STRING *f_pdstrdevcert,
    IN     DRM_CONST_STRING *f_pdstrXMLExclusion, 
       OUT DRM_BOOL         *f_pfExcluded)
{
    DRM_RESULT dr       = DRM_SUCCESS;

    ChkArg(f_pfExcluded != NULL);
    ChkDRMString(f_pdstrXMLExclusion);
    ChkDRMString(f_pdstrdevcert);

    *f_pfExcluded = FALSE;

    /* get the devcert XML with the <DATA> tag at the root */
    ChkDR(DRM_XMU_MatchNodeFromTemplate(f_pdstrdevcert,
                                        f_pdstrXMLExclusion,
                                        TRUE,
                                        f_pfExcluded));
    
ErrorExit:          
    return dr;
} 

#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_WMDRMNET 

/******************************************************************************
** 
** Function :   _VerifyWMDRMNETRevocationList
** 
** Synopsis :   Verify signature on the WMDRMNET CRL and return the version
**              of the CRL.
** 
** Arguments :  f_pdstrList     - WMDRMNET Revocation list
**              f_pdwVersion    - Version or Serial number on revocation list
** 
** Returns :    
** 
** Notes :      If the verification fails, the buffer will be filled with
**              spaces to prevent the XML parsing from being confused later
**
******************************************************************************/
static DRM_RESULT _VerifyWMDRMNETRevocationList(
    IN  DRM_CONST_STRING   *f_pdstrList,
    OUT DRM_DWORD          *f_pdwVersion )
{
    DRM_RESULT dr                 = DRM_SUCCESS;
    DRM_DWORD  cbData             = 0;
    DRM_DWORD  cbEncoded         = 0;
    DRM_STRING dstrRevocationData = EMPTY_DRM_STRING;


    ChkArg( f_pdstrList  != NULL 
         && f_pdwVersion != NULL );

       
    DSTR_FROM_PB( &dstrRevocationData, 
                  PB_DSTR( f_pdstrList ), 
                  CB_DSTR( f_pdstrList ) );

    cbData = CB_BASE64_DECODE(dstrRevocationData.cchString);


    ChkDR( DRM_B64_DecodeW( (DRM_CONST_STRING *) &dstrRevocationData, 
                         &cbData, 
                          NULL, 
                          DRM_BASE64_DECODE_IN_PLACE ) );
    
    ChkDR( _VerifyBinaryWMDRMNETSignature( (DRM_BYTE*)dstrRevocationData.pwszString,
                                        cbData,
                                        f_pdwVersion ) );

    cbEncoded = dstrRevocationData.cchString;
    ChkDR( DRM_B64_EncodeW( (DRM_BYTE*)dstrRevocationData.pwszString, 
                         cbData, 
                         dstrRevocationData.pwszString, 
                        &cbEncoded,
                         0 ) );
    
 ErrorExit:

    /*
     * If verification failed, the CRL may be in binary form and could
     * could mess up XML parsing later on, so we overwrite it with spaces.
     */
    if( DRM_FAILED( dr ) )
    {
        DRM_BYT_SetBytes( dstrRevocationData.pwszString, 
                    0, 
                    dstrRevocationData.cchString, 
                    ' ' );
    }
    
    return dr;
} 

/******************************************************************************
** 
** Function :   _UpdateWMDRMNETRevocationList
** 
** Synopsis :   updates the WMDRMNET revocation list in the secure store
** 
** Arguments :  
** [f_pcontextCrypto]      -- 
** [f_pcontextSST]         -- 
** [f_rgbPasswordSST]      -- created with the BBX hash
** [f_pbRevocationList]    -- input buffer for exclusion list
** [f_cbRevocationList]    -- buffer size
** [f_pdstrRevocationList] -- the new DCRL
** [f_pID]                 -- DRM_ID used to store this list in secure store
** [f_pcontextHDS]         -- initialized HDS context

** Returns :    
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT _UpdateWMDRMNETRevocationList(
    IN          DRM_CRYPTO_CONTEXT   *f_pcontextCrypto,
    IN          DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN          DRM_BYTE              f_rgbPassword[__CB_DECL(SHA_DIGEST_LEN)],
    IN          DRM_CHAR             *f_rgchBase,
    IN  const   DRM_SUBSTRING        *f_pdasstrRevocationList,
    IN          DRM_BYTE             *f_pbRevocationBuffer,
    IN          DRM_DWORD             f_cbRevocationBuffer,
    IN  const   DRM_ID               *f_pID,
    IN  const   PUBKEY               *f_ppubkey,
    IN          DRM_HDS_CONTEXT      *f_pcontextHDS )
{
    DRM_RESULT       dr           = DRM_SUCCESS;        
    DRM_DWORD        idSerialNew  = 0,
                     idSerialOld  = 0,
                     cbDecoded    = 0,
                     cbReturned   = 0;
    DRM_BYTE        *pbDecoded   = NULL;
    DRM_CONST_STRING dstrTemplate  = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrList       = EMPTY_DRM_STRING;

    ChkArg(   f_pcontextCrypto   != NULL
           && f_pcontextSST      != NULL
           && f_rgbPassword      != NULL
           && f_pID              != NULL
           && f_pcontextHDS      != NULL
           && f_rgchBase           != NULL
           && f_pbRevocationBuffer != NULL
           && f_cbRevocationBuffer > 0
           && f_pdasstrRevocationList != NULL
           && f_pdasstrRevocationList->m_cch > 0 );  


     /* pbOffset will point within the base64 revocation list we were passed,
       such that after base64 decoding the end of the decoded data will co-incide with
       the end of the buffer we were given, minus one byte.

       This is because we are giving the B64 decoder overlapping memory for source and desitination,
       and we can't use the DECODE_IN_PLACE flag because this is ANSI where the offset may not coincide
       with a word boundary as required on 16-bit platforms.
     */

     pbDecoded = (DRM_BYTE*)f_rgchBase
                        + __CB_DECL( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) - 1 )
                        + ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

	cbDecoded = CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) + 1 - ( ( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch - CB_BASE64_DECODE( f_pdasstrRevocationList->m_cch ) ) % CB_NATIVE_BYTE );

    /* decode the XML for the new exclusion list in place */
    ChkDR( DRM_B64_DecodeA( f_rgchBase,
                            f_pdasstrRevocationList, 
                           &cbDecoded, 
                            pbDecoded, 
                            0 ) );
    DSTR_FROM_PB( &dstrList, pbDecoded, cbDecoded );
    
    idSerialNew = DRM_NO_PREVIOUS_CRL;
    idSerialOld = DRM_NO_PREVIOUS_CRL;
    if ( IsWrappedCRL( &dstrList ) )
    {
        ChkDR( _VerifyRevocationList( f_pcontextCrypto, 
                                     &dstrList, 
                                      f_ppubkey,
                                      &idSerialNew ) );
        
        ChkDR( DRM_XML_GetSubNode( &dstrList, 
                                  &g_dstrTemplate, 
                                   NULL, 
                                   NULL, 
                                   0, 
                                   NULL,
                                  &dstrTemplate,
                                   1 ) );

        /* We will store the unwrapped CRL in decoded form */
        ChkDR( DRM_B64_DecodeW( (const DRM_CONST_STRING*)&dstrTemplate,
                               &cbDecoded,
                               NULL,
                               DRM_BASE64_DECODE_IN_PLACE ) );

        pbDecoded = (DRM_BYTE*)dstrTemplate.pwszString;

    }
    else
    {
        ChkDR( _VerifyBinaryWMDRMNETSignature( pbDecoded,
                                                   cbDecoded,
                                                  &idSerialNew ) );
    }


    cbReturned = f_cbRevocationBuffer;
    /* get and verify the current SST image
     */
    dr = _GetSSTRevocationList( f_pID, 
                                f_pcontextCrypto, 
                                f_pcontextSST,
                                f_pcontextHDS,
                                f_rgbPassword,
                                f_ppubkey,
                                f_pbRevocationBuffer,
                               &cbReturned,
                               &idSerialOld );


    /* This can be the first Revocation list */

    if ( dr == DRM_E_FILENOTFOUND 
        || ( ( idSerialOld == DRM_NO_PREVIOUS_CRL ) && DRM_SUCCEEDED( dr ) )
        || ( ( idSerialOld < idSerialNew ) && DRM_SUCCEEDED( dr ) ) )
    {
        
        /* store the new list. */
        ChkDR( DRM_SST_SetData( f_pcontextSST, 
                               f_pID, 
                               NULL,
                               f_rgbPassword,
                               SECURE_STORE_GLOBAL_DATA,
                               f_pcontextHDS, 
                               pbDecoded, 
                               cbDecoded ) );
    }
    else
    {
        ChkDR( dr );    
    }

ErrorExit:
    if( ( f_rgchBase != NULL ) 
        && ( f_pdasstrRevocationList != NULL )
        && ( f_pdasstrRevocationList->m_cch != 0 ) )
    {
        /* Since we decoded in-place, we need to clean up otherwise the XML parsing may
         * not work properly later on. So we have to overwrite our binary with spaces.
         *
         * NOTE: This means that we CANNOT process the same revocation list in the same
         * license response buffer twice since we're overwriting the buffer we were given
         */
        DRM_BYT_SetBytes( f_rgchBase, f_pdasstrRevocationList->m_ich, f_pdasstrRevocationList->m_cch, ' ');
    }
    return dr;
} 



/*****************************************************************************
** Function: DRM_RVK_GetWMDRMNETList
**
** Synopsis: gets the current link protection list from the secure store
**
** Arguments:
** [f_pcontextCRYP]   -- a buffer
** [f_pcontextSST]    -- a buffer
** [f_pcontextHDS]    -- initialized HDS context
** [f_rgbPasswordSST] -- created with the BBX hash
** [f_pbRevocationData]  -- output buffer for exclusion list; NULL to request
**                       required size
** [f_pcbRevocationData] -- DRM_DWORD to hold max buffer size on in, bytes 
**                       actually used on out
** [f_pidSerial]      -- receives numerical representation of <INDEX> tag
*****************************************************************************/
DRM_RESULT DRM_API DRM_RVK_GetWMDRMNETList(
    IN      DRM_CRYPTO_CONTEXT   *f_pcontextCRYP, 
    IN      DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN      DRM_HDS_CONTEXT      *f_pcontextHDS,
    IN      DRM_BYTE              f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
        OUT DRM_BYTE             *f_pbRevocationData,
    IN  OUT DRM_DWORD            *f_pcbRevocationData,
        OUT DRM_DWORD            *f_pidSerial)
{
    DRM_RESULT          dr = DRM_SUCCESS;

    ChkArg(   f_pcontextCRYP        != NULL
           && f_pcontextSST         != NULL
           && f_pcontextHDS         != NULL
           && f_rgbPassword         != NULL
           && f_pcbRevocationData   != NULL
           && f_pidSerial           != NULL );
    
    dr = _GetSSTRevocationList( &g_lidWMDRMNET_Revocation, 
                                  f_pcontextCRYP, 
                                  f_pcontextSST,
                                  f_pcontextHDS,
                                  f_rgbPassword,
                                  &g_pubkeyCardeaRevocation,
                                  f_pbRevocationData,
                                  f_pcbRevocationData,
                                f_pidSerial );
    if ( dr == DRM_E_FILENOTFOUND
      || dr == DRM_E_HDSSLOTNOTFOUND )
    {
        dr                   = DRM_SUCCESS;
        *f_pidSerial         = 0;
        *f_pcbRevocationData = 0;
        goto ErrorExit;
    }
    ChkDR(dr);
    
ErrorExit:
    return dr;
}

#endif 

#if DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_WMDRMNET || DRM_SUPPORT_REVOCATION || DRM_SUPPORT_APP_REVOCATION

typedef struct _tagRevDispatchEntry
{
    DRM_REVOCATION_TYPE_ENUM        eType;
    const DRM_ANSI_CONST_STRING *pdastrType;
    const DRM_LID               *plid;
    const PUBKEY                *ppubkey;
} REVDISPATCHENTRY;

/* dispatch table for various revocation types */
/* note: remove this conditional and all like it if any revocation types are entered 
         feature-independently
         likewise, extend this conditional and all like it if this list is extended with other 
         feature-dependent revocation types */

REVDISPATCHENTRY g_arevDispatch [] =
{
#if DRM_SUPPORT_APP_REVOCATION
    { WM_DRM_REVOCATION_TYPE_APP,     &g_dastrRevocationGuidApp,      &g_lidAppRevocation,       &g_pubkeyRevocation},
#endif /* DRM_SUPPORT_APP_REVOCATION */

#if DRM_SUPPORT_DEVICE_REVOCATION
    { WM_DRM_REVOCATION_TYPE_WMDRMPD, &g_dastrRevocationGuidDevice,   &g_lidDeviceRevocation,    &g_pubkeyDeviceRevocation},
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_WMDRMNET
    { WM_DRM_REVOCATION_TYPE_WMDRMND, &g_dastrRevocationGuidWMDRMNET, &g_lidWMDRMNET_Revocation, &g_pubkeyCardeaRevocation},
#endif /* DRM_SUPPORT_WMDRMNET */
};

#endif

    /*
    // The CRL has the following format:
    //
    // +--------------------+------------------------------------------+
    // | SECTIONS           | FIELDS                                   |
    // +--------------------+------------------------------------------+
    // | Header             | 32-bit CRL Version                       |
    // |                    +------------------------------------------+
    // |                    | 32-bit Number of Entries                 |
    // +--------------------+------------------------------------------+
    // | Revocation Entries | Multiple 160-bit Revocation Entries      |
    // +--------------------+------------------------------------------+
    // | Certificate        | 32-bit Certificate Length                |
    // |                    +------------------------------------------+
    // |                    | Variable Length Certificate              |
    // +--------------------+------------------------------------------+
    // | Signature          | 8-bit Signature Type                     |
    // |                    +------------------------------------------+
    // |                    | 16-bit Signature Length                  |
    // |                    +------------------------------------------+
    // |                    | Variable Length Signature                |
    // +--------------------+------------------------------------------+
    */


#if DRM_SUPPORT_REVOCATION
/**********************************************************************
**
** Function:    _VerifyCRLSignature
**
** Synopsis:    Verifies the CRL signature.
**
** Arguments:    
**              [f_pbSignedBytes]        - Specifies the bytes that are signed
**              [f_cbSignedBytes]        - Specifies the size of the signed bytes
**              [f_pbSignature]          - Specifies the signature
**              [f_cbSignature]          - Specifies the size signature
**              [f_pbCertificate]        - Specifies the certificate chain used to find signing key
**              [f_cbCertificate]        - Specifies the size certificate chain used to find signing key
**
** Returns:     DRM_SUCCESS if the signature is valid
**              DRM_XMLNOTFOUND if unable to locate signing key
**              passes return codes from other failures up to caller
**
**********************************************************************/
DRM_RESULT DRM_API _VerifyCRLSignature (DRM_BYTE  *f_pbSignedBytes,
                                              DRM_DWORD     f_cbSignedBytes,
                                              DRM_BYTE     *f_pbSignature,
                                              DRM_DWORD     f_cbSignature,
                                              DRM_SUBSTRING f_dasstrCertificate)
{
    DRM_RESULT          dr = DRM_SUCCESS;
    DRM_RSA_PUBLIC_KEY *pPubKey = NULL;
    DRM_SUBSTRING       dasstrSignedBytes;
    

    dasstrSignedBytes.m_ich = 0;
    dasstrSignedBytes.m_cch = f_cbSignedBytes;

    /* validate certificate chain */
    dr = _ValidateCertificate( (DRM_CHAR *) f_pbSignedBytes, f_dasstrCertificate, NULL );
    if( DRM_FAILED(dr) )
    {
        TRACE(( "_VerifyCRLSignature: Invalid Certificate\n" ));
        ChkDR( dr );
    }

    /* find certificate that signed CRL */
    {
        DRM_SUBSTRING       dasstrCollection = f_dasstrCertificate;
        DRM_SUBSTRING       dasstrData = EMPTY_DRM_SUBSTRING;
        DRM_DWORD           cNodes;
        DRM_DWORD           iNode;


        ChkDR( DRM_XML_GetNodeA( (const DRM_CHAR *) f_pbSignedBytes, &dasstrCollection, &g_dastrTagCertificateCollection, NULL, NULL, 0, NULL, &dasstrData ));

        /* enumerate c:Certificate nodes */

        ChkDR(DRM_XML_CountMatchingNodesA( (const DRM_CHAR *) f_pbSignedBytes,
                                        &dasstrData,
                                        &g_dastrTagWMDRMCertificate,
                                        NULL,
                                        NULL,
                                        &cNodes));

        ChkArg(cNodes >= 1
            && cNodes <= DRM_CERTIFICATE_COLLECTION_MAX);

        for (iNode = 0; iNode < cNodes; iNode++)
        {
            DRM_SUBSTRING dasstrCertificate = EMPTY_DRM_STRING;
            DRM_SUBSTRING dasstrTag         = EMPTY_DRM_STRING;
            DRM_SUBSTRING rgdasstrAttrs [3]   = { 0 };
            DRM_DWORD     cAttrEntries        = NO_OF(rgdasstrAttrs);
            DRM_DWORD     iAttr;

            ChkDR(DRM_XML_EnumNextNodeA( (const DRM_CHAR *) f_pbSignedBytes,
                                        &dasstrData,
                                         iNode,
                                        &dasstrTag,
                                        &dasstrCertificate,
                                         NULL,
                                         NULL,
                                         NULL));

            /* there should be nothing but <c:Certificate>s in <CertificateCollection> */

            ChkArg(DRM_UTL_DASSTRStringsEqual( (const DRM_CHAR *) f_pbSignedBytes,
                                              &dasstrTag,
                                              &g_dastrTagWMDRMCertificate));

            /* Check if cert signed CRL, and if so, get public key */
            ChkDR( DRM_WCP_GetAttribute( (const DRM_CHAR *) f_pbSignedBytes,
                                        &dasstrCertificate,
                                         DRM_WMDRM_CERT_ATTR_KEY_USAGE,
                                         rgdasstrAttrs,
                                        &cAttrEntries ) );

            for( iAttr = 0; iAttr < cAttrEntries ; iAttr++ )
            {
                if( DRM_UTL_DASSTRStringsEqual( (const DRM_CHAR *) f_pbSignedBytes, rgdasstrAttrs + iAttr, &g_dastrKeyUsageSignCRL ) )
                {
                    DRM_DWORD cbDestination;
                    DRM_DWORD dwExponent = 0;
                    DRM_BYTE  rgbExponent[4];
                    DRM_BYTE  rgbModulus [__CB_DECL(DRM_CB_RSA_PUBLIC_MOD_1024 * 2 + 8)] = { 0 };

                    cAttrEntries = 3;
                    ChkDR( DRM_WCP_GetAttribute( (const DRM_CHAR *) f_pbSignedBytes,
                                                &dasstrCertificate,
                                                 DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SELF_RSA,
                                                 rgdasstrAttrs,
                                                &cAttrEntries ) );

                    /*
                    *  Decode Exponent
                    */
                    cbDestination = 4;
                    ChkDR( DRM_B64_DecodeA( (const DRM_CHAR *) f_pbSignedBytes,
                                            rgdasstrAttrs,
                                           &cbDestination,
                                            rgbExponent,
                                            0 ) );
                    PUT_BYTE( rgbExponent, 3, GET_BYTE( rgbExponent, 2 ) );
                    PUT_BYTE( rgbExponent, 2, GET_BYTE( rgbExponent, 1 ) );
                    PUT_BYTE( rgbExponent, 1, GET_BYTE( rgbExponent, 0 ) );
                    PUT_BYTE( rgbExponent, 0, 0 );
                    NETWORKBYTES_TO_DWORD( dwExponent, rgbExponent, 0 );


                    /*
                    *  Decode Modulus
                    */
                    cbDestination = SIZEOF(rgbModulus);
                    ChkDR( DRM_B64_DecodeA( (const DRM_CHAR *) f_pbSignedBytes,
                                            rgdasstrAttrs + 1,
                                           &cbDestination,
                                            rgbModulus,
                                            0 ) );

                    ChkDR( OEM_DrmRsaSetPublicKey( dwExponent, rgbModulus, cbDestination, &pPubKey ) );

                    break;
                }
            }

            if( pPubKey != NULL )
            {
                break;
            }
        }

        if( pPubKey == NULL )
        {
            TRACE(( "_VerifyCRLSignature: Couldn't find public key for CRL signer\n" ));
            ChkDR( DRM_E_XMLNOTFOUND );
        }
    }


    dr = DrmRsaVerify( (DRM_CHAR*) f_pbSignedBytes, &dasstrSignedBytes, pPubKey, f_pbSignature, f_cbSignature );
    
    if( DRM_FAILED(dr) )
    {
        TRACE(( "_VerifyCRLSignature: Signature Invalid\n" ));
        ChkDR( dr );
    }

ErrorExit:

    if ( pPubKey != NULL )
    {
        OEM_DrmRsaReleaseKey( pPubKey );
    }

    return dr;
}
#endif

#if DRM_SUPPORT_WMDRMNET
static DRM_RESULT DRM_API _VerifyBinaryWMDRMNETSignature(
    IN     DRM_BYTE  *f_pbData,
    IN     DRM_DWORD  f_cbData,
    IN OUT DRM_DWORD *f_pidSerial)
{
    DRM_RESULT          dr              = DRM_SUCCESS;
    DRM_BYTE            bSignatureType  = 0;
    DRM_DWORD           cEntries        = 0;
    DRM_UINT64          cbEntries       = DRM_UI64HL(0, 0);
    DRM_DWORD           cbSigned        = 0;
    DRM_DWORD           dwVersion       = 0;
    DRM_SUBSTRING       dasstrCertificate = EMPTY_DRM_SUBSTRING;
    DRM_DWORD           cbData          = f_cbData;
    DRM_DWORD           ibData          = 0;
    DRM_WORD           cbSignature      = 0;
#if SIXTEEN_BIT_ADDRESSING
    DRM_BYTE            rgbSignature[ __CB_DECL( WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1 ) ];
#endif

    /*
    ** Get the CRL Version
    */

    ChkArg(f_cbData >= SIZEOF(DRM_DWORD));

    NETWORKBYTES_TO_DWORD( dwVersion, f_pbData, 0 );
    cbSigned += SIZEOF(DRM_DWORD);
    ibData   += SIZEOF(DRM_DWORD);
    cbData   -= SIZEOF(DRM_DWORD);

    /* if the expected version number is given it must match, otherwise its' a query */

    if (*f_pidSerial != DRM_NO_PREVIOUS_CRL)
    {
        ChkArg(dwVersion == *f_pidSerial);
    }
    else
    {
        *f_pidSerial = dwVersion;
    }

    /*
    ** Get the number of entries
    */
    ChkArg(cbData >= SIZEOF(DRM_DWORD));

    NETWORKBYTES_TO_DWORD( cEntries, f_pbData, ibData );
    cbSigned += SIZEOF(DRM_DWORD);
    ibData   += SIZEOF(DRM_DWORD);
    cbData   -= SIZEOF(DRM_DWORD);

    /*
    ** Get the size of the entries
    ** 
    */
    cbEntries = DRM_UI64Mul(DRM_UI64HL( 0, cEntries ), DRM_UI64HL( 0, SIZEOF(WMDRMNET_CRL_ENTRY) ));

    ChkArg(cbData >= DRM_UI64Low32(cbEntries)); /* use qword to prevent arithmetic overflows */


    cbSigned += SIZEOF(WMDRMNET_CRL_ENTRY) * cEntries;
    ibData   += SIZEOF(WMDRMNET_CRL_ENTRY) * cEntries;
    cbData   -= SIZEOF(WMDRMNET_CRL_ENTRY) * cEntries;

    /*
    ** Get the certificate length
    */

    ChkArg(cbData >= SIZEOF(DRM_DWORD));

    NETWORKBYTES_TO_DWORD( dasstrCertificate.m_cch, f_pbData, ibData );

    cbSigned += SIZEOF(DRM_DWORD);
    ibData   += SIZEOF(DRM_DWORD);
    cbData   -= SIZEOF(DRM_DWORD);

    ChkArg(dasstrCertificate.m_cch > 0);

    /*
    ** Get the certificate.  we don't need to copy it, just update
    ** our byte offset to point to the right location.
    */

    ChkArg(cbData >= dasstrCertificate.m_cch);
    dasstrCertificate.m_ich = ibData;


    cbSigned += dasstrCertificate.m_cch;
    ibData   += dasstrCertificate.m_cch;
    cbData   -= dasstrCertificate.m_cch;

    /*
    ** Get the signature type
    */

    ChkArg(cbData >= SIZEOF(DRM_BYTE));

    bSignatureType = GET_BYTE( f_pbData, ibData );

    ibData++;
    cbData--;

    ChkArg( bSignatureType == WMDRMNET_CRL_SIGNATURE_TYPE_RSA_SHA1 );

    /*
    ** get the signature length
    */

    ChkArg(cbData >= SIZEOF(DRM_WORD));

    NETWORKBYTES_TO_WORD( cbSignature, f_pbData, ibData );
    ibData += SIZEOF(DRM_WORD);
    cbData -= SIZEOF(DRM_WORD);

    ChkArg( cbSignature == WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1 );

    /*
    ** get the signature and validate it
    */
    ChkArg(cbData >= WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1);

#if SIXTEEN_BIT_ADDRESSING
    DRM_BYT_CopyBytes( rgbSignature, 
                      0, 
                      f_pbData, 
                      ibData, 
                      WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1 );

    dr = _VerifyCRLSignature( f_pbData,
                            cbSigned,
                            rgbSignature,
                            WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1, 
                            dasstrCertificate );
#else
    dr = _VerifyCRLSignature( f_pbData,
                            cbSigned,
                            f_pbData + ibData,
                            WMDRMNET_CRL_SIGNATURE_LEN_RSA_SHA1, 
                            dasstrCertificate );
#endif

    if (DRM_FAILED(dr))
    {
        ChkDR(DRM_E_INVALID_SIGNATURE);
    }

ErrorExit:

    return dr;
}

#endif

/**********************************************************************
**
** Function:    _ValidateCertificate
**
** Synopsis:    Validates the device certificate. Optionally returns WMDRM-ND certificate
**
** Arguments:
**              [f_rgchDeviceCertificate]     - Specifies the device certificate
**              [f_cbDeviceCertificate]       - Specifies the size (in bytes) of the Device Certificate
**              [f_pdasstrWMDRMNDCertificate] - Optional, can be NULL.  If not NULL, returns the
**                                              DRM_SUBSTRING pointing to the WMDRM-ND certificate
**
** Returns:     DRM_SUCCESS on success or
**              DRM_E_INVALIDARG if any of the arguments are invalid
**
**********************************************************************/
#if DRM_SUPPORT_REVOCATION
DRM_RESULT
_ValidateCertificate(
    IN DRM_CHAR          *f_rgchBase,
    IN DRM_SUBSTRING      f_dasstrCertificate,
    IN OUT DRM_SUBSTRING *f_pdasstrWMDRMNDCertificate
    )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_rgchBase );

    if (DRM_FAILED( DRM_WCP_VerifyCertificateCollection(
                             f_rgchBase,
                            &f_dasstrCertificate,
                             DRM_DSIG_TYPE_WMDRMNET,
                            &g_dastrMSRootPubKey,
                             NULL,
                             0,
                             f_pdasstrWMDRMNDCertificate,
                             NULL ) ) )
    {
        ChkDR(DRM_E_INVALIDDEVICECERTIFICATE);
    }

ErrorExit:
    return dr;
}
#endif

/******************************************************************************
**
** Function :   _VerifyRevocationInfo
**
** Synopsis :   Verify signature on the revocation info
**
** Arguments :  f_pbRevInfo  - rev info buffer (already b64 decoded)
**              f_pcbRevInfo - size of rev info buffer
** Returns :
**
** Notes :
**
******************************************************************************/
#if DRM_SUPPORT_REVOCATION
static DRM_RESULT _VerifyRevocationInfo(
    IN          DRM_BYTE           *f_pbRevInfo,
    IN          DRM_DWORD           f_cbRevInfo,
    OUT         DRM_RLVI           *f_pRLVI)
{
    DRM_RESULT      dr 		= DRM_SUCCESS;
    DRM_DWORD       cbRevInfo 	= f_cbRevInfo;
    DRM_DWORD       cbSignedBytes   = 0;
    DRM_DWORD       cbEntries        = 0;
    DRM_DWORD	    ibRevInfo 	      = 0;
    DRM_SUBSTRING   dasstrCertificate = EMPTY_DRM_SUBSTRING;
#if SIXTEEN_BIT_ADDRESSING
    DRM_BYTE        rgbSignature[ __CB_DECL( RLVI_SIGNATURE_SIZE ) ];
#endif

    ChkArg( f_pbRevInfo != NULL
          && f_pRLVI     != NULL );
    ChkArg( SIZEOF( DRM_RLVI_HEAD ) <= f_cbRevInfo );
    
    MEMSET( f_pRLVI, 0, SIZEOF( DRM_RLVI ) );
    
    /* ID */
    NETWORKBYTES_TO_DWORD( f_pRLVI->head.dwID, f_pbRevInfo, ibRevInfo );
    ChkArg( RLVI_MAGIC_NUM == f_pRLVI->head.dwID );
    ibRevInfo += SIZEOF( DRM_DWORD );

    /* Length */
    NETWORKBYTES_TO_DWORD( f_pRLVI->head.cbSignedBytes, f_pbRevInfo, ibRevInfo );
    ChkArg( SIZEOF( DRM_RLVI_HEAD ) <= f_pRLVI->head.cbSignedBytes );
    ibRevInfo += SIZEOF( DRM_DWORD );
    
    /* Format Version */
    f_pRLVI->head.bFormatVersion = GET_BYTE( f_pbRevInfo, ibRevInfo );
    ChkArg( RLVI_FORMAT_VERSION == f_pRLVI->head.bFormatVersion );
    ibRevInfo += SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE;
    
    /* Reserved */
    f_pRLVI->head.bReserved[0] = GET_BYTE( f_pbRevInfo, ibRevInfo );
    ibRevInfo += SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE;
    f_pRLVI->head.bReserved[1] = GET_BYTE( f_pbRevInfo, ibRevInfo );
    ibRevInfo += SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE;
    f_pRLVI->head.bReserved[2] = GET_BYTE( f_pbRevInfo, ibRevInfo );
    ibRevInfo += SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE;

    /* Sequence Nubmer */
    NETWORKBYTES_TO_DWORD( f_pRLVI->head.dwRIV, f_pbRevInfo, ibRevInfo );
    ibRevInfo += SIZEOF( DRM_DWORD );

    /* Issued Time: not stored in network byte order */
    /* NETWORKBYTES_TO_QWORD( f_pRLVI->head.ftIssuedTime, pbRevInfo, 0 ); */
    ibRevInfo += SIZEOF( DRMFILETIME );

    /* Entry Count */
    NETWORKBYTES_TO_DWORD( f_pRLVI->head.dwRecordCount, f_pbRevInfo, ibRevInfo );
    ibRevInfo += SIZEOF( DRM_DWORD );
    
    /* Entries */
    cbEntries = SIZEOF( DRM_RLVI_RECORD ) * f_pRLVI->head.dwRecordCount;
    ChkArg( f_cbRevInfo - ibRevInfo >= cbEntries + ( SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE ) + RLVI_SIGNATURE_SIZE + SIZEOF( DRM_DWORD ) );
    f_pRLVI->ibEntries = ibRevInfo;
    ibRevInfo += cbEntries;
    
    cbSignedBytes = ibRevInfo;
    
    /* Signature Type */
    f_pRLVI->signature.bSignatureType = GET_BYTE( f_pbRevInfo, ibRevInfo );
    ibRevInfo += SIZEOF(DRM_BYTE) / CB_NATIVE_BYTE;
    ChkArg( RLVI_SIGNATURE_TYPE == f_pRLVI->signature.bSignatureType );
    ChkArg( RLVI_SIGNATURE_SIZE + SIZEOF(DRM_DWORD) <= (cbRevInfo - ibRevInfo) );
    
    /* Signature */
    f_pRLVI->signature.ibSignature = ibRevInfo;
#if SIXTEEN_BIT_ADDRESSING
    DRM_BYT_CopyBytes( rgbSignature, 0, f_pbRevInfo, ibRevInfo, RLVI_SIGNATURE_SIZE );
#endif
    ibRevInfo += RLVI_SIGNATURE_SIZE;
    
    
    /* Certificate Chain Length */
    NETWORKBYTES_TO_DWORD( f_pRLVI->certchain.cbCertChain, f_pbRevInfo, ibRevInfo );
    ibRevInfo += SIZEOF( DRM_DWORD );
    
    /* Certificate Chain */
    ChkArg( f_cbRevInfo - ibRevInfo >= f_pRLVI->certchain.cbCertChain );
    f_pRLVI->certchain.ibCertChain = ibRevInfo;
    ibRevInfo += f_pRLVI->certchain.cbCertChain;

    /* Verify Signature */

    dasstrCertificate.m_ich = f_pRLVI->certchain.ibCertChain;
    dasstrCertificate.m_cch = f_pRLVI->certchain.cbCertChain;

#if SIXTEEN_BIT_ADDRESSING
    ChkDR( _VerifyCRLSignature(f_pbRevInfo,
                                  cbSignedBytes,
                                  rgbSignature,
                                  RLVI_SIGNATURE_SIZE,
                                  dasstrCertificate ) );
#else
    ChkDR( _VerifyCRLSignature(f_pbRevInfo,
                                  cbSignedBytes,
                                  f_pbRevInfo + f_pRLVI->signature.ibSignature,
                                  RLVI_SIGNATURE_SIZE,
                                  dasstrCertificate ) );
#endif

 ErrorExit:
    
    return dr;
}
#endif

/*****************************************************************************
** Function: DRM_RVK_GetCurrentRevocationInfo
**
** Synopsis: gets the current device exclusion list from the secure store
**
** Arguments:
** [f_pcontextSST]       -- just a buffer
** [f_pcontextHDS]       -- initialized* HDS context
** [f_rgbPasswordSST]    -- created with the BBX hash
** [f_pbBuffer]          -- output buffer for exclusion list; NULL to request 
**                          required size
** [f_pcbBuffer]         -- DRM_DWORD to hold max buffer size on in, bytes actually 
**                          used on out
*****************************************************************************/
#if DRM_SUPPORT_REVOCATION
DRM_RESULT DRM_API DRM_RVK_GetCurrentRevocationInfo(
    IN     DRM_SECSTORE_CONTEXT *f_pContextSST,
    IN     DRM_BB_CONTEXT       *f_pContextBB,
    IN     DRM_HDS_CONTEXT      *f_pContextHDS,
       OUT DRM_BYTE             *f_pbBuffer,
    IN OUT DRM_DWORD            *f_pcbBuffer,
       OUT DRM_RLVI             *f_pRLVI)
{

    DRM_RESULT                    dr        = DRM_SUCCESS;
    DRM_BYTE                      rgbPassword [__CB_DECL(SHA_DIGEST_LEN)] = { 0x00 };

    ChkArg ( f_pRLVI != NULL 
        &&   f_pContextSST != NULL
        &&   f_pContextHDS != NULL
        &&   f_pContextBB  != NULL );

    ChkDR( DRM_SST_CreateGlobalStorePassword( rgbPassword, (DRM_BYTE *) f_pContextBB ) );

    ChkDR( DRM_SST_OpenKeyTokens( f_pContextSST, 
                                  (DRM_ID *) &g_rgbSecStoreGlobalName, 
                                  NULL,
                                  rgbPassword, 
                                  DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS,
                                  SECURE_STORE_GLOBAL_DATA, 
                                  f_pContextHDS ) );

    ChkDR( _CreateRevocationStorePassword( f_pContextBB, rgbPassword ) );
    
    dr = DRM_SST_GetData(f_pContextSST,  
                         &g_lidRevocationInfo,
                         NULL,
                         rgbPassword,
                         SECURE_STORE_GLOBAL_DATA,
                         f_pContextHDS, 
                         f_pbBuffer, 
                         f_pcbBuffer);
    if ( dr == DRM_E_FILENOTFOUND
      || dr == DRM_E_HDSSLOTNOTFOUND )
    {
        /* if there's no revocation info current stored, fake out the RIV so the new info can be stored */
        MEMSET( f_pRLVI, 0, SIZEOF( DRM_RLVI ) );
        f_pRLVI->head.dwRIV = 0;
        *f_pcbBuffer = 0;
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }
    ChkDR(dr);

    /* decode the revocation info */

    ChkDR( _VerifyRevocationInfo(f_pbBuffer, *f_pcbBuffer, f_pRLVI) );
    
ErrorExit:
    if ( f_pContextSST && f_pContextHDS )
    {
        f_pContextSST->fInited = TRUE;
        DRM_SST_CloseKey( f_pContextSST, f_pContextHDS );
    }

    return dr;
}


/*****************************************************************************
** Function: DRM_RVK_ProcessRevocationInfo
**
** Synopsis: 
** processes the revocation info struct from the license response and updates
** the revinfo and revocations stored on the device if necessary
**
** Arguments:
** [f_pDrmContext]          -- DRM context
** [f_pdastrLicenseResponse]-- license response XML string
*****************************************************************************/

DRM_RESULT DRM_API DRM_RVK_ProcessRevocationInfo (
    IN DRM_LICEVAL_CONTEXT   *f_pContextLEVL,
    IN DRM_HDS_CONTEXT       *f_pContextHDS,
    IN DRM_SECSTORE_CONTEXT  *f_pContextSST,
    IN DRM_BB_CONTEXT        *f_pContextBB,
    IN DRM_ANSI_CONST_STRING *f_pdastrLicenseResponse)
{
    DRM_RESULT     dr = DRM_SUCCESS;
    DRM_BYTE       rgbPassword [__CB_DECL(SHA_DIGEST_LEN)]  = { 0x00 };
    DRM_BYTE      *pbLicenseResponse;
    DRM_SUBSTRING  dasstrLicenseResponse                    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING  dasstrDataWithoutTags                    = EMPTY_DRM_SUBSTRING;
    DRM_BYTE      *pbNewRevocationInfo                      = NULL;
    DRM_DWORD      cbNewRevocationInfo                      = 0;
    DRM_RLVI       newRLVI;
    DRM_RLVI       currentRLVI;
    DRM_DWORD      iRev;
    DRM_SUBSTRING  dasstrRevocationList                     = EMPTY_DRM_SUBSTRING;
    DRM_DWORD      cbTmp                                    = 0;
    DRM_BOOL       fAllVersionsMatch                        = FALSE;


    MEMSET( &newRLVI,       0, SIZEOF( DRM_RLVI ) );
    MEMSET( &currentRLVI,   0, SIZEOF( DRM_RLVI ) );

    ChkArg( f_pdastrLicenseResponse            != NULL
         && f_pdastrLicenseResponse->pszString != NULL
         && f_pdastrLicenseResponse->cchString != 0 
         && f_pContextLEVL != NULL
         && f_pContextHDS  != NULL 
         && f_pContextSST  != NULL
         && f_pContextBB   != NULL);

    pbLicenseResponse = (DRM_BYTE*)f_pdastrLicenseResponse->pszString;
    dasstrLicenseResponse.m_cch = f_pdastrLicenseResponse->cchString;

    ChkDR( DRM_SST_CreateGlobalStorePassword( rgbPassword, (DRM_BYTE *) f_pContextBB ) );
        
    ChkDR( DRM_SST_OpenKeyTokens( f_pContextSST, 
                                  (DRM_ID *) &g_rgbSecStoreGlobalName, 
                                  NULL,
                                  rgbPassword, 
                                  DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS,
                                  SECURE_STORE_GLOBAL_DATA, 
                                  f_pContextHDS ) );
        
    ChkDR( _CreateRevocationStorePassword( f_pContextBB, rgbPassword ) );

    /* foreach revocation type we care about, get it out of the license response, and store if the version is newer */
    for (iRev = 0; iRev < NO_OF(g_arevDispatch); iRev++)
    {
        dr = _ExtractRevocationList( f_pdastrLicenseResponse, 
                                     g_arevDispatch [iRev].pdastrType, 
                                     &dasstrRevocationList );

        if ( DRM_E_XMLNOTFOUND == dr )
        {
            dr = DRM_SUCCESS;
            continue;
        }
        ChkDR(dr);
        
        switch ( g_arevDispatch[iRev].eType )
        {
#if DRM_SUPPORT_APP_REVOCATION
        case WM_DRM_REVOCATION_TYPE_APP:
            ChkDR( DRM_RVK_UpdateAppRevocationListA( &f_pContextBB->CryptoContext, 
                                                     f_pContextSST,
                                                     rgbPassword,
                                                     f_pContextLEVL->pbRevocationBuffer,
                                                     f_pContextLEVL->cbRevocationBuffer,
                                          (DRM_CHAR*)f_pdastrLicenseResponse->pszString,
                                                    &dasstrRevocationList,
                                                     f_pContextHDS,
                                                    &f_pContextLEVL->appcert,
                                                     f_pContextLEVL->idCRLsCurrent.app,
                                                    &f_pContextLEVL->fUpdatedRevocationList ) );
            break;
#endif /* DRM_SUPPORT_APP_REVOCATION */

#if DRM_SUPPORT_DEVICE_REVOCATION
        case WM_DRM_REVOCATION_TYPE_WMDRMPD:
            ChkDR( _UpdateRevocationList( &f_pContextBB->CryptoContext, 
                                          f_pContextSST,
                                          rgbPassword,
                               (DRM_CHAR*)f_pdastrLicenseResponse->pszString,
                                         &dasstrRevocationList,
                                          f_pContextLEVL->pbRevocationBuffer,
                                          f_pContextLEVL->cbRevocationBuffer,
                                          g_arevDispatch[iRev].plid,
                                          g_arevDispatch[iRev].ppubkey,
                                          f_pContextHDS ) );
            break;
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */
#if DRM_SUPPORT_WMDRMNET
        case WM_DRM_REVOCATION_TYPE_WMDRMND:
            ChkDR( _UpdateWMDRMNETRevocationList( 
                                          &f_pContextBB->CryptoContext, 
                                          f_pContextSST,
                                          rgbPassword,
                               (DRM_CHAR*)f_pdastrLicenseResponse->pszString,
                                         &dasstrRevocationList,
                                          f_pContextLEVL->pbRevocationBuffer,
                                          f_pContextLEVL->cbRevocationBuffer,
                                          g_arevDispatch[iRev].plid,
                                          g_arevDispatch[iRev].ppubkey,
                                          f_pContextHDS ) );

            break;
#endif /* DRM_SUPPORT_WMDRMNET */
        default:
            ChkDR(DRM_E_INVALIDARG);
            break;
        }
    }

    /* 
      Process the revocation info struct from the license response after the  
      CRLs in the license response if present are processed.
    */
    
    dr = DRM_XML_GetSubNodeA((DRM_CHAR*)pbLicenseResponse,
                            &dasstrLicenseResponse,
                            &g_dastrTagRevocationInfo, 
                             NULL, 
                             NULL, 
                             0, 
                             NULL,
                            &dasstrDataWithoutTags, 
                             1);
    if ( DRM_E_XMLNOTFOUND == dr )
    {
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }
    ChkDR(dr);

     /* pbOffset will point within the base64 revocation list we were passed,
       such that after base64 decoding the end of the decoded data will co-incide with
       the end of the buffer we were given, minus one byte.

       This is because we are giving the B64 decoder overlapping memory for source and desitination,
       and we can't use the DECODE_IN_PLACE flag because this is ANSI where the offset may not coincide
       with a word boundary as required on 16-bit platforms.
     */

    pbNewRevocationInfo = pbLicenseResponse
                        + __CB_DECL( dasstrDataWithoutTags.m_ich + dasstrDataWithoutTags.m_cch - CB_BASE64_DECODE( dasstrDataWithoutTags.m_cch ) - 1 )
                        + ( ( dasstrDataWithoutTags.m_ich + dasstrDataWithoutTags.m_cch - CB_BASE64_DECODE( dasstrDataWithoutTags.m_cch ) ) % CB_NATIVE_BYTE );

	cbNewRevocationInfo = CB_BASE64_DECODE( dasstrDataWithoutTags.m_cch ) + 1 - ( ( dasstrDataWithoutTags.m_ich + dasstrDataWithoutTags.m_cch - CB_BASE64_DECODE( dasstrDataWithoutTags.m_cch ) ) % CB_NATIVE_BYTE );


    /* decode the XML for the new revocation info in place */
    ChkDR( DRM_B64_DecodeA( (const DRM_CHAR*)pbLicenseResponse,
                           &dasstrDataWithoutTags, 
                           &cbNewRevocationInfo, 
                            pbNewRevocationInfo, 
                            0 ) );


    /* Verify the one from the license response is a good one */
    ChkDR( _VerifyRevocationInfo(pbNewRevocationInfo, cbNewRevocationInfo, &newRLVI) );

    /* Now get the one store in the data store */
    cbTmp = f_pContextLEVL->cbRevocationBuffer;
    ChkDR( DRM_RVK_GetCurrentRevocationInfo( f_pContextSST,
                                           f_pContextBB,
                                           f_pContextHDS,
                                           f_pContextLEVL->pbRevocationBuffer, 
                                          &cbTmp, 
                                          &currentRLVI ) );

    /* 
       Compare the indivudual CRL versions in the Rev Info to the ones in the
       store and store only if the versions in the store >= those in Rev Info.
    */

    for ( iRev = 0; iRev < newRLVI.head.dwRecordCount; iRev++ )
    {
        DRM_INT64  qwrlviVersion;
        DRM_DWORD  dwrlviVersion = 0;
        DRM_GUID   rlviGUID;
        DRM_DWORD  crlVersion = 0;

        NETWORKBYTES_TO_QWORD( qwrlviVersion, 
                        pbNewRevocationInfo, 
                        newRLVI.ibEntries + ( iRev * SIZEOF( DRM_RLVI_RECORD ) ) + SIZEOF( DRM_GUID ) ); 

        dwrlviVersion = DRM_I64ToUI32(qwrlviVersion);
        DRM_BYT_CopyBytes( &rlviGUID,
                        0,
                        pbNewRevocationInfo,
                        newRLVI.ibEntries + ( iRev * SIZEOF( DRM_RLVI_RECORD ) ),
                        SIZEOF(DRM_GUID) );
        
        FIX_ENDIAN_DWORD( rlviGUID.Data1 );
        FIX_ENDIAN_WORD( rlviGUID.Data2 );
        FIX_ENDIAN_WORD( rlviGUID.Data3 );

        cbTmp = f_pContextLEVL->cbRevocationBuffer;

#if DRM_SUPPORT_APP_REVOCATION
        if ( 0 == MEMCMP(&rlviGUID, &g_guidRevocationTypeApp, SIZEOF(DRM_GUID)) )
        {
            ChkDR( DRM_RVK_GetCurrentAppRevocationList(f_pContextSST,
                                                     rgbPassword,
                                                     f_pContextLEVL->pbRevocationBuffer,
                                                    &cbTmp,
                                                     f_pContextHDS,
                                                    &crlVersion) );

            if( f_pContextLEVL->idCRLsCurrent.app != crlVersion )
            {
                f_pContextLEVL->idCRLsCurrent.app = crlVersion;
                f_pContextLEVL->fUpdatedRevocationList = TRUE;
            }
            
            if ( crlVersion >= dwrlviVersion )
            {
                fAllVersionsMatch = TRUE;
            }
            else
            {
                fAllVersionsMatch = FALSE;
                break;
            }
        }
#endif /* DRM_SUPPORT_APP_REVOCATION */

#if DRM_SUPPORT_DEVICE_REVOCATION
        if ( 0 == MEMCMP(&rlviGUID, &g_guidRevocationTypeDevice, SIZEOF(DRM_GUID)) )
        {
            ChkDR( DRM_RVK_GetDeviceRevocationList(&f_pContextBB->CryptoContext,
                                                 f_pContextSST,
                                                 f_pContextHDS,
                                                 rgbPassword,
                                                 f_pContextLEVL->pbRevocationBuffer,
                                                &cbTmp,
                                                &crlVersion) );

            if( f_pContextLEVL->idCRLsCurrent.device != crlVersion )
            {
                f_pContextLEVL->idCRLsCurrent.device = crlVersion;
                f_pContextLEVL->fUpdatedRevocationList = TRUE;
            }

            if ( crlVersion >= dwrlviVersion )
            {
                fAllVersionsMatch = TRUE;
                f_pContextLEVL->fUpdatedRevocationList = TRUE;
            }
            else
            {
                fAllVersionsMatch = FALSE;
                break;
            }
        }
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_WMDRMNET
        if ( 0 == MEMCMP(&rlviGUID, &g_guidRevocationTypeWMDRMNET, SIZEOF(DRM_GUID)) )
        {
            ChkDR( DRM_RVK_GetWMDRMNETList(&f_pContextBB->CryptoContext,
                                         f_pContextSST,
                                         f_pContextHDS,
                                         rgbPassword,
                                         f_pContextLEVL->pbRevocationBuffer,
                                        &cbTmp,
                                        &crlVersion) );

            if( f_pContextLEVL->idCRLsCurrent.wmdrmnet != crlVersion )
            {
                f_pContextLEVL->idCRLsCurrent.wmdrmnet = crlVersion;
                f_pContextLEVL->fUpdatedRevocationList = TRUE;
            }

            if ( crlVersion >= dwrlviVersion )
            {
                fAllVersionsMatch = TRUE;
                f_pContextLEVL->fUpdatedRevocationList = TRUE;
            }
            else
            {
                fAllVersionsMatch = FALSE;
                break;
            }
        }
#endif /* DRM_SUPPORT_WMDRMNET */
    }
    /* If each stored version matches the corresponding rlvi version, then store the rlvi */
    if ( TRUE == fAllVersionsMatch && newRLVI.head.dwRIV > currentRLVI.head.dwRIV )
    {
        /* Storing binary revocation info */
        ChkDR( DRM_SST_SetData( f_pContextSST,
                                &g_lidRevocationInfo, 
                                NULL,
                                rgbPassword,
                                SECURE_STORE_GLOBAL_DATA,
                                f_pContextHDS, 
                                pbNewRevocationInfo,
                                cbNewRevocationInfo ) );
    }
    
ErrorExit:

    if( ( dasstrDataWithoutTags.m_cch != 0 )
        && ( f_pdastrLicenseResponse != NULL )
        && ( f_pdastrLicenseResponse->pszString != NULL ))
    {
        /* Since we decoded in-place, we need to clean up otherwise the XML parsing may
         * not work properly later on. So we have to overwrite our binary with spaces.
         *
         * NOTE: This means that we CANNOT process the same revocation list in the same
         * license response buffer twice since we're overwriting the buffer we were given
         */
        DRM_BYT_SetBytes( (DRM_BYTE*)f_pdastrLicenseResponse->pszString, dasstrDataWithoutTags.m_ich, dasstrDataWithoutTags.m_cch, ' ');
    }

    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        dr = DRM_E_REVOCATION_BUFFERTOOSMALL;
    }

    return dr;    
}
#endif /* DRM_SUPPORT_REVOCATION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmrsaex.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef _DRMRSAEX_H_
#define _DRMRSAEX_H_

#ifdef  __cplusplus
extern "C"
{
#endif

#define DRM_RSA_ENC_CIPHERTEXT_LEN 128

DRM_RESULT DRM_API DrmRsaOaepDecrypt(
    IN DRM_RSA_PRIVATE_KEY *pPrivateKey,
    IN DRM_BYTE            *pbCiphertext,
    IN    DRM_DWORD            cbCiphertext,
    OUT   DRM_BYTE           **ppbPlaintext,
    OUT   DRM_DWORD           *pcbPlaintext );

DRM_RESULT DRM_API DrmRsaOaepEncrypt(
    IN DRM_RSA_PUBLIC_KEY *pPublicKey,
    IN DRM_BYTE           *pbPlaintext,
    IN       DRM_DWORD           cbPlaintext,
    OUT   DRM_BYTE          **ppbCiphertext,
    OUT   DRM_DWORD          *pcbCiphertext );

DRM_RESULT DRM_API DrmRsaSign(
       IN                                  DRM_RSA_PRIVATE_KEY *f_pkeyPrivate,
       IN                                  DRM_BYTE            *f_pbData,
       IN                                  DRM_SUBSTRING       *f_pdasstr, 
       OUT                   DRM_BYTE            **f_ppbSignature,
       OUT                                 DRM_DWORD           *f_pcbSignature);

DRM_RESULT DRM_API DrmRsaVerify(
    IN const DRM_CHAR           *f_pszBase,
    IN       DRM_SUBSTRING      *f_pdasstrData,
    IN       DRM_RSA_PUBLIC_KEY *f_ppubkey,
    IN const DRM_BYTE           *f_pbSignature,
    IN const DRM_DWORD           f_cbSignature); /* = key modulus length */

#ifdef  __cplusplus
}
#endif

#endif /* _DRMRSAEX_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmsecureclockstatus.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSECURECLOCKSTATUS_H__
#define __DRMSECURECLOCKSTATUS_H__

#ifdef __cplusplus
extern "C" {
#endif

#define DRM_CLK_NOT_SET 0
#define DRM_CLK_SET 1
#define DRM_CLK_NEEDS_REFRESH 2


#ifdef __cplusplus
}
#endif

#endif /*__DRMSECURECLOCKSTATUS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmsecureclock.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSECURECLOCK_H__
#define __DRMSECURECLOCK_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct __tagDRM_SECSTORE_CLOCK_DATA
{
    DRM_TID        tid;
    DRM_DWORD      fInGracePeriod; /*Used as a BOOL. DWORD for compatibility*/
    DRM_UINT64     LastKnownGoodSecureClock;
    DRM_UINT64     LastKnownRealtimeSecureClock;
    DRM_UINT64     LastKnownGracePeriodStartTime;
    DRM_UINT64     RefreshDate;
    DRM_UINT64     ChallengeTime;
    DRM_DWORD      flag; /*One bit for each member. Starting from TID. For data validity*/
} DRM_SECSTORE_CLOCK_DATA;

#define CLK_TID_VALID           0x00000001
#define CLK_IN_GP_VALID         0x00000002
#define CLK_LK_GSC_VALID        0x00000004
#define CLK_LK_RSC_VALID        0x00000008
#define CLK_LK_GP_VALID         0x00000010
#define CLK_REFRESHDATE_VALID   0x00000020
#define CLK_CHALLENGETIME_VALID 0x00000040
#define CLK_EVER_SET            0x00000080

DRM_VOID _PrepareSecureClockDataForWriting( DRM_SECSTORE_CLOCK_DATA *pData );
#define _PrepareSecureClockDataForReading _PrepareSecureClockDataForWriting

/* pseudo-hashes to read/write Data in the secure store */

extern const DRM_ID g_idSData;
extern const DRM_ID g_idSDataPrev;


/**********************************************************************
** Function:    DRM_CLK_CreateChallenge
** Synopsis:    Creates a Secure Clock challenge.
** Arguments:   
**              [pdstrURL] -- pointer to DevCert struct
**              [rgbSecStoreInPswd] -- Secure store password
**              [pContext] -- pointer to DRM_CRYPTO_CONTEXT
**              [poHdsContext] -- pointer to HDS_CONTEXT
**              [poSecureStoreContext] -- pointer to Secure Store context
**              [pwszUrl] -- user allocated buffer to get URL in WCHAR
**              [pcchUrl] -- character count of pwszUrl. Can be NULL if URL is not required.
**              [pbData] -- user allocated buffer to be used as output buffer
**              [pcbData] -- size of pbData
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL
** Notes:       To get the minimum size required, first call with pbData=NULL and
**              pcbData points to value 0. This will return DRM_E_BUFFERTOOSMALL 
**              and pcbData will point to a value of minimum context size.
***********************************************************************/
DRM_RESULT DRM_API DRM_CLK_CreateChallenge(
    IN const DRM_CONST_STRING        *pdstrURL,
    IN const DRM_BYTE                 rgbSecStoreInPswd [__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_CRYPTO_CONTEXT      *pContext, 
    IN       DRM_HDS_CONTEXT         *poHdsContext,
    IN       DRM_SECSTORE_CONTEXT    *poSecureStoreContext,
    OUT      DRM_WCHAR               *pwszUrl,
    IN OUT   DRM_DWORD               *pcchUrl,
    IN       DRM_BYTE                *pbData,
    IN OUT   DRM_DWORD               *pcbData );


/**********************************************************************
** Function:    DRM_CLK_ProcessResponse
** Synopsis:    Process Secure clock request response received from server
** Arguments:   [pDevCert] -- pointer to DevCert struct
**              [pbResponse] -- Response string received from server
**              [cbResponse] -- size of pbResponse in bytes.
**              [rgbSecStoreInPswd] -- Secure store password
**              [pResult] --pointer to DRM_RESULT to get error from server included in response
**              [pContext] --pointer to the DRM_CRYPTO_CONTEXT
**              [poHdsContext] -- pointer to HDS_CONTEXT
**              [poSecureStoreContext] -- pointer to Secure Store context
**              [poLicEvalContext] -- pointer to LICEVAL_CONTEXT
** Returns:     DRM_SUCCESS on success, or failed with 
**              DRM_E_INVALIDARG,
**              CLK_INVALID_RESPONSE, and
**              error codes from Licesne store.
**
***********************************************************************/
DRM_RESULT DRM_API DRM_CLK_ProcessResponse(
    IN const PUBKEY                *ppubkeySecureClockServer,
    IN       DRM_BYTE              *pbResponse,
    IN       DRM_DWORD              cbResponse,
    IN const DRM_BYTE               rgbSecStoreInPswd [__CB_DECL(SHA_DIGEST_LEN)],
    OUT      DRM_RESULT            *pResult,
    IN       DRM_CRYPTO_CONTEXT    *pContext,
    IN       DRM_HDS_CONTEXT       *poHdsContext,
    IN       DRM_SECSTORE_CONTEXT  *poSecureStoreContext,
    IN       DRM_LICEVAL_CONTEXT   *poLicEvalContext );

/**********************************************************************
** Function:    DRM_CLK_GetSecureClock
** Synopsis:    Gets Secure clock.
** Arguments:   
**              [poSecureTime] -- pointer to WCHAR buffer to get Secure time 
**              [pcchSecureTime] -- size of buffer in WCHAR
**              [pdwFlags] -- pointer to DWORD. 0 not set, 1 set, 2 need refresh
**              [pbSecureTimeWithStatus] -- pointer to BYTE buffer to get Secure time and flag status in XML format. Optional 
**              [pcbSecureTimeWithStatus] -- size of buffer. Optioanl
**              [rgbSecStoreInPswd] -- Secure store password
**              [pContext] -- pointer to DRM_CRYPTO_CONTEXT
**              [poHdsContext] -- pointer to HDS_CONTEXT
**              [poSecureStoreContext] -- pointer to Secure Store context
** Returns:     DRM_SUCCESS on success. 
***********************************************************************/
DRM_RESULT DRM_API DRM_CLK_GetSecureClock(
    OUT      DRM_WCHAR            *pwszSecureTime,
    IN OUT   DRM_DWORD            *pcchSecureTime, 
    OUT      DRM_DWORD            *pdwFlags,
    IN       DRM_BYTE             *pbSecureTimeWithStatus,
    IN OUT   DRM_DWORD            *pcbSecureTimeWithStatus, 
    IN const DRM_BYTE              rgbSecStoreInPswd [__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_CRYPTO_CONTEXT   *pContext,
    IN       DRM_HDS_CONTEXT      *poHdsContext,
    IN       DRM_SECSTORE_CONTEXT *poSecureStoreContext);


/**********************************************************************
** Function:    DRM_CLK_InitCheckSecureClock
** Synopsis:    Initializes and checks Secure clock. Called by DRM_Manager_Init
** Arguments:   
**              [rgbSecStoreInPswd] -- Secure store password
**              [pContext] -- pointer to DRM_CRYPTO_CONTEXT
**              [poHdsContext] -- pointer to HDS_CONTEXT
**              [pfClockset] -- pointer to DRM_BOOL to know whether clock is set.
**              [poSecureStoreContext] -- pointer to Secure Store context
**              [poLicEvalContext] -- pointer to LICEVAL_CONTEXT
** Returns:     DRM_SUCCESS on success. 
***********************************************************************/
DRM_RESULT DRM_API DRM_CLK_InitCheckSecureClock(
    IN const DRM_BYTE              rgbSecStoreInPswd [__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_CRYPTO_CONTEXT   *pContext,
    IN       DRM_HDS_CONTEXT      *poHdsContext,
    IN OUT   DRM_BOOL             *pfClockset,
    IN       DRM_SECSTORE_CONTEXT *poSecureStoreContext,
    IN       DRM_LICEVAL_CONTEXT  *poLicEvalContext );

#ifdef __cplusplus
}
#endif

#endif /*__DRMSECURECLOCK_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmsecstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmsecurestore.h>
#include <drmhmac.h>
#include <oemimpl.h>

/*
    A secure store entry in the HDS will look like this:
    4 bytes -- type of entry ( see type enum )
    20 bytes -- hmac of data with password
    n bytes of data
    The decrypted data will contain attributes name/value pairs like so:
    DRM_WORD ( length in bytes of the attribute name )
    n bytes of name
    TOKEN - 12 bytes
    --- Next attribute
*/

static const DRM_HDS_NAMESPACE SEC_STORE_NAMESPACE                 = { TWO_BYTES('s', 'e'),  TWO_BYTES('c', 'u'),  TWO_BYTES('r', 'e'),  TWO_BYTES('s', 't'),  TWO_BYTES('o', 'r'),  TWO_BYTES('e', '\0') };
static const DRM_HDS_NAMESPACE METER_STORE_NAMESPACE               = { TWO_BYTES('m', 'e'),  TWO_BYTES('t', 'e'),  TWO_BYTES('r', 'i'),  TWO_BYTES('n', 'g'),  TWO_BYTES('s', 't'),  TWO_BYTES('o', 'r'),   TWO_BYTES('e', '\0') };
static const DRM_HDS_NAMESPACE DEVICE_REGISTRATION_STORE_NAMESPACE = { TWO_BYTES('d', 'e'),  TWO_BYTES('v', 'i'),  TWO_BYTES('c', 'e'),  TWO_BYTES('r', 'e'),  TWO_BYTES('g', 's'),  TWO_BYTES('t', 'o'),   TWO_BYTES('r', 'e')  };
static const DRM_HDS_NAMESPACE PLAYLIST_BURN_STORE_NAMESPACE       = { TWO_BYTES('p', 'l'),  TWO_BYTES('a', 'y'),  TWO_BYTES('l', 'i'),  TWO_BYTES('s', 't'),  TWO_BYTES('b', 'u'),  TWO_BYTES('r', 'n'),   TWO_BYTES('s', 't'),   TWO_BYTES('r', '\0') };


/* In the slot meta data if the high bit is set it is raw data.  Otherwise it is TOKEN data */
#define DRM_SST_RAW_DATA             0x80000000
#define DRM_SST_SLOT_SIZE_MASK       0x3FFF0000
#define DRM_SST_SLOT_SIZE_VALID_MASK 0x40000000
#define DRM_SST_PREALLOCATE_SIZE     500
#define DRM_SST_SLOT_DATA_MASK       0x7FFFFF00
#define DRM_SST_SLOT_VERSION_MASK    0x0000FF00
#define DRM_SST_SLOT_VERSION         0x00000100

#define DRM_SST_SET_SLOT_SIZE_IN_METADATA( dwMetaData, cbSlotData ) \
        {                                                           \
                dwMetaData &= ~DRM_SST_SLOT_SIZE_MASK;              \
                dwMetaData |= (cbSlotData << 16)                    \
                           |  DRM_SST_SLOT_SIZE_VALID_MASK;         \
        }
#define DRM_SST_SET_SLOT_METADATA( dwMetaData )         \
        {                                                           \
                dwMetaData &= ~DRM_SST_SLOT_DATA_MASK;              \
                dwMetaData |= DRM_SST_SLOT_VERSION                  \
                           |  DRM_SST_SLOT_SIZE_VALID_MASK;         \
        }

#define DRM_SST_GET_SLOT_SIZE_FROM_METADATA( cbSlotData, dwMetaData ) cbSlotData = (dwMetaData & DRM_SST_SLOT_SIZE_MASK) >> 16;           

DRM_VOID _PrepareTokenForWrite( TOKEN *pToken )
{
    DRMASSERT( pToken != NULL );

    switch( pToken->TokenType )
    {
    case TOKEN_LONG:
        FIX_ENDIAN_DWORD( pToken->val.lValue );
        break;
    case TOKEN_DATETIME:
        FIX_ENDIAN_QWORD( pToken->val.u64DateTime );
        break;
    }
    FIX_ENDIAN_DWORD( pToken->TokenType );
}


DRM_VOID _PrepareTokenForRead( TOKEN *pToken )
{
    DRMASSERT( pToken != NULL );

    FIX_ENDIAN_DWORD( pToken->TokenType );
    switch( pToken->TokenType )
    {
    case TOKEN_LONG:
        FIX_ENDIAN_DWORD( pToken->val.lValue );
        break;
    case TOKEN_DATETIME:
        FIX_ENDIAN_QWORD( pToken->val.u64DateTime );
        break;
    }
}

/*******************************************************************
 *          PRIVATE FUNCTION _LoadAttributesIntoCache
 *
 * purpose: scan through an entire slot that has been cached and populate an
 *          array of the data for easy manipulation later
 *
 * assumptions:  the data will be in this format
 * |2 |  cb  | Token | 
 * |cb| Name | Value | 
 ******************************************************************/

static DRM_RESULT _LoadAttributesIntoCache(
    IN const DRM_BYTE        *pbSlotData,
    IN       DRM_DWORD        cbSlotData,
       OUT   CachedAttribute  rgAttributes[DRM_MAX_ATTRIBUTES_PER_SST_KEY],
       OUT   DRM_WORD        *pwNumAttributes)
{
    DRM_RESULT dr    = DRM_SUCCESS;

    DRMASSERT( pwNumAttributes != NULL );

    /* This assert ensures that when we write tokens to disk they are align on boundaries that
       are compatible with the DRM_WCHAR alignment.  If they aren't most processors could have a 
       alignment fault later when we access the strings */
    DRMCASSERT( ( SIZEOF( TOKEN ) % SIZEOF( DRM_WCHAR ) ) == 0 );
    for( *pwNumAttributes = 0; 
         ( *pwNumAttributes <DRM_MAX_ATTRIBUTES_PER_SST_KEY ) && ( cbSlotData > 0 );
         (*pwNumAttributes)++ )
    {
        DRM_WORD cbString = 0;
        
        if( cbSlotData < SIZEOF( DRM_WORD ) )
        {
            /* Absolutely too small */
            dr = DRM_E_SECURESTORE_CORRUPT;
            goto ErrorExit;
        }
        MEMCPY( &cbString, pbSlotData, SIZEOF( cbString ) );
        FIX_ENDIAN_WORD( cbString );
        pbSlotData += __CB_DECL(SIZEOF( DRM_WORD ));
        cbSlotData -= SIZEOF( DRM_WORD );

        if( cbSlotData < cbString + SIZEOF( TOKEN ) )
        {
            /* There are not enough bytes left in the slot to finish this token out */
            dr = DRM_E_SECURESTORE_CORRUPT;
            goto ErrorExit;
        }

        DSTR_FROM_PB( &rgAttributes[*pwNumAttributes].dstrAttribute, pbSlotData, cbString );

        pbSlotData += __CB_DECL(cbString);
        cbSlotData -= cbString;
        
        rgAttributes[*pwNumAttributes].pTokenValue = (TOKEN*)pbSlotData;
        pbSlotData += __CB_DECL(SIZEOF( TOKEN ));
        cbSlotData -= SIZEOF( TOKEN );

        ZEROMEM( &rgAttributes[*pwNumAttributes].TokenDelta, SIZEOF( rgAttributes[*pwNumAttributes].TokenDelta ) );
        rgAttributes[*pwNumAttributes].dwFlags = 0;
    }    

ErrorExit:
    return dr;
}

static DRM_RESULT _VerifySlotHash( 
    IN OUT   DRM_SECSTORE_CONTEXT *pcontextSST,
    IN       DRM_BOOL              fRaw,
    IN const DRM_BYTE              rgbPassword [__CB_DECL(SHA_DIGEST_LEN)] )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    DRM_BYTE    *pbSlotHash     = NULL;
    DRM_BYTE    *pbBuffer       = NULL;
    DRM_BYTE rgbVerifiedHash [__CB_DECL(SHA_DIGEST_LEN)];
    DRM_DWORD    cbBuffer       = 0;
    DRM_DWORD    cbHeader       = 0;
    HMAC_CONTEXT oHmacContext;

    cbHeader = ( pcontextSST->dwSlotVersion == 0 )
             ? DRM_SST_SLOT_V0_HEADER_SIZE
             : DRM_SST_SLOT_HEADER_SIZE;
    pbBuffer = pcontextSST->rgbSlotData + __CB_DECL( cbHeader ); 
    /* If it is a raw slot the min-header has been loaded.
       Other wise the whole slot has been cached already */
    ChkDR( DRM_HMAC_Init( &oHmacContext, rgbPassword, SHA_DIGEST_LEN ) );

    if( fRaw )
    {
        DRM_DWORD cbRead = 0;
        DRM_DWORD cbSlot = pcontextSST->cbSlotData - cbHeader;
            
        cbBuffer = SIZEOF( pcontextSST->rgbSlotData ) - cbHeader;
        while( cbSlot > 0 )
        {
            DRM_DWORD cbToRead = min( cbBuffer, cbSlot );

            ChkDR( DRM_HDS_SlotRead( &pcontextSST->oSlotContext, cbToRead, pbBuffer, &cbRead ) );    
            if( cbToRead != cbRead )
            {
                dr = DRM_E_FILEREADERROR;
                goto ErrorExit;
            }
            ChkDR( DRM_HMAC_Update( &oHmacContext, pbBuffer, cbRead ) );
            cbSlot -= cbRead;
        }
    }
    else
    {
        cbBuffer = pcontextSST->cbSlotData  - cbHeader;
        ChkDR( DRM_HMAC_Update( &oHmacContext, pbBuffer, cbBuffer ) );
    }

    ChkDR( DRM_HMAC_Finalize( &oHmacContext, rgbVerifiedHash, SHA_DIGEST_LEN ) );

    pbSlotHash = ( pcontextSST->dwSlotVersion == 0 )
               ? ( pcontextSST->rgbSlotData + __CB_DECL(DRM_SST_SLOT_V0_HASH_OFFSET) )
               : ( pcontextSST->rgbSlotData + __CB_DECL(DRM_SST_SLOT_HASH_OFFSET) );
    if( 0 != MEMCMP( pbSlotHash, rgbVerifiedHash, SHA_DIGEST_LEN ) )
    {
        dr = DRM_E_INVALID_SECURESTORE_PASSWORD;
        goto ErrorExit;
    }

ErrorExit:
    return dr;
}


static DRM_RESULT _InitSlot(
    IN OUT   DRM_SECSTORE_CONTEXT  *pcontextSST,
    IN       DRM_BOOL               fRaw,
    IN       eDRM_SECURE_STORE_TYPE eType,
    IN const DRM_BYTE               rgbPassword[__CB_DECL(SHA_DIGEST_LEN)])
{
    DRM_DWORD    dwSlotMetaData = eType;
    DRM_RESULT   dr        = DRM_SUCCESS;
    DRM_DWORD    cbWritten = 0;
    DRM_DWORD    cbToWrite = 0;
    HMAC_CONTEXT hmac;

    if ( fRaw )
    {
        dwSlotMetaData |= DRM_SST_RAW_DATA;
    }

    /*  Set the slot version    */
    pcontextSST->dwSlotVersion = DRM_SST_SLOT_VERSION;
    
    /* Secure store section was just created.  Add the Initial hash */
    ChkDR(DRM_HMAC_Init(&hmac, rgbPassword, SHA_DIGEST_LEN));
    ChkDR(DRM_HMAC_Finalize(&hmac, pcontextSST->rgbSlotData + __CB_DECL( DRM_SST_SLOT_HASH_OFFSET), SHA_DIGEST_LEN));

    DRM_SST_SET_SLOT_METADATA(dwSlotMetaData);
    DWORD_TO_BYTES(pcontextSST->rgbSlotData, dwSlotMetaData);
    DWORD_TO_BYTES(pcontextSST->rgbSlotData + __CB_DECL( SIZEOF( dwSlotMetaData)), pcontextSST->cbSlotData);

    cbToWrite = SIZEOF(dwSlotMetaData)
              + SIZEOF(pcontextSST->cbSlotData)
              + SHA_DIGEST_LEN;

    ChkDR(DRM_HDS_SlotSeek(&pcontextSST->oSlotContext, 0, eDRM_HDS_SEEKSET,NULL));
    ChkDR(DRM_HDS_SlotWrite(&pcontextSST->oSlotContext, cbToWrite, pcontextSST->rgbSlotData, &cbWritten));
    if ( cbWritten != cbToWrite )
    {
        dr = DRM_E_FILEWRITEERROR;
        goto ErrorExit;
    }
#if !_DATASTORE_WRITE_THRU
    ChkDR( DRM_HDS_CommitNamespace(&pcontextSST->oNsContext) );
#endif

ErrorExit:
    return dr;
}


static DRM_RESULT _LoadSlot(
    IN OUT   DRM_SECSTORE_CONTEXT  *pcontextSST,
    IN       DRM_BOOL               fRaw,
    IN       eDRM_SECURE_STORE_TYPE eType,
    IN const DRM_BYTE               rgbPassword[__CB_DECL(SHA_DIGEST_LEN)])
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_DWORD  cbRead    = 0;
    DRM_DWORD  cbToRead  = 0;
    DRM_DWORD  dwSlotMetaData = 0;

    /* A secure store slot is never this small.  Somethings wrong */
    ChkBOOL(pcontextSST->cbSlot >= DRM_SST_SLOT_V0_HEADER_SIZE, DRM_E_SECURESTORE_CORRUPT);
   
    if ( fRaw )
    {
        cbToRead = DRM_SST_SLOT_V0_HEADER_SIZE;
    }        
    else
    {
        ChkBOOL((pcontextSST->cbSlot <= SIZEOF(pcontextSST->rgbSlotData)), DRM_E_SECURESTORE_FULL);
        cbToRead = pcontextSST->cbSlot;
    }
    
    ChkDR( DRM_HDS_SlotRead( &pcontextSST->oSlotContext, cbToRead, pcontextSST->rgbSlotData, &cbRead ) );
    ChkBOOL(cbToRead == cbRead, DRM_E_FILEREADERROR);
    
    /*
    **  First check the version number
    */
    BYTES_TO_DWORD( dwSlotMetaData, pcontextSST->rgbSlotData );
    pcontextSST->dwSlotVersion = dwSlotMetaData & DRM_SST_SLOT_VERSION_MASK;
    if ( pcontextSST->dwSlotVersion == 0 )
    {            
        if ( (DRM_SST_SLOT_SIZE_VALID_MASK & dwSlotMetaData) != 0 )
        {
            DRM_SST_GET_SLOT_SIZE_FROM_METADATA(pcontextSST->cbSlotData, dwSlotMetaData);
        }
        dwSlotMetaData &= ~DRM_SST_SLOT_SIZE_MASK;  
    }
    else 
    {  
        if ( fRaw )
        {
            /*
            **  We need to read one more DWORD. This DWORD is just the last
            **  DWORD of the hash. We haven't read it yet because we first 
            **  read just DRM_SST_SLOT_V0_HEADER_SIZE amount of data from
            **  the beginning of the slot.
            */
            ChkDR( DRM_HDS_SlotRead( &pcontextSST->oSlotContext, 
                                     DRM_SST_SLOT_SIZEDATA_SIZE, 
                                     pcontextSST->rgbSlotData + __CB_DECL( DRM_SST_SLOT_V0_HEADER_SIZE ), 
                                     &cbRead ) );
            ChkBOOL(cbRead == DRM_SST_SLOT_SIZEDATA_SIZE, DRM_E_FILEREADERROR);
        }
        BYTES_TO_DWORD( pcontextSST->cbSlotData, 
                        pcontextSST->rgbSlotData + __CB_DECL( DRM_SST_SLOT_METADATA_SIZE ) );            
    }
    
    if ( (DRM_SST_SLOT_SIZE_VALID_MASK & dwSlotMetaData) == 0 )
    {            
        pcontextSST->cbSlotData = pcontextSST->cbSlot;
    }  
    else
    {
        dwSlotMetaData &= ~((DRM_DWORD)DRM_SST_SLOT_SIZE_VALID_MASK);
    }
    
    dwSlotMetaData &= ~((DRM_DWORD)DRM_SST_SLOT_VERSION_MASK);
    
    ChkBOOL(pcontextSST->cbSlotData <= pcontextSST->cbSlot, DRM_E_SECURESTORE_CORRUPT);
    if ( fRaw )
    {
        ChkBOOL((dwSlotMetaData == (((DRM_DWORD)eType)|((DRM_DWORD)DRM_SST_RAW_DATA))), DRM_E_SECURESTORE_CORRUPT);
    }
    else
    {
        ChkBOOL((dwSlotMetaData == (DRM_DWORD)eType), DRM_E_SECURESTORE_CORRUPT);
    }       
    
    dr = _VerifySlotHash(pcontextSST, fRaw, rgbPassword);

ErrorExit:

    return dr;
}
static DRM_RESULT _OpenAndVerifySlot( 
    IN OUT DRM_SECSTORE_CONTEXT    *pcontextSST,
    IN     DRM_HDS_CONTEXT         *pcontextHDS,
    const  DRM_BYTE                 rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    IN     eDRM_SECURE_STORE_TYPE   eType,
    IN     DRM_BOOL                 fRaw,
    IN     DRM_BOOL                 fCreate )
{
    DRM_RESULT dr              = DRM_SUCCESS;
    DRM_BOOL   fCloseNamespace = FALSE,
               fCloseSlot      = FALSE,
               fCreated        = FALSE;
    DRM_DWORD  dwSlotMetaData  = eType;
    DRM_DWORD   cbRemaining     = 0;
    DRM_DWORD   cbToRead        = 0;
    DRM_DWORD   cbRead          = 0;

    if ( fCreate )
    {
        ChkDR( DRM_HDS_OpenNamespace( pcontextHDS, 
                                      pcontextSST->pNamespaceId, 
                                      eDRM_HDS_CREATE_IF_NEW | eDRM_HDS_LOCKWAIT,
                                      DRM_SECURE_STORE_NUM_CHILD_NODES,
                                      &pcontextSST->oNsContext ) );
    }
    else
    {
        dr = DRM_HDS_OpenNamespace( pcontextHDS, 
                                    pcontextSST->pNamespaceId, 
                                    eDRM_HDS_OPEN_EXISTING | eDRM_HDS_LOCKWAIT,
                                    DRM_SECURE_STORE_NUM_CHILD_NODES,
                                    &pcontextSST->oNsContext );
        if ( dr == DRM_E_HDSNAMESPACENOTFOUND )
        {
            /*
            **  TODO: Why are we changing the errorcode here? What error
            **  code are callers expecting? Need to revisit this.
            */
            dr = DRM_E_FILENOTFOUND;
        }
        ChkDR(dr);
    }
    fCloseNamespace = TRUE;

    if( fRaw )
    {
        dwSlotMetaData |= DRM_SST_RAW_DATA;
    }

    dr = DRM_HDS_OpenSlot (&pcontextSST->oNsContext, 
                           eDRM_HDS_OPEN_EXISTING | eDRM_HDS_LOCKEXCLUSIVE | eDRM_HDS_LOCKWAIT, 
                           &pcontextSST->rgbKey1, 
                           &pcontextSST->rgbKey2,
                            NULL,
                           &pcontextSST->cbSlot,
                           &pcontextSST->oSlotContext);
    if (dr == DRM_E_HDSSLOTNOTFOUND )
    {
        if( fCreate )
        {
            pcontextSST->cbSlotData = DRM_SST_SLOT_HEADER_SIZE;
            pcontextSST->cbSlot     = DRM_SST_SLOT_HEADER_SIZE 
                                    + DRM_SST_PREALLOCATE_SIZE;
            dr = DRM_HDS_OpenSlot (&pcontextSST->oNsContext, 
                                   eDRM_HDS_CREATE_IF_NEW | eDRM_HDS_LOCKEXCLUSIVE | eDRM_HDS_LOCKWAIT, 
                                   &pcontextSST->rgbKey1, 
                                   &pcontextSST->rgbKey2,
                                    NULL,
                                   &pcontextSST->cbSlot,            
                                   &pcontextSST->oSlotContext);
            fCreated = TRUE;
        }
        else
        {
            dr = DRM_E_FILENOTFOUND;
        }
    }
    ChkDR( dr );    
    fCloseSlot = TRUE;

    /* The slot is open.*/
    if( fCreated )
    {
        dr = _InitSlot(pcontextSST, fRaw, eType, rgbPassword);
    }
    else
    {           
        dr = _LoadSlot(pcontextSST, fRaw, eType, rgbPassword);
    }
    pcontextSST->eType = eType;

ErrorExit:
    if( DRM_FAILED( dr ) )
    {
        if( fCloseSlot )
        {
            DRM_HDS_CloseSlot( &pcontextSST->oSlotContext );
        }
        if( fCloseNamespace )
        {
            DRM_HDS_CloseNamespace( &pcontextSST->oNsContext );
        }
    }
    return dr;
}

DRM_RESULT DRM_API DRM_SST_OpenKeyTokens(
    IN OUT   DRM_SECSTORE_CONTEXT   *pcontextSST,
    IN const DRM_ID                 *pKey1,
    IN const DRM_ID                 *pKey2,
    IN const DRM_BYTE                rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_DWORD               dwFlags,
    IN       eDRM_SECURE_STORE_TYPE  eType,
    IN       DRM_HDS_CONTEXT        *pcontextHDS)
{
    DRM_RESULT                  dr        = DRM_SUCCESS;
    DRM_DWORD                   cbRead    = 0;    
    DRM_DWORD                   cbHeader  = 0;
    DRM_BOOL                    fClose    = FALSE;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_SST_OpenKeyTokens", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
        
    ChkArg( pcontextSST != NULL
         && pKey1       != NULL
         && rgbPassword != NULL
         && pcontextHDS != NULL );

    ZEROMEM( pcontextSST, SIZEOF( *pcontextSST ) );

    /* Check for supported flags */
    if ( ( dwFlags & ~(DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS) ) ||
        !( eType == SECURE_STORE_LICENSE_DATA    ||
           eType == SECURE_STORE_GLOBAL_DATA     ||          
           eType == SECURE_STORE_METERING_DATA   ||
           eType == SECURE_STORE_PLAYLIST_BURNING_DATA ) )
    {
        dr = DRM_E_INVALIDARG;
        goto ErrorExit;
    }
    
    switch( eType )
    {
    case SECURE_STORE_METERING_DATA:
        pcontextSST->pNamespaceId = &METER_STORE_NAMESPACE;
        break;
    case SECURE_STORE_PLAYLIST_BURNING_DATA:
        pcontextSST->pNamespaceId = &PLAYLIST_BURN_STORE_NAMESPACE;
        break;
    case SECURE_STORE_GLOBAL_DATA: /* Fall through */
    case SECURE_STORE_LICENSE_DATA:
        pcontextSST->pNamespaceId = &SEC_STORE_NAMESPACE;
        break;
    }

    /* Copy the IDs so we can open the right slot later */
    MEMCPY( &pcontextSST->rgbKey1, pKey1, SIZEOF( pcontextSST->rgbKey1 ) );
    if( pKey2 )
    {
        MEMCPY( &pcontextSST->rgbKey2, pKey2, SIZEOF( pcontextSST->rgbKey2 ) );
    }
    else
    {
        ZEROMEM( &pcontextSST->rgbKey2, SIZEOF( pcontextSST->rgbKey2 ) );
    }
    
    ChkDR( _OpenAndVerifySlot( pcontextSST, pcontextHDS, rgbPassword, eType, FALSE, dwFlags & DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS ) );
    fClose = TRUE;

    MEMCPY( pcontextSST->rgbPassword, rgbPassword, SHA_DIGEST_LEN );

    /* The data has been read and verified.  Run through the data and create a map of the keys */
    cbHeader = ( pcontextSST->dwSlotVersion == 0) 
             ? DRM_SST_SLOT_V0_HEADER_SIZE
             : DRM_SST_SLOT_HEADER_SIZE;
    ChkDR( _LoadAttributesIntoCache( pcontextSST->rgbSlotData + __CB_DECL( cbHeader ), 
                                     pcontextSST->cbSlotData  - cbHeader,
                                     pcontextSST->rgAttributes,
                                    &pcontextSST->wNumAttributes ) );

    pcontextSST->wNumOriginalAttributes = pcontextSST->wNumAttributes;
    pcontextSST->fInited                = TRUE;
    dr                                  = DRM_SUCCESS;

ErrorExit:
    if (fClose)
    {
        DRM_HDS_CloseSlot(&pcontextSST->oSlotContext);
        DRM_HDS_CloseNamespace(&pcontextSST->oNsContext);
    }

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_SST_OpenKeyTokens", g_pwszLeavingFunction);
        
    return ( dr );
}

/******************************************************************************
** 
** Function :   DRM_SST_OpenAndLockSlot
** 
** Synopsis :   Opens and locks the appropriate slot
** 
** Arguments :  f_pcontextHDS   : 
**              f_eType         :   Type of secure store
**              f_pKey1         :   Key1 buffer
**              f_pKey2         :   Key2 buffer
**              f_rgbPassword   :   Secure store password
**              f_dwFlags       :   Only allowed flag for now is 
**                                  DRM_SECURE_STORE_CREATE_IF_NOT_EXIST 
**              f_pcontextSST   :   Secure store context for opened slot
**              f_pcbData       :   (Optional - can be NULL)If slot already 
**                                  exists, on return it contains slot size
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_SST_OpenAndLockSlot(
    IN          DRM_HDS_CONTEXT        *f_pcontextHDS,
    IN          eDRM_SECURE_STORE_TYPE  f_eType,
    IN  const   DRM_ID                 *f_pKey1,
    IN  const   DRM_ID                 *f_pKey2,
    IN  const   DRM_BYTE                f_rgbPassword[__CB_DECL(SHA_DIGEST_LEN)],
    IN          DRM_DWORD               f_dwFlags,
        OUT     DRM_SECSTORE_CONTEXT   *f_pcontextSST,
        OUT     DRM_DWORD              *f_pcbData )
{
    DRM_RESULT  dr  = DRM_SUCCESS;

    /*
    **  Check input
    */
    ChkArg( (f_dwFlags & ~DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS) == 0 );
    ChkArg( f_pcontextSST != NULL
         && f_pcontextHDS != NULL
         && f_pKey1       != NULL
         && f_rgbPassword != NULL );
    
    /*
    **  Clear the output flag in secstore
    */
    f_pcontextSST->fLocked = FALSE;
    
    /*
    **  Check for supported flags
    */
    if (  f_eType != SECURE_STORE_LICENSE_DATA             
       && f_eType != SECURE_STORE_GLOBAL_DATA              
       && f_eType != SECURE_STORE_REVOCATION_DATA          
       && f_eType != SECURE_STORE_METERING_DATA            
       && f_eType != SECURE_STORE_DEVICE_REGISTRATION_DATA 
       && f_eType != SECURE_STORE_PLAYLIST_BURNING_DATA
       && f_eType != SECURE_STORE_CACHED_CERTIFICATE_DATA )
    {
        dr = DRM_E_INVALIDARG;
        goto ErrorExit;
    }

    /*
    **  Initialize the secstore context
    */
    ZEROMEM( f_pcontextSST, SIZEOF( *f_pcontextSST ) );
    switch( f_eType )
    {
    case SECURE_STORE_METERING_DATA:
        f_pcontextSST->pNamespaceId = &METER_STORE_NAMESPACE;
        break;
    case SECURE_STORE_PLAYLIST_BURNING_DATA:
        f_pcontextSST->pNamespaceId = &PLAYLIST_BURN_STORE_NAMESPACE;
        break;
    case SECURE_STORE_DEVICE_REGISTRATION_DATA:
        f_pcontextSST->pNamespaceId = &DEVICE_REGISTRATION_STORE_NAMESPACE;
        break;
    case SECURE_STORE_GLOBAL_DATA: /* Fall through */
    case SECURE_STORE_REVOCATION_DATA:
    case SECURE_STORE_LICENSE_DATA:
    case SECURE_STORE_CACHED_CERTIFICATE_DATA:
        f_pcontextSST->pNamespaceId = &SEC_STORE_NAMESPACE;
        break;
    }
        
    /*
    **  Copy the IDs so we can open the right slot later
    */
    MEMCPY( &f_pcontextSST->rgbKey1, f_pKey1, SIZEOF( f_pcontextSST->rgbKey1 ) );
    if( f_pKey2 != NULL )
    {
        MEMCPY( &f_pcontextSST->rgbKey2, f_pKey2, SIZEOF( f_pcontextSST->rgbKey2 ) );
    }
    else
    {
        ZEROMEM(&f_pcontextSST->rgbKey2, SIZEOF( f_pcontextSST->rgbKey2 ) );
    }

    /*
    **  Open and lock slot
    */
    ChkDR( _OpenAndVerifySlot( f_pcontextSST, 
                               f_pcontextHDS, 
                               f_rgbPassword, 
                               f_eType, 
                               TRUE, 
                               f_dwFlags & DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS ) );

    /*
    **  Save the securestore password
    */
    MEMCPY( f_pcontextSST->rgbPassword, 
            f_rgbPassword, 
            SIZEOF(f_pcontextSST->rgbPassword) );

    /*
    **  Set the slot size for the caller
    */
    if (f_pcbData != NULL)
    {
        *f_pcbData = ( f_pcontextSST->dwSlotVersion == 0 )
                   ? f_pcontextSST->cbSlotData - DRM_SST_SLOT_V0_HEADER_SIZE
                   : f_pcontextSST->cbSlotData - DRM_SST_SLOT_HEADER_SIZE; 
    }   
    
    /*
    **  Secstore context now holds the lock. Set appropriate flag
    */
    f_pcontextSST->fLocked = TRUE;
    
ErrorExit:
    return dr;
}
    

/******************************************************************************
** 
** Function :   DRM_SST_GetLockedData
** 
** Synopsis :   Gets data from the slot if this thread holds the lock to the slot
** 
** Arguments :  f_pcontextSST   : Secure store context
**              f_pbData        : Buffer for slot data
**              f_pcbData       : Buffer size; if slot is bigger, on return, it
**                                would contain the slot size
** 
** Returns :    DRM_E_SECURESTORE_LOCKNOTOBTAINED if  DRM_SST_OpenAndLockSlot has
**              not been successfully called prior to this function
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_SST_GetLockedData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
       OUT   DRM_BYTE               *f_pbData,
       OUT   DRM_DWORD              *f_pcbData )
{
    DRM_RESULT  dr          = DRM_SUCCESS;
    DRM_DWORD   cbRemaining = 0;
    DRM_DWORD   cbHeader    = 0;

    ChkArg( f_pcontextSST != NULL
         && f_pcbData     != NULL );
    
    /*
    **  Check if the caller holds the lock for the secure store
    */
    if (!f_pcontextSST->fLocked)
    {
        ChkDR(DRM_E_SECURESTORE_LOCKNOTOBTAINED);
    }
    
    /*
    **  Check size of input buffer
    */
    cbHeader = ( f_pcontextSST->dwSlotVersion == 0 )
             ? DRM_SST_SLOT_V0_HEADER_SIZE
             : DRM_SST_SLOT_HEADER_SIZE;
    cbRemaining = f_pcontextSST->cbSlotData - cbHeader;    
    
    if( f_pbData == NULL || *f_pcbData < cbRemaining )
    {
        *f_pcbData = cbRemaining;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }
    *f_pcbData = cbRemaining;
    
    /*
    **  Get the data
    */
    ChkDR( DRM_HDS_SlotSeek( &f_pcontextSST->oSlotContext, 
                             cbHeader, 
                             eDRM_HDS_SEEKSET, NULL ) );
    ChkDR( DRM_HDS_SlotRead( &f_pcontextSST->oSlotContext, 
                             cbRemaining, 
                             f_pbData, 
                             f_pcbData ) );

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_SST_SetLockedData
** 
** Synopsis :   Sets data into the slot if this thread holds the lock to the slot
** 
** Arguments :  f_pcontextSST   : Secure store context
**              f_cbData        : Buffer size; 
**              f_pbData        : Data Buffer
** 
** Returns :    DRM_E_SECURESTORE_LOCKNOTOBTAINED if  DRM_SST_OpenAndLockSlot has
**              not been successfully called prior to this function
**
** Notes :
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_SST_SetLockedData(
    IN          DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN          DRM_DWORD               f_cbData,
        OUT     DRM_BYTE               *f_pbData )
{
    DRM_RESULT      dr              = DRM_SUCCESS;
    DRM_DWORD       cbWritten       = 0;
    DRM_DWORD       dwSlotMetaData  = 0;
    HMAC_CONTEXT    contextHMAC;

    ChkArg( f_pcontextSST != NULL
         && f_pbData      != NULL );
    
    /*
    **  Check if the caller holds the lock for the secure store
    */
    if (!f_pcontextSST->fLocked)
    {
        ChkDR(DRM_E_SECURESTORE_LOCKNOTOBTAINED);
    }    
    

    f_pcontextSST->cbSlotData = DRM_SST_SLOT_HEADER_SIZE + f_cbData;
    ChkDR( DRM_HDS_SlotResize( &f_pcontextSST->oSlotContext, 
                               f_pcontextSST->cbSlotData ) );
    /*
    **  If this was a v0 slot, update it to current version
    */
    if ( f_pcontextSST->dwSlotVersion == 0 )
    {
        /* Clear the old format size fields in the slot meta data */
        BYTES_TO_DWORD( dwSlotMetaData, f_pcontextSST->rgbSlotData );
        DRM_SST_SET_SLOT_METADATA( dwSlotMetaData );
        DWORD_TO_BYTES( f_pcontextSST->rgbSlotData, dwSlotMetaData );
    }
     
    /*
    **  Obtain HMAC of data to be written to secstore
    */
    ChkDR( DRM_HMAC_Init( &contextHMAC, 
                          f_pcontextSST->rgbPassword, 
                          SHA_DIGEST_LEN ) );
    ChkDR( DRM_HMAC_Update( &contextHMAC, f_pbData, f_cbData ) );
    ChkDR( DRM_HMAC_Finalize( &contextHMAC, 
                              f_pcontextSST->rgbSlotData + __CB_DECL( DRM_SST_SLOT_HASH_OFFSET), 
                              SHA_DIGEST_LEN ) );

    /*
    **  Find the right slot
    */
    ChkDR( DRM_HDS_SlotSeek( &f_pcontextSST->oSlotContext, 
                             0, 
                             eDRM_HDS_SEEKSET,
                             NULL ) );

    /* Update the size in the slot meta data */
    DWORD_TO_BYTES( f_pcontextSST->rgbSlotData + __CB_DECL( DRM_SST_SLOT_METADATA_SIZE ), 
                    f_pcontextSST->cbSlotData );        
    
    if( DRM_SST_SLOT_HEADER_SIZE + f_cbData <= SIZEOF( f_pcontextSST->rgbSlotData ) )
    {
        /* Copy to in memory buffer to minimize calls to SlotWrite */
        DRM_BYT_CopyBytes( f_pcontextSST->rgbSlotData, DRM_SST_SLOT_DATA_OFFSET, f_pbData, 0, f_cbData );
        ChkDR( DRM_HDS_SlotWrite( &f_pcontextSST->oSlotContext, 
                                   f_pcontextSST->cbSlotData, 
                                   f_pcontextSST->rgbSlotData, 
                                  &cbWritten ) );
        if ( cbWritten != f_pcontextSST->cbSlotData )
        {
            ChkDR( DRM_E_FILEWRITEERROR );
        }
    }
    else
    {

        /*
        **  Write HMAC to secstore
        */
        ChkDR( DRM_HDS_SlotWrite( &f_pcontextSST->oSlotContext, 
                                   DRM_SST_SLOT_HEADER_SIZE, 
                                   f_pcontextSST->rgbSlotData, 
                                  &cbWritten ) );
        if ( cbWritten != DRM_SST_SLOT_HEADER_SIZE )
        {
            ChkDR( DRM_E_FILEWRITEERROR );
        }
        
        /*
        **  Write data to slot
        */
        ChkDR( DRM_HDS_SlotWrite( &f_pcontextSST->oSlotContext, 
                                   f_cbData, 
                                   f_pbData, 
                                  &cbWritten ) );        
        if( cbWritten != f_cbData )
        {
            ChkDR( DRM_E_FILEWRITEERROR );
        }
    }

#if !_DATASTORE_WRITE_THRU
    ChkDR( DRM_HDS_CommitNamespace(&f_pcontextSST->oNsContext) );
#endif

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_SST_CloseLockedSlot
** 
** Synopsis :   Closes the slot, releasing lock in the process
** 
** Arguments :  f_pcontextSST - secure store context
** 
** Returns :    DRM_SUCCESS 
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_SST_CloseLockedSlot( IN  DRM_SECSTORE_CONTEXT *f_pcontextSST )
{
    DRM_RESULT  dr  = DRM_SUCCESS;

    ChkArg( f_pcontextSST != NULL );
    
    /*
    **  Close the slot - release lock if the caller holds the lock for the 
    **  secure store
    */
    if (f_pcontextSST->fLocked)
    {
        DRM_HDS_CloseSlot( &f_pcontextSST->oSlotContext );
        DRM_HDS_CloseNamespace( &f_pcontextSST->oNsContext );
        f_pcontextSST->fLocked = FALSE;
    }      
        
ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_SST_GetData
** 
** Synopsis :   
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_SST_GetData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN const DRM_ID                 *f_pKey1,
    IN const DRM_ID                 *f_pKey2,
    IN const DRM_BYTE                f_rgbPassword[__CB_DECL(SHA_DIGEST_LEN)],
    IN       eDRM_SECURE_STORE_TYPE  f_eType,
    IN       DRM_HDS_CONTEXT        *f_pcontextHDS,
       OUT   DRM_BYTE               *f_pbData,
       OUT   DRM_DWORD              *f_pcbData )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    DRM_DWORD   cbData  = 0;
    
    /*
    **  All other parameters will be checked by internal functions
    **  This is just a wrapper over them
    */
    ChkArg( f_pcbData != NULL );
    
    ChkDR( DRM_SST_OpenAndLockSlot( f_pcontextHDS, 
                                    f_eType, 
                                    f_pKey1, 
                                    f_pKey2, 
                                    f_rgbPassword,
                                    0, 
                                    f_pcontextSST,
                                    &cbData ) );
    if ( *f_pcbData < cbData)
    {
        *f_pcbData = cbData;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;        
    }
    
    /*
    **  Read data now
    */
    ChkDR( DRM_SST_GetLockedData( f_pcontextSST, 
                                  f_pbData, 
                                  f_pcbData ) );
    
ErrorExit:
    
    /*
    **  Release lock
    */ 
    DRM_SST_CloseLockedSlot( f_pcontextSST );    
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_SST_SetData
** 
** Synopsis :   
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_SST_SetData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN const DRM_ID                 *f_pKey1,
    IN const DRM_ID                 *f_pKey2,
    IN const DRM_BYTE                f_rgbPassword[__CB_DECL(SHA_DIGEST_LEN)],
    IN       eDRM_SECURE_STORE_TYPE  f_eType,
    IN       DRM_HDS_CONTEXT        *f_pcontextHDS,
       OUT   DRM_BYTE               *f_pbData,
    IN       DRM_DWORD               f_cbData )
{
    DRM_RESULT  dr      = DRM_SUCCESS;
    
    /*
    **  Parameters will be checked by internal functions
    **  This is just a wrapper over them
    */
    ChkDR( DRM_SST_OpenAndLockSlot( f_pcontextHDS, 
                                    f_eType, 
                                    f_pKey1, 
                                    f_pKey2, 
                                    f_rgbPassword,
                                    DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS, 
                                    f_pcontextSST,
                                    NULL ) );    
    /*
    **  Set data now
    */
    ChkDR( DRM_SST_SetLockedData( f_pcontextSST,
                                  f_cbData, 
                                  f_pbData ) );
    
ErrorExit:

    /*
    **  Release lock
    */ 
    DRM_SST_CloseLockedSlot( f_pcontextSST );
    return dr;

}

static DRM_RESULT _UpdateAttributeTokenInSlot( 
    DRM_SECSTORE_CONTEXT *pcontextSST, 
    DRM_CONST_STRING     *pdstrAttribute,
    TOKEN                *pToken,
    DRM_BOOL              fNewAttribute )
{
    DRM_RESULT dr        = DRM_SUCCESS;    
    DRM_DWORD  dwOffset  = 0;
    DRM_WORD   cbString  = 0;
    DRM_DWORD   cbDataLen       = 0;
    DRM_DWORD   dwDataOffset    = 0;
    TOKEN       token;

    if ( pcontextSST->dwSlotVersion == 0)
    {
        cbDataLen       = pcontextSST->cbSlotData - DRM_SST_SLOT_V0_HEADER_SIZE;
        dwDataOffset    = DRM_SST_SLOT_V0_DATA_OFFSET;        
    }
    else
    {
        cbDataLen       = pcontextSST->cbSlotData - DRM_SST_SLOT_HEADER_SIZE;
        dwDataOffset    = DRM_SST_SLOT_DATA_OFFSET; 
    }
    while( dwOffset < cbDataLen )
    {
        DRM_WORD cbString = 0;

        DRM_BYT_CopyBytes( &cbString, 0, pcontextSST->rgbSlotData, dwDataOffset + dwOffset, SIZEOF( cbString ) );
        FIX_ENDIAN_WORD( cbString );        
        
        dwOffset += SIZEOF( cbString );

        if( cbString == CB_DSTR( pdstrAttribute )
         && DRM_MAX_ATTRIBUTE_STRING_LENGTH >= pdstrAttribute->cchString )
        {
            DRM_WCHAR rgchString[DRM_MAX_ATTRIBUTE_STRING_LENGTH];

            DRM_BYT_CopyBytes( rgchString, 0, pcontextSST->rgbSlotData, dwDataOffset + dwOffset, cbString );
            dwOffset += cbString;

            /* It is the right size, see if it is the right string */
            if( 0 == MEMCMP(rgchString, PB_DSTR( pdstrAttribute ), CB_DSTR( pdstrAttribute ) ) )
            {
                DRM_BYT_CopyBytes( &token, 0, pcontextSST->rgbSlotData, dwDataOffset + dwOffset, SIZEOF( TOKEN ) );
                _PrepareTokenForRead( &token );                

                /* Apply the diff */
                if( fNewAttribute )
                {
                    /* Yikes!  This is a new attribute for our context but someother context has already
                        written it.  Tread here very carfully */
                    /* The valid scenarios for this is relative experiation, or saveddatetime being updated,
                        or perhaps metering or playlist burns.  In the time cases we will do nothing.  In the count
                        cases we can safely add the diff */                    
                    switch( pToken->TokenType )
                    {
                    case TOKEN_LONG:
                        /* Ensure that it really is a positive add though, because that is the only valid scenario. */
                        if( pToken->val.lValue < 0 )
                        {
                            dr = CPRMEXP_UPDATE_FAILURE;
                            goto ErrorExit;
                        }
                        token.val.lValue += pToken->val.lValue;
                        break;
                    case TOKEN_DATETIME:
                        /* Do nothing */
                        break;
                    }
                }
                else
                {
                    /* Update the result token with the delta data */
                    switch( pToken->TokenType )
                    {
                    case TOKEN_LONG:
                        /* NewDiff = NewValue - ( OldDiff + CachedValue ) */                        
                        token.val.lValue += pToken->val.lValue;
                        if( token.val.lValue < 0 )
                        {
                            /* Really slim case that if someone used their last playcount in one session, but didn't get flushed,
                                and it was later set to 0 in another context, we could roll over to a huge count.  We 
                                don't want our smart diff delay write to have a hole where users turn 1 playcount into
                                0x8FFFFFFF playcounts! */
                            dr = CPRMEXP_UPDATE_FAILURE;
                            goto ErrorExit;
                        }
                        break;
                    case TOKEN_DATETIME:
                        /* The delta value has been set, just return that. */
                        token.val.u64DateTime = pToken->val.u64DateTime;
                    }
                }
                _PrepareTokenForWrite( &token );
                DRM_BYT_CopyBytes( pcontextSST->rgbSlotData, dwDataOffset + dwOffset, &token, 0, SIZEOF( TOKEN ) );
                dwOffset += SIZEOF( TOKEN );
                dr = DRM_SUCCESS;
                goto ErrorExit;
            }
            dwOffset += SIZEOF( TOKEN );
        }
        else
        {            
            dwOffset += ( cbString + SIZEOF( TOKEN ) );
        }
    }

    /* If we got here then the attribute was found in the slot.  This is good for new attributes, bad for non-new attributes */
    if( !fNewAttribute )
    {
        ChkDR( CPRMEXP_UPDATE_FAILURE );
    }
    
    dwOffset                 = pcontextSST->cbSlotData;
    pcontextSST->cbSlotData += SIZEOF( DRM_WORD ) 
                             + CB_DSTR( pdstrAttribute ) 
                             + SIZEOF( TOKEN );

    if( pcontextSST->cbSlotData > DRM_SEC_STORE_MAX_SLOT_SIZE )
    {
        ChkDR( DRM_E_SECURESTORE_FULL );
    }
    
    cbString = (DRM_WORD) CB_DSTR( pdstrAttribute );    
    FIX_ENDIAN_WORD( cbString );
    MEMCPY( &token, pToken, SIZEOF( TOKEN ) );
    _PrepareTokenForWrite( &token );

    DRM_BYT_CopyBytes( pcontextSST->rgbSlotData, dwOffset, &cbString,                 0, SIZEOF( cbString ) );
    dwOffset += SIZEOF( cbString );
    DRM_BYT_CopyBytes( pcontextSST->rgbSlotData, dwOffset, PB_DSTR( pdstrAttribute ), 0, CB_DSTR( pdstrAttribute ) );
    dwOffset += CB_DSTR( pdstrAttribute );
    DRM_BYT_CopyBytes( pcontextSST->rgbSlotData, dwOffset, &token,                    0, SIZEOF( TOKEN ) );    

ErrorExit:
    return dr;
}

static DRM_RESULT _ApplyDiffsToStore( 
    IN     DRM_SECSTORE_CONTEXT *pcontextSST, 
    IN OUT DRM_SECSTORE_CONTEXT *pcontextSSTFromDisk )
{
    DRM_RESULT dr     = DRM_SUCCESS;
    DRM_WORD   iCount = 0;    

    for( iCount = 0; iCount < pcontextSST->wNumOriginalAttributes; iCount++ )
    {
        if( ( pcontextSST->rgAttributes[iCount].TokenDelta.TokenType == TOKEN_LONG &&
              pcontextSST->rgAttributes[iCount].TokenDelta.val.lValue    != 0 ) ||
            ( pcontextSST->rgAttributes[iCount].TokenDelta.TokenType == TOKEN_DATETIME &&
              !DRM_UI64Eql( pcontextSST->rgAttributes[iCount].TokenDelta.val.u64DateTime, DRM_UI64(0) ) ) )
        {
            ChkDR( _UpdateAttributeTokenInSlot( pcontextSSTFromDisk,
                                                &(pcontextSST->rgAttributes[iCount].dstrAttribute),
                                                &(pcontextSST->rgAttributes[iCount].TokenDelta),
                                                FALSE ) );
        }
    }

    for( iCount = pcontextSST->wNumOriginalAttributes; iCount < pcontextSST->wNumAttributes; iCount++ )
    {
        if( ( pcontextSST->rgAttributes[iCount].TokenDelta.TokenType == TOKEN_LONG ) ||
            ( pcontextSST->rgAttributes[iCount].TokenDelta.TokenType == TOKEN_DATETIME ) )
        {
            ChkDR( _UpdateAttributeTokenInSlot( pcontextSSTFromDisk, 
                                                &(pcontextSST->rgAttributes[iCount].dstrAttribute),
                                                &(pcontextSST->rgAttributes[iCount].TokenDelta),
                                                TRUE ) );        
        }
    }

ErrorExit:
    return dr;
}

                    
DRM_RESULT DRM_API DRM_SST_CloseKey( 
    IN       DRM_SECSTORE_CONTEXT *pcontextSST, 
    IN       DRM_HDS_CONTEXT      *pcontextHDS )
{
    DRM_RESULT   dr                 = DRM_SUCCESS;
    DRM_DWORD    cbWritten          = 0;    
    DRM_DWORD    dwSlotMetaData     = 0;
    DRM_BOOL     fCloseStore        = FALSE;
    DRM_SECSTORE_CONTEXT contextSST = { 0 };
    HMAC_CONTEXT oHmacContext;

    ChkArg (pcontextSST          != NULL
         && pcontextHDS          != NULL
         && pcontextSST->fInited != FALSE);
    
    MEMCPY( &contextSST.rgbKey1, &pcontextSST->rgbKey1, SIZEOF( contextSST.rgbKey1 ) );
    MEMCPY( &contextSST.rgbKey2, &pcontextSST->rgbKey2, SIZEOF( contextSST.rgbKey2 ) );
    contextSST.pNamespaceId = pcontextSST->pNamespaceId;
        
    ChkDR( _OpenAndVerifySlot( &contextSST, pcontextHDS, pcontextSST->rgbPassword, pcontextSST->eType, FALSE, FALSE ) );    
    fCloseStore = TRUE;

    /* The slot hash of the now opened slot is valid.  Go about the process of applying diff's to the 
       attributes in the slot */    
    ChkDR( _ApplyDiffsToStore( pcontextSST, &contextSST ) );

    /* Update the size in the slot meta data */
    if ( contextSST.dwSlotVersion == 0 )
    {
        /*
        **  We must update the format of this slot before writing it to disc
        */ 

        /*  Set the metadata first  */
        BYTES_TO_DWORD( dwSlotMetaData, contextSST.rgbSlotData );
        DRM_SST_SET_SLOT_METADATA( dwSlotMetaData );
        DWORD_TO_BYTES( contextSST.rgbSlotData, dwSlotMetaData );

        /*  Move the rest of the data down by a DWORD       */
        /*  We have enough space in the bufer to do this    */
        DRM_BYT_MoveBytes( contextSST.rgbSlotData, 
                           DRM_SST_SLOT_DATA_OFFSET, 
                           contextSST.rgbSlotData, 
                           DRM_SST_SLOT_V0_DATA_OFFSET, 
                           contextSST.cbSlotData - DRM_SST_SLOT_V0_HEADER_SIZE );

        /*  Increment the slotsize by a DWORD   */
        contextSST.cbSlotData += DRM_SST_SLOT_SIZEDATA_SIZE;
    }

    /*  Update the size data in the buffer  */        
    DWORD_TO_BYTES( contextSST.rgbSlotData + __CB_DECL( DRM_SST_SLOT_METADATA_SIZE ), 
                    contextSST.cbSlotData );     

    ChkDR( DRM_HMAC_Init    ( &oHmacContext, pcontextSST->rgbPassword,                                        SHA_DIGEST_LEN ) );
    ChkDR( DRM_HMAC_Update  ( &oHmacContext, contextSST.rgbSlotData + __CB_DECL( DRM_SST_SLOT_DATA_OFFSET ), contextSST.cbSlotData - DRM_SST_SLOT_HEADER_SIZE) );
    ChkDR( DRM_HMAC_Finalize( &oHmacContext, contextSST.rgbSlotData + __CB_DECL( DRM_SST_SLOT_HASH_OFFSET ), SHA_DIGEST_LEN ) );

    /* Write the new hash back to disk */    
    if( contextSST.cbSlot < contextSST.cbSlotData )
    {
        ChkDR( DRM_HDS_SlotResize( &contextSST.oSlotContext, contextSST.cbSlotData ) );
    }
    ChkDR( DRM_HDS_SlotSeek  ( &contextSST.oSlotContext, 0,                     eDRM_HDS_SEEKSET,        NULL ) );
    ChkDR( DRM_HDS_SlotWrite ( &contextSST.oSlotContext, contextSST.cbSlotData, contextSST.rgbSlotData, &cbWritten ) );

#if !_DATASTORE_WRITE_THRU
    ChkDR( DRM_HDS_CommitNamespace(&contextSST.oNsContext) );
#endif
    
ErrorExit:    
    if( fCloseStore )
    {
        DRM_HDS_CloseSlot     ( &contextSST.oSlotContext );
        DRM_HDS_CloseNamespace( &contextSST.oNsContext   );
    }    
    return dr;
}


DRM_RESULT DRM_API DRM_SST_GetTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pcontextSST,
    IN const DRM_CONST_STRING     *pdstrAttribute,
       OUT   TOKEN                *pToken )
{
    DRM_RESULT                  dr       = DRM_S_FALSE; /* Return DRM_S_FALSE to indicate that it couldn't be found */
    DRM_DWORD                   dwCount  = 0;
    /*Some compilers remove memcpy while optimizing which can cause datatype misalignment exceptions*/
    DRM_BYTE *pbOptimizeBugByte = NULL; 

    ChkArg (pcontextSST          != NULL
         && pcontextSST->fInited != FALSE
         && pToken               != NULL);

    ChkDRMString( pdstrAttribute );

    for( dwCount = 0; dwCount < pcontextSST->wNumAttributes; dwCount++ )
    {
        if( pdstrAttribute->cchString == pcontextSST->rgAttributes[dwCount].dstrAttribute.cchString 
         && 0 == MEMCMP( PB_DSTR( pdstrAttribute ), 
                         PB_DSTR( &pcontextSST->rgAttributes[dwCount].dstrAttribute ), 
                         CB_DSTR( pdstrAttribute ) ) )
        {
            /* We matched the string value. Return the token value.*/
            pbOptimizeBugByte = (DRM_BYTE*)pcontextSST->rgAttributes[dwCount].pTokenValue; 
            MEMCPY( pToken, pbOptimizeBugByte, SIZEOF( TOKEN ) );
            _PrepareTokenForRead( pToken );

            /* Update the result token with the delta data */
            switch( pToken->TokenType )
            {
            case TOKEN_LONG:
                /* NewDiff = NewValue - ( OldDiff + CachedValue ) */
                pToken->val.lValue += pcontextSST->rgAttributes[dwCount].TokenDelta.val.lValue;
                break;
            case TOKEN_DATETIME:
                if( !DRM_UI64Eql( pcontextSST->rgAttributes[dwCount].TokenDelta.val.u64DateTime, DRM_UI64( 0 ) ) )
                {
                    /* The delta value has been set, just return that. */
                    pbOptimizeBugByte = (DRM_BYTE*)&(pcontextSST->rgAttributes[dwCount].TokenDelta); 
                    MEMCPY( pToken, pbOptimizeBugByte, SIZEOF( TOKEN ) );
                }
            }
            
            dr = DRM_SUCCESS; /* DRM_SUCCESS indicates that the value was found */
            break;
        }
    }

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_SST_SetTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pcontextSST,
    IN const DRM_CONST_STRING     *pdstrAttribute,
    IN const TOKEN                *pToken )
{
    DRM_RESULT dr = DRM_S_FALSE; /* Return DRM_S_FALSE to indicate that it couldn't be found */
    DRM_DWORD  dwCount  = 0;
    DRM_WORD   cbString = 0;
    TOKEN token;
    /*Some compilers remove memcpy while optimizing which can cause datatype misalignment exceptions*/
    DRM_BYTE *pbOptimizeBugByte = NULL; 

    ChkArg (pcontextSST          != NULL
        &&  pToken               != NULL
        &&  pcontextSST->fInited != FALSE
        &&  (pToken->TokenType   == TOKEN_LONG 
          || pToken->TokenType   == TOKEN_DATETIME));

    ChkDRMString( pdstrAttribute );

    /* Search to see if the token already exists */
    for( dwCount = 0; dwCount < pcontextSST->wNumAttributes; dwCount++ )
    {
        if( pdstrAttribute->cchString == pcontextSST->rgAttributes[dwCount].dstrAttribute.cchString 
         && 0 == MEMCMP( PB_DSTR( pdstrAttribute ), 
                         PB_DSTR( &pcontextSST->rgAttributes[dwCount].dstrAttribute ), 
                         CB_DSTR( pdstrAttribute ) ) )
        {
            /* We matched the string value. Update the delta.*/
            pbOptimizeBugByte = (DRM_BYTE*)pcontextSST->rgAttributes[dwCount].pTokenValue; 
            MEMCPY( &token, pbOptimizeBugByte, SIZEOF( TOKEN ) );
            _PrepareTokenForRead( &token );
            if( pToken->TokenType != token.TokenType )
            {
                /* You can't change the token type!! */
                ChkDR( DRM_E_WRONG_TOKEN_TYPE );
            }

            pcontextSST->rgAttributes[dwCount].TokenDelta.TokenType = token.TokenType;
            switch( token.TokenType )
            {
                case TOKEN_LONG:
                    /* NewDiff = NewValue - ( OldDiff + CachedValue ) */
                    pcontextSST->rgAttributes[dwCount].TokenDelta.val.lValue = pToken->val.lValue - (pcontextSST->rgAttributes[dwCount].TokenDelta.val.lValue + token.val.lValue);
                    break;
                case TOKEN_DATETIME:
                    pbOptimizeBugByte = (DRM_BYTE*)&(pcontextSST->rgAttributes[dwCount].TokenDelta); 
                    MEMCPY( pbOptimizeBugByte, pToken, SIZEOF( TOKEN ) );
                    break;
            }

            dr = DRM_SUCCESS;
            goto ErrorExit;
        }
    }
        
    /* Attribute doesn't exist.  Try to create a new one.  Be weary or running out of slot space, as well as 
       cached attribute structure space */
    if( pcontextSST->wNumAttributes == DRM_MAX_ATTRIBUTES_PER_SST_KEY )
    {
        ChkDR( DRM_E_SECURESTORE_FULL );
    }
    if( ( pcontextSST->cbSlotData + SIZEOF( DRM_WORD ) + CB_DSTR( pdstrAttribute ) + SIZEOF ( TOKEN ) ) > DRM_SEC_STORE_MAX_SLOT_SIZE )
    {
        /* Not enough room in the slot */
        ChkDR( DRM_E_SECURESTORE_FULL );
    }

    /* Fill in the data in the slot buffer and the cache attribute array */
    ZEROMEM(       &pcontextSST->rgAttributes[pcontextSST->wNumAttributes], 
            SIZEOF( pcontextSST->rgAttributes[pcontextSST->wNumAttributes] ) );

    cbString = (DRM_WORD) CB_DSTR( pdstrAttribute );
    FIX_ENDIAN_WORD( cbString );
    MEMCPY( &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]), &cbString, SIZEOF( cbString ) );
    pcontextSST->cbSlotData += SIZEOF( cbString );
    FIX_ENDIAN_WORD( cbString );
    
    pcontextSST->rgAttributes[pcontextSST->wNumAttributes].dstrAttribute.cchString  = pdstrAttribute->cchString;
    pcontextSST->rgAttributes[pcontextSST->wNumAttributes].dstrAttribute.pwszString = (DRM_WCHAR*) &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]);
    MEMCPY( &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]), pdstrAttribute->pwszString, cbString );
    pcontextSST->cbSlotData += cbString;

    MEMCPY (&(pcontextSST->rgAttributes[dwCount].TokenDelta), pToken, SIZEOF( TOKEN ) );
    ZEROMEM(&token, SIZEOF( TOKEN ) );
    token.TokenType = pToken->TokenType;
    
    pcontextSST->rgAttributes[pcontextSST->wNumAttributes].pTokenValue = (TOKEN*) &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]);
    _PrepareTokenForWrite( &token );
    MEMCPY( &(pcontextSST->rgbSlotData[__CB_DECL(pcontextSST->cbSlotData)]), &token, SIZEOF( TOKEN ) );
    pcontextSST->cbSlotData += SIZEOF( TOKEN );
    pcontextSST->wNumAttributes++;

    dr = DRM_SUCCESS;

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function: DRM_SST_DeleteKey
**
** Synopsis: Delete an entry from the secure store
**
** Arguments:
**           [f_pcontextSST] -- secure store context, need not be initialized
**           [f_typeSST]     -- one of the legal enums corresponding to the 
**                              layer to open
**           [f_pid1]
**           [f_pid2]        -- major and minor "keys" of the data store to 
**                              delete
**           [f_pcontextHDS] -- initialized HDS context
**                              
** Notes:    Indiscriminate deletion of keys could open up the system for 
**           replay attacks 
*****************************************************************************/

DRM_RESULT DRM_API DRM_SST_DeleteKey(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN       eDRM_SECURE_STORE_TYPE  f_typeSST,
    IN const DRM_ID                 *f_pid1,
    IN const DRM_ID                 *f_pid2,
    IN       DRM_HDS_CONTEXT        *f_pcontextHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_HDS_UNIQUEKEY id2 = {0};

    ChkArg(f_pcontextSST != NULL
        && f_pcontextHDS != NULL
        && f_pid1        != NULL);

    /* Check for supported flags */

    ChkArg(f_typeSST == SECURE_STORE_LICENSE_DATA             
        || f_typeSST == SECURE_STORE_GLOBAL_DATA              
        || f_typeSST == SECURE_STORE_REVOCATION_DATA          
        || f_typeSST == SECURE_STORE_METERING_DATA            
        || f_typeSST == SECURE_STORE_DEVICE_REGISTRATION_DATA 
        || f_typeSST == SECURE_STORE_PLAYLIST_BURNING_DATA);

    switch (f_typeSST)
    {
    case SECURE_STORE_METERING_DATA:
        f_pcontextSST->pNamespaceId = &METER_STORE_NAMESPACE;
        break;
        
    case SECURE_STORE_PLAYLIST_BURNING_DATA:
        f_pcontextSST->pNamespaceId = &PLAYLIST_BURN_STORE_NAMESPACE;
        break;
        
    case SECURE_STORE_DEVICE_REGISTRATION_DATA:
        f_pcontextSST->pNamespaceId = &DEVICE_REGISTRATION_STORE_NAMESPACE;
        break;
        
    case SECURE_STORE_GLOBAL_DATA: /* Fall through */
    case SECURE_STORE_REVOCATION_DATA:
    case SECURE_STORE_LICENSE_DATA:
        f_pcontextSST->pNamespaceId = &SEC_STORE_NAMESPACE;
        break;
    }

    if( f_pid2 != NULL )
    {
        MEMCPY( &id2, f_pid2, SIZEOF( id2 ) );
    }
    ChkDR(DRM_HDS_OpenNamespace( f_pcontextHDS, 
                                 f_pcontextSST->pNamespaceId, 
                                 eDRM_HDS_OPEN_EXISTING | eDRM_HDS_LOCKWAIT,
                                 0,
                                 &f_pcontextSST->oNsContext));
                               
    ChkDR(DRM_HDS_DeleteSlot(&f_pcontextSST->oNsContext,
                             (DRM_HDS_HASHKEY   *) f_pid1, 
                             &id2,
                             NULL,
                             TRUE));

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_SST_GetAllData( 
    IN     DRM_SECSTORE_CONTEXT *pcontextSST,
    OUT    DRM_BYTE             *pbData,
    IN OUT DRM_DWORD            *pcbData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbRequired = 0;
    DRM_DWORD   cbHeader    = 0;

    ChkArg (pcontextSST          != NULL
        &&  pcbData              != NULL
        &&  pcontextSST->fInited != FALSE);

    cbHeader = ( pcontextSST->dwSlotVersion == 0 )
             ? DRM_SST_SLOT_V0_HEADER_SIZE
             : DRM_SST_SLOT_HEADER_SIZE;
    
    cbRequired = pcontextSST->cbSlotData - cbHeader;

    if (  pbData == NULL
      || *pcbData < cbRequired)
    {        
        *pcbData = cbRequired;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }

    MEMCPY (pbData, pcontextSST->rgbSlotData + __CB_DECL( cbHeader ), cbRequired);

    *pcbData = cbRequired;
    dr = DRM_SUCCESS;

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_SST_OpenEnumerator(
    IN        eDRM_SECURE_STORE_TYPE    eType,
    IN  const DRM_ID                   *pKey1,
    OUT       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    IN        DRM_HDS_CONTEXT          *pcontextHDS,
    IN        DRM_BOOL                  fExclusiveLock)
{
    DRM_RESULT dr=DRM_SUCCESS;      
    const DRM_HDS_NAMESPACE *pNamespaceId = NULL;
    DRM_DWORD  dwLockMode = eDRM_HDS_LOCKWAIT;

    ChkArg( pcontextSSTEnum && pcontextHDS );
    if ( fExclusiveLock )
    {
        dwLockMode |= eDRM_HDS_LOCKEXCLUSIVE;
    }
    else
    {
        dwLockMode |= eDRM_HDS_LOCKSHARED;
    }

    /* Check for supported flags */
    if (!( eType == SECURE_STORE_LICENSE_DATA             ||
           eType == SECURE_STORE_GLOBAL_DATA              ||
           eType == SECURE_STORE_REVOCATION_DATA          ||
           eType == SECURE_STORE_METERING_DATA            ||
           eType == SECURE_STORE_DEVICE_REGISTRATION_DATA ||
           eType == SECURE_STORE_PLAYLIST_BURNING_DATA ) )
    {
        dr = DRM_E_INVALIDARG;
        goto ErrorExit;
    }

    ZEROMEM(pcontextSSTEnum, SIZEOF(pcontextSSTEnum));

    switch( eType )
    {
    case SECURE_STORE_METERING_DATA:
        pNamespaceId = &METER_STORE_NAMESPACE;
        break;
    case SECURE_STORE_PLAYLIST_BURNING_DATA:
        pNamespaceId = &PLAYLIST_BURN_STORE_NAMESPACE;
        break;
    case SECURE_STORE_DEVICE_REGISTRATION_DATA:
        pNamespaceId = &DEVICE_REGISTRATION_STORE_NAMESPACE;
        break;
    case SECURE_STORE_GLOBAL_DATA: /* Fall through */
    case SECURE_STORE_REVOCATION_DATA:
    case SECURE_STORE_LICENSE_DATA:
        pNamespaceId = &SEC_STORE_NAMESPACE;
        break;
    }

    dr = DRM_HDS_OpenNamespace( pcontextHDS, 
                                pNamespaceId, 
                                eDRM_HDS_OPEN_EXISTING | eDRM_HDS_LOCKWAIT,
                                0,
                                &pcontextSSTEnum->oNsContext );
    if ( dr == DRM_E_HDSNAMESPACENOTFOUND )
    {  
        dr = DRM_SUCCESS;
        pcontextSSTEnum->fInited = TRUE;
        pcontextSSTEnum->eMode   = eSSTEnumNone;
        goto ErrorExit;
    }
    ChkDR( dr );

    dr = DRM_HDS_InitSlotEnum( &pcontextSSTEnum->oNsContext, 
                               (DRM_HDS_HASHKEY*)pKey1, 
                               dwLockMode, 
                               &pcontextSSTEnum->oHdsEnumContext);
    if( dr == DRM_E_HDSSLOTNOTFOUND )
    {
        /* No Slots found. */
        pcontextSSTEnum->eMode = eSSTEnumNone;
        dr = DRM_SUCCESS;
    }
    else if( DRM_FAILED( dr ) )
    {
        goto ErrorExit;
    }
    else if ( pKey1 )
    {
        pcontextSSTEnum->eMode = eSSTEnumFiltered;
    }
    else
    {
        pcontextSSTEnum->eMode = eSSTEnumNatural;        
    }

    pcontextSSTEnum->fCurrIsValid = FALSE;
    pcontextSSTEnum->fInited      = TRUE;
    pcontextSSTEnum->eType        = eType;

ErrorExit:    
    return dr;
}


/*
**
*/
DRM_RESULT DRM_API DRM_SST_EnumNext( 
    IN  DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    OUT DRM_ID                   *pKey2,
    OUT DRM_DWORD                *pcbData )
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  cbSlot = 0;
    DRM_DWORD  cbHeader         = 0;
    DRM_DWORD  cbRead           = 0;   
    DRM_DWORD  dwSlotMetaData   = 0;

    ChkArg (pcontextSSTEnum           != NULL
         && pcontextSSTEnum->fInited  != NULL
         && pcbData         != NULL
         && pKey2           != NULL);

    if ( pcontextSSTEnum->eMode == eSSTEnumNone )
    {
        dr = DRM_E_NOMORE;
        goto ErrorExit;            
    }

    *pcbData = 0;

    dr = DRM_HDS_SlotEnumNext(&pcontextSSTEnum->oHdsEnumContext, 
                              &pcontextSSTEnum->oSlotContext, 
                              &pcontextSSTEnum->oCurrKID, 
                              &pcontextSSTEnum->oCurrLID, 
                              &cbSlot );
    if ( dr == DRM_E_NOMORE )
    {
        goto ErrorExit;
    }
    else if ( dr == DRM_E_HDSBLOCKMISMATCH 
           || dr == DRM_E_HDSSLOTNOTFOUND )
    {
        ChkDR(DRM_E_SECURESTORE_CORRUPT);
    }
    ChkDR(dr);

    MEMCPY(pKey2->rgb, pcontextSSTEnum->oCurrLID.rgb, DRM_ID_SIZE);    

    pcontextSSTEnum->fCurrIsValid = TRUE;
    
    /*
    **  Figure out the slot version
    */
    ChkDR( DRM_HDS_SlotRead( &pcontextSSTEnum->oSlotContext, 
                             DRM_SST_SLOT_METADATA_SIZE, 
                             (DRM_BYTE *)&dwSlotMetaData, 
                             &cbRead ) );
    if( cbRead != DRM_SST_SLOT_METADATA_SIZE )
    {
        dr = DRM_E_FILEREADERROR;
        goto ErrorExit;
    }
    FIX_ENDIAN_DWORD( dwSlotMetaData );
    
    *pcbData = ( ( dwSlotMetaData & DRM_SST_SLOT_VERSION_MASK ) == 0 )
             ? cbSlot - DRM_SST_SLOT_V0_HEADER_SIZE
             : cbSlot - DRM_SST_SLOT_HEADER_SIZE;
    ChkDR(DRM_HDS_CloseSlot(&pcontextSSTEnum->oSlotContext));
    
ErrorExit:
    return dr;
}

/******************************************************************************
** Function :   DRM_SST_EnumDeleteCurrent
** Synopsis :   Delete the current enumerated slot
******************************************************************************/
DRM_RESULT DRM_API DRM_SST_EnumDeleteCurrent( 
    IN       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    IN OUT   DRM_SECSTORE_CONTEXT     *pcontextSST)
{
    DRM_RESULT dr               = DRM_SUCCESS;
    DRM_DWORD  cbSlot           = 0;
    DRM_DWORD  cbHeader         = 0;
    DRM_DWORD  cbRead           = 0;   
    DRM_DWORD  dwSlotMetaData   = 0;
    DRM_DWORD  cbData           = 0;
    
    ChkArg (pcontextSSTEnum          != NULL
         && pcontextSSTEnum->fInited != NULL);

    ChkBOOL( pcontextSSTEnum->eMode != eSSTEnumNone, DRM_E_NOMORE);

    dr = DRM_HDS_SlotEnumReloadCurrent(&pcontextSSTEnum->oHdsEnumContext, 
                                       &pcontextSST->oSlotContext, 
                                       &pcontextSSTEnum->oCurrKID, 
                                       &pcontextSSTEnum->oCurrLID, 
                                       &cbSlot);
    ChkBOOL(dr != DRM_E_NOMORE, DRM_E_NOMORE);
    ChkBOOL((dr != DRM_E_HDSBLOCKMISMATCH && dr != DRM_E_HDSSLOTNOTFOUND), DRM_E_SECURESTORE_CORRUPT);
    ChkDR(dr);

    dr = DRM_HDS_SlotEnumDeleteCurrent(&pcontextSSTEnum->oHdsEnumContext, 
                                       &pcontextSST->oSlotContext);
    DRM_HDS_CloseSlot( &pcontextSST->oSlotContext );
    pcontextSSTEnum->fCurrIsValid = FALSE;
    pcontextSST->fInited = FALSE;
    
ErrorExit:
    return dr;
}


/******************************************************************************
** Function :   DRM_SST_EnumLoadCurrent
** Synopsis :   Load the current slot in memory
******************************************************************************/
DRM_RESULT DRM_API DRM_SST_EnumLoadCurrent( 
    IN       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    IN OUT   DRM_SECSTORE_CONTEXT     *pcontextSST,
    IN const DRM_BYTE                  rgbPassword[__CB_DECL(SHA_DIGEST_LEN)],
       OUT   DRM_ID                   *pKey2,
    IN OUT DRM_DWORD                  *pcbData)
{
    DRM_RESULT dr               = DRM_SUCCESS;
    DRM_DWORD  cbSlot           = 0;
    DRM_DWORD  cbHeader         = 0;
    DRM_DWORD  cbRead           = 0;   
    DRM_DWORD  dwSlotMetaData   = 0;
    DRM_DWORD  cbData           = 0;
    
    ChkArg (pcontextSSTEnum          != NULL
         && pcontextSSTEnum->fInited != NULL
         && pKey2                    != NULL
         && pcbData                  != NULL);

    ChkBOOL( pcontextSSTEnum->eMode != eSSTEnumNone, DRM_E_NOMORE);

    dr = DRM_HDS_SlotEnumReloadCurrent(&pcontextSSTEnum->oHdsEnumContext, 
                                       &pcontextSST->oSlotContext, 
                                       &pcontextSSTEnum->oCurrKID, 
                                       &pcontextSSTEnum->oCurrLID, 
                                       &cbSlot);
    ChkBOOL(dr != DRM_E_NOMORE, DRM_E_NOMORE);
    ChkBOOL((dr != DRM_E_HDSBLOCKMISMATCH && dr != DRM_E_HDSSLOTNOTFOUND), DRM_E_SECURESTORE_CORRUPT);
    ChkDR(dr);

    MEMCPY(pKey2->rgb, pcontextSSTEnum->oCurrLID.rgb, DRM_ID_SIZE);
    pcontextSSTEnum->fCurrIsValid = TRUE;
    
    /*
    **  Figure out the slot version
    */
    ChkDR( DRM_HDS_SlotRead( &pcontextSST->oSlotContext, 
                             DRM_SST_SLOT_METADATA_SIZE, 
                             (DRM_BYTE *)&dwSlotMetaData, 
                             &cbRead ) );
    if ( cbRead != DRM_SST_SLOT_METADATA_SIZE )
    {
        dr = DRM_E_FILEREADERROR;
        goto ErrorExit;
    }
    FIX_ENDIAN_DWORD( dwSlotMetaData );

    cbData = ( ( dwSlotMetaData & DRM_SST_SLOT_VERSION_MASK ) == 0 )
             ? cbSlot - DRM_SST_SLOT_V0_HEADER_SIZE
             : cbSlot - DRM_SST_SLOT_HEADER_SIZE;

    /* read the slot data */
    pcontextSST->cbSlot = cbData;

    DRM_HDS_SlotSeek(&pcontextSST->oSlotContext, 0, eDRM_HDS_SEEKSET, NULL);
    dr = _LoadSlot(pcontextSST, FALSE, pcontextSSTEnum->eType, rgbPassword);
    if ( DRM_SUCCEEDED(dr) )
    {
        *pcbData = cbData;
    }
    DRM_HDS_CloseSlot( &pcontextSST->oSlotContext );
    pcontextSST->fInited = TRUE;
    
ErrorExit:
    return dr;
}
/*****************************************************************************
** Function: DRM_SST_CreateGlobalStorePassword
**
** Synopsis: use the keyeed to create the hash used as the secure store password 
**           for the global store
**
** Arguments:
**           [f_rgbSeed]     -- buffer to hold keyseed 
**           [f_rgbPassword] -- buffer to hold Password
**           [f_pcontextBBX] -- initialized BBX context
*****************************************************************************/

DRM_RESULT DRM_API DRM_SST_CreateGlobalStorePassword(
    OUT DRM_BYTE  f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)],
    IN  DRM_BYTE *f_pbContextBBX)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   rgbSeed [__CB_DECL(SHA_DIGEST_LEN)];

    ChkDR(OEM_GetSecureStoreGlobalPasswordSeed(rgbSeed));

    ChkDR(DRM_BBX_HashValue(rgbSeed, 
                            SHA_DIGEST_LEN-1,
                            f_rgbPasswordSST,
                            (DRM_BB_CONTEXT *) f_pbContextBBX));

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function: DRM_SST_CreateLicenseStatePassword
**
** Synopsis: use the LID to create the hash used as the secure store password 
**           for this license
**
** Arguments:
**           [f_rgbLID]         -- the LID 
**           [f_rgbPasswordSST] -- buffer to receive the password
**           [f_pcontextBBX]    -- initialized BBX context
*****************************************************************************/

DRM_RESULT DRM_API DRM_SST_CreateLicenseStatePassword(
    IN  DRM_LID  *f_plid,
    OUT DRM_BYTE  f_rgbPasswordLST [__CB_DECL(SHA_DIGEST_LEN)],
    IN  DRM_BYTE *f_pbContextBBX)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR(DRM_BBX_HashValue((DRM_BYTE*) f_plid, 
                            SIZEOF (DRM_LID), 
                            f_rgbPasswordLST, 
                            (DRM_BB_CONTEXT *) f_pbContextBBX)); 

ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmrsaex.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
 * DrmRsaEx.c
 *
 * This file implements RSA signing and encryption of variable length data.
 * It assumes the existence of routines to encrypt a single key sized buffer
 *
 */

#include <drmcommon.h>
#include <drmtypes.h>
#include <oemimpl.h>
#include <drmrsaex.h>
#include <drmsha1.h>
#include <drmutilities.h>
#include <byteorder.h>

#ifndef RSA_REVERSE_OS2IP
#define RSA_REVERSE_OS2IP 0
#endif

/*
 * The _GenerateMGF1Mask function generates an MGF1 mask using SHA1 as the hash 
 * (see PKCS#1 v2.1)
 *
 * Parameters:
 *
 *      pbSeed - Specifies the seed to use for the mask
 *
 *      cbSeed - Specifies the size of the seed
 *
 *      cbMask - Specifies the size of the mask that is required
 *
 *      f_ppbData - Returns a buffer containing the generated mask
 *               This buffer must be freed using OEM_free()
 *
 * Return Value:
 *
 *  DRM_SUCCESS - Operation completed successfully
 *  DRM_E_OUTOFMEMORY - There is no enough memory to complete the operation
 *  DRM_E_INVALIDARG - One of the passed in arguments is bad
 */

static DRM_RESULT _GenerateMGF1Mask( 
    IN const DRM_BYTE  *f_pbSeed,
    IN       DRM_DWORD  f_cbSeed,
    IN       DRM_DWORD  f_cbMask,
       OUT   DRM_BYTE **f_ppbMask)
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_DWORD   cIterations  = 0;
    DRM_DWORD   cbHashInput  = 0;
    DRM_DWORD   cbTotalMask  = 0;
    DRM_DWORD   i            = 0;
    DRM_BYTE   *pbHashInput  = NULL;
    DRM_BYTE   *pbMask       = NULL;
    DRM_BYTE   *pbHashOut    = NULL;
    SHA_CONTEXT contextSHA   = { 0 };
        
    cbHashInput = f_cbSeed + SIZEOF(DRM_DWORD);

    ChkArg(cbHashInput >= f_cbSeed
        && f_cbMask    >  0
        && f_pbSeed    != NULL 
        && f_cbSeed    >  0);

    cIterations = f_cbMask / SHA_DIGEST_LEN;

    if (f_cbMask % SHA_DIGEST_LEN > 0)
    {
        cIterations++;
    }

    cbTotalMask = cIterations * SHA_DIGEST_LEN;

    ChkMem(pbMask      = OEM_malloc(cbTotalMask));
    ChkMem(pbHashInput = OEM_malloc(cbHashInput));

    MEMCPY(pbHashInput, f_pbSeed, f_cbSeed);

    pbHashOut = pbMask;
        
    for (i = 0; i < cIterations; i++)
    {
        DRM_SHA_Init(&contextSHA);

        DWORD_TO_NETWORKBYTES( pbHashInput, f_cbSeed, i );

        DRM_SHA_Update  (pbHashInput, cbHashInput, &contextSHA);
        DRM_SHA_Finalize(&contextSHA, pbHashOut);

        pbHashOut += __CB_DECL(SHA_DIGEST_LEN);
    }

    /*
    ** Wipe off the mask bits that we don't need
    */
    DRM_BYT_SetBytes(pbMask, f_cbMask, cbTotalMask - f_cbMask, 0);

    *f_ppbMask = pbMask;
    pbMask = NULL;

    dr = DRM_SUCCESS;

ErrorExit:

    SAFE_OEM_FREE(pbMask);
    SAFE_OEM_FREE(pbHashInput);

    return dr;
}


/*
 * The DrmOAEPDecode function performs the OAEP decode on an encoded buffer
 * (see PKCS#1 v2.1)
 *
 * Parameters:
 *
 *      cbModulus - Specifies the size of the public key modulus
 *
 *      pbEncData - Specifies the input, encoded data of size cbModulus
 *
 *      ppbDecData - Returns a buffer containing processed, OAEP decoded data
 *                   This buffer must be freed using OEM_free()
 *
 *      pcbDecData - Returns the size (in bytes) of the processed, OAEP 
 *                   decoded data
 *
 * Return Value:
 *
 *  DRM_SUCCESS - Operation completed successfully
 *  DRM_E_OUTOFMEMORY - There is no enough memory to complete the operation
 *  DRM_E_INVALIDARG - The specified modulus size is too small
 *  Other failure - Failed to OAEP decode the data.
 */

static DRM_RESULT DrmOAEPDecode(
    IN       DRM_DWORD  cbModulus,
    IN       DRM_BYTE  *pbEncData,
       OUT   DRM_BYTE **ppbDecData,
       OUT   DRM_DWORD *pcbDecData )
{
    DRM_RESULT dr         = DRM_SUCCESS;
    DRM_BYTE *pbDataBlock = NULL;
    DRM_DWORD cbDataBlock = 0;
    DRM_BYTE *pbSeedMask  = NULL;
    DRM_BYTE *pbDBMask    = NULL;
    DRM_BYTE rgbLHash[ __CB_DECL( SHA_DIGEST_LEN ) ];
    DRM_BYTE cSeed[__CB_DECL(SHA_DIGEST_LEN)];
    DRM_DWORD dwDataBlock = 0;
    DRM_DWORD dwCur = 0;
    DRM_DWORD dwSeed = 0;
    SHA_CONTEXT contextSHA;
        
    ChkArg( cbModulus >= ( 2 * SHA_DIGEST_LEN + 2 ) );

    /*
     * Set up pointer to seed/maskedseed
     */
    dwSeed = 1;
    DRM_BYT_CopyBytes(cSeed, 0, pbEncData, dwSeed, SHA_DIGEST_LEN);

    /*
     * Set up pointer to DB/maskedDB
     */
    dwDataBlock = 1 + SHA_DIGEST_LEN;
    cbDataBlock = cbModulus 
                - 1 
                - SHA_DIGEST_LEN;

    ChkMem(pbDataBlock = OEM_malloc(cbDataBlock));
    DRM_BYT_CopyBytes(pbDataBlock, 0, pbEncData, dwDataBlock, cbDataBlock);

    /*
     * First byte of the EM must be 0
     */
    if( GET_BYTE( pbEncData, 0 ) != 0x00 )
    {
        ChkDR( DRM_E_FAIL );
    }
    
    /*
     * Compute the seed mask and decode the seed
     */
    ChkDR(_GenerateMGF1Mask(pbDataBlock, 
                            cbDataBlock, 
                            SHA_DIGEST_LEN,
                           &pbSeedMask));

    DRM_XOR( cSeed, pbSeedMask, SHA_DIGEST_LEN );

    /*
     * Compute DB Mask from the seed and decode DB
     */
    ChkDR(_GenerateMGF1Mask(cSeed,
                            SHA_DIGEST_LEN,
                            cbDataBlock,
                           &pbDBMask));

    DRM_XOR( pbDataBlock, pbDBMask, cbDataBlock );

    /*
     * Compute LHash for empty label and verify that DB starts with LHash
     */

    DRM_SHA_Init( &contextSHA );
    DRM_SHA_Update( NULL, 0, &contextSHA );
    DRM_SHA_Finalize( &contextSHA, rgbLHash );

    if( MEMCMP( rgbLHash, pbDataBlock, SHA_DIGEST_LEN ) != 0 )
    {
      ChkDR( DRM_E_FAIL );
    }
    
    /*
     * Locate a 0x01 value byte to indicate start of original message
     */
     
    dwCur = SHA_DIGEST_LEN;
    while( dwCur < (dwDataBlock + cbDataBlock) 
	   && GET_BYTE(pbDataBlock, dwCur) == 0x00 ) 
    {
        dwCur++;
    }

    if(  dwCur == dwDataBlock + cbDataBlock 
	 || GET_BYTE(pbDataBlock, dwCur) != 0x01 ) 
    {
        ChkDR( DRM_E_FAIL );
    }

    /*
     * Finally, output the decoded message
     */

    dwCur++;     
    *pcbDecData = cbModulus - dwCur - dwDataBlock;
    if( *pcbDecData > 0 ) 
    {
        ChkMem( *ppbDecData = OEM_malloc( *pcbDecData ) );
        DRM_BYT_CopyBytes( *ppbDecData, 0, pbDataBlock, dwCur, *pcbDecData );
    }
    else 
    {
        *ppbDecData = NULL;
    }

    DRM_BYT_CopyBytes( pbEncData, dwSeed, cSeed, 0, SHA_DIGEST_LEN );
    DRM_BYT_CopyBytes( pbEncData, dwDataBlock, pbDataBlock, 0, cbDataBlock );

ErrorExit:
    if( pbSeedMask != NULL ) 
    {
        OEM_free( pbSeedMask );
    }
    if( pbDBMask != NULL ) 
    {
        OEM_free( pbDBMask );
    }
    if (pbDataBlock != NULL )
    {
        OEM_free( pbDataBlock );
    }

    return dr;

}

static DRM_RESULT DrmOAEPEncode(
    IN       DRM_DWORD  cbModulus,
    IN const DRM_BYTE  *pbMsg,
    IN const DRM_DWORD  cbMsg,
       OUT   DRM_BYTE  *pbEncodedMsg )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbMaxMsg     = 0;
    DRM_DWORD cbEncodedMsg = 0;
    DRM_DWORD cbDataBlock  = 0;
    DRM_BYTE *pbDataBlock  = NULL;
    DRM_BYTE *pbDBMask     = NULL;
    DRM_BYTE *pbSeedMask   = NULL;
    SHA_CONTEXT contextSHA;
    DRM_BYTE cSeed[__CB_DECL(SHA_DIGEST_LEN)];
    DRM_BYTE cHash[__CB_DECL(SHA_DIGEST_LEN)];
    DRM_DWORD dwOffset;
    DRM_DWORD dwSeedOffset;
    DRM_DWORD dwDataBlockOffset;
   
    ChkArg( cbModulus >= ( 2 * SHA_DIGEST_LEN + 2 ) );
    ChkArg( pbMsg        != NULL
         && pbEncodedMsg != NULL );

    cbEncodedMsg = cbModulus;
    cbDataBlock  = cbEncodedMsg 
                 - SHA_DIGEST_LEN 
                 - 1;
    cbMaxMsg     = cbDataBlock 
                 - SHA_DIGEST_LEN 
                 - 1;


    ChkArg( cbMsg <= cbMaxMsg );
    
    PUT_BYTE(pbEncodedMsg, 0, 0x00);                 /* Set first byte of EM to 0 */    
    dwSeedOffset = 1;                                /* Set up pointer to the seed/maskedSeed */
    dwOffset = dwDataBlockOffset = dwSeedOffset + SHA_DIGEST_LEN; /* Set up pointer to DB/maskedDB */
       
    /* Compute Hash of the empty Label */
    DRM_SHA_Init( &contextSHA );
    DRM_SHA_Update( NULL, 0, &contextSHA );
    DRM_SHA_Finalize( &contextSHA, cHash );
    DRM_BYT_CopyBytes(pbEncodedMsg, dwOffset, cHash, 0, SHA_DIGEST_LEN);
    dwOffset += SHA_DIGEST_LEN;

    /* Construct PS */
    DRM_BYT_SetBytes(pbEncodedMsg, dwOffset, cbMaxMsg - cbMsg, 0);
    dwOffset += cbMaxMsg - cbMsg;
    
    /* Write the 0x01 value byte to mark start of original message */
    PUT_BYTE(pbEncodedMsg, dwOffset, 0x01);
    dwOffset++;

    /* Copy the original message */
    DRM_BYT_CopyBytes(pbEncodedMsg, dwOffset, pbMsg, 0, cbMsg);
    dwOffset += cbMsg;
    
    /* Generate the seed in DB */
    ChkDR( OEM_GenRandomBytes( cSeed, SHA_DIGEST_LEN ) );
    
    /* Compute the DB Mask from the seed and XOR it with DB */
    ChkDR(_GenerateMGF1Mask(cSeed, 
                            SHA_DIGEST_LEN, 
                            cbDataBlock, 
                            &pbDBMask));

    ChkMem( pbDataBlock = OEM_malloc(cbDataBlock) );
    DRM_BYT_CopyBytes( pbDataBlock, 0, pbEncodedMsg, dwDataBlockOffset, cbDataBlock );
    DRM_XOR( pbDataBlock, pbDBMask, cbDataBlock );
    
    /* Next, compute the seed mask and XOR it with the seed */
    ChkDR(_GenerateMGF1Mask(pbDataBlock, 
                            cbDataBlock, 
                            SHA_DIGEST_LEN, 
                           &pbSeedMask));

    DRM_XOR( cSeed, pbSeedMask, SHA_DIGEST_LEN );
    DRM_BYT_CopyBytes(pbEncodedMsg, dwSeedOffset, cSeed, 0, SHA_DIGEST_LEN);
    DRM_BYT_CopyBytes(pbEncodedMsg, dwDataBlockOffset, pbDataBlock, 0, cbDataBlock);
    
    
ErrorExit:
    OEM_free( pbDBMask );
    OEM_free( pbSeedMask );
    OEM_free( pbDataBlock );
    return dr;
}
    
/*
 * The _DrmRsaProcess function provides common processing for Sign/Verify and Encrypt/Decrypt
 *
 * Parameters:
 *
 *      pKey - Specifies the key to use
 *          NULL indicates that the private key baked into the device should be used
 *
 *      f_pbData - Specifies the data input
 *      f_cbData - Specifies the size (in bytes) of the input data
 *
 *      f_ppbData - Returns a buffer containing processed data
 *          This buffer must be freed using OEM_free()
 *
 *      f_pcbData - Returns the size (in bytes) of the processed data
 *
 * Return Value:
 *
 *  DRM_SUCCESS - Operation completed successfully
 *  DRM_E_OUTOFMEMORY - There is no enough memory to complete the operation
 *  DRM_E_INVALIDARG - One of the arguments is invalid
 */

static DRM_RESULT _DrmRsaProcess(
    IN const DRM_VOID  *f_pvKey,
    IN const DRM_BYTE  *f_pbData,
    IN       DRM_DWORD  f_cbData,
       OUT   DRM_BYTE **f_ppbData,
       OUT   DRM_DWORD *f_pcbData)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE *pbDataOut = NULL;
    DRM_DWORD cbDataOut = 0;
    DRM_BYTE *pbDataInForProcess = NULL;
    enum DRM_RSA_KEY_TYPE kt = DRM_RSA_KEY_TYPE_UNKNOWN;

    /*
     * Determine the size of the working buffer the underlying routines need
     */
    ChkArg(f_ppbData != NULL
        && f_pvKey   != NULL
        && f_pcbData != NULL);

    ChkArg(f_pbData != NULL 
        && f_cbData  > 0);

    
    cbDataOut = OEM_DrmRsaKeySize    (f_pvKey);
    
    kt        = OEM_DrmRsaIdentifyKey(f_pvKey);
    
	
    ChkArg(cbDataOut > 0
        && kt       != DRM_RSA_KEY_TYPE_UNKNOWN);

    /*
    ** Allocate working buffers
    */

    ChkMem( pbDataOut = OEM_malloc( cbDataOut * 2 ) );

    MEMSET( pbDataOut, 0, cbDataOut * 2 );

    pbDataInForProcess = pbDataOut + __CB_DECL(cbDataOut);

    /*
     * Copy the input data into the larger working buffer
     */

    DRMASSERT(f_cbData <= cbDataOut);
    ChkArg   (f_cbData <= cbDataOut);

    MEMCPY( pbDataInForProcess, f_pbData, f_cbData );
    /*
     * Call the underlying routines
     */
    
    if (kt == DRM_RSA_KEY_TYPE_PUBLIC)
    {
        ChkFAIL( OEM_DrmRsaEncPublic( (DRM_RSA_PUBLIC_KEY *)f_pvKey,
                                       pbDataInForProcess,
                                       pbDataOut ) );
    }
    else
    {
        ChkFAIL( OEM_DrmRsaDecPrivate( (DRM_RSA_PRIVATE_KEY *)f_pvKey,
                                        pbDataInForProcess,
                                        pbDataOut ) );
    }

    /*
     * Success
     */
    *f_ppbData = pbDataOut;
    *f_pcbData = cbDataOut;
    pbDataOut   = NULL;

ErrorExit:

    SAFE_OEM_FREE(pbDataOut);

    return dr;
}

#define CB_ZERO_PADDING 8

static DRM_RESULT _PSSVerify(
    IN const DRM_BYTE      *f_pbData,
    IN const DRM_SUBSTRING *f_pdasstrData,
    IN       DRM_BYTE      *f_pbEncoding,
    IN       DRM_DWORD      f_cbEMBits)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbEM         = 0;
    DRM_DWORD cbDB         = 0;
    DRM_DWORD cbMPrime     = 0;
    DRM_DWORD cbZeroBits   = 0;
    DRM_DWORD i            = 0;
#if SIXTEEN_BIT_ADDRESSING
    DRM_DWORD ichData      = 0;
    DRM_DWORD cchData      = 0;
    DRM_BYTE pbTemp[__CB_DECL(SHA_DIGEST_LEN)];
    DRM_BYTE *pbTemp2 = NULL;
#else
    DRM_BYTE *pbMPrimeHash = NULL;
#endif /* SIXTEEN_BIT_ADDRESSING */
    DRM_BYTE *pbDB         = NULL;
    DRM_BYTE *pbMPrime     = NULL;
    DRM_BYTE *pbSalt       = NULL;
    DRM_BYTE *pbCurr       = NULL;
    DRM_BYTE *pbDBMask     = NULL;
    DRM_BYTE  bMask        = 0x00;
    DRM_BYTE  rgbMPrimeHash [__CB_DECL(SHA_DIGEST_LEN)];
    SHA_CONTEXT contextSHA   = { 0 };
    const DRM_DWORD cbSalt = 0;

    cbEM = (f_cbEMBits % BITS_PER_STANDARD_BYTE == 0)
         ? (f_cbEMBits / BITS_PER_STANDARD_BYTE)
         : (f_cbEMBits / BITS_PER_STANDARD_BYTE) + 1;

    cbZeroBits = (BITS_PER_STANDARD_BYTE * cbEM) - f_cbEMBits;

    ChkArg(cbEM >= SHA_DIGEST_LEN + cbSalt + 2);

    /*
    ** Verify last bit of EM
    */

    ChkArg(GET_BYTE(f_pbEncoding, cbEM - 1) == 0xBC);

    /*
    ** Generate partial M'. We don't yet have the salt so leave it empty
    */

    cbMPrime = BITS_PER_STANDARD_BYTE + SHA_DIGEST_LEN + cbSalt;
    ChkMem(pbMPrime = OEM_malloc(cbMPrime));

    pbCurr = pbMPrime;
    ZEROMEM(pbCurr, CB_ZERO_PADDING);     /* 8-bytes of zero padding*/
    pbCurr += __CB_DECL(CB_ZERO_PADDING); /* OK; always even */

    DRM_SHA_Init  (&contextSHA);                  /* Original message hash */
    DRM_SHA_UpdateOffset(f_pbData, f_pdasstrData->m_ich, f_pdasstrData->m_cch, &contextSHA);
    DRM_SHA_Finalize (&contextSHA, pbCurr);

    pbCurr += __CB_DECL(SHA_DIGEST_LEN);

    if (cbSalt > 0)            /* Remember pointer to Salt: fill this later */
    {
        pbSalt = pbCurr;
    }

    /*
    ** Set up DB and Hash(M') in EM
    */

    cbDB = cbEM - SHA_DIGEST_LEN - 1;
    pbDB = f_pbEncoding;

#if SIXTEEN_BIT_ADDRESSING
    DRM_BYT_CopyBytes(pbTemp, 0, pbDB, cbDB, SHA_DIGEST_LEN);
#else
    pbMPrimeHash = pbDB + __CB_DECL(cbDB);
#endif
    
    /*
    ** Check that the requisite leftmost bits of DB are 0
    */

    bMask = (DRM_BYTE)( 0xFF << (BITS_PER_STANDARD_BYTE - cbZeroBits) );
    
    ChkArg((GET_BYTE(pbDB, 0) & bMask) == 0);

    /*
    ** Compute DBMask and extract DB
    */
#if SIXTEEN_BIT_ADDRESSING
    ChkDR(_GenerateMGF1Mask(pbTemp,
                            SHA_DIGEST_LEN, 
                            cbDB, 
                           &pbDBMask));
#else
    ChkDR(_GenerateMGF1Mask(pbMPrimeHash, 
                            SHA_DIGEST_LEN, 
                            cbDB, 
                           &pbDBMask));
#endif
    DRM_XOR(pbDB, pbDBMask, cbDB);

    PUT_BYTE( pbDB, 0, (DRM_BYTE)(GET_BYTE(pbDB, 0) & (0xFF >> cbZeroBits)));

    /*
    ** Verify that bytes before the salt are all zero followed by 0x01
    */
    
    for (i = 0; i < cbDB - cbSalt - 1; i++)
    {
        if (GET_BYTE(pbDB, i) != 0)
        {
            ChkDR(DRM_E_FAIL);
        }
    }

    if (GET_BYTE(pbDB, cbDB - cbSalt - 1) != 0x01)
    {
        ChkDR(DRM_E_FAIL);
    }

    /*
    ** Fill the salt in M' now, compute Hash(M') and check against the hash in EM
    */
    
    DRM_BYT_CopyBytes(pbSalt,
                      0, 
                      pbDB, 
                      cbDB - cbSalt, 
                      cbSalt);

    DRM_SHA_Init  (&contextSHA);
    DRM_SHA_Update(pbMPrime, cbMPrime, &contextSHA);
    DRM_SHA_Finalize (&contextSHA, rgbMPrimeHash);

    if (DRM_BYT_CompareBytes(pbDB, cbDB, rgbMPrimeHash, 0, SHA_DIGEST_LEN) != 0)
    {
        ChkDR(DRM_E_FAIL);
    }

ErrorExit:

    SAFE_OEM_FREE(pbMPrime);
    SAFE_OEM_FREE(pbDBMask);

    return dr;
}

static DRM_RESULT _PSSEncode(
    IN const DRM_BYTE      *f_pbData,
    IN const DRM_SUBSTRING *f_pdasstrData,
    IN DRM_DWORD            f_cbEMBits,
    OUT DRM_BYTE           *f_pbEncodedMsg,
    IN const DRM_DWORD      f_cbEncodedMsg)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbEM         = 0;
#if SIXTEEN_BIT_ADDRESSING
    DRM_DWORD ichData      = 0;
    DRM_DWORD cchData      = 0;
#endif
    DRM_BYTE *pbDB         = NULL;
    DRM_DWORD cbDB         = 0;
    DRM_BYTE *pbMHash      = NULL;
    DRM_BYTE *pbMPrime     = NULL;
    DRM_DWORD cbMPrime     = 0;
    DRM_DWORD cbZeroBits   = 0;
    DRM_BYTE *pbMPrimeHash = NULL;
    DRM_BYTE *pbCurr       = NULL;
    DRM_BYTE *pbDBMask     = NULL;
    SHA_CONTEXT contextSHA = { 0 };

    cbEM = (f_cbEMBits % BITS_PER_STANDARD_BYTE == 0)
         ? (f_cbEMBits / BITS_PER_STANDARD_BYTE)
         : (f_cbEMBits / BITS_PER_STANDARD_BYTE) + 1;

    cbZeroBits = (BITS_PER_STANDARD_BYTE * cbEM) - f_cbEMBits;

    ChkArg(cbEM >= SHA_DIGEST_LEN + 2 
        && cbEM == f_cbEncodedMsg);

    pbDB = f_pbEncodedMsg;
    cbDB = cbEM - SHA_DIGEST_LEN - 1;  
    pbMPrimeHash = pbDB + cbDB;

    /*
    ** Generate M' and compute its hash
    */

    cbMPrime = CB_ZERO_PADDING + SHA_DIGEST_LEN;
    ChkMem(pbMPrime = OEM_malloc(cbMPrime));

    pbCurr = pbMPrime;
    ZEROMEM(pbCurr, CB_ZERO_PADDING);
    pbCurr += __CB_DECL(CB_ZERO_PADDING); /* 16-bit safe: CB_ZERO_PADDING always even */

    DRM_SHA_Init  (&contextSHA);

#if SIXTEEN_BIT_ADDRESSING
    cchData = f_pdasstrData->m_cch;
    ichData = f_pdasstrData->m_ich;

    if (ISODD(ichData))
    {
        DRM_BYTE b = GET_BYTE(f_pbData, ichData);

        DRM_SHA_Update(&b, 1, &contextSHA);
        ichData++;
        cchData--;
    }
    DRM_SHA_Update(((DRM_BYTE *) f_pbData) + __CB_DECL(ichData), cchData, &contextSHA);
#else
    DRM_SHA_Update(((DRM_BYTE *) f_pbData) + f_pdasstrData->m_ich, f_pdasstrData->m_cch, &contextSHA);
#endif

    DRM_SHA_Finalize (&contextSHA, pbCurr);
    pbMHash = pbCurr;
    pbCurr += __CB_DECL(SHA_DIGEST_LEN); /* 16-bit safe: SHA_DIGEST_LEN always even */

    /*
    ** Calculate Hash(M')
    */

    DRM_SHA_Init  (&contextSHA);
    DRM_SHA_Update(pbMPrime, cbMPrime, &contextSHA);
    DRM_SHA_Finalize (&contextSHA, pbMPrimeHash);

    pbCurr = pbDB;
    ZEROMEM(pbCurr, cbDB - 1);

    PUT_BYTE(pbCurr, cbDB - 1, 0x01); /* 0x01 byte separating padding and salt */

    ChkDR(_GenerateMGF1Mask(pbMPrimeHash, 
                            SHA_DIGEST_LEN, 
                            cbDB, 
                           &pbDBMask));

    DRM_XOR(pbDB, pbDBMask, cbDB);

    pbDB [0] &= (0xFF >> cbZeroBits);

    PUT_BYTE(f_pbEncodedMsg, cbEM - 1, 0xBC);

    /*
    ** Output the digest if requested
    */

ErrorExit:

    SAFE_OEM_FREE(pbMPrime);
    SAFE_OEM_FREE(pbDBMask);

    return dr;
}


/*
 * The DrmRsaOaepDecrypt function decrypts a cipher text that was encrypted 
 * using PKCS #1 RSAES-OAEP v2.1. MGF1 is used as the mask generation function
 * and SHA1 is the hashing algorithm.
 *
 * This version of OAEP decrypt uses a "Label" of an empty string.
 *
 * Parameters:
 *
 *      pPrivateKey - Specifies an RSA private key (as returned from DrmRsaSetPrivateKey)
 *          NULL indicates that the private key baked into the device should be used
 *
 *      pbCiphertext - Specifies the cipher text to be decrypted
 *
 *      cbCiphertext - Specifies the size (in bytes) of the cipher text.
 *          This size must be the modulus length of the passed in RSA private key.
 *          If not, DRM_E_INVALIDARG is returned.
 *
 *      ppbPlaintext - Returns a buffer containing the resulting plain text
 *          The returned buffer must be freed using OEM_free()
 *
 *      pcbPlaintext - Returns the size (in bytes) of the plain text
 *
 * Return Value:
 *  DRM_SUCCESS - Operation completed successfully
 *  DRM_E_OUTOFMEMORY - There is no enough memory to complete the operation
 *  DRM_E_INVALIDARG - The passed in cipher text is the wrong size
 */

DRM_RESULT DRM_API DrmRsaOaepDecrypt(
    IN DRM_RSA_PRIVATE_KEY *pPrivateKey,
    IN DRM_BYTE            *pbCiphertext,
    IN       DRM_DWORD            cbCiphertext,
       OUT   DRM_BYTE           **ppbPlaintext,
       OUT   DRM_DWORD           *pcbPlaintext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbModulus   = 0;
    DRM_BYTE *pbData      = NULL;
    DRM_BYTE *pbTempBuff  = NULL;
    DRM_BYTE *pbDecrypted = NULL;
    DRM_DWORD cbDecrypted = 0;
#if RSA_REVERSE_OS2IP == 1
    DRM_DWORD i           = 0;
#endif  /* RSA_REVERSE_OS2IP */

    ChkArg( pbCiphertext != NULL 
         && ppbPlaintext != NULL
         && pcbPlaintext != NULL );
    
    /*
     * Ensure the cipher text is the right size
     *
     * This is the correct test for RSA OEAP
     */

    cbModulus = OEM_DrmRsaModulusSize( pPrivateKey );

    ChkArg( cbModulus == cbCiphertext );

    /*
     * Perform OS2IP on encrypted data if required
     */

#if RSA_REVERSE_OS2IP == 1

#if TARGET_LITTLE_ENDIAN

    pbTempBuff = OEM_malloc( cbModulus );
    ChkMem( pbTempBuff );

    for( i = 0; i < cbModulus; i++ )
    {
        PUT_BYTE( pbTempBuff, i, GET_BYTE( pbCiphertext, (cbModulus - 1) - i ) );
    }

    pbData = pbTempBuff;

#else

    pbData = pbCiphertext;

#endif

#else   /* RSA_REVERSE_OS2IP */

    pbData = pbCiphertext;

#endif  /* RSA_REVERSE_OS2IP */

    /*
     * Decrypt the buffer with the private key
     */

    ChkDR(_DrmRsaProcess(pPrivateKey, 
                         pbData, 
                         cbModulus, 
                        &pbDecrypted, 
                        &cbDecrypted));
    
    /*
     * Perform I2OSP on decrypted data if required
     */

#if RSA_REVERSE_OS2IP == 1

#if TARGET_LITTLE_ENDIAN

    for( i = 0; i < cbModulus; i++ )
    {
        PUT_BYTE( pbTempBuff, i, GET_BYTE( pbDecrypted, (cbModulus - 1) - i ) );
    }

    pbData = pbTempBuff;

#else

    pbData = pbDecrypted;

#endif

#else   /* RSA_REVERSE_OS2IP */

    pbData = pbDecrypted;

#endif  /* RSA_REVERSE_OS2IP */

    /*
     * Decode EM and hand out
     */

    ChkDR( DrmOAEPDecode( cbModulus, pbData, ppbPlaintext, pcbPlaintext ) );

ErrorExit:

    if ( pbTempBuff != NULL ) 
    {
        OEM_free( pbTempBuff );
    }
    if ( pbDecrypted != NULL ) 
    {
        OEM_free( pbDecrypted );
    }

    return dr;
}

DRM_RESULT DRM_API DrmRsaOaepEncrypt(
    IN DRM_RSA_PUBLIC_KEY *pPublicKey,
    IN DRM_BYTE           *pbPlaintext,
    IN       DRM_DWORD           cbPlaintext,
       OUT   DRM_BYTE          **ppbCiphertext,
       OUT   DRM_DWORD          *pcbCiphertext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbModulus = 0;
    DRM_BYTE *pbEncodedData = NULL;
    DRM_BYTE *pbEncryptedData = NULL;
    DRM_DWORD cbEncryptedData = 0;
    DRM_BYTE *pbDataOut = NULL;
    DRM_DWORD i = 0;

    ChkArg( pPublicKey    != NULL 
         && pbPlaintext   != NULL
         && cbPlaintext    > 0 
         && ppbCiphertext != NULL
         && pcbCiphertext != NULL );
    
    /*
     * Ensure the cipher text is the right size
     */

    cbModulus = OEM_DrmRsaModulusSize( pPublicKey );
    ChkArg( cbModulus > 0);
    
    /* Allocate buffer to accomodate EM and OS2IP(EM) */
    ChkMem( pbEncodedData = OEM_malloc( 2 * cbModulus ) );

    /* Compute EM */
    ChkDR( DrmOAEPEncode( cbModulus,
                          pbPlaintext, 
                          cbPlaintext, 
                          pbEncodedData + __CB_DECL(cbModulus)));

#if RSA_REVERSE_OS2IP == 1

    /* Perform OS2IP(EM): Reverse EM */
    for( i = 0; i < cbModulus; i++ )
    {
        PUT_BYTE(pbEncodedData, i,  GET_BYTE(pbEncodedData, 2*cbModulus - 1 - i));
    }

#else   /* RSA_REVERSE_OS2IP */

    for( i = 0; i < cbModulus; i++ )
    {
        PUT_BYTE(pbEncodedData, i, GET_BYTE(pbEncodedData, cbModulus + i));
    }

#endif  /* RSA_REVERSE_OS2IP */

    /* Encrypt using the public key */
    ChkDR( _DrmRsaProcess(pPublicKey, 
                          pbEncodedData, 
                          cbModulus, 
                         &pbEncryptedData, 
                         &cbEncryptedData));

    /*
    ** Compute I2OSP for encrypted message: reverse encrypted
    ** message and hand out
    */
    ChkMem( pbDataOut = OEM_malloc( cbModulus ) );

#if RSA_REVERSE_OS2IP == 1

    for( i = 0; i < cbModulus; i++ )
    {
        pbDataOut[ i ] = pbEncryptedData[ cbModulus - 1 - i ];
    }

#else   /* RSA_REVERSE_OS2IP */

    for( i = 0; i < cbModulus; i++ )
    {
        PUT_BYTE(pbDataOut, i, GET_BYTE(pbEncryptedData, i ) );
    }

#endif  /* RSA_REVERSE_OS2IP */

    *ppbCiphertext = pbDataOut;
     pbDataOut     = NULL;
    *pcbCiphertext = cbModulus;

ErrorExit:
    OEM_free( pbEncodedData );
    OEM_free( pbEncryptedData );
    SAFE_OEM_FREE( pbDataOut );

    return dr;
}

/*****************************************************************************
** Function: DrmRsaSign
**
** Synopsis: sign the given data with the given privkey and return an 
**           allocated signature.  
**
:* Caveat:   caller is responsible for releasing the buffer returned in 
**           f_ppbSignature
**
** Arguments:
**           [f_pkeyPrivate]
**           [f_pbData]
**           [f_pdasstr] 
**           [f_ppbSignature]
**           [f_pcbSignature]
*****************************************************************************/

DRM_RESULT DRM_API DrmRsaSign(
       IN  DRM_RSA_PRIVATE_KEY *f_pkeyPrivate,
       IN  DRM_BYTE            *f_pbData,
       IN  DRM_SUBSTRING       *f_pdasstr, 
       OUT DRM_BYTE           **f_ppbSignature,
       OUT DRM_DWORD           *f_pcbSignature)

{
    DRM_RESULT dr              = DRM_SUCCESS;
    DRM_DWORD  cbModulus       = 0;
    DRM_BYTE  *pbDataEncoded   = NULL;
    DRM_BYTE  *pbDataEncrypted = NULL;
    DRM_DWORD  cbDataEncrypted = 0;
    DRM_BYTE  *pbDataOut       = NULL;
    DRM_DWORD  i               = 0;

    ChkArg(f_pbData        != NULL 
        && f_ppbSignature  != NULL
        && f_pcbSignature  != NULL
        && f_pdasstr       != NULL
        && f_pdasstr->m_cch > 0);

    ChkDR(OEM_DrmRsaParsePrivateKey(f_pkeyPrivate, NULL, NULL, &cbModulus, NULL, NULL));
 
    ChkArg(cbModulus > 0);

    ChkMem(pbDataEncoded = OEM_malloc(2 * cbModulus));

    ZEROMEM(pbDataEncoded, 2 * cbModulus);

    ChkDR(_PSSEncode(f_pbData, 
                     f_pdasstr, 
                    (cbModulus * BITS_PER_STANDARD_BYTE) - 1, 
                     pbDataEncoded + __CB_DECL(cbModulus), 
                     cbModulus));

    for (i = 0; i < cbModulus; i++)
    {
        PUT_BYTE(pbDataEncoded, i, GET_BYTE(pbDataEncoded, ((2 * cbModulus) - 1 - i)));
    }

    ChkDR(_DrmRsaProcess(f_pkeyPrivate,
                         pbDataEncoded,
                         cbModulus,
                        &pbDataEncrypted,
                        &cbDataEncrypted));

    ChkMem(pbDataOut = OEM_malloc(cbModulus));

    for (i = 0; i < cbModulus; i++)
    {
        PUT_BYTE(pbDataOut, i, GET_BYTE(pbDataEncrypted, (cbModulus - 1 - i)));
    }

    *f_ppbSignature = pbDataOut;
    *f_pcbSignature = cbModulus;
    pbDataOut = NULL;
    
ErrorExit:

    SAFE_OEM_FREE(pbDataOut);
    SAFE_OEM_FREE(pbDataEncrypted);
    SAFE_OEM_FREE(pbDataEncoded);

    return dr;
}

DRM_RESULT DRM_API DrmRsaVerify(
    IN const DRM_CHAR           *f_pszBase,
    IN       DRM_SUBSTRING      *f_pdasstrData,
    IN       DRM_RSA_PUBLIC_KEY *f_ppubkey,
    IN const DRM_BYTE           *f_pbSignature,
    IN const DRM_DWORD           f_cbSignature)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbModulus       = 0;
    DRM_BYTE  *pbDataBuff      = NULL;
    DRM_BYTE  *pbDecryptedData = NULL;
    DRM_DWORD  cbDecryptedData = 0;
#if RSA_REVERSE_OS2IP == 1
    DRM_DWORD  i               = 0;
#endif  /* RSA_REVERSE_OS2IP */
    const DRM_BYTE *pbDataIn   = (const DRM_BYTE *) f_pszBase;

    ChkArg(f_pszBase     != NULL 
        && f_pdasstrData != NULL
        && f_pbSignature != NULL
        && f_pdasstrData->m_cch > 0);

    ChkDR(OEM_DrmRsaParsePublicKey(f_ppubkey, NULL, NULL, &cbModulus));

    /*
    ** Signed data must be equal in length to the modulus
    */

	if(!(cbModulus > 0 && cbModulus == f_cbSignature))
    {
        TRACE(("!(cbModulus > 0 && cbModulus == f_cbSignature): cbModulus = %ld; f_cbSignature = %ld\n", cbModulus, f_cbSignature));
    }
    ChkArg(cbModulus  > 0
        && cbModulus == f_cbSignature);

    /*
    ** Perform OS2IP on the signature: reverse the signature
    */
    
#if RSA_REVERSE_OS2IP == 1

    ChkMem(pbDataBuff = OEM_malloc(cbModulus));

    for (i = 0; i < cbModulus; i++)
    {
        PUT_BYTE(pbDataBuff, i, GET_BYTE(f_pbSignature, cbModulus - 1 - i));
    }

#else   /* RSA_REVERSE_OS2IP */

    pbDataBuff = (DRM_BYTE*)f_pbSignature;

#endif  /* RSA_REVERSE_OS2IP */

    /*
    ** Decrypt
    */
    ChkDR(_DrmRsaProcess(f_ppubkey,
                         pbDataBuff,
                         cbModulus,
                        &pbDecryptedData,
                        &cbDecryptedData));

    /* Perform I2OSP on the decrypted data to get EM: reverse 
    ** decrypted Data
    */

#if RSA_REVERSE_OS2IP == 1

    for (i = 0; i < cbModulus; i++)
    {
        PUT_BYTE(pbDataBuff, i, GET_BYTE(pbDecryptedData, cbModulus - 1 - i));
    }

#else   /* RSA_REVERSE_OS2IP */

    pbDataBuff = pbDecryptedData;

#endif  /* RSA_REVERSE_OS2IP */

    /* Verify EM 
    */
    ChkDR(_PSSVerify(pbDataIn, 
                     f_pdasstrData, 
                     pbDataBuff, 
                    (cbModulus * BITS_PER_STANDARD_BYTE) - 1));

ErrorExit:

    SAFE_OEM_FREE(pbDecryptedData);
#if RSA_REVERSE_OS2IP == 1
    SAFE_OEM_FREE(pbDataBuff);
#endif  /* RSA_REVERSE_OS2IP */

    return( dr );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmsecurestore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSECURESTORE_H__
#define __DRMSECURESTORE_H__

#include <drmtoken.h>

#ifdef __cplusplus
extern "C" {
#endif

#define DRM_SEC_STORE_MAX_SLOT_SIZE     1024 + 2*SIZEOF(DRM_DWORD) + SHA_DIGEST_LEN
#define DRM_MAX_ATTRIBUTES_PER_SST_KEY    25
#define DRM_MAX_ATTRIBUTE_STRING_LENGTH   25

/* 
    Secure store API users.  Please note that there are 3 modes these APIs open the secure store in.
    The standard DRM_SST_OpenKeyTokens API will open and cache a secure store entry.  This data will
    be flushed to disk on a call to DRM_SST_CloseKey.  No file I/O is done in the calls to 
    DRM_SST_GetTokenValue and DRM_SST_SetTokenValue in between.

    Using the enumerator APIs requries that the HDS context the enum is given be kept open the whole 
    time.

    And finally the DRM_SST_GetData & DRM_SST_SetData are direct read/write tunnels to the secure data in
    the secure store.  The secure store opens and closes the HDS during this call so no caching in on.
    If the Token APIs are too restrictive going directly to these raw read/write may be the best option; but these
    should be used with caution.
*/


typedef enum
{
    SECURE_STORE_LICENSE_DATA            = 0x1,
    SECURE_STORE_GLOBAL_DATA             = 0x2,
    SECURE_STORE_REVOCATION_DATA         = 0x3,
    SECURE_STORE_METERING_DATA           = 0x4,
    SECURE_STORE_PLAYLIST_BURNING_DATA   = 0x5,
    SECURE_STORE_DEVICE_REGISTRATION_DATA= 0x6,
    SECURE_STORE_CACHED_CERTIFICATE_DATA = 0x7
} eDRM_SECURE_STORE_TYPE;

#define DRM_SECURE_STORE_NUM_CHILD_NODES 0x10

typedef struct __tagCachedAttribute
{
    TOKEN             TokenDelta;
    DRM_CONST_STRING  dstrAttribute;
    DRM_DWORD         dwFlags;    
    TOKEN            *pTokenValue;  /* Never assume this is aligned before accessing it!!*/
}CachedAttribute;

#define DRM_SST_SLOT_V0_HASH_OFFSET  SIZEOF(DRM_DWORD)
#define DRM_SST_SLOT_V0_DATA_OFFSET (DRM_SST_SLOT_V0_HASH_OFFSET + SHA_DIGEST_LEN)
#define DRM_SST_SLOT_V0_HEADER_SIZE  DRM_SST_SLOT_V0_DATA_OFFSET

#define DRM_SST_SLOT_METADATA_SIZE     SIZEOF(DRM_DWORD)
#define DRM_SST_SLOT_SIZEDATA_SIZE     SIZEOF(DRM_DWORD)
#define DRM_SST_SLOT_HASH_OFFSET  DRM_SST_SLOT_METADATA_SIZE + DRM_SST_SLOT_SIZEDATA_SIZE
#define DRM_SST_SLOT_DATA_OFFSET (DRM_SST_SLOT_HASH_OFFSET + SHA_DIGEST_LEN)
#define DRM_SST_SLOT_HEADER_SIZE  DRM_SST_SLOT_DATA_OFFSET

typedef struct __tagSEC_STORE_CONTEXT
{    
    DRM_HDS_NAMESPACE_CONTEXT oNsContext;
    DRM_HDS_SLOT_CONTEXT      oSlotContext;

    CachedAttribute rgAttributes [DRM_MAX_ATTRIBUTES_PER_SST_KEY];
    DRM_BYTE        rgbSlotData  [__CB_DECL(DRM_SEC_STORE_MAX_SLOT_SIZE)];
    DRM_BYTE        rgbPassword  [__CB_DECL(SHA_DIGEST_LEN)];
        
    DRM_HDS_HASHKEY   rgbKey1;
    DRM_HDS_UNIQUEKEY rgbKey2;
    
    const DRM_HDS_NAMESPACE *pNamespaceId;
    eDRM_SECURE_STORE_TYPE   eType;

    DRM_WORD wNumAttributes;
    DRM_WORD wNumOriginalAttributes;
    DRM_DWORD cbSlotData;
    DRM_DWORD cbSlot;
    DRM_BOOL fInited;
    DRM_BOOL fLocked;
    DRM_DWORD dwSlotVersion;
} DRM_SECSTORE_CONTEXT;


typedef enum _tag_EnumModeSST
{
    eSSTEnumNone=0,       /* no secure store entries found */    
    eSSTEnumFiltered,     /* enum for secure store entries matching given ID */
    eSSTEnumNatural       /* enum all secure store entries */
} _EnumModeSST;

typedef struct _tag_DRM_SECSTOREENUM_CONTEXT
{
    DRM_HDS_ENUM_CONTEXT      oHdsEnumContext;
    DRM_HDS_NAMESPACE_CONTEXT oNsContext;
    DRM_HDS_SLOT_CONTEXT      oSlotContext;
    DRM_BOOL                  fInited;
    _EnumModeSST              eMode;
    eDRM_SECURE_STORE_TYPE    eType;
    DRM_BOOL                  fCurrIsValid;
    DRM_KID                   oCurrKID;
    DRM_LID                   oCurrLID;
} DRM_SECSTOREENUM_CONTEXT;


/* Flags for DRM_SST_OpenKeyTokens */
#define DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS   0x1
#define DRM_SECURE_STORE_OPEN_ALWAYS            0x2
#define DRM_SECURE_STORE_TRUNCATE_SLOT          0x4

#define DRM_SECURE_STORE_VALID_FLAGS    (DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS | DRM_SECURE_STORE_OPEN_ALWAYS)


DRM_RESULT DRM_API DRM_SST_OpenKeyTokens(
    IN OUT   DRM_SECSTORE_CONTEXT   *pbSecureStoreContext,
    IN const DRM_ID                 *pKey1,
    IN const DRM_ID                 *pKey2,
    IN const DRM_BYTE                rgbPassword[__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_DWORD               dwFlags,
    IN       eDRM_SECURE_STORE_TYPE  eType,
    IN       DRM_HDS_CONTEXT        *pcontextHDS);

DRM_RESULT DRM_API DRM_SST_GetTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pbSecureStoreContext,
    IN const DRM_CONST_STRING     *pdstrAttribute,
       OUT   TOKEN                *pToken );

DRM_RESULT DRM_API DRM_SST_SetTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pbSecureStoreContext,
    IN const DRM_CONST_STRING     *pdstrAttribute,
    IN const TOKEN                *pToken );


DRM_RESULT DRM_API DRM_SST_CloseKey( 
    IN       DRM_SECSTORE_CONTEXT *pbSecureStoreContext, 
    IN       DRM_HDS_CONTEXT      *pcontextHDS );

DRM_RESULT DRM_API DRM_SST_OpenAndLockSlot(
    IN          DRM_HDS_CONTEXT        *f_pcontextHDS,
    IN          eDRM_SECURE_STORE_TYPE  f_eType,
    IN  const   DRM_ID                 *f_pKey1,
    IN  const   DRM_ID                 *f_pKey2,
    IN  const   DRM_BYTE                f_rgbPassword[__CB_DECL(SHA_DIGEST_LEN)],
    IN          DRM_DWORD               f_dwFlags,
        OUT     DRM_SECSTORE_CONTEXT   *f_pcontextSST,
        OUT     DRM_DWORD              *f_pcbData );

DRM_RESULT DRM_API DRM_SST_GetLockedData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
       OUT   DRM_BYTE               *f_pbData,
       OUT   DRM_DWORD              *f_pcbData );

DRM_RESULT DRM_API DRM_SST_SetLockedData(
    IN          DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN          DRM_DWORD               f_cbData,
        OUT     DRM_BYTE               *f_pbData );

DRM_RESULT DRM_API DRM_SST_CloseLockedSlot( IN  DRM_SECSTORE_CONTEXT *f_pcontextSST );

DRM_RESULT DRM_API DRM_SST_GetData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN const DRM_ID                 *f_pKey1,
    IN const DRM_ID                 *f_pKey2,
    IN const DRM_BYTE                f_rgbPassword[__CB_DECL(SHA_DIGEST_LEN)],
    IN       eDRM_SECURE_STORE_TYPE  f_eType,
    IN       DRM_HDS_CONTEXT        *f_pcontextHDS,
       OUT   DRM_BYTE               *f_pbData,
       OUT   DRM_DWORD              *f_pcbData );

DRM_RESULT DRM_API DRM_SST_SetData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN const DRM_ID                 *f_pKey1,
    IN const DRM_ID                 *f_pKey2,
    IN const DRM_BYTE                f_rgbPassword [__CB_DECL(SHA_DIGEST_LEN)],
    IN       eDRM_SECURE_STORE_TYPE  f_eType,
    IN       DRM_HDS_CONTEXT        *f_pcontextHDS,
       OUT   DRM_BYTE               *f_pbData,
    IN       DRM_DWORD               f_cbData );


/* Delete an entry from the secure store.  Be careful when this happens -- it could open up the system for 
   replay attacks */
DRM_RESULT DRM_API DRM_SST_DeleteKey(
    IN       DRM_SECSTORE_CONTEXT   *pbSecureStoreContext,
    IN       eDRM_SECURE_STORE_TYPE  eType,
    IN const DRM_ID                 *pid1,
    IN const DRM_ID                 *pid2,
    IN       DRM_HDS_CONTEXT        *pcontextHDS);


DRM_RESULT DRM_API DRM_SST_GetAllData( 
    IN     DRM_SECSTORE_CONTEXT *pbSecureStoreContext,
    OUT    DRM_BYTE             *pbData,
    IN OUT DRM_DWORD            *pcbData );

/* The enumeration APIs work on 2 keys or IDs.  When opening an enumerator the caller should pass in key1 (the first key used 
    calls to DRM_SST_SetData and DRM_SST_OpenKeyTokens.  All entries with this value as the first key will be listed in the
    enumeration.  On calls to DRM_SST_EnumNext the value of key2 will be returned so that the caller can use the combination of
    key1 and key2 to open a unique SST entry. */

DRM_RESULT DRM_API DRM_SST_OpenEnumerator(
    IN        eDRM_SECURE_STORE_TYPE    eType,
    IN  const DRM_ID                   *pKey1,
    OUT       DRM_SECSTOREENUM_CONTEXT *pSecEnumContext,
    IN        DRM_HDS_CONTEXT          *pcontextHDS,
    IN        DRM_BOOL                  fExclusiveLock);

DRM_RESULT DRM_API DRM_SST_EnumNext( 
    IN  DRM_SECSTOREENUM_CONTEXT *pSecEnumContext,
    OUT DRM_ID                   *pKey2,
    OUT DRM_DWORD                *pcbData );
DRM_RESULT DRM_API DRM_SST_EnumLoadCurrent( 
    IN       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    IN OUT   DRM_SECSTORE_CONTEXT     *pcontextSST,
    IN const DRM_BYTE                  rgbPassword[__CB_DECL(SHA_DIGEST_LEN)],
       OUT   DRM_ID                   *pKey2,
    IN OUT DRM_DWORD                  *pcbData);

DRM_RESULT DRM_API DRM_SST_EnumDeleteCurrent( 
    IN       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    IN OUT   DRM_SECSTORE_CONTEXT     *pcontextSST);

DRM_RESULT DRM_API DRM_SST_CreateGlobalStorePassword(
    OUT DRM_BYTE        f_rgbPasswordSST [__CB_DECL(SHA_DIGEST_LEN)],
    IN  DRM_BYTE       *f_pbContextBBX);

DRM_RESULT DRM_API DRM_SST_CreateLicenseStatePassword(
    IN  DRM_LID  *f_plid,
    OUT DRM_BYTE  f_rgbPasswordLST [__CB_DECL(SHA_DIGEST_LEN)],
    IN  DRM_BYTE *f_pbContextBBX);

#ifdef __cplusplus
}
#endif

#endif /* __DRMSECURESTORE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmsha1.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#include <drmcommon.h>
#include <drmsha1.h>
#include <drmbytemanip.h>

/*
	OEMNOTE: There are optimizations that could be done.
	1.  The loop ranges in SHA are static so the loop can be unrolled.  This will make larger code but will be faster.
	2.  If loop is unrolled the ft and K functions can be put inline as to not incur a function call overhead
*/
	
/* These macros are for readability and should make sense when looking at the standard */
#define A 0
#define B 1
#define C 2
#define D 3
#define E 4

/* Define S (circular shift operator) */
#define S ROTATE_LEFT

/******************************************************************************/
static DRM_VOID DRM_API _PackDRMDWORD(
    IN const DRM_DWORD *dwFrom,
    IN       DRM_DWORD  dwCount, 
    OUT      DRM_BYTE  *bOut)
{
	DRM_UINT i = 0;
    DRM_UINT j = 0;
	for(; i<dwCount; i++)
	{
		PUT_BYTE(bOut, j, (DRM_BYTE)((dwFrom[i] >> 24) & 0xff)); j++;
        PUT_BYTE(bOut, j, (DRM_BYTE)((dwFrom[i] >> 16) & 0xff)); j++;
        PUT_BYTE(bOut, j, (DRM_BYTE)((dwFrom[i] >> 8 ) & 0xff)); j++;
        PUT_BYTE(bOut, j, (DRM_BYTE)((dwFrom[i]      ) & 0xff)); j++;
	}
}

/******************************************************************************/

static DRM_VOID DRM_API _GetDRMDWORD(
    OUT      DRM_DWORD *dwTo,
    IN       DRM_DWORD  dwCount,
    IN const DRM_BYTE  *bIn )
{
	DRM_UINT i = 0;
    DRM_UINT j = 0;
	for( ; i < dwCount; i++, j+=4)
	{
        dwTo[i] = ( ( (DRM_DWORD) GET_BYTE(bIn,j)   ) << 24 ) | 
                  ( ( (DRM_DWORD) GET_BYTE(bIn,j+1) ) << 16 ) |
                  ( ( (DRM_DWORD) GET_BYTE(bIn,j+2) ) << 8 )  |
                  (   (DRM_DWORD) GET_BYTE(bIn,j+3) );
	}
}


/******************************************************************************/

static DRM_INT _ft(DRM_INT b, DRM_INT c, DRM_INT d, DRM_INT t)
{
	DRMASSERT(t<80);
	if(t >= 60)
		return (b^c^d);
	if(t>=40)
		return ((b&c)|(b&d)|(c&d));
	if(t>=20)
		return (b^c^d);
	if(t>=0)
		return ((b&c) | ((~b)&d));

	return 0;	/* If valid input we should never hit this */

}

/******************************************************************************/

static DRM_DWORD _K(DRM_SHORT t)
{

	DRMASSERT(t<80);
	if(t >= 60)
		return 0xCA62C1D6;
	if(t>=40)
		return 0x8F1BBCDC;
	if(t>=20)
		return 0x6ED9EBA1;
	if(t>=0)
		return 0x5A827999;

	return 0;	/* If valid input we should never hit this */
}

/******************************************************************************/

/* SHA operates on 512 bit blocks which is 16-dword sized blocks.  (16*32 = 512) */

/**********************************************************************
** Function:		_sha1
**
** Synopsis:	Meat of sha, this is the actual mathematical processing.
**
** Arguments:	[ABCDE] -- current state numbers of sha
**				[bInput] -- 64 byte block to put through the sha process
**
** Returns:		None
**
** Notes:		This version of SHA1 is written to reduce processor instructions
**				but the tradeoff is the 80 DWORD stack buffer.
**
***********************************************************************/
static DRM_VOID _sha1(
    IN       DRM_DWORD ABCDE[5],
    IN const DRM_BYTE  bInput[__CB_DECL(SHA_BLOCK_SIZE)] )
{
    DRM_DWORD Buf2[5];
    DRM_DWORD W[80];
    DRM_SHORT cCount;
    DRM_DWORD TEMP;


    _GetDRMDWORD(W,16,bInput);
    MEMCPY((DRM_BYTE*)Buf2, (DRM_BYTE*)ABCDE, SIZEOF(DRM_DWORD) * 5);
    for(cCount = 16; cCount < 80; cCount++)
    {
        TEMP = W[cCount-3] ^ W[cCount-8] ^ W[cCount-14] ^ W[cCount-16];
        W[cCount] = S(TEMP,1);
    }
    for(cCount = 0; cCount < 80; cCount++ )
    {
        TEMP = S(ABCDE[A],5);
        TEMP += _ft(ABCDE[B],ABCDE[C],ABCDE[D], cCount);
        TEMP += ABCDE[E];
        TEMP += W[cCount];
        TEMP += _K(cCount);
        ABCDE[E] = ABCDE[D];
        ABCDE[D] = ABCDE[C];
        ABCDE[C] = S(ABCDE[B],30);
        ABCDE[B] = ABCDE[A];
        ABCDE[A] = TEMP;
    }
    for (cCount = 0; cCount < 5; cCount++)
    {
        Buf2[cCount] += ABCDE[cCount];
    }
    MEMCPY((DRM_BYTE*)ABCDE, (DRM_BYTE*)Buf2, SIZEOF(DRM_DWORD) * 5);
}

/******************************************************************************/
DRM_VOID DRM_API DRM_SHA_Init(
    IN OUT SHA_CONTEXT* pShaContext )
{
    /*Zero out the buffer*/
	ZEROMEM((DRM_BYTE*)pShaContext, SIZEOF(SHA_CONTEXT));	
	
    /* Set the initial magic numbers */
    pShaContext->ABCDE[A] = 0x67452301;
	pShaContext->ABCDE[B] = 0xEFCDAB89;
	pShaContext->ABCDE[C] = 0x98BADCFE;
	pShaContext->ABCDE[D] = 0x10325476;
	pShaContext->ABCDE[E] = 0xC3D2E1F0;
}

/******************************************************************************/
DRM_VOID DRM_API DRM_SHA_Update(
    IN const DRM_BYTE    *pbData,
    IN       DRM_DWORD    cbData,
    IN OUT   SHA_CONTEXT *pShaContext )
{
    DRM_SHA_UpdateOffset( pbData, 0, cbData, pShaContext );
    
    return;
}

DRM_VOID DRM_API DRM_SHA_UpdateOffset(
    IN const DRM_BYTE    *pbData,
    IN       DRM_DWORD    ibData,
    IN       DRM_DWORD    cbData,
    IN OUT   SHA_CONTEXT *pShaContext )
{
    /* If we aren't a multiple of 64 bytes we should save the last bytes to odr buffer
    ** and sha what is left
    */
    DRM_DWORD dwTempLen;


    /* How many bytes do we have remaining? */
    dwTempLen = pShaContext->dwLowByteCount & (SHA_BLOCK_SIZE - 1);
    pShaContext->dwLowByteCount += cbData;

    if(pShaContext->dwLowByteCount < cbData)
    {
        /* We overflowed and wrapped around.  This means
        ** we need to increment the high order byte counter 
        */
        pShaContext->dwHighByteCount++;
    }

    if (   dwTempLen > 0 
        && cbData   >= (SHA_BLOCK_SIZE - dwTempLen) )
    {
        /* We have enough to complete the last block.  Fill it and sha it */
        DRM_BYT_CopyBytes(pShaContext->bTempBuffer, dwTempLen, pbData, ibData, SHA_BLOCK_SIZE-dwTempLen);
        _sha1(pShaContext->ABCDE,pShaContext->bTempBuffer);        
        ibData += SHA_BLOCK_SIZE - dwTempLen;
        cbData -= SHA_BLOCK_SIZE - dwTempLen;

        dwTempLen = 0;
    }

    /* Sha each portion of the buffer that is big enough */
    while(cbData>=SHA_BLOCK_SIZE)
    {
#if SIXTEEN_BIT_ADDRESSING
        DRM_BYT_CopyBytes(pShaContext->bTempBuffer, 0, pbData, ibData, SHA_BLOCK_SIZE);
        _sha1( pShaContext->ABCDE,pShaContext->bTempBuffer);
#else
        _sha1( pShaContext->ABCDE,pbData + __CB_DECL(ibData));
#endif
        ibData += SHA_BLOCK_SIZE;
        cbData -= SHA_BLOCK_SIZE;
    }

    if(cbData)
    {
        DRM_BYT_CopyBytes(pShaContext->bTempBuffer, dwTempLen, pbData, ibData, cbData);
    }
}

/******************************************************************************/

DRM_VOID DRM_API DRM_SHA_Finalize(
    IN  SHA_CONTEXT *pShaContext,
    OUT DRM_BYTE     rgbDigest[__CB_DECL(SHA_DIGEST_LEN)] )
{
	DRM_DWORD dwTempLen;
	DRM_DWORD dwTotalBitLen[2];
    DRM_BYTE  bPaddingBuffer[__CB_DECL(SHA_BLOCK_SIZE+12)] = {0};	/* Maximum block size we may need. */
		
	/* How many bytes do we need to make a SHA block? */
	dwTempLen = SHA_BLOCK_SIZE - (pShaContext->dwLowByteCount & 63);
	
	/* This is there enough room for the padding?.*/
	if(dwTempLen<=8)
    {
		dwTempLen += SHA_BLOCK_SIZE;
    }
	
	/*dwLowByteCount is the number of bytes so we have to multiply that by 8 to get the number of bits */
	dwTotalBitLen[1] = pShaContext->dwLowByteCount << 3;
	dwTotalBitLen[0] = (pShaContext->dwHighByteCount << 3) | 
						(pShaContext->dwLowByteCount >> 29); /* We could have overflowed so put the extra here */

    PUT_BYTE(bPaddingBuffer, 0, 0x80);	/* We add a 10000000 */ 
	
#if SIXTEEN_BIT_ADDRESSING
    {
        DRM_BYTE rgbTemp[__CB_DECL(2*SIZEOF(DRM_DWORD))];
        /* 
        ** We do the packing to a temporary buffer because the offset into
        ** the padding buffer could be odd, and _PackDRMDWORD doesn't handle
        ** that case
        */
        _PackDRMDWORD(dwTotalBitLen,2,rgbTemp);
        DRM_BYT_CopyBytes( bPaddingBuffer, dwTempLen-8, rgbTemp, 0, 2*SIZEOF(DRM_DWORD) );
    }

#else

    /* Last 2 DWORDS are for the total bit length */
    _PackDRMDWORD(dwTotalBitLen,2,&(bPaddingBuffer[(dwTempLen-8)]));

#endif

	DRM_SHA_Update(bPaddingBuffer, dwTempLen, pShaContext);
	
	/* Extract the digest and save it. */
    _PackDRMDWORD(pShaContext->ABCDE,5,rgbDigest);		
	return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmstkalloc.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmstkalloc.h>

/*
** Push the stack to allocate the requested size of buffer 
*/
DRM_RESULT DRM_API DRM_STK_Alloc(
    IN  DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    IN  DRM_DWORD                    cbSize,
    OUT DRM_VOID                   **ppbBuffer)
{
    DRM_RESULT dr = DRM_E_LOGICERR;
    DRM_DWORD  dwSize = cbSize;

    ChkArg( pContext && ppbBuffer && cbSize );
    
    *ppbBuffer = NULL;
    /* allocate buffer from top of stack */
    if ( ( dwSize % SIZEOF(DRM_DWORD_PTR) )!=0 )
    {
        /* adjust cbSize for alignment of DRM_DWORD_PTR */
        dwSize += SIZEOF(DRM_DWORD_PTR) - ( dwSize % SIZEOF(DRM_DWORD_PTR) );
    }

    if ( (pContext->nStackTop+dwSize+SIZEOF(DRM_DWORD) ) >= pContext->cbStack )
    {
        dr = DRM_E_OUTOFMEMORY;
        goto ErrorExit;
    }

    DRM_BYT_CopyBytes((DRM_BYTE*)pContext->pbStack, pContext->nStackTop, (DRM_BYTE*)&dwSize, 0, SIZEOF(DRM_DWORD));
    *ppbBuffer = pContext->pbStack + ((pContext->nStackTop + SIZEOF(DRM_DWORD))/CB_NATIVE_BYTE);

    pContext->nStackTop += (DRM_DWORD)(dwSize+SIZEOF(DRM_DWORD));
    /*
    TRACE(("Alloc: top=0x%08X  pb=0x%08X  cb=%d\n", pContext->nStackTop, *ppbBuffer, dwSize));
    */
#if DBG
    MEMSET((DRM_BYTE*)*ppbBuffer, 0xa, dwSize);
#endif
    dr = DRM_SUCCESS;

ErrorExit:    
    return dr;
}


/*
** Pop the stack to free the allocated buffer
*/
DRM_RESULT DRM_API DRM_STK_Free(
    IN DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    IN DRM_VOID                    *pbBuffer)
{
    DRM_RESULT dr = DRM_E_LOGICERR;
    DRM_DWORD  dwSize = 0;
    
    if ( pbBuffer == NULL )
    {
        /* pbBuffer is NULL, simply return */
        goto ErrorExit;
    }

    ChkArg( pContext );

    /* verify the buffer with the stack */
    MEMCPY((DRM_BYTE*)&dwSize,(DRM_BYTE*)pbBuffer - sizeof(DRM_DWORD),SIZEOF(DRM_DWORD) );    
    /*
    TRACE((" Free: top=0x%08X  pb=0x%08X  cb=%d\n", pContext->nStackTop, pbBuffer, dwSize));
    */
    if ( ((DRM_BYTE*)pbBuffer+(dwSize/CB_NATIVE_BYTE)) != &pContext->pbStack[(pContext->nStackTop/CB_NATIVE_BYTE)])
    {
        TRACE(("\n\n***  DRM_STK_Free(): heap corrupted ***\n\n"));
        DRMASSERT( FALSE );
        dr = DRM_E_STACK_CORRUPT; /* internal stack corrupted */
        goto ErrorExit;
    }

#if DBG
    /* clear the buffer */
    MEMSET((DRM_BYTE*)pbBuffer-sizeof(DRM_DWORD), 0xb, dwSize+SIZEOF(DRM_DWORD));
#endif

    pContext->nStackTop -= (DRM_DWORD)(dwSize+SIZEOF(DRM_DWORD));
    dr = DRM_SUCCESS;
ErrorExit:    
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmstkalloc.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_STACK_ALLOCATOR__
#define __DRM_STACK_ALLOCATOR__

#ifdef __cplusplus
extern "C" {
#endif

#define DRM_STK_REQUIRED(cbData) \
    (   (cbData) \
    +   SIZEOF(DRM_DWORD) \
    +   ( ((cbData) % SIZEOF(DRM_DWORD_PTR) == 0) ? (0) : (SIZEOF(DRM_DWORD_PTR) - ((cbData) % SIZEOF(DRM_DWORD_PTR))) ) )  

typedef struct __tagDRM_STACK_ALLOCATOR_CONTEXT
{
    DRM_DWORD nStackTop;    /* position of stack top */
    DRM_DWORD cbStack;      /* size of stack */
    DRM_BYTE *pbStack;      /* stack buffer */
} DRM_STACK_ALLOCATOR_CONTEXT;

/*********************************************************************
**
**  Function:  DRM_STK_Free
**
**  Synopsis:  Free a buffer that was allocated using DRM_STK_Alloc.
**
**  Arguments:  
**     [pContext] -- Stack allcator context that was used to allocate the pbBuffer parameter
**     [pbBuffer] -- Pointer returned from a call to DRM_STK_Alloc
**
**  Notes:  Pointers must be freed in LIFO order ( just like a stack ).
**
*********************************************************************/
DRM_RESULT DRM_API DRM_STK_Free(
    IN DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    IN DRM_VOID                    *pbBuffer);

#define SAFE_STK_FREE(pdsac,pv)    \
    if (pv != NULL)                \
    {                              \
        DRM_STK_Free (pdsac, pv);  \
        pv = NULL;                 \
    }

/*********************************************************************
**
**  Function:  DRM_STK_Alloc
**
**  Synopsis:  Allocates a buffer from a give stack context
**
**  Arguments:  
**     [pContext] -- Stack allocator context to allocate from
**     [cbSize] -- Size of the buffer needed
**     [ppbBuffer] -- Pointer to pointer to hold the new memory offset.
**
**  Notes:  Pointers must be freed in LIFO order ( just like a stack ).
**
*********************************************************************/
DRM_RESULT DRM_API DRM_STK_Alloc(
    IN  DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    IN  DRM_DWORD                    cbSize,
    OUT DRM_VOID                   **ppbBuffer);


#ifdef __cplusplus
}
#endif

#endif /* __DRM_STACK_ALLOCATOR__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmsha1.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMSHA_1_H__
#define __DRMSHA_1_H__

#ifdef __cplusplus
extern "C" {
#endif


#define SHA_DIGEST_LEN 20	/*5 32-bit numbers which is 20 BYTES */
#define SHA_BLOCK_SIZE 64	/*Sha operates on 64 BYTE blocks */

#define SHA_B64ENC_DIGEST_LEN CCH_BASE64_EQUIV( SHA_DIGEST_LEN )


/**********************************************************************
** Struct:      SHA_CONTEXT
**
** Synopsis:    Maintains the running state of a sha operations
**
** Members:		[dwHighByteCount] -- High order of the byte count
**				[dwLowByteCount] -- Low order of the byte count
**				[bTempBuffer] -- Maximum temp buffer we may need 
**				[ABCDE] -- current SHA state
**
***********************************************************************/
typedef struct __tagSHA_CONTEXT
{
	DRM_DWORD dwHighByteCount;
	DRM_DWORD dwLowByteCount;	
	DRM_BYTE  bTempBuffer[__CB_DECL(SHA_BLOCK_SIZE)];
	DRM_DWORD ABCDE[5];
} SHA_CONTEXT;


/*********************************************************************
**
**  Function:  DRM_SHA_Init
**
**  Synopsis:  Start a clean new instance of Sha
**
**  Arguments:  
**     [pShaContext] -- Pointer to context to hold current state of sha
**
**  Returns:  None
**
*********************************************************************/

DRM_VOID DRM_API DRM_SHA_Init(
    IN OUT SHA_CONTEXT* pShaContext );

/*********************************************************************
**
**  Function:  DRM_SHA_Update
**
**  Synopsis:  
**
**  Arguments:  
**     [pbData] -- array of bytes to add to the sha computation
**     [cbData] -- length of pbData in bytes
**     [pShaContext] -- running sha context
**
**  Returns:  
**
*********************************************************************/

DRM_VOID DRM_API DRM_SHA_Update(
    IN const DRM_BYTE    *pbData,
    IN       DRM_DWORD    cbData,
    IN OUT   SHA_CONTEXT *pShaContext );


DRM_VOID DRM_API DRM_SHA_UpdateOffset(
    IN const DRM_BYTE    *pbData,
    IN       DRM_DWORD    ibData,
    IN       DRM_DWORD    cbData,
    IN OUT   SHA_CONTEXT *pShaContext );

/*********************************************************************
**
**  Function:  DRM_SHA_Finalize
**
**  Synopsis:  
**
**  Arguments:  
**     [pShaContext] -- current running sha context
**     [ShaDigest] -- resultant sha digest from sha operation
**
**  Returns:  None
**
*********************************************************************/

DRM_VOID DRM_API DRM_SHA_Finalize(
    IN     SHA_CONTEXT *pShaContext,
       OUT DRM_BYTE     rgbDigest[__CB_DECL(SHA_DIGEST_LEN)] );

#ifdef __cplusplus
}
#endif


#endif /* __DRMSHA_1_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmsyncstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_SYNC_STORE__
#define __DRM_SYNC_STORE__

#ifdef __cplusplus
extern "C" 
{
#endif

typedef struct _tagSyncContext
{    
    DRM_HDS_SLOT_CONTEXT      contextHDSSlot;
    DRM_HDS_NAMESPACE_CONTEXT contextNameSpace;
    DRM_HDS_CONTEXT          *pcontextHDSStorage;
    DRM_BOOL                  fInited;
} DRM_SYNC_CONTEXT_PRIVATE;

typedef struct _tagSyncListEntry
{
    DRM_BOOL fIsValid;
    DRM_KID  kid;
} SyncListEntry;

typedef struct _tagSyncEnumContext
{
    DRM_SYNC_CONTEXT_PRIVATE *pcontextSync;
    DRM_HDS_ENUM_CONTEXT      contextHDSEnum;
    DRM_HDS_SLOT_CONTEXT      contextHDSSlot;
    DRM_BOOL                  fInited,
                              fAny;
    SyncListEntry             itemSync;
} DRM_SYNC_ENUM_CONTEXT_PRIVATE;


/* opaque versions of contexts, corresponding to those actually declared in drmsyncstore.c */

typedef struct __tagDRM_SYNC_CONTEXT
{
    DRM_BYTE rgbOpaqueData [__CB_DECL(SIZEOF(DRM_SYNC_CONTEXT_PRIVATE))];
} DRM_SYNC_CONTEXT;

typedef struct __tagDRM_SYNC_ENUM_CONTEXT
{
    DRM_BYTE rgbOpaqueData [__CB_DECL(SIZEOF(DRM_SYNC_ENUM_CONTEXT_PRIVATE))];
} DRM_SYNC_ENUM_CONTEXT;

/* low-level access to the sync store */

/**********************************************************************
 *				     PUBLIC FUNCTION DRM_SNC_OpenStore
 **********************************************************************/

DRM_RESULT DRM_API DRM_SNC_OpenStore  (
    IN  DRM_HDS_CONTEXT  *f_pcontextHDSIn,
    OUT DRM_SYNC_CONTEXT *f_pcontextSyncOut);

/**********************************************************************
 *				     PUBLIC FUNCTION DRM_SNC_CloseStore
 **********************************************************************/

DRM_RESULT DRM_API DRM_SNC_CloseStore (
    IN  DRM_SYNC_CONTEXT *f_pcontextSyncIn);


/**********************************************************************
 *				    PUBLIC FUNCTION DRM_SNC_InitEnum
 ***********************************************************************/

DRM_RESULT DRM_API DRM_SNC_InitEnum   (
    IN  DRM_SYNC_CONTEXT       *f_pcontextSyncIn, 
    OUT DRM_SYNC_ENUM_CONTEXT  *f_pcontextSyncEnumOut);

DRM_RESULT DRM_API DRM_SNC_EnumNext   (
    IN  DRM_SYNC_ENUM_CONTEXT  *f_pcontextSYNEnum, 
    OUT DRM_KID                *f_pkid,
    OUT DRM_HDS_SLOT_HINT      *f_pslotHint);

DRM_RESULT DRM_API DRM_SNC_UpdateKID(
    IN       DRM_SYNC_CONTEXT        *f_pcontextSyncIn, 
    IN       DRM_VIEW_RIGHTS_CONTEXT *f_pcontextViewRightsIn,
    IN const DRM_KID                 *f_pkid);

#define DRM_SYNC_IGNORE_THRESHOLD_PARAMETER	0xFFFFFFFF

/* inner implementations of DRM_Manager-level Sync API */

DRM_RESULT DRM_API DRM_SNC_GenerateSyncChallenge (
    IN     DRM_VIEW_RIGHTS_CONTEXT     *f_pcontextViewRights,
    IN     DRM_HDS_CONTEXT			   *f_pcontextHDS,
    IN     DRM_STACK_ALLOCATOR_CONTEXT *f_pcontextStack,
    IN     DRM_DWORD					f_cMaxCount,
    IN     DRM_DWORD                    f_cMaxHours,
    IN     DRM_DWORD                    f_iKIDStart,
    IN     DRM_DWORD                    f_cKIDs,
       OUT DRM_DWORD                   *f_piKIDNext,
       OUT DRM_DWORD                   *f_pcKIDs,
       OUT DRM_BYTE                    *f_pbChallenge,
    IN OUT DRM_DWORD                   *f_pcbChallenge);


/*********************************************************************
** Function: DRM_SNC_DeleteKID
**
** Synopsis: delete the indicated KID from the sync store; its absense
**           is not an error
**
** Parameters:
**
** [f_pcontextSYN]          -- initialized SYNC context
** [f_pkid]                 -- pointer to KID to be added/updated
**********************************************************************/

DRM_RESULT DRM_API DRM_SNC_DeleteKID(
    IN       DRM_SYNC_CONTEXT *f_pcontextSYN, 
    IN const DRM_KID          *f_pkid);


#ifdef __cplusplus
}
#endif

#endif /* __DRM_SYNC_STORE__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmsyncstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmsyncstore.h>
#include <drmhds.h>


static const DRM_HDS_NAMESPACE g_namespaceSyncStore = 
{ 
    TWO_BYTES('s',  'y'),  TWO_BYTES('n',  'c'),  TWO_BYTES('s',  't'),  TWO_BYTES('o',  'r'), 
    TWO_BYTES('e',  '\0'), TWO_BYTES('\0', '\0'), TWO_BYTES('\0', '\0'), TWO_BYTES('\0', '\0') 
};

extern const DRM_CONST_STRING *g_apdstrActions [1];


/*********************************************************************
** Function: DRM_SNC_DeleteKID
**
** Synopsis: delete the indicated KID from the sync store; its absense
**           is not an error
**
** Parameters:
**
** [f_pcontextSYN]          -- initialized SYNC context
** [f_pkid]                 -- pointer to KID to be added/updated
**********************************************************************/

DRM_RESULT DRM_API DRM_SNC_DeleteKID(
    IN       DRM_SYNC_CONTEXT *f_pcontextSYN, 
    IN const DRM_KID          *f_pkid)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_SYNC_CONTEXT_PRIVATE *pcontextSYN = (DRM_SYNC_CONTEXT_PRIVATE *) f_pcontextSYN;

    ChkArg(f_pcontextSYN != NULL
        && f_pkid        != NULL);

    dr = DRM_HDS_DeleteSlot(&pcontextSYN->contextNameSpace, 
                            f_pkid, 
                            f_pkid,
                            NULL,
                            TRUE);

    if (dr == DRM_E_HDSSLOTNOTFOUND)
    {
        dr = DRM_SUCCESS;
    }
    else
    {
        ChkDR(dr);
    }
    
ErrorExit:
    return dr;
} /* DRM_SNC_DeleteKID */

/**********************************************************************
 *				     PUBLIC FUNCTION DRM_SNC_OpenStore
 **********************************************************************/

DRM_RESULT DRM_API DRM_SNC_OpenStore  (
    IN  DRM_HDS_CONTEXT        *f_pcontextHDS,
    OUT DRM_SYNC_CONTEXT       *f_pcontextSYN)
{
    DRM_RESULT				  dr           =  DRM_SUCCESS;
    DRM_SYNC_CONTEXT_PRIVATE *pcontextSync = (DRM_SYNC_CONTEXT_PRIVATE *) f_pcontextSYN;

    ChkArg (f_pcontextHDS   != NULL
         && f_pcontextSYN != NULL);

    DRMASSERT (SIZEOF (DRM_SYNC_CONTEXT_PRIVATE) <= SIZEOF (DRM_SYNC_CONTEXT));

    /* open the namespace for the Sync Store */    
    ChkDR( DRM_HDS_OpenNamespace( f_pcontextHDS, 
                                  &g_namespaceSyncStore, 
                                  eDRM_HDS_CREATE_IF_NEW | eDRM_HDS_LOCKWAIT,
                                  16,
                                  &pcontextSync->contextNameSpace ) );
    pcontextSync->fInited            = TRUE;
    pcontextSync->pcontextHDSStorage = f_pcontextHDS;

ErrorExit:

    return dr;
}

/**********************************************************************
 *				     PUBLIC FUNCTION DRM_SNC_CloseStore
 **********************************************************************/

DRM_RESULT DRM_API DRM_SNC_CloseStore (
    IN  DRM_SYNC_CONTEXT       *f_pcontextSYN)
{
    DRM_SYNC_CONTEXT_PRIVATE *pcontextSync = (DRM_SYNC_CONTEXT_PRIVATE *) f_pcontextSYN;
    DRM_RESULT	dr = DRM_SUCCESS;

    ChkArg (f_pcontextSYN != NULL);

    if (pcontextSync->fInited)
    {
        ChkDR (DRM_HDS_CloseNamespace (&pcontextSync->contextNameSpace));
    }

    ZEROMEM(f_pcontextSYN, SIZEOF (DRM_SYNC_CONTEXT));
    
ErrorExit:
    return dr;
}

/**********************************************************************
 *				    PUBLIC FUNCTION DRM_SNC_InitEnum
 ***********************************************************************/

DRM_RESULT DRM_API DRM_SNC_InitEnum   (
    IN  DRM_SYNC_CONTEXT       *f_pcontextSYN, 
    OUT DRM_SYNC_ENUM_CONTEXT  *f_pcontextSYNEnum)
{
    DRM_SYNC_CONTEXT_PRIVATE      *pcontextSync     = (DRM_SYNC_CONTEXT_PRIVATE *)      f_pcontextSYN;
    DRM_SYNC_ENUM_CONTEXT_PRIVATE *pcontextSyncEnum = (DRM_SYNC_ENUM_CONTEXT_PRIVATE *) f_pcontextSYNEnum;
    DRM_RESULT dr =  DRM_SUCCESS;  

    ChkArg(f_pcontextSYN         != NULL
        && f_pcontextSYNEnum     != NULL);
    ChkArg(pcontextSync->fInited);

    DRMASSERT (SIZEOF (DRM_SYNC_CONTEXT_PRIVATE) <= SIZEOF (DRM_SYNC_CONTEXT));

    ZEROMEM(f_pcontextSYNEnum, SIZEOF (DRM_SYNC_ENUM_CONTEXT));

    dr = DRM_HDS_InitSlotEnum (&pcontextSync->contextNameSpace, 
                               NULL, 
                               eDRM_HDS_LOCKSHARED | eDRM_HDS_LOCKWAIT, 
                              &pcontextSyncEnum->contextHDSEnum);

    if (DRM_SUCCEEDED (dr))
    {
        pcontextSyncEnum->fAny = TRUE;
    }
    else if (dr == DRM_E_HDSSLOTNOTFOUND)
    {
        /* No KIDs found. */
        
		pcontextSyncEnum->fAny = FALSE;
        dr = DRM_SUCCESS;
    }
    else
    {
        ChkDR (dr);
    }
    
    pcontextSyncEnum->fInited      = TRUE;
    pcontextSyncEnum->pcontextSync = pcontextSync;

ErrorExit:    
    return dr;
}

/**********************************************************************
 *				    PUBLIC FUNCTION DRM_SNC_EnumNext
 ***********************************************************************/

DRM_RESULT DRM_API DRM_SNC_EnumNext   (
    IN  DRM_SYNC_ENUM_CONTEXT  *f_pcontextSYNEnum, 
    OUT DRM_KID                *f_pkid,
    OUT DRM_HDS_SLOT_HINT      *f_pslotHint)
{
	DRM_SYNC_ENUM_CONTEXT_PRIVATE *pcontextSyncEnum = (DRM_SYNC_ENUM_CONTEXT_PRIVATE *) f_pcontextSYNEnum;
    DRM_HDS_UNIQUEKEY keyHash;
    DRM_RESULT        dr     = DRM_SUCCESS;
    DRM_DWORD         cbSlot = SIZEOF (DRM_DWORD);

    ChkArg (f_pcontextSYNEnum != NULL
         && f_pkid            != NULL);

    ChkArg (pcontextSyncEnum->fInited);

    DRMASSERT (SIZEOF (DRM_SYNC_CONTEXT_PRIVATE) 
            <= SIZEOF (DRM_SYNC_CONTEXT));

    if  (pcontextSyncEnum->fAny == FALSE)
    {
        dr = DRM_E_NOMORE;
        goto ErrorExit;            
    }

    dr = DRM_HDS_SlotEnumNext(&pcontextSyncEnum->contextHDSEnum, 
                              &pcontextSyncEnum->contextHDSSlot, 
                              &keyHash,
                              &pcontextSyncEnum->itemSync.kid, 
                              &cbSlot);

    if (dr == DRM_E_HDSBLOCKMISMATCH 
    ||  dr == DRM_E_HDSSLOTNOTFOUND)
    {
        ChkDR (DRM_E_SYNC_ENTRYNOTFOUND);
    }

    ChkDR (dr); /* includes DRM_E_NOMORE */

    MEMCPY (f_pkid->rgb, 
            pcontextSyncEnum->itemSync.kid.rgb, 
            SIZEOF (DRM_KID));

    if( f_pslotHint != NULL )
    {
        DRM_HDS_MakeSlotHint( &pcontextSyncEnum->contextHDSSlot, 
                               f_pslotHint );
    }

    ChkDR (DRM_HDS_CloseSlot (&pcontextSyncEnum->contextHDSSlot));
    
ErrorExit:
    
    return dr;
}

/*********************************************************************
 *                   INTERNAL FUNCTIONS _GetKIDStoreData
 *                                      _SetKIDStoreData
 *
 * purpose: get/set the data currently in the sync store for this KID
 *********************************************************************/

/* Obselete hash key that was used in the previous sync store. */
static const DRM_HDS_HASHKEY g_keyHashSync = 
{ 
    TWO_BYTES(0xA9, 0x68), TWO_BYTES(0xAE, 0xEF),
    TWO_BYTES(0xA7, 0x66), TWO_BYTES(0xF4, 0xD7),
    TWO_BYTES(0xD0, 0xEE), TWO_BYTES(0x73, 0xDE),
    TWO_BYTES(0x65, 0xAE), TWO_BYTES(0xA7, 0xEA)
};

DRM_RESULT _GetKIDStoreData(
    IN       DRM_SYNC_CONTEXT       *f_pcontextSYN,
    IN const DRM_KID                *f_pkid,
    IN       DRM_HDS_SLOT_HINT      *f_pslotHint,
       OUT   DRM_LICENSE_STATE_DATA *f_plsd)
{
    DRM_SYNC_CONTEXT_PRIVATE *pcontextSync = (DRM_SYNC_CONTEXT_PRIVATE *) f_pcontextSYN;
    DRM_DWORD   cbSlot   = SIZEOF (DRM_LICENSE_STATE_DATA);
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_BOOL   fSlotOpen = FALSE;    
    DRM_WORD   iMember   = 0;
    
    dr = DRM_HDS_OpenSlot (&pcontextSync->contextNameSpace, 
                             eDRM_HDS_OPEN_EXISTING | eDRM_HDS_LOCKWAIT, 
                             f_pkid,
                             f_pkid, 
                             f_pslotHint,
                            &cbSlot, 
                            &pcontextSync->contextHDSSlot);
    
    if( dr == DRM_E_HDSSLOTNOTFOUND )
    {
        /* Older HDS files had a constant hashkey, so try opening the slot with that,
           and if it's there we should "upgrade" it to the new hashkey */
        ChkDR (DRM_HDS_OpenSlot (&pcontextSync->contextNameSpace, 
                         eDRM_HDS_OPEN_EXISTING | eDRM_HDS_LOCKWAIT, 
                        &g_keyHashSync,
                         f_pkid, 
                         NULL,
                        &cbSlot, 
                        &pcontextSync->contextHDSSlot));
        
        fSlotOpen = TRUE;

        /* It's there, so read out the data */
        ChkDR (DRM_HDS_SlotRead (&pcontextSync->contextHDSSlot, 
                                SIZEOF (DRM_LICENSE_STATE_DATA), 
                    (DRM_BYTE *)f_plsd, 
                                &cbSlot));
        DRM_HDS_CloseSlot (&pcontextSync->contextHDSSlot);
        fSlotOpen = FALSE;

        /* Delete the old slot */
        ChkDR(DRM_HDS_DeleteSlot(&pcontextSync->contextNameSpace, 
                &g_keyHashSync,
                 f_pkid, 
                 NULL,
                 FALSE ));

        /* Open the new slot */
        ChkDR (DRM_HDS_OpenSlot (&pcontextSync->contextNameSpace, 
                         eDRM_HDS_CREATE_IF_NEW | eDRM_HDS_LOCKEXCLUSIVE | eDRM_HDS_LOCKWAIT, 
                         f_pkid,
                         f_pkid,
                         NULL,
                        &cbSlot,
                        &pcontextSync->contextHDSSlot));
        fSlotOpen = TRUE;

        /* Write the data for the new slot */
        ChkDR (DRM_HDS_SlotWrite (&pcontextSync->contextHDSSlot, 
                                SIZEOF (DRM_LICENSE_STATE_DATA), 
                    (DRM_BYTE *)f_plsd, 
                                &cbSlot));
        
#if !_DATASTORE_WRITE_THRU
        ChkDR (DRM_HDS_CommitNamespace(&pcontextSync->contextNameSpace));
#endif
        
    }
    else
    {
        ChkDR( dr );
        fSlotOpen = TRUE;

        ChkDR (DRM_HDS_SlotRead (&pcontextSync->contextHDSSlot, 
                                SIZEOF (DRM_LICENSE_STATE_DATA), 
                    (DRM_BYTE *)f_plsd, 
                                &cbSlot));
    }


                             
    FIX_ENDIAN_DWORD(f_plsd->dwCategory);                        
    FIX_ENDIAN_DWORD(f_plsd->dwStreamId);
    FIX_ENDIAN_DWORD(f_plsd->dwNumCounts);
    FIX_ENDIAN_DWORD(f_plsd->dwNumDates); 
    FIX_ENDIAN_DWORD(f_plsd->dwVague);    
    
    for (iMember = 0; 
         iMember < NO_OF(f_plsd->datetime); 
         iMember++)
    {
        DRM_UINT64 ui64;
        FILETIME_TO_UI64(f_plsd->datetime [iMember], ui64 );
        FIX_ENDIAN_QWORD(ui64);
        UI64_TO_FILETIME( ui64, f_plsd->datetime [iMember] );
    }

    for (iMember = 0; 
         iMember < NO_OF(f_plsd->dwCount); 
         iMember++)
    {
        FIX_ENDIAN_DWORD(f_plsd->dwCount [iMember]);
    }
                             
ErrorExit:
    if (fSlotOpen)
    {
        dr = DRM_HDS_CloseSlot (&pcontextSync->contextHDSSlot);
    }

    return dr;
} /* _GetKIDStoreData */

DRM_RESULT _SetKIDStoreData(
    IN       DRM_SYNC_CONTEXT       *f_pcontextSYN,
    IN const DRM_KID                *f_pkid,
    IN       DRM_HDS_SLOT_HINT      *f_pslotHint,
    IN const DRM_LICENSE_STATE_DATA *f_plsd,
    IN       DRM_BOOL                f_fCreateIfNotExisting )
{
    DRM_SYNC_CONTEXT_PRIVATE *pcontextSync = (DRM_SYNC_CONTEXT_PRIVATE *) f_pcontextSYN;
    DRM_LICENSE_STATE_DATA    lsd = { 0 };
    DRM_DWORD  cbSlot    = SIZEOF (DRM_LICENSE_STATE_DATA);
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_BOOL   fSlotOpen = FALSE;    
    DRM_WORD   iMember   = 0;
    
    MEMCPY( &lsd, f_plsd, SIZEOF( lsd ) );

    FIX_ENDIAN_DWORD(lsd.dwCategory);                        
    FIX_ENDIAN_DWORD(lsd.dwStreamId);
    FIX_ENDIAN_DWORD(lsd.dwNumCounts);
    FIX_ENDIAN_DWORD(lsd.dwNumDates); 
    FIX_ENDIAN_DWORD(lsd.dwVague);    
    
    for (iMember = 0; 
         iMember < NO_OF(lsd.datetime); 
         iMember++)
    {
        DRM_UINT64 ui64;
        FILETIME_TO_UI64(lsd.datetime [iMember], ui64 );
        FIX_ENDIAN_QWORD(ui64);
        UI64_TO_FILETIME( ui64, lsd.datetime [iMember] );
    }

    for (iMember = 0; 
         iMember < NO_OF(lsd.dwCount); 
         iMember++)
    {
        FIX_ENDIAN_DWORD(lsd.dwCount [iMember]);
    }

    /* check to see if the entry already exists */
    dr = DRM_HDS_OpenSlot (&pcontextSync->contextNameSpace, 
                           eDRM_HDS_OPEN_EXISTING | eDRM_HDS_LOCKEXCLUSIVE | eDRM_HDS_LOCKWAIT, 
                           f_pkid,
                           f_pkid,
                           f_pslotHint,
                          &cbSlot,
                          &pcontextSync->contextHDSSlot);

    /* doesn't exist; create it */
    if (dr == DRM_E_HDSSLOTNOTFOUND 
     && f_fCreateIfNotExisting )
    {
        ChkDR (DRM_HDS_OpenSlot (&pcontextSync->contextNameSpace, 
                                 eDRM_HDS_CREATE_IF_NEW | eDRM_HDS_LOCKEXCLUSIVE | eDRM_HDS_LOCKWAIT, 
                                 f_pkid,
                                 f_pkid,
                                 NULL,
                                &cbSlot,
                                &pcontextSync->contextHDSSlot));
    }
    else
    {
        ChkDR (dr);
    }


    fSlotOpen = TRUE;

    ChkDR (DRM_HDS_SlotWrite (&pcontextSync->contextHDSSlot, 
                       SIZEOF (DRM_LICENSE_STATE_DATA), 
                (DRM_BYTE *)   &lsd, 
                              &cbSlot));
#if !_DATASTORE_WRITE_THRU
    ChkDR (DRM_HDS_CommitNamespace(&pcontextSync->contextNameSpace));
#endif

ErrorExit:
    if (fSlotOpen)
    {
        dr = DRM_HDS_CloseSlot (&pcontextSync->contextHDSSlot);
    }

    return dr;
} /* _SetKIDStoreData */

/*********************************************************************
** Function: DRM_SNC_UpdateKID
**
** Synopsis: force the updating of the license state data of a KID
**           entry in the sync store.  
**         * if the pcontextViewRightsIn parameter is not NULL, the
**           license store is read for the data
**         * if the pcontextViewRightsIn parameter is NULL, the data
**           is cleared.  This typically follows the deletion of a 
**           license
**
** Parameters:
**
** [f_pcontextSYN]          -- initialized SYNC context
** [f_pcontextViewRightsIn] -- optional VIEWRIGHTS context (see above)
** [f_pkid]                 -- pointer to KID to be added/updated
**********************************************************************/

DRM_RESULT DRM_API DRM_SNC_UpdateKID(
    IN       DRM_SYNC_CONTEXT        *f_pcontextSYN, 
    IN       DRM_VIEW_RIGHTS_CONTEXT *f_pcontextViewRightsIn,
    IN const DRM_KID                 *f_pkid)
{
    DRM_LICENSE_STATE_DATA    lsd = { 0 };
    DRM_SYNC_CONTEXT_PRIVATE *pcontextSync = (DRM_SYNC_CONTEXT_PRIVATE *) f_pcontextSYN;
    DRM_RESULT dr        = DRM_SUCCESS;
   
    ChkArg (f_pcontextSYN != NULL
         && f_pkid        != NULL);

    if (f_pcontextViewRightsIn != NULL)
    {
        MEMCPY(&f_pcontextViewRightsIn->KID, f_pkid, SIZEOF (DRM_KID));

        ChkDR( DRM_ASD_GetLicenseAggregateData( g_apdstrActions, 
                                                &lsd, 
                                                NO_OF( g_apdstrActions ), 
                                                f_pcontextViewRightsIn, 
                                                pcontextSync->pcontextHDSStorage,
                                                TRUE ) );

        /* if this is an UNLIMITED license delete it from the sync store 
        ** if present since it's now attached to an UNLIM license and will never 
        ** be synced 
        */
                                
        if (lsd.dwCategory == WM_DRM_LICENSE_STATE_UNLIM)
        {
            ChkDR(DRM_SNC_DeleteKID(f_pcontextSYN, f_pkid));
        }
        else
        {
            _SetKIDStoreData(f_pcontextSYN, f_pkid, NULL, &lsd, TRUE);
        }       
    }

    /* a call with a NULL f_pcontextViewRightsIn means that the KID should 
    ** be stored in the synclist and updated from the license store next time the sync list is generated
    */    

    else
    {
        lsd.dwCategory = WM_DRM_LICENSE_STATE_FORCE_SYNC;
        
        _SetKIDStoreData(f_pcontextSYN, f_pkid, NULL, &lsd, TRUE);
    }

ErrorExit:
    return dr;
} /* DRM_SNC_UpdateKID */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmtoken.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_TOKEN_H__
#define __DRM_TOKEN_H__


#ifdef __cplusplus
extern "C" {
#endif

typedef enum
{
    /* Tokens expected from the expression */
    TOKEN_VARIABLE=0,
    TOKEN_FUNCTION,
    TOKEN_LONG,
    TOKEN_DATETIME,
    TOKEN_STRING,
    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_ADD,
    TOKEN_SUB,
    TOKEN_MUL,
    TOKEN_DIV,
    TOKEN_MOD,
    TOKEN_PREINCR,
    TOKEN_POSTINCR,
    TOKEN_PREDECR,
    TOKEN_POSTDECR,
    TOKEN_ASSIGN,
    TOKEN_LESS,
    TOKEN_LESSEQ,
    TOKEN_GREAT,
    TOKEN_GREATEQ,
    TOKEN_NOTEQ,
    TOKEN_EQ,
    TOKEN_NOT,
    TOKEN_AND,
    TOKEN_OR,
    TOKEN_IF,
    TOKEN_COLON,
    TOKEN_SEMICOLON,
    TOKEN_OPEN,
    TOKEN_CLOSE,
    TOKEN_COMMA,
    TOKEN_UNKNOWN,

    /* For internal Use of the processing algorithm */
    TOKEN_IFSKIP,
    TOKEN_COLONSKIP,
    TOKEN_ANDSKIP,
    TOKEN_ORSKIP,
    TOKEN_UNARYSYNC, /* indicates that the pre unary operator just pushed into operator stack needs  right operand. */
    TOKEN_FUNCTIONSYNC /* indicates that the fucntion sysmbol just pushed need right arguments. Popping of arguments should stop at this token. */

} DRM_EXPR_TOKEN_TYPE;

typedef enum
{
    FN_DATEADD,
    FN_DATEDIFF,
    FN_MIN,
    FN_MAX,
    FN_INDEX,
    FN_DATEPART,
    FN_VERSIONCOMPARE,
    FN_DELETELICENSE,
    FN_EXISTS,
    FN_LENGTH
} DRM_EXPR_FUNCTION_TYPE;

/*
   In the context of the expression evaluator any token can be placed in here.  When one of these tokens
   is given to the secure store the only valid token types are 
       TOKEN_LONG and  TOKEN_DATETIME
*/


#if defined (_MSC_VER)
#pragma warning(disable:4103)
#pragma pack(push)
#pragma pack(1)
#endif

/*
** NOTE:  This structure should be 12 bytes long to allow for binary compatability of the secure store.
**        Using MS Visual C++ we have to use #pragma pack to achieve this 
*/
typedef struct tagTOKEN
{
    DRM_DWORD TokenType;
    union _tagTokenValue
    {
        DRM_UINT64 u64DateTime;
        DRM_LONG lValue;
        DRM_CONST_STRING stringValue;
        DRM_DWORD fnValue;
    } val;
}TOKEN;

#if defined (_MSC_VER)
#pragma pack(pop)
#pragma warning(default:4103)
#endif

#ifdef __cplusplus
}
#endif

#endif /* __DRM_TOKEN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmtoolsmacros.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#pragma once


#define CallXmlBuilder(context, fn)   {\
    while (TRUE)\
    {\
        dr = (fn);\
        if ( dr == DRM_E_BUFFERTOOSMALL )\
        {\
            ChkDR(DRMTOOLS_ReallocXmlContext(&(context)));\
            continue;\
        }\
        ChkDR(dr);\
        break;\
    }\
}

#define MAX_FILENAME 1023
#define XML_INIT_SIZE   1024
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmstrings.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSTRINGS_H__
#define __DRMSTRINGS_H__

#include <drmtypes.h>
#ifdef __cplusplus
extern "C"
{
#endif

    /* Declare the characters first */
    extern const DRM_WCHAR              g_wchPathSeperator;
    extern const DRM_WCHAR              g_wchNull;
    extern const DRM_WCHAR              g_wchMinus;
    extern const DRM_WCHAR              g_wchPlus;
    extern const DRM_WCHAR              g_wchForwardSlash;
    extern const DRM_WCHAR              g_wchColon;
    extern const DRM_WCHAR              g_wchComma;
    extern const DRM_WCHAR              g_wchQuote;
    extern const DRM_WCHAR              g_wchSingleQuote;

    extern const DRM_WCHAR              g_wchNewLine;
    extern const DRM_WCHAR              g_wchBackSlash;
    extern const DRM_WCHAR              g_wch0;
    extern const DRM_WCHAR              g_wch1;
    extern const DRM_WCHAR              g_wch2;
    extern const DRM_WCHAR              g_wch9;
    extern const DRM_WCHAR              g_wcha;
    extern const DRM_WCHAR              g_wchd;
    extern const DRM_WCHAR              g_wchf;
    extern const DRM_WCHAR              g_wchh;
    extern const DRM_WCHAR              g_wchm;
    extern const DRM_WCHAR              g_wchn;
    extern const DRM_WCHAR              g_wchs;
    extern const DRM_WCHAR              g_wchy;
    extern const DRM_WCHAR              g_wchA;
    extern const DRM_WCHAR              g_wchF;
    extern const DRM_WCHAR              g_wchx;
    extern const DRM_WCHAR              g_wchX;
    extern const DRM_WCHAR              g_wchUnderscore;
    extern const DRM_WCHAR              g_wchz;
    extern const DRM_WCHAR              g_wchZ;
    extern const DRM_WCHAR              g_wchPeriod;
    extern const DRM_WCHAR              g_wchQuestionMark;
    extern const DRM_WCHAR              g_wchExclamationMark;
    extern const DRM_WCHAR              g_wchOpenParen;
    extern const DRM_WCHAR              g_wchCloseParen;
    extern const DRM_WCHAR              g_wchPound;
    extern const DRM_WCHAR              g_wchSpace;
    extern const DRM_WCHAR              g_wchTab;
    extern const DRM_WCHAR              g_wchLineFeed;
    extern const DRM_WCHAR              g_wchVerticalTab;
    extern const DRM_WCHAR              g_wchFormFeed;
    extern const DRM_WCHAR              g_wchCarriageReturn;
    extern const DRM_WCHAR              g_wchEqual;
    extern const DRM_WCHAR              g_wchOpenCurly;
    extern const DRM_WCHAR              g_wchCloseCurly;
    extern const DRM_WCHAR              g_wchLessThan;
    extern const DRM_WCHAR              g_wchGreaterThan;
    extern const DRM_WCHAR              g_wchLeftBracket;
    extern const DRM_WCHAR              g_wchRightBracket;
    extern const DRM_WCHAR              g_wchAsterisk;
    extern const DRM_WCHAR              g_wchPercent;
    extern const DRM_WCHAR              g_wchSemiColon;
    extern const DRM_WCHAR              g_wchAmpersand;
    extern const DRM_WCHAR              g_wchPipe;
    extern const DRM_WCHAR              g_rgwchWMDRM_RIGHT_ALLOW_COPY[];
    extern const DRM_WCHAR              g_rgwchCreatePMLicense[];

#if DRM_SUPPORT_REVOCATION
    extern const DRM_LID                g_lidRevocationInfo;
#if DRM_SUPPORT_DEVICE_REVOCATION
    extern const DRM_LID                g_lidDeviceRevocation;
    extern const DRM_CONST_STRING       g_dstrRevocationGuidDevice;
    extern const DRM_ANSI_CONST_STRING  g_dastrRevocationGuidDevice;
    extern const DRM_GUID               g_guidRevocationTypeDevice;
#endif               

#if DRM_SUPPORT_WMDRMNET
    extern const DRM_LID                g_lidWMDRMNET_Revocation;
    extern const DRM_CONST_STRING       g_dstrRevocationGuidWMDRMNET;
    extern const DRM_ANSI_CONST_STRING  g_dastrRevocationGuidWMDRMNET;
    extern const DRM_GUID               g_guidRevocationTypeWMDRMNET;
#endif

#if DRM_SUPPORT_APP_REVOCATION
    extern const DRM_LID                g_lidAppRevocation;
    extern const DRM_CONST_STRING       g_dstrRevocationGuidApp;
    extern const DRM_ANSI_CONST_STRING  g_dastrRevocationGuidApp;
    extern const DRM_GUID               g_guidRevocationTypeApp;
#endif /* DRM_SUPPORT_APP_REVOCATION */
#endif /* DRM_SUPPORT_REVOCATION */

    /* Now declare the strings */
    
    extern const DRM_ANSI_CONST_STRING  g_adstrAttributeVersion;
    extern const DRM_ANSI_CONST_STRING  g_dastrAttributeType;
    extern const DRM_ANSI_CONST_STRING  g_adstrLicenseRespTag;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagLicense;
    extern const DRM_ANSI_CONST_STRING  g_dastrAttributeFALSE;
    extern const DRM_ANSI_CONST_STRING  g_adstrAttributeEncrypted;

    extern const DRM_ANSI_CONST_STRING  g_dastrTagSLK;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSLKID;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSLKDATA;


    extern const DRM_CONST_STRING       g_dstrTagSLK;
    extern const DRM_CONST_STRING       g_dstrTagSLKID;
    extern const DRM_CONST_STRING       g_dstrTagSLKDATA;

    extern const DRM_CONST_STRING       g_dstrAttributeVersion;
    extern const DRM_CONST_STRING       g_dstrAttributeEncrypted;
    extern const DRM_CONST_STRING       g_dstrAttributeFALSE;
    extern const DRM_CONST_STRING       g_dstrLicVerAttrValue;
    extern const DRM_CONST_STRING       g_dstrLicenseRespTag;
    extern const DRM_CONST_STRING       g_dstrTagLicense;

    /* Script varibles used for license properties. */
    extern const DRM_CONST_STRING       g_dstrDRM_LS_BEGIN_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_COUNT_ATTR;

    extern const DRM_CONST_STRING       g_dstrDRM_LS_BEGDATE_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_ENDDATE_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_FIRSTUSE_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_EXPIRATION_AFTER_FIRSTUSE_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_MINAPPSECLEVEL_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_APPSEC_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_BURNTOCDCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_TRANSFERCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_PLAYCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_BEGINBURNTOCDCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_BEGINTRANSFERCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_BEGINPLAYCOUNT_ATTR;

    extern const DRM_CONST_STRING       g_dstrDRM_LS_MACHINE_DATETIME_GE;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_MACHINE_DATETIME_LE;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_APP_MINSECLEVEL_GE;
    extern const DRM_CONST_STRING       g_dstrEqual;

    extern const DRM_CONST_STRING       g_dstrDrmRestoreInfo;
    extern const DRM_CONST_STRING       g_dstrTagData;
    extern const DRM_CONST_STRING       g_dstrTagLID;

    extern const DRM_CONST_STRING       g_dstrTagIndex;
    extern const DRM_CONST_STRING       g_dstrTagEnablingbits;
    extern const DRM_CONST_STRING       g_dstrTagHashAlgorithm;
    extern const DRM_CONST_STRING       g_dstrTagSymValue;
    extern const DRM_CONST_STRING       g_dstrTagSymSig;

    extern const DRM_CONST_STRING       g_dstrTagPubkey;

    extern const DRM_CONST_STRING       g_dstrTagValue;
    extern const DRM_CONST_STRING       g_dstrTagSignature;
    extern const DRM_CONST_STRING       g_dstrTagHashAlg;
    extern const DRM_CONST_STRING       g_dstrTagSignAlg;
    extern const DRM_CONST_STRING       g_dstrSHA;
    extern const DRM_CONST_STRING       g_dstrMSDRM;
    extern const DRM_CONST_STRING       g_dstrMSDRM_CK;
    extern const DRM_CONST_STRING       g_dstrAttributeType;
    extern const DRM_CONST_STRING       g_dstrSavedDateTime;

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK    
    extern const DRM_CONST_STRING       g_dstrCheckClockRollback;
    extern const DRM_CONST_STRING       g_dstrResetRollbackedClock;
#endif
    
    extern const DRM_CONST_STRING       g_dstrSetSavedDateTime;
    extern const DRM_CONST_STRING       g_dstrCreatePMLicense;
    extern const DRM_CONST_STRING       g_dstrAttributeVersion;
    extern const DRM_CONST_STRING       g_dstrVersion_1_0;
    extern const DRM_CONST_STRING       g_dstrTagIndivPrivkey;
    extern const DRM_CONST_STRING       g_dstrTagDevinfo;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagRevocation;
    extern const DRM_CONST_STRING       g_dstrTagError;
    extern const DRM_CONST_STRING       g_dstrXPathSigValue;
    extern const DRM_CONST_STRING       g_dstrFeatureIndivURL;
    extern const DRM_CONST_STRING       g_dstrCompatCert;
    extern const DRM_CONST_STRING       g_dstrCompatSecVersion;
    extern const DRM_CONST_STRING       g_dstrSubjectId;
    extern const DRM_CONST_STRING       g_dstrMaxSecLevel;
    extern const DRM_CONST_STRING       g_dstrAuthSecVer;
    extern const DRM_CONST_STRING       g_dstrAuthPubKey;
    extern const DRM_CONST_STRING       g_dstrXPathTagSignature;
    extern const DRM_CONST_STRING       g_dstrTagSignatureVal;
    extern const DRM_CONST_STRING       g_dstrXPathTagCertificateChain;
    extern const DRM_CONST_STRING       g_dstrTagSecurityLevel;
    extern const DRM_CONST_STRING       g_dstrAuthData;
    extern const DRM_CONST_STRING       g_dstrAuthHashAlg;
    extern const DRM_CONST_STRING       g_dstrAuthSignAlg;
    extern const DRM_CONST_STRING       g_dstrTagFallback;

    extern const DRM_CONST_STRING       g_dstrTagCertificate;
    extern const DRM_CONST_STRING       g_dstrXPathDataUniqueID;

    extern const DRM_CONST_STRING       g_dstrXPathManufacturer;
    extern const DRM_CONST_STRING       g_dstrXPathMake;
    extern const DRM_CONST_STRING       g_dstrXPathModel;
    extern const DRM_CONST_STRING       g_dstrXPathDistributor;
    extern const DRM_CONST_STRING       g_dstrXPathHardwareMajor;
    extern const DRM_CONST_STRING       g_dstrXPathHardwareMinor;
    extern const DRM_CONST_STRING       g_dstrXPathFirmwareMajor;
    extern const DRM_CONST_STRING       g_dstrXPathFirmwareMinor;
    extern const DRM_CONST_STRING       g_dstrXPathFeatureTemplate;
    extern const DRM_CONST_STRING       g_dstrXPathHeaderUplinks;
    extern const DRM_CONST_STRING       g_dstrXPathClientOldKeys;
    extern const DRM_CONST_STRING       g_dstrXPathClientEscrowKeys;
    extern const DRM_CONST_STRING       g_dstrXPathClientEscrowKey;
    extern const DRM_CONST_STRING       g_dstrXPathIndivServerEscrowKey;
    extern const DRM_CONST_STRING       g_dstrXPathDevicePublicKey;
    extern const DRM_CONST_STRING       g_dstrXPathOldKeysData;
    extern const DRM_CONST_STRING       g_dstrXPathIndivSvrPubKey;
    extern const DRM_CONST_STRING       g_dstrXPathSecureClock;
    extern const DRM_CONST_STRING       g_dstrXPathIndivType;
    extern const DRM_CONST_STRING       g_dstrXPathSecureStore;
    extern const DRM_CONST_STRING       g_dstrXPathMetering;
    extern const DRM_CONST_STRING       g_dstrXPathLicenseChain;
    extern const DRM_CONST_STRING       g_dstrFallback;

    extern const DRM_CONST_STRING       g_dstrTagDevCert;
    extern const DRM_CONST_STRING       g_dstrTagWrmHeader;
    extern const DRM_CONST_STRING       g_dstrAttributeVersionValue;
    extern const DRM_CONST_STRING       g_dstrTagLAINFO;
    extern const DRM_CONST_STRING       g_dstrTagKID;
    extern const DRM_CONST_STRING       g_dstrTagChecksum;
    extern const DRM_CONST_STRING       g_dstrTagUplink;
    extern const DRM_CONST_STRING       g_dstrTagUplinks;

    extern const DRM_CONST_STRING       g_dstrTagLicenseRequest;
    extern const DRM_CONST_STRING       g_dstrTagAction;

    extern const DRM_CONST_STRING       g_dstrTagV1Challenge;
    extern const DRM_CONST_STRING       g_dstrDefaultV1Data;
    extern const DRM_CONST_STRING       g_dstrTagActionList;
    extern const DRM_CONST_STRING       g_dstrTagSecurityVersion;
    extern const DRM_CONST_STRING       g_dstrTagDevice;
    extern const DRM_CONST_STRING       g_dstrTagPrivateKey;
    extern const DRM_CONST_STRING       g_dstrKeyDataTag;
    extern const DRM_CONST_STRING       g_dstrGroupTag;
    extern const DRM_CONST_STRING       g_dstrTagMSDRMSignature;

    /*
    **  Devcert Non-indiv Tags
    */
    extern const DRM_CONST_STRING       g_dstrTagDNIUniqueID;
    extern const DRM_CONST_STRING       g_dstrTagMSDRMSignature;
    extern const DRM_CONST_STRING       g_dstrPrivateKeys;        
    extern const DRM_CONST_STRING       g_dstrCertTypeDevice;
    extern const DRM_CONST_STRING       g_dstrCerttypeGroup;
    extern const DRM_CONST_STRING       g_dstrCerttypeAuth;
    extern const DRM_CONST_STRING       g_dstrCerttypeAuthRoot;
    
    /*
    **  Devcert Non-indiv XPaths
    */
    extern const DRM_CONST_STRING       g_dstrXPathPubkeyData;
    extern const DRM_CONST_STRING       g_dstrXPathGCSecureClock;
    extern const DRM_CONST_STRING       g_dstrXPathGCSecureClockURL;
    extern const DRM_CONST_STRING       g_dstrXPathGCSecureClockPubKey;
    extern const DRM_CONST_STRING       g_dstrXPathGCMetering;
    extern const DRM_CONST_STRING       g_dstrXPathGCLicenseAcquisitionMode;
    extern const DRM_CONST_STRING       g_dstrXPathGCLicenseSyncMode;
    extern const DRM_CONST_STRING       g_dstrXPathGCSymmOptsMode;
    extern const DRM_CONST_STRING       g_dstrXPathGCEncryption;
    extern const DRM_CONST_STRING       g_dstrXPathGCMaxChainDepth;
    extern const DRM_CONST_STRING       g_dstrXPathGCMaxLicenseSize;
    extern const DRM_CONST_STRING       g_dstrXPathGCMaxHeaderSize;
    extern const DRM_CONST_STRING       g_dstrXPathDeviceKeydata;
    extern const DRM_CONST_STRING       g_dstrXPathDACAuthID;

    extern const DRM_CONST_STRING       g_dstrReqTagClientInfo;
    extern const DRM_CONST_STRING       g_dstrReqTagClientID;
    extern const DRM_CONST_STRING       g_dstrReqTagClientVersion;
    extern const DRM_CONST_STRING       g_dstrReqTagAppSecurity;
    extern const DRM_CONST_STRING       g_dstrReqTagSubjectID1;
    extern const DRM_CONST_STRING       g_dstrReqTagSubjectID2;
    extern const DRM_CONST_STRING       g_dstrReqTagDrmkVersion;
    extern const DRM_CONST_STRING       g_dstrReqTagClientVersionData;
    extern const DRM_CONST_STRING       g_dstrReqTagSubjectID2Data;
    extern const DRM_CONST_STRING       g_dstrReqTagDrmkData;

    /* XML tags used in parsing licenses */
    extern const DRM_CONST_STRING       g_dstrLicense;
    extern const DRM_CONST_STRING       g_dstrLicensorInfoNode;
    extern const DRM_CONST_STRING       g_dstrLIData;
    extern const DRM_CONST_STRING       g_dstrMeta;

    /* Strings for various revocation queries */
    extern const DRM_CONST_STRING       g_dstrTagRevocation;
    extern const DRM_CONST_STRING       g_dstrTagRevocationInfo;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagRevocationInfo;
    extern const DRM_CONST_STRING       g_dstrAppRevocation;

    extern const DRM_CONST_STRING       g_dstrDeviceRevocationLicenseTag;
    extern const DRM_CONST_STRING       g_dstrWMDRMNETRevocationLicenseTag;

    extern const DRM_CONST_STRING       g_dstrDeviceRevocationList;
    extern const DRM_CONST_STRING       g_dstrDeviceRevocation;
    extern const DRM_ANSI_CONST_STRING  g_dastrDeviceRevocation;
    extern const DRM_CONST_STRING       g_dstrWMDRMNET_Revocation;
    extern const DRM_ANSI_CONST_STRING  g_dastrWMDRMNET_Revocation;

    extern const DRM_CONST_STRING       g_dstrTagRevInfoVersion;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagRevInfoVersion;
    extern const DRM_CONST_STRING       g_dstrTagSourceID;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSourceID;


    extern const DRM_CONST_STRING       g_dstrMeteringId;
    
    
    extern const DRM_CONST_STRING       g_dstrPriority;
    extern const DRM_CONST_STRING       g_dstrIssueDate;
    extern const DRM_CONST_STRING       g_dstrContentPubKey;
    extern const DRM_CONST_STRING       g_dstrContentRevocation;
    extern const DRM_CONST_STRING       g_dstrCondition;
    extern const DRM_CONST_STRING       g_dstrAction;
    extern const DRM_CONST_STRING       g_dstrRestrictions;
    extern const DRM_CONST_STRING       g_dstrChainedEnablingBits;
    extern const DRM_CONST_STRING       g_dstrDrmRestoreInfoEnablingBits;
    extern const DRM_CONST_STRING       g_dstrCertChain;
    extern const DRM_CONST_STRING       g_dstrXPathTagCertificate;
    extern const DRM_CONST_STRING       g_dstrLISigHashAlgo;
    extern const DRM_CONST_STRING       g_dstrLISigAlgo;
    extern const DRM_CONST_STRING       g_dstrLISigValue;
    extern const DRM_CONST_STRING       g_dstrOnActionPath;
    extern const DRM_CONST_STRING       g_dstrXPathSymSig;
    extern const DRM_CONST_STRING       g_dstrXPathSymValue;


    extern const DRM_CONST_STRING       g_dstrSequenceNumber;
    extern const DRM_CONST_STRING       g_dstrLSPubKey;
    extern const DRM_CONST_STRING       g_dstrUplinkKid;
    extern const DRM_CONST_STRING       g_dstrChainedCheckSum;
    extern const DRM_CONST_STRING       g_dstrTempMeterId;
    extern const DRM_CONST_STRING       g_dstrPMLicenseVersionString;
    extern const DRM_ANSI_CONST_STRING  g_dastrPMLicenseVersionString;
    extern const DRM_CONST_STRING       g_dstrRevAttribute;
    extern const DRM_CONST_STRING       g_dstrDerivedLicTemplate;
    extern const DRM_CONST_STRING       g_dstrLicDataDerivedTmpl;


    /* XML tags used in writing Challenge and parsing Response for metering */
    extern const DRM_CONST_STRING       g_dstrTagMetering;
    extern const DRM_CONST_STRING       g_dstrTagHash;
    extern const DRM_CONST_STRING       g_dstrXPathMID;
    extern const DRM_CONST_STRING       g_dstrTagMID;
    extern const DRM_CONST_STRING       g_dstrTagTID;
    extern const DRM_CONST_STRING       g_dstrTagCmd;
    extern const DRM_CONST_STRING       g_dstrTagPassword;
    extern const DRM_CONST_STRING       g_dstrTagRecords;
    extern const DRM_CONST_STRING       g_dstrTagPartialData;
    extern const DRM_CONST_STRING       g_dstrTagURL;
    extern const DRM_CONST_STRING       g_dstrLabelValue;
    extern const DRM_CONST_STRING       g_dstrHMAC;
    extern const DRM_CONST_STRING       g_dstrChallenge;
    extern const DRM_CONST_STRING       g_dstrResponse;
    extern const DRM_CONST_STRING       g_dstr1;
    extern const DRM_CONST_STRING       g_dstrReset;

    extern const DRM_ANSI_CONST_STRING  g_dastrTagMeterCert;
    extern const DRM_CONST_STRING       g_dstrTagMeterCert;

    extern const DRM_CONST_STRING       g_dstrTagCertificateChain;



    extern const DRM_ANSI_CONST_STRING  g_dastrAttributeAlgorithm;
    extern const DRM_ANSI_CONST_STRING  g_dastrAttributeVersionWMDRM;      
    extern const DRM_ANSI_CONST_STRING  g_dastrTagEscrowedKeys;            
    extern const DRM_ANSI_CONST_STRING  g_dastrKeyUsageSignCert;           
    extern const DRM_ANSI_CONST_STRING  g_dastrKeyUsageSignCRL;            
    extern const DRM_ANSI_CONST_STRING  g_dastrKeyUsageEncryptKey;         
    extern const DRM_ANSI_CONST_STRING  g_dastrOne;                        
    extern const DRM_ANSI_CONST_STRING  g_dastrPrefixManufacturer;         
    extern const DRM_ANSI_CONST_STRING  g_dastrTagCanonicalization;        
    extern const DRM_ANSI_CONST_STRING  g_dastrTagCertificateCollection;   
    extern const DRM_ANSI_CONST_STRING  g_dastrTagDigestMethod;            
    extern const DRM_ANSI_CONST_STRING  g_dastrURIDSigSHA1;                
    extern const DRM_ANSI_CONST_STRING  g_dastrTagDigestValue;             
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSignatureValue;          
    extern const DRM_ANSI_CONST_STRING  g_dastrTagKeyInfo;                 
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSymmetricKey;            
    extern const DRM_ANSI_CONST_STRING  g_dastrTagPublicKey;               
    extern const DRM_ANSI_CONST_STRING  g_dastrTagPrivateKey;              
    extern const DRM_ANSI_CONST_STRING  g_dastrTagKeyValue;               
    extern const DRM_ANSI_CONST_STRING  g_dastrTagRSAKeyValue;             
    extern const DRM_ANSI_CONST_STRING  g_dastrTagModulus;                 
    extern const DRM_ANSI_CONST_STRING  g_dastrTagExponent;  

    extern const DRM_ANSI_CONST_STRING  g_dastrTagManufacturerName;           
    extern const DRM_ANSI_CONST_STRING  g_dastrTagManufacturerData;           
    extern const DRM_ANSI_CONST_STRING  g_dastrTagModelName;                  
    extern const DRM_ANSI_CONST_STRING  g_dastrTagModelNumber;    
    extern const DRM_ANSI_CONST_STRING  g_dastrTagHardwareID;
    extern const DRM_ANSI_CONST_STRING  g_dastrURIRSASHA1;                    
    extern const DRM_ANSI_CONST_STRING  g_dastrURIRSASHA1_Old;                
    extern const DRM_ANSI_CONST_STRING  g_dastrTagReference;                  
    extern const DRM_ANSI_CONST_STRING  g_dastrTagTransforms;                 
    extern const DRM_ANSI_CONST_STRING  g_dastrTagTransform;                  
    extern const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCert;            
    extern const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCertColl;        
    extern const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCert_Old;        
    extern const DRM_ANSI_CONST_STRING  g_dastrURITransformC14N;              
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertificate;           
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMData;                  
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertPublicKey;         
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSecurityVersion;   
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSecurityLevel;     
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSerialNumber;      
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertFeatures;          
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertKeyUsage;          

    extern const DRM_ANSI_CONST_STRING  g_dastrTagSignature;       
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSignatureMethod; 
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSignedInfo;      
    extern const DRM_ANSI_CONST_STRING  g_dastrURIC14N;            
    extern const DRM_ANSI_CONST_STRING  g_dastrVersionWMDRM;       
    extern const DRM_ANSI_CONST_STRING  g_dastrWMDRMCertExponent;  


    extern const DRM_ANSI_CONST_STRING  g_dastrFeatureSampleProtection;
    extern const DRM_ANSI_CONST_STRING  g_dastrFeatureExport;
    extern const DRM_ANSI_CONST_STRING  g_dastrFeatureExportIncl;

    extern const DRM_ANSI_CONST_STRING  g_dastrPrefixMicrosoftCert;
    extern const DRM_ANSI_CONST_STRING  g_dastrMSRootPubKey;

    /* tags used for sync lists */

    extern const DRM_CONST_STRING       g_dstrTagSyncList;

    extern const DRM_CONST_STRING       g_dstrBackup;
    extern const DRM_CONST_STRING       g_dstrRestore;
    extern const DRM_CONST_STRING       g_dstrRootSigValueVersionTag;
    extern const DRM_CONST_STRING       g_dstrRootSigValueVersionVal;
    extern const DRM_CONST_STRING       g_dstrPFRootTag;
    extern const DRM_CONST_STRING       g_dstrDACPubKeyTag;
    extern const DRM_CONST_STRING       g_dstrAuthRoot;
    extern const DRM_CONST_STRING       g_dstrTagNameValue;
    extern const DRM_CONST_STRING       g_dstrXPathTagSecurityLevel;
    extern const DRM_CONST_STRING       g_dstrTagDataId;
    extern const DRM_CONST_STRING       g_dstrTagDataPubKey;
    extern const DRM_CONST_STRING       g_dstrFallBack;
    extern const DRM_CONST_STRING       g_dstrTagName;
    extern const DRM_CONST_STRING       g_dstrManufacturer;
    extern const DRM_CONST_STRING       g_dstrModel;
    extern const DRM_CONST_STRING       g_dstrHwMajor;
    extern const DRM_CONST_STRING       g_dstrHwMinor;
    extern const DRM_CONST_STRING       g_dstrFwMajor;
    extern const DRM_CONST_STRING       g_dstrFwMinor;
    extern const DRM_CONST_STRING       g_dstrFeatures;
    extern const DRM_CONST_STRING       g_dstrSecureClockNotSet;
    extern const DRM_CONST_STRING       g_dstrSecureClockSet;
    extern const DRM_CONST_STRING       g_dstrSecureClockNeedsRefresh;
    extern const DRM_CONST_STRING       g_dstrTemplate;
    extern const DRM_CONST_STRING       g_dstrIndivPubKey;
    extern const DRM_CONST_STRING       g_dstrUniqueId;
    extern const DRM_CONST_STRING       g_dstrUnsignedtemplate;
    extern const DRM_CONST_STRING       g_dstrTagDataSecVer;
    extern const DRM_CONST_STRING       g_dstrExprFuncDateAdd;
    extern const DRM_CONST_STRING       g_dstrExprFuncDateDiff;
    extern const DRM_CONST_STRING       g_dstrExprFuncMin;
    extern const DRM_CONST_STRING       g_dstrExprFuncMax;
    extern const DRM_CONST_STRING       g_dstrExprFuncDatePart;
    extern const DRM_CONST_STRING       g_dstrExprFuncVersionCompare;
    extern const DRM_CONST_STRING       g_dstrExprFuncDeleteLicense;
    extern const DRM_CONST_STRING       g_dstrExprFuncExists;    

    /* Strings for license evaluator well known actions */
    extern const DRM_CONST_STRING       g_dstrLicEvalOnSelect;
    extern const DRM_CONST_STRING       g_dstrLicEvalOnDelete;
    extern const DRM_CONST_STRING       g_dstrLicEvalOnStore;
    extern const DRM_CONST_STRING       g_dstrLicEvalOnAction;
    extern const DRM_CONST_STRING       g_dstrLicEvalOnClockRollback;

    /* Strings for expression evaluator variable evaluation */
    extern const DRM_CONST_STRING       g_dstrDRM_PREFIX;
    extern const DRM_CONST_STRING       g_dstrDRMK_PREFIX;
    extern const DRM_CONST_STRING       g_dstrMACHINE_PREFIX;
    extern const DRM_CONST_STRING       g_dstrAPP_PREFIX;
    extern const DRM_CONST_STRING       g_dstrSECSTATE_PREFIX;
    extern const DRM_CONST_STRING       g_dstrLICENSE_PREFIX;
    extern const DRM_CONST_STRING       g_dstrCONTENT_PREFIX;
    extern const DRM_CONST_STRING       g_dstrDEVICE_PREFIX;
    extern const DRM_CONST_STRING       g_dstrPMLICENSE_PREFIX;
    extern const DRM_CONST_STRING       g_dstrSECURETIME_PREFIX;
    extern const DRM_CONST_STRING       g_dstrPLAYLISTBURN_PREFIX;

#if DRM_SUPPORT_SST_REDUNANCY
    extern const DRM_CONST_STRING       g_dstrSSTREDUNDANCY_PREFIX;
#endif

    extern const DRM_CONST_STRING       g_dstrExprVarVersion;
    extern const DRM_CONST_STRING       g_dstrExprVarParameter;
    extern const DRM_CONST_STRING       g_dstrExprVarReason;
    extern const DRM_CONST_STRING       g_dstrExprVarBBMSDRMVersion;
    extern const DRM_CONST_STRING       g_dstrExprVarDateTime;
    extern const DRM_CONST_STRING       g_dstrExprVarCount;
    extern const DRM_CONST_STRING       g_dstrExprVarMinSecLevel;
    extern const DRM_CONST_STRING       g_dstrExprVarSecLevel;
    extern const DRM_CONST_STRING       g_dstrExprVarAppSecLevel;
    extern const DRM_CONST_STRING       g_dstrExprVarSubjID;
    extern const DRM_CONST_STRING       g_dstrExprVarAppSubjID;
    extern const DRM_CONST_STRING       g_dstrExprVarGlobal;
    extern const DRM_CONST_STRING       g_dstrExprVarSaveDateTime;
    extern const DRM_CONST_STRING       g_dstrExprVarSavedDateTime;
    extern const DRM_CONST_STRING       g_dstrExprVarDRMReason;
    extern const DRM_CONST_STRING       g_dstrExprVarRights;
    extern const DRM_CONST_STRING       g_dstrExprVarExpiryDate;
    extern const DRM_CONST_STRING       g_dstrExprVarInGracePeriod;
    extern const DRM_CONST_STRING       g_dstrExprVarGpStartTime;
    extern const DRM_CONST_STRING       g_dstrExprVarIncrementCount;    
    extern const DRM_CONST_STRING       g_dstrExprVarDevReg;    
    extern const DRM_CONST_STRING       g_dstrTagCDATA;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagCDATAOpenBracket;
    extern const DRM_CONST_STRING       g_dstrTagCDATAOpenBracket;
    extern const DRM_CONST_STRING       g_dstrOpenTag;
    extern const DRM_CONST_STRING       g_dstrSpace;
    extern const DRM_CONST_STRING       g_dstrOpenEndTag;
    extern const DRM_CONST_STRING       g_dstrCloseTag;
    extern const DRM_CONST_STRING       g_dstrEqualQuote;
    extern const DRM_CONST_STRING       g_dstrQuote;
    extern const DRM_CONST_STRING       g_dstrOpenCDATATag;
    extern const DRM_CONST_STRING       g_dstrCloseCDATATag;

    extern const DRM_CONST_STRING       g_dstrTagDRMReqRoot;
    extern const DRM_CONST_STRING       g_dstrResponse;
    extern const DRM_CONST_STRING       g_dstrStatus;
    extern const DRM_CONST_STRING       g_dstrFlag;
    extern const DRM_CONST_STRING       g_dstrTagGmtTime;
    extern const DRM_CONST_STRING       g_dstrTagRefreshDate;

    /* Output restriction strings */
    extern const DRM_CONST_STRING       g_dstrLabelGuid;
    extern const DRM_CONST_STRING       g_dstrLabelLevel;
    extern const DRM_CONST_STRING       g_dstrTagUncompressedDigitalVideo;
    extern const DRM_CONST_STRING       g_dstrTagCompressedDigitalVideo;
    extern const DRM_CONST_STRING       g_dstrTagUncompressedDigitalAudio;
    extern const DRM_CONST_STRING       g_dstrTagCompressedDigitalAudio;
    extern const DRM_CONST_STRING       g_dstrTagAnalogVideo;
    extern const DRM_CONST_STRING       g_dstrTagCopy;
    extern const DRM_CONST_STRING       g_dstrTagExtensionList;
    extern const DRM_CONST_STRING       g_dstrTagExtension;
    extern const DRM_CONST_STRING       g_dstrTagIncludeList;
    extern const DRM_CONST_STRING       g_dstrTagInclude;
    extern const DRM_CONST_STRING       g_dstrTagExcludeList;
    extern const DRM_CONST_STRING       g_dstrTagExclude;
    
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_PLAYBACK;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY;

#if DRM_SUPPORT_PLAYLIST_BURN
    extern const DRM_CONST_STRING      g_dstrPlaylistBurnCount;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_PLAYLIST_BURN;
#endif

#if DRM_SUPPORT_PMLICENSE
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE;
#endif

#if DRM_BACKUP_RESTORE_SUPPORT
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_BACKUP;
#endif

    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_CD;    

    extern const DRM_CONST_STRING      g_dstrMSRootPubKey;

/* License State strings */
    extern const DRM_CONST_STRING      g_dstrTagLicenseStateRequestRoot;
    extern const DRM_CONST_STRING      g_dstrTagCanBind;

/*Device License Revocation Blob Strings*/

    extern const DRM_CONST_STRING      g_dstrTagDeviceLicenseRevocationRoot;
    extern const DRM_CONST_STRING      g_dstrTagRevocationPubKey;


#ifdef __cplusplus
}
#endif

#endif /* __DRMSTRINGS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmtoolsutils.c ===
/**@@@+++@@@@******************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//*@@@---@@@@******************************************************************/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <drmpkcrypto.h>
#include <drmlicense.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <stdio.h>

#include <drmtoolsconstants.h>
#include <drmtoolsmacros.h>
#include <drmtoolsutils.h>

/******************************************************************************
** 
** Function :   _TestKeyPair
** 
** Synopsis :   
** 
** Arguments :  
******************************************************************************/
DRM_RESULT DRMTOOLS_TestKeyPair(
    IN  PUBKEY              *f_ppubkey, 
    IN  PRIVKEY             *f_pprivkey, 
    IN  DRM_CRYPTO_CONTEXT  *f_contextCRYP)
{
    DRM_RESULT   dr = DRM_SUCCESS;
    DRM_BYTE     rgbSignature [__CB_DECL(PK_ENC_SIGNATURE_LEN)] = { 0 };
    DRM_BYTE     rgbBuffer    [__CB_DECL(1024)]                 = { 0 };
    DRM_BYTE    *pbIn        = NULL;
    DRM_BYTE    *pbOut       = NULL;
    DRM_BYTE    *pbEncrypted = NULL;
    
    ChkArg(f_pprivkey != NULL
        && f_ppubkey  != NULL);

    MEMSET(rgbBuffer, 'b', SIZEOF(rgbBuffer));

    DRMCASSERT(PK_ENC_PLAINTEXT_LEN <= SIZEOF(f_contextCRYP->pubKey2));

    pbIn = (DRM_BYTE *) &f_contextCRYP->pubKey2;
    
    MEMSET(pbIn, 'a', SIZEOF(PUBKEY));

    DRMCASSERT(PK_ENC_CIPHERTEXT_LEN <= SIZEOF(f_contextCRYP->union_cert.cert));

    pbEncrypted = (DRM_BYTE *)&f_contextCRYP->union_cert.cert;
    pbOut       = (DRM_BYTE *) f_contextCRYP->signature;

    ChkDR(DRM_PK_Encrypt(f_contextCRYP->rgbCryptoContext, (const PUBKEY *)f_ppubkey , pbIn, pbEncrypted));

    ChkDR(DRM_PK_Decrypt(f_contextCRYP->rgbCryptoContext, 
                         f_pprivkey,
                         pbEncrypted, 
                         pbOut));

    if (MEMCMP(pbIn, pbOut, PK_ENC_PLAINTEXT_LEN) != 0)
    {
        dr = DRM_E_KEY_MISMATCH;
        goto ErrorExit;
    }

    ChkDR(DRM_PK_Sign(f_contextCRYP->rgbCryptoContext, f_pprivkey, rgbBuffer , SIZEOF(rgbBuffer), rgbSignature));

    if(! DRM_PK_Verify(f_contextCRYP->rgbCryptoContext, 
                       f_ppubkey, 
                       rgbBuffer, 
                       SIZEOF(rgbBuffer), 
                       rgbSignature))
    {
        ChkDR(DRM_E_INVALID_SIGNATURE);
    }


ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRMTOOLS_CreateKeyPair
** 
** Synopsis :   Creates a public private key pair
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRMTOOLS_CreateKeyPair(
    IN      DRM_CRYPTO_CONTEXT  *f_pcontextCrypto,
    IN  OUT PUBKEY              *f_ppubkey,
    IN  OUT PRIVKEY             *f_pprivkey,
        OUT DRM_STRING          *f_pdstrPubKey,
        OUT DRM_STRING          *f_pdstrPrivKey)
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkDR(DRM_PK_GenKeyPair(f_pcontextCrypto->rgbCryptoContext, 
                            f_ppubkey , 
                            f_pprivkey));
   
    ChkDR(DRMTOOLS_TestKeyPair(f_ppubkey, 
                               f_pprivkey,  
                               f_pcontextCrypto));
            
    f_pdstrPubKey->cchString  = CCH_BASE64_EQUIV(SIZEOF(PUBKEY));
    f_pdstrPubKey->pwszString = (DRM_WCHAR *) OEM_malloc(f_pdstrPubKey->cchString * SIZEOF(DRM_WCHAR));

    ChkMem(f_pdstrPubKey->pwszString);

    ChkDR(DRM_B64_EncodeW((const DRM_BYTE *)f_ppubkey, 
                           SIZEOF(PUBKEY), 
                           f_pdstrPubKey->pwszString,                            
                          &f_pdstrPubKey->cchString, 
                           0));
            
    f_pdstrPrivKey->cchString  = CCH_BASE64_EQUIV(SIZEOF(PRIVKEY));
    f_pdstrPrivKey->pwszString = (DRM_WCHAR *) OEM_malloc(f_pdstrPrivKey->cchString * SIZEOF(DRM_WCHAR));

    ChkMem(f_pdstrPrivKey->pwszString);

    ChkDR(DRM_B64_EncodeW((const DRM_BYTE *)f_pprivkey, 
                           SIZEOF(PRIVKEY), 
                           f_pdstrPrivKey->pwszString,                           
                          &f_pdstrPrivKey->cchString, 
                           0));       

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRMTOOLS_ReallocXmlContext
** 
** Synopsis :   Allocate double the size of the current context
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT  DRMTOOLS_ReallocXmlContext(
    IN  DRM_BYTE **f_ppbXmlContext)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbcontextXML     = 0;
    DRM_BYTE  *pbcontextXMLNew = NULL;

    ChkDR(DRM_XMB_GetContextSize(*f_ppbXmlContext, 
                                 &cbcontextXML));  /* get current size */
    /*
    **  This should never be 0
    */
    if ( cbcontextXML == 0 )
    {
        ChkDR(DRM_E_LOGICERR);
    }
    
    cbcontextXML *= 2;
            
    /* alloc double of the current size */
    ChkMem(pbcontextXMLNew = (DRM_BYTE *) OEM_malloc(cbcontextXML));  

    ChkDR(DRM_XMB_ReallocDocument(*f_ppbXmlContext,    
                                   cbcontextXML, 
                                   pbcontextXMLNew));
    
    OEM_free(*f_ppbXmlContext);

    *f_ppbXmlContext = pbcontextXMLNew;

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRMTOOLS_ReadFileData
** 
** Synopsis :   Reads the content of a file into a DRM_STRING
** 
** Arguments :  f_pdstrFileName
**              f_pdstrFileData
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRMTOOLS_ReadFileData(
    IN  const   DRM_CONST_STRING    *f_pdstrFileName,
        OUT     DRM_STRING          *f_pdstrFileData)
{
    DRM_RESULT  dr = DRM_SUCCESS;
    OEM_FILEHDL hfile  = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD   cbFile = 0;
    DRM_DWORD   cbRead = 0;
    DRM_WCHAR   rgwchTemp [MAX_FILENAME + 1] = { 0 };
    
    wcsncpy(rgwchTemp, f_pdstrFileName->pwszString, f_pdstrFileName->cchString);
    rgwchTemp [f_pdstrFileName->cchString] = 0;
    
    hfile = OEM_OpenFile(rgwchTemp, 
                         OEM_GENERIC_READ,
                         OEM_FILE_SHARE_READ, 
                         OEM_OPEN_EXISTING, 
                         OEM_ATTRIBUTE_NORMAL);
    if(hfile == OEM_INVALID_HANDLE_VALUE)
    {
        printf("%S could not be opened\n",  rgwchTemp);
        goto ErrorExit;
    }

    if (! OEM_GetFileSize(hfile, &cbFile))
    {
        printf("Error getting filesize of %S.\n", rgwchTemp);
        goto ErrorExit;    
    }
    
    if ((cbFile % SIZEOF(DRM_WCHAR)) != 0)
    {
        printf("%S is not Wide Char format.\n", rgwchTemp);
        goto ErrorExit;    
    }

    if (! OEM_SetFilePointer(hfile, 0, OEM_FILE_BEGIN, NULL))
    {
        ChkDR(DRM_E_FILEREADERROR);
    }

    /*
    **  Read data from hfile
    */    
    ChkMem(f_pdstrFileData->pwszString = (DRM_WCHAR *) OEM_malloc(cbFile));

    if (! OEM_ReadFile(hfile, f_pdstrFileData->pwszString, cbFile, &cbRead) 
     ||   cbRead != cbFile)
    {
        ChkDR(DRM_E_FILEREADERROR);
    }    
    f_pdstrFileData->cchString = cbFile / SIZEOF(DRM_WCHAR);
        
ErrorExit:
    /*
    **  Close file
    */
    if (hfile != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile(hfile);
    }
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmtoolsconstants.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#pragma once
#ifdef __cplusplus
extern "C"
{
#endif

extern const DRM_CONST_STRING  g_dstrTagRequestDAC;
extern const DRM_CONST_STRING  g_dstrTagDAC;
extern const DRM_CONST_STRING  g_dstrTagOEMPrivateKeys;
extern const DRM_CONST_STRING  g_dstrTagDACResponse;

extern const DRM_BYTE          g_rgbFFFE[__CB_DECL(2)];

/*
**  Xpaths
*/
extern const DRM_CONST_STRING  g_dstrXPathDACPubKey;
extern const DRM_CONST_STRING  g_dstrXPathFallbackPubKey;
extern const DRM_CONST_STRING  g_dstrXPathDACPrivKey;
extern const DRM_CONST_STRING  g_dstrXPathFallbackPrivKey;
extern const DRM_CONST_STRING  g_dstrXPathFallbackSecVer;

extern const DRM_CONST_STRING  g_dstrTagDataSecurityVersionValue;
extern const DRM_CONST_STRING  g_dstrAuthorizationIDDAC;
extern const DRM_CONST_STRING  g_dstrAuthIDDACRoot;
extern const DRM_CONST_STRING  g_dstrTagSecurityLevelValue;

extern const DRM_CONST_STRING  g_dstrCertMetercert;
extern const DRM_CONST_STRING  g_dstrCertSecureClock;

extern const DRM_CONST_STRING  g_dstrTestTemplate;
extern const DRM_CONST_STRING  g_dstrXMLTree1;
extern const DRM_CONST_STRING  g_dstrXMLTree2;
extern const DRM_CONST_STRING  g_dstrXMLTree3;
extern const DRM_CONST_STRING  g_dstrXMLTree4;

extern const DRM_CONST_STRING  g_dstrSigningKey;
extern const DRM_CONST_STRING  g_dstrTagKeySeed;
extern const DRM_CONST_STRING  g_dstrTagRoot;
extern const DRM_CONST_STRING  g_dstrTagURLLicAcq;
extern const DRM_CONST_STRING  g_dstrEncBlkSize;
extern const DRM_CONST_STRING  g_dstrCID;
extern const DRM_CONST_STRING  g_dstrVerifyKey;
extern const DRM_CONST_STRING  g_dstrDefaultURL;
extern const DRM_CONST_STRING  g_dstrDefaultBlksize;
extern const DRM_CONST_STRING  g_dstrDefaultFilename;
extern const DRM_CONST_STRING  g_dstrContents;
extern const DRM_CONST_STRING  g_dstrSerial;

extern const DRM_CONST_STRING  g_dstrTagPrivkey;
extern const DRM_CONST_STRING  g_dstrTagKeypair;
extern const DRM_CONST_STRING  g_dstrTagExpression;
                               
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmtoolsutils.h ===
/**@@@+++@@@@******************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//*@@@---@@@@******************************************************************/
#pragma once

#ifdef __cplusplus
extern "C"
{
#endif


DRM_RESULT DRMTOOLS_CreateKeyPair( 
    IN      DRM_CRYPTO_CONTEXT  *f_pcontextCrypto,
    IN  OUT PUBKEY              *f_ppubkey,
    IN  OUT PRIVKEY             *f_pprivkey,
        OUT DRM_STRING          *f_pdstrPubKey,
        OUT DRM_STRING          *f_pdstrPrivKey);

DRM_RESULT  DRMTOOLS_ReallocXmlContext(
    IN  DRM_BYTE **f_ppbXmlContext);

DRM_RESULT DRMTOOLS_ReadFileData(
    IN  const   DRM_CONST_STRING    *f_pdstrFileName,
        OUT     DRM_STRING          *f_pdstrFileData);

DRM_RESULT DRMTOOLS_TestKeyPair( 
    IN  PUBKEY *f_ppubkey, 
    IN  PRIVKEY *f_pprivkey, 
    IN  DRM_CRYPTO_CONTEXT  *f_contextCrypto );

#ifdef __cplusplus
        }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmutilities.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmxmlparser.h>
#include <drmrc4.h>
#include <oemimpl.h>
#if DRM_SUPPORT_CERTIFICATE_CACHING
#include <drmblackbox.h>
#endif

/*****************************************************************************
** Function: DRM_UTL_IsCertDateOK
**
** Synopsis: test whether a given date is before todays date.
**
** Arguments:
**   [f_pbDate]     -- date as a byte array
**   f_pbData [0] -- century, e.g. 20
**   f_pbData [1] -- year mod 100 e.g. 4
**   f_pbData [2] -- month, 1-based
**   f_pbData [3] -- day-of-month, 1-based
**
** Example: March 21, 2004 = |20|4|3|21|
**                            0  1 2 3
** Returns TRUE if the date is reasonable
*****************************************************************************/

DRM_BOOL DRM_API DRM_UTL_IsCertDateOK(const DRM_BYTE *f_pbDate)
{                 
    DRMSYSTEMTIME systimeCurrent;
    DRM_BOOL      fOK = FALSE;
    DRM_BYTE      rgbDate[4]; /* Don't use __CB_DECL here */

    OEM_GetDeviceDateTime(&systimeCurrent);

    rgbDate[0] = GET_BYTE( f_pbDate, 0 );
    rgbDate[1] = GET_BYTE( f_pbDate, 1 );
    rgbDate[2] = GET_BYTE( f_pbDate, 2 );
    rgbDate[3] = GET_BYTE( f_pbDate, 3 );

    if ((rgbDate [0] * 100 + rgbDate [1]) > systimeCurrent.wYear)
    {
        fOK = TRUE;
    }
    else if ((rgbDate [0] * 100 + rgbDate [1]) < systimeCurrent.wYear)
    {
        fOK = FALSE;
    }
    else if (rgbDate [2] > systimeCurrent.wMonth)
    {
        fOK = TRUE;
    }
    else if (rgbDate [2] < systimeCurrent.wMonth)
    {
        fOK = FALSE;
    }
    else 
    {
        fOK = (rgbDate [3] >= systimeCurrent.wDay);
    }
        
    return fOK;
}


DRM_BOOL DRM_API DRM_UTL_DateLessThan(
    IN const DRMFILETIME* f_pFileTime1, 
    IN const DRMFILETIME* f_pFileTime2)
{
    DRM_UINT64 u641;
    DRM_UINT64 u642;

    FILETIME_TO_UI64( *f_pFileTime1, u641 );
    FILETIME_TO_UI64( *f_pFileTime2, u642 );
    return DRM_UI64Les( u641, u642);
}

#if DRM_SUPPORT_CERTIFICATE_CACHING

DRM_ID g_idCachedCert = { TWO_BYTES( 'C', 0 ), TWO_BYTES( 'E', 0 ), TWO_BYTES( 'R', 0 ), TWO_BYTES( 'T', 0 ), 
                          TWO_BYTES( 'C', 0 ), TWO_BYTES( 'A', 0 ), TWO_BYTES( 'C', 0 ), TWO_BYTES( 'H', 0 ) };

static DRM_BOOL _VerifyCachedCertificate (
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN const DRM_BYTE            *f_pbData,
    IN       DRM_DWORD            f_cbData )
{
    DRM_RESULT  dr        = DRM_SUCCESS;
    DRM_BOOL    fVerified = FALSE;
    DRM_MD5_CTX contextMD5;
    DRM_BYTE    rgbHash[__CB_DECL(SHA_DIGEST_LEN)];
    DRM_BYTE    rgbSigDigest[__CB_DECL(MD5DIGESTLEN)];
    DRM_DWORD   cbSigDigest = SIZEOF( rgbSigDigest );

    ChkArg( f_pcontextLEVL                        != NULL
         && f_pcontextLEVL->pcontextBBX           != NULL
         && f_pcontextLEVL->pcontextSSTRevocation != NULL
         && f_pcontextLEVL->pcontextHDS           != NULL
         && f_pbData                              != NULL
         && f_cbData                               > 0 );

    ChkDR( DRM_BBX_HashValue( f_pbData, f_cbData, rgbHash, f_pcontextLEVL->pcontextBBX ) );
    DRM_MD5_Init  ( &contextMD5 );
    DRM_MD5_Update( &contextMD5, f_pbData, f_cbData );
    DRM_MD5_Final ( &contextMD5 );

    DRMCASSERT( SIZEOF( contextMD5.digest ) == SIZEOF( DRM_ID ) );

    dr = DRM_SST_GetData( f_pcontextLEVL->pcontextSSTRevocation,
                 (DRM_ID*)contextMD5.digest,
                         &g_idCachedCert,
                          rgbHash,
                          SECURE_STORE_CACHED_CERTIFICATE_DATA,
                          f_pcontextLEVL->pcontextHDS,
                          rgbSigDigest,
                         &cbSigDigest );
    if( DRM_SUCCEEDED( dr ) )
    {
        if( cbSigDigest == SIZEOF( rgbSigDigest )
         && 0 == MEMCMP( rgbSigDigest, contextMD5.digest, cbSigDigest ) )
        {
            fVerified = TRUE;
        }
    }

ErrorExit:
    return fVerified;
}

static DRM_RESULT _AddCachedCertificate (
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN const DRM_BYTE            *f_pbData,
    IN       DRM_DWORD            f_cbData )
{
    DRM_RESULT  dr        = DRM_SUCCESS;
    DRM_MD5_CTX contextMD5;
    DRM_BYTE    rgbHash[__CB_DECL(SHA_DIGEST_LEN)];

    ChkArg( f_pcontextLEVL                        != NULL
         && f_pcontextLEVL->pcontextBBX           != NULL
         && f_pcontextLEVL->pcontextHDS           != NULL
         && f_pcontextLEVL->pcontextSSTRevocation != NULL
         && f_pbData                              != NULL
         && f_cbData                               > 0 );

    ChkDR( DRM_BBX_HashValue( f_pbData, f_cbData, rgbHash, f_pcontextLEVL->pcontextBBX ) );
    DRM_MD5_Init  ( &contextMD5 );
    DRM_MD5_Update( &contextMD5, f_pbData, f_cbData );
    DRM_MD5_Final ( &contextMD5 );

    DRMCASSERT( SIZEOF( contextMD5.digest ) == SIZEOF( DRM_ID ) );

    dr = DRM_SST_SetData( f_pcontextLEVL->pcontextSSTRevocation,
                 (DRM_ID*)contextMD5.digest,
                         &g_idCachedCert,
                          rgbHash,
                          SECURE_STORE_CACHED_CERTIFICATE_DATA,
                          f_pcontextLEVL->pcontextHDS,
                          contextMD5.digest,
                   SIZEOF(contextMD5.digest) );
ErrorExit:
    return dr;
}

#endif


/******************************************************************************
** 
** Function :   _UTL_VerifySignature
** 
** Synopsis :   Verify the xml signature over some data
** 
** Arguments :  f_pdstrSignedData   -   The entire data that is signed
**              f_pdstrSignatureValue -   Sig value 
**              f_pdstrCertChainXML -   <CERTIFICATECHAIN>...</CERTIFICATECHAIN>
**              f_fCheckExpiry      -   Check for cert expiration
**              f_fCheckCertChain   -   Verify cert chain. If this is false,
**                                      f_pcontextCrypto->pubKey must contain
**                                      the public key which will be used to
**                                      verify the signature.
**              f_eRootPubkey       -   Root Pubkey to use for cert verification
**              f_pcontextLEVL      -   License eval context.  The HDS, pcontextSSTRevocation, 
**                                      and BBX pointers must be valid 
**
** Returns :    DRM_SUCCESS -   Signature verified successfully
**              DRM_E_INVALID_SIGNATURE -   Verification failed
**              some other problem
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT _UTL_VerifySignature(
    IN  const   DRM_CONST_STRING        *f_pdstrSignedData,
    IN  const   DRM_CONST_STRING        *f_pdstrSignatureValue,
    IN  const   DRM_CONST_STRING        *f_pdstrCertChainXML,
    IN          DRM_BOOL                 f_fCheckExpiry,
    IN          DRM_BOOL                 f_fCheckCertChain,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey,
    IN          DRM_LICEVAL_CONTEXT     *f_pcontextLEVL)
{
    DRM_BOOL         fFirstCertCheck =   TRUE;
    DRM_CONST_STRING dstrCert        =   EMPTY_DRM_STRING;
    DRM_DWORD        cbSignature     =   0;
    DRM_DWORD        iCert           =   0;
    DRM_RESULT       dr              =   DRM_SUCCESS;    
    
    /*
    **  No need to verify input in internal function
    */    
    
#if DRM_SUPPORT_CERTIFICATE_CACHING
    if( _VerifyCachedCertificate( f_pcontextLEVL, 
                                  PB_DSTR( f_pdstrSignedData ), 
                                  CB_DSTR( f_pdstrSignedData ) ) )
    {
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }
#endif

    if (f_fCheckCertChain)
    {
        /*
        **  Verify cert chain 
        */  
        while( TRUE ) /*    Loop will break when DRM_E_XMLNOTFOUND is hit */
        {
            DRM_DWORD cbCert = SIZEOF(CERT);

            dr  =   DRM_XML_GetSubNode( f_pdstrCertChainXML, 
                                       &g_dstrTagCertificate, 
                                        NULL, 
                                        NULL, 
                                        iCert, 
                                        NULL, 
                                       &dstrCert, 
                                        1);
            iCert++;

            if (dr == DRM_E_XMLNOTFOUND)
            {
                break;
            }
            ChkDR(dr);
            
            ChkDR(DRM_B64_DecodeW( &dstrCert, 
                                   &cbCert, 
                       (DRM_BYTE*) &f_pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert,
                                    0) );

            ChkDR(  DRM_UTL_CheckCertificate( &f_pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert, 
                                               fFirstCertCheck ? NULL : &f_pcontextLEVL->pcontextBBX->CryptoContext.pubKey, 
                                               f_fCheckExpiry, 
                                               f_pcontextLEVL,
                                               f_eRootPubkey) );
            
            MEMCPY( &(f_pcontextLEVL->pcontextBBX->CryptoContext.pubKey), 
                    &(f_pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert.cd.pk), 
                      SIZEOF(PUBKEY) );
            
            fFirstCertCheck = FALSE;        
        }
        
        if( iCert == 1 )
        {
            dr = DRM_E_INVALID_SIGNATURE;   /*  No certificates */
            goto ErrorExit;
        }
        /*
        **  f_pcontextCrypto->pubKey now contains the pubkey needed for verification
        */        
    }
        
    cbSignature = SIZEOF(f_pcontextLEVL->pcontextBBX->CryptoContext.signature);
    ChkDR(DRM_B64_DecodeW( f_pdstrSignatureValue, 
                          &cbSignature, 
                           f_pcontextLEVL->pcontextBBX->CryptoContext.signature, 
                           0) );
    
    if( !DRM_PK_Verify( f_pcontextLEVL->pcontextBBX->CryptoContext.rgbCryptoContext, 
                       &f_pcontextLEVL->pcontextBBX->CryptoContext.pubKey,
                        PB_DSTR(f_pdstrSignedData), 
                        CB_DSTR(f_pdstrSignedData),
                        f_pcontextLEVL->pcontextBBX->CryptoContext.signature) )
    {       
        dr = DRM_E_INVALID_SIGNATURE;
    }
#if DRM_SUPPORT_CERTIFICATE_CACHING
    else
    {
        (void)_AddCachedCertificate( f_pcontextLEVL, 
                                     PB_DSTR( f_pdstrSignedData ), 
                                     CB_DSTR( f_pdstrSignedData ) );
    }
#endif

    
ErrorExit:
    return dr;
}

static DRM_RESULT _CheckCertificate(
    const CERT                *f_pcert,
    const PUBKEY              *f_ppubkey,
          DRM_BOOL             f_fCheckDate,
          DRM_LICEVAL_CONTEXT *f_pcontextLEVL )
{
    DRM_DWORD  cbData = 0;
    DRM_RESULT dr     = DRM_SUCCESS;

    ChkArg(f_pcert        != NULL
        && f_ppubkey      != NULL
        && f_pcontextLEVL != NULL
        && f_pcontextLEVL->pcontextBBX != NULL );

    BYTES_TO_DWORD(cbData, f_pcert->datalen);

    if (MEMCMP(f_pcert->certVersion, (DRM_BYTE *)CERT_VER, VERSION_LEN) != 0)
    {
        ChkDR(DRMUTIL_UNSUPPORTED_VERSION);
    }

    if (f_fCheckDate && !DRM_UTL_IsCertDateOK(f_pcert->cd.expiryDate))
    {
        ChkDR(DRMUTIL_EXPIRED_CERT);
    }

#if DRM_SUPPORT_CERTIFICATE_CACHING
    /*
    ** First check to see if the certificate signature is cached.  
    ** If it is then we don't need to call DRM_PK_Verify 
    */
    if( !_VerifyCachedCertificate( f_pcontextLEVL, (const DRM_BYTE*) f_pcert, sizeof( *f_pcert ) ) )
#endif
    {
        if (! DRM_PK_Verify( f_pcontextLEVL->pcontextBBX->CryptoContext.rgbCryptoContext, 
                             f_ppubkey, 
               (DRM_BYTE *) &f_pcert->cd, 
                             cbData, 
                             f_pcert->sign))
        {
            ChkDR(DRMUTIL_INVALID_CERT);
        }
#if DRM_SUPPORT_CERTIFICATE_CACHING
        (void)_AddCachedCertificate( f_pcontextLEVL, (const DRM_BYTE*) f_pcert, sizeof( *f_pcert ) );
#endif
    }

ErrorExit:
    return dr;
}


/******************************************************************************
** 
** Function :   DRM_UTL_CheckCertificate
** 
** Synopsis :   Verifies the signature on a certificate using either the 
**              supplied public key, or the default for the supplied
**              DRM_ROOTPUBKEY_CATEGORY
** 
** Arguments :  f_pcert     -   Cert to be checked
**              f_ppubkey   -   Pubkey to be used for verification - If it is 
**                              NULL, use appropriate hard-coded key
**              f_fCheckCertDate    -   Check for expiration
**              f_pcontextCrypto   -   Crypto context
**              f_eRootPubkey   -   The root pubkey to use if f_ppubkey is NULL.
**                                  if it is WM_DRM_ROOTPUBKEY_CLK
**                                  f_pcontextCrypto->pubKey will hold the root
**                                  public key to use to verify the cert chain.
**              
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_UTL_CheckCertificate(
    IN  const   CERT                    *f_pcert, 
    IN  const   PUBKEY                  *f_ppubkey, 
    IN          DRM_BOOL                 f_fCheckCertDate,   
    IN          DRM_LICEVAL_CONTEXT     *f_pcontextLEVL,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey)
{
    DRM_RESULT  dr          =   DRM_SUCCESS;
    PUBKEY      *ppubkey    =   NULL;
    
    static PUBKEY pubkeyMSCERT = { {
            TWO_BYTES(0x4D, 0xBF), TWO_BYTES(0xD9, 0x0D), TWO_BYTES(0xD9, 0x6E), TWO_BYTES(0x8C, 0x9E),
            TWO_BYTES(0x32, 0x5F), TWO_BYTES(0x4F, 0x3D), TWO_BYTES(0xEC, 0xA9), TWO_BYTES(0x84, 0x59),
            TWO_BYTES(0x6B, 0x5E), TWO_BYTES(0x06, 0x86), TWO_BYTES(0xE7, 0xE2), TWO_BYTES(0xC2, 0x8B),
            TWO_BYTES(0xDE, 0x14), TWO_BYTES(0x4B, 0x29), TWO_BYTES(0x2C, 0xEC), TWO_BYTES(0x4D, 0x1D),
            TWO_BYTES(0x76, 0xFD), TWO_BYTES(0x5A, 0x14), TWO_BYTES(0x90, 0x3A), TWO_BYTES(0x10, 0x77)
    } };

    static PUBKEY pubkeyMSSecureClock = { {
            TWO_BYTES(0xF8, 0x23), TWO_BYTES(0x61, 0xBE), TWO_BYTES(0xFC, 0xF5), TWO_BYTES(0x59, 0xA3), 
            TWO_BYTES(0x55, 0xD4), TWO_BYTES(0x01, 0x54), TWO_BYTES(0x99, 0xEB), TWO_BYTES(0x71, 0x92), 
            TWO_BYTES(0xF9, 0xBD), TWO_BYTES(0x88, 0x3E), TWO_BYTES(0x14, 0xAC), TWO_BYTES(0x4F, 0x5C), 
            TWO_BYTES(0x9C, 0x65), TWO_BYTES(0x22, 0xFA), TWO_BYTES(0xA7, 0x2A), TWO_BYTES(0x77, 0x13), 
            TWO_BYTES(0x22, 0x5E), TWO_BYTES(0x60, 0xF5), TWO_BYTES(0xFE, 0x29), TWO_BYTES(0x18, 0x18)
    } }; 
    static PUBKEY pubkeyRootMeteringCert = 
    {
        TWO_BYTES(0x45, 0xB1), TWO_BYTES(0xA7, 0xE1), TWO_BYTES(0x90, 0x81), TWO_BYTES(0x98, 0x37), 
        TWO_BYTES(0x00, 0xCC), TWO_BYTES(0x89, 0xA7), TWO_BYTES(0x57, 0x24), TWO_BYTES(0x72, 0xB9), 
        TWO_BYTES(0xC1, 0x29), TWO_BYTES(0xA3, 0x62), TWO_BYTES(0xD9, 0x55), TWO_BYTES(0x74, 0x04), 
        TWO_BYTES(0x02, 0x7D), TWO_BYTES(0x6E, 0x69), TWO_BYTES(0x79, 0xE9), TWO_BYTES(0x6A, 0xD9), 
        TWO_BYTES(0x7A, 0x92), TWO_BYTES(0xE4, 0xF3), TWO_BYTES(0x4B, 0x6B), TWO_BYTES(0x42, 0x6C)
    };

    if (f_ppubkey != NULL)
    {
        ppubkey = (PUBKEY *)f_ppubkey;
    }
    else
    {
        switch(f_eRootPubkey)
        {
        case WM_DRM_ROOTPUBKEY_LRB:
        case WM_DRM_ROOTPUBKEY_LICENSES:
            ppubkey = &pubkeyMSCERT;
            break;
            
        case WM_DRM_ROOTPUBKEY_CLK:
            ppubkey = &(f_pcontextLEVL->pcontextBBX->CryptoContext.pubKey);
            break;

        case WM_DRM_ROOTPUBKEY_MTR:
            ppubkey = &pubkeyRootMeteringCert;
            break;
        
        default :
            dr = DRM_E_INVALIDARG;
        } 
    }

    ChkDR( _CheckCertificate( f_pcert, 
                              ppubkey, 
                              f_fCheckCertDate, 
                              f_pcontextLEVL) );

ErrorExit:
    return dr;
}

static PUBKEY pubkeyMS = 
{ 
    {
        TWO_BYTES(0x4D, 0xBF), TWO_BYTES(0xD9, 0x0D), TWO_BYTES(0xD9, 0x6E), TWO_BYTES(0x8C, 0x9E),
        TWO_BYTES(0x32, 0x5F), TWO_BYTES(0x4F, 0x3D), TWO_BYTES(0xEC, 0xA9), TWO_BYTES(0x84, 0x59),
        TWO_BYTES(0x6B, 0x5E), TWO_BYTES(0x06, 0x86), TWO_BYTES(0xE7, 0xE2), TWO_BYTES(0xC2, 0x8B),
        TWO_BYTES(0xDE, 0x14), TWO_BYTES(0x4B, 0x29), TWO_BYTES(0x2C, 0xEC), TWO_BYTES(0x4D, 0x1D),
        TWO_BYTES(0x76, 0xFD), TWO_BYTES(0x5A, 0x14), TWO_BYTES(0x90, 0x3A), TWO_BYTES(0x10, 0x77)
    } 
};

DRM_RESULT DRM_API DRM_UTL_CheckCert(
    IN const CERT                *f_pcert, 
    IN const PUBKEY              *f_ppubkey, 
    IN       DRM_BOOL             f_fCheckDate, 
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR(_CheckCertificate( f_pcert, 
                            (f_ppubkey != NULL) ? f_ppubkey : &pubkeyMS, 
                             f_fCheckDate, 
                             f_pcontextLEVL) );

ErrorExit:
    return (dr);
}

DRM_RESULT DRM_API DRM_UTL_CheckCertNoCache(
    IN const CERT               *f_pcert, 
    IN const PUBKEY             *f_ppubkey, 
    IN       DRM_BOOL            f_fCheckDate, 
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT contextLEVL = {0};

    /* 
    ** This is a safe cast.  When the underlying CheckCert functions are called
    ** the will not use the BBX as a BBX, they will just use it as a crypto context.
    */
    contextLEVL.pcontextBBX = (DRM_BB_CONTEXT*)f_pcontextCRYP;

    ChkDR(_CheckCertificate( f_pcert, 
                            (f_ppubkey != NULL) ? f_ppubkey : &pubkeyMS, 
                             f_fCheckDate, 
                            &contextLEVL) );

ErrorExit:
    return (dr);
}

DRM_RESULT DRM_API DRM_UTL_CheckDACCert(
    IN const CERT                *f_pcert, 
    IN const PUBKEY              *f_ppubkey, 
    IN       DRM_BOOL             f_fCheckDate, 
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL)
{
    DRM_RESULT    dr = DRM_SUCCESS;

    static PUBKEY pubkeyDeviceAuthorizationCertificate = 
    { 
        {
            TWO_BYTES(0x4D, 0xBF), TWO_BYTES(0xD9, 0x0D), TWO_BYTES(0xD9, 0x6E), TWO_BYTES(0x8C, 0x9E),
            TWO_BYTES(0x32, 0x5F), TWO_BYTES(0x4F, 0x3D), TWO_BYTES(0xEC, 0xA9), TWO_BYTES(0x84, 0x59),
            TWO_BYTES(0x6B, 0x5E), TWO_BYTES(0x06, 0x86), TWO_BYTES(0xE7, 0xE2), TWO_BYTES(0xC2, 0x8B),
            TWO_BYTES(0xDE, 0x14), TWO_BYTES(0x4B, 0x29), TWO_BYTES(0x2C, 0xEC), TWO_BYTES(0x4D, 0x1D),
            TWO_BYTES(0x76, 0xFD), TWO_BYTES(0x5A, 0x14), TWO_BYTES(0x90, 0x3A), TWO_BYTES(0x10, 0x77)
        } 
    };

    ChkDR(_CheckCertificate( f_pcert, 
                            (f_ppubkey != NULL) ? f_ppubkey : &pubkeyDeviceAuthorizationCertificate,
                             f_fCheckDate, 
                             f_pcontextLEVL) );

ErrorExit:
    return (dr);
}

static DRM_BOOL HexStringToDword(
    IN const DRM_WCHAR *f_pwsz,
       OUT   DRM_DWORD *f_pdwValue,
    IN       DRM_INT    f_cDigits)
{
    DRM_INT  iDigit;    
    DRM_BOOL fOK = TRUE;
    DRM_DWORD dwValue = 0;
    
    *f_pdwValue = 0;
    
    for (iDigit = 0; 
         iDigit < f_cDigits; 
         iDigit++)
    {
        dwValue <<= 4;
        if( NATIVE_WCHAR(f_pwsz[iDigit]) >= NATIVE_WCHAR(g_wch0) 
         && NATIVE_WCHAR(f_pwsz[iDigit]) <= NATIVE_WCHAR(g_wch9))
        {
            dwValue += NATIVE_WCHAR(f_pwsz[iDigit]) - NATIVE_WCHAR(g_wch0);
        }
        else if( NATIVE_WCHAR(f_pwsz[iDigit]) >= NATIVE_WCHAR(g_wchA)
              && NATIVE_WCHAR(f_pwsz[iDigit]) <= NATIVE_WCHAR(g_wchF) )
        {
            
            dwValue += NATIVE_WCHAR(f_pwsz[iDigit]) - NATIVE_WCHAR(g_wchA) + 10;            
        }
        else if( NATIVE_WCHAR(f_pwsz[iDigit]) >= NATIVE_WCHAR(g_wcha) 
              && NATIVE_WCHAR(f_pwsz[iDigit]) <= NATIVE_WCHAR(g_wchf) )
        {
            dwValue += NATIVE_WCHAR(f_pwsz[iDigit]) - NATIVE_WCHAR(g_wcha) + 10;
        }
        else
        {
            /* Reverse the shift operation if all the range checks failed */
        	dwValue >>= 4;
            fOK = FALSE;
        }
    }
    
    MEMCPY( f_pdwValue, &dwValue, SIZEOF( dwValue ) );

    return fOK;
}

/*****************************************************************************
** Function: DRM_UTL_NumberToString
**
** Synopsis: express an unsigned long as a base10 UNICODE string.  
**
** Arguments:
** [f_dwValue]   -- value to translate
** [f_pszBuffer] -- output buffer
** [f_cchBuffer] -- output buffer size
**
** Returns string length
**
** Notes:    Output is not NUL-terminated 
*****************************************************************************/

DRM_DWORD DRM_API DRM_UTL_NumberToString(
    IN  DRM_DWORD  f_dwValue, 
    OUT DRM_WCHAR *f_pszBuffer, 
    IN  DRM_DWORD  f_cchBuffer)
{
    DRM_WCHAR *pszBuffer = f_pszBuffer + (f_cchBuffer  - 1);     /* last digit at end of buffer */
    DRM_DWORD  cchOut    = 0;

    if (f_dwValue == 0)
    {
        *f_pszBuffer = g_wch0;
        cchOut = 1;
    }
    else 
    {
        while (f_dwValue != 0 
           &&  pszBuffer >= f_pszBuffer) 
        {
            cchOut++;
            *pszBuffer-- = WCHAR_CAST(NATIVE_WCHAR(g_wch0) + (f_dwValue % 10)); /* store the digit */
            f_dwValue /= 10;            /* reduce number */        
        }

        /* Shift string to begin offset */
        DRM_BYT_MoveBytes(f_pszBuffer, 0, pszBuffer, 1, cchOut * SIZEOF (DRM_WCHAR)); 
    }    
    
    return cchOut; /* compute length of number & return */
}

/*****************************************************************************
** Function: DRM_UTL_GetVersionAsString
**
** Synopsis: express n version binary as a base10 dotted UNICODE string.  
**
** Arguments:
** [f_rgbVersion]   -- version as binary
** [f_wszVerString] -- output buffer
**
** Returns string length
**
** Notes:    Output is not NUL-terminated 
*****************************************************************************/

DRM_RESULT DRM_API DRM_UTL_GetVersionAsString(
    IN  DRM_BYTE  f_rgbVersion   [__CB_DECL(VERSION_LEN)],
    OUT DRM_WCHAR f_wszVerString [VER_STRING_MAX_LEN])
{
    DRM_INT ich = 0;
    DRM_INT ib  = 0;
    
    /* 
    ** (VER_STRING_MAX_LEN - 4) / 4 :
    ** This is 4 characters for the 3 periods and the NULL terminator.
    ** We divide by 4 because we have to perform the operation 4 times and give an equal buffer size to each operation
    */
       
    for (ib = 0; ib < VERSION_LEN; ib++)
    {
        ich += DRM_UTL_NumberToString( GET_BYTE(f_rgbVersion, ib), 
                                      &f_wszVerString[ich], 
                                      (VER_STRING_MAX_LEN - 4) / 4);
        
        f_wszVerString [ich++] = g_wchPeriod;
    }

    /* Overwrite that last g_wchPeriod with the NULL terminator */
    f_wszVerString [ich-1] = g_wchNull;

    return DRM_SUCCESS;
}

DRM_RESULT DRM_API DRM_UTL_GetVersionFromString(
   IN const DRM_WCHAR  *pwszVersion,
   IN       DRM_DWORD   cchVersion,
      OUT   DRM_WORD    rgwVersion[VERSION_LEN] )
{
    DRM_UINT uVer[VERSION_LEN];
	DRM_DWORD iCount = 0;
    DRM_DWORD ich = 0;
    
    for( iCount = 0; iCount < VERSION_LEN - 1; iCount++ )
    {
        ich = 0;
        while( ich < cchVersion )
        {
            if( pwszVersion[ich] == g_wchPeriod )
            {
                break;
            }
            ich++;
        }
        if( pwszVersion[ich] != g_wchPeriod                                        /* Didn't find a . seperator */
         || DRM_FAILED( wcsntol( pwszVersion, ich, (DRM_LONG *) &uVer [iCount] ) ) /* Couldn't extract a number */
         || uVer[iCount]     != (DRM_WORD) uVer[iCount] )                          /* Not in a valid range      */
        {
            return CPRMEXP_INVALID_ARGUMENT;
        }

        cchVersion -= (ich+1);
        pwszVersion = pwszVersion + (ich + 1);
    }

    if( DRM_FAILED( wcsntol( pwszVersion, cchVersion, (DRM_LONG *) &uVer [iCount] ) ) /* Couldn't extract a number */
     || uVer[iCount] != (DRM_WORD) uVer[iCount] )                                     /* Not in a valid range      */
    {
        return CPRMEXP_INVALID_ARGUMENT;
    }

    for( iCount = 0; iCount < VERSION_LEN; iCount++ )
    {
        rgwVersion[iCount] = (DRM_WORD)uVer[iCount];
    }
    return DRM_SUCCESS;

}

DRM_RESULT DRM_API DRM_UTL_StringToGuid(
    IN const DRM_CONST_STRING *pdstrString,
    OUT      DRM_GUID         *pGuid)
{
    DRM_RESULT dr      = DRM_SUCCESS;
    DRM_DWORD  dwValue = 0;
    DRM_INT ib;

    ChkArg(pdstrString != NULL 
        && pGuid       != NULL 
        && pdstrString->pwszString != NULL 
        && pdstrString->cchString  == 38); /* 38 characters in a proper Guid String - including { } */

    ChkArg(pdstrString->pwszString [0]  == g_wchOpenCurly 
        && pdstrString->pwszString [37] == g_wchCloseCurly); /* First and last char must be { & } */

    /* Validate the delimitar characters */

    if (pdstrString->pwszString [9]  != g_wchMinus 
     || pdstrString->pwszString [14] != g_wchMinus 
     || pdstrString->pwszString [19] != g_wchMinus 
     || pdstrString->pwszString [24] != g_wchMinus)
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    /* Convert pieces to BYTES */
    
    if (! HexStringToDword(pdstrString->pwszString + 1, &pGuid->Data1, 8))
    {
        ChkDR(DRM_E_INVALIDARG);
    }
    if (! HexStringToDword(pdstrString->pwszString + 10, &dwValue, 4))
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    pGuid->Data2 = (DRM_SHORT) dwValue;

    if (! HexStringToDword(pdstrString->pwszString + 15, &dwValue, 4))
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    pGuid->Data3 = (DRM_SHORT) dwValue;

    if (! HexStringToDword(pdstrString->pwszString + 20, &dwValue, 2))
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    PUT_BYTE(pGuid->Data4, 0, (DRM_BYTE) dwValue);

    if (! HexStringToDword(pdstrString->pwszString + 22, &dwValue, 2))
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    PUT_BYTE(pGuid->Data4, 1, (DRM_BYTE) dwValue);

    for (ib = 2; ib < 8; ib++)
    {
        if (! HexStringToDword(pdstrString->pwszString  + (((ib - 1) * 2) + 23), &dwValue, 2))
        {
            ChkDR(DRM_E_INVALIDARG);
        }

        PUT_BYTE(pGuid->Data4,ib, (DRM_BYTE) dwValue);
    }
    
    FIX_ENDIAN_DWORD( pGuid->Data1 );
    FIX_ENDIAN_WORD(  pGuid->Data2 );
    FIX_ENDIAN_WORD(  pGuid->Data3 );

    /* We have validated the string && now the bits are converted. */
ErrorExit:
    return dr;
}

DRM_BOOL DRM_API DRM_UTL_DASSSTRStringsEqual(
    const DRM_CHAR      *f_pszBase0,
    const DRM_SUBSTRING *f_pdasstr0,
    const DRM_CHAR      *f_pszBase1,
    const DRM_SUBSTRING *f_pdasstr1)
{
    return (f_pdasstr0->m_cch == f_pdasstr1->m_cch
        &&  DRM_BYT_CompareBytes(f_pszBase0, 
                                 f_pdasstr0->m_ich, 
                                 f_pszBase1, 
                                 f_pdasstr1->m_ich,
                                 f_pdasstr1->m_cch) == 0);
}

/**********************************************************************
** Function:    PKEncryptLarge
**
** Synopsis:    Encrypt large amoutn of data (using PKEncrypt with large data is slow, this is fast)
**
** Arguments:   [f_ppubkey]        -- Caller supplied public key to encrypt with
**              [f_pbClear]        -- Array of bytes to encrypt
**              [f_cbClear]        -- Length ob f_pbClear in bytes
**              [f_pbCipher]       -- Buffer to hold encrypted data
**              [f_cbKeySymmetric] -- Desired length of internal symmertic key to be created
**              [f_pcontextCRYP]   -- A DRM_CRYPTO_CONTEXT so PKCrypto operations can be performed.
**
** Notes:       out must be of length f_cbClear + PK_ENC_CIPHERTEXT_LEN
**              Internally a rc4 symmetric key will be created to encrypt the content (because it's fast) &
**              that symmertic key will be encrypted with the PUBKEY.
**              In place encryption is possible if f_pbCipher equals to f_pbClear.
***********************************************************************/

DRM_RESULT DRM_API DRM_PK_EncryptLarge(
    IN const PUBKEY              *f_ppubkey,
    IN OUT   DRM_BYTE            *f_pbClear, 
    IN       DRM_DWORD            f_cbClear, 
       OUT   DRM_BYTE            *f_pbCipher, 
    IN       DRM_DWORD            f_cbKeySymmetric, 
    IN       DRM_CRYPTO_CONTEXT  *f_pcontextCRYP)
{
    DRM_RESULT     dr    = DRM_SUCCESS;
    DRM_BYTE      *pbKey = NULL; /* This needs __CB_DECL(PK_ENC_PLAINTEXT_LEN) bytes */
    RC4_KEYSTRUCT  rc4KS;
    
    ChkArg(f_ppubkey      != NULL
        && f_pbClear      != NULL
        && f_pbCipher     != NULL
        && f_pcontextCRYP != NULL);

    ChkArg(f_cbKeySymmetric <= (PK_ENC_PLAINTEXT_LEN - 2)) 
    
    if (f_cbKeySymmetric > DRMCIPHERKEYLEN)
    {
        f_cbKeySymmetric = DRMCIPHERKEYLEN;
    }

    /* Ensure the temporary buffer we are using is big enough */
    DRMCASSERT( PK_ENC_PLAINTEXT_LEN <= SIZEOF( f_pcontextCRYP->signature ) );
    pbKey = f_pcontextCRYP->signature;

    DRM_BYT_MoveBytes(f_pbCipher, PK_ENC_CIPHERTEXT_LEN, f_pbClear, 0, f_cbClear);

    PUT_BYTE( pbKey, 0, (DRM_BYTE) f_cbKeySymmetric );
    PUT_BYTE( pbKey, 1, (DRM_BYTE) PKSYMM_ALG_TYPE_RC4 );

    ChkDR(OEM_GenRandomBytes(pbKey + __CB_DECL(2), f_cbKeySymmetric));
    ChkDR(DRM_PK_Encrypt(f_pcontextCRYP->rgbCryptoContext, f_ppubkey, pbKey, f_pbCipher));
        
    DRM_RC4_KeySetup(&rc4KS, f_cbKeySymmetric, pbKey      + __CB_DECL(2));
    DRM_RC4_Cipher  (&rc4KS, f_cbClear,        f_pbCipher + __CB_DECL(PK_ENC_CIPHERTEXT_LEN));

ErrorExit:
    return dr;
}    

/**********************************************************************
** Function:    DRM_PK_DecryptLarge
**
** Synopsis:    Dencrypt data encrypted with DRM_PK_EncryptLarge
**
** Arguments:   [f_ppubkey] -- Caller supplied private key to decrypt with
**              [f_pbCipher]    -- Array of bytes to decrypt
**              [f_cbCipher]    -- Length of f_pbCipher in bytes
**              [f_pbClear]   -- Buffer to hold decrypted data
**              [f_pcontextCRYP] -- A DRM_CRYPT_CONTEXT so PKCrypto operations can be performed.
**
** Notes:       out must be at least f_cbCipher - PK_ENC_CIPHERTEXT_LEN in length.
**              In place decryption is possible if f_pbClear equals to f_pbCipher.
***********************************************************************/

DRM_RESULT DRM_API DRM_PK_DecryptLarge(
    IN const PRIVKEY            *f_ppubkey,
    IN OUT   DRM_BYTE           *f_pbCipher, 
    IN       DRM_DWORD           f_cbCipher, 
    OUT      DRM_BYTE           *f_pbClear, 
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP)
{
    DRM_RESULT     dr    = DRM_SUCCESS;
    DRM_BYTE      *pbKey = NULL;
    RC4_KEYSTRUCT  rc4KS;

    ChkArg(f_ppubkey      != NULL
        && f_pbCipher     != NULL
        && f_pbClear      != NULL
        && f_pcontextCRYP != NULL);         

    /* Ensure the temporary buffer we are using is big enough */
    DRMCASSERT( PK_ENC_PLAINTEXT_LEN <= SIZEOF( f_pcontextCRYP->signature ) );
    pbKey = f_pcontextCRYP->signature;

    ChkDR(DRM_PK_Decrypt( f_pcontextCRYP->rgbCryptoContext, 
                          f_ppubkey, 
                          f_pbCipher, 
                          pbKey));

    if (GET_BYTE(pbKey,1) != PKSYMM_ALG_TYPE_RC4)
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    DRM_BYT_MoveBytes(f_pbClear,
                      0,
                      f_pbCipher,
                      PK_ENC_CIPHERTEXT_LEN,
                      f_cbCipher - PK_ENC_CIPHERTEXT_LEN);

    DRM_RC4_KeySetup(&rc4KS, GET_BYTE(pbKey,0),                  pbKey + __CB_DECL(2));
    DRM_RC4_Cipher  (&rc4KS, f_cbCipher - PK_ENC_CIPHERTEXT_LEN, f_pbClear);

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_PK_SymmetricCrypt
** 
** Synopsis :   Encrypts/Decrypts data using a symmetric key derived from
**              a private key
** 
** Arguments :  f_pprivkey - Private key
**              f_cbCipher, f_pbCipher - # of bytes and buffer for ciphertext
**              f_cbClear, f_pbClear - # of bytes and buffer for cleartext. If 
**                  this buffer is NULL, decrypt/encrypt would be done in place.

******************************************************************************/
DRM_RESULT DRM_API DRM_PK_SymmetricCrypt(
    IN const DRM_BYTE  *f_pbKey,
    IN       DRM_DWORD  f_cbKey,
    IN       DRM_DWORD  f_cbCipher,
    IN       DRM_BYTE  *f_pbCipher,
    IN       DRM_DWORD  f_cbClear,
       OUT   DRM_BYTE  *f_pbClear )
{
    DRM_BYTE        rgbDigest[__CB_DECL(SHA_DIGEST_LEN)];
    DRM_BYTE       *pbClear = NULL;
    DRM_DWORD       cbClear = 0;
    DRM_RESULT      dr      = DRM_SUCCESS;
    RC4_KEYSTRUCT   rc4keystruct;
    SHA_CONTEXT     contextSHA;  
    
    ChkArg( f_pbKey    != NULL
         && f_cbKey     > 0
         && f_pbCipher != NULL );
    
    if ( f_pbClear != NULL )
    {
        ChkArg( f_cbCipher == f_cbClear );
        cbClear = f_cbClear;
        pbClear = f_pbClear;
        MEMCPY(pbClear, f_pbCipher, cbClear);
    }
    else
    {
        pbClear = f_pbCipher;
        cbClear = f_cbCipher;
    }
        
    /*
    **  1. Get a hash of the privkey
    **  2. Generate a RC4 key using this hash
    **  3. Decrypt ciphertext using this RC4 key
    */
    DRM_SHA_Init( &contextSHA );
    DRM_SHA_Update( f_pbKey, f_cbKey, &contextSHA );
    DRM_SHA_Finalize( &contextSHA, rgbDigest );

    DRM_RC4_KeySetup( &rc4keystruct, SIZEOF(rgbDigest) , rgbDigest );
    DRM_RC4_Cipher( &rc4keystruct, cbClear, pbClear );

    ZEROMEM( &rc4keystruct, SIZEOF(rc4keystruct) );
    ZEROMEM( &contextSHA,   SIZEOF(contextSHA) );
    
ErrorExit:
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_PK_SymmetricSign
**
**  Synopsis:  Creates a symmetric signature using a private key provided by the caller.
**
**  Arguments:  
**     [f_pprivkey]  -- Private key to sign with
**     [f_pbData]    -- Data to create a signature over
**     [f_cbData]    -- Length of f_pbData in DRM_BYTEs
**     [f_rgbSymSig] -- Buffer of length SHA_DIGEST_LEN DRM_BYTEs where the signature will be returned.
**
**  Notes:  Use DRM_PK_SymmetricVerify to verify a signature created with DRM_PK_SymmetricSign.
**
*********************************************************************/
DRM_RESULT DRM_API DRM_PK_SymmetricSign(
    IN const DRM_BYTE  *f_pbKey,
    IN       DRM_DWORD  f_cbKey,
    IN const DRM_BYTE *f_pbData,
    IN       DRM_DWORD f_cbData,
       OUT   DRM_BYTE  f_rgbSymSig[__CB_DECL( SHA_DIGEST_LEN )] )
{
    HMAC_CONTEXT hmac;
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR( DRM_HMAC_Init(     &hmac, f_pbKey,     f_cbKey ) );
    ChkDR( DRM_HMAC_Update(   &hmac, f_pbData,    f_cbData ) );
    ChkDR( DRM_HMAC_Finalize( &hmac, f_rgbSymSig, SHA_DIGEST_LEN ) );

ErrorExit:
    return dr;
}

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
/*********************************************************************
**
**  Function:  DRM_PK_SymmetricVerify
**
**  Synopsis:  Verifies a symmetric signature using a private key provided by the caller.
**
**  Arguments:  
**     [f_pprivkey]  -- Private key with which to verify the signature
**     [f_pbData]    -- Data to verify
**     [f_cbData]    -- Length of f_pbData in DRM_BYTEs
**     [f_rgbSymSig] -- Buffer of length SHA_DIGEST_LEN DRM_BYTEs of the signature to verify
**
**  Notes:  Use DRM_PK_SymmetricSign to create a symmetric signature
*********************************************************************/
DRM_RESULT DRM_API DRM_PK_SymmetricVerify(
    IN const DRM_BYTE  *f_pbKey,
    IN       DRM_DWORD  f_cbKey,
    IN const DRM_BYTE *f_pbData,
    IN       DRM_DWORD f_cbData,
    IN const DRM_BYTE  f_rgbSymSig[__CB_DECL( SHA_DIGEST_LEN )] )
{
    HMAC_CONTEXT hmac;
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   rgbSymSig[__CB_DECL( SHA_DIGEST_LEN )];

    ChkDR( DRM_HMAC_Init(     &hmac, f_pbKey,   f_cbKey ) );
    ChkDR( DRM_HMAC_Update(   &hmac, f_pbData,  f_cbData ) );
    ChkDR( DRM_HMAC_Finalize( &hmac, rgbSymSig, SHA_DIGEST_LEN ) );

    if( MEMCMP( f_rgbSymSig, rgbSymSig, SHA_DIGEST_LEN ) != 0 )
    {
        dr = DRM_E_INVALID_SIGNATURE;
    }

ErrorExit:
    return dr;
}
#endif

/**********************************************************************
** Function:    DRM_UTL_StringInsertSubString
**
** Synopsis:    Insert a substring to a target string at specific insertion point
**
** Arguments:   [f_pdstrTarget]  -- target string
**              [f_ichInsertion] -- insertion position of target string: index of f_pwsz.
**              [f_cch]          -- # of blank char to insert
**
** Notes:       
** - Caller is responsible to make sure there is enough room in target string.
***********************************************************************/
DRM_RESULT DRM_API DRM_UTL_StringInsertBlankSubString(
    IN OUT DRM_STRING *f_pdstrTarget,
    IN     DRM_DWORD   f_ichInsertion,
    IN     DRM_DWORD   f_cch)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchToMove     = 0;
    DRM_DWORD  ich           = 0;

    ChkDRMString(f_pdstrTarget);
    ChkArg(f_ichInsertion <= f_pdstrTarget->cchString);

    cchToMove = f_pdstrTarget->cchString - f_ichInsertion;
    
    MEMMOVE(&f_pdstrTarget->pwszString[f_ichInsertion+f_cch],
            &f_pdstrTarget->pwszString[f_ichInsertion], 
            cchToMove*SIZEOF(DRM_WCHAR));

    /* fill the hole in the blanks */
    for (ich=0; ich<f_cch; ich++)
    {
        f_pdstrTarget->pwszString[f_ichInsertion+ich] = g_wchSpace;
    }

    /* adjust destination string length */
    f_pdstrTarget->cchString += f_cch;

ErrorExit:
    return dr;
}



/**********************************************************************
** Function:    DRM_UTL_StringInsertSubString
**
** Synopsis:    Insert a substring to a target string at specific insertion point
**
** Arguments:   [f_pdstrTarget]  -- target string
**              [f_ichInsertion] -- insertion position of target string: index of f_pwsz.
**              [f_pdstrSub]     -- sub string to be inserted
**
** Notes:       
** - Caller is responsible to make sure there is enough room in target string.
***********************************************************************/

DRM_RESULT DRM_API DRM_UTL_StringInsertSubString(
    IN OUT   DRM_STRING       *f_pdstrTarget,
    IN       DRM_DWORD         f_ichInsertion,
    IN const DRM_CONST_STRING *f_pdstrSub)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMString(f_pdstrTarget);
    ChkDRMString(f_pdstrSub);
    ChkArg(f_ichInsertion <= f_pdstrTarget->cchString);

    ChkDR(DRM_UTL_StringInsertBlankSubString(f_pdstrTarget, f_ichInsertion, f_pdstrSub->cchString));

    /* copy the source string to target point */
    MEMCPY( (DRM_BYTE *) (f_pdstrTarget->pwszString + f_ichInsertion),
            PB_DSTR(f_pdstrSub), 
            CB_DSTR(f_pdstrSub));

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    DRM_UTL_StringRemoveSubString
** Synopsis:    remove a substring from the target string
** Arguments:   [f_pdstrSource] -- Source string
**              [f_pdstrSub]    -- A substring within f_pdstrSource
** Notes:       
** - Caller is responsible for sufficient buffer in destination string
***********************************************************************/

DRM_RESULT DRM_API DRM_UTL_StringRemoveSubString(
    IN OUT   DRM_STRING       *f_pdstrSource,
    IN const DRM_CONST_STRING *f_pdstrSub)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchToMove = 0;
    DRM_DWORD  ich       = 0;
    DRM_WCHAR *pwsz       = NULL;

    ChkDRMString(f_pdstrSource);
    if ( f_pdstrSub             == NULL 
      || f_pdstrSub->pwszString == NULL 
      || f_pdstrSub->cchString  == 0 )
    {
        goto ErrorExit;
    }

    /* make sure f_pdstrSub is within f_pdstrSource */
    ChkArg(f_pdstrSource->pwszString <= f_pdstrSub->pwszString);
     
    ChkArg((f_pdstrSub->pwszString    + f_pdstrSub->cchString) 
        <= (f_pdstrSource->pwszString + f_pdstrSource->cchString));
    
    cchToMove = f_pdstrSource->cchString 
              - f_pdstrSub->cchString 
              - (DRM_DWORD)(f_pdstrSub->pwszString 
              - f_pdstrSource->pwszString);

    /* move the rest of the string to cover the hole.
    ** alternative way: use memmove().
    */
    
    pwsz = (DRM_WCHAR *) f_pdstrSub->pwszString;
    
    for (ich = cchToMove; 
         ich > 0; 
         ich--)
    {
        *pwsz = pwsz [f_pdstrSub->cchString];
        pwsz++;
    }

    /* adjust string length */
    f_pdstrSource->cchString -= f_pdstrSub->cchString;

ErrorExit:
    return dr;
}

/*****************************************************************************
** Function : DRM_UTL_DSTRStringsEqual
**            DRM_UTL_DASTRStringsEqual
**
** Synopsis: case-sensitive comparison of two DRM_CONST_STRINGs or 
**           DRM_ANSI_CONST_STRINGs
**
** Arguments:
** [f_pdstr1]
** [f_pdstr2] -- strings to compare
**
** Return: TRUE if strings are same length and identical
**
** Note: No argument checking; make sure you pass valid strings
*****************************************************************************/

DRM_BOOL DRM_API DRM_UTL_DSTRStringsEqual(
    const DRM_CONST_STRING *pdstr1,
    const DRM_CONST_STRING *pdstr2)
{
    return (pdstr1->cchString == pdstr2->cchString
        &&  wcsncmp(pdstr1->pwszString, pdstr2->pwszString, pdstr1->cchString) == 0);
}

DRM_BOOL DRM_API DRM_UTL_DASTRStringsEqual(
    const DRM_ANSI_CONST_STRING *f_pdastr1,
    const DRM_ANSI_CONST_STRING *f_pdastr2)
{
    return (f_pdastr1->cchString == f_pdastr2->cchString
        &&  strncmp(f_pdastr1->pszString, f_pdastr2->pszString, f_pdastr1->cchString) == 0);
}

/*****************************************************************************
** Function : DRM_UTL_DASSTRStringsEqual
**
** Synopsis: case-sensitive comparison of an ANSI substring with a
**           DRM_ANSI_CONST_STRING
** Arguments:
** [f_pszBase] -- base of buffer into which f_pdasstr is an offset
** [f_pdasstr] -- substring of f_pszBase to compare
** [f_pdastr]  -- constant or literal string to compare
**
** Return: TRUE if strings are same length and identical
**
** Note: No argument checking; make sure you pass valid strings
*****************************************************************************/

DRM_BOOL DRM_API DRM_UTL_DASSTRStringsEqual(
    const DRM_CHAR              *f_pszBase,
    const DRM_SUBSTRING         *f_pdasstr,
    const DRM_ANSI_CONST_STRING *f_pdastr)
{
    return (f_pdasstr->m_cch  == f_pdastr->cchString
        &&  DRM_BYT_CompareBytes(f_pszBase, 
                                 f_pdasstr->m_ich, 
                                 f_pdastr->pszString, 
                                 0, 
                                 f_pdasstr->m_cch) == 0);
}

/**********************************************************************
** Function:    DRM_UTL_EnsureDataAlignment
**
** Synopsis:    return a pointer aligned on the specified data boundary
**
** Arguments:   [f_pbOriginal] -- original pointer, potentially misaligned
**              [f_cbOriginal] -- maximum size of f_pbOriginal
**              [f_ppbAligned] -- filled in with adjusted pointer
**              [f_pcbAligned] -- adjusted size, <= f_cbOriginal
**              [f_cbDataType] -- SIZEOF data type to align
**
** Notes:       address is moved forward from the original to the next
**              aligned boundary
***********************************************************************/

DRM_RESULT DRM_API DRM_UTL_EnsureDataAlignment(
    IN  DRM_BYTE   *f_pbOriginal,
    IN  DRM_DWORD   f_cbOriginal,
    OUT DRM_BYTE  **f_ppbAligned,
    OUT DRM_DWORD  *f_pcbAligned,
    IN  DRM_DWORD   f_cbDataType,
    OUT DRM_DWORD  *f_pcbAdjustment)
{
    DRM_RESULT      dr         = DRM_SUCCESS;
    DRM_DWORD_PTR   pvOriginal = (DRM_DWORD_PTR) f_pbOriginal;
    DRM_DWORD       cbScrap    = 0;
    DRM_DWORD       cbAdjust   = 0;

    ChkArg (f_pbOriginal != NULL
        &&  f_cbOriginal  > 0
        &&  f_ppbAligned != NULL
        &&  f_pcbAligned != NULL
        &&  f_cbDataType >= 1);

    /* e.g. for a DWORD on an 4n + 1 address, cbScrap = 1 */
        
    cbScrap  = (DRM_DWORD) (pvOriginal % f_cbDataType);

    /* e.g. for a DWORD on an 4n + 1 address, cbAdjust = 3 */
        
    if (cbScrap > 0)        
    {
        cbAdjust = (DRM_DWORD) (f_cbDataType - cbScrap);
    }
    
    /* check to see if it's already aligned */
        
    if (cbScrap == 0)
    {
        *f_ppbAligned = f_pbOriginal;
        *f_pcbAligned = f_cbOriginal;
    }
    else
    {
        /* verify that an adjusted pointer won't straddle the boundary */
        
        if ((f_cbDataType + cbAdjust) < f_cbOriginal)
        {
            *f_ppbAligned = (DRM_BYTE *) (pvOriginal) + (DRM_WORD) cbAdjust;
            *f_pcbAligned =  f_cbOriginal - cbAdjust;
        }
        else
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
    }

    if (f_pcbAdjustment != NULL)
    {
        *f_pcbAdjustment = cbAdjust;
    }
    
ErrorExit:    
    return dr;
} /* DRM_UTL_EnsureDataAlignment */

/******************************************************************************
** 
** Function :   DRM_UTL_VerifyXMLSignature
** 
** Synopsis :   Verify the xml signature over some data
** 
** Arguments :  f_pdstrSignedData   -   The entire data that is signed
**              f_pdstrSignatureXML -   <SIGNATURE>...</SIGNATURE> 
**              f_pdstrCertChainXML -   <CERTIFICATECHAIN>...</CERTIFICATECHAIN>
**              f_fCheckExpiry      -   Check for cert expiration
**              f_fCheckCertChain   -   Verify cert chain. If this is false,
**                                      f_pcontextCrypto->pubKey must contain
**                                      the public key which will be used to
**                                      verify the signature.
**              f_eRootPubkey       -   Root Pubkey to use for cert verification
**                                      if it is WM_DRM_ROOTPUBKEY_CLK, 
**              f_pcontextLEVL      -   License eval context.  The BBX pointer must be valid.
**                                      The HDS and pcontextSSTRevocation pointers must be valid to perform cert caching.
**                                      
** Returns :    DRM_SUCCESS -   Signature verified successfully
**              DRM_E_INVALID_SIGNATURE -   Verification failed
**              some other problem
******************************************************************************/
DRM_RESULT DRM_API DRM_UTL_VerifyXMLSignature(
    IN  const   DRM_CONST_STRING        *f_pdstrSignedData,
    IN  const   DRM_CONST_STRING        *f_pdstrSignatureXML,
    IN  const   DRM_CONST_STRING        *f_pdstrCertChainXML,
    IN          DRM_BOOL                 f_fCheckExpiry,
    IN          DRM_BOOL                 f_fCheckCertChain,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey,
    IN          DRM_LICEVAL_CONTEXT     *f_pcontextLEVL)
{
    DRM_CONST_STRING dstrSignature = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrTmp       = EMPTY_DRM_STRING;
    DRM_RESULT       dr            = DRM_SUCCESS;    
       
    /*
    **  Verify input
    */
    ChkDRMString(f_pdstrSignedData);
    ChkDRMString(f_pdstrSignatureXML);
    if (f_fCheckCertChain)
    {
        ChkDRMString(f_pdstrCertChainXML); 
    }
    
    ChkArg( f_pcontextLEVL              != NULL
         && f_pcontextLEVL->pcontextBBX != NULL );

    /*
    **  Verify Hashing algorithm
    */
    dr = DRM_XML_GetSubNode( f_pdstrSignatureXML,
                            &g_dstrTagHashAlg, 
                            &g_dstrAttributeType,
                            &g_dstrSHA, 
                             0, 
                             NULL,
                            &dstrTmp,
                             1);
    if( DRM_FAILED(dr) )
    {
        ChkDR(DRM_E_UNSUPPORTEDALGORITHM);
    }

    /*
    **  Verify Signature algorithm
    */
    dr = DRM_XML_GetSubNode( f_pdstrSignatureXML,
                            &g_dstrTagSignAlg, 
                            &g_dstrAttributeType,
                            &g_dstrMSDRM, 
                             0, 
                             NULL,
                            &dstrTmp,
                            1);
    if( DRM_FAILED(dr) )
    {
        ChkDR(DRM_E_UNSUPPORTEDALGORITHM);
    }

    /*
    **  Get Signature value
    */
    ChkDR( DRM_XML_GetSubNode( f_pdstrSignatureXML, 
                              &g_dstrTagValue,
                               NULL,
                               NULL,
                               0,
                               NULL,
                              &dstrSignature,
                               1)  );

    dr = _UTL_VerifySignature( f_pdstrSignedData, 
                              &dstrSignature, 
                               f_pdstrCertChainXML, 
                               f_fCheckExpiry,
                               f_fCheckCertChain, 
                               f_eRootPubkey,
                               f_pcontextLEVL );
    
ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_UTL_VerifyXMLSignatureEx
** 
** Synopsis :   Verify the xml signature over some data
** 
** Arguments :  f_pdstrSignedData   -   The entire data that is signed
**              f_pdstrSignatureValue -   Sig value
**              f_pdstrCertChainXML -   <CERTIFICATECHAIN>...</CERTIFICATECHAIN>
**              f_fCheckExpiry      -   Check for cert expiration
**              f_fCheckCertChain   -   Verify cert chain. If this is false,
**                                      f_pcontextCrypto->pubKey must contain
**                                      the public key which will be used to
**                                      verify the signature.
**              f_eRootPubkey       -   Root Pubkey to use for cert verification
**              f_pcontextLEVL      -   License eval context.  The BBX pointer must be valid.
**                                      The HDS and pcontextSSTRevocation pointers must be valid to perform cert caching.
**                                      
** Returns :    DRM_SUCCESS -   Signature verified successfully
**              DRM_E_INVALID_SIGNATURE -   Verification failed
**              some other problem
******************************************************************************/
DRM_RESULT DRM_API DRM_UTL_VerifyXMLSignatureEx(
    IN  const   DRM_CONST_STRING        *f_pdstrSignedData,
    IN  const   DRM_CONST_STRING        *f_pdstrSignatureValue,
    IN  const   DRM_CONST_STRING        *f_pdstrCertChainXML,
    IN          DRM_BOOL                 f_fCheckExpiry,
    IN          DRM_BOOL                 f_fCheckCertChain,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey,
    IN          DRM_LICEVAL_CONTEXT     *f_pcontextLEVL)
{
    DRM_RESULT dr = DRM_SUCCESS;    
    
    /*
    **  Verify input
    */
    ChkDRMString(f_pdstrSignedData);
    ChkDRMString(f_pdstrSignatureValue);
    if (f_fCheckCertChain)
    {
        ChkDRMString(f_pdstrCertChainXML); 
    }
    ChkArg( f_pcontextLEVL              != NULL
         && f_pcontextLEVL->pcontextBBX != NULL );

    dr = _UTL_VerifySignature( f_pdstrSignedData, 
                               f_pdstrSignatureValue, 
                               f_pdstrCertChainXML, 
                               f_fCheckExpiry,
                               f_fCheckCertChain, 
                               f_eRootPubkey,
                               f_pcontextLEVL );
    
ErrorExit:
    return dr;
}

/*********************************************************************
**
**  Function:  DRM_UTL_DecodeKID
**
**  Synopsis:  Decode a KID value.  In general it just performs a Base64 decode but
**             also takes into account the possibility that a header or license
**             may technically have an invalid KID in it (wrong size) and we need
**             to work with it correctly.
**
**  Arguments:  
**     [f_pdstrKID] -- String representation of the KID
**     [f_pkid]     -- Binary KID will be copied to this out buffer.
**
**  Notes:     KIDs should really be 24 characters long when encoded but
**             some licenses and content have these strings incorrectly set
**             so this function compensates for that possiblity.
**
*********************************************************************/
DRM_RESULT DRM_API DRM_UTL_DecodeKID( 
    IN const DRM_CONST_STRING *f_pdstrKID, 
       OUT   DRM_KID          *f_pkid )
{    
    DRM_RESULT          dr      = DRM_SUCCESS;
    DRM_CONST_STRING    dstrKID = EMPTY_DRM_STRING;
    DRM_DWORD           cb      = SIZEOF(DRM_KID);
    DRM_WCHAR           wszKID[ CCH_BASE64_EQUIV(SIZEOF(DRM_KID)) ];

    
    if ( f_pdstrKID->cchString <= NO_OF(wszKID) )
    {
        dstrKID.pwszString = wszKID, 
        dstrKID.cchString  = NO_OF(wszKID);

        for( cb = 0; cb < ( NO_OF( wszKID ) - f_pdstrKID->cchString ); cb++ )
        {
            wszKID[cb] = g_wchAsterisk;
        }
    
        wcsncpy( wszKID + ( NO_OF(wszKID)-f_pdstrKID->cchString ),
                 f_pdstrKID->pwszString,
                 f_pdstrKID->cchString );
        cb = SIZEOF( DRM_KID );
        dr = DRM_B64_DecodeW( &dstrKID, &cb, (DRM_BYTE*)f_pkid, 0 );    
    }
    else
    {
        dstrKID.pwszString = f_pdstrKID->pwszString, 
        dstrKID.cchString  = f_pdstrKID->cchString;
    }
    
    if (   DRM_FAILED( dr ) 
        || f_pdstrKID->cchString > NO_OF(wszKID) )
    {                        
        /*
        **  Bad KID - Let's just take the first 16 bytes from original ANSI KID
        */ 
        DRM_DWORD   iKID = 0;        
       
        /*
        **  Now convert it ansi - Note we cannot use DRM_UTL_DemoteUNICODEtoANSI
        **  here because we are writing to DRM_KID directly instead of a string
        **  So we do not want the trailing '\0'
        */        
        while( iKID < DRM_ID_SIZE )
        {
            PUT_BYTE( f_pkid->rgb, iKID, (DRM_CHAR)NATIVE_WCHAR(dstrKID.pwszString[iKID]) );
            iKID++;
        } 
        dr = DRM_SUCCESS;
    }

    return dr;
}

/*****************************************************************************
** Function: DRM_UTL_PromoteANSItoUNICODE
**
** Synopsis: copies an ASCII ANSI string to wide-ASCII
**
** Arguments:
** [pdastrIn] -- ANSI original
** [pdstrOut] -- UNICODE copy
*****************************************************************************/

DRM_VOID DRM_API DRM_UTL_PromoteANSItoUNICODE(
    const DRM_CHAR      *f_pszBase,
    const DRM_SUBSTRING *f_pdasstr, 
          DRM_STRING    *f_pdstrOut)
{
    DRM_DWORD ich = 0;

    for (ich = 0; ich < f_pdasstr->m_cch; ich++)
    {
        f_pdstrOut->pwszString [ich] = WCHAR_CAST(GET_CHAR(f_pszBase, f_pdasstr->m_ich + ich));
    }
    
    f_pdstrOut->cchString = f_pdasstr->m_cch;
}
    
DRM_VOID DRM_API DRM_UTL_DemoteUNICODEtoANSI( 
    const DRM_WCHAR *pwszFileName, 
          DRM_CHAR  *pszFileName, 
          DRM_DWORD  cchMax )
{
    DRM_DWORD ich = 0;

    while( NATIVE_WCHAR(pwszFileName[ich]) != g_wchNull
        && cchMax                           > 0 )
    {
        PUT_BYTE( pszFileName, ich, (DRM_CHAR)NATIVE_WCHAR(pwszFileName[ich]) );
        cchMax--;
        ich++;
    }
    PUT_BYTE(pszFileName,ich,'\0');
}


DRM_BOOL DRM_API DRM_UTL_DSTRSearch( 
    IN const DRM_CONST_STRING *f_pdstrString,
    IN const DRM_CONST_STRING *f_pdstrSubString,
       OUT   DRM_CONST_STRING *f_pdstrFoundString )
{
    DRM_RESULT       dr            = DRM_SUCCESS;
    DRM_CONST_STRING dstrString    = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSubString = EMPTY_DRM_STRING;

    /*
    ** NOTE:  All dr's in this function are meaningless.
    ** They will be masked before return into a TRUE/FALSE
    ** return value.
    */
    ChkArg( f_pdstrFoundString != NULL );

    ChkDRMString( f_pdstrString );
    ChkDRMString( f_pdstrSubString );

    dstrString    = *f_pdstrString;
    dstrSubString = *f_pdstrSubString;
    
    while( dstrString.cchString >= dstrSubString.cchString )
    {
        DRM_DWORD ich = 0;

        while( ich                        <  dstrSubString.cchString
            && dstrString.pwszString[ich] == dstrSubString.pwszString[ich] )
        {
            ich++;
        }

        if( ich == dstrSubString.cchString )
        {
            /* 
            ** We looped through all the characters in dstrSubString
            ** so there must have been a match 
            */

            *f_pdstrFoundString = dstrString;
            goto ErrorExit;
        }

        dstrString.cchString--;
        dstrString.pwszString++;
    }

    dr = DRM_E_FAIL;

ErrorExit:

    if( DRM_FAILED( dr ) )
    {
        return FALSE;
    }
    return TRUE;    
}

DRM_BOOL DRM_API DRM_UTL_DSTRSearchReverse( 
    IN const DRM_CONST_STRING *f_pdstrString,
    IN const DRM_CONST_STRING *f_pdstrSubString,
       OUT   DRM_CONST_STRING *f_pdstrFoundString )
{
    DRM_RESULT       dr            = DRM_SUCCESS;
    DRM_CONST_STRING dstrString    = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSubString = EMPTY_DRM_STRING;

    /*
    ** NOTE:  All dr's in this function are meaningless.
    ** They will be masked before return into a TRUE/FALSE
    ** return value.
    */

    ChkArg( f_pdstrFoundString != NULL );

    ChkDRMString( f_pdstrString );
    ChkDRMString( f_pdstrSubString );

    dstrString    = *f_pdstrString;
    dstrSubString = *f_pdstrSubString;
    
    if( dstrSubString.cchString == 0 )
    {
        *f_pdstrFoundString = dstrString;
        goto ErrorExit;
    }

    if( dstrString.cchString < dstrSubString.cchString )
    {
        ChkDR( DRM_E_INVALIDARG );
    }
    
    dstrString.pwszString += (f_pdstrString->cchString - dstrSubString.cchString);
    dstrString.cchString   =  dstrSubString.cchString;
    
    while( dstrString.cchString <= f_pdstrString->cchString )
    {
        DRM_DWORD ich = 0;

        while( ich                        <  dstrSubString.cchString
            && dstrString.pwszString[ich] == dstrSubString.pwszString[ich] )
        {
            ich++;
        }

        if( ich == dstrSubString.cchString )
        {
            /* 
            ** We looped through all the characters in dstrSubString
            ** so there must have been a match 
            */
            *f_pdstrFoundString = dstrString;
            goto ErrorExit;
        }

        dstrString.cchString++;
        dstrString.pwszString--;
    }

    dr = DRM_E_FAIL;

ErrorExit:

    if( DRM_FAILED( dr ) )
    {
        return FALSE;
    }
    return TRUE;    
}

/*
**  Add encoding-decoding strings in pairs
*/

const DRM_WCHAR g_rgwchEncodedAmpersand[]   =  { ONE_WCHAR('&', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('m', '\0'), ONE_WCHAR('p', '\0'), ONE_WCHAR(';', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_WCHAR g_rgwchEncodedQuote[]       =  { ONE_WCHAR('&', '\0'), ONE_WCHAR('q', '\0'), ONE_WCHAR('u', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR(';', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_WCHAR g_rgwchEncodedLesserThan[]  =  { ONE_WCHAR('&', '\0'), ONE_WCHAR('l', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR(';', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_WCHAR g_rgwchEncodedGreaterThan[] =  { ONE_WCHAR('&', '\0'), ONE_WCHAR('g', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR(';', '\0'), ONE_WCHAR('\0', '\0')};

const DRM_CONST_STRING g_dstrEncodedAmpersand    =  CREATE_DRM_STRING( g_rgwchEncodedAmpersand );
const DRM_CONST_STRING g_dstrEncodedQuote        =  CREATE_DRM_STRING( g_rgwchEncodedQuote );
const DRM_CONST_STRING g_dstrEncodedLesserThan   =  CREATE_DRM_STRING( g_rgwchEncodedLesserThan );
const DRM_CONST_STRING g_dstrEncodedGreaterThan  =  CREATE_DRM_STRING( g_rgwchEncodedGreaterThan );

typedef struct tagXMLEncodeMapping {
    const DRM_CONST_STRING  *pdstrEncoding;
    const DRM_WCHAR         wchEncodedCharacter;
} XMLEncodeMapping;

XMLEncodeMapping   g_rgXMLEncodeMapping[] = 
{
    { &g_dstrEncodedAmpersand,    WCHAR_CAST( '&' ) }, 
    { &g_dstrEncodedQuote,        WCHAR_CAST( '\"' ) },
    { &g_dstrEncodedLesserThan,   WCHAR_CAST( '<' ) },
    { &g_dstrEncodedGreaterThan,  WCHAR_CAST( '>' ) }
};

/******************************************************************************
** 
** Function :   DRM_UTL_XMLDecode
** 
** Synopsis :   Decode special characters like "&amp;" to plain old"&"
** 
** Arguments :  f_pwszEncoded   : Encoded string
**              f_cchEncoded    : Length of encoded string
**              f_pwszDecoded   : Buffer for decoded string; if NULL, the
**                                length of buffer required is returned and 
**                                errcode is DRM_E_BUFFERTOOSMALL
**              f_pcchDecoded   : Length of buffer for decoded string. After 
**                                returning, it contains length of decoded buffer,
**                                or length of buffer required.
**                              
** 
** Returns :    DRM_E_BUFFERTOOSMALL, if buffer for decoded string is not long 
**              enough  
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_UTL_XMLDecode(
    IN  const   DRM_WCHAR   *f_pwszEncoded,
    IN          DRM_DWORD    f_cchEncoded,
        OUT     DRM_WCHAR   *f_pwszDecoded,
    IN  OUT     DRM_DWORD   *f_pcchDecoded )
{
    DRM_RESULT      dr                  = DRM_SUCCESS;
    DRM_DWORD       iEncoded            = 0;
    DRM_DWORD       iDecoded            = 0;
    DRM_DWORD       iEncoding           = 0;
    DRM_BOOL        fFoundEncodedChar   = FALSE; 
    
    ChkArg( f_pwszEncoded != NULL && f_pcchDecoded != NULL );

    while ( iEncoded < f_cchEncoded )
    {                
        /*
        **  Check whether the next character is a encoded character
        */
        fFoundEncodedChar = FALSE; 
        for ( iEncoding = 0; 
              iEncoding < NO_OF( g_rgXMLEncodeMapping );
              iEncoding ++ )
        {
            if ( ( f_cchEncoded >= iEncoded + g_rgXMLEncodeMapping[iEncoding].pdstrEncoding->cchString )
              && wcsncmp( f_pwszEncoded + iEncoded, 
                          g_rgXMLEncodeMapping[iEncoding].pdstrEncoding->pwszString, 
                          g_rgXMLEncodeMapping[iEncoding].pdstrEncoding->cchString ) == 0 )
            {
                if ( f_pwszDecoded != NULL && iDecoded < (*f_pcchDecoded) )
                {
                    f_pwszDecoded[ iDecoded ] =   g_rgXMLEncodeMapping[iEncoding].wchEncodedCharacter;
                }
                iEncoded += g_rgXMLEncodeMapping[iEncoding].pdstrEncoding->cchString;
                fFoundEncodedChar = TRUE;
                break;
            }            
        }        
        
        if ( !fFoundEncodedChar )
        {
            if ( f_pwszDecoded != NULL && iDecoded < (*f_pcchDecoded) )
            {
                f_pwszDecoded[ iDecoded ] = f_pwszEncoded[ iEncoded ];
            }
            iEncoded++;
        }

        iDecoded++;        
    }
    
    if ( iDecoded > (*f_pcchDecoded) )
    {        
        dr = DRM_E_BUFFERTOOSMALL;
    }
    *f_pcchDecoded = iDecoded;
    
ErrorExit:    
    return dr;
}


DRM_VOID DRM_API DRM_XOR( 
    IN OUT   DRM_BYTE *pbLHS, 
    IN const DRM_BYTE *pbRHS, 
    IN       DRM_DWORD cb )
{
    DRM_DWORD i;
    for( i = 0; i < cb; i++ )
    {
        PUT_BYTE(pbLHS, i, GET_BYTE(pbLHS, i) ^ GET_BYTE(pbRHS,i) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmutilities.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_UTILITIES_H__
#define __DRM_UTILITIES_H__

#include <drmcontextsizes.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef enum DRM_ROOTPUBKEY_CATEGORY
{
    WM_DRM_ROOTPUBKEY_LICENSES = 0,
    WM_DRM_ROOTPUBKEY_LRB,   
    WM_DRM_ROOTPUBKEY_CLK,
    WM_DRM_ROOTPUBKEY_MTR   
} DRM_ROOTPUBKEY_CATEGORY;

DRM_BOOL DRM_API DRM_UTL_IsCertDateOK(const DRM_BYTE *f_pbDate);

DRM_RESULT DRM_API DRM_UTL_CheckCertNoCache(
    IN const CERT               *f_pcert, 
    IN const PUBKEY             *f_ppubkey, 
    IN       DRM_BOOL            f_fCheckDate, 
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP);

DRM_RESULT DRM_API DRM_UTL_CheckCertificate(
    IN  const   CERT                    *f_pcert, 
    IN  const   PUBKEY                  *f_ppubkey, 
    IN          DRM_BOOL                 f_fCheckCertDate,   
    IN          DRM_LICEVAL_CONTEXT     *f_pcontextLEVL,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey);

DRM_RESULT DRM_API DRM_UTL_CheckCert(
    IN const CERT                *f_pcert, 
    IN const PUBKEY              *f_ppubkey, 
    IN       DRM_BOOL             f_fCheckCertDate, 
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL);

DRM_RESULT DRM_API DRM_UTL_CheckDACCert(
    IN const CERT                *f_pcert, 
    IN const PUBKEY              *f_ppubkey, 
    IN       DRM_BOOL             f_fCheckCertDate, 
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL);

DRM_RESULT DRM_API DRM_PK_EncryptLarge( 
    IN const PUBKEY              *f_ppubkey,
    IN OUT   DRM_BYTE            *f_pbClear, 
    IN       DRM_DWORD            f_cbClear, 
    OUT      DRM_BYTE            *f_pbCipher, 
    IN       DRM_DWORD            f_cbKeySymmetric, 
    IN       DRM_CRYPTO_CONTEXT  *f_pcontextCRYP);

DRM_RESULT DRM_API DRM_PK_DecryptLarge( 
    IN const PRIVKEY            *f_ppubkey,
    IN OUT   DRM_BYTE           *f_pbCipher, 
    IN       DRM_DWORD           f_cbCipher, 
       OUT   DRM_BYTE           *f_pbClear, 
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP);

DRM_RESULT DRM_API DRM_PK_SymmetricCrypt(
    IN const DRM_BYTE  *f_pbKey,
    IN       DRM_DWORD  f_cbKey,
    IN       DRM_DWORD  f_cbCipher,
    IN       DRM_BYTE  *f_pbCipher,
    IN       DRM_DWORD  f_cbClear,
       OUT   DRM_BYTE  *f_pbClear );

DRM_RESULT DRM_API DRM_PK_SymmetricSign(
    IN const DRM_BYTE  *f_pbKey,
    IN       DRM_DWORD  f_cbKey,
    IN const DRM_BYTE *f_pbData,
    IN       DRM_DWORD f_cbData,
       OUT   DRM_BYTE  f_rgbSymSig[__CB_DECL( SHA_DIGEST_LEN )] );

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
DRM_RESULT DRM_API DRM_PK_SymmetricVerify(
    IN const DRM_BYTE  *f_pbKey,
    IN       DRM_DWORD  f_cbKey,
    IN const DRM_BYTE *f_pbData,
    IN       DRM_DWORD f_cbData,
    IN const DRM_BYTE  f_rgbSymSig[__CB_DECL( SHA_DIGEST_LEN )] );
#endif

DRM_RESULT DRM_API DRM_UTL_GetVersionAsString( 
    IN  DRM_BYTE  rgbVersion[__CB_DECL(VERSION_LEN)],
    OUT DRM_WCHAR wszVerString [VER_STRING_MAX_LEN]);

DRM_RESULT DRM_API DRM_UTL_GetVersionFromString(
   IN const DRM_WCHAR  *pwszVersion,
   IN       DRM_DWORD   cchVersion,
      OUT   DRM_WORD    rgwVersion[VERSION_LEN] );

DRM_RESULT DRM_API DRM_UTL_StringToGuid( 
    IN const DRM_CONST_STRING *pdstrString,
    OUT      DRM_GUID         *pGuid );

DRM_DWORD DRM_API DRM_UTL_NumberToString (
    IN  DRM_DWORD  dwValue, 
    OUT DRM_WCHAR *pszBuffer, 
    IN  DRM_DWORD  cchBuffer);

DRM_RESULT DRM_API DRM_UTL_StringInsertSubString(
    IN OUT   DRM_STRING       *pdstrString,
    IN       DRM_DWORD         dwInsertPoint,
    IN const DRM_CONST_STRING *pdstrSubString);

DRM_RESULT DRM_API DRM_UTL_StringRemoveSubString(
    IN OUT   DRM_STRING       *pdstrString,
    IN const DRM_CONST_STRING *pdstrSubString);

DRM_RESULT DRM_API DRM_UTL_StringInsertBlankSubString(
    IN OUT DRM_STRING *f_pdstrTarget,
    IN     DRM_DWORD   f_ichInsertion,
    IN     DRM_DWORD   f_cch);

DRM_BOOL DRM_API DRM_UTL_DSTRStringsEqual(
    const DRM_CONST_STRING *pdstr1,
    const DRM_CONST_STRING *pdstr2);

DRM_BOOL DRM_API DRM_UTL_DASTRStringsEqual(
    const DRM_ANSI_CONST_STRING *f_pdastr1,
    const DRM_ANSI_CONST_STRING *f_pdastr2);

DRM_BOOL DRM_API DRM_UTL_DASSTRStringsEqual(
    const DRM_CHAR              *f_pszBase,
    const DRM_SUBSTRING         *f_pdasstr,
    const DRM_ANSI_CONST_STRING *f_pdastr);

DRM_BOOL DRM_API DRM_UTL_DASSSTRStringsEqual(
    const DRM_CHAR      *f_pszBase0,
    const DRM_SUBSTRING *f_pdasstr0,
    const DRM_CHAR      *f_pszBase1,
    const DRM_SUBSTRING *f_pdasstr1);

DRM_BOOL DRM_API DRM_UTL_DSTRSearch( 
    IN const DRM_CONST_STRING *f_pdstrString,
    IN const DRM_CONST_STRING *f_pdstrSubString,
       OUT   DRM_CONST_STRING *f_pdstrFoundString );

DRM_BOOL DRM_API DRM_UTL_DSTRSearchReverse( 
    IN const DRM_CONST_STRING *f_pdstrString,
    IN const DRM_CONST_STRING *f_pdstrSubString,
       OUT   DRM_CONST_STRING *f_pdstrFoundString );

DRM_RESULT DRM_API DRM_UTL_EnsureDataAlignment(
    IN  DRM_BYTE   *pbOriginal,
    IN  DRM_DWORD   cbOriginal,
    OUT DRM_BYTE  **ppbAligned,
    OUT DRM_DWORD  *pcbAligned,
    IN  DRM_DWORD   cbDataType,
    OUT DRM_DWORD  *pcbAdjustment);

DRM_RESULT DRM_API DRM_UTL_VerifyXMLSignature(
    IN  const   DRM_CONST_STRING        *f_pdstrSignedData,
    IN  const   DRM_CONST_STRING        *f_pdstrSignatureXML,
    IN  const   DRM_CONST_STRING        *f_pdstrCertChainXML,
    IN          DRM_BOOL                 f_fCheckExpiry,
    IN          DRM_BOOL                 f_fCheckCertChain,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey,
    IN  OUT     DRM_LICEVAL_CONTEXT     *f_pcontextLEVL);

DRM_RESULT DRM_API DRM_UTL_VerifyXMLSignatureEx(
    IN  const   DRM_CONST_STRING        *f_pdstrSignedData,
    IN  const   DRM_CONST_STRING        *f_pdstrSignatureValue,
    IN  const   DRM_CONST_STRING        *f_pdstrCertChainXML,
    IN          DRM_BOOL                 f_fCheckExpiry,
    IN          DRM_BOOL                 f_fCheckCertChain,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey,
    IN  OUT     DRM_LICEVAL_CONTEXT     *f_pcontextLEVL);

DRM_BOOL DRM_API DRM_UTL_DateLessThan(
    IN const DRMFILETIME* f_pFileTime1, 
    IN const DRMFILETIME* f_pFileTime2);

DRM_RESULT DRM_API DRM_UTL_DecodeKID( 
    IN const DRM_CONST_STRING *f_pdstrKID, 
       OUT   DRM_KID          *f_pkid );
        
DRM_VOID DRM_API DRM_UTL_PromoteANSItoUNICODE(
    const DRM_CHAR      *f_pszBase,
    const DRM_SUBSTRING *f_pdassstrIn, 
          DRM_STRING    *f_pdstrOut);    

DRM_VOID DRM_API DRM_UTL_DemoteUNICODEtoANSI( 
    const DRM_WCHAR *pwszFileName, 
          DRM_CHAR  *pszFileName, 
          DRM_DWORD  cchMax );

DRM_RESULT DRM_UTL_XMLDecode(
    IN  const   DRM_WCHAR   *f_pwszEncoded,
    IN          DRM_DWORD    f_cchEncoded,
        OUT     DRM_WCHAR   *f_pwszDecoded,
    IN  OUT     DRM_DWORD   *f_pcchDecoded );

DRM_VOID DRM_API DRM_XOR( 
    IN OUT   DRM_BYTE *pbLHS, 
    IN const DRM_BYTE *pbRHS, 
    IN       DRM_DWORD cb );

#ifdef __cplusplus
}
#endif

#endif /* __DRM_UTILITIES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmviewrights.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmlicenseparser.h>
#include <drmsecurestore.h>
#include <drmblackbox.h>
#include <drmlicstore.h>
#include <drmliceval.h>
#include <drmexpreval.h>
#include <drmmanager.h>
#include <drmlicreason.h>
#include <drmviewprops.h>
#include <oemimpl.h>


/* Is the date a negative infinite date? */
static DRM_BOOL NegInfDate(const DRMFILETIME* pFileTime)
{
    return (pFileTime->dwLowDateTime  == 0 && pFileTime->dwHighDateTime == 0);
}

/* Is the date an infinity representation */
static DRM_BOOL InfDate(const DRMFILETIME* pFileTime)
{
    return (pFileTime->dwLowDateTime == 0xFFFFFFFF && pFileTime->dwHighDateTime == 0xFFFFFFFF);
}

/*****************************************************************************/

/*****************************************************************************/
static DRM_BOOL IsExpired(const DRMFILETIME* pFileTime)
{
    DRMFILETIME   currDate;

    if( InfDate(pFileTime))
    {
        return FALSE;
    }
    
    OEM_GetDeviceTime (&currDate);
    
    return (DRM_UTL_DateLessThan(pFileTime, &currDate));
}    

/*****************************************************************************/

static DRM_BOOL OverlappingDates(
    const DRMFILETIME* pBegDate1,
    const DRMFILETIME* pEndDate1, 
    const DRMFILETIME* pBegDate2,
    const DRMFILETIME* pEndDate2)
{  
    return !(DRM_UTL_DateLessThan(pEndDate2, pBegDate1) || DRM_UTL_DateLessThan(pEndDate1, pBegDate2));
}

/*****************************************************************************/

static DRM_RESULT GetSecStateAttr(
          DRM_SECSTORE_CONTEXT *pbSecStore,
    const DRM_CONST_STRING     *pdstrAttribute,
          DRM_DWORD            *pdwValue,
          DRMFILETIME          *pFileTime)
{
    DRM_RESULT dr = DRM_SUCCESS;    
    TOKEN token;
    
    dr = DRM_SST_GetTokenValue( pbSecStore, pdstrAttribute, &token);
    if( DRM_FAILED(dr) || dr == DRM_S_FALSE )
    {
        /* Unable to retrieve the value. */
        ChkDR(CPRMEXP_RETRIEVAL_FAILURE);
    }

    switch(token.TokenType)
    {
    case TOKEN_LONG:
        if( pdwValue)
        {
            *pdwValue = token.val.lValue;
        }
        else
        {
            dr = DRM_S_FALSE; /* We are not passing any data back */
        }
        break;
    case TOKEN_DATETIME:
        if( pFileTime)
        {
            UI64_TO_FILETIME( token.val.u64DateTime, *pFileTime );
        }
        else
        {
            dr = DRM_S_FALSE; /* We are not passing any data back */
        }
        break;
    default:
        dr = DRM_S_FALSE; /* We don't retrieve any string data for license view. */
    }
ErrorExit:
    return dr;
}

/*****************************************************************************/

static DRM_VOID SetExpiryCategory(
          DRM_LICENSE_STATE_DATA *pStateData,
    const DRMFILETIME            *pBegDate, 
    const DRMFILETIME            *pEndDate)
{
    DRM_DWORD dwExpiryType;

    DRMASSERT( pStateData != NULL && pBegDate != NULL && pEndDate != NULL );

    dwExpiryType = ((!NegInfDate(pBegDate)) << 1) + !InfDate(pEndDate);
    if( dwExpiryType != 0 && pStateData->dwVague != 0)
    {
        /* If the state is already vague, don't change it unless the new license is unlim type. */
        return;
    }
    switch (dwExpiryType)                    
    {
    case 0:
        pStateData->dwCategory    = WM_DRM_LICENSE_STATE_UNLIM;
        pStateData->dwNumDates    = 0;
        pStateData->dwNumCounts   = 0;
        pStateData->dwCount[0]    = 0;
        pStateData->dwCount[1]    = 0;
        pStateData->dwVague       = 0; /* No longer vague. */
        break;
    case 1:
        pStateData->dwCategory    = WM_DRM_LICENSE_STATE_UNTIL;
        pStateData->dwNumDates    = 1;
        MEMCPY( &pStateData->datetime[0], pEndDate, SIZEOF( DRMFILETIME ) );
        break;
    case 2:
        pStateData->dwCategory    = WM_DRM_LICENSE_STATE_FROM;
        pStateData->dwNumDates    = 1;
        MEMCPY( &pStateData->datetime[0], pBegDate, SIZEOF( DRMFILETIME ) );
        break;
    case 3:
        pStateData->dwCategory    = WM_DRM_LICENSE_STATE_FROM_UNTIL;
        pStateData->dwNumDates    = 2;
        MEMCPY( &pStateData->datetime[0], pBegDate, SIZEOF( DRMFILETIME ) );
        MEMCPY( &pStateData->datetime[1], pEndDate, SIZEOF( DRMFILETIME ) );
        break;                        
    }                        
}

/*****************************************************************************/

static DRM_VOID SetCountedExpiryCategory(
          DRM_LICENSE_STATE_DATA *pStateData, 
    const DRMFILETIME            *pBegDate, 
    const DRMFILETIME            *pEndDate)
{
    DRM_DWORD dwExpiryType;

    dwExpiryType = ((!NegInfDate(pBegDate)) << 1) + !InfDate(pEndDate);
    switch (dwExpiryType)                    
    {
    case 0:
        pStateData->dwCategory    = WM_DRM_LICENSE_STATE_COUNT;
        pStateData->dwNumDates    = 0;
        break;
    case 1:
        pStateData->dwCategory    = WM_DRM_LICENSE_STATE_COUNT_UNTIL;
        pStateData->dwNumDates    = 1;
        MEMCPY( &pStateData->datetime[0], pEndDate, SIZEOF( DRMFILETIME ) );        
        break;
    case 2:
        pStateData->dwCategory    = WM_DRM_LICENSE_STATE_COUNT_FROM;
        pStateData->dwNumDates    = 1;
        MEMCPY( &pStateData->datetime[0], pBegDate, SIZEOF( DRMFILETIME ) );        
        break;
    case 3:
        pStateData->dwCategory    = WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL;
        pStateData->dwNumDates    = 2;
        MEMCPY( &pStateData->datetime[0], pBegDate, SIZEOF( DRMFILETIME ) );
        MEMCPY( &pStateData->datetime[1], pEndDate, SIZEOF( DRMFILETIME ) );
        break;                        
    }                        
}

/*****************************************************************************/

#if DRM_SUPPORT_PMLICENSE
DRM_BOOL HaveRights( const DRM_BYTE *pbCrit, const DRM_BYTE *pbRights )
{
    DRM_BYTE rgbCrit[__CB_DECL(RIGHTS_LEN)]; /* Local copy. */
    DRM_BYTE rgbTemp[__CB_DECL(RIGHTS_LEN)] = {0};
    DRM_BYTE bTemp = 0;
    DRM_SHORT i;

    MEMCPY(rgbCrit, pbCrit, RIGHTS_LEN);

    /* Check if all bits are 0. If then, indicate that the right is not allowed. */
    /* This is to prevent from reporting TRUE for non-existing rights. */
    
    if (MEMCMP(rgbCrit, rgbTemp, RIGHTS_LEN) == 0)
    {
        return FALSE;
    }
    /* It is not all 0. Check if the rights requested exist. */
    /* Handle backup bit separately since the logic in for loop below does not work for this case. */
    if( (GET_BYTE(rgbCrit,0)  & GET_BYTE(RIGHT_NO_RESTORE,0)) 
     && (GET_BYTE(pbRights,0) & GET_BYTE(RIGHT_NO_RESTORE,0)) )
    {
        /* We want backup/restore but the license does not have it. */
        return FALSE;
    }
    /* Set the backup/restore bit to 0 since we don't care about it anymore.     */
    bTemp = GET_BYTE(rgbCrit, 0);
    bTemp &= ~GET_BYTE( RIGHT_NO_RESTORE,0);
    PUT_BYTE(rgbCrit,0,bTemp);

    for (i=0; i<RIGHTS_LEN; i++)
    {
        bTemp = GET_BYTE(rgbCrit,i);
        if( ( bTemp & GET_BYTE(pbRights,i) ) != bTemp )
        {
            return FALSE;
        }
    }
    return TRUE;
}

/*****************************************************************************/

DRM_BOOL HaveRightsLong( const DRM_BYTE *pbCrit, DRM_LONG lRights )
{
    DRM_BYTE  rgbRights[__CB_DECL(RIGHTS_LEN)];

    PUT_BYTE(rgbRights,0, (DRM_BYTE)(lRights & 0x00FF) );
    PUT_BYTE(rgbRights,1, (DRM_BYTE)((lRights >>  8) & 0x00FF) );
    PUT_BYTE(rgbRights,2, (DRM_BYTE)((lRights >> 16) & 0x00FF) );
    PUT_BYTE(rgbRights,3, (DRM_BYTE)((lRights >> 24) & 0x00FF) );

    return HaveRights( pbCrit, rgbRights );
}

#endif /* DRM_SUPPORT_PMLICENSE */

DRM_RESULT DRM_API DRM_ASD_ParseV2License(
    IN const DRM_CONST_STRING *f_pdstrLicense, 
    IN const DRM_CONST_STRING *f_pdstrAttrName,
       OUT   DRM_DWORD        *f_pdwValue, 
       OUT   DRMFILETIME      *f_pfiletime)
{
    DRM_RESULT       dr             = DRM_SUCCESS;
    DRM_CONST_STRING dstrExpression = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrLIData     = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrValue      = EMPTY_DRM_STRING;
    TOKEN            token          = {0};

    DRM_PROFILING_ENTER_SCOPE(L"DRM_ASD_ParseV2License", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
  
    ChkDRMString( f_pdstrLicense );
    ChkDRMString( f_pdstrAttrName );
        
    if( f_pfiletime != NULL 
     && ( f_pdstrAttrName == &g_dstrDRM_LS_BEGDATE_ATTR 
       || f_pdstrAttrName == &g_dstrDRM_LS_ENDDATE_ATTR ) )
    {
        const DRM_CONST_STRING *pdstrSubString = NULL;
        
        /* Retrieve the condition for the ONSELECT event. */
        ChkDR( DRM_LIC_GetEvent( f_pdstrLicense, &g_dstrLicEvalOnSelect, NULL, &dstrLIData, &dstrExpression, NULL, NULL ) );
        dr = DRM_S_FALSE;

        if( f_pdstrAttrName == &g_dstrDRM_LS_BEGDATE_ATTR )
        {
            pdstrSubString = &g_dstrDRM_LS_MACHINE_DATETIME_GE;
        }
        else if( f_pdstrAttrName == &g_dstrDRM_LS_ENDDATE_ATTR ) 
        {
            pdstrSubString = &g_dstrDRM_LS_MACHINE_DATETIME_LE;
        }

        /*
        ** Search for last occurence of pwszSearch in bstrExpr. Due to disable clock & deletelicesne
        ** functionalities, it is possible that there is more than one such string. The last one
        ** is the correct one that is used for determining whether license is selectable or not.
        */        
        if( DRM_UTL_DSTRSearchReverse( &dstrExpression, pdstrSubString, &dstrValue ) )
        {
            /* 
            ** If the date string was found we know there are at least 21 characters,
            ** and we push past all those and look at the date immediately after,
            ** skipping whitespace
            */                        

            if( dstrValue.cchString > g_dstrDRM_LS_MACHINE_DATETIME_GE.cchString )
            {
                /* Advance to the # */
                dstrValue.pwszString += g_dstrDRM_LS_MACHINE_DATETIME_GE.cchString - 1;
                dstrValue.cchString  -= g_dstrDRM_LS_MACHINE_DATETIME_GE.cchString - 1;

                while( dstrValue.cchString > 0 
                    && iswspace( *(dstrValue.pwszString) ) )
                {
                    dstrValue.pwszString++;
                    dstrValue.cchString--;
                }

                if( DRM_SUCCEEDED( ExtractDateToken( &dstrValue, &token ) ) )
                {
                    UI64_TO_FILETIME( token.val.u64DateTime, *f_pfiletime );
                    dr = DRM_SUCCESS;
                }                
            }
        }
    }
    else if( f_pdwValue      !=  NULL
          && f_pdstrAttrName == &g_dstrDRM_LS_APPSEC_ATTR )
    {
        /*
        ** Need to get min app sec needed by the license.
        ** Retrieve the condition for the ONSELECT event.
        */

        ChkDR( DRM_LIC_GetEvent( f_pdstrLicense, &g_dstrLicEvalOnSelect, NULL, &dstrLIData, &dstrExpression, NULL, NULL ) );
        dr = DRM_S_FALSE;
        
        if( DRM_UTL_DSTRSearchReverse( &dstrExpression, &g_dstrDRM_LS_APP_MINSECLEVEL_GE, &dstrValue ) )
        {
            /* 
            ** If the date string was found we know there are at least 21 characters,
            ** and we push past all those and look at the date immediately after,
            ** skipping whitespace
            */                        

            if( dstrValue.cchString > g_dstrDRM_LS_APP_MINSECLEVEL_GE.cchString )
            {
                /* Advance past the string */
                dstrValue.pwszString += g_dstrDRM_LS_APP_MINSECLEVEL_GE.cchString;
                dstrValue.cchString  -= g_dstrDRM_LS_APP_MINSECLEVEL_GE.cchString; 
                
                while( dstrValue.cchString > 0 
                    && iswspace( *(dstrValue.pwszString) ) )
                {
                    dstrValue.pwszString++;
                    dstrValue.cchString--;
                }

                if( DRM_SUCCEEDED( ExtractLongToken( &dstrValue, &token ) ) )
                {
                    *f_pdwValue = token.val.lValue;
                    dr = DRM_SUCCESS;
                }                
            }
        }
    }
    else if( f_pdwValue != NULL
          && DRM_UTL_DSTRSearch( f_pdstrAttrName, &g_dstrDRM_LS_BEGIN_ATTR, &dstrValue )
          && DRM_UTL_DSTRSearch( f_pdstrAttrName, &g_dstrDRM_LS_COUNT_ATTR, &dstrValue ) )
    {
        /* We will look for this in ONSTORE action part. */
        ChkDR( DRM_LIC_GetEvent( f_pdstrLicense, &g_dstrLicEvalOnStore, NULL, &dstrLIData, NULL, &dstrExpression, NULL ) );

        dr = DRM_S_FALSE;

        if( DRM_UTL_DSTRSearch( &dstrExpression, f_pdstrAttrName, &dstrValue ) )
        {
            DRM_CONST_STRING dstr = EMPTY_DRM_STRING;            

            if( DRM_UTL_DSTRSearch( &dstrValue, &g_dstrEqual, &dstr) )
            {
                /* Move past the "=" */
                dstr.pwszString += 1;
                dstr.cchString  += 1;

                while( dstrValue.cchString > 0 
                    && iswspace( *(dstrValue.pwszString) ) )
                {
                    dstrValue.pwszString++;
                    dstrValue.cchString--;
                }

                ChkDR( ExtractLongToken( &dstr, &token ) );
                *f_pdwValue = token.val.lValue;
            }
        }                    
    }
    else
    {
        ChkDR( DRM_E_INVALIDARG );
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_ASD_ParseV2License", g_pwszLeavingFunction);
  
    if( DRM_FAILED( dr ) )
    {
        dr = DRM_S_FALSE;
    }
    return dr;    
}


/*****************************************************************************/

static DRM_RESULT GetV2LicenseInfo(
    const DRM_CONST_STRING     *pdstrLicense,
          LicenseInfo          *licenseInfo,
    const DRM_CONST_STRING     *pdstrAction,
          DRM_SECSTORE_CONTEXT *pbSecStoreContext)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRMFILETIME FileTime;

    ZEROMEM(licenseInfo, SIZEOF(LicenseInfo));
    licenseInfo->dwCategory = LIC_TYPE_IGNORE; /* We need to ignore until we realize that license is good. */
    MEMSET(&licenseInfo->endDate, 0xFF, SIZEOF(DRMFILETIME)); 


    /* RETRIEVE ATTRIBUTES ONE BY ONE AND SET THE FIELDS. */
    licenseInfo->dwCategory = LIC_TYPE_EXPIRY; /* Treat all licenses as expiry license for now.  */

    /* First retrieve begin expiry date.     */
    dr = GetSecStateAttr(pbSecStoreContext, &g_dstrDRM_LS_BEGDATE_ATTR, NULL, &licenseInfo->begDate);
    if( dr != DRM_SUCCESS )
    {
        dr = DRM_ASD_ParseV2License(pdstrLicense, &g_dstrDRM_LS_BEGDATE_ATTR, NULL, &licenseInfo->begDate);
    }

    /* Next retrieve end expiry date.  */
    dr = GetSecStateAttr(pbSecStoreContext, &g_dstrDRM_LS_ENDDATE_ATTR, NULL, &licenseInfo->endDate);
    if( dr != DRM_SUCCESS )
    {
        dr = DRM_ASD_ParseV2License(pdstrLicense, &g_dstrDRM_LS_ENDDATE_ATTR, NULL, &licenseInfo->endDate);
    }    

    if( IsExpired(&licenseInfo->endDate))
    {
        licenseInfo->dwCategory = LIC_TYPE_IGNORE;
        goto ErrorExit;
    }        

    /* Next retrieve expiration after first use.  */
    /* For this type of license, we will not do parsing. We expect the data to be in secure store.     */
    dr = GetSecStateAttr(pbSecStoreContext, &g_dstrDRM_LS_EXPIRATION_AFTER_FIRSTUSE_ATTR, &licenseInfo->dwHours, NULL);
    if( dr == DRM_SUCCESS )
    {
        /* It is expiration after first use type of license. See if FirstUseDate is available in secure store. If it does, it is activated. */
        /* If it does not exist, then it is not enabled yet.         */
        dr = GetSecStateAttr(pbSecStoreContext, &g_dstrDRM_LS_FIRSTUSE_ATTR, NULL, &FileTime);
        if( dr == DRM_SUCCESS)
        {
            DRM_UINT64 u64;
            /* It is enabled. Treat the license has expiring license. */
            licenseInfo->dwCategory = LIC_TYPE_EXPIRY;
            /* Compute the expiry date according to hours allowed by the license. */
            u64 = DRM_UI64Add( DRM_UI64Mul( DRM_UI64( 10000000 ), DRM_UI64(60 * 60 * licenseInfo->dwHours) ), *(DRM_UINT64 *)&FileTime );
            UI64_TO_FILETIME( u64, FileTime );

            /* Set the expiry as min of this and the any end expiry specified in license. */
            if( DRM_UTL_DateLessThan(&FileTime, &licenseInfo->endDate))
            {
                licenseInfo->endDate = FileTime;
            }
        }
#if DRM_BACKUP_RESTORE_SUPPORT
        else if( DRM_UTL_DSTRStringsEqual(pdstrAction, &g_dstrWMDRM_RIGHT_BACKUP ) )
        {            
            licenseInfo->dwCategory = LIC_TYPE_EXPIRY;            
        }
#endif        
        else
        {
            licenseInfo->dwCategory = LIC_TYPE_EXPIRATION_AFTER_FIRST_USE;            
        }
    }

    /* Next retrieve count. If it exists, we should treat it as counted expiry license. */
    /* Remaining count is never parsed from the license. */
    dr = DRM_S_FALSE;
#if DRM_SUPPORT_PMLICENSE
    /* For Transfer count, the name is TransferCount. Don't use the action word supplied. */
    if( DRM_UTL_DSTRStringsEqual(pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE     ) 
     || DRM_UTL_DSTRStringsEqual(pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE ) )
    {        
        dr = GetSecStateAttr(pbSecStoreContext, &g_dstrDRM_LS_TRANSFERCOUNT_ATTR, &licenseInfo->dwCount, NULL);
    }
    else 
#endif
    if( DRM_UTL_DSTRStringsEqual(pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_CD ) )
    {
        /* wmrm sdk uses BurnToCDCount for this right instead of BeginPrint.redbookCount. So special case this too.         */
        dr = GetSecStateAttr(pbSecStoreContext, &g_dstrDRM_LS_BURNTOCDCOUNT_ATTR, &licenseInfo->dwCount, NULL);
    }
    else if( DRM_UTL_DSTRStringsEqual(pdstrAction, &g_dstrWMDRM_RIGHT_PLAYBACK)
          || DRM_UTL_DSTRStringsEqual(pdstrAction, &g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY) )
    {        
        dr = GetSecStateAttr( pbSecStoreContext, &g_dstrDRM_LS_PLAYCOUNT_ATTR, &licenseInfo->dwCount, NULL);
    }

    if( dr == DRM_SUCCESS)
    {
        /* We got the count. To play safe, make sure the count is non-zero. If zero. ignore this license. */
        if( licenseInfo->dwCount == 0 )
        {
            licenseInfo->dwCategory = LIC_TYPE_IGNORE;
            goto ErrorExit;
        }
        else 
        {
            licenseInfo->dwCategory = LIC_TYPE_COUNTED_EXPIRY;
        }
    }

    if( licenseInfo->dwCategory == LIC_TYPE_COUNTED_EXPIRY)
    {
        /* Retrieve the Start Count. */
        const DRM_CONST_STRING *pdstrCountType = NULL;

#if DRM_SUPPORT_PMLICENSE
        /* For Transfer count, the name is TransferCount. Don't use the action word supplied. */
        if( DRM_UTL_DSTRStringsEqual( pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE ) 
         || DRM_UTL_DSTRStringsEqual( pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE ) )
        {
            pdstrCountType = &g_dstrDRM_LS_BEGINTRANSFERCOUNT_ATTR;
        }
        else 
#endif
        if( DRM_UTL_DSTRStringsEqual( pdstrAction, &g_dstrWMDRM_RIGHT_COPY_TO_CD) )
        {
            /* WMRM SDK uses BurnToCDCount for this right instead of BeginPrint.redbookCount. So special case this too.         */
            pdstrCountType = &g_dstrDRM_LS_BEGINBURNTOCDCOUNT_ATTR;
        }
        else
        {
            pdstrCountType = &g_dstrDRM_LS_BEGINPLAYCOUNT_ATTR;
        }
        dr = GetSecStateAttr(pbSecStoreContext, pdstrCountType, &licenseInfo->dwStartCount, NULL);
        if( dr != DRM_SUCCESS )
        {
            dr = DRM_ASD_ParseV2License(pdstrLicense, pdstrCountType, &licenseInfo->dwStartCount, NULL);
        }
    }
    dr = DRM_SUCCESS;
ErrorExit:
    return dr;
}


/*****************************************************************************/

static DRM_RESULT GetNextLicense(
          LicenseInfo              *pLicenseInfo,
    const DRM_CONST_STRING         *rgpdstrAction[],
          DRM_DWORD                 cActions,
          DRM_BOOL                  fIsAllowedCheck, 
          DRM_LICSTOREENUM_CONTEXT *pLicQueryContext,
          DRM_VIEW_RIGHTS_CONTEXT  *pContext,
          DRM_HDS_CONTEXT          *pcontextHDS,
          DRM_BOOL                  fDeleteExpiredLicenses )
{
    DRM_RESULT dr      = DRM_SUCCESS;    
    DRM_BOOL    fFound = FALSE;
    DRM_DWORD  iAction = 0;
#if DRM_SUPPORT_PMLICENSE
    DRM_BOOL    fUpdateWithPMExpiry = FALSE;
    DRMFILETIME FileTime;
#endif
    DRM_BOOL    fSelect = FALSE;
    DRM_BOOL    fAction = FALSE;
    DRM_DWORD cbSize = 0;
    DRM_BYTE rgbPassword [__CB_DECL(SHA_DIGEST_LEN)];
    DRM_KID oKID;
    DRM_LID oLID;

    for( iAction = cActions-1; iAction < cActions; iAction--  )
    {   /* Loop termination when iAction wraps around to DWORD( -1 ) */
        if( NULL != pLicenseInfo )
        {
            pLicenseInfo[iAction].dwCategory = LIC_TYPE_IGNORE; /* We need to ignore until we realize that license is good. */
        }
    }

    do
    {   
        DRM_HDS_SLOT_HINT slotHint;

        cbSize = pContext->cbBuffer;
        dr = DRM_LST_EnumNext( pLicQueryContext, &oKID, &oLID, &slotHint, NULL);
        if( dr == DRM_E_NOMORE )
        {
            break;
        }
        if( DRM_FAILED( dr ) )
        {
            break;
        }

        dr = DRM_LST_GetLicense(pContext->pbLicenseStore, &oKID, &oLID, &slotHint, pContext->pbBuffer, &cbSize );
        if( DRM_FAILED( dr ) )
        {
            break;
        }
        
        DSTR_FROM_PB( &pContext->pLicEval->dstrContentLicense,
                       pContext->pbBuffer,
                       cbSize );
        pContext->pLicEval->fUseCachedAttribs = FALSE;        

        MEMCPY( pContext->pLicEval->LID.rgb, oLID.rgb, SIZEOF( oLID.rgb) );
        
        /* Talk to blackbox to get the secure store password for this license */
        ChkDR(DRM_SST_CreateLicenseStatePassword(&pContext->pLicEval->LID, 
                                                  rgbPassword, 
                                                 (DRM_BYTE *) pContext->pBBContext));

        if( DRM_FAILED( DRM_SST_OpenKeyTokens( pContext->pbLIDSecStore, 
                                               &pContext->pLicEval->LID, 
                                               NULL,
                                               rgbPassword,
                                               0,
                                               SECURE_STORE_LICENSE_DATA,
                                               pcontextHDS ) ) )
        {
            continue;
        }


        pContext->pLicEval->pcontextSSTLicense       = pContext->pbLIDSecStore;
        pContext->pLicEval->pcontextSSTGlobal        = pContext->pbGlobalSecStore;
        pContext->pLicEval->fGlobalSecStoreWritable  = FALSE;
        pContext->pLicEval->pLicStoreEnumContext     = pLicQueryContext;
        pContext->pLicEval->dwFlags                  = LICEVAL_VERIFY_IGNORE_VERIFICATION;
        pContext->pLicEval->pcontextBBX              = pContext->pBBContext;
        pContext->pLicEval->fReserved                = 0;
        
        /* Call IsSelectable to check if the license needs SAP or SVP etc.  */
        /* Ignore the return value since we want to consider all licenses */
        /* for this content. If it has expired, we will ignore it for aggregation. */
        DRM_LEVL_PerformOperations( pContext->pLicEval,
                                    DRM_LICENSE_EVAL_SELECT, 
                                    DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                    NULL,
                                    &fSelect, 
                                    NULL,
                                    pcontextHDS); 
        if (   fDeleteExpiredLicenses
            && !fSelect 
            && pContext->pLicEval->lReasonForFail == LR_LICENSE_EXPIRED )
        {
            /*
            **  License is expired. Let's delete it.
            */
            (void)DRM_LST_EnumDelete( pLicQueryContext );
            continue;
        }
        
        if( fIsAllowedCheck )
        {
            if( !fSelect )
            {
#if DRM_BACKUP_RESTORE_SUPPORT
                /* If we couldn't select the license there is 1 special case where we may want to succeeded */
                if( DRM_UTL_DSTRStringsEqual(rgpdstrAction[0], &g_dstrWMDRM_RIGHT_BACKUP))
                {
                    /* Backup right is allowed even if the license is not enabled. */
                    if( pContext->pLicEval->lReasonForFail != LR_LICENSE_NOTENABLED)
                    {
                        continue; /* Ignore this license */
                    }
                }
                else
                {
                    continue;
                }
#endif                
            }
        }
        else
        {
            if( pContext->pLicEval->lReasonForFail == LR_LICENSE_EXPIRED ||
                pContext->pLicEval->lReasonForFail == LR_LICENSE_NOSAP   ||
                pContext->pLicEval->lReasonForFail == LR_LICENSE_NOSVP   ||
                pContext->pLicEval->lReasonForFail == LR_LICENSE_NOWDM	 ||
                pContext->pLicEval->lReasonForFail == LR_LICENSE_NEED_UPGRADE_MSSAP	||
                pContext->pLicEval->lReasonForFail == LR_LICENSE_INVALID_APPLICATION)
            {
                continue; /* Ignore this license. */
            }
        }
        /* Assumption: There will be no date based condition for this right. */
        /* If the right does not exist in this license, we want to skip it. */
        /* The alternative is simply to check if the license contains the right */
        /* without evaluating the condition. But, if the playcount is 0, we don't */
        /* to return 0 as the count to the application. It is better to skip this license. */

        for( iAction = cActions-1 ; iAction < cActions ; iAction-- )
        {        

#if DRM_SUPPORT_PMLICENSE
            if( DRM_UTL_DSTRStringsEqual(rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE ) )
            {
                dr = DRM_LEVL_PerformOperations( pContext->pLicEval, 
                                                 DRM_LICENSE_EVAL_ACTION,
                                                 DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                                 &g_dstrCreatePMLicense, 
                                                 &fAction, 
                                                 NULL,
                                                 pcontextHDS);
                /* Check if the pmlicence data supports the required action */
                if( dr == DRM_SUCCESS 
                  && fAction 
                  && HaveRightsLong(RIGHT_COPY_TO_SDMI_DEVICE, pContext->pLicEval->lPMRights))
                {
                    dr = DRM_SUCCESS;
                    fUpdateWithPMExpiry = TRUE;
                }
                else
                {
                    dr = DRM_S_FALSE;
                }
            }
            else if( DRM_UTL_DSTRStringsEqual(rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE) )
            {
                dr = DRM_LEVL_PerformOperations( pContext->pLicEval,
                                                 DRM_LICENSE_EVAL_ACTION,
                                                 DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                                 &g_dstrCreatePMLicense, 
                                                 &fAction, 
                                                 NULL,
                                                 pcontextHDS);
                /* Check if the pmlicence data supports the required action */
                if( dr == DRM_SUCCESS 
                  && fAction 
                  && HaveRightsLong(RIGHT_COPY_TO_NONSDMI_DEVICE, pContext->pLicEval->lPMRights))
                {
                    dr = DRM_SUCCESS;
                    fUpdateWithPMExpiry = TRUE;
                }
                else
                {
                    dr = DRM_S_FALSE;
                }
            }
            else
#endif /* DRM_SUPPORT_PMLICENSE */
            {       
                dr = DRM_LEVL_PerformOperations( pContext->pLicEval,
                                                 DRM_LICENSE_EVAL_ACTION, 
                                                 DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                                 rgpdstrAction[iAction],
                                                 &fAction, 
                                                 NULL,
                                                 pcontextHDS);
            }

            if( dr == DRM_SUCCESS && fAction )
            {
                if( pLicenseInfo == NULL )
                {
                    /* We don't care about the license info.  We found a license that we can do the action on. */
                    fFound = TRUE;
                }
                else
                {

#if DRM_SUPPORT_PMLICENSE
                    /* Check PM Expiry, if it is relevant. */
                    if( fUpdateWithPMExpiry )
                    {
                        if( pContext->pLicEval->PMExpiryDate.wYear == 9999)
                        {
                            MEMSET(&FileTime, 0xFF, SIZEOF(DRMFILETIME));
                        }
                        else
                        {
                            OEM_SystemTimeToFileTime(&(pContext->pLicEval->PMExpiryDate), &FileTime);
                        }
                    }
                    if( !fUpdateWithPMExpiry || !IsExpired(&FileTime) )
#endif /* DRM_SUPPORT_PMLICENSE */
                    {

                        /* The right is allowed. Let us now check if the license can be used on this machine. */
                        dr = GetV2LicenseInfo( &pContext->pLicEval->dstrContentLicense,
                                               &pLicenseInfo[iAction],
                                               rgpdstrAction[iAction], 
                                               pContext->pbLIDSecStore );
                        if( dr == DRM_SUCCESS)
                        {
#if DRM_SUPPORT_PMLICENSE
                            if( fUpdateWithPMExpiry && DRM_UTL_DateLessThan(&FileTime, &( pLicenseInfo[iAction].endDate ) ) )
                            {
                                pLicenseInfo->endDate = FileTime;
                            }
#endif /* DRM_SUPPORT_PMLICENSE */
                            /* Ignore begin expiry for backup right. */
#if DRM_BACKUP_RESTORE_SUPPORT
                            if( DRM_UTL_DSTRStringsEqual(rgpdstrAction[iAction], &g_dstrWMDRM_RIGHT_BACKUP) )
                            {
                                ZEROMEM(&pLicenseInfo[iAction].begDate, SIZEOF(DRMFILETIME)); /* Make it negative infinity. */
                            }
#endif /* DRM_BACKUP_RESTORE_SUPPORT */
                            fFound |= TRUE;
                        }
                    }
                }
            }
        }
    }while (!fFound);

    /* Determine return value. */
    if( fFound)       
    {
        dr = DRM_SUCCESS;
    }
    else
    {
        dr = DRM_S_FALSE;
    }

ErrorExit:
    return dr;    
}

/*****************************************************************************/

static DRM_RESULT Aggregate(
    DRM_LICENSE_STATE_DATA *stateData, 
    LicenseInfo            *licenseInfo, 
    DRM_LICENSE_STATE_DATA *HighestPriInfo, 
    DRM_DWORD               dwNum)
{
    DRM_RESULT  dr           = DRM_SUCCESS;    
    DRMFILETIME stateBegDate;       /* Beg Date of aggregated data in stateData. */
    DRMFILETIME stateEndDate;       /* End Date of aggregated data in stateData. */
    DRM_BOOL    bSetToHighPriorityLicense = FALSE;


    for( ; dwNum > 0; )
    {
        dwNum--;
        if( stateData[dwNum].dwCategory == WM_DRM_LICENSE_STATE_UNLIM)
        {
            /* It is already set to unlim. Aggregation should not be called in this case. But, play safe. */
            continue;
        }

        switch (stateData[dwNum].dwCategory)
        {
        case WM_DRM_LICENSE_STATE_NORIGHT:
            switch(licenseInfo[dwNum].dwCategory)
            {
            case LIC_TYPE_EXPIRY:
                SetExpiryCategory(&stateData[dwNum], &licenseInfo[dwNum].begDate, &licenseInfo[dwNum].endDate);
                break;
            case LIC_TYPE_COUNTED_EXPIRY:
                SetCountedExpiryCategory(&stateData[dwNum], &licenseInfo[dwNum].begDate, &licenseInfo[dwNum].endDate);
                /* We return both counts. Since the spec does not require to send start counts, set dwNumCounts to 1. */
                stateData[dwNum].dwNumCounts   = 1;
                stateData[dwNum].dwCount[0]    = licenseInfo[dwNum].dwCount;
                stateData[dwNum].dwCount[1]    = licenseInfo[dwNum].dwStartCount;
                break;
            case LIC_TYPE_EXPIRATION_AFTER_FIRST_USE:
                /* If the license is not used yet, we give hours left. Else, it becomes a regular expiry license.                     */
                /* Set the end expiry if it is not inf date. This will be the case if it is already enabled. */
                if( !InfDate(&licenseInfo[dwNum].endDate) )
                {
                    stateData[dwNum].dwNumDates    = 1;
                    MEMCPY( &stateData[dwNum].datetime[0], &licenseInfo[dwNum].endDate, SIZEOF( DRMFILETIME ) );
                }

                /* The license has never been used. It is still LIC_TYPE_EXPIRATION_AFTER_FIRST_USE type. */
                stateData[dwNum].dwCategory    = WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE;                        
                stateData[dwNum].dwNumCounts   = 1;
                stateData[dwNum].dwCount[0]    = licenseInfo[dwNum].dwHours;
                break;
            default:
                /* Do nothing. Either unknown type of license or unsupported or expired. Ignore this license. */
                break;
            }
            break;
        case WM_DRM_LICENSE_STATE_COUNT:
            switch( licenseInfo[dwNum].dwCategory )
            {
            case LIC_TYPE_IGNORE:
                break; /* Ignore this license. */
            case LIC_TYPE_EXPIRY:
                /* If the current license is unlim, we need to use that for view rights.  */
                SetExpiryCategory(&stateData[dwNum], &licenseInfo[dwNum].begDate, &licenseInfo[dwNum].endDate);
                if( stateData[dwNum].dwCategory != WM_DRM_LICENSE_STATE_UNLIM )
                {
                    /* we can't aggregate. We need to set to the one given by highest priority license. */
                    bSetToHighPriorityLicense = TRUE;
                }                        
                break;
            case LIC_TYPE_COUNTED_EXPIRY:
                if( NegInfDate(&licenseInfo[dwNum].begDate) && InfDate(&licenseInfo[dwNum].endDate)  )
                {
                    /* Add counts. No expiry dates are used. Plain counted licenses. */
                    stateData[dwNum].dwCount[0] += licenseInfo[dwNum].dwCount;
                    stateData[dwNum].dwCount[1] += licenseInfo[dwNum].dwStartCount;
                    break;
                }
                /* else fall through to the default case. */
            default:
                /* Multiple Licenses that cannot be aggregated. Return highest priority one. */
                /* Do not stop as there might be a license with unlim license later. */
                bSetToHighPriorityLicense = TRUE;
            }            
            break;
        case WM_DRM_LICENSE_STATE_FROM:
        case WM_DRM_LICENSE_STATE_UNTIL:
        case WM_DRM_LICENSE_STATE_FROM_UNTIL:
            /* Initialize stateBegDate and stateEndDate. */
            ZEROMEM(&stateBegDate, SIZEOF(DRMFILETIME));
            MEMSET(&stateEndDate, 0xFF, SIZEOF(DRMFILETIME));
            /* Set the begindate  */
            if( stateData[dwNum].dwCategory == WM_DRM_LICENSE_STATE_FROM ||
                stateData[dwNum].dwCategory == WM_DRM_LICENSE_STATE_FROM_UNTIL )
            {
                MEMCPY(&stateBegDate, &stateData[dwNum].datetime[0], SIZEOF(DRMFILETIME));
            }

            /* Set the enddate */
            if( stateData[dwNum].dwCategory == WM_DRM_LICENSE_STATE_UNTIL)
            {
                MEMCPY(&stateEndDate, &stateData[dwNum].datetime[0], SIZEOF(DRMFILETIME));
            }
            else if( stateData[dwNum].dwCategory == WM_DRM_LICENSE_STATE_FROM_UNTIL)
            {
                MEMCPY(&stateEndDate, &stateData[dwNum].datetime[1], SIZEOF(DRMFILETIME));
            }
            switch(licenseInfo[dwNum].dwCategory)
            {
            case LIC_TYPE_IGNORE:
                break; /* Ignore this license. */
            case LIC_TYPE_EXPIRY:
                /* If the two date ranges are overlapping, we continue. Else, we use highest priority one. */
                if( OverlappingDates(&stateBegDate, &stateEndDate, &licenseInfo[dwNum].begDate, &licenseInfo[dwNum].endDate))
                {
                    if( DRM_UTL_DateLessThan(&licenseInfo[dwNum].begDate, &stateBegDate))
                    {
                        stateBegDate = licenseInfo[dwNum].begDate;
                    }
                    if( DRM_UTL_DateLessThan(&stateEndDate, &licenseInfo[dwNum].endDate))
                    {
                        stateEndDate = licenseInfo[dwNum].endDate;
                    }
                    SetExpiryCategory(&stateData[dwNum], &stateBegDate, &stateEndDate);
                    break;
                }
                /* else fall through to the default case. */
            default:                
                /* Multiple Licenses that cannot be aggrgated. Return highest priority one. */
                /* Do not stop as there might be a license with unlim license later. */
                bSetToHighPriorityLicense = TRUE;
            }
            break;
        case WM_DRM_LICENSE_STATE_COUNT_FROM:
        case WM_DRM_LICENSE_STATE_COUNT_UNTIL:
        case WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL:
        case WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE:
        default:
            switch(licenseInfo[dwNum].dwCategory)
            {
            case LIC_TYPE_EXPIRY:
                /* If the current license is unlim, we need to use that for view rights.  */
                SetExpiryCategory(&stateData[dwNum], &licenseInfo[dwNum].begDate, &licenseInfo[dwNum].endDate);
                if( stateData[dwNum].dwCategory == WM_DRM_LICENSE_STATE_UNLIM)
                {
                    break;
                }
                /* Fall through. We are in a situation where we can't aggregate. */
            default:                
                /* Multiple Licenses that cannot be aggrgated. Return highest priority one. */
                /* Do not stop as there might be a license with unlim license later. */
                bSetToHighPriorityLicense = TRUE;
            }
            break;
        }
        /* Set to the highest priority license info if needed and not already set. */
        if( HighestPriInfo[dwNum].dwCategory == WM_DRM_LICENSE_STATE_NORIGHT )
        {
            /* Highest pri isn't set yet.  Set it now.  This really should happen only on the first call to aggregate */
            HighestPriInfo[dwNum] = stateData[dwNum];
        }
        else if( bSetToHighPriorityLicense && stateData[dwNum].dwVague == 0)
        {
            stateData[dwNum]           = HighestPriInfo[dwNum];
            stateData[dwNum].dwVague   = 1;
        }

    }
    return dr;    
}

/*****************************************************************************/
DRM_RESULT DRM_API DRM_ASD_GetLicenseAggregateData(
    IN const DRM_CONST_STRING        *rgpdstrAction[], /* Array of DRM_CONST_STRING pointers */
    OUT      DRM_LICENSE_STATE_DATA   rgStateData[], /* array of DRM_LICENSE_STATE_DATAs */
    IN       DRM_DWORD                cActionsQueried,
    IN       DRM_VIEW_RIGHTS_CONTEXT *pContext,
    IN       DRM_HDS_CONTEXT         *pcontextHDS,
    IN       DRM_BOOL                 fDeleteExpiredLicenses )
{    
    DRM_RESULT dr         = DRM_SUCCESS;    
    DRM_WORD   cbSize     = 0;
    DRM_BOOL   fUnlimited = FALSE;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_ASD_GetLicenseAggregateData", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    ChkArg( rgpdstrAction  != NULL
         && rgStateData    != NULL
         && pContext       != NULL
         && pcontextHDS    != NULL 
         && cActionsQueried > 0 
         && cActionsQueried <= DRM_MAX_RIGHTS_SUPPORTED );

    for( cbSize = 0; cbSize < cActionsQueried; cbSize ++ )
    {
        ChkDRMString( rgpdstrAction[cbSize] );
    }

    if( pContext->pbLicenseStore )
    {
        /* If the caller gave us a store context then we can try v2 */
        ChkDR(DRM_LST_InitEnum( pContext->pbLicenseStore, &pContext->KID, TRUE, pContext->pLicQueryContext));

        ZEROMEM(pContext->licenseInfo, SIZEOF( LicenseInfo ) * cActionsQueried );

        /* Init output to sane values. */
        ZEROMEM(rgStateData, SIZEOF(DRM_LICENSE_STATE_DATA) * cActionsQueried );
        
        for( cbSize = 0; cbSize<cActionsQueried; cbSize++ )
        {
            pContext->TempStateData[cbSize].dwCategory = WM_DRM_LICENSE_STATE_NORIGHT;
            rgStateData[cbSize].dwCategory             = WM_DRM_LICENSE_STATE_NORIGHT;
        }

        while( !fUnlimited
            && (dr = GetNextLicense( pContext->licenseInfo, 
                                     rgpdstrAction, 
                                     cActionsQueried, 
                                     FALSE, 
                                     pContext->pLicQueryContext, 
                                     pContext, 
                                     pcontextHDS,
                                     fDeleteExpiredLicenses ) ) == DRM_SUCCESS)
        {
            /* We have a license. Need to aggregate. */
            Aggregate(rgStateData, pContext->licenseInfo, pContext->TempStateData, cActionsQueried);
            for( cbSize = 0; cbSize < cActionsQueried; cbSize++ )
            {
                /* Assume unlimited for now */
                fUnlimited = TRUE;
                if( rgStateData[cbSize].dwCategory != WM_DRM_LICENSE_STATE_UNLIM )
                {
                    fUnlimited = FALSE;
                    break; /* from the for loop */
                }
            }
        }
    }

    if( pContext->pGetNextV1License != NULL )
    {
        /* if the caller gave us a v1 context, we can try v1 */
        while( !fUnlimited
            && (dr = pContext->pGetNextV1License( pContext->pV1LicenseContext, 
                                                  rgpdstrAction, 
                                                  cActionsQueried, 
                                                  pContext->licenseInfo )) == DRM_SUCCESS)
        {
            /* We have a license. Need to aggregate. */
            Aggregate(rgStateData, pContext->licenseInfo, pContext->TempStateData, cActionsQueried);
            for( cbSize = 0; cbSize < cActionsQueried; cbSize++ )
            {
                /* Assume unlimited for now */
                fUnlimited = TRUE;
                if( rgStateData[cbSize].dwCategory != WM_DRM_LICENSE_STATE_UNLIM )
                {
                    fUnlimited = FALSE;
                    break; /* from the for loop */
                }
            }
        }
    }

    dr = DRM_SUCCESS;    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_ASD_GetLicenseAggregateData", g_pwszLeavingFunction);

    if( pContext                   != NULL
     && pContext->pLicQueryContext != NULL )
    {
        ZEROMEM( pContext->pLicQueryContext, SIZEOF( *pContext->pLicQueryContext ) );
    }
    return dr;
}

/*****************************************************************************/
DRM_RESULT DRM_API DRM_ASD_IsAllowed(
    IN const DRM_CONST_STRING        *pdstrAction,
    IN       DRM_VIEW_RIGHTS_CONTEXT *pContext,
    IN       DRM_HDS_CONTEXT         *pcontextHDS)
{
    DRM_RESULT dr = DRM_E_LOGICERR;
    const DRM_CONST_STRING *ppArray [1];

    ppArray [0] = pdstrAction;

    ChkArg( pContext );
    ChkDRMString( pdstrAction );

    if( pContext->pbLicenseStore && pContext->pLicQueryContext )
    {
        dr = DRM_LST_InitEnum( pContext->pbLicenseStore, &pContext->KID, TRUE, pContext->pLicQueryContext);
        /* Find the first license that fits all the criteria for this action */
        if( DRM_SUCCEEDED( dr ) )
        {
            dr = GetNextLicense( NULL, 
                                 ppArray, 
                                 1, 
                                 TRUE, 
                                 pContext->pLicQueryContext, 
                                 pContext, 
                                 pcontextHDS, 
                                 FALSE );
        }
    }
    
    if( dr != DRM_SUCCESS && pContext->pGetNextV1License )
    {
        /* No V2 licenses but we can try V1 to see if the action(s) allowed. */
        dr = pContext->pGetNextV1License(pContext->pV1LicenseContext, ppArray, 1, pContext->licenseInfo );
    }

ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmtypes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMTYPES_H__
#define __DRMTYPES_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Would be good to have a test for platform.  If the platform isn't Windows
	we should define __cdecl to be nothing.  We can't just use _MSC_VER though
	as there are other compilers for the Windows platforms. */
#if defined (_MSC_VER)
#ifdef __STDC__ /* when compiling as ANSI, parameter-passing specifications aren't allowed */
#define DRM_API 
#define DRMINLINE
#define DRMFORCEINLINE
#else
#define DRM_API __cdecl   
#define DRMINLINE _inline
#define DRMFORCEINLINE  __forceinline
#define DRM_INLINING_SUPPORTED 1
#endif
#elif defined (__GNUC__)
#define DRM_API 
#define DRMINLINE inline
#define DRMFORCEINLINE  inline
#define DRM_INLINING_SUPPORTED 1
#elif defined (__TMS320C55X__)
#define SIXTEEN_BIT_ADDRESSING 1
#define DRM_NO_NATIVE_64_TYPES 1
#define DRM_API 
#define DRMINLINE inline
#define DRMFORCEINLINE  inline
#define DRM_INLINING_SUPPORTED 1
#elif defined (__arm)
#define DRM_API    
#define DRMINLINE inline
#define DRMFORCEINLINE  inline
#define DRM_INLINING_SUPPORTED 1
#else
#error Unknown compiler -- fix up drmcommon.h to understand this compiler.
#define DRM_API    
#endif  


/* 
* In General, 
* DRM_CHAR* is used for null terminated ANSI strings
* DRM_BYTE* is used for just plain byte buffer, w/o any termination
*/

#if defined(_M_IX86)
#define TARGET_LITTLE_ENDIAN 1
#elif defined( _M_AMD64 )
#define TARGET_LITTLE_ENDIAN 1
#elif defined( _M_IA64 )
#define TARGET_LITTLE_ENDIAN 1
#elif defined( ARM )
#define TARGET_LITTLE_ENDIAN 1
#elif defined(__TMS320C55X__)
#define TARGET_LITTLE_ENDIAN 0
#define SIXTEEN_BIT_ADDRESSING 1
#else
#define TARGET_LITTLE_ENDIAN 0
#endif
/* _M_IA64 _M_AMD64 */

                                                                        /* 8-bit addressing    16 bit addressing*/
typedef void                    DRM_VOID;
typedef unsigned char           DRM_BYTE;                               /* 1 byte              1 byte */
typedef char                    DRM_CHAR;                               /* 1 byte              1 byte */
typedef unsigned short          DRM_WORD, DRM_WCHAR;                    /* 2 bytes             1 byte */
typedef short                   DRM_SHORT;                              /* 2 bytes             1 byte */
#if SIXTEEN_BIT_ADDRESSING
typedef unsigned int            DRM_BOOL;                               /* 1 bytes             1 bytes */
typedef unsigned long           DRM_UINT;                               /* 4 bytes             2 bytes */
typedef long                    DRM_INT;                                /* 4 bytes             2 bytes */
typedef long                    DRM_LONG;                               /* 4 bytes             2 bytes */
typedef long           DRM_RESULT;                             /* 4 bytes             2 bytes */
#else
typedef unsigned int            DRM_UINT,DRM_BOOL;                      /* 4 bytes             2 bytes */
typedef int                     DRM_INT;                                /* 4 bytes             2 bytes */
typedef long                    DRM_LONG, DRM_RESULT;                   /* 4 bytes             2 bytes */
#endif
typedef unsigned long           DRM_DWORD, DRM_ULONG;                   /* 2 bytes             1 bytes */
typedef unsigned short          DRM_LANGID;

#include <drmint64.h>

#if SIXTEEN_BIT_ADDRESSING
#define CB_NATIVE_BYTE 2
#define __CB_DECL(x) ((x)/CB_NATIVE_BYTE+(((x)%CB_NATIVE_BYTE)?1:0))
#else
#define CB_NATIVE_BYTE 1
#define __CB_DECL(x) (x)
#endif

#ifndef SIZEOF
#define SIZEOF(x) (sizeof(x)*CB_NATIVE_BYTE)
#endif

#ifndef BITS_PER_BYTE
#define BITS_PER_BYTE (CB_NATIVE_BYTE*8)
#endif

#include <drmbytemanip.h>

#if !defined( _W64 )
#if  ( defined(_X86_) || defined(_M_IX86) ) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif


#if defined( _WIN64)
typedef DRM_INT64 DRM_INT_PTR;
typedef DRM_UINT64 DRM_UINT_PTR;
typedef DRM_UINT64 DRM_DWORD_PTR;
#else
typedef _W64 DRM_INT DRM_INT_PTR;
typedef _W64 DRM_UINT DRM_UINT_PTR;
typedef _W64 DRM_DWORD DRM_DWORD_PTR;
#endif

#define BYTE2LITTLEENDIAN(dword, byte)     DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),0,SIZEOF(DRM_DWORD));
#define DWORD2LITTLEENDIAN( byte, dword )  DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));

#define BYTE2BIGENDIAN(dword, byte)        {DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),0,SIZEOF(DRM_DWORD));FIX_ENDIAN_DWORD((dword));}
#define DWORD2BIGENDIAN(byte, dword)       {FIX_ENDIAN_DWORD((dword));DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));FIX_ENDIAN_DWORD((dword));}


#if TARGET_LITTLE_ENDIAN
#define BYTES_TO_DWORD BYTE2LITTLEENDIAN
#define DWORD_TO_BYTES DWORD2LITTLEENDIAN
#define FIX_ENDIAN_WORD(w)
#define FIX_ENDIAN_DWORD(dw)
#define FIX_ENDIAN_QWORD(qw)
#else
#define BYTES_TO_DWORD BYTE2BIGENDIAN
#define DWORD_TO_BYTES DWORD2BIGENDIAN

#if __TMS320C55X__
/* Work around a bug in the TI compiler */
#define FIX_ENDIAN_WORD(w)   {DRM_DWORD __dw = SIZEOF(DRM_WORD);DRM_BYT_ReverseBytes((DRM_BYTE*)&(w), __dw);}
#define FIX_ENDIAN_DWORD(dw) {DRM_DWORD __dw = SIZEOF(DRM_DWORD);DRM_BYT_ReverseBytes((DRM_BYTE*)&(dw),__dw);}
#define FIX_ENDIAN_QWORD(qw) {DRM_DWORD __dw = SIZEOF(DRM_UINT64);DRM_BYT_ReverseBytes((DRM_BYTE*)&(qw),__dw);NATIVE64_TO_NONNATIVE64((qw));}
#else
#define FIX_ENDIAN_WORD(w)   DRM_BYT_ReverseBytes((DRM_BYTE*)&(w), SIZEOF(DRM_WORD))
#define FIX_ENDIAN_DWORD(dw) DRM_BYT_ReverseBytes((DRM_BYTE*)&(dw),SIZEOF(DRM_DWORD))
#define FIX_ENDIAN_QWORD(qw) {DRM_BYT_ReverseBytes((DRM_BYTE*)&(qw),SIZEOF(DRM_UINT64));NATIVE64_TO_NONNATIVE64((qw));}
#endif

#endif

typedef struct __tagDRM_GUID {
    DRM_DWORD Data1;
    DRM_WORD  Data2;
    DRM_WORD  Data3;
    DRM_BYTE  Data4 [__CB_DECL(8)];
} DRM_GUID;

#define ALL_N_BITS_ON(n) (~((~0)<<(n)))
/*
** This macro will calculate the maximum value of an unsigned data type 
** where the type is passed in as x.
** For example MAX_UNSIGNED_TYPE( DRM_BYTE  ) will evaluate to 0xFF
**             MAX_UNSIGNED_TYPE( DRM_DWORD ) will evaluate to 0xFFFFFFFF
*/
#define MAX_UNSIGNED_TYPE(x) (ALL_N_BITS_ON(SIZEOF(x)*BITS_PER_BYTE))


/*
**
*/
typedef struct tagDRM_CONST_STRING
{
    const DRM_WCHAR *pwszString;
    DRM_DWORD        cchString;
} DRM_CONST_STRING;

/*
**
*/
typedef struct tagDRM_STRING
{
    DRM_WCHAR *pwszString;
    DRM_DWORD  cchString;
} DRM_STRING;

typedef struct tagDRM_ANSI_CONST_STRING
{
    const DRM_CHAR *pszString;
    DRM_DWORD       cchString;
} DRM_ANSI_CONST_STRING;

typedef struct tagDRM_ANSI_STRING
{
    DRM_CHAR  *pszString;
    DRM_DWORD  cchString;
} DRM_ANSI_STRING;

typedef struct __tagSubString
{
    DRM_DWORD m_ich;
    DRM_DWORD m_cch;
} DRM_SUBSTRING;

#define ASSIGN_DRM_ANSI_STRING(x,y) \
{ \
    (x).pszString = (y); \
    (x).cchString = NO_OF(y)-1; \
}

#define ASSIGN_DRM_STRING(x,y) \
{ \
    (x).pwszString = (y).pwszString; \
    (x).cchString  = (y).cchString; \
}

#define INIT_DRM_STRING(x) \
{ \
    (x).pwszString = NULL; \
    (x).cchString  = 0; \
}

#define INIT_DRM_ANSI_STRING(x) \
{ \
    (x).pszString = NULL; \
    (x).cchString = 0; \
}

#if TARGET_LITTLE_ENDIAN || SIXTEEN_BIT_ADDRESSING
/* Little endian machines will use L"".  Packed strings will use TWO_BYTES( ) which will be a short and the right size */
#define CREATE_DRM_STRING(x) { (x), (NO_OF(x)) - 1 }
#else
/* Big Endian processors that are 8-bit referencable will have strings like "S\0t\0r\0i\0n\0g\0" */
#define CREATE_DRM_STRING(x) { (DRM_WCHAR*) x, (NO_OF(x)-1)/SIZEOF(DRM_WCHAR)}
#endif

#if TARGET_LITTLE_ENDIAN
#define WCHAR_CAST(x)   ((DRM_WCHAR)(x))
#define NATIVE_WCHAR(x) (x)
#else
#define WCHAR_CAST(x)   ((DRM_WCHAR)(x)<<8)
#define NATIVE_WCHAR(x) ((x)>>8)
#endif

#define CREATE_DRM_ANSI_STRING(x) {(x),((NO_OF(x))-1)*CB_NATIVE_BYTE}

#define EMPTY_DRM_STRING     { NULL, 0 }
#define EMPTY_DRM_SUBSTRING  { 0, 0 }

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(p)   (p)
#endif

#define DSTR_FROM_PB(pdstr,pb,cb) \
    (pdstr)->cchString=(cb)/SIZEOF(DRM_WCHAR); \
    (pdstr)->pwszString=(DRM_WCHAR*)(pb); 

#define DASTR_FROM_PB(pdastr,pb,cb) \
    (pdastr)->cchString=(cb)/( SIZEOF( DRM_CHAR ) / CB_NATIVE_BYTE ); \
    (pdastr)->pszString=(DRM_CHAR*)(pb); 

/* for frequent uses of DRM_CONST_STRINGs' char counts and
  wide-char buffers as byte counts and byte buffers */

#define PB_DSTR(pdstr) (DRM_BYTE*)((pdstr)->pwszString)
#define CB_DSTR(pdstr) ((pdstr)->cchString*SIZEOF(DRM_WCHAR))

#define PB_DASTR(pdstr) (DRM_BYTE*)((pdstr)->pszString)
#define CB_DASTR(pdstr) ((pdstr)->cchString)

typedef struct _tagDRMSYSTEMTIME
{
    DRM_WORD wYear;
    DRM_WORD wMonth;
    DRM_WORD wDayOfWeek;
    DRM_WORD wDay;
    DRM_WORD wHour;
    DRM_WORD wMinute;
    DRM_WORD wSecond;
    DRM_WORD wMilliseconds;
} 	DRMSYSTEMTIME;

#if TARGET_LITTLE_ENDIAN
typedef struct _tagDRMFILETIME
{
    DRM_DWORD dwLowDateTime;
    DRM_DWORD dwHighDateTime;
} DRMFILETIME;
#else
typedef struct _tagDRMFILETIME
{
    DRM_DWORD dwHighDateTime;
    DRM_DWORD dwLowDateTime;
} DRMFILETIME;
#endif
/* generic ID type, currently all the same size */

#define DRM_ID_SIZE  16

typedef struct _tagDRM_ID 
{
    DRM_BYTE rgb [__CB_DECL(DRM_ID_SIZE)];
} DRM_ID;

typedef DRM_ID DRM_MID;
typedef DRM_ID DRM_KID;
typedef DRM_ID DRM_LID;
typedef DRM_ID DRM_TID;

#define DRM_SLK_SIZE 8

typedef struct __tagDRM_SLK
{
    DRM_BYTE rgb[__CB_DECL(DRM_SLK_SIZE)];
} DRM_SLK;

#ifdef __cplusplus
}
#endif

#endif  /* __DRMTYPES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmtoolsconstants.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>

const DRM_WCHAR g_rgwchRootTag                     [] = L"PACKAGEPARAMS";
const DRM_WCHAR g_rgwchKeySeedTag                  [] = L"KEYSEED";
const DRM_WCHAR g_rgwchSigningKey                  [] = L"SIGNINGKEY";
const DRM_WCHAR g_rgwchLaUrlTag                    [] = L"LAURL";
const DRM_WCHAR g_rgwchEncBlkSize                  [] = L"BLOCKSIZE";
const DRM_WCHAR g_rgwchCID                         [] = L"CID";
const DRM_WCHAR g_rgwchVerifyKey                   [] = L"VERIFYKEY";
const DRM_WCHAR g_rgwchDefaultURL                  [] = L"http://v2srv/WM/getv2lic.asp";
const DRM_WCHAR g_rgwchDefaultBlksize              [] = L"2048";
const DRM_WCHAR g_rgwchDefaultFilename             [] = L"c:\\WMDRMPD\\PkgInit.xml";
const DRM_WCHAR g_rgwchContents                    [] = L"Contents";
const DRM_WCHAR g_rgwchSerial                      [] = L"Serial";
const DRM_WCHAR g_rgwchTagPrivkey                  [] = L"PRIVKEY";
const DRM_WCHAR g_rgwchTagKeypair                  [] = L"KEYPAIR";
const DRM_WCHAR g_rgwchTagExpression               [] = L"EXPR";

const DRM_WCHAR g_rgwchTagRequestDAC               [] = L"RequestDAC";
const DRM_WCHAR g_rgwchTagDAC                      [] = L"DAC";
const DRM_WCHAR g_rgwchTagOEMPrivateKeys           [] = L"OEMPrivateKeys";
const DRM_WCHAR g_rgwchTagDACResponse              [] = L"DacResponse";

const DRM_BYTE  g_rgbFFFE              [__CB_DECL(2)] = { TWO_BYTES( 0xff, 0xfe ) };

/*
**  XPaths
*/
const DRM_WCHAR g_rgwchXPathDACPubKey              [] = L"DAC/PUBLICKEY";
const DRM_WCHAR g_rgwchXPathFallbackPubKey         [] = L"FALLBACK/PUBLICKEY";
const DRM_WCHAR g_rgwchXPathDACPrivKey             [] = L"DAC/PRIVKEY";
const DRM_WCHAR g_rgwchXPathFallbackPrivKey        [] = L"FALLBACK/PRIVKEY";
const DRM_WCHAR g_rgwchXPathFallbackSecVer         [] = L"FALLBACK/SECURITYVERSION";

/* generateDAC */

const DRM_WCHAR g_rgwchTagDataSecurityVersionValue [] = L"2.3.0.2";
const DRM_WCHAR g_rgwchAuthorizationIDDAC          [] = L"42";
const DRM_WCHAR g_rgwchAuthIDDACRoot               [] = L"1";
const DRM_WCHAR g_rgwchTagSecurityLevelValue       [] = L"2000";

/* metering tools */

const DRM_WCHAR g_rgwchCertMetercert               [] = L"AAEAADgAAAB17bfg!cqDLB2clHGU7P6zkrOCVUddX95UYkqpjqvoIr4ezqw2zgwfrvKR1dq!EzdGD8ND2Ihkn0OPEoWZZKCwgidp7Y5SHR!NFJJazdPWfBQEBB4AAAABAAAAAQAAAAE=";

/* secure clock */

const DRM_WCHAR g_rgwchCertSecureClock             [] = L"AAEAADgAAAC5z9yihdTTDj6gWuC2hovQQiLzAxNdjiupld!06zjVyJCPSjOLwjkI5SmqrnEDjo2H!KJV4qk2CQ0gMwyurmC1oOVc1uT64vQ!uoHobiFeg2NjDB8AAAABAAAAAQAAAAE=";

/* XML utils */

const DRM_WCHAR g_rgwchTestTemplate                [] = L"<INCLUDES><INCLUDE>xyz</INCLUDE></INCLUDES>";
const DRM_WCHAR g_rgwchXMLTree1                    [] = L"<INCLUDES><INCLUDE1>abc</INCLUDE1><INCLUDE>xyx</INCLUDE></INCLUDES>";
const DRM_WCHAR g_rgwchXMLTree2                    [] = L"<DATA><KID>abc</KID><LID>pqr</LID><META><UID>xyz</UID><LGPUBKEY>sfsd</LGPUBKEY></META></DATA>";
const DRM_WCHAR g_rgwchXMLTree3                    [] = L"<LID>pqr</LID><META><UID>xyz</UID></META>";
const DRM_WCHAR g_rgwchXMLTree4                    [] = L"<KID>abc</KID><META><UID>xyz</UID></META>";

const DRM_CONST_STRING  g_dstrTagRequestDAC         = CREATE_DRM_STRING(g_rgwchTagRequestDAC);
const DRM_CONST_STRING  g_dstrTagDAC                = CREATE_DRM_STRING(g_rgwchTagDAC);
const DRM_CONST_STRING  g_dstrTagOEMPrivateKeys     = CREATE_DRM_STRING(g_rgwchTagOEMPrivateKeys);
const DRM_CONST_STRING  g_dstrTagDACResponse        = CREATE_DRM_STRING(g_rgwchTagDACResponse);
const DRM_CONST_STRING  g_dstrXPathDACPubKey        = CREATE_DRM_STRING(g_rgwchXPathDACPubKey);
const DRM_CONST_STRING  g_dstrXPathFallbackPubKey   = CREATE_DRM_STRING(g_rgwchXPathFallbackPubKey);
const DRM_CONST_STRING  g_dstrXPathDACPrivKey       = CREATE_DRM_STRING(g_rgwchXPathDACPrivKey);
const DRM_CONST_STRING  g_dstrXPathFallbackPrivKey  = CREATE_DRM_STRING(g_rgwchXPathFallbackPrivKey);
const DRM_CONST_STRING  g_dstrXPathFallbackSecVer   = CREATE_DRM_STRING(g_rgwchXPathFallbackSecVer);

/* generateDAC */

const DRM_CONST_STRING  g_dstrTagDataSecurityVersionValue = CREATE_DRM_STRING(g_rgwchTagDataSecurityVersionValue);
const DRM_CONST_STRING  g_dstrAuthorizationIDDAC          = CREATE_DRM_STRING(g_rgwchAuthorizationIDDAC);
const DRM_CONST_STRING  g_dstrAuthIDDACRoot               = CREATE_DRM_STRING(g_rgwchAuthIDDACRoot);
const DRM_CONST_STRING  g_dstrTagSecurityLevelValue       = CREATE_DRM_STRING(g_rgwchTagSecurityLevelValue);

/* metering tools */

const DRM_CONST_STRING g_dstrCertMetercert                = CREATE_DRM_STRING(g_rgwchCertMetercert);

/* secure clock */

const DRM_CONST_STRING g_dstrCertSecureClock        = CREATE_DRM_STRING(g_rgwchCertSecureClock);

/* XML utils */

const DRM_CONST_STRING  g_dstrTestTemplate          = CREATE_DRM_STRING(g_rgwchTestTemplate);
const DRM_CONST_STRING  g_dstrXMLTree1              = CREATE_DRM_STRING(g_rgwchXMLTree1);
const DRM_CONST_STRING  g_dstrXMLTree2              = CREATE_DRM_STRING(g_rgwchXMLTree2);
const DRM_CONST_STRING  g_dstrXMLTree3              = CREATE_DRM_STRING(g_rgwchXMLTree3);
const DRM_CONST_STRING  g_dstrXMLTree4              = CREATE_DRM_STRING(g_rgwchXMLTree4);

/* package tools */

const DRM_CONST_STRING  g_dstrSigningKey            = CREATE_DRM_STRING(g_rgwchSigningKey);
const DRM_CONST_STRING  g_dstrTagRoot               = CREATE_DRM_STRING(g_rgwchRootTag);
const DRM_CONST_STRING  g_dstrTagKeySeed            = CREATE_DRM_STRING(g_rgwchKeySeedTag);
const DRM_CONST_STRING  g_dstrTagURLLicAcq          = CREATE_DRM_STRING(g_rgwchLaUrlTag);
const DRM_CONST_STRING  g_dstrEncBlkSize            = CREATE_DRM_STRING(g_rgwchEncBlkSize);
const DRM_CONST_STRING  g_dstrCID                   = CREATE_DRM_STRING(g_rgwchCID);
const DRM_CONST_STRING  g_dstrVerifyKey             = CREATE_DRM_STRING(g_rgwchVerifyKey);
const DRM_CONST_STRING  g_dstrDefaultURL            = CREATE_DRM_STRING(g_rgwchDefaultURL);
const DRM_CONST_STRING  g_dstrDefaultBlksize        = CREATE_DRM_STRING(g_rgwchDefaultBlksize);
const DRM_CONST_STRING  g_dstrDefaultFilename       = CREATE_DRM_STRING(g_rgwchDefaultFilename);
const DRM_CONST_STRING  g_dstrContents              = CREATE_DRM_STRING(g_rgwchContents);
const DRM_CONST_STRING  g_dstrSerial                = CREATE_DRM_STRING(g_rgwchSerial);
const DRM_CONST_STRING  g_dstrTagPrivkey            = CREATE_DRM_STRING(g_rgwchTagPrivkey);
const DRM_CONST_STRING  g_dstrTagKeypair            = CREATE_DRM_STRING(g_rgwchTagKeypair);
const DRM_CONST_STRING  g_dstrTagExpression         = CREATE_DRM_STRING(g_rgwchTagExpression);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmviewprops.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_VIEWPROPERTIES_H__
#define __DRM_VIEWPROPERTIES_H__


#ifdef __cplusplus
extern "C" {
#endif

/* We need: */
/* 1.  Content header KID */
/* 2.  Blackbox context */
/* 3.  Secure store open to global state */
/* 4.  Secure store context not open yet */
/* 5.  License store context ( we enum here ) */
/* 6.  License eval context */
#if DRM_SUPPORT_PMLICENSE == 1
#define DRM_MAX_RIGHTS_SUPPORTED 5
#else
#define DRM_MAX_RIGHTS_SUPPORTED 3
#endif

#if !DRM_LICENSE_STATE_TYPES_DEFINED
#define DRM_LICENSE_STATE_TYPES_DEFINED 1
/* Enum and structure for license properties queries */
typedef enum DRM_LICENSE_STATE_CATEGORY
{
    WM_DRM_LICENSE_STATE_NORIGHT = 0,
    WM_DRM_LICENSE_STATE_UNLIM,
    WM_DRM_LICENSE_STATE_COUNT,
    WM_DRM_LICENSE_STATE_FROM,
    WM_DRM_LICENSE_STATE_UNTIL,
    WM_DRM_LICENSE_STATE_FROM_UNTIL,
    WM_DRM_LICENSE_STATE_COUNT_FROM,
    WM_DRM_LICENSE_STATE_COUNT_UNTIL,
    WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL,
    WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE,
    WM_DRM_LICENSE_STATE_FORCE_SYNC
} DRM_LICENSE_STATE_CATEGORY;

typedef struct _DRM_LICENSE_STATE_DATA
{
    DRM_DWORD   dwStreamId;      /* 0 -> All streams, != 0 -> A particular stream. */
    DRM_DWORD   dwCategory;      /* Indicates the category of string to be displayed. */
    DRM_DWORD   dwNumCounts;     /* Number of items supplied in dwCount. */
    DRM_DWORD   dwCount  [4];    /* Up to 4 counts. */
    DRM_DWORD   dwNumDates;      /* Number of items supplied in dwDate. */
    DRMFILETIME datetime [4];    /* Up to 4 dates. */
    DRM_DWORD   dwVague;         /* 0 -> certain, 1 -> atleast.  (There could be more */
                                 /*               licenses. Aggregation not possible.) */
} DRM_LICENSE_STATE_DATA;

#endif

/***************************************************************************/
/* Internal structures and data */
typedef enum
{
    LIC_TYPE_IGNORE = 0,
    LIC_TYPE_EXPIRY,
    LIC_TYPE_COUNTED_EXPIRY,
    LIC_TYPE_EXPIRATION_AFTER_FIRST_USE
} LicenseCategory;

typedef struct LicenseInfo
{
    LicenseCategory  dwCategory;     /* License Category. DIVX, counted etc. */
    DRM_DWORD       dwStartCount;   /* How many counts were given originally. */
    DRM_DWORD       dwCount;        /* How many counts are left. */
    DRM_DWORD       dwHours;        /* How many days are left. For expiration after first use licenses that are never used so far. */
    DRMFILETIME    begDate;        /* License valid only after this date. */
    DRMFILETIME    endDate;        /* License not valid after this date. */
} LicenseInfo;
/***************************************************************************/

typedef DRM_RESULT ( DRM_API *pfnGetNextV1License )( 
    IN DRM_VOID*, 
    const DRM_CONST_STRING *rgpdstrAction[], /* Array of DRM_CONST_STRING pointers */
    DRM_DWORD cActionsQueried, 
    OUT LicenseInfo* pInfo );

/* Structure to be filled by caller */
typedef struct __tagDRM_VIEW_RIGHTS_CONTEXT
{
/*PUBLIC */
    DRM_KID KID; /* Pointer to a DRM_KID_LENGTH byte buffer with the KID we are looking for */
    DRM_BB_CONTEXT *pBBContext; /* Pointer to a Blackbox context structure */
    DRM_SECSTORE_CONTEXT *pbGlobalSecStore; /* Pointer to a secure store opened to the global key */
    DRM_SECSTORE_CONTEXT *pbLIDSecStore; /* Pointer to open secure store -- not opened to a specific key yet. */
    DRM_LICSTORE_CONTEXT *pbLicenseStore; /* Pointer to an open license store context */
    DRM_LICSTOREENUM_CONTEXT *pLicQueryContext; /* Pointer to memory for a DRM_LICSTOREENUM_CONTEXT.  Should not be intialized!!!  Just need the memory */
    DRM_LICEVAL_CONTEXT* pLicEval; /* Pointer to a liceval context */
    pfnGetNextV1License pGetNextV1License; /* Callback so V1 licenses can be aggregated as well, can be NULL*/
    DRM_VOID* pV1LicenseContext; /* Context passed to pGetNextV1License can be NULL */
    DRM_BYTE *pbBuffer; /* User gives a sandbox buffer to work in */
    DRM_DWORD cbBuffer; /* Size of sandbox buffer.  If it is too small we will fail.  Don't know how big because licenses can be variable length */

/*PRIVATE */
    DRM_LICENSE_STATE_DATA TempStateData[DRM_MAX_RIGHTS_SUPPORTED]; /* Caller shouldn't touch these */
    LicenseInfo licenseInfo[DRM_MAX_RIGHTS_SUPPORTED]; /* Caller shouldn't touch these */
} DRM_VIEW_RIGHTS_CONTEXT;


DRM_RESULT DRM_API DRM_ASD_GetLicenseAggregateData(
    IN const DRM_CONST_STRING        *f_rgpdstrAction[], /* Array of DRM_CONST_STRING pointers */
    OUT      DRM_LICENSE_STATE_DATA   f_rgStateData[], /* array of DRM_LICENSE_STATE_DATAs */
    IN       DRM_DWORD                f_cActionsQueried,
    IN       DRM_VIEW_RIGHTS_CONTEXT *f_pContext,
    IN       DRM_HDS_CONTEXT         *f_pcontextHDS,
    IN       DRM_BOOL                 f_fDeleteExpiredLicenses);

DRM_RESULT DRM_API DRM_ASD_IsAllowed(
    IN const DRM_CONST_STRING        *pdstrAction,
    IN       DRM_VIEW_RIGHTS_CONTEXT *pContext,
    IN       DRM_HDS_CONTEXT         *pcontextHDS);

DRM_RESULT DRM_API DRM_ASD_ParseV2License(
    IN const DRM_CONST_STRING *f_pdstrLicense, 
    IN const DRM_CONST_STRING *f_pdstrAttrName,
       OUT   DRM_DWORD        *f_pdwValue, 
       OUT   DRMFILETIME      *f_pfiletime);


#ifdef __cplusplus
}
#endif

#endif /* __DRM_VIEWPROPERTIES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmxmlbuilder.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmbase64.h>
#include <drmcrt.h>
#include <drmutilities.h>
#include <drmcipher.h>
#include <drmxmlbuilder.h>

#define CB_XML_BUFFER_MINIMUM  100
#define CWCH_DWORD_STACK       (SIZEOF(DRM_DWORD)/SIZEOF(DRM_WCHAR))
#define CCH_SIMULATION_MININUM (2*CWCH_DWORD_STACK)

/*
***********************************************************************
** types used within this file
***********************************************************************
*/


const DRM_DWORD g_cbXMLBuilderMinimum = SIZEOF (_XMBContext) 
                                      + __CB_DECL(CB_XML_BUFFER_MINIMUM)
                                      + SIZEOF (DRM_WCHAR);

/***************************************************************************** */

/******************************************************************************
** Function:   _PushDWORD
** 
** Synopsis:   push a DWORD value on the end of the stack and decrement it 
** 
** Arguments:  f_pcontextXML - the XML context in use; must be inited
**             f_dwValue     - the value to push  
******************************************************************************/

static DRM_RESULT _PushDWORD(_XMBContext *f_pcontextXML,
                             DRM_DWORD    f_dwValue)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  iPos = 0;

    ChkArg (f_pcontextXML != NULL);
    ChkBOOL(f_pcontextXML->wNextOpenNodePos >= CWCH_DWORD_STACK, DRM_E_BUFFERTOOSMALL);

    iPos = f_pcontextXML->wNextOpenNodePos;
    f_pcontextXML->XmlString [iPos+1] = (DRM_WCHAR) (f_dwValue  & 0x0000FFFF);
    f_pcontextXML->XmlString [iPos]   = (DRM_WCHAR) (f_dwValue >> 16);
    f_pcontextXML->wNextOpenNodePos  -= CWCH_DWORD_STACK;

ErrorExit:
    return dr;
}

/******************************************************************************
** Function:   _GetPushedDWORD
** 
** Synopsis:   pop a DWORD value from the end of the stack 
** 
** Arguments:  f_pcontextXML - the XML context in use; must be inited
**             f_iOffset     - an offset from the current stack position
**             f_pdwValue    - pointer to variable to hold the retrieved value
******************************************************************************/

static DRM_RESULT _GetPushedDWORD(_XMBContext *f_pcontextXML,
                                  DRM_DWORD    f_iOffset,
                                  DRM_DWORD   *f_pdwValue)
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg(f_pcontextXML != NULL
        && f_pdwValue    != NULL);

    ChkArg((f_pcontextXML->wNextOpenNodePos + f_iOffset) >= CWCH_DWORD_STACK);

    *f_pdwValue  =  (DRM_DWORD)  (f_pcontextXML->XmlString [f_pcontextXML->wNextOpenNodePos + f_iOffset + 1]);
    *f_pdwValue += ((DRM_DWORD) ((f_pcontextXML->XmlString [f_pcontextXML->wNextOpenNodePos + f_iOffset])) << 16);

ErrorExit:
    return dr;
}

/*
** Trim all leading and trailing blanks in given string 
** return TRUE if resulting string length > 0
*/
static DRM_BOOL _AllTrim2(
    IN const DRM_CONST_STRING *pdstrString,
       OUT   DRM_CONST_STRING *pdstrTrimedString)
{
    DRM_BOOL fResult = FALSE;

    if ( pdstrString             == NULL
      || pdstrTrimedString       == NULL
      || pdstrString->pwszString == NULL 
      || pdstrString->cchString  == 0 )
    {
        goto ErrorExit;
    }

    *pdstrTrimedString = *pdstrString;

    /* trim leading blanks */
    while ( pdstrTrimedString->pwszString[0] == g_wchSpace  && pdstrTrimedString->cchString>0 )
    {
        ++pdstrTrimedString->pwszString;
        --pdstrTrimedString->cchString;
    }

    /* trim trailing blanks */
    while ( pdstrTrimedString->cchString>0
        && pdstrTrimedString->pwszString[pdstrTrimedString->cchString-1] == g_wchSpace )
    {
        --pdstrTrimedString->cchString;
    }

    fResult = pdstrTrimedString->cchString > 0;

ErrorExit:
    return fResult;
}

/*
** Create context for the builder
*/
static DRM_RESULT _CreateContext(
    IN     DRM_DWORD  cbXmlContext,
    IN OUT DRM_BYTE  *pbXmlContext,
    IN     DRM_BOOL   fIsSimMode)
{
    DRM_RESULT   dr = DRM_SUCCESS;
    _XMBContext *pContext = NULL;

    if (cbXmlContext < g_cbXMLBuilderMinimum)
    {
        ChkDR (DRM_E_BUFFERTOOSMALL);
    }

    ZEROMEM(pbXmlContext, cbXmlContext);
    pContext                   = (_XMBContext*)pbXmlContext;
    pContext->wSize            = cbXmlContext;
    pContext->wBuffSize        = ((cbXmlContext - SIZEOF(_XMBContext)) / SIZEOF(DRM_WCHAR));
    pContext->wNextStringPos   = 0;
    pContext->wNextOpenNodePos = pContext->wBuffSize - CWCH_DWORD_STACK; /* next position to be used on stack */
    pContext->fInited          = TRUE;
    pContext->fIsSimMode       = fIsSimMode;
    pContext->wMaxStackUsed    = 0;
    
ErrorExit:
    return dr;
}

/*
** Open a new node nested from current opened node
*/
static DRM_RESULT _OpenNode(
    IN OUT   _XMBContext      *pContext,
    IN const DRM_CONST_STRING *pdstrNodeName )
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_DWORD        wNodePos     = 0;
    DRM_CONST_STRING dstrNodeName = EMPTY_DRM_STRING;
    
    ChkArg(_AllTrim2(pdstrNodeName, &dstrNodeName));

    if ( pContext->fIsSimMode )
    {
        /* fake mode pushes 2 DWORDs, one for node position, one for tag name size */
        
        if (pContext->wNextOpenNodePos < CCH_SIMULATION_MININUM)
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
        wNodePos = pContext->wNextStringPos + 1;
        
        /* calculate length of the open tag now  2 = "<>" */
        
        pContext->wNextStringPos += dstrNodeName.cchString + 2;

        /* push the node position to end of XML string */
        
        ChkDR(_PushDWORD(pContext, wNodePos));

        /* push the tag name length to end of XML string */

        ChkDR(_PushDWORD(pContext, dstrNodeName.cchString));

        /* keep track of max stack used */
        {

            DRM_DWORD wCurrStack = (pContext->wBuffSize - 1 - pContext->wNextOpenNodePos) / 2;

            if ( pContext->wMaxStackUsed < wCurrStack )
            {
                pContext->wMaxStackUsed = wCurrStack;
            }
        }
        
    }
    else
    {
        if ( (pContext->wNextStringPos + dstrNodeName.cchString + CWCH_DWORD_STACK) >= pContext->wNextOpenNodePos )
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* print "<tag>" to the XML string*/
        wcsncpy(&pContext->XmlString[pContext->wNextStringPos], g_dstrOpenTag.pwszString, g_dstrOpenTag.cchString);
        pContext->wNextStringPos += 1;
        wNodePos = pContext->wNextStringPos;

        wcsncpy(&pContext->XmlString[pContext->wNextStringPos], dstrNodeName.pwszString, dstrNodeName.cchString);
        pContext->wNextStringPos += dstrNodeName.cchString;

        wcsncpy(&pContext->XmlString[pContext->wNextStringPos], g_dstrCloseTag.pwszString, g_dstrCloseTag.cchString);
        pContext->wNextStringPos += 1;
        
        /* push the node position to end of XML string */

        ChkDR(_PushDWORD(pContext, wNodePos));
    }
    
ErrorExit:
    return dr;
}


/*
** Close the current opened node
*/
static DRM_RESULT DRM_API _CloseCurrNode(
    IN OUT DRM_BYTE   *pbXmlContext,
    IN     DRM_BOOL    fOkayToCloseRoot,
       OUT DRM_STRING *pdstrXMLString)   /* optional parameter */
{
    DRM_RESULT   dr          = DRM_SUCCESS;
    _XMBContext *pContext    = (_XMBContext*)pbXmlContext;
    DRM_DWORD    wLen        = 0;
    DRM_DWORD    wNodePos    = 0;
    DRM_DWORD    cwchMinStack = 0;

    ChkArg(pContext->fInited);

    /*
    ** make sure the stack is not empty. Stack is count by CWCH_DWORD_STACK. 
    ** to close a node, we must have at least ONE CWCH_DWORD_STACK on stack.
    ** if fOkayToCloseRoot is FALSE, we must have at least two CWCH_DWORD_STACK
    ** on stack.
    */
    cwchMinStack = 2 * CWCH_DWORD_STACK;  /* do not pop off the root node */
    if (fOkayToCloseRoot)
    {
        cwchMinStack = CWCH_DWORD_STACK;  /* root node */
    }

    if ( (pContext->wNextOpenNodePos + cwchMinStack) >= pContext->wBuffSize )    /* do not pop off the root node !*/
    {
        dr = DRM_E_NOMORE;    /* stack is empty */
        goto ErrorExit;
    }

    if ( !pContext->fIsSimMode )
    {
        /* parse length of node name */

        ChkDR(_GetPushedDWORD(pContext, CWCH_DWORD_STACK, &wNodePos));

        if ( pdstrXMLString != NULL )
        {
            pdstrXMLString->pwszString = &(pContext->XmlString[wNodePos - 1]);    
        }

        while (pContext->XmlString [wNodePos + wLen] != g_wchSpace 
            && pContext->XmlString [wNodePos + wLen] != g_wchGreaterThan )
        {
            wLen++;
        }
        
        if ( (pContext->wNextStringPos + wLen + 3) >= pContext->wNextOpenNodePos )
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* print </tag> to the XML string*/
        wcsncpy(&pContext->XmlString[pContext->wNextStringPos], g_dstrOpenEndTag.pwszString, g_dstrOpenEndTag.cchString);
        pContext->wNextStringPos += 2;
        wcsncpy(&pContext->XmlString[pContext->wNextStringPos], &pContext->XmlString[wNodePos], wLen);
        pContext->wNextStringPos += wLen;
        wcsncpy(&pContext->XmlString[pContext->wNextStringPos], g_dstrCloseTag.pwszString, g_dstrCloseTag.cchString);
        pContext->wNextStringPos += 1;

        /* pop the node position from end of XML string */
        pContext->wNextOpenNodePos += CWCH_DWORD_STACK;
    }
    else
    {
        DRM_DWORD cchPop = 0;
        
        ChkDR(_GetPushedDWORD(pContext, CWCH_DWORD_STACK, &cchPop));
        ChkDR(_GetPushedDWORD(pContext, 2 * CWCH_DWORD_STACK, &wNodePos));
                              
        /* calculate length of the close tag now 3 = "</>" */
        
        pContext->wNextStringPos += cchPop + 3;

        /* pop the node position and tag name size from end of XML string */

        pContext->wNextOpenNodePos += 2 * CWCH_DWORD_STACK;
    }

    if ( pdstrXMLString != NULL )
    {
        pdstrXMLString->cchString = pContext->wNextStringPos - wNodePos + 1;
    }

ErrorExit:
    return dr;
}


/*
** calcuate the current node size
*/
static DRM_RESULT DRM_API _CalcNodeSize(
    IN  DRM_BYTE  *pbXmlContext,
    OUT DRM_DWORD *pcchContent,  /* ch count of node content */
    OUT DRM_DWORD *pcchTagName)  /* ch count of node tag */
{
    DRM_RESULT   dr       = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;
    DRM_DWORD    wLen     = 0;
    DRM_DWORD    wNodePos = 0;

    ChkArg( pbXmlContext != NULL
         && pcchContent  != NULL
         && pcchTagName  != NULL
         && pContext->fInited );

    if ( pContext->fIsSimMode )
    {
        _GetPushedDWORD(pContext, CWCH_DWORD_STACK,  pcchTagName);
        _GetPushedDWORD(pContext, 2 * CWCH_DWORD_STACK, &wNodePos);
        
        /* this is not accurate in case the open node has attributes */
        *pcchContent = pContext->wNextStringPos - wNodePos - *pcchTagName - 1;
    }
    else
    {
        /* parse length of node name */
        
        _GetPushedDWORD(pContext, CWCH_DWORD_STACK, &wNodePos);
        
        while (pContext->XmlString [wNodePos + wLen] != g_wchSpace 
            && pContext->XmlString [wNodePos + wLen] != g_wchGreaterThan )
        {
            wLen++;
        }
        *pcchTagName = wLen;

        /* parse first position of node content */
        while (pContext->XmlString[wNodePos + wLen] != g_wchGreaterThan )
        {
            wLen++;
        }
        *pcchContent = pContext->wNextStringPos - wNodePos - wLen - 1;
    }
    
ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_XMB_SimulateCreateDocument(
    IN const DRM_DWORD         cbXmlContext,
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrRootNodeName)
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;

    /* create the context */
    ChkArg(pbXmlContext != NULL
        && cbXmlContext != 0    );

    ChkDRMString(pdstrRootNodeName);

    ChkDR(_CreateContext(cbXmlContext, pbXmlContext, TRUE));

    /* open the root node */
    ChkDR( _OpenNode(pContext, pdstrRootNodeName) );

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_XMB_CreateDocument(
    IN const DRM_DWORD         cbXmlContext,
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrRootNodeName)
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;

    /* create the context */
    ChkArg(pbXmlContext != NULL
        && cbXmlContext != 0    );

    ChkArg((((DRM_DWORD) pbXmlContext) % sizeof (DRM_DWORD)) == 0);

    ChkDRMString(pdstrRootNodeName);

    ChkDR(_CreateContext(cbXmlContext, pbXmlContext, FALSE));

    /* open the root node */
    ChkDR( _OpenNode(pContext, pdstrRootNodeName) );

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_XMB_ReallocDocument(
    IN const DRM_BYTE  *pbOldXmlContext,
    IN const DRM_DWORD  cbNewXmlContext,
    IN OUT   DRM_BYTE  *pbNewXmlContext )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContext *pOldContext = (_XMBContext*)pbOldXmlContext;
    _XMBContext *pNewContext = (_XMBContext*)pbNewXmlContext;

    ChkArg( pbOldXmlContext != NULL
         && cbNewXmlContext != 0
         && pbNewXmlContext != NULL 
         && pOldContext->fInited );

    if ( cbNewXmlContext <= pOldContext->wSize )
    {
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    /* create new context using new buffer */
    if ( pbOldXmlContext != pbNewXmlContext )
    {
        ChkDR(_CreateContext(cbNewXmlContext, pbNewXmlContext, pOldContext->fIsSimMode));

        /* copy XML String to new context */
        MEMCPY(pNewContext->XmlString, pOldContext->XmlString, pOldContext->wNextStringPos * SIZEOF(DRM_WCHAR));
        pNewContext->wNextStringPos = pOldContext->wNextStringPos;

        /* copy node positions info to new context */
        pNewContext->wNextOpenNodePos = pNewContext->wBuffSize 
                                      - pOldContext->wBuffSize 
                                      + pOldContext->wNextOpenNodePos;

        MEMMOVE(&pNewContext->XmlString[pNewContext->wNextOpenNodePos],
                &pOldContext->XmlString[pOldContext->wNextOpenNodePos],
                (pOldContext->wBuffSize - pOldContext->wNextOpenNodePos) * SIZEOF(DRM_WCHAR));
        
        /* invalidate the old context */
        pOldContext->fInited = FALSE;
    }

    // the new buffer is the same as the old buffer except bigger.
    else
    {
        DRM_DWORD dwOldSize = pOldContext->wBuffSize;
        DRM_DWORD dwOldNextOpenNodePos = pOldContext->wNextOpenNodePos;
            
        pNewContext->wSize     = cbNewXmlContext;
        pNewContext->wBuffSize = ((cbNewXmlContext - SIZEOF(_XMBContext)) / SIZEOF(DRM_WCHAR));

        /* copy node positions info to new context */
        pNewContext->wNextOpenNodePos = pNewContext->wBuffSize - dwOldSize + dwOldNextOpenNodePos;

        MEMMOVE(&pNewContext->XmlString[pNewContext->wNextOpenNodePos],
                &pOldContext->XmlString[dwOldNextOpenNodePos],
                (dwOldSize - dwOldNextOpenNodePos) * SIZEOF(DRM_WCHAR));
    }
ErrorExit:
    return dr;
}
 

DRM_RESULT DRM_API DRM_XMB_CloseDocument(
    IN OUT DRM_BYTE    *pbXmlContext,
       OUT DRM_STRING  *pdstrXML)
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;

    ChkArg( pbXmlContext != NULL 
         && pdstrXML     != NULL
         && pContext->fInited );
    
    while (TRUE)
    {
        dr = _CloseCurrNode(pbXmlContext, TRUE, NULL);
        if ( dr == DRM_E_NOMORE )
        {
            dr = DRM_SUCCESS;
            break;
        }
        else
        {
            ChkDR(dr);
        }
    }

    if ( pContext->fIsSimMode )
    {
        DRM_DWORD cbOverhead = DRM_XMB_OVERHEAD;

        pdstrXML->pwszString = NULL;
        pdstrXML->cchString  = pContext->wNextStringPos;

        /* add extra room for simulate mode so that the call can allow enough 
        ** buffer size for creating this document */
        if ( cbOverhead < (pContext->wMaxStackUsed * SIZEOF(DRM_WCHAR) + SIZEOF(_XMBContext)) )
        {
            cbOverhead = pContext->wMaxStackUsed * SIZEOF(DRM_WCHAR) + SIZEOF(_XMBContext);
        }
        pdstrXML->cchString += (cbOverhead + 1) / SIZEOF(DRM_WCHAR);
    }
    else
    {
        pdstrXML->pwszString = pContext->XmlString;
        pdstrXML->cchString  = pContext->wNextStringPos;
    }
        

    /* invalidate the context */
    pContext->fInited = FALSE;

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_XMB_OpenNode(
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrNodeName)
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;

    ChkArg( pbXmlContext != NULL
         && pContext->fInited    ); 
    ChkDRMString(pdstrNodeName);

    /* open the root node */
    ChkDR( _OpenNode(pContext, pdstrNodeName) );

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_XMB_CloseCurrNode(
    IN OUT DRM_BYTE   *pbXmlContext,
       OUT DRM_STRING *pdstrXMLFragment)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( pbXmlContext != NULL );
    ChkDR(_CloseCurrNode(pbXmlContext, FALSE, pdstrXMLFragment));

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_XMB_SaveState(
    IN OUT   DRM_BYTE  *pbXmlContext,
       OUT   XMBState  *pState)
{
    DRM_RESULT   dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;

    ChkArg( pbXmlContext != NULL  &&  pState != NULL );

    pState->cwchMaxStackUsed    = pContext->wMaxStackUsed;
    pState->iwchNextOpenNodePos = pContext->wNextOpenNodePos;
    pState->iwchNextStringPos   = pContext->wNextStringPos;

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_XMB_RestoreState(
    IN OUT   DRM_BYTE  *pbXmlContext,
    IN       XMBState  *pState)
{
    DRM_RESULT   dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;

    ChkArg( pbXmlContext != NULL  &&  pState != NULL );

    pContext->wMaxStackUsed    = pState->cwchMaxStackUsed;
    pContext->wNextOpenNodePos = pState->iwchNextOpenNodePos;
    pContext->wNextStringPos   = pState->iwchNextStringPos;

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_XMB_EncryptAndCloseCurrNode(
    IN OUT   DRM_BYTE           *pbXmlContext,
    IN       DRM_CRYPTO_CONTEXT *pCryptoContext,    /* Pointer to DRM_CRYPTO_CONTEXT */
    IN const PUBKEY             *pPubkey,           /* pub key to use for encrypt */
       OUT   DRM_STRING         *pdstrXMLFragment)  /* optional: XML fragment of the current node, optional. */
{
    DRM_RESULT   dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;
    DRM_DWORD    cchContent = 0;
    DRM_DWORD    cbCryptSize= 0;
    DRM_DWORD    cchEncoded = 0;

    ChkArg( pbXmlContext   != NULL
         && pCryptoContext != NULL
         && pPubkey        != NULL
         && pContext->fInited      );
    

    /*
    ** 1. check available buffer size: 
    **    req size = SIZEOF(WCHAR) * ((blob_size + PK_ENC_CIPHERTEXT_LEN + 2) / 3 * 4)
    ** 2. call EncryptLarge to encrypt the blob in place
    ** 3. call Base64Encode the encrypted data
    ** 4. close the node 
    */

    /* check available space */
    {
        DRM_DWORD cchTagName=0;

        ChkDR(_CalcNodeSize(pbXmlContext, &cchContent, &cchTagName));

        /* req size for encryption */    
        cbCryptSize = cchContent * SIZEOF(DRM_WCHAR) + PK_ENC_CIPHERTEXT_LEN;
        
        /* req size for base64 encode after encryption */
        cchEncoded = CCH_BASE64_EQUIV( cbCryptSize );
        
        if ( !pContext->fIsSimMode )
        {
            if ( (pContext->wNextStringPos - cchContent + cchEncoded + cchTagName + 3) >= 
                pContext->wNextOpenNodePos )
            {
                ChkDR(DRM_E_BUFFERTOOSMALL);
            }
        }
    }

    if ( !pContext->fIsSimMode )
    {
        /* encrypt the content */
        ChkDR(DRM_PK_EncryptLarge(pPubkey, 
                     (DRM_BYTE*)(&pContext->XmlString[pContext->wNextStringPos-cchContent]),
                                  cchContent * SIZEOF(DRM_WCHAR), 
                     (DRM_BYTE*)(&pContext->XmlString[pContext->wNextStringPos-cchContent]), /* encrypt in place */
                                  DRMCIPHERKEYLEN,
                                  pCryptoContext));
        
        /* base64 encode the crypted blob */
        ChkDR(DRM_B64_EncodeW( (DRM_BYTE*)(&pContext->XmlString[pContext->wNextStringPos-cchContent]), 
                                            cbCryptSize,
                                           &pContext->XmlString[pContext->wNextStringPos-cchContent],  /* encode in place */
                                           &cchEncoded, 
                                            0));
    }
    
    /* update wNextStringPos */
    pContext->wNextStringPos = pContext->wNextStringPos - cchContent + cchEncoded;

    /* now close the node */
    ChkDR(_CloseCurrNode(pbXmlContext, FALSE, pdstrXMLFragment));

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_XMB_SignAndCloseCurrNode(
    IN OUT   DRM_BYTE           *pbXmlContext,
    IN       DRM_CRYPTO_CONTEXT *pCryptoContext,  /* Pointer to DRM_CRYPTO_CONTEXT */
    IN const PRIVKEY            *pPrivkey,        /* pub key to use for encrypt */
    IN       DRM_BOOL            fIncludeTag,
       OUT   DRM_BYTE            rgbSign   [__CB_DECL(PK_ENC_SIGNATURE_LEN)],    /* cannot be both NULL */
       OUT   DRM_WCHAR           wszB64Sign [PK_ENC_SIGNATURE_B64LEN], /* cannot be both NULL */
       OUT   DRM_STRING         *pdstrXMLFragment)  /* optional: XML fragment of the current node, optional. */
{
    DRM_RESULT   dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;
    DRM_DWORD    cchContent=0;
    DRM_DWORD    cchTagName=0;
    DRM_STRING   dstrXMLFragment = EMPTY_DRM_STRING;
    DRM_BYTE     _rgbSign[__CB_DECL(PK_ENC_SIGNATURE_LEN)];
    DRM_BYTE    *prgbSign = _rgbSign;

    ChkArg( pbXmlContext   != NULL
         && pCryptoContext != NULL
         && pPrivkey       != NULL
         && ( rgbSign      != NULL 
           || wszB64Sign   != NULL ) 
         && pContext->fInited      );
    
    ChkDR(_CalcNodeSize(pbXmlContext, &cchContent, &cchTagName));

    if ( rgbSign != NULL )
    {
        prgbSign = rgbSign;
    }

    if ( !pContext->fIsSimMode )
    {
        if ( !fIncludeTag )
        {
            /* sign the content */
            ChkDR(DRM_PK_Sign(pCryptoContext->rgbCryptoContext, 
                              pPrivkey,
                 (DRM_BYTE*)(&pContext->XmlString[pContext->wNextStringPos-cchContent]),
                             cchContent * SIZEOF(DRM_WCHAR), 
                             prgbSign));
        }
    }
    
    /* close the node */
    ChkDR(_CloseCurrNode(pbXmlContext, FALSE, &dstrXMLFragment));

    if ( !pContext->fIsSimMode )
    {
        if ( fIncludeTag )
        {
            /* sign the content */
            ChkDR(DRM_PK_Sign(pCryptoContext->rgbCryptoContext, 
                              pPrivkey,
                              PB_DSTR( &dstrXMLFragment ),
                              CB_DSTR( &dstrXMLFragment ),
                              prgbSign));
        }

        /* Base64 encode the signature */
        if ( wszB64Sign )
        {
            DRM_DWORD cchEncoded=PK_ENC_SIGNATURE_B64LEN;
            
            ChkDR(DRM_B64_EncodeW( prgbSign, 
                                   PK_ENC_SIGNATURE_LEN, 
                      (DRM_WCHAR *)wszB64Sign, 
                                  &cchEncoded, 
                                  0));
        }
    }
    
    if ( pdstrXMLFragment )
    {
        *pdstrXMLFragment = dstrXMLFragment;
    }

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_XMB_KeyedHashAndCloseCurrNode(
    IN OUT   DRM_BYTE           *pbXmlContext,
    IN       HMAC_CONTEXT       *pHmacContext,     /* HMAC context */
    IN const DRM_BYTE           *pbHashkey,        /* Hash key for HMAC */
    IN       DRM_DWORD           cbHashkey,        /* byte count of HMAC */
    IN       DRM_BOOL            fIncludeTag,
    OUT      DRM_BYTE            rgbSign    [__CB_DECL(SHA_DIGEST_LEN)],       /* cannot be both NULL */
    OUT      DRM_WCHAR           wszB64Sign [SHA_B64ENC_DIGEST_LEN], /* cannot be both NULL */
    OUT      DRM_STRING         *pdstrXMLFragment) /* optional: XML fragment of the current node, optional. */
{
    DRM_RESULT   dr = DRM_SUCCESS;
    _XMBContext *pContext   = (_XMBContext*)pbXmlContext;
    DRM_DWORD    cchContent = 0;
    DRM_DWORD    cchTagName = 0;
    DRM_STRING   dstrXMLFragment = EMPTY_DRM_STRING;
    DRM_BYTE     _rgbSign [__CB_DECL(SHA_DIGEST_LEN)];
    DRM_BYTE    *prgbSign = _rgbSign;

    ChkArg( pbXmlContext != NULL
         && pHmacContext != NULL
         && pbHashkey    != NULL
         && cbHashkey    != NULL
         && ( rgbSign    != NULL
           || wszB64Sign != NULL )
         && pContext->fInited );
    
    ChkDR(_CalcNodeSize(pbXmlContext, &cchContent, &cchTagName));

    if ( rgbSign )
    {
        prgbSign = rgbSign;
    }


    if ( !pContext->fIsSimMode )
    {
        ChkDR(DRM_HMAC_Init(pHmacContext,pbHashkey,cbHashkey));
        if ( !fIncludeTag )
        {
            /* sign the content */
            ChkDR(DRM_HMAC_Update( pHmacContext,
                      (DRM_BYTE*)(&pContext->XmlString[pContext->wNextStringPos - cchContent]),
                                   cchContent * SIZEOF(DRM_WCHAR)));
        }
    }
    
    /* close the node */
    ChkDR(_CloseCurrNode(pbXmlContext, FALSE, &dstrXMLFragment));

    if ( !pContext->fIsSimMode )
    {
        if ( fIncludeTag )
        {
            /* sign the content */
            ChkDR(DRM_HMAC_Update(pHmacContext, PB_DSTR(&dstrXMLFragment), CB_DSTR(&dstrXMLFragment)));
        }
        ChkDR(DRM_HMAC_Finalize(pHmacContext,prgbSign,SHA_DIGEST_LEN));
    
        /* Base64 encode the signature */
        if ( wszB64Sign )
        {
            DRM_DWORD cchEncoded=SHA_B64ENC_DIGEST_LEN;
            
            ChkDR(DRM_B64_EncodeW(prgbSign, 
                                  SHA_DIGEST_LEN, 
                     (DRM_WCHAR *)wszB64Sign, 
                                 &cchEncoded, 
                                  0));
        }
    }

    if ( pdstrXMLFragment )
    {
        *pdstrXMLFragment = dstrXMLFragment;
    }

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_XMB_GetCurrNodeName(
    IN  DRM_BYTE   *pbXmlContext,
    OUT DRM_STRING *pdstrNodeName)
{
    DRM_RESULT   dr       = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;
    DRM_DWORD    wLen     = 0;
    DRM_DWORD    wNodePos = 0;

    ChkArg( pbXmlContext  != NULL
         && pdstrNodeName != NULL
         && pContext->fInited);
         
    if ( pContext->fIsSimMode )
    {
        ChkDR(DRM_E_LOGICERR);  /* this function does not support fake mode */
    }

    /* parse length of node name */

    ChkDR(_GetPushedDWORD(pContext, CWCH_DWORD_STACK, &wNodePos));
    
    while (pContext->XmlString [wNodePos + wLen] != g_wchSpace 
        && pContext->XmlString [wNodePos + wLen] != g_wchGreaterThan)
    {
        wLen++;
    }

    pdstrNodeName->pwszString = &pContext->XmlString[wNodePos];
    pdstrNodeName->cchString  = wLen;

ErrorExit:
    return dr;
}



DRM_RESULT DRM_API DRM_XMB_GetContextSize(
    IN  DRM_BYTE  *pbXmlContext,
    OUT DRM_DWORD *pcbXmlContext)
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;

    ChkArg( pbXmlContext  != NULL
         && pcbXmlContext != NULL 
         && pContext->fInited     );
   
    *pcbXmlContext = pContext->wSize;

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_XMB_AddAttribute(
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrAttrName,
    IN const DRM_CONST_STRING *pdstrAttrValue )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;
    DRM_DWORD    wReqSize = 0;
    DRM_DWORD    wOffset  = 0;
    DRM_DWORD    wDst     = 0;
    DRM_DWORD    wSrc     = 0;
    DRM_DWORD    i        = 0;
    DRM_CONST_STRING dstrAttrName  = EMPTY_DRM_STRING,
                     dstrAttrValue = EMPTY_DRM_STRING;

    ChkArg( pbXmlContext != NULL
         && pContext->fInited);
         
    ChkDRMString(pdstrAttrName);
    ChkDRMString(pdstrAttrValue);

    if ( (pContext->wNextOpenNodePos + ( pContext->fIsSimMode? 2 : 1 )) == pContext->wBuffSize )
    {
        ChkDR(DRM_E_NOMORE);    /* stack is empty */
    }

    /* make sure it's not blank */
    ChkArg(_AllTrim2(pdstrAttrName, &dstrAttrName));

    /* trim leading and trialing blanks, but blank attrib value is allowed */
    _AllTrim2(pdstrAttrValue, &dstrAttrValue);

    /* calculate the buffer size needed to insert the ' attr="value"' 4 = space + equal sign + "" */

    wReqSize = (dstrAttrName.cchString + dstrAttrValue.cchString + 4);

    if ( !pContext->fIsSimMode )
    {
        if ( (pContext->wNextStringPos + wReqSize) >= pContext->wNextOpenNodePos )
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* at this point, we've got the required buffer length,
        ** now parse for '>' start from the current node name */
        ChkDR(_GetPushedDWORD(pContext, CWCH_DWORD_STACK, &wOffset));
        
        while ( pContext->XmlString[wOffset] != g_wchGreaterThan )
        {
            wOffset++;
        }

        /* now, XmlString[wOffset] contains the '>' char, insert attr=value in there
        ** first, move everything, if any, from '>' to give space for the insertion 
        */
        wDst = pContext->wNextStringPos+wReqSize-1;
        wSrc = pContext->wNextStringPos-1;
        for (i=0; i<(pContext->wNextStringPos - wOffset); i++)
        {
            pContext->XmlString[wDst--] = pContext->XmlString[wSrc--];
        }

        /* now, insert it in there */
        wcsncpy(&pContext->XmlString[wOffset], g_dstrSpace.pwszString, g_dstrSpace.cchString);
        wOffset += 1;
        wcsncpy(&pContext->XmlString[wOffset], dstrAttrName.pwszString, dstrAttrName.cchString);
        wOffset += dstrAttrName.cchString;
        wcsncpy(&pContext->XmlString[wOffset], g_dstrEqualQuote.pwszString, g_dstrEqualQuote.cchString );
        wOffset += 2;
        wcsncpy(&pContext->XmlString[wOffset], dstrAttrValue.pwszString, dstrAttrValue.cchString);
        wOffset += dstrAttrValue.cchString;
        wcsncpy(&pContext->XmlString[wOffset], g_dstrQuote.pwszString, g_dstrQuote.cchString);
    }

    /* update next XML string position */
    pContext->wNextStringPos += wReqSize;

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_XMB_AddData(
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;
    DRM_DWORD wOffset = 0;
    DRM_DWORD wDst    = 0;
    DRM_DWORD wSrc    = 0;
    DRM_DWORD i       = 0;
    DRM_CONST_STRING dstrData = EMPTY_DRM_STRING;

    ChkArg( pbXmlContext != NULL
         && pContext->fInited    );
    ChkDRMString(pdstrData);

    if ( (pContext->wNextOpenNodePos + ( pContext->fIsSimMode? 2 : 1 )) == pContext->wBuffSize )
    {
        ChkDR(DRM_E_NOMORE);    /* stack is empty */
    }

    if ( !_AllTrim2(pdstrData, &dstrData) )     /* a blank string found */
    {
        goto ErrorExit;
    }

    if ( !pContext->fIsSimMode )
    {
        /* check if we have enough space */
        if ((pContext->wNextStringPos + dstrData.cchString) >= pContext->wNextOpenNodePos)
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* at this point, we've got the required buffer length,
        ** now parse for '>' start from the current node name */
        
        ChkDR(_GetPushedDWORD(pContext, CWCH_DWORD_STACK, &wOffset));

        while ( pContext->XmlString[wOffset] != g_wchGreaterThan )
        {
            wOffset++;
        }

        /* now, XmlString[wOffset] contains the '>' char, insert data after it.
        ** first, move everything, if any, after '>' to give space for the insertion 
        */
        wOffset += 1;

        wDst = pContext->wNextStringPos + dstrData.cchString - 1;
        wSrc = pContext->wNextStringPos-1;

        for (i=0; i<(pContext->wNextStringPos - wOffset); i++)
        {
            pContext->XmlString[wDst--] = pContext->XmlString[wSrc--];
        }

        /* now, insert it in there */
        wcsncpy(&pContext->XmlString[wOffset], dstrData.pwszString, dstrData.cchString);
    }

    /* update next XML string position */
    pContext->wNextStringPos += dstrData.cchString;

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_XMB_AddCData(
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrCData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    _XMBContext *pContext      = (_XMBContext*)pbXmlContext;
    DRM_DWORD wReqSize         = 0;
    DRM_DWORD wOffset          = 0;
    DRM_DWORD wDst             = 0;
    DRM_DWORD wSrc             = 0;
    DRM_DWORD i                = 0;
    DRM_CONST_STRING dstrCData = EMPTY_DRM_STRING;

    ChkArg( pbXmlContext != NULL
         && pContext->fInited    );
    ChkDRMString(pdstrCData);

    if ( (pContext->wNextOpenNodePos + ( pContext->fIsSimMode? 2 : 1 )) == pContext->wBuffSize )
    {
        ChkDR(DRM_E_NOMORE);    /* stack is empty */
    }

    /* trim leading and trialing blanks, but blank CDATA value is allowed */
    _AllTrim2(pdstrCData, &dstrCData);

    /* calculate the buffer size needed to insert <!<CDATA[xxx]]> */
    wReqSize = dstrCData.cchString + 12;

    if ( !pContext->fIsSimMode )
    {
        if ( (pContext->wNextStringPos + wReqSize) >= pContext->wNextOpenNodePos )
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        /* at this point, we've got the required buffer length,
        ** now parse for '>' start from the current node name */
        ChkDR(_GetPushedDWORD(pContext, CWCH_DWORD_STACK, &wOffset));
        
        while ( pContext->XmlString[wOffset] != g_wchGreaterThan )
        {
            wOffset++;
        }

        /* now, XmlString[wOffset] contains the '>' char, insert CDATA after it
        ** first, move everything, if any, after '>' to give space for the insertion 
        */
        wOffset += 1;
        wDst = pContext->wNextStringPos+wReqSize-1;
        wSrc = pContext->wNextStringPos-1;
        
        for (i = 0; i < (pContext->wNextStringPos - wOffset); i++)
        {
            pContext->XmlString[wDst--] = pContext->XmlString[wSrc--];
        }

        /* now, insert it in there */
        wcsncpy(&pContext->XmlString[wOffset], g_dstrOpenCDATATag.pwszString, g_dstrOpenCDATATag.cchString);
        wOffset += 9;
        wcsncpy(&pContext->XmlString[wOffset], dstrCData.pwszString, dstrCData.cchString);
        wOffset += dstrCData.cchString;
        wcsncpy(&pContext->XmlString[wOffset], g_dstrCloseCDATATag.pwszString, g_dstrCloseCDATATag.cchString);
    }

    /* update next XML string position */
    pContext->wNextStringPos += wReqSize;

ErrorExit:
    return dr;
}



DRM_RESULT DRM_API DRM_XMB_AppendNode(
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrXmlString)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrNode = EMPTY_DRM_STRING;
    _XMBContext *pContext = (_XMBContext*)pbXmlContext;

    ChkArg( pbXmlContext != NULL
         && pContext->fInited    );
    ChkDRMString( pdstrXmlString );

    /* open the root node */
    ChkArg(_AllTrim2(pdstrXmlString, &dstrNode));

    if (! pContext->fIsSimMode)
    {
        if ((pContext->wNextStringPos + dstrNode.cchString) >= pContext->wNextOpenNodePos)
        {
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

        wcsncpy(&pContext->XmlString [pContext->wNextStringPos], 
                 dstrNode.pwszString, 
                 dstrNode.cchString);
    }
    
    pContext->wNextStringPos += dstrNode.cchString;

ErrorExit:
    return dr;
}


DRM_DWORD DRM_API DRM_XMB_RequiredCharsForTag (
    IN const DRM_DWORD cchTag,
    IN const DRM_DWORD cchData,
    IN const DRM_DWORD cchAttrLabel,
    IN const DRM_DWORD cchAttrText)
{
    DRM_DWORD  cch = 0;

    cch = (cchTag * 2) +  5; /* <TAG></TAG> */
    
    cch += cchData;

    if (cchAttrLabel != 0)
    {
        cch += cchAttrLabel + 4;  /* two quotes, space and equal sign */
        cch += cchAttrText;
    }

    return cch;
}



DRM_RESULT DRM_API DRM_XMB_WriteTag (
    IN OUT       DRM_BYTE         *pbDataOut,
    IN     const DRM_CONST_STRING *pdstrTag,
    IN     const DRM_CONST_STRING *pdstrData,
    IN     const DRM_CONST_STRING *pdstrAttrLabel,
    IN     const DRM_CONST_STRING *pdstrAttrText,
    IN     enum  WriteTagType      wtt)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg(pbDataOut != NULL
        && pdstrTag  != NULL);

    ChkDR (DRM_XMB_OpenNode (pbDataOut, pdstrTag));

    if (pdstrAttrLabel != NULL
    &&  pdstrAttrText  != NULL)
    {
        ChkDR (DRM_XMB_AddAttribute (pbDataOut, pdstrAttrLabel, pdstrAttrText));
    }

    if (pdstrData != NULL)
    {
        ChkDR (DRM_XMB_AddData (pbDataOut, pdstrData));
    }
    
    if (wtt == wttClosed)
    {    
        ChkDR (DRM_XMB_CloseCurrNode (pbDataOut,  NULL));
    }

ErrorExit:    
    return dr;
} /* DRM_XMB_WriteTag */

DRM_RESULT DRM_API DRM_XMB_WriteCDATATag (
    IN OUT       DRM_BYTE         *pbDataOut,
    IN     const DRM_CONST_STRING *pdstrTag,
    IN     const DRM_CONST_STRING *pdstrCDATA,
    IN     const DRM_CONST_STRING *pdstrAttrLabel,
    IN     const DRM_CONST_STRING *pdstrAttrText,
    IN     enum  WriteTagType      wtt)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg (pbDataOut  != NULL
        &&  pdstrTag   != NULL
        &&  pdstrCDATA != NULL);

    ChkDR (DRM_XMB_OpenNode (pbDataOut, pdstrTag));

    if (pdstrAttrLabel != NULL
    &&  pdstrAttrText  != NULL)
    {
        ChkDR (DRM_XMB_AddAttribute (pbDataOut, pdstrAttrLabel, pdstrAttrText));
    }

    ChkDR (DRM_XMB_AddCData (pbDataOut, pdstrCDATA));
    
    if (wtt == wttClosed)
    {    
        ChkDR (DRM_XMB_CloseCurrNode (pbDataOut,  NULL));
    }

ErrorExit:    
    return dr;
} /* DRM_XMB_WriteCDATATag */

DRM_RESULT DRM_API DRM_XMB_RemainingBuffer(
    IN  DRM_BYTE  *f_pbXMB,
    OUT DRM_DWORD *f_pcbRemaining)
{
    _XMBContext *pcontext = (_XMBContext *) f_pbXMB;
    DRM_RESULT   dr       = DRM_SUCCESS;
    
    ChkArg(f_pbXMB        != NULL
        && f_pcbRemaining != NULL);
    
    ChkBOOL((pcontext->wNextStringPos + CWCH_DWORD_STACK) < pcontext->wNextOpenNodePos, DRM_E_BUFFERTOOSMALL);
    
    *f_pcbRemaining = (pcontext->wNextOpenNodePos - (pcontext->wNextStringPos + CWCH_DWORD_STACK));

ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmxmlparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmxmlparser.h>
#include <drmcrt.h>
#include <drmbase64.h>
#include <drmutilities.h>
#include <drmcipher.h>

/*
***********************************************************************
** types used within this file
***********************************************************************
*/

typedef enum {
    eTagNone = 0,
    eOpenTag = 1,     /* <tag ...> */
    eCloseTag,      /* </tag> */
    eEmptyTag,      /* <tag ... /> */
    eCDataSection,  /* <![CDATA[...]]> */
}  _ETAGTYPE;


typedef struct _tag_XMLTAG 
{
    _ETAGTYPE       m_eTagType;  
    DRM_SUBSTRING   m_dasstrTag;
    DRM_SUBSTRING   m_dasstrAttrName;
    DRM_SUBSTRING   m_dasstrAttrValue;
    DRM_SUBSTRING   m_dasstrCData;
    DRM_DWORD       m_ichTagBegin; /* index of '<' */
    DRM_DWORD       m_ichTagEnd;   /* index of '>' */
}  _XMLTAGA;

typedef struct _tag_XMLTAGW
{
    _ETAGTYPE        m_eTagType;  /*fCloseTag; */
    const DRM_WCHAR *m_pwszBase;
    DRM_SUBSTRING    m_dasstrTag;
    DRM_SUBSTRING    m_dasstrAttrName;
    DRM_SUBSTRING    m_dasstrAttrValue;
    DRM_SUBSTRING    m_dasstrCData;
    DRM_DWORD        m_ichTagBegin;     /* index of '<' */
    DRM_DWORD        m_ichTagEnd;  /* index of '>' */
}  _XMLTAGW;

#define SCAN_FOR(condition)  \
{                            \
    while (ichCurr != ichEnd \
       && !(condition))      \
    {                        \
        ichCurr++;           \
    }                        \
    if (ichCurr >= ichEnd)   \
    {                        \
        break;               \
    }                        \
}

#define SCAN_WHILE(condition) \
{                             \
    while(ichCurr != ichEnd   \
       && (condition))        \
    {                         \
        if (++ichCurr >= ichEnd) \
        {                        \
            break;               \
        }                        \
    }                        \
}

#define NEXT_CHAR            \
{                            \
    if (++ichCurr >= ichEnd) \
    {                        \
        break;               \
    }                        \
}    

#define SKIP_SPACEW           \
{                             \
    while (ichCurr < ichEnd   \
       &&  _IsSpaceW(pwszBase[ichCurr]))\
    {                         \
        ichCurr++;            \
    }                         \
    if (ichCurr >= ichEnd)    \
    {                         \
        break;                \
    }                         \
}

#define SKIP_SPACEA           \
{                             \
    while (ichCurr < ichEnd   \
       &&  _IsSpaceA(GET_CHAR(f_pszBase,ichCurr)))\
    {                         \
        ichCurr++;            \
    }                         \
    if (ichCurr >= ichEnd)    \
    {                         \
        break;                \
    }                         \
}

/*
***********************************************************************
** static functions
***********************************************************************
*/

/*
**
*/
#define _IsAlphaNumW(f_wch) (iswalpha(f_wch) || iswdigit(f_wch))

#define _IsAlphaNumA(f_ch) ( (f_ch >= '0' && f_ch <= '9')        \
                          || (f_ch >= 'a' && f_ch <= 'z')        \
                          || (f_ch >= 'A' && f_ch <= 'Z'))

#define _IsSymbolW(f_wch) ( _IsAlphaNumW(f_wch)                  \
                         || f_wch == g_wchUnderscore             \
                         || f_wch == g_wchColon                  \
                         || f_wch == g_wchMinus                  \
                         || f_wch == g_wchPeriod )

#define _IsSymbolA(f_ch) ( _IsAlphaNumA(f_ch)                    \
                        || f_ch == '_'                           \
                        || f_ch == ':'                           \
                        || f_ch == '-'                           \
                        || f_ch == '.' )

#define _IsSpaceW(f_wch) ( f_wch > 0           && ( NATIVE_WCHAR(f_wch) < NATIVE_WCHAR (g_wchExclamationMark) ) )
#define _IsSpaceA(f_ch)  ( f_ch > 0            && f_ch < '!' )
#define _IsQuoteW(f_wch) ( f_wch == g_wchQuote || f_wch == g_wchSingleQuote )
#define _IsQuoteA(f_ch)  ( f_ch == '\''        || f_ch == '\"' )



DRMFORCEINLINE DRM_RESULT _TranslateXMLError(DRM_RESULT f_drXML)
{
    DRM_RESULT dr = f_drXML;

    switch (f_drXML)
    {
    case DRM_E_NOXMLOPENTAG:
        dr = DRM_E_XMLNOTFOUND;
        break;

    default:
        dr = f_drXML;
        break;
    }

    return dr;
}


/*
** Trim all leading and trailing blanks in given string 
** return TRUE if resulting string length > 0
*/

static DRM_BOOL _AllTrimW(IN OUT DRM_CONST_STRING *f_pdstr)
{
    DRM_BOOL fOK = FALSE;
    
    if (f_pdstr == NULL)
    {
        goto ErrorExit;
    }
    
    /* trim space in node data, if any */
    while (f_pdstr->cchString > 0
        && _IsSpaceW(f_pdstr->pwszString [0]))
    {
        f_pdstr->pwszString++;
        f_pdstr->cchString--;
    }

    while (f_pdstr->cchString > 0
        && _IsSpaceW(f_pdstr->pwszString [f_pdstr->cchString - 1]))
    {
        f_pdstr->cchString--;
    }

    fOK = f_pdstr->cchString > 0;

ErrorExit:
    return fOK;
}

static DRM_BOOL _AllTrimA(
    IN     const DRM_CHAR *f_pszBase,
    IN OUT DRM_SUBSTRING  *f_pdasstr)
{
    DRM_BOOL fOK = FALSE;

    if (f_pszBase == NULL
     || f_pdasstr == NULL)
    {
        goto ErrorExit;
    }
    
    /* trim space in node data, if any */
    while (_IsSpaceA(GET_CHAR(f_pszBase, f_pdasstr->m_ich)))
    {
        f_pdasstr->m_ich++;
        f_pdasstr->m_cch--;
    }

    while (f_pdasstr->m_cch > 0 
       &&  _IsSpaceA(GET_CHAR(f_pszBase, (f_pdasstr->m_ich + f_pdasstr->m_cch - 1))))
    {
        f_pdasstr->m_cch--;
    }

    fOK = (f_pdasstr->m_cch > 0);

ErrorExit:
    return fOK;
}


/*
**
*/
static DRM_BOOL _ScanTagW(
    IN const DRM_CONST_STRING *f_pdstrXML, 
    IN OUT   DRM_DWORD        *f_pichCurr, 
       OUT   _XMLTAGW         *f_ptagParsed)
{
    const DRM_WCHAR *pwszBase =  f_pdstrXML->pwszString;
    DRM_DWORD        ichCurr  = *f_pichCurr;
    DRM_DWORD        ichEnd   =  f_pdstrXML->cchString;
    DRM_BOOL         fParsedOkay = FALSE;
    DRM_DWORD        ichOpenTag  = 0;
    
#if DBG
    /* init return value */
    ZEROMEM(f_ptagParsed, SIZEOF(_XMLTAGW));
#endif

    f_ptagParsed->m_pwszBase = pwszBase;    
    f_ptagParsed->m_eTagType = eTagNone;
    
    while (ichCurr < ichEnd)
    {
        /* search for next element */

        SCAN_FOR(pwszBase [ichCurr] == g_wchLessThan);   /*Find the next '<' */

        if (pwszBase [ichCurr] != g_wchLessThan)
        {
            continue;
        }
        
        ichOpenTag = ichCurr;
        NEXT_CHAR;

        /* 
        ** ------------------------------------------------------------------ 
        ** parse the CLOSE TAG
        ** ------------------------------------------------------------------ 
        */
        if (pwszBase [ichCurr] == g_wchForwardSlash)    /* '</...' */
        {
            NEXT_CHAR;
            if (_IsSymbolW(pwszBase [ichCurr]))     /* '</#...' */
            {
                f_ptagParsed->m_eTagType = eCloseTag;   /* indicates this is a close tag */
                goto PARSE_TAG;   /* parse the tag name */
            }
            
            /* Bad </...>, ignore the TAG and continue */
            SCAN_FOR(pwszBase [ichCurr] == g_wchGreaterThan);    /* Look for '>' */
            NEXT_CHAR;
            continue;
        }

		/* 
		** ------------------------------------------------------------------ 
		** parse the Process Instruction: ignore the TAG and continue
		** ------------------------------------------------------------------ 
		*/
		else if (pwszBase [ichCurr] == g_wchQuestionMark)    /* '<?...' */
        {
            NEXT_CHAR;
            /* we do not support PI tag, ignore it and continue */
            SCAN_FOR(pwszBase [ichCurr] == g_wchGreaterThan);    /* Look for '>' */
            NEXT_CHAR;
            continue;
		}

		/* 
		** ------------------------------------------------------------------ 
		** parse the Special TAG, ignore and continue
		** ------------------------------------------------------------------ 
		*/
		else if (pwszBase [ichCurr] == g_wchExclamationMark)     /* '<!...' */
        {
            NEXT_CHAR;
            if (pwszBase [ichCurr] == g_wchMinus)     /* '<!-...' */
            {
                NEXT_CHAR;
                /* we do not support comment, ignore it and continue */
                while  (ichCurr < ichEnd)
                {
                    /* Look for terminating '-->' */
                    
                    if (pwszBase [ichCurr]     == g_wchMinus
                    &&  pwszBase [ichCurr + 1] == g_wchMinus
                    &&  pwszBase [ichCurr + 2] == g_wchGreaterThan)
                    {
                        break;
                    }           
        
                    ichCurr++;    
                }

                NEXT_CHAR;
                continue;
            }
            
            /* '<![...' */
            
            else if (pwszBase [ichCurr] == g_wchLeftBracket)    
            {
                NEXT_CHAR;

                /* Parsing CDATA section */

                if ((ichCurr + 6) >= ichEnd  
                ||  (wcsncmp((DRM_WCHAR *) (pwszBase + ichCurr), 
                             g_dstrTagCDATAOpenBracket.pwszString, 
                             g_dstrTagCDATAOpenBracket.cchString) != 0))
                {   
                    /* not CDATA section, ignore it */
                    while ((ichCurr + 2) < ichEnd)
                    {
                        /*Scan for terminating ']]>' */
                        
                        if (pwszBase [ichCurr]     == g_wchRightBracket
                        &&  pwszBase [ichCurr + 1] == g_wchRightBracket
                        &&  pwszBase [ichCurr + 2] == g_wchGreaterThan)
                        {
                            break;
                        }

                        ichCurr++;
                    }
                }
                else
                {
                    /* CDATA section found */

                    f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
                    f_ptagParsed->m_dasstrTag.m_cch = 5;

                    ichCurr += 6;
                    
                    f_ptagParsed->m_dasstrCData.m_ich = ichCurr;
                    f_ptagParsed->m_dasstrCData.m_cch = 0;
                    
                    while ((ichCurr + 2) < ichEnd)
                    {
                        /*Scan for terminating ']]>' */
                    
                        if (pwszBase [ichCurr]     == g_wchRightBracket
                        &&  pwszBase [ichCurr + 1] == g_wchRightBracket
                        &&  pwszBase [ichCurr + 2] == g_wchGreaterThan)
                        {
                            break;
                        }

                        f_ptagParsed->m_dasstrCData.m_cch++;
                        ichCurr++;  
                    }
                    
                    if ((ichCurr + 2) < ichEnd)
                    {
                        f_ptagParsed->m_eTagType    = eCDataSection;
                        f_ptagParsed->m_ichTagBegin = ichOpenTag;
                        
                        ichCurr += 2;
                        
                        f_ptagParsed->m_ichTagEnd = ichCurr;
                        fParsedOkay               = TRUE;
                        break;
                    }
                    
                    ichCurr += 2;
                }
                NEXT_CHAR;
                continue;
            }
            
            else if (_IsSymbolW(pwszBase [ichCurr]))  /* An inline DTD tag. */
            {
                NEXT_CHAR;
                /* we do not support inline DTD tag, ignore it and continue */
                SCAN_FOR(pwszBase [ichCurr] == g_wchGreaterThan);    /* Look for '>' */
                NEXT_CHAR;
                continue;
			}
		}


		/* 
		** ------------------------------------------------------------------ 
		** parse the contents of a TAG
		** note: we only support this format: <tag attr=value>, attr and value is optional.
		** ------------------------------------------------------------------ 
		*/
		else if (_IsSymbolW(pwszBase [ichCurr]))  /* '<#...' */
		{
PARSE_TAG:   
            /* Scan for tag name. */
            f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
            
            SCAN_WHILE(_IsSymbolW(pwszBase [ichCurr]));    /* Scan for a terminator. */

            f_ptagParsed->m_dasstrTag.m_cch = ichCurr - f_ptagParsed->m_dasstrTag.m_ich;

            /* at this point, we've got the tag name */
            
            SKIP_SPACEW;   /* skip any whitespace and parse attr name. */

            if (_IsSymbolW(pwszBase [ichCurr]))  /* <... #... */
            {
                /* parse the attribute name */

                f_ptagParsed->m_dasstrAttrName.m_ich = ichCurr;
                
                /* Scan for a terminator. */
                
                SCAN_WHILE(_IsSymbolW(pwszBase [ichCurr]));    
                
                f_ptagParsed->m_dasstrAttrName.m_cch = (ichCurr - f_ptagParsed->m_dasstrAttrName.m_ich);

                /* at this point, we've got the attribute name */
                SKIP_SPACEW;   /* skip any whitespace and parse attr value. */

                if (pwszBase [ichCurr] == g_wchEqual)    /* '<... #=...' */
                {
                    /* parse the attribute value */
                    NEXT_CHAR;     /* skip the equal sign */
                    SKIP_SPACEW;    /* skip any whitespace. */
                    
                    if (_IsQuoteW(pwszBase [ichCurr]))     /* '<... #="...' */
                    {
                        DRM_WCHAR wchQuote = pwszBase [ichCurr];    /* Save quote char to avoid breaking on " ' ' " -or- ' " " '. */

                        NEXT_CHAR;    /* Step over the quote. */

                        f_ptagParsed->m_dasstrAttrValue.m_ich = ichCurr;

                        SCAN_FOR((pwszBase [ichCurr] == wchQuote));  /* Scan for the terminating quote, or '>'. */
                        
                        f_ptagParsed->m_dasstrAttrValue.m_cch = ichCurr - f_ptagParsed->m_dasstrAttrValue.m_ich;

                        /* trim space in attribute value, if any */

                        while (f_ptagParsed->m_dasstrAttrValue.m_cch > 0
                           &&  _IsSpaceW(pwszBase [f_ptagParsed->m_dasstrAttrValue.m_ich + f_ptagParsed->m_dasstrAttrValue.m_cch - 1]))
                        {
                            f_ptagParsed->m_dasstrAttrValue.m_cch--;
                        }

                        /* at this point, we've got the attribute value */
                        /* note: we only support parsing the first attribute with value, the rest is ignored */
                        goto PARSE_TAGEND;
                    }
                }
            } /* end if _IsSymbolW(pwszBase [ichCurr] */
            
PARSE_TAGEND:

            if (f_ptagParsed->m_eTagType == eCloseTag)
            {
                SCAN_FOR(pwszBase [ichCurr] == g_wchGreaterThan);   
            }
            else
            {
                SCAN_FOR(pwszBase [ichCurr] == g_wchForwardSlash
                     ||  pwszBase [ichCurr] == g_wchGreaterThan);
                
                if (pwszBase [ichCurr] == g_wchForwardSlash)
                {
                    NEXT_CHAR;
                    SCAN_FOR(pwszBase [ichCurr] == g_wchGreaterThan);   

                    f_ptagParsed->m_eTagType = eEmptyTag;
                }
                else
                {
                    f_ptagParsed->m_eTagType = eOpenTag;  
                }
            }

            if (f_ptagParsed->m_eTagType == eTagNone)
            {
                f_ptagParsed->m_eTagType = eOpenTag;   
            }

            f_ptagParsed->m_ichTagBegin = ichOpenTag;
            f_ptagParsed->m_ichTagEnd   = ichCurr;

            fParsedOkay = TRUE;
            NEXT_CHAR;
            break;  /* that's it, we parsed a tag */
        }
    }

    if (fParsedOkay)
    {
        *f_pichCurr = ichCurr;
    }

    return fParsedOkay;
} /* _ScanTagW */

static DRM_BOOL _ScanTagA(
    IN const DRM_CHAR      *f_pszBase,
    IN const DRM_SUBSTRING *f_pdastrXML, 
    IN OUT   DRM_DWORD     *f_pichCurr, 
       OUT   _XMLTAGA      *f_ptagParsed)
{
    DRM_DWORD       ichEnd  =  f_pdastrXML->m_ich 
                            +  f_pdastrXML->m_cch;
    DRM_DWORD       ichCurr = *f_pichCurr;
    DRM_BOOL        fParsedOkay = FALSE;
    DRM_DWORD       ichOpenTag  = 0;

#if DBG
    /* init return value */
    ZEROMEM(f_ptagParsed, SIZEOF(_XMLTAGA));
#endif

    f_ptagParsed->m_eTagType = eTagNone;
    
    while (ichCurr < ichEnd)
    {
        /* search for next element */

        SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == '<');   /*Find the next '<' */

        if (GET_CHAR(f_pszBase, ichCurr) != '<')
        {
            continue;
        }
        
        ichOpenTag = ichCurr;
        NEXT_CHAR;

        /* 
        ** ------------------------------------------------------------------ 
        ** parse the CLOSE TAG
        ** ------------------------------------------------------------------ 
        */
        if (GET_CHAR(f_pszBase, ichCurr) == '/')    /* '</...' */
        {
            NEXT_CHAR;
            if (_IsSymbolA(GET_CHAR(f_pszBase, ichCurr)))     /* '</#...' */
            {
                f_ptagParsed->m_eTagType = eCloseTag;   /* indicates this is a close tag */
                goto PARSE_TAG;   /* parse the tag name */
            }
            
            /* Bad </...>, ignore the TAG and continue */
            SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == '>');    /* Look for '>' */
            NEXT_CHAR;
            continue;
        }

		/* 
		** ------------------------------------------------------------------ 
		** parse the Process Instruction: ignore the TAG and continue
		** ------------------------------------------------------------------ 
		*/
		else if (GET_CHAR(f_pszBase, ichCurr) == '?')    /* '<?...' */
        {
            NEXT_CHAR;
            /* we do not support PI tag, ignore it and continue */
            SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == '>');    /* Look for '>' */
            NEXT_CHAR;
            continue;
		}

		/* 
		** ------------------------------------------------------------------ 
		** parse the Special TAG, ignore and continue
		** ------------------------------------------------------------------ 
		*/
		else if (GET_CHAR(f_pszBase, ichCurr) == '!')     /* '<!...' */
        {
            NEXT_CHAR;
            if (GET_CHAR(f_pszBase, ichCurr) == '-')     /* '<!-...' */
            {
                NEXT_CHAR;
                /* we do not support comment, ignore it and continue */
                while  (ichCurr < ichEnd)
                {
                    /* Look for terminating '-->' */
                    
                    if (GET_CHAR(f_pszBase, ichCurr)     == '-'
                    &&  GET_CHAR(f_pszBase, ichCurr + 1) == '-'
                    &&  GET_CHAR(f_pszBase, ichCurr + 2) == '>')
                    {
                        break;
                    }           
        
                    ichCurr++;    
                }

                NEXT_CHAR;
                continue;
            }
            
            /* '<![...' */
            
            else if (GET_CHAR(f_pszBase, ichCurr) == '[')    
            {
                NEXT_CHAR;

                /* Parsing CDATA section */

                if ((ichCurr + 6) >= ichEnd  
                ||  (DRM_BYT_CompareBytes(f_pszBase, 
                                          ichCurr, 
                                          g_dastrTagCDATAOpenBracket.pszString, 
                                          0, 
                                          g_dastrTagCDATAOpenBracket.cchString) != 0))
                {   
                    /* not CDATA section, ignore it */
                    while ((ichCurr + 2) < ichEnd)
                    {
                        /*Scan for terminating ']]>' */
                        
                        if (GET_CHAR(f_pszBase, ichCurr)     == ']'
                        &&  GET_CHAR(f_pszBase, ichCurr + 1) == ']'
                        &&  GET_CHAR(f_pszBase, ichCurr + 2) == '>')
                        {
                            break;
                        }

                        NEXT_CHAR;
                   }
                }

                /* CDATA section found */

                else
                {
                    f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
                    f_ptagParsed->m_dasstrTag.m_cch = 5;

                    ichCurr += 6;
                    
                    f_ptagParsed->m_dasstrCData.m_ich = ichCurr;
                    f_ptagParsed->m_dasstrCData.m_cch = 0;
                    
                    while ((ichCurr + 2) < ichEnd)
                    {
                        /*Scan for terminating ']]>' */
                    
                        if (GET_CHAR(f_pszBase, ichCurr)     == ']'
                        &&  GET_CHAR(f_pszBase, ichCurr + 1) == ']'
                        &&  GET_CHAR(f_pszBase, ichCurr + 2) == '>')
                        {
                            break;
                        }

                        f_ptagParsed->m_dasstrCData.m_cch++;
                        NEXT_CHAR;
                    }
                    
                    if ((ichCurr + 2) < ichEnd)
                    {
                        f_ptagParsed->m_eTagType    = eCDataSection;
                        f_ptagParsed->m_ichTagBegin = ichOpenTag;
                        
                        ichCurr += 2;
                        
                        f_ptagParsed->m_ichTagEnd = ichCurr;
                        fParsedOkay               = TRUE;
                        break;
                    }
                    
                    ichCurr += 2;
                }
                NEXT_CHAR;
                continue;
            }
            
            else if (_IsSymbolA(GET_CHAR(f_pszBase, ichCurr)))  /* An inline DTD tag. */
            {
                NEXT_CHAR;
                /* we do not support inline DTD tag, ignore it and continue */
                SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == '>');    /* Look for '>' */
                NEXT_CHAR;
                continue;
			}
		}


		/* 
		** ------------------------------------------------------------------ 
		** parse the contents of a TAG
		** note: we only support this format: <tag attr=value>, attr and value is optional.
		** ------------------------------------------------------------------ 
		*/
		else if (_IsSymbolA(GET_CHAR(f_pszBase, ichCurr)))  /* '<#...' */
		{
            DRM_BOOL    fParsedAttr = FALSE;
PARSE_TAG:   
            /* Scan for tag name. */
            f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
            
            SCAN_WHILE(_IsSymbolA(GET_CHAR(f_pszBase, ichCurr)));    /* Scan for a terminator. */

            f_ptagParsed->m_dasstrTag.m_cch = ichCurr - f_ptagParsed->m_dasstrTag.m_ich;

            /* at this point, we've got the tag name */
PARSE_ATTR:
            SKIP_SPACEA;   /* skip any whitespace and parse attr name. */

            if (_IsSymbolA(GET_CHAR(f_pszBase, ichCurr)))  /* <... #... */
            {
                /* parse the attribute name */

                if( !fParsedAttr )
                {
                    f_ptagParsed->m_dasstrAttrName.m_ich = ichCurr;
                }
                
                /* Scan for a terminator. */
                
                SCAN_WHILE(_IsSymbolA(GET_CHAR(f_pszBase, ichCurr)));    
                
                if( !fParsedAttr )
                {
                    f_ptagParsed->m_dasstrAttrName.m_cch = (ichCurr - f_ptagParsed->m_dasstrAttrName.m_ich);
                }

                /* at this point, we've got the attribute name */
                SKIP_SPACEA;   /* skip any whitespace and parse attr value. */

                if (GET_CHAR(f_pszBase, ichCurr) == '=')    /* '<... #=...' */
                {
                    /* parse the attribute value */
                    NEXT_CHAR;     /* skip the equal sign */
                    SKIP_SPACEA;    /* skip any whitespace. */
                    
                    if (_IsQuoteA(GET_CHAR(f_pszBase, ichCurr)))     /* '<... #="...' */
                    {
                        DRM_WCHAR wchQuote = GET_CHAR(f_pszBase, ichCurr);    /* Save quote char to avoid breaking on " ' ' " -or- ' " " '. */

                        NEXT_CHAR;    /* Step over the quote. */

                        if( !fParsedAttr )
                        {
                            f_ptagParsed->m_dasstrAttrValue.m_ich = ichCurr;
                        }

                        SCAN_FOR((GET_CHAR(f_pszBase, ichCurr) == wchQuote));  /* Scan for the terminating quote, or '>'. */
                        
                        if( !fParsedAttr )
                        {
                            f_ptagParsed->m_dasstrAttrValue.m_cch = (ichCurr - f_ptagParsed->m_dasstrAttrValue.m_ich);

                            /* trim space in attribute value, if any */

                            while (f_ptagParsed->m_dasstrAttrValue.m_cch > 0
                            &&  _IsSpaceA(GET_CHAR(f_pszBase, f_ptagParsed->m_dasstrAttrValue.m_ich + f_ptagParsed->m_dasstrAttrValue.m_cch - 1)))
                            {
                                f_ptagParsed->m_dasstrAttrValue.m_cch--;
                            }
                        }

                        /* at this point, we've got the attribute value */
                        /* note: we only support parsing the first attribute with value, the rest is ignored */
                        if (_IsQuoteA(GET_CHAR(f_pszBase, ichCurr)))
                        {
                            NEXT_CHAR;
                        }

                        /* We have to parse all the attributes, but we can only return one. 
                        *  To continue the expected behaviour of returning the first attribute
                        *  found (instead of the last), we need to keep track of whether 
                        *  we've already parsed an attrbitue
                        */

                        fParsedAttr = TRUE;
                        goto PARSE_ATTR;
                    }
                }
            } /* end if _IsSymbolA(GET_CHAR(f_pszBase, ichCurr) */

            if (f_ptagParsed->m_eTagType == eCloseTag)
            {
                SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == '>');   
            }
            else
            {
                SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == '/'
                     ||  GET_CHAR(f_pszBase, ichCurr) == '>');
                
                if (GET_CHAR(f_pszBase, ichCurr) == '/')
                {
                    NEXT_CHAR;
                    SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == '>');   

                    f_ptagParsed->m_eTagType = eEmptyTag;
                }
                else
                {
                    f_ptagParsed->m_eTagType = eOpenTag;  
                }
            }

            if (f_ptagParsed->m_eTagType == eTagNone)
            {
                f_ptagParsed->m_eTagType = eOpenTag;   
            }

            f_ptagParsed->m_ichTagBegin = ichOpenTag;
            f_ptagParsed->m_ichTagEnd   = ichCurr;

            fParsedOkay = TRUE;
            NEXT_CHAR;
            break;  /* that's it, we parsed a tag */
        }
    }

    if (fParsedOkay)
    {
        *f_pichCurr = ichCurr;
    }

    return fParsedOkay;
} /* _ScanTagA */


/*
** ----------------------------------------------------------------------------
** 
** ----------------------------------------------------------------------------
*/
static DRM_BOOL _ScanNodeForAttributeW(
    IN const DRM_CONST_STRING *f_pdstrNode,  /* node */
    IN const DRM_CONST_STRING *f_pdstrAttr,  /* Attribute name to search in the topmost node */
    OUT      _XMLTAGW         *f_ptagParsed)
{
    const DRM_WCHAR *pwszBase    = f_pdstrNode->pwszString;
    DRM_DWORD        ichEnd      = f_pdstrNode->cchString;
    DRM_DWORD        ichCurr     = 0;
    DRM_BOOL         fParsedOkay = FALSE;
    DRM_CONST_STRING dstrAttr    = EMPTY_DRM_STRING;

#if DBG
    /* init return value */
    ZEROMEM(f_ptagParsed, SIZEOF(_XMLTAGW));
#endif

    while (TRUE)
    {
        SCAN_FOR(pwszBase [ichCurr] == g_wchLessThan);   /*Find the next '<' */

        if (pwszBase [ichCurr] != g_wchLessThan)
        {
            goto ErrorExit;   /* cannot find  '<'  */
        }
        
        NEXT_CHAR;

        /* 
        ** ------------------------------------------------------------------ 
        ** parse the contents of a TAG
        ** note: we only support this format: <tag attr=value>, attr and value is optional.
        ** ------------------------------------------------------------------ 
        */
        if (! _IsSymbolW(pwszBase [ichCurr]))  /* '<#...' */
        {
            goto ErrorExit;  /* cannot find an element tag */
        }
        
        /* Scan for tag name. */

        f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
        
        /* Scan for a terminator. */
        
        SCAN_WHILE(_IsSymbolW(pwszBase [ichCurr]));    
        
        f_ptagParsed->m_dasstrTag.m_cch = ichCurr - f_ptagParsed->m_dasstrTag.m_ich;

        /* at this point, we've got the tag name */
        SKIP_SPACEW;   /* skip any whitespace and parse attr name. */
        
        if (_IsSymbolW(pwszBase [ichCurr]))  /* <... #... */
        {
PARSE_ATTR:
            /* parse the attribute name */
            f_ptagParsed->m_dasstrAttrName.m_ich = ichCurr;
            
            SCAN_WHILE(_IsSymbolW(pwszBase [ichCurr]));    /* Scan for a terminator. */
            
            f_ptagParsed->m_dasstrAttrName.m_cch = (ichCurr - f_ptagParsed->m_dasstrAttrName.m_ich);

            /* at this point, we've got the attribute name */
            SKIP_SPACEW;   /* skip any whitespace and parse attr value. */
            
            if (pwszBase [ichCurr] == g_wchEqual)    /* '<... #=...' */
            {
                /* parse the attribute value */
                NEXT_CHAR;     /* skip the equal sign */
                SKIP_SPACEW;   /* skip any whitespace. */
                if (_IsQuoteW(pwszBase [ichCurr]))     /* '<... #="...' */
                {
                    DRM_WCHAR wchQuote = pwszBase [ichCurr];    /* Save quote char to avoid breaking on " ' ' " -or- ' " " '. */
                    
                    NEXT_CHAR;    /* Step over the quote. */
                    
                    f_ptagParsed->m_dasstrAttrValue.m_ich = ichCurr;
                    
                    SCAN_FOR(pwszBase [ichCurr] == wchQuote);  /* Scan for the terminating quote, or '>'. */
                    
                    f_ptagParsed->m_dasstrAttrValue.m_cch = (ichCurr - f_ptagParsed->m_dasstrAttrValue.m_ich);

                    NEXT_CHAR;

                    /* trim space in attribute value, if any */
                    while (f_ptagParsed->m_dasstrAttrValue.m_cch > 0 
                       &&  _IsSpaceW(pwszBase [f_ptagParsed->m_dasstrAttrValue.m_ich 
                                             + f_ptagParsed->m_dasstrAttrValue.m_cch 
                                             - 1]))
                    {
                        f_ptagParsed->m_dasstrAttrValue.m_cch--;                       
                    }
                }
            }

            dstrAttr.pwszString = pwszBase + f_ptagParsed->m_dasstrAttrName.m_ich;
            dstrAttr.cchString  =            f_ptagParsed->m_dasstrAttrName.m_cch;
            
            /* check if this is the attr we want */
            if (DRM_UTL_DSTRStringsEqual(&dstrAttr, f_pdstrAttr))
            {
                /* Scan for '>' to make sure this is a legal tag */
                
                SCAN_FOR(pwszBase [ichCurr] == g_wchGreaterThan);   

                fParsedOkay=TRUE;

                f_ptagParsed->m_ichTagBegin = 0;
                f_ptagParsed->m_ichTagEnd   = 0;
                f_ptagParsed->m_eTagType    = eOpenTag;
                goto ErrorExit;		/* we found it */
            }
            else
            {
                SKIP_SPACEW;   /* skip any whitespace and parse attr value. */

                if (_IsAlphaNumW(pwszBase [ichCurr]))
                {
                    goto PARSE_ATTR;	/* keep going */
                }
            }
        } /* end if is alnum */
        
        break;  /* that'pwszBase it */
    }

ErrorExit:
    return fParsedOkay;
}

static DRM_BOOL _ScanNodeForAttributeA(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdastrNode,  /* string that contains a node */
    IN const DRM_ANSI_CONST_STRING *f_pdastrAttrName,  /* Attribute name to search in the topmost node */
    OUT      _XMLTAGA              *f_ptagParsed)
{
    DRM_DWORD ichEnd      = f_pdastrNode->m_ich 
                          + f_pdastrNode->m_cch;
    DRM_DWORD ichCurr     = f_pdastrNode->m_ich;
    DRM_BOOL  fParsedOkay = FALSE;

#if DBG
    /* init return value */
    ZEROMEM(f_ptagParsed, SIZEOF(_XMLTAGA));
#endif
    
    while (TRUE)
    {
        SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == '<');   /*Find the next '<' */

        if (GET_CHAR(f_pszBase, ichCurr) != '<')
        {
            goto ErrorExit;   /* cannot find  '<'  */
        }
        
        NEXT_CHAR;

        /* 
        ** ------------------------------------------------------------------ 
        ** parse the contents of a TAG
        ** note: we only support this format: <tag attr=value>, attr and value is optional.
        ** ------------------------------------------------------------------ 
        */
        if (! _IsSymbolA(GET_CHAR(f_pszBase, ichCurr)))  /* '<#...' */
        {
            goto ErrorExit;  /* cannot find an element tag */
        }
        
        /* Scan for tag name. */

        f_ptagParsed->m_dasstrTag.m_ich = ichCurr;
        
        /* Scan for a terminator. */
        
        SCAN_WHILE(_IsSymbolA(GET_CHAR(f_pszBase, ichCurr)));    
        
        f_ptagParsed->m_dasstrTag.m_cch = ichCurr - f_ptagParsed->m_dasstrTag.m_ich;

        /* at this point, we've got the tag name */
        SKIP_SPACEA;   /* skip any whitespace and parse attr name. */
        
        if (_IsSymbolA(GET_CHAR(f_pszBase, ichCurr)))  /* <... #... */
        {
PARSE_ATTR:
            /* parse the attribute name */
            f_ptagParsed->m_dasstrAttrName.m_ich = ichCurr;
            
            SCAN_WHILE(_IsSymbolA(GET_CHAR(f_pszBase, ichCurr)));    /* Scan for a terminator. */
            
            f_ptagParsed->m_dasstrAttrName.m_cch = (ichCurr - f_ptagParsed->m_dasstrAttrName.m_ich);

            /* at this point, we've got the attribute name */
            SKIP_SPACEA;   /* skip any whitespace and parse attr value. */
            
            if (GET_CHAR(f_pszBase, ichCurr) == '=')    /* '<... #=...' */
            {
                /* parse the attribute value */
                NEXT_CHAR;     /* skip the equal sign */
                SKIP_SPACEA;   /* skip any whitespace. */
                if (_IsQuoteA(GET_CHAR(f_pszBase, ichCurr)))     /* '<... #="...' */
                {
                    DRM_CHAR chQuote = GET_CHAR(f_pszBase, ichCurr);    /* Save quote char to avoid breaking on " ' ' " -or- ' " " '. */
                    
                    NEXT_CHAR;    /* Step over the quote. */
                    
                    f_ptagParsed->m_dasstrAttrValue.m_ich = ichCurr;
                    
                    SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == chQuote);  /* Scan for the terminating quote, or '>'. */
                    
                    f_ptagParsed->m_dasstrAttrValue.m_cch = (ichCurr - f_ptagParsed->m_dasstrAttrValue.m_ich);

                    NEXT_CHAR;

                    /* trim space in attribute value, if any */
                    while (f_ptagParsed->m_dasstrAttrValue.m_cch > 0 
                       &&  _IsSpaceA(GET_CHAR(f_pszBase, f_ptagParsed->m_dasstrAttrValue.m_cch - 1)))
                    {
                        f_ptagParsed->m_dasstrAttrValue.m_cch--;                       
                    }
                }
            }

            /* check if this is the attr we want */
            if (DRM_UTL_DASSTRStringsEqual(f_pszBase, &f_ptagParsed->m_dasstrAttrName, f_pdastrAttrName))
            {
                /* Scan for '>' to make sure this is a legal tag */
                
                SCAN_FOR(GET_CHAR(f_pszBase, ichCurr) == '>');   

                fParsedOkay=TRUE;

                f_ptagParsed->m_ichTagBegin = 0;
                f_ptagParsed->m_ichTagEnd   = 0;
                f_ptagParsed->m_eTagType    = eOpenTag;
                goto ErrorExit;		/* we found it */
            }
            else
            {
                SKIP_SPACEA;   /* skip any whitespace and parse attr value. */

                if (_IsAlphaNumA(GET_CHAR(f_pszBase, ichCurr)))
                {
                    goto PARSE_ATTR;	/* keep going */
                }
            }
        } /* end if is alnum */
        
        break;  /* that'f_pszBase it */
    }

ErrorExit:
    return fParsedOkay;
}

/*
** check Tag
*/
static _ETAGTYPE _CheckTagW(
    IN       _XMLTAGW         *f_ptagParsed, 
    IN const DRM_CONST_STRING *f_pdstrTag,
    IN const DRM_CONST_STRING *f_pdstrAttrName,
    IN const DRM_CONST_STRING *f_pdstrAttrValue)
{
    const DRM_WCHAR *pwszBase = f_ptagParsed->m_pwszBase;
    DRM_BOOL   fWork          = FALSE;
    _ETAGTYPE  eStatus        = eTagNone;
    DRM_CONST_STRING dstrTag  = EMPTY_DRM_STRING;

    dstrTag.cchString  =            f_ptagParsed->m_dasstrTag.m_cch;
    dstrTag.pwszString = pwszBase + f_ptagParsed->m_dasstrTag.m_ich;
    
    fWork = f_pdstrTag->cchString  == 0 
         || f_pdstrTag->pwszString == NULL;
         
    fWork = fWork || DRM_UTL_DSTRStringsEqual(f_pdstrTag, &dstrTag);

    if (fWork)
    {
        DRM_CONST_STRING dstrAttrParsed = EMPTY_DRM_STRING;
        
        dstrAttrParsed.cchString  =             f_ptagParsed->m_dasstrAttrName.m_cch;
        dstrAttrParsed.pwszString = pwszBase + f_ptagParsed->m_dasstrAttrName.m_ich;

        if (f_ptagParsed->m_eTagType == eCloseTag)
        {
            eStatus = eCloseTag;
        }

        /* attribute is ignored */
        else if (f_pdstrAttrName            == NULL 
             ||  f_pdstrAttrName->cchString == 0)
        {
            eStatus = f_ptagParsed->m_eTagType;
        }

        /* check the attribute and its value */
        else if (DRM_UTL_DSTRStringsEqual(&dstrAttrParsed, f_pdstrAttrName))
        {
            dstrAttrParsed.cchString  =             f_ptagParsed->m_dasstrAttrValue.m_cch;
            dstrAttrParsed.pwszString = pwszBase + f_ptagParsed->m_dasstrAttrValue.m_ich;

            if (DRM_UTL_DSTRStringsEqual(&dstrAttrParsed, f_pdstrAttrValue))
            {
                eStatus = f_ptagParsed->m_eTagType;
            }
        }
    }
    
    return eStatus;
} /* _CheckTagW */

static _ETAGTYPE _CheckTagA(
    IN const DRM_CHAR              *f_pszBase,
    IN       _XMLTAGA              *f_ptagParsed, 
    IN const DRM_CHAR              *f_pszBaseTag,
    IN const DRM_SUBSTRING         *f_pdasstrTag,
    IN const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    IN const DRM_ANSI_CONST_STRING *f_pdasstrAttrValue)
{
    DRM_BOOL  fWork    = FALSE;
    _ETAGTYPE eStatus  = eTagNone;
    
    fWork = f_pdasstrTag->m_cch == 0 
         || f_pszBaseTag        == NULL;
         
    fWork = (fWork 
          || DRM_UTL_DASSSTRStringsEqual(f_pszBase, 
                                        &f_ptagParsed->m_dasstrTag, 
                                         f_pszBaseTag,
                                         f_pdasstrTag));

    if (fWork)
    {
        if (f_ptagParsed->m_eTagType == eCloseTag)
        {
            eStatus = eCloseTag;
        }

        /* attribute is ignored */
        else if (f_pdastrAttrName            == NULL 
             ||  f_pdastrAttrName->cchString == 0)
        {
            eStatus = f_ptagParsed->m_eTagType;
        }

        /* check the attribute and its value */
        
        else if (DRM_UTL_DASSTRStringsEqual(f_pszBase, &f_ptagParsed->m_dasstrAttrName,   f_pdastrAttrName)
              && DRM_UTL_DASSTRStringsEqual(f_pszBase, &f_ptagParsed->m_dasstrAttrValue,  f_pdasstrAttrValue))
        {
                eStatus = f_ptagParsed->m_eTagType;
        }
    }
    
    return eStatus;
}

/**********************************************************************
** Function:    _GetXMLSubNodeW
** Synopsis:    
** Arguments:   
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _GetXMLSubNodeW(
    IN const DRM_CONST_STRING *f_pdstrXML,
    IN const DRM_CONST_STRING *f_pdstrTag,
    IN const DRM_CONST_STRING *f_pdstrAttrName,
    IN const DRM_CONST_STRING *f_pdstrAttrValue,
    IN const DRM_DWORD         f_iNode,             /* nth occurence of the node in the xml stirng, start from 0 */
    OUT      DRM_CONST_STRING *f_pdstrNodeOut,      /* these two parameters can either be NULL but not both */
    OUT      DRM_CONST_STRING *f_pdstrNodeDataOut,
    IN const DRM_DWORD         f_cLayersToSkip,
    IN       DRM_BOOL          f_fSkipValidation)
{
    DRM_RESULT dr      = DRM_E_NOXMLOPENTAG;
    DRM_DWORD  cNodes  = 0;
    DRM_DWORD  ichCurr = 0;
    DRM_DWORD  cTagsUnmatched   = 0;   
    DRM_DWORD  cTagsMatched     = 0; 
    DRM_DWORD  ichNodeBegin     = 0; 
    DRM_DWORD  ichNodeEnd       = 0; 
    DRM_DWORD  ichDataBegin     = 0; 
    DRM_DWORD  ichDataEnd       = 0;
    _ETAGTYPE  eStatus          = eTagNone;
    _XMLTAGW   xmltagW          = { 0 };    

    ChkDRMString(f_pdstrXML);
    ChkDRMString(f_pdstrTag);
    
    ChkArg(f_pdstrNodeOut     != NULL
        || f_pdstrNodeDataOut != NULL);

    while (TRUE)
    {
        /* scan for tag at currIndex */
        if (! _ScanTagW(f_pdstrXML, &ichCurr, &xmltagW))
        {
            if (cTagsMatched == 0)
            {
                ChkDR(DRM_E_NOXMLOPENTAG);
            }
            else
            {
                ChkDR(DRM_E_NOXMLCLOSETAG);
            }
        }

        /* check if we have a match to the node tag */
        if (cTagsUnmatched != f_cLayersToSkip)
        {
            if (xmltagW.m_eTagType == eOpenTag)
            {
                cTagsUnmatched++;
            }
            else if (xmltagW.m_eTagType == eCloseTag)
            {
                if (cTagsUnmatched > 0)
                {
                    cTagsUnmatched--;
                }
                else
                {
                    ChkDR(DRM_E_NOXMLOPENTAG);
                }
            }

            continue;
        }

        eStatus = _CheckTagW(&xmltagW, 
                              f_pdstrTag, 
                              f_pdstrAttrName, 
                              f_pdstrAttrValue);

        switch (eStatus)
        {
        case eOpenTag:     /* open tag found */
            /* this is the first matched open tag found. if cTagsMatched>0, it
            ** means the matched opend tag is nested.
            */
            if (cTagsMatched == 0) 
            {
                ichNodeBegin = xmltagW.m_ichTagBegin;
                ichDataBegin = xmltagW.m_ichTagEnd + 1;
                if (f_fSkipValidation && (cNodes == f_iNode) )
                {
                    ichNodeEnd = f_pdstrXML->cchString - 1;
                    ichDataEnd = f_pdstrXML->cchString - 1;
                    goto PREPARENODE;
                }                
            }
            cTagsMatched++;
            break;

        case eCloseTag:    /* close tag found */
            if (cTagsMatched == 0)
            {
                /* we get </tag> before we get <tag> */
                ChkDR(DRM_E_NOXMLOPENTAG);
            }
            cTagsMatched--;
            
            if (cTagsMatched == 0)  /* make sure it is not nested */
            {
                /* we've got the matching <tag> and </tag>, 
                ** exit the loop if this is the node we want
                */
                if (cNodes == f_iNode)
                {
                    ichNodeEnd = xmltagW.m_ichTagEnd;
                    ichDataEnd = xmltagW.m_ichTagBegin - 1;
                    goto PREPARENODE;
                }
                ichNodeBegin = 0;
                ichDataBegin = 0;
                cNodes++;
            }
            break;

        case eEmptyTag:
            if (cTagsMatched == 0)
            {
                /* we've got the matching <tag/>, 
                ** exit the loop if this is the node we want
                */
                if (cNodes == f_iNode)
                {
                    ichNodeBegin = xmltagW.m_ichTagBegin;
                    ichNodeEnd   = xmltagW.m_ichTagEnd;
                    ichDataBegin = 0;
                    ichDataEnd   = 0;
                    goto PREPARENODE;
                }
                ichNodeBegin = 0;
                cNodes++;
            }
            break;

        default:
            if (xmltagW.m_eTagType == eOpenTag)
            {
                cTagsUnmatched++;
            }
            else if (xmltagW.m_eTagType == eCloseTag)
            {
                if (cTagsUnmatched > f_cLayersToSkip)
                {
                    --cTagsUnmatched;
                }
                else
                {
                    /* end of 'f_cLayersToSkip' layers exits, the target tag is not found */
                    ChkDR(DRM_E_NOXMLOPENTAG);   
                }
            }
            break;
        }
    }

PREPARENODE:
    /* prepare f_pdstrNodeOut & f_pdstrNodeDataOut */
    if (f_pdstrNodeOut != NULL)
    {
        f_pdstrNodeOut->pwszString = f_pdstrXML->pwszString + ichNodeBegin;
        f_pdstrNodeOut->cchString  = (DRM_DWORD) (ichNodeEnd - ichNodeBegin + 1);
    }

    if (f_pdstrNodeDataOut != NULL)
    {
        if (eStatus == eEmptyTag)
        {
            f_pdstrNodeDataOut->pwszString = NULL;
            f_pdstrNodeDataOut->cchString  = 0;
        }
        else
        {
            f_pdstrNodeDataOut->pwszString = f_pdstrXML->pwszString + ichDataBegin;
            f_pdstrNodeDataOut->cchString = (DRM_DWORD) (ichDataEnd - ichDataBegin + 1);

            /* trim space in node data, if any */
            _AllTrimW(f_pdstrNodeDataOut);
        }
    }
    dr = DRM_SUCCESS;

ErrorExit:

    return dr;
} /* _GetXMLSubNodeW */

/**********************************************************************
** Function:    _GetXMLNodeCData
** Synopsis:    
** Arguments:   [pdwStamp] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/

static DRM_RESULT _GetXMLNodeCDataW(
    IN const DRM_CONST_STRING *f_pdstrNode,     /* the topmost node in this XML string will be worked on */
    OUT      DRM_CONST_STRING *f_pdstrCData)         /* returned CData */
{
    DRM_RESULT dr = DRM_E_NOXMLCDATA;
    DRM_BOOL      fOpenTagFound=FALSE;
    DRM_DWORD     ichCurr = 0;
    _XMLTAGW      xmltagW = { 0 };

    ChkDRMString(f_pdstrNode);
    
    ChkArg(f_pdstrCData != NULL);
    
    while (TRUE)
    {
        /* scan for tag at currIndex */
        if (!_ScanTagW(f_pdstrNode, &ichCurr, &xmltagW))  /* _ScanTagA failed */
        {
            if (! fOpenTagFound)
            {
                ChkDR(DRM_E_NOXMLOPENTAG);      /* open tag not found yet */
            }
            else
            {
                ChkDR(DRM_E_NOXMLCDATA);        /* could not find CDATA */
            }
        }

        switch (xmltagW.m_eTagType)
        {
            case eTagNone:
            case eCloseTag:
            case eEmptyTag:
                ChkDR(DRM_E_NOXMLCDATA);	/* could not find CDATA */

            case eOpenTag:
                if (fOpenTagFound)
                {
                    ChkDR(DRM_E_INVALIDXMLTAG); /* an open tag found already */
                }

                fOpenTagFound = TRUE;
                break;

            case eCDataSection:
                if (!fOpenTagFound)
                {
                    ChkDR(DRM_E_NOXMLOPENTAG); /* an open tag not found yet */
                }

                f_pdstrCData->cchString  =                           xmltagW.m_dasstrCData.m_cch;
                f_pdstrCData->pwszString = f_pdstrNode->pwszString + xmltagW.m_dasstrCData.m_ich;
                
                dr = (_AllTrimW(f_pdstrCData) 
                      ? DRM_SUCCESS
                      : DRM_E_NOXMLCDATA);

                goto ErrorExit;
        }
    }

ErrorExit:
    return dr;
} /* _GetXMLNodeCDataW */

/**********************************************************************
** Function:    _EnumXMLSubNode
** Synopsis:    Enum the next "sub" node from the given xml string. 
**              Caller can specify how many layer to skip. 
** Arguments:   
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _EnumXMLSubNodeW(
    IN const DRM_CONST_STRING *f_pdstrXML,
       OUT   DRM_CONST_STRING *f_pdstrTag,
       OUT   DRM_CONST_STRING *f_pdstrNode,         /* these two parameters can either be NULL but not both */
       OUT   DRM_CONST_STRING *f_pdstrNodeData,
       OUT   DRM_CONST_STRING *f_pdstr1stAttrName,  /* optional */
       OUT   DRM_CONST_STRING *f_pdstr1stAttrValue, /* optional */
       OUT   DRM_BOOL         *f_pfIsLeaf,          /* set to TRUE of the returned node is a leaf node */
    IN const DRM_DWORD         f_cLayers)
{
    DRM_RESULT dr = DRM_E_NOXMLOPENTAG;
    DRM_DWORD cTagsMatched   = 0; 
    DRM_DWORD     ichNodeBegin   = 0, 
                  ichDataBegin   = 0, 
                  ichNodeEnd     = 0, 
                  ichDataEnd     = 0, 
                  ichCurr        = 0;
    DRM_DWORD     cTagsUnmatched = 0;   /* increment until we find the matching tag */
    _ETAGTYPE     eStatus        = eTagNone;
    _XMLTAGW      xmltag         = { 0 };    
    DRM_CONST_STRING dstr1stAttrName  = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstr1stAttrValue = EMPTY_DRM_STRING;

    ChkDRMString(f_pdstrXML);
    ChkArg(f_pdstrTag != NULL);
    
    ChkArg(f_pfIsLeaf      != NULL);
    ChkArg(f_pdstrNode     != NULL
        || f_pdstrNodeData != NULL);

    *f_pfIsLeaf = TRUE;
    
    xmltag.m_pwszBase = f_pdstrXML->pwszString;
    
    while (TRUE)
    {
        /* scan for tag at currIndex */
        if (!_ScanTagW(f_pdstrXML, &ichCurr, &xmltag))
        {
            if (cTagsMatched == 0)
            {
                ChkDR(DRM_E_NOXMLOPENTAG);
            }
            else
            {
                ChkDR(DRM_E_NOXMLCLOSETAG);
            }
        }

        /* check if we are at the desired layer */
        if (cTagsUnmatched != f_cLayers)
        {
            if (xmltag.m_eTagType == eOpenTag)
            {
                cTagsUnmatched++;
            }
            else if (xmltag.m_eTagType == eCloseTag)
            {
                if (cTagsUnmatched>0)
                {
                    cTagsUnmatched--;
                }
                else
                {
                    ChkDR(DRM_E_NOXMLOPENTAG);
                }
            }

            continue;
        }

        /* we are at the layer that caller specified */
        eStatus = _CheckTagW(&xmltag, f_pdstrTag, NULL, NULL);

        switch (eStatus)
        {
            case eOpenTag:     /* open tag found */
                /* this is the first matched open tag found. if cTagsMatched>0, it
                ** means the matched opend tag is nested.
                */
                if (cTagsMatched == 0) 
                {
                    ichNodeBegin = xmltag.m_ichTagBegin;
                    ichDataBegin = xmltag.m_ichTagEnd+1;

                    /* assign the tag name so that we know what to look for closing tag */
                    f_pdstrTag->cchString  =                          xmltag.m_dasstrTag.m_cch;
                    f_pdstrTag->pwszString = f_pdstrXML->pwszString + xmltag.m_dasstrTag.m_ich;

                    /* save the attr name/value */
                    dstr1stAttrName.cchString  = xmltag.m_dasstrAttrName.m_cch;
                    dstr1stAttrName.pwszString = f_pdstrXML->pwszString 
                                               + xmltag.m_dasstrAttrName.m_ich;
                    dstr1stAttrValue.cchString  = xmltag.m_dasstrAttrValue.m_cch;
                    dstr1stAttrValue.pwszString = f_pdstrXML->pwszString 
                                                + xmltag.m_dasstrAttrValue.m_ich;
                }
                else if (*f_pfIsLeaf )  /* only do it once */
                {
                    *f_pfIsLeaf = FALSE;
                }
                cTagsMatched++;
                break;
                
            case eCloseTag:    /* close tag found */
                if (cTagsMatched == 0)
                {
                    /* we get </tag> before we get <tag> */
                    ChkDR(DRM_E_NOXMLOPENTAG);
                }
                cTagsMatched--;
                if (cTagsMatched == 0)  /* make sure it is not nested */
                {
                    /* we've got the matching <tag> and </tag>, 
                    ** exit the loop if this is the node we want
                    */
                    ichNodeEnd = xmltag.m_ichTagEnd;
                    ichDataEnd = xmltag.m_ichTagBegin - 1;
                    goto PREPARENODE;
                }
                break;

            case eEmptyTag:
                if (cTagsMatched == 0)
                {
                    /* we've got the matching <tag/>, 
                    ** exit the loop, this is the node we want
                    */
                    ichNodeBegin = xmltag.m_ichTagBegin;
                    ichDataBegin = 0;
                    ichNodeEnd   = xmltag.m_ichTagEnd;
                    ichDataEnd   = 0;

                    /* assign the tag name so that we know what to look for closing tag */
                    f_pdstrTag->cchString  =                          xmltag.m_dasstrTag.m_cch;
                    f_pdstrTag->pwszString = f_pdstrXML->pwszString + xmltag.m_dasstrTag.m_ich;
                    goto PREPARENODE;
                }
                break;
            default:
                if (xmltag.m_eTagType == eOpenTag)
                {
                    cTagsUnmatched++;
                    *f_pfIsLeaf = FALSE;
                }
                else if (xmltag.m_eTagType == eCloseTag)
                {
                    if (cTagsUnmatched > f_cLayers)
                    {
                        cTagsUnmatched--;
                    }
                    else
                    {
                        /* end of 'f_cLayers' layers exits, the target tag is not found */
                        ChkDR(DRM_E_NOXMLOPENTAG);   
                    }
                }
                break;
        }
    }

PREPARENODE:
    /* prepare f_pdstrNode & f_pdstrNodeData */
    if (f_pdstrNode != NULL)
    {
        f_pdstrNode->pwszString = f_pdstrXML->pwszString  + ichNodeBegin;
        f_pdstrNode->cchString  = (DRM_DWORD) (ichNodeEnd - ichNodeBegin + 1);
    }

    if (f_pdstrNodeData != NULL)
    {
        if (eStatus == eEmptyTag)
        {
            f_pdstrNodeData->pwszString = NULL;
            f_pdstrNodeData->cchString  = 0;
        }
        else
        {
            f_pdstrNodeData->pwszString = f_pdstrXML->pwszString  + ichDataBegin;
            f_pdstrNodeData->cchString  = (DRM_DWORD) (ichDataEnd - ichDataBegin + 1);

            if (! _AllTrimW(f_pdstrNodeData))
            {
                f_pdstrNodeData->pwszString = NULL;
            }
        }
    }

    if (f_pdstr1stAttrName != NULL)
    {
        *f_pdstr1stAttrName = dstr1stAttrName;
    }

    if (f_pdstr1stAttrValue != NULL)
    {
        *f_pdstr1stAttrValue = dstr1stAttrValue;
    }
    
    dr = DRM_SUCCESS;

ErrorExit:

    return dr;
}

/*
***********************************************************************
** API methods
***********************************************************************
*/

DRM_RESULT DRM_API DRM_XML_GetNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,            /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_CONST_STRING       *f_pdstrNode,       /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData)   /* data enclosed by the immediate <tag>...</tag> in the given XML string */
{
    return DRM_XML_GetSubNode(f_pdstrXML,
                              f_pdstrTag,
                              f_pdstrAttrName,
                              f_pdstrAttrValue,
                              f_iNode,
                              f_pdstrNode,
                              f_pdstrNodeData,
                              0);    
}

DRM_RESULT DRM_API DRM_XML_GetNodeA(
    IN  const DRM_CHAR              *f_pszBase,
    IN  const DRM_SUBSTRING         *f_pdasstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrTag,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    IN  const DRM_ANSI_CONST_STRING *f_pdasstrAttrValue,
    IN  const DRM_DWORD              f_iNode,              /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_SUBSTRING               *f_pdasstrXmlNode,     /* either of these 2 parameter can be NULL but not both */
    OUT DRM_SUBSTRING               *f_pdasstrXmlNodeData) /* data enclosed by the immediate <tag>...</tag> in the given XML string */
{
    return DRM_XML_GetSubNodeA(f_pszBase,
                               f_pdasstrXML,
                               f_pdastrTag,
                               f_pdastrAttrName,
                               f_pdasstrAttrValue,
                               f_iNode,
                               f_pdasstrXmlNode, 
                               f_pdasstrXmlNodeData,
                               0);
}
    
/******************************************************************************
** 
** Function :   _GetSubNodeOptimized
** 
** Synopsis :   Get the beginning of a subnode (i.e. without parsing till the 
**              endtag
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      f_pdstrNode and f_pdstrNodeData in this case would contain the 
**              entire XML buffer starting from the required node or node-data
**              respectively
** 
******************************************************************************/
DRM_RESULT DRM_API _GetSubNodeOptimized(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,          /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_CONST_STRING       *f_pdstrNode,     /* these two parameters can either be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData,
    IN  DRM_DWORD               f_iLayer)      /* outermost layer is 0 */
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMString(f_pdstrXML);
    ChkDRMString(f_pdstrTag);
        
    ChkArg(f_pdstrNode     != NULL 
        || f_pdstrNodeData != NULL);

    ChkDR(_GetXMLSubNodeW( f_pdstrXML, 
                           f_pdstrTag, 
                           f_pdstrAttrName, 
                           f_pdstrAttrValue, 
                           f_iNode,
                           f_pdstrNode, 
                           f_pdstrNodeData, 
                           f_iLayer,
                           TRUE ) );

ErrorExit:

    return dr;
}

DRM_RESULT DRM_API DRM_XML_GetSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,          /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_CONST_STRING       *f_pdstrNode,     /* these two parameters can either be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData,
    IN  DRM_DWORD               f_iLayer)      /* outermost layer is 0 */
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMString(f_pdstrXML);
    ChkDRMString(f_pdstrTag);
        
    ChkArg(f_pdstrNode     != NULL 
        || f_pdstrNodeData != NULL);

    ChkDR(_GetXMLSubNodeW(f_pdstrXML, 
                          f_pdstrTag, 
                          f_pdstrAttrName, 
                          f_pdstrAttrValue, 
                          f_iNode,
                          f_pdstrNode, 
                          f_pdstrNodeData, 
                          f_iLayer,
                          FALSE));

ErrorExit:

    return _TranslateXMLError(dr);
}

DRM_RESULT DRM_API DRM_XML_GetSubNodeA(
    IN  const DRM_CHAR              *f_pszBase,
    IN  const DRM_SUBSTRING         *f_pdasstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrTag,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    IN  const DRM_ANSI_CONST_STRING *f_pdasstrAttrValue,
    IN  const DRM_DWORD              f_iNode,           /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_SUBSTRING               *f_pdasstrNode,     /* these two parameters can either be NULL but not both */
    OUT DRM_SUBSTRING               *f_pdasstrNodeData,
    IN  DRM_DWORD                    f_iLayer)       /* outermost layer is 0 */
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD     cTagsMatched   = 0;
    DRM_DWORD     cNodes         = 0;
    DRM_DWORD     cTagsUnmatched = 0;   /* increment until we find the matching tag */
    DRM_DWORD     ichNodeBegin   = 0; 
    DRM_DWORD     ichDataBegin   = 0; 
    DRM_DWORD     ichNodeEnd     = 0; 
    DRM_DWORD     ichDataEnd     = 0; 
    DRM_DWORD     ichCurr        = f_pdasstrXML->m_ich;
    DRM_SUBSTRING dasstrTag      = EMPTY_DRM_SUBSTRING;
    _ETAGTYPE     eStatus        = eTagNone;
    _XMLTAGA      xmltag         = { 0 };    

    ChkArg(f_pszBase != NULL);
    
    ChkArg(f_pdasstrXML != NULL
        && f_pdastrTag  != NULL);
        
    ChkArg(f_pdasstrNode     != NULL 
        || f_pdasstrNodeData != NULL);

    while (TRUE)
    {
        /* scan for tag at currIndex */
        if (! _ScanTagA(f_pszBase, f_pdasstrXML, &ichCurr, &xmltag))
        {
            if (cTagsMatched == 0)
            {
                ChkDR(DRM_E_NOXMLOPENTAG);
            }
            else
            {
                ChkDR(DRM_E_NOXMLCLOSETAG);
            }
        }

        /* check if we have a match to the node tag */
        if (cTagsUnmatched != f_iLayer)
        {
            if (xmltag.m_eTagType == eOpenTag)
            {
                cTagsUnmatched++;
            }
            else if (xmltag.m_eTagType == eCloseTag)
            {
                if (cTagsUnmatched > 0)
                {
                    cTagsUnmatched--;
                }
                else
                {
                    ChkDR(DRM_E_NOXMLOPENTAG);
                }
            }
            continue;
        }

        dasstrTag.m_cch = f_pdastrTag->cchString;

        eStatus = _CheckTagA(f_pszBase,
                            &xmltag, 
                             f_pdastrTag->pszString, 
                            &dasstrTag,
                             f_pdastrAttrName, 
                             f_pdasstrAttrValue);
        switch (eStatus)
        {
        case eOpenTag:     /* open tag found */
            /* this is the first matched open tag found. if cTagsMatched>0, it
            ** means the matched opend tag is nested.
            */
            if (cTagsMatched == 0) 
            {
                ichNodeBegin = xmltag.m_ichTagBegin;
                ichDataBegin = xmltag.m_ichTagEnd + 1;
            }
            cTagsMatched++;
            break;

        case eCloseTag:    /* close tag found */
            if (cTagsMatched == 0)
            {
                /* we get </tag> before we get <tag> */
                ChkDR(DRM_E_NOXMLOPENTAG);
            }
            
            cTagsMatched--;
            
            if (cTagsMatched == 0)  /* make sure it is not nested */
            {
                /* we've got the matching <tag> and </tag>, 
                ** exit the loop if this is the node we want
                */
                if (cNodes == f_iNode)
                {
                    ichNodeEnd = xmltag.m_ichTagEnd;
                    ichDataEnd = xmltag.m_ichTagBegin - 1;
                    goto PREPARENODE;
                }
                ichNodeBegin = 0;
                ichDataBegin = 0;
                cNodes++;
            }
            break;

        case eEmptyTag:
            if (cTagsMatched == 0)
            {
                /* we've got the matching <tag/>, 
                ** exit the loop if this is the node we want
                */
                if (cNodes == f_iNode)
                {
                    ichNodeBegin = xmltag.m_ichTagBegin;
                    ichNodeEnd   = xmltag.m_ichTagEnd;
                    ichDataBegin = 0;
                    ichDataEnd   = 0;
                    goto PREPARENODE;
                }
                ichNodeBegin = 0;
                cNodes++;
            }
            break;

        default:
            if (xmltag.m_eTagType == eOpenTag)
            {
                cTagsUnmatched++;
            }
            else if (xmltag.m_eTagType == eCloseTag)
            {
                if (cTagsUnmatched > f_iLayer)
                {
                    cTagsUnmatched--;
                }
                else
                {
                    /* end of 'f_cLayers' layers exits, the target tag is not found */
                    ChkDR(DRM_E_NOXMLOPENTAG);   
                }
            }
            break;
        }
    }

PREPARENODE:
    /* prepare f_pdstrNode & f_pdstrNodeData */
    if (f_pdasstrNode != NULL)
    {
        f_pdasstrNode->m_ich = ichNodeBegin;
        f_pdasstrNode->m_cch = (ichNodeEnd - ichNodeBegin + 1);
    }

    if (f_pdasstrNodeData != NULL)
    {
        if (eStatus == eEmptyTag)
        {
            f_pdasstrNodeData->m_cch = 0;
            f_pdasstrNodeData->m_ich = 0;
        }
        else
        {
            f_pdasstrNodeData->m_ich = ichDataBegin;
            f_pdasstrNodeData->m_cch = (ichDataEnd - ichDataBegin + 1);

            _AllTrimA(f_pszBase, f_pdasstrNodeData);
        }
    }
    dr = DRM_SUCCESS;

ErrorExit:

    return _TranslateXMLError(dr);
} /* DRM_XML_GetSubNodeA */

DRM_RESULT DRM_API DRM_XML_GetNodeAttribute(
    IN const DRM_CONST_STRING *f_pdstrNode,    /* the topmost node in this XML string will be worked on */
    IN const DRM_CONST_STRING *f_pdstrAttrName,   /* attrName to retrieve */
    OUT      DRM_CONST_STRING *f_pdstrAttrValue)	/* returned attrValue */
{
    DRM_RESULT dr = DRM_E_INVALIDXMLTAG;
    _XMLTAGW xmltag;

    ChkDRMString(f_pdstrNode);
    ChkDRMString(f_pdstrAttrName);
    ChkArg(f_pdstrAttrName->cchString  > 0);
    ChkArg(f_pdstrAttrValue != NULL);

    if (_ScanNodeForAttributeW(f_pdstrNode, f_pdstrAttrName, &xmltag))
    {
        f_pdstrAttrValue->pwszString = f_pdstrNode->pwszString + xmltag.m_dasstrAttrValue.m_ich;
        f_pdstrAttrValue->cchString  =                           xmltag.m_dasstrAttrValue.m_cch;

        dr = DRM_SUCCESS;
    }
    else
    {
        goto ErrorExit;
    }
    

ErrorExit:

    return _TranslateXMLError(dr);
}


/**********************************************************************
** Function:    DRM_XML_GetNodeAttributeA
** Synopsis:    
** Arguments:   [pdwStamp] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/

DRM_RESULT DRM_API DRM_XML_GetNodeAttributeA(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrNode,
    IN const DRM_ANSI_CONST_STRING *f_pdastrAttrName,  /* attrName to retrieve */
       OUT   DRM_SUBSTRING         *f_pdasstrAttrValue) /* returned attrValue */
{
    DRM_RESULT dr = DRM_E_INVALIDXMLTAG;
    _XMLTAGA   xmltag = { 0 };

    ChkArg(f_pszBase          != NULL);
    ChkArg(f_pdasstrAttrValue != NULL);

    ChkArg(f_pdasstrNode       != NULL
        && f_pdasstrNode->m_cch > 0);
        
    ChkArg(f_pdastrAttrName            != NULL
        && f_pdastrAttrName->pszString != NULL
        && f_pdastrAttrName->cchString  > 0);
        
    if (_ScanNodeForAttributeA(f_pszBase, f_pdasstrNode, f_pdastrAttrName, &xmltag))
    {
        f_pdasstrAttrValue->m_cch = xmltag.m_dasstrAttrValue.m_cch;
        f_pdasstrAttrValue->m_ich = xmltag.m_dasstrAttrValue.m_ich;

        dr = DRM_SUCCESS;
    }
    
ErrorExit:

    return _TranslateXMLError(dr);
}


/**********************************************************************
** Function:    DRM_XML_GetNodeCData
** Synopsis:    
** Arguments:   [pdwStamp] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
DRM_RESULT DRM_API DRM_XML_GetNodeCData(
    IN const DRM_CONST_STRING *f_pdstrNode,     /* the topmost node in this XML string will be worked on */
    OUT      DRM_CONST_STRING *f_pdstrCData)       /* returned CData */
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMString(f_pdstrNode);
    ChkArg(f_pdstrCData != NULL);

    ChkDR(_GetXMLNodeCDataW(f_pdstrNode, f_pdstrCData));

ErrorExit:

    return _TranslateXMLError(dr);
}

DRM_RESULT DRM_API DRM_XML_GetAndDecryptNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,           /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pcontextCRYP,    /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  PRIVKEY                *f_pprivkey,          /* priv key to use for decrypt */
    OUT DRM_CONST_STRING       *f_pdstrNode,      /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData)  /* data enclosed by the immediate <tag>...</tag> in the given XML string */
{
    return DRM_XML_GetAndDecryptSubNode(f_pdstrXML,
                                        f_pdstrTag,
                                        f_pdstrAttrName,
                                        f_pdstrAttrValue,
                                        f_iNode,
                                        f_pcontextCRYP,
                                        f_pprivkey,
                                        f_pdstrNode,
                                        f_pdstrNodeData,
                                        0);
}


/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_RESULT DRM_API DRM_XML_GetAndVerifyNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,           /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pcontextCRYP,    /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  const PUBKEY           *f_ppubkey,           /* pub key to use for verify */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrNode,      /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData)  /* data enclosed by the immediate <tag>...</tag> in the given XML string */
{
    return DRM_XML_GetAndVerifySubNode(f_pdstrXML,
                                       f_pdstrTag,
                                       f_pdstrAttrName,
                                       f_pdstrAttrValue,
                                       f_iNode,
                                       f_pcontextCRYP,
                                       f_ppubkey,
                                       f_fIncludeTag,
                                       f_pdstrB64Signature,
                                       f_pdstrNode,
                                       f_pdstrNodeData,
                                       0);
}

/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_RESULT DRM_API DRM_XML_GetAndDecryptSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,        /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pcontextCRYP, /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  PRIVKEY                *f_pprivkey,     /* priv key to use for decrypt */
    OUT DRM_CONST_STRING       *f_pdstrNode,    /* these two parameters can either be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData,
    IN  DRM_DWORD               f_iLayer)       /* outermost layer is 0 */
{
    DRM_CONST_STRING dstrXMLNode     = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrXMLNodeData = EMPTY_DRM_STRING;
    DRM_RESULT       dr          = DRM_SUCCESS;
    DRM_DWORD        cbDecoded     = 0;
    DRM_DWORD        i           = 0;
    DRM_WCHAR       *_pwszString = NULL;

    ChkArg(f_pcontextCRYP  != NULL
        && f_pprivkey      != NULL);
         
    ChkArg(f_pdstrNode     != NULL 
        || f_pdstrNodeData != NULL);

    /* get the node first */

    ChkDR(DRM_XML_GetSubNode(f_pdstrXML, 
                             f_pdstrTag, 
                             f_pdstrAttrName, 
                             f_pdstrAttrValue, 
                             f_iNode, 
                            &dstrXMLNode,
                            &dstrXMLNodeData, 
                             f_iLayer));

    /* base64 decode in-place */

    ChkDR(DRM_B64_DecodeW(&dstrXMLNodeData, &cbDecoded, NULL, DRM_BASE64_DECODE_IN_PLACE));

    /* decrypt the node data in-place */
                                
    ChkDR (DRM_PK_DecryptLarge (f_pprivkey, 
                                PB_DSTR(&dstrXMLNodeData),
                                cbDecoded,
                                PB_DSTR(&dstrXMLNodeData),
                                f_pcontextCRYP));

    /* fill the "empty space" with blanks */
    cbDecoded = (cbDecoded - PK_ENC_CIPHERTEXT_LEN) / SIZEOF(DRM_WCHAR);

    _pwszString = (DRM_WCHAR*)(dstrXMLNodeData.pwszString);
    for (i = 0; i < (dstrXMLNodeData.cchString - cbDecoded); i++)
    {
        _pwszString [cbDecoded+i] = g_wchSpace;
    }

    dstrXMLNodeData.cchString = cbDecoded;

    /* prepare for return value */
    if (f_pdstrNode != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNode, dstrXMLNode);
    }

    if (f_pdstrNodeData != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNodeData, dstrXMLNodeData);
    }
    
ErrorExit:

    return _TranslateXMLError(dr);
}


/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_RESULT DRM_API DRM_XML_GetAndVerifySubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,          /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pcontextCRYP,   /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  const PUBKEY           *f_ppubkey,          /* pub key to use for verify */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrNode,     /* these two parameters can either be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData,
    IN  DRM_DWORD               f_iLayer)      /* outermost layer is 0 */
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrXMLNode;
    DRM_CONST_STRING dstrXMLNodeData;
    DRM_DWORD        cbDecoded = PK_ENC_SIGNATURE_LEN;
    DRM_BYTE         rgbSign [__CB_DECL(PK_ENC_SIGNATURE_LEN)];
    
    ChkArg(f_pcontextCRYP      != NULL
        && f_ppubkey           != NULL
        && f_pdstrB64Signature != NULL);
        
    ChkArg(f_pdstrNode    != NULL 
       || f_pdstrNodeData != NULL);
        
    ChkArg(f_pdstrB64Signature->cchString == PK_ENC_SIGNATURE_B64LEN);

    /* get the node first */
    ChkDR(DRM_XML_GetSubNode(f_pdstrXML, 
                             f_pdstrTag, 
                             f_pdstrAttrName, 
                             f_pdstrAttrValue, 
                             f_iNode,
                            &dstrXMLNode,
                            &dstrXMLNodeData, 
                             f_iLayer));

    /* base64 decode the signature */
    ChkDR(DRM_B64_DecodeW(f_pdstrB64Signature, &cbDecoded, rgbSign, 0));

    /* verify the node with the signature */
    if (f_fIncludeTag)
    {
        if (! DRM_PK_Verify(f_pcontextCRYP->rgbCryptoContext, 
                            f_ppubkey, 
                            PB_DSTR(&dstrXMLNode), 
                            CB_DSTR(&dstrXMLNode),
                            rgbSign))
        {
            ChkDR (DRM_E_INVALID_SIGNATURE);
        }
    }
    else
    {
        if (! DRM_PK_Verify(f_pcontextCRYP->rgbCryptoContext, 
                            f_ppubkey, 
                            PB_DSTR(&dstrXMLNodeData), 
                            CB_DSTR(&dstrXMLNodeData),
                            rgbSign))
        {
            ChkDR (DRM_E_INVALID_SIGNATURE);
        }
    }

    /* prepare for return value */
    if (f_pdstrNode != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNode, dstrXMLNode);
    }
    if (f_pdstrNodeData != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNodeData, dstrXMLNodeData);
    }

ErrorExit:

    return _TranslateXMLError(dr);
}

DRM_RESULT DRM_API DRM_XML_GetAndVerifyKeyedHashNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,              /* nth occurence of the node in the xml stirng, start from 0 */
    IN  HMAC_CONTEXT           *f_pcontextHMAC,
    IN  DRM_BYTE               *f_pbKeyHash,          /* Hash key for HMAC */
    IN  DRM_DWORD               f_cbKeyHash,          /* byte count of HMAC */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrNode,       /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData)   /* data enclosed by the immediate <tag>...</tag> in the given XML string */
{
    return DRM_XML_GetAndVerifyKeyedHashSubNode(f_pdstrXML,
                                                f_pdstrTag,
                                                f_pdstrAttrName,
                                                f_pdstrAttrValue,
                                                f_iNode,
                                                f_pcontextHMAC,
                                                f_pbKeyHash,
                                                f_cbKeyHash,
                                                f_fIncludeTag,
                                                f_pdstrB64Signature,
                                                f_pdstrNode,
                                                f_pdstrNodeData,
                                                0);
}

DRM_RESULT DRM_API DRM_XML_GetAndVerifyKeyedHashSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,          /* nth occurence of the node in the xml stirng, start from 0 */
    IN  HMAC_CONTEXT           *f_pcontextHMAC,     /* HMAC context */
    IN  DRM_BYTE               *f_pbKeyHash,        /* Hash key for HMAC */
    IN  DRM_DWORD               f_cbKeyHash,        /* byte count of HMAC */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrNode,     /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrNodeData, /* data enclosed by the immediate <tag>...</tag> in the given XML string */
    IN  DRM_DWORD               f_iLayer)      /* outermost layer is 0 */
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrXMLNode;
    DRM_CONST_STRING dstrXMLNodeData;
    DRM_DWORD        cbDecoded = SHA_DIGEST_LEN;
    DRM_BYTE         rgbSign   [__CB_DECL(SHA_DIGEST_LEN)];
    DRM_BYTE         rgbVerify [__CB_DECL(SHA_DIGEST_LEN)];
    
    ChkArg(f_pcontextHMAC      != NULL
        && f_pbKeyHash         != NULL
        && f_cbKeyHash         != NULL
        && f_pdstrB64Signature != NULL);

    ChkArg(f_pdstrNode     != NULL 
        || f_pdstrNodeData != NULL);
        
    ChkArg(f_pdstrB64Signature->cchString == SHA_B64ENC_DIGEST_LEN);

    /* get the node first */
    ChkDR(DRM_XML_GetSubNode(f_pdstrXML,
                             f_pdstrTag,
                             f_pdstrAttrName,
                             f_pdstrAttrValue,
                             f_iNode,
                            &dstrXMLNode,
                            &dstrXMLNodeData, 
                             f_iLayer));

    /* base64 decode the signature */
    ChkDR(DRM_B64_DecodeW(f_pdstrB64Signature, &cbDecoded, rgbSign, 0));

    ChkDR(DRM_HMAC_Init(f_pcontextHMAC, f_pbKeyHash, f_cbKeyHash));

    if (f_fIncludeTag)
    {
        ChkDR(DRM_HMAC_Update(f_pcontextHMAC, 
                              PB_DSTR (&dstrXMLNode), 
                              CB_DSTR (&dstrXMLNode)));
    }
    else
    {
        ChkDR(DRM_HMAC_Update(f_pcontextHMAC,
                              PB_DSTR (&dstrXMLNodeData), 
                              CB_DSTR (&dstrXMLNodeData)));
    }

    ChkDR(DRM_HMAC_Finalize(f_pcontextHMAC, rgbVerify, SHA_DIGEST_LEN));

    if (MEMCMP(rgbVerify, rgbSign, SHA_DIGEST_LEN) != 0)
    {
        ChkDR(DRM_E_HASHMISMATCH);
    }

    /* prepare for return value */
    if (f_pdstrNode != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNode, dstrXMLNode);
    }

    if (f_pdstrNodeData != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrNodeData, dstrXMLNodeData);
    }

ErrorExit:

    return _TranslateXMLError(dr);
}

DRM_RESULT DRM_API DRM_XML_GetSubNodeByPath(
    IN const DRM_CONST_STRING* f_pdstrXML, 
    IN const DRM_CONST_STRING* f_pdstrXMLNode, 
    IN const DRM_CONST_STRING* f_pdstrAttrName, 
    IN const DRM_CONST_STRING* f_pdstrAttrValue,
    OUT      DRM_CONST_STRING* f_pdstrXMLNodeOut, 
    OUT      DRM_CONST_STRING* f_pdstrXMLDataOut,
    IN       DRM_WCHAR chSeparator)
{
    DRM_RESULT dr = DRM_E_LOGICERR;
    const DRM_WCHAR* pch = NULL;
    DRM_DWORD        cch = 0;
    DRM_CONST_STRING dstrXml      = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNode     = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNodeName = EMPTY_DRM_STRING;

    ChkDRMString(f_pdstrXML);
    ChkDRMString(f_pdstrXMLNode);

    pch = f_pdstrXMLNode->pwszString;

    ASSIGN_DRM_STRING(dstrXml, *f_pdstrXML);    
    while(cch < f_pdstrXMLNode->cchString)
    {
        pch = f_pdstrXMLNode->pwszString + cch;
        while(f_pdstrXMLNode->pwszString [cch] != chSeparator 
           &&  cch  < f_pdstrXMLNode->cchString)
        {
            cch++;            
        }

        dstrNodeName.pwszString = pch;
        dstrNodeName.cchString  = cch - ((DRM_DWORD)(pch - f_pdstrXMLNode->pwszString));

        if (*(f_pdstrXMLNode->pwszString + cch) != chSeparator)
        {   /* We are on the last segment.             */
            if (DRM_UTL_DSTRStringsEqual(&g_dstrTagCDATA, &dstrNodeName))
            {   /* Requesting the CDATA section.  Ask for that. */
                ChkDR(DRM_XML_GetNodeCData(&dstrXml, f_pdstrXMLDataOut));
            }
            else
            {   /* Just get the node and use the attributes parameters */
                ChkDR(DRM_XML_GetSubNode(&dstrXml, &dstrNodeName, f_pdstrAttrName, f_pdstrAttrValue, 0, &dstrNode, f_pdstrXMLDataOut, 1));
            }
        }
        else
        {   
#if DBG
            ChkDR(DRM_XML_GetSubNode(&dstrXml, &dstrNodeName, NULL, NULL, 0, &dstrNode, f_pdstrXMLDataOut , 1));            
#else
            /*
            **  Use optimized version - no need to check end tag
            */
            ChkDR(_GetSubNodeOptimized(&dstrXml, &dstrNodeName, NULL, NULL, 0, &dstrNode, f_pdstrXMLDataOut , 1));
#endif            
        }

        ASSIGN_DRM_STRING(dstrXml, dstrNode);
        cch++;    
    }

    if(f_pdstrXMLNodeOut != NULL)
    {
        ASSIGN_DRM_STRING(*f_pdstrXMLNodeOut, dstrXml);
    }

ErrorExit:
    DRMASSERT(dr != DRM_E_LOGICERR);

    return _TranslateXMLError(dr);
} /* DRM_XML_GetSubNodeByPath */

/**********************************************************************
** Function:    DRM_XML_EnumNextNode
** Synopsis:    Enumerate the next node from the given xml string
** Arguments:   [f_pdstrXML] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
DRM_RESULT DRM_API DRM_XML_EnumNextNode(
    IN const DRM_CONST_STRING *f_pdstrXML,
       OUT   DRM_CONST_STRING *f_pdstrTag,
       OUT   DRM_CONST_STRING *f_pdstrNode,         /* either of these 2 parameter can be NULL but not both */
       OUT   DRM_CONST_STRING *f_pdstrNodeData,     /* data enclosed by the immediate <tag>...</tag> in the given XML string */
       OUT   DRM_CONST_STRING *f_pdstr1stAttrName,  /* optional */
       OUT   DRM_CONST_STRING *f_pdstr1stAttrValue, /* optional */
       OUT   DRM_BOOL         *f_pfIsLeaf)          /* set to TRUE of the returned node is a leaf node */
{
    return DRM_XML_EnumNextSubNode(
                f_pdstrXML,
                f_pdstrTag,
                f_pdstrNode,
                f_pdstrNodeData,
                f_pdstr1stAttrName,
                f_pdstr1stAttrValue,
                f_pfIsLeaf,
                0);    
} /* DRM_XML_EnumNextNode */

/**********************************************************************
** Function:    DRM_XML_EnumNextSubNode
** Synopsis:    Enumerate the next subnode from the given xml string,
**              optionaly, from nth layer
** Arguments:   [f_pdstrXML] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
DRM_RESULT DRM_API DRM_XML_EnumNextSubNode(
    IN const DRM_CONST_STRING *f_pdstrXML,
       OUT   DRM_CONST_STRING *f_pdstrTag,
       OUT   DRM_CONST_STRING *f_pdstrNode,         /* these two parameters can either be NULL but not both */
       OUT   DRM_CONST_STRING *f_pdstrNodeData,
       OUT   DRM_CONST_STRING *f_pdstr1stAttrName,  /* optional */
       OUT   DRM_CONST_STRING *f_pdstr1stAttrValue, /* optional */
       OUT   DRM_BOOL         *f_pfIsLeaf,          /* set to TRUE of the returned node is a leaf node */
    IN       DRM_DWORD         f_nAtNthLayer)       /* outermost layer is 0 */
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDRMString(f_pdstrXML);
    ChkArg(f_pdstrTag != NULL);
        
    ChkArg(f_pdstrNode     != NULL 
        || f_pdstrNodeData != NULL);

    ChkDR(_EnumXMLSubNodeW(f_pdstrXML, 
                           f_pdstrTag, 
                           f_pdstrNode, 
                           f_pdstrNodeData, 
                           f_pdstr1stAttrName,
                           f_pdstr1stAttrValue,
                           f_pfIsLeaf, 
                           f_nAtNthLayer));

ErrorExit:

    return _TranslateXMLError(dr);
} /* DRM_XML_EnumNextSubNode */


/* Ensure that the XML is valid */
DRM_BOOL DRM_API DRM_XML_Validate( IN const DRM_CONST_STRING *f_pdstrXML )
{
    DRM_RESULT       dr      = DRM_SUCCESS;
    DRM_DWORD        ich     = 0;
    _XMLTAGW         xmltag  = { 0 };
    DRM_CONST_STRING dstrTag = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrNode= EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrData= EMPTY_DRM_STRING;

    /* Note that all error codes are meaningless in the end.  Only a 
       true of false is returned */
    DRMASSERT( f_pdstrXML             != NULL 
            && f_pdstrXML->pwszString != NULL
            && f_pdstrXML->cchString   > 0 );
    
    ChkDRMString( f_pdstrXML );

    /* ScanTag will skip all the xml preamble stuff and give me the
       first real XML tag */
    if( !_ScanTagW( f_pdstrXML, &ich, &xmltag )
     ||  xmltag.m_eTagType != eOpenTag )
    {
        ChkDR( DRM_E_INVALIDXMLTAG );
    }

    /* The first tag has been found. */
    dstrTag.cchString  = xmltag.m_dasstrTag.m_cch;
    dstrTag.pwszString = xmltag.m_pwszBase 
                       + xmltag.m_dasstrTag.m_ich;

    /* Now do an XML GetNode to parse to the end of 
       this tag and ensure it's valid. */
    
    ChkDR( _GetXMLSubNodeW( f_pdstrXML,
                           &dstrTag,
                            NULL,
                            NULL,
                            0,
                           &dstrNode,
                           &dstrData,
                            0,
                            FALSE ) );

ErrorExit:
    return DRM_SUCCEEDED( dr );
}

/**********************************************************************
** Function:    DRM_XML_EnumNextNode
** Synopsis:    Enumerate the next node from the given xml string
** Arguments:   [f_pdstrXML] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/

DRM_RESULT DRM_API DRM_XML_EnumNextNodeA(
    IN const DRM_CHAR         *f_pszBase,
    IN const DRM_SUBSTRING    *f_pdasstrXML,
    IN const DRM_DWORD         f_iNode,
       OUT   DRM_SUBSTRING    *f_pdasstrTag,
       OUT   DRM_SUBSTRING    *f_pdasstrNode,         /* either of these 2 parameter can be NULL but not both */
       OUT   DRM_SUBSTRING    *f_pdasstrNodeData,     /* data enclosed by the immediate <tag>...</tag> in the given XML string */
       OUT   DRM_SUBSTRING    *f_pdasstr1stAttrName,  /* optional */
       OUT   DRM_SUBSTRING    *f_pdasstr1stAttrValue)            /* set to TRUE of the returned node is a leaf node */
{
    DRM_RESULT    dr = DRM_E_NOXMLOPENTAG;
    DRM_DWORD     cRecursionDepth= 0;
    DRM_DWORD     cTagsMatched   = 0; 
    DRM_DWORD     ichNodeBegin   = 0; 
    DRM_DWORD     ichDataBegin   = 0; 
    DRM_DWORD     ichNodeEnd     = 0; 
    DRM_DWORD     ichDataEnd     = 0; 
    DRM_DWORD     iNode          = 0;
    DRM_DWORD     ichCurr        = f_pdasstrXML->m_ich;
    _XMLTAGA      xmltag         = { 0 };    
    DRM_SUBSTRING dasstr1stAttrName  = { 0 };
    DRM_SUBSTRING dasstr1stAttrValue = { 0 };

    ChkArg(f_pszBase    != NULL
        && f_pdasstrXML != NULL
        && f_pdasstrTag != NULL);
        
    ChkArg(f_pdasstrNode     != NULL 
        || f_pdasstrNodeData != NULL);

    for( ; ; )
    {
        /* scan for tag at currIndex */
        if (! _ScanTagA(f_pszBase, f_pdasstrXML, &ichCurr, &xmltag))
        {
            if (cTagsMatched == 0)
            {
                ChkDR(DRM_E_NOXMLOPENTAG);
            }
            else
            {
                ChkDR(DRM_E_NOXMLCLOSETAG);
            }
        }

        switch (xmltag.m_eTagType)
        {
            case eOpenTag:
                if (cRecursionDepth == 0
                &&  ++iNode         == (f_iNode + 1)) 
                {
                    ichNodeBegin = xmltag.m_ichTagBegin;
                    ichDataBegin = xmltag.m_ichTagEnd + 1;

                    /* assign the tag name so that we know what to look for closing tag */

                    f_pdasstrTag->m_cch = xmltag.m_dasstrTag.m_cch;
                    f_pdasstrTag->m_ich = xmltag.m_dasstrTag.m_ich;

                    /* save the attr name/value */
                    dasstr1stAttrName.m_cch  = xmltag.m_dasstrAttrName.m_cch;
                    dasstr1stAttrName.m_ich  = xmltag.m_dasstrAttrName.m_ich;
                    dasstr1stAttrValue.m_cch = xmltag.m_dasstrAttrValue.m_cch;
                    dasstr1stAttrValue.m_ich = xmltag.m_dasstrAttrValue.m_ich;
                }
                else
                {
                    cRecursionDepth++;
                }
                cTagsMatched++;
                break;
                
            case eCloseTag:    /* close tag found */
                if (cTagsMatched == 0)
                {
                    /* we get </tag> before we get <tag> */
                    ChkDR(DRM_E_NOXMLOPENTAG);
                }

                cTagsMatched--;

                if (cTagsMatched    == 0
                &&  cRecursionDepth == 0)
                {
                    /* we've got the matching <tag> and </tag>, 
                    ** exit the loop if this is the node we want
                    */
                    ichNodeEnd   = xmltag.m_ichTagEnd;
                    ichDataEnd   = xmltag.m_ichTagBegin - 1;
                    goto PREPARENODE;
                }
                else
                {
                    cRecursionDepth--;
                }
                break;

            default:
                break;
        }
    }

PREPARENODE:
    /* prepare f_pdasstrNode & f_pdasstrNodeData */
    if (f_pdasstrNode != NULL)
    {
        f_pdasstrNode->m_ich = ichNodeBegin;
        f_pdasstrNode->m_cch = (DRM_DWORD) (ichNodeEnd - ichNodeBegin + 1);
    }

    if (f_pdasstrNodeData != NULL)
    {
        if (xmltag.m_eTagType == eEmptyTag)
        {
            f_pdasstrNodeData->m_ich = 0;
            f_pdasstrNodeData->m_cch = 0;
        }
        else
        {
            f_pdasstrNodeData->m_ich = ichDataBegin;
            f_pdasstrNodeData->m_cch = (DRM_DWORD) (ichDataEnd - ichDataBegin + 1);

            if (! _AllTrimA(f_pszBase, f_pdasstrNodeData))
            {
                f_pdasstrNodeData->m_cch = 0;
            }
        }
    }

    if (f_pdasstr1stAttrName != NULL)
    {
        *f_pdasstr1stAttrName = dasstr1stAttrName;
    }

    if (f_pdasstr1stAttrValue != NULL)
    {
        *f_pdasstr1stAttrValue = dasstr1stAttrValue;
    }
    
    dr = DRM_SUCCESS;

ErrorExit:

    return _TranslateXMLError(dr);
} /* DRM_XML_EnumNextNode */

DRM_RESULT DRM_API DRM_XML_CountMatchingNodesA(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrXML,
    IN const DRM_ANSI_CONST_STRING *f_pdastrTag,          /* optional */
    IN       DRM_ANSI_CONST_STRING *f_pdastr1stAttrName,  /* optional */
    IN       DRM_ANSI_CONST_STRING *f_pdastr1stAttrValue, /* optional */
       OUT   DRM_DWORD             *f_cMatchingNodes)
{
    DRM_RESULT    dr    = DRM_SUCCESS;
    DRM_DWORD     iNode = 0;
    DRM_SUBSTRING dasstrTag          = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDummy        = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstr1stAttrLabel = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstr1stAttrValue = EMPTY_DRM_SUBSTRING;

    ChkArg(f_pszBase        != NULL
        && f_pdasstrXML     != NULL
        && f_cMatchingNodes != NULL);

    *f_cMatchingNodes = 0;

    for( ; ; )
    {
        dr = DRM_XML_EnumNextNodeA(f_pszBase,
                                   f_pdasstrXML,
                                   iNode++,
                                  &dasstrTag,
                                  &dasstrDummy,
                                   NULL,
                                  &dasstr1stAttrLabel,
                                  &dasstr1stAttrValue);

        if (dr == DRM_E_XMLNOTFOUND)                                                   
        {
            dr = DRM_SUCCESS;
            break;
        }
        else
        {
            ChkDR(dr);
            
            if ((f_pdastrTag          == NULL || DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrTag,          f_pdastrTag))
            &&  (f_pdastr1stAttrName  == NULL || DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstr1stAttrLabel, f_pdastr1stAttrName))
            &&  (f_pdastr1stAttrValue == NULL || DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstr1stAttrValue, f_pdastr1stAttrValue)))
            {
                (*f_cMatchingNodes)++;
            }              
        }
    }
    
ErrorExit:

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmxmlutilities.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMXMLUTILS_H__
#define __DRMXMLUTILS_H__


#ifdef __cplusplus
extern "C" {
#endif

DRM_RESULT DRM_API DRM_XMU_MatchNodeFromTemplate(
    IN  const   DRM_CONST_STRING    *f_pdstrXmlNodeList,
    IN  const   DRM_CONST_STRING    *f_pdstrXmlTemplate,
    IN          DRM_BOOL            f_fAttributeMatch,
        OUT     DRM_BOOL            *f_pfMatch);


#ifdef __cplusplus
           }
#endif
           
#endif      /* __DRMXMLUTILS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmxmlbuilder.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMXMLBUILDER_H__
#define __DRMXMLBUILDER_H__


#include <drmcommon.h>
#include <drmresults.h>
#include <drmtypes.h>
#include <drmlicense.h>
#include <drmhmac.h>

#ifdef __cplusplus
extern "C" {
#endif

#define CB_XMB_EXTRA              100
#define CCH_CDATA_EXTRA           12
#define CCH_CDATA_REQUIRED(pdstr) ((pdstr)->cchString+CCH_CDATA_EXTRA)


#define DRM_SIMXMLDOC_BUFFSIZE    192
#define DRM_XMB_OVERHEAD          (SIZEOF(_XMBContext) + CB_XMB_EXTRA)


extern const DRM_DWORD g_cbXMLBuilderMinimum;


typedef struct _tagXMBContext
{
    /*
    ** Usage of buffer:
    ** This context buffer is allocated by user at CreateDocument(). Its size  can be reallocated
    ** via ReallocDocument(). The XML string is built on the way when each of the API calls are
    ** made. The XML string grow from top to bottom. On the way, all opened node's open tag 
    ** position is kept and saved on the buffer from bottom to top. So when wNextStringPos
    ** and wNextOpenNodePos collides, NO_MEM is returned and user should reallocate more
    ** memory to finish the operation. 
    ** Note: The open nodes positions will be saved as DWORDs, so it aligns perfectly with the 
    ** growing XML string within the WCHAR buffer.
    */

    /* !!! Caller is ensuring only 2 byte alignment. Never add any member variable greater than 2 bytes*/
    
    DRM_BOOL fInited;
    DRM_BOOL fIsSimMode;        /* TRUE to create a faked doc to calculate the length needed */
    DRM_DWORD wMaxStackUsed;    /* Max stack space used for nested nodes */
    DRM_DWORD wSize;            /* size of context */
    DRM_DWORD wNextOpenNodePos; 
    DRM_DWORD wNextStringPos;   /* next insertion point */
    DRM_DWORD wBuffSize;        /* size of buffer in WCHARs*/
    DRM_WCHAR XmlString [1];
} _XMBContext;




/* state to be used for save/restore XML context during API calls */
typedef struct _tagXMBState
{
    DRM_DWORD cwchMaxStackUsed;    /* Max stack space used for nested nodes */
    DRM_DWORD iwchNextOpenNodePos; 
    DRM_DWORD iwchNextStringPos;   /* next insertion point */
} XMBState;


/*
*******************************************************************************
** API methods
*******************************************************************************
*/

DRM_RESULT DRM_API DRM_XMB_SimulateCreateDocument(
    IN const DRM_DWORD         cbXmlContext,
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrRootNodeName);

DRM_RESULT DRM_API DRM_XMB_CreateDocument(
    IN const DRM_DWORD         cbXmlContext,
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrRootNodeName);

DRM_RESULT DRM_API DRM_XMB_ReallocDocument(
    IN const DRM_BYTE  *pbOldXmlContext,
    IN const DRM_DWORD  cbNewXmlContext,
    IN OUT   DRM_BYTE  *pbNewXmlContext );
 
/**********************************************************************
** Function:    DRM_XMB_CloseDocument
** Synopsis:    Pop the opened nodes and close the document, if space allowed.
** Arguments:   
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_XMB_CloseDocument(
    IN OUT DRM_BYTE    *pbXmlContext,
       OUT DRM_STRING  *pdstrXML);   /* if opened with DRM_XMB_SimulateCreateDocument, this contains the counts of WCHAR's needed for the real string */

DRM_RESULT DRM_API DRM_XMB_OpenNode(
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrNodeName);

DRM_RESULT DRM_API DRM_XMB_SaveState(
    IN OUT   DRM_BYTE  *pbXmlContext,
       OUT   XMBState  *pState);

DRM_RESULT DRM_API DRM_XMB_RestoreState(
    IN OUT   DRM_BYTE  *pbXmlContext,
    IN       XMBState  *pState);


/**********************************************************************
** Function:    DRM_XMB_CloseCurrNode
** Synopsis:    
** Arguments:   [pbXmlContext] -- 
**              [pdstrXMLFragment] -- XML fragment of the current node, optional.
** Returns:     DRM_SUCCESS on success
** Notes:       
**********************************************************************/
DRM_RESULT DRM_API DRM_XMB_CloseCurrNode(
    IN OUT DRM_BYTE   *pbXmlContext,
       OUT DRM_STRING *pdstrXMLFragment);    /* optional: XML fragment of the current node, optional. */

/**********************************************************************
** Function:    DRM_XMB_EncryptAndCloseCurrNode
** Synopsis:    Encrypt and Base64 encode the node (not including the tag)
** Arguments:   [pbXmlContext] -- 
**              [pdstrXMLFragment] -- XML fragment of the current node, optional.
** Returns:     DRM_SUCCESS on success
** Notes:       encryption does not include the tag
***********************************************************************/
DRM_RESULT DRM_API DRM_XMB_EncryptAndCloseCurrNode(
    IN OUT   DRM_BYTE           *pbXmlContext,
    IN       DRM_CRYPTO_CONTEXT *pCryptoContext,    /* Pointer to DRM_CRYPTO_CONTEXT */
    IN const PUBKEY             *pPubkey,           /* pub key to use for encrypt */
       OUT   DRM_STRING         *pdstrXMLFragment); /* optional: XML fragment of the current node, optional. */

/**********************************************************************
** Function:    DRM_XMB_SignAndCloseCurrNode
** Synopsis:    Encrypt and Base64 encode the node (not including the tag)
** Arguments:   [pbXmlContext] -- 
**              [pdstrXMLFragment] -- XML fragment of the current node, optional.
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_XMB_SignAndCloseCurrNode(
    IN OUT   DRM_BYTE           *pbXmlContext,
    IN       DRM_CRYPTO_CONTEXT *pCryptoContext,  /* Pointer to DRM_CRYPTO_CONTEXT */
    IN const PRIVKEY            *pPrivkey,        /* pub key to use for encrypt */
    IN       DRM_BOOL            fIncludeTag,
       OUT   DRM_BYTE            rgbSign    [__CB_DECL(PK_ENC_SIGNATURE_LEN)],       /* cannot be both NULL */
       OUT   DRM_WCHAR           wszB64Sign[PK_ENC_SIGNATURE_B64LEN], /* cannot be both NULL */
       OUT   DRM_STRING         *pdstrXMLFragment); /* optional: XML fragment of the current node, optional. */


DRM_RESULT DRM_API DRM_XMB_KeyedHashAndCloseCurrNode(
    IN OUT   DRM_BYTE           *pbXmlContext,
    IN       HMAC_CONTEXT       *pHmacContext,     /* HMAC context */
    IN const DRM_BYTE           *pbHashkey,        /* Hash key for HMAC */
    IN       DRM_DWORD           cbHashkey,        /* byte count of HMAC */
    IN       DRM_BOOL            fIncludeTag,
    OUT      DRM_BYTE            rgbSign    [__CB_DECL(SHA_DIGEST_LEN)],       /* cannot be both NULL */
    OUT      DRM_WCHAR           wszB64Sign[SHA_B64ENC_DIGEST_LEN], /* cannot be both NULL */
    OUT      DRM_STRING         *pdstrXMLFragment); /* optional: XML fragment of the current node, optional. */


DRM_RESULT DRM_API DRM_XMB_GetCurrNodeName(
    IN  DRM_BYTE   *pbXmlContext,
    OUT DRM_STRING *pdstrNodeName);

DRM_RESULT DRM_API DRM_XMB_GetContextSize(
    IN  DRM_BYTE  *pbXmlContext,
    OUT DRM_DWORD *pcbXmlContext);

DRM_RESULT DRM_API DRM_XMB_AddAttribute(
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrAttrName,
    IN const DRM_CONST_STRING *pdstrAttrValue );

DRM_RESULT DRM_API DRM_XMB_AddData(
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrData );
 
DRM_RESULT DRM_API DRM_XMB_AddCData(
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrCData );

/**********************************************************************
** Function:    DRM_XMB_AppendNode
** Synopsis:    Appends a caller provided node nested from current opened node
** Arguments:   [pdwStamp] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       The caller is responsible for the validity of the appending node
***********************************************************************/
DRM_RESULT DRM_API DRM_XMB_AppendNode(
    IN OUT   DRM_BYTE         *pbXmlContext,
    IN const DRM_CONST_STRING *pdstrXmlString);


/*******************************************************************
 *          PUBLIC FUNCTION DRM_XMB_RequiredCharsForTag
 *
 * purpose: calculates the number of XML characters required for
 *          the indicated tag, optional text, and optional 
 *          attribute label and text
 ******************************************************************/

DRM_DWORD DRM_API DRM_XMB_RequiredCharsForTag (
    IN const DRM_DWORD cchTag,
    IN const DRM_DWORD cchData,
    IN const DRM_DWORD cchAttrLabel,
    IN const DRM_DWORD cchAttrText);

enum WriteTagType
{
    wttOpen,
    wttClosed
};

/*********************************************************************
 *                 PUBLIC FUNCTION DRM_XMB_WriteTag
 *                                                                   
 *      function: write one or both tags of an XML pair              
 *                  and optionally the enclosed data and/or
 *                  a single attribute
 *
 *      if parameter wtt is wttClosed, the tag is closed and the
 *      XML builder insertion point remains at the same scope as
 *      when the function was called
 *
 *        <TAG[ attrlabel="attrtext"]>[data][</TAG>]
 *
 ********************************************************************/

DRM_RESULT DRM_API DRM_XMB_WriteTag (
    IN OUT       DRM_BYTE         *pbDataOut,
    IN     const DRM_CONST_STRING *pdstrTag,
    IN     const DRM_CONST_STRING *pdstrData,
    IN     const DRM_CONST_STRING *pdstrAttrLabel,
    IN     const DRM_CONST_STRING *pdstrAttrText,
    IN     enum  WriteTagType      wtt);

/*********************************************************************
 *             PUBLIC FUNCTION DRM_XMB_WriteCDATATag
 *                                                                   
 * as above but writes a CDATA tag
 ********************************************************************/

DRM_RESULT DRM_API DRM_XMB_WriteCDATATag (
    IN OUT       DRM_BYTE         *pbDataOut,
    IN     const DRM_CONST_STRING *pdstrTag,
    IN     const DRM_CONST_STRING *pdstrCDATA,
    IN     const DRM_CONST_STRING *pdstrAttrLabel,
    IN     const DRM_CONST_STRING *pdstrAttrText,
    IN     enum  WriteTagType      wtt);

DRM_RESULT DRM_API DRM_XMB_RemainingBuffer(
    IN  DRM_BYTE  *f_pbXMB,
    OUT DRM_DWORD *f_pcbRemaining);

#ifdef __cplusplus
}
#endif

#endif      /* __XMLBUILDER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmxmlutilities.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>
#include <drmxmlparser.h>
#include <drmutilities.h>

/******************************************************************************
** 
** Function :   DRM_XMU_MatchNodeFromTemplate
** 
** Synopsis :   Deep compare a XML node with a given template. It will be 
**              considered a match ONLY if all subnodes in the template exist 
**              AND exactly match the subnodes in the template. The node might 
**              be a superset of the template
** 
** Arguments :  f_pdstrXmlNodeList  -   List of XML nodes in which we have to 
**                                      find a match
**              f_pdstrXmlTemplate  -   Template for finding match
**              f_fAttributeMatch   -   Match the first attribute (if any) of 
**                                      each node
**              f_pfMatch           -   TRUE/FALSE indicating match or not
** Returns :    
** 
** Notes :      Example:
**              f_pdstrXmlTemplate  :                 
**                      <KID>xyz</KID>
**                      <META>
**                          <LGPUBKEY>abc</LGPUBKEY>
**                      </META>
**                  
**              f_pdstrXmlNodeList  :   No match (LGPUBKEY different)                  
**                      <KID>xyz</KID>
**                      <LID>pqr</LID>
**                      <META>
**                          <LGPUBKEY>sfsgdgddsg</LGPUBKEY>
**                      </META>
**
**              f_pdstrXmlNodeList  :   No match (KID missing)                  
**                      <META>
**                          <LGPUBKEY>abc</LGPUBKEY>
**                      </META>
**
**              f_pdstrXmlNodeList  :   Exact match 
**                      <KID>xyz</KID>
**                      <LID>pqr</LID>
**                      <META>
**                          <LGPUBKEY>abc</LGPUBKEY>
**                      </META>
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_XMU_MatchNodeFromTemplate(
    IN  const   DRM_CONST_STRING    *f_pdstrXmlNodeList,
    IN  const   DRM_CONST_STRING    *f_pdstrXmlTemplate,
    IN          DRM_BOOL            f_fAttributeMatch,
        OUT     DRM_BOOL            *f_pfMatch)
{
    DRM_RESULT                  dr                      =   DRM_SUCCESS;
    DRM_BOOL                    fIsLeafNode             =   FALSE;
    DRM_CONST_STRING            dstrNextTag             =   EMPTY_DRM_STRING;
    DRM_CONST_STRING            dstrNextNode            =   EMPTY_DRM_STRING;    
    DRM_CONST_STRING            dstrNextNodeData        =   EMPTY_DRM_STRING; 
    DRM_CONST_STRING            dstrMatchingNodeData    =   EMPTY_DRM_STRING;
    DRM_CONST_STRING            dstrXmlNodeList         =   EMPTY_DRM_STRING;
    DRM_CONST_STRING            dstrXmlTemplate         =   EMPTY_DRM_STRING;
    DRM_CONST_STRING            dstrFirstAttrName       =   EMPTY_DRM_STRING;    
    DRM_CONST_STRING            dstrFirstAttrValue      =   EMPTY_DRM_STRING;    
    DRM_CONST_STRING           *pdstrFirstAttrName      =   NULL;
    DRM_CONST_STRING           *pdstrFirstAttrValue     =   NULL;
    
    /*
    **  Check input
    */
    ChkArg(f_pfMatch);
    
    /*
    **  Clear output
    */
    *f_pfMatch = TRUE;

    if (f_fAttributeMatch)
    {
        pdstrFirstAttrName  = &dstrFirstAttrName;
        pdstrFirstAttrValue = &dstrFirstAttrValue;
    }
    
    ASSIGN_DRM_STRING(dstrXmlNodeList, *f_pdstrXmlNodeList);
    ASSIGN_DRM_STRING(dstrXmlTemplate, *f_pdstrXmlTemplate);      
    
    /*
    **  Enumerate all nodes in the template
    **  Loop will break if there is a mismatch
    */
    while(dstrXmlTemplate.cchString > 0)
    {
        INIT_DRM_STRING(dstrNextTag);
        
        /*
        **  Get next node from template
        */
        ChkDR(  DRM_XML_EnumNextNode(
                    &dstrXmlTemplate,
                    &dstrNextTag,
                    &dstrNextNode,
                    &dstrNextNodeData,
                    pdstrFirstAttrName,
                    pdstrFirstAttrValue,
                    &fIsLeafNode)   );
        
        /*
        **  Find matching node in xml tree
        */
        dr  =   DRM_XML_GetNode(
                    &dstrXmlNodeList, 
                    &dstrNextTag, 
                    pdstrFirstAttrName,
                    pdstrFirstAttrValue,
                    0,
                    NULL,
                    &dstrMatchingNodeData);

        if (dr == DRM_E_XMLNOTFOUND
         || dr == DRM_E_INVALIDARG)
        {
            /*
            **  Corresponding node not found in xml tree - Mismatch
            */
            dr = DRM_SUCCESS;
            *f_pfMatch = FALSE;
            break;            
        }
        ChkDR(dr);
        
        if (fIsLeafNode)
        {            
            if (!DRM_UTL_DSTRStringsEqual(
                    &dstrNextNodeData, 
                    &dstrMatchingNodeData) )            
            {
                *f_pfMatch = FALSE;
                break;
            }
        }
        else
        {
            /*
            **  TODO: We might consider removing recursion. However, we do not
            **  expect this recursion to go beyond a few levels. Hence using 
            **  recursion to keep things simple.
            */
            ChkDR(  DRM_XMU_MatchNodeFromTemplate(
                        &dstrMatchingNodeData,
                        &dstrNextNodeData,
                        f_fAttributeMatch,
                        f_pfMatch)  );
            if (!(*f_pfMatch))
            {
                break;
            }                        
        }   
        
        /*
        **  Advance the template buffer
        */
        dstrXmlTemplate.pwszString  +=  dstrNextNode.cchString;
        dstrXmlTemplate.cchString   -=  dstrNextNode.cchString;        
       
    }   /*  End of while(TRUE) loop */
    
ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\generatedacrequest.c ===
/**@@@+++@@@@******************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//*@@@---@@@@******************************************************************/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <drmpkcrypto.h>
#include <drmlicense.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <stdio.h>

#include <drmtoolsconstants.h>
#include <drmtoolsmacros.h>
#include <drmtoolsutils.h>

typedef struct DRMSTATE
{
    PUBKEY              pubkeyDAC;
    PRIVKEY             privkeyDAC;
    PUBKEY              pubkeyFallback;
    PRIVKEY             privkeyFallback; 
    DRM_STRING          dstrPubKeyDAC;
    DRM_STRING          dstrPrivKeyDAC;
    DRM_STRING          dstrPubKeyFallback;
    DRM_STRING          dstrPrivKeyFallback;     
    FILE                *fpDACRequest;
    FILE                *fpOEMPrivKeys;
    DRM_BYTE            *pbXML;
    DRM_CRYPTO_CONTEXT  *pcontextCrypto;
}DRMSTATE;

/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] [-r:DACRequestFile]  [-p:PrivateKeyFile]\n", pwszAppName);
}

/******************************************************************************
** 
** Function :   DRMInit
** 
** Synopsis :   
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRMInit(DRMSTATE **f_ppState)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkMem  (*f_ppState = (DRMSTATE*) OEM_malloc(SIZEOF(DRMSTATE)));
    ZEROMEM (*f_ppState, SIZEOF(DRMSTATE));
    ChkMem ((*f_ppState)->pcontextCrypto = (DRM_CRYPTO_CONTEXT *)OEM_malloc(SIZEOF(DRM_CRYPTO_CONTEXT)));
    ZEROMEM((*f_ppState)->pcontextCrypto, SIZEOF(DRM_CRYPTO_CONTEXT));

    ChkMem((*f_ppState)->pbXML = (DRM_BYTE*) OEM_malloc(XML_INIT_SIZE));
    ZEROMEM((*f_ppState)->pbXML, XML_INIT_SIZE);

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRMClose
** 
** Synopsis :   
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
void DRMClose(DRMSTATE **f_ppState)
{
    if (f_ppState == NULL || *f_ppState == NULL)
    {
        return;
    }
    
    if ((*f_ppState)->fpDACRequest != NULL)
    {
        fclose((*f_ppState)->fpDACRequest);
    }
    if ((*f_ppState)->fpOEMPrivKeys != NULL)
    {
        fclose((*f_ppState)->fpOEMPrivKeys);
    }
    if ((*f_ppState)->pcontextCrypto)
    {
        OEM_free((*f_ppState)->pcontextCrypto);
    }
    if ((*f_ppState)->dstrPubKeyDAC.pwszString != NULL)
    {
        OEM_free((*f_ppState)->dstrPubKeyDAC.pwszString);
    }
    if ((*f_ppState)->dstrPrivKeyDAC.pwszString != NULL)
    {
        OEM_free((*f_ppState)->dstrPrivKeyDAC.pwszString);
    }
    if ((*f_ppState)->dstrPubKeyFallback.pwszString != NULL)
    {
        OEM_free((*f_ppState)->dstrPubKeyFallback.pwszString);
    }
    if ((*f_ppState)->dstrPrivKeyFallback.pwszString != NULL)
    {
        OEM_free((*f_ppState)->dstrPrivKeyFallback.pwszString);
    }
    if ((*f_ppState)->pbXML)
    {
        OEM_free((*f_ppState)->pbXML);
    }
    OEM_free(*f_ppState);

    *f_ppState = NULL;    
}

/******************************************************************************
** 
** Function :   _ReallocXmlContext
** 
** Synopsis :   Allocate double the size of the current context
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT
_ReallocXmlContext(
    DRM_BYTE **f_ppbXmlContext)
{
    DRM_RESULT  dr              = DRM_SUCCESS;
    DRM_DWORD   cbXmlContext    = 0;
    DRM_BYTE   *pbNewXmlContext = NULL;

    ChkDR(DRM_XMB_GetContextSize(*f_ppbXmlContext, 
                                 &cbXmlContext));  /* get current size */
    
    /* alloc double of the current size */
    ChkMem(pbNewXmlContext = (DRM_BYTE*)OEM_malloc(2 * cbXmlContext));  

    
    ChkDR(DRM_XMB_ReallocDocument(*f_ppbXmlContext,    
                                   2 * cbXmlContext, 
                                   pbNewXmlContext));
    
    OEM_free(*f_ppbXmlContext);
    *f_ppbXmlContext = pbNewXmlContext;

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   _CreateDACRequest
** 
** Synopsis :   
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
**
**  <RequestDAC>
**      <DAC><PUBKEY>base64 encoded DAC public key</PUBKEY></DAC>
**      <FALLBACK>
**          <PUBKEY>base64 encoded FALLBACKVERIFICATION public key</PUBKEY>
**      </FALLBACK>
**  </RequestDAC>
**
******************************************************************************/
DRM_RESULT _CreateDACRequest(IN DRMSTATE *f_pState)
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_STRING dstrClose = EMPTY_DRM_STRING;
    DRM_DWORD  cbWrite   = 0;
    DRM_DWORD  cbWritten = 0;
    
    ChkDR(DRM_XMB_CreateDocument(XML_INIT_SIZE, 
                                 f_pState->pbXML, 
                                &g_dstrTagRequestDAC));

    CallXmlBuilder(f_pState->pbXML, DRM_XMB_OpenNode(f_pState->pbXML, &g_dstrTagDAC));

    CallXmlBuilder(f_pState->pbXML, 
                    DRM_XMB_WriteTag(f_pState->pbXML, 
                                      &g_dstrTagDataPubKey, 
                                      (DRM_CONST_STRING *)&(f_pState->dstrPubKeyDAC),
                                      NULL,
                                      NULL,
                                      wttClosed));
    CallXmlBuilder(f_pState->pbXML, 
        DRM_XMB_CloseCurrNode(f_pState->pbXML, NULL));

    CallXmlBuilder(f_pState->pbXML, 
        DRM_XMB_OpenNode(f_pState->pbXML, &g_dstrTagFallback));

    CallXmlBuilder(f_pState->pbXML, 
                    DRM_XMB_WriteTag(f_pState->pbXML, 
                                      &g_dstrTagDataPubKey, 
                                      (DRM_CONST_STRING *)&(f_pState->dstrPubKeyFallback),
                                      NULL,
                                      NULL,
                                      wttClosed));
    CallXmlBuilder(f_pState->pbXML, 
        DRM_XMB_CloseCurrNode(f_pState->pbXML, NULL));    

    /*
    **  close the root node
    */
    CallXmlBuilder(f_pState->pbXML, 
        DRM_XMB_CloseDocument(f_pState->pbXML, &dstrClose));

    cbWrite   = SIZEOF( g_rgbFFFE );

    cbWritten = fwrite((DRM_BYTE*)g_rgbFFFE, 1, cbWrite, f_pState->fpDACRequest);
    
    if (cbWritten != cbWrite)
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }

    cbWrite   = CB_DSTR(&dstrClose);

    cbWritten = fwrite(dstrClose.pwszString, 1, cbWrite, f_pState->fpDACRequest);
    
    if (cbWritten != cbWrite)
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   _CreateOEMPrivKeys
** 
** Synopsis :   
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
**
**  <OEMPrivateKeys>
**      <DAC><PRIVKEY>base64 encoded DAC private key</PRIVKEY></DAC>
**      <FALLBACK>
**          <PRIVKEY>base64 encoded FALLBACKVERIFICATION private key</PRIVKEY>
**      </FALLBACK>
**  </OEMPrivateKeys>
**
******************************************************************************/
DRM_RESULT _CreateOEMPrivKeys(IN DRMSTATE *f_pState)
{
    DRM_RESULT dr          = DRM_SUCCESS;
    DRM_STRING dstrClose   = EMPTY_DRM_STRING;
    DRM_DWORD  cbWrite     = 0;
    DRM_DWORD  cbWritten   = 0;
    
    ChkDR(DRM_XMB_CreateDocument(XML_INIT_SIZE, 
                                   f_pState->pbXML, 
                                   &g_dstrTagOEMPrivateKeys));

    CallXmlBuilder(f_pState->pbXML, 
        DRM_XMB_OpenNode(f_pState->pbXML, &g_dstrTagDAC));

    CallXmlBuilder(f_pState->pbXML, 
                    DRM_XMB_WriteTag(f_pState->pbXML, 
                                    &g_dstrTagPrivkey, 
                                    (DRM_CONST_STRING *)&(f_pState->dstrPrivKeyDAC),
                                     NULL,
                                     NULL,
                                     wttClosed));
    CallXmlBuilder(f_pState->pbXML, 
        DRM_XMB_CloseCurrNode(f_pState->pbXML, NULL));

    CallXmlBuilder(f_pState->pbXML, 
        DRM_XMB_OpenNode(f_pState->pbXML, &g_dstrTagFallback));

    CallXmlBuilder(f_pState->pbXML, 
                    DRM_XMB_WriteTag(f_pState->pbXML, 
                                      &g_dstrTagPrivkey, 
                                      (DRM_CONST_STRING *)&(f_pState->dstrPrivKeyFallback),
                                      NULL,
                                      NULL,
                                      wttClosed));
    CallXmlBuilder(f_pState->pbXML, 
        DRM_XMB_CloseCurrNode(f_pState->pbXML, NULL));    

    /*
    **  close the root node
    */
    CallXmlBuilder(f_pState->pbXML, 
        DRM_XMB_CloseDocument(f_pState->pbXML, &dstrClose));

    cbWrite   = SIZEOF( g_rgbFFFE );

    cbWritten = fwrite((DRM_BYTE*)g_rgbFFFE, 1, cbWrite, f_pState->fpOEMPrivKeys);
    
    if (cbWritten != cbWrite)
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }

    cbWrite = CB_DSTR(&dstrClose);

    cbWritten = fwrite(dstrClose.pwszString, 
                       1, 
                       cbWrite, 
                       f_pState->fpOEMPrivKeys);
    if (cbWritten != cbWrite)
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }
    
ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   CreateDACRequest
** 
** Synopsis :   
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT CreateDACRequest(DRMSTATE *f_pState)
{

    DRM_RESULT                  dr = DRM_SUCCESS;
    
    ChkDR(DRMTOOLS_CreateKeyPair(f_pState->pcontextCrypto,
                               &(f_pState->pubkeyDAC), 
                               &(f_pState->privkeyDAC), 
                               &(f_pState->dstrPubKeyDAC),
                               &(f_pState->dstrPrivKeyDAC)));

    ChkDR(DRMTOOLS_CreateKeyPair(f_pState->pcontextCrypto,
                               &(f_pState->pubkeyFallback),
                               &(f_pState->privkeyFallback), 
                               &(f_pState->dstrPubKeyFallback),
                               &(f_pState->dstrPrivKeyFallback)));  

    printf("Creating DAC Request...\n");
    ChkDR(_CreateDACRequest(f_pState));
    printf("Creating Private key file...\n");
    ChkDR(_CreateOEMPrivKeys(f_pState));
    
ErrorExit:
   return dr;
}

DRM_VOID DRM_API 
wmain(
    DRM_INT     argc, 
    DRM_WCHAR** argv)
{
    DRM_RESULT       dr                      = DRM_SUCCESS;
    DRM_CONST_STRING dstrDACRequestFile      = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrOEMPrivateKeyFile   = EMPTY_DRM_STRING;    
    DRM_INT          iParam                  = 0;
    DRMSTATE        *pState                  = NULL;
    DRM_CHAR         rgchFile [MAX_FILENAME + 1] = { 0 };
    
    printf("Microsoft (R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "DAC Creation Tool");

    /*
    **  Check input
    */
    if (argc != 3)
    {
        goto _PrintUsage;
    }

    for (iParam = 1; iParam < argc; iParam++)
    {
        DRM_WCHAR        wchOption = 0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;
        
        if (!DRM_CMD_ParseCmdLine(argv[iParam], &wchOption, &dstrParam, NULL))
        {
            goto _PrintUsage;
        }
        
        switch(towlower(wchOption))
        {
        case WCHAR_CAST('r'):  
            ASSIGN_DRM_STRING(dstrDACRequestFile, dstrParam);
            break;
                    
        case WCHAR_CAST('p'):  
            ASSIGN_DRM_STRING(dstrOEMPrivateKeyFile, dstrParam);
            break;
            
        default:
            goto _PrintUsage;
        }
    }

    if (dstrDACRequestFile.cchString    == 0 
     || dstrOEMPrivateKeyFile.cchString == 0) 
    {
        goto _PrintUsage;
    }
 
    if (dstrDACRequestFile.cchString    > MAX_FILENAME 
     || dstrOEMPrivateKeyFile.cchString > MAX_FILENAME)
    {
        printf("File name is too big. Max Filename is %d \n", MAX_FILENAME);
        goto ErrorExit;
    }

    /*
    **  Initialize state
    */
    ChkDR(DRMInit(&pState));

    DRM_UTL_DemoteUNICODEtoANSI(dstrDACRequestFile.pwszString, 
                                rgchFile, 
                                dstrDACRequestFile.cchString);
    
    rgchFile [dstrDACRequestFile.cchString] = '\0';
    
    pState->fpDACRequest = (FILE *) fopen(rgchFile, "w+b");

    if (pState->fpDACRequest == NULL)
    {
        printf("DAC Request file could not be opened\n");
        goto ErrorExit;
    }

    DRM_UTL_DemoteUNICODEtoANSI(dstrOEMPrivateKeyFile.pwszString, 
                                rgchFile, 
                                dstrOEMPrivateKeyFile.cchString);

    rgchFile [dstrOEMPrivateKeyFile.cchString] = '\0';
    
    pState->fpOEMPrivKeys= (FILE *) fopen (rgchFile, "w+b");

    if (pState->fpOEMPrivKeys == NULL)
    {
        printf("OEM private key file could not be opened\n");
        goto ErrorExit;
    }

    printf("Processing Request...\n");
    ChkDR(CreateDACRequest(pState));
    printf("Done.\n");
    
ErrorExit:
    
    if (pState)
    {
        DRMClose(&pState);
    }

    return;
_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmxmlparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMXMLPARSER_H__
#define __DRMXMLPARSER_H__

#include <drmcommon.h>
#include <drmresults.h>
#include <drmtypes.h>
#include <drmlicense.h>
#include <drmhmac.h>

#ifdef __cplusplus
extern "C" {
#endif

/* UNICODE  */

/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_RESULT DRM_API DRM_XML_GetNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,            /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,       /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData);  /* data enclosed by the immediate <tag>...</tag> in the given XML string */

/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_RESULT DRM_API DRM_XML_GetAndDecryptNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,           /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pCryptoContext,    /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  PRIVKEY                *f_pPrivkey,          /* priv key to use for decrypt */
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,      /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData); /* data enclosed by the immediate <tag>...</tag> in the given XML string */

/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_RESULT DRM_API DRM_XML_GetAndVerifyNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,           /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pCryptoContext,    /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  const PUBKEY           *f_pPubkey,           /* pub key to use for verify */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,      /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData); /* data enclosed by the immediate <tag>...</tag> in the given XML string */

#define DRM_XML_HASH_INCLUDE_TAGS   TRUE
#define DRM_XML_HASH_EXCLUDE_TAGS   FALSE

DRM_RESULT DRM_API DRM_XML_GetAndVerifyKeyedHashNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,            /* nth occurence of the node in the xml stirng, start from 0 */
    IN  HMAC_CONTEXT           *f_pHmacContext,       /* HMAC context */
    IN  DRM_BYTE               *f_pbHashkey,          /* Hash key for HMAC */
    IN  DRM_DWORD               f_cbHashkey,          /* byte count of HMAC */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,       /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData);  /* data enclosed by the immediate <tag>...</tag> in the given XML string */

/*
** 
*/
DRM_RESULT DRM_API DRM_XML_GetNodeAttribute(
    IN const DRM_CONST_STRING *f_pdstrXMLNode,    /* the topmost node in this XML string will be worked on */
    IN const DRM_CONST_STRING *f_pdstrAttrName,   /* attrName to retrieve */
    OUT      DRM_CONST_STRING *f_pdstrAttrValue);	/* returned attrValue */

/*
** extract the CDATA section from a given XML node
*/
DRM_RESULT DRM_API DRM_XML_GetNodeCData(
    IN const DRM_CONST_STRING *f_pdstrXMLNode,     /* the topmost node in this XML string will be worked on */
    OUT      DRM_CONST_STRING *f_pdstrCData);      /* returned CData */

/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_RESULT DRM_API DRM_XML_GetSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,          /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,     /* these two parameters can either be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData,
    IN  DRM_DWORD               f_iLayer);     /* outermost layer is 0 */

/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_RESULT DRM_API DRM_XML_GetAndDecryptSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,        /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pCryptoContext, /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  PRIVKEY                *f_pPrivkey,       /* priv key to use for decrypt */
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,   /* these two parameters can either be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData,
    IN  DRM_DWORD               f_iLayer);   /* outermost layer is 0 */

/*
** extract license node from given XML string matching <tag AttrName="Value"> ... </tag>
*/
DRM_RESULT DRM_API DRM_XML_GetAndVerifySubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,          /* nth occurence of the node in the xml stirng, start from 0 */
    IN  DRM_CRYPTO_CONTEXT     *f_pCryptoContext,   /* Pointer to DRM_CRYPTO_CONTEXT */
    IN  const PUBKEY           *f_pPubkey,          /* pub key to use for verify */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,     /* these two parameters can either be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData,
    IN  DRM_DWORD               f_iLayer);     /* outermost layer is 0 */


DRM_RESULT DRM_API DRM_XML_GetAndVerifyKeyedHashSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD         f_iNode,          /* nth occurence of the node in the xml stirng, start from 0 */
    IN  HMAC_CONTEXT           *f_pHmacContext,     /* HMAC context */
    IN  DRM_BYTE               *f_pbHashkey,        /* Hash key for HMAC */
    IN  DRM_DWORD               f_cbHashkey,        /* byte count of HMAC */
    IN  DRM_BOOL                f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,     /* either of these 2 parameter can be NULL but not both */
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData, /* data enclosed by the immediate <tag>...</tag> in the given XML string */
    IN  DRM_DWORD               f_iLayer);     /* outermost layer is 0 */

DRM_RESULT DRM_API DRM_XML_GetSubNodeByPath(
    IN const DRM_CONST_STRING* pdstrXML, 
    IN const DRM_CONST_STRING *f_pdstrXMLNodeString, 
    IN const DRM_CONST_STRING *f_pdstrAttrName, 
    IN const DRM_CONST_STRING *f_pdstrAttrValue,
    OUT      DRM_CONST_STRING *f_pdstrResultXML, 
    OUT      DRM_CONST_STRING *f_pdstrResultXMLData,
    IN       DRM_WCHAR         f_chSeparator);


DRM_RESULT DRM_API DRM_XML_EnumNextNode(
    IN const DRM_CONST_STRING *f_pdstrXML,
       OUT   DRM_CONST_STRING *f_pdstrTag,
       OUT   DRM_CONST_STRING *f_pdstrXMLNode,       /* either of these 2 parameter can be NULL but not both */
       OUT   DRM_CONST_STRING *f_pdstrXMLNodeData,
       OUT   DRM_CONST_STRING *f_pdstr1stAttrName,   /* optional */
       OUT   DRM_CONST_STRING *f_pdstr1stAttrValue,  /* optional */
       OUT   DRM_BOOL         *f_pfIsLeafNode);

DRM_RESULT DRM_API DRM_XML_EnumNextSubNode(
    IN const DRM_CONST_STRING *f_pdstrXML,
       OUT   DRM_CONST_STRING *f_pdstrTag,
       OUT   DRM_CONST_STRING *f_pdstrXMLNode,     /* these two parameters can either be NULL but not both */
       OUT   DRM_CONST_STRING *f_pdstrXMLNodeData,
       OUT   DRM_CONST_STRING *f_pdstr1stAttrName,   /* optional */
       OUT   DRM_CONST_STRING *f_pdstr1stAttrValue,  /* optional */
       OUT   DRM_BOOL         *f_pfIsLeafNode,
    IN       DRM_DWORD         f_iLayer);      /* outermost layer is 0 */

/* ANSI  */

DRM_RESULT DRM_API DRM_XML_GetNodeA(
    IN  const DRM_CHAR              *f_pszBase,
    IN  const DRM_SUBSTRING         *f_padstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_padstrTag,
    IN  const DRM_ANSI_CONST_STRING *f_padstrAttrName,
    IN  const DRM_ANSI_CONST_STRING *f_padstrAttrValue,
    IN  const DRM_DWORD              f_iNode,             /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_SUBSTRING               *f_psubstrXMLNode,      /* either of these 2 parameter can be NULL but not both */
    OUT DRM_SUBSTRING               *f_psubstrXMLNodeData); /* data enclosed by the immediate <tag>...</tag> in the given XML string */

DRM_RESULT DRM_API DRM_XML_GetSubNodeA(
    IN  const DRM_CHAR              *f_pszBase,
    IN  const DRM_SUBSTRING         *f_padstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_padstrTag,
    IN  const DRM_ANSI_CONST_STRING *f_padstrAttrName,
    IN  const DRM_ANSI_CONST_STRING *f_padstrAttrValue,
    IN  const DRM_DWORD              f_iNode,           /* nth occurence of the node in the xml stirng, start from 0 */
    OUT DRM_SUBSTRING               *f_psubstrXMLNode,      /* either of these 2 parameter can be NULL but not both */
    OUT DRM_SUBSTRING               *f_psubstrXMLNodeData, /* data enclosed by the immediate <tag>...</tag> in the given XML string */
    IN  DRM_DWORD                    f_iLayer);      /* outermost layer is 0 */

DRM_RESULT DRM_API DRM_XML_GetNodeAttributeA(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_padstrXML,
    IN const DRM_ANSI_CONST_STRING *f_padstrAttrName,   /* attrName to retrieve */
       OUT   DRM_SUBSTRING         *f_psubstrAttrValue); /* returned attrValue */

DRM_RESULT DRM_API DRM_XML_EnumNextNodeA(
    IN const DRM_CHAR         *f_pszBase,
    IN const DRM_SUBSTRING    *f_pdasstrXML,
    IN const DRM_DWORD         f_iNode,
       OUT   DRM_SUBSTRING    *f_pdasstrTag,
       OUT   DRM_SUBSTRING    *f_pdasstrNode,          /* either of these 2 parameter can be NULL but not both */
       OUT   DRM_SUBSTRING    *f_pdasstrNodeData,      /* data enclosed by the immediate <tag>...</tag> in the given XML string */
       OUT   DRM_SUBSTRING    *f_pdasstr1stAttrName,   /* optional */
       OUT   DRM_SUBSTRING    *f_pdasstr1stAttrValue); /* optional */

DRM_RESULT DRM_API DRM_XML_CountMatchingNodesA(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrXML,
    IN const DRM_ANSI_CONST_STRING *f_pdasstrTag,
    IN       DRM_ANSI_CONST_STRING *f_pdasstr1stAttrName,  /* optional */
    IN       DRM_ANSI_CONST_STRING *f_pdasstr1stAttrValue, /* optional */
       OUT   DRM_DWORD             *f_cMatchingNodes);

DRM_BOOL DRM_API DRM_XML_Validate( IN const DRM_CONST_STRING *f_pdstrXML );

#ifdef __cplusplus
}
#endif

#endif      /* __DRMXMLPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\generatedevcerttemplate.c ===
/**@@@+++@@@@*****************************************************************
 *
 * Microsoft Windows Media
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *
 **@@@---@@@@*****************************************************************/
#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <drmpkcrypto.h>
#include <drmlicense.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <stdio.h>

#include <drmtoolsconstants.h>
#include <drmtoolsmacros.h>
#include <drmtoolsutils.h>

typedef struct DRMSTATE
{  
    DRM_STRING          dstrDACResponse;
    DRM_STRING          dstrAuthCert;
    DRM_STRING          dstrAuthRootCert;
    DRM_STRING          dstrUnsignedTemplate;
    DRM_STRING          dstrOEMPrivKeys;
    OEM_FILEHDL         fpDevcertTemplate;
    FILE                *fpDeviceKeys;
    PUBKEY              pubkeyGC;
    PRIVKEY             privkeyGC;
    PRIVKEY             privkeyDAC;
    PRIVKEY             privkeyFallback;
    DRM_STRING          dstrGCPubKey;
    DRM_STRING          dstrGCPrivKey;
    DRM_STRING          dstrFalbackPrivKey;
    DRM_STRING          dstrSecurityVersion;
    DRM_BYTE            *pbTemplate;
    DRM_CRYPTO_CONTEXT  *pcontextCrypto;
}DRMSTATE;

#define SIGNED_TEMPLATE_EXTRA_SIZE 2048
#define PRIVKEY_FILE_SIZE          2048
#define OBFBYTESLEN	               4096

        

/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] -d:DACResponseFile -u:UnsignedTemplate -f:OEMPrivateKeyFile -t:DevcerttemplateFile -k:KeyFile\n", pwszAppName);
}

/******************************************************************************
** 
** Function :   DRMInit
** 
** Synopsis :   Initialize the internal context data structure
** 
** Arguments :  f_ppState
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRMInit(DRMSTATE **f_ppState)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg(f_ppState != NULL);
    
    ChkMem(*f_ppState = (DRMSTATE*) OEM_malloc(SIZEOF(DRMSTATE)));
    MEMSET(*f_ppState, 0, SIZEOF(DRMSTATE));
    ChkMem((*f_ppState)->pcontextCrypto = 
            (DRM_CRYPTO_CONTEXT *)OEM_malloc(SIZEOF(DRM_CRYPTO_CONTEXT)));
    MEMSET((*f_ppState)->pcontextCrypto, 0, SIZEOF(DRM_CRYPTO_CONTEXT));
    
    (*f_ppState)->fpDevcertTemplate       = OEM_INVALID_HANDLE_VALUE;
    (*f_ppState)->fpDeviceKeys            = NULL;   
    
ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRMClose
** 
** Synopsis :   Shutdown the internal context data structure, free allocated
**              buffers and file pointers
** 
** Arguments :  f_ppState
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
void DRMClose(DRMSTATE **f_ppState)
{
    if (f_ppState == NULL || *f_ppState == NULL)
    {
        return;
    }
    
    if ((*f_ppState)->dstrDACResponse.pwszString != NULL)
    {
        OEM_free((*f_ppState)->dstrDACResponse.pwszString);
    }
    if ((*f_ppState)->dstrUnsignedTemplate.pwszString != NULL)
    {
        OEM_free((*f_ppState)->dstrUnsignedTemplate.pwszString);
    }
    if ((*f_ppState)->dstrOEMPrivKeys.pwszString != NULL)
    {
        OEM_free((*f_ppState)->dstrOEMPrivKeys.pwszString);
    }
    
    if ((*f_ppState)->fpDevcertTemplate != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile((*f_ppState)->fpDevcertTemplate);
    }    
    if ((*f_ppState)->fpDeviceKeys != NULL)
    {
        fclose((*f_ppState)->fpDeviceKeys);
    }    
     
    if ((*f_ppState)->pbTemplate != NULL)
    {
        OEM_free((*f_ppState)->pbTemplate);
    }
    
    if ((*f_ppState)->pcontextCrypto)
    {
        OEM_free((*f_ppState)->pcontextCrypto);
    }
    
    OEM_free(*f_ppState);
    *f_ppState = NULL;    
}

/******************************************************************************
** 
** Function :   _ParseDACResponse
** 
** Synopsis :   
** 
** Arguments :  
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT _ParseDACResponse(DRMSTATE *f_pState)
{
    DRM_RESULT                  dr              =   DRM_SUCCESS;
    
    ChkArg(f_pState != NULL);

    ChkDR(DRM_XML_GetSubNode((DRM_CONST_STRING *)&(f_pState->dstrDACResponse), 
                               &g_dstrTagCertificate, 
                               &g_dstrAttributeType,
                               &g_dstrCerttypeAuth, 
                               0, 
                               (DRM_CONST_STRING *)&(f_pState->dstrAuthCert), 
                               NULL,
                               1));

    ChkDR(DRM_XML_GetSubNode((DRM_CONST_STRING *)&(f_pState->dstrDACResponse), 
                               &g_dstrTagCertificate, 
                               &g_dstrAttributeType,
                               &g_dstrCerttypeAuthRoot, 
                               0, 
                               (DRM_CONST_STRING *)&(f_pState->dstrAuthRootCert), 
                               NULL,
                               1));

    ChkDR(DRM_XML_GetSubNodeByPath((DRM_CONST_STRING *)&(f_pState->dstrDACResponse), 
                                     &g_dstrXPathFallbackSecVer, 
                                     NULL,
                                     NULL, 
                                     NULL,
                                     (DRM_CONST_STRING *)&(f_pState->dstrSecurityVersion),
                                     g_wchForwardSlash));    
ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   _ObtainOEMKeys
** 
** Synopsis :   Parses the OEM key file to obtain the necessary private keys
** 
** Arguments :  f_pState
** 
** Returns :    
** 
** Notes :   
**  
**  <OEMPrivateKeys>
**      <DAC><PRIVKEY>base64 encoded DAC private key</PRIVKEY></DAC>
**      <FALLBACK>
**          <PRIVKEY>base64 encoded FALLBACKVERIFICATION private key</PRIVKEY>
**      </FALLBACK>
**  </OEMPrivateKeys>

** 
******************************************************************************/
DRM_RESULT _ObtainOEMKeys(DRMSTATE *f_pState)
{
    DRM_CONST_STRING dstrPrivKey = EMPTY_DRM_STRING;
    DRM_RESULT       dr          = DRM_SUCCESS;    
    DRM_DWORD        cbSize      = 0;
    DRM_DWORD        cbRead      = 0;
    
    /*
    **  Validate input
    */
    ChkArg(f_pState != NULL);
   
    /*
    **  Parse XML to get the DAC private key
    */
    ChkDR(DRM_XML_GetSubNodeByPath((DRM_CONST_STRING *)&(f_pState->dstrOEMPrivKeys),
                                     &g_dstrXPathDACPrivKey,
                                     NULL,
                                     NULL,
                                     NULL,
                                     (DRM_CONST_STRING *)&dstrPrivKey,
                                     g_wchForwardSlash));
    
    /*
    **  Decode this to get the private key
    */    
    cbSize = PK_ENC_PRIVATE_KEY_LEN;
    ChkDR(DRM_B64_DecodeW(&dstrPrivKey, 
                           &cbSize, 
                           (DRM_BYTE*)&(f_pState->privkeyDAC), 
                           0));

    /*
    **  Parse XML to get the Fallback private key
    */
    ChkDR(DRM_XML_GetSubNodeByPath((DRM_CONST_STRING *)&(f_pState->dstrOEMPrivKeys),
                                     &g_dstrXPathFallbackPrivKey,
                                     NULL,
                                     NULL,
                                     NULL,
                                     (DRM_CONST_STRING *)&(f_pState->dstrFalbackPrivKey),
                                     g_wchForwardSlash)); 

    /*
    **  Decode this to get the private key
    */    
    cbSize = PK_ENC_PRIVATE_KEY_LEN;
    ChkDR(DRM_B64_DecodeW((DRM_CONST_STRING *)&(f_pState->dstrFalbackPrivKey),
                           &cbSize, 
                           (DRM_BYTE*)&(f_pState->privkeyFallback), 
                           0));   
    
ErrorExit:
   return dr;
}

/******************************************************************************
** 
** Function :   VerifyDevcert
** 
** Synopsis :   Verify the signatures on the devcerts
** 
** Arguments :  f_pState    --
**              f_pdstrDevcertTemplate  --
** 
** Returns :    
** 
** Notes :   
**  
** 
******************************************************************************/
DRM_RESULT VerifyDevcert( IN DRMSTATE   *f_pState,
                          IN DRM_STRING *f_pdstrDevcertTemplate )
{
    DRM_RESULT  dr = DRM_SUCCESS;
    
    ChkDR( DRM_DCP_VerifyDeviceCert( (DRM_CONST_STRING *)f_pdstrDevcertTemplate,
                                     DRM_DCP_VERIFY_GROUP_CERT | DRM_DCP_VERIFY_DAC,
                                     f_pState->pcontextCrypto ) );    
    
ErrorExit:
   return dr;
}

/******************************************************************************
** 
** Function :   GenerateDevcert
** 
** Synopsis :   Generate the devcert
** 
** Arguments :  f_pState
** 
** Returns :    
** 
** Notes :   
**  
** 
******************************************************************************/
DRM_RESULT GenerateDevcert(DRMSTATE *f_pState)
{
    DRM_BYTE        rgbSignature[PK_ENC_SIGNATURE_LEN] = {0};    
    DRM_BOOL        fResult         = FALSE;
    DRM_DWORD       dwApproxSize    = 0;
    DRM_DWORD       cbWritten       = 0;
    DRM_RESULT      dr              = DRM_SUCCESS;
    DRM_STRING      dstrClose       = EMPTY_DRM_STRING;
    DRM_STRING      dstrSignature   = EMPTY_DRM_STRING;
    DRM_STRING      dstrGroupData   = EMPTY_DRM_STRING;
    
    ChkDR(_ParseDACResponse(f_pState));
        
    /*
    **  Allocate buffer for devcert template
    */
    dwApproxSize = CB_DSTR(&(f_pState->dstrAuthCert)) 
                 + CB_DSTR(&(f_pState->dstrAuthRootCert))
                 + CB_DSTR(&(f_pState->dstrUnsignedTemplate))
                 + SIGNED_TEMPLATE_EXTRA_SIZE;  
    
    ChkMem(f_pState->pbTemplate = (DRM_BYTE*) OEM_malloc(dwApproxSize));
    MEMSET(f_pState->pbTemplate, 0, dwApproxSize);

    /*
    **  Generate a GC private public keypair
    */
    ChkDR(DRMTOOLS_CreateKeyPair(f_pState->pcontextCrypto,
                                   &(f_pState->pubkeyGC),
                                   &(f_pState->privkeyGC),
                                   &(f_pState->dstrGCPubKey), 
                                   &(f_pState->dstrGCPrivKey)));

    /*
    **  Create Devcert template document
    */
    ChkDR(DRM_XMB_CreateDocument(dwApproxSize, f_pState->pbTemplate, &g_dstrTagDevCert));

    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_AddAttribute(f_pState->pbTemplate, 
                                          &g_dstrAttributeVersion, 
                                          &g_dstrVersion_1_0));

    /*  <CERTIFICATE type="device"> */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_OpenNode(f_pState->pbTemplate, &g_dstrTagCertificate));
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_AddAttribute(f_pState->pbTemplate, 
                                          &g_dstrAttributeType,
                                          &g_dstrCertTypeDevice));

    /*  <DATA>  */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_OpenNode(f_pState->pbTemplate, &g_dstrTagData));

    /*  <UNIQUEID private=\"1\">CgoKCgoKCgoKCgoKCgoKCgoKCgo=</UNIQUEID> */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_WriteTag(f_pState->pbTemplate, 
                                      &g_dstrTagDNIUniqueID, 
                                      NULL,
                                      &g_dstrRootSigValueVersionTag,
                                      &g_dstrRootSigValueVersionVal,
                                      wttClosed));

    /*  <PUBLICKEY private=\"1\">Device public key</PUBLICKEY> */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_WriteTag(f_pState->pbTemplate, 
                                      &g_dstrTagDataPubKey, 
                                      NULL,
                                      &g_dstrRootSigValueVersionTag,
                                      &g_dstrRootSigValueVersionVal,
                                      wttClosed));

    /*  <KEYDATA> 
            template for Device Private key encrypted using the GC Public Key 
        </KEYDATA>   */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_WriteTag(f_pState->pbTemplate, 
                                      &g_dstrPFRootTag, 
                                      NULL,
                                      NULL,
                                      NULL,
                                      wttClosed));

    /*  Close the data node */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_CloseCurrNode(f_pState->pbTemplate, NULL));

    /*  <MSDRM_SIGNATURE_VALUE> 
            template for Signature over DATA using GC private key 
        </MSDRM_SIGNATURE_VALUE>   */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_WriteTag(f_pState->pbTemplate, 
                                      &g_dstrTagMSDRMSignature, 
                                      NULL,
                                      NULL,
                                      NULL,
                                      wttClosed));

/*
**  #if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS  
**  Doesn't hurt to always have this node
*/


    /*  <SYMSIGNATURE> </SYMSIGNATURE>   */
    CallXmlBuilder( f_pState->pbTemplate, 
                    DRM_XMB_WriteTag(f_pState->pbTemplate, 
                                      &g_dstrTagSymSig, 
                                      NULL,
                                      NULL,
                                      NULL,
                                      wttClosed ) );
/*
**  #endif     
*/

    /*  Close the certificate node */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_CloseCurrNode(f_pState->pbTemplate, NULL));


    /*  <FALLBACK>  */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_OpenNode(f_pState->pbTemplate, &g_dstrTagFallback));

    /*  <SECURITYVERSION>2.3.101.0</SECURITYVERSION>    */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_WriteTag(f_pState->pbTemplate, 
                                      &g_dstrTagSecurityVersion, 
                                      (DRM_CONST_STRING *)&(f_pState->dstrSecurityVersion),
                                      NULL,
                                      NULL,
                                      wttClosed));

    /*  <CERTIFICATE private="1">
            template for Device Public key signed with the Fallback signing key.
            Standard CERT structure w/2.3.101.0 as version.
        </CERTIFICATE>  */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_WriteTag(f_pState->pbTemplate, 
                                      &g_dstrTagCertificate, 
                                      NULL,
                                      &g_dstrRootSigValueVersionTag,
                                      &g_dstrRootSigValueVersionVal,
                                      wttClosed));

    /*  Close the Fallback node */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_CloseCurrNode(f_pState->pbTemplate, NULL));
    
    /*  <Certificate type="GROUP"> */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_OpenNode(f_pState->pbTemplate, &g_dstrTagCertificate));
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_AddAttribute(f_pState->pbTemplate, 
                                          &g_dstrAttributeType,
                                          &g_dstrCerttypeGroup));

    /*  <DATA> */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_OpenNode(f_pState->pbTemplate, &g_dstrTagData));
    
    /*
    **  Get the group data inside Unsigned template 
    */
    ChkDR(DRM_XML_GetNode((DRM_CONST_STRING *)&(f_pState->dstrUnsignedTemplate), 
                            &g_dstrUnsignedtemplate, 
                            NULL,
                            NULL,
                            0, 
                            NULL,
                            (DRM_CONST_STRING *)&dstrGroupData));

    /*
    **  Append the data into the devcert template 
    */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_AddData(f_pState->pbTemplate, 
                                     (DRM_CONST_STRING *)&dstrGroupData));
    
    /*  <PUBLICKEY>GC Public key</PUBLICKEY>    */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_WriteTag(f_pState->pbTemplate, 
                                      &g_dstrTagDataPubKey, 
                                      (DRM_CONST_STRING *)&(f_pState->dstrGCPubKey),
                                      NULL,
                                      NULL,
                                      wttClosed));

    /* Close data node */
    CallXmlBuilder(f_pState->pbTemplate, 
        DRM_XMB_CloseCurrNode(f_pState->pbTemplate, &dstrClose));

    /* Now we need to sign the data portion with DAC private key */
    ChkDR(DRM_PK_Sign(f_pState->pcontextCrypto->rgbCryptoContext, 
                        &f_pState->privkeyDAC, 
                        PB_DSTR(&dstrClose), 
                        CB_DSTR(&dstrClose),  
                        rgbSignature));

    dstrSignature.cchString         = CCH_BASE64_EQUIV(PK_ENC_SIGNATURE_LEN);
    ChkMem(dstrSignature.pwszString = (DRM_WCHAR *)OEM_malloc(CB_DSTR(&dstrSignature)));

    ChkDR(DRM_B64_EncodeW(rgbSignature, 
                          PK_ENC_SIGNATURE_LEN, 
                          dstrSignature.pwszString, 
                         &dstrSignature.cchString, 
                          0));

    /*  <MSDRM_SIGNATURE_VALUE> 
            template for Signature over DATA using GC private key 
        </MSDRM_SIGNATURE_VALUE>   */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_WriteTag(f_pState->pbTemplate, 
                                      &g_dstrTagMSDRMSignature, 
                                      (DRM_CONST_STRING *)&dstrSignature,
                                      NULL,
                                      NULL,
                                      wttClosed));    

    /*  Close the GROUP node    */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_CloseCurrNode(f_pState->pbTemplate, NULL));
    
    /*
    **  Append the Authorization cert
    */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_AppendNode(f_pState->pbTemplate, 
                                        (DRM_CONST_STRING *)&(f_pState->dstrAuthCert)));
    /*
    **  Append the Authorization Root cert
    */
    CallXmlBuilder(f_pState->pbTemplate, 
                    DRM_XMB_AppendNode(f_pState->pbTemplate, 
                                        (DRM_CONST_STRING *)&(f_pState->dstrAuthRootCert)));
    
    /* close the root node */
    CallXmlBuilder(f_pState->pbTemplate, 
        DRM_XMB_CloseDocument(f_pState->pbTemplate, &dstrClose));    

    printf("Verifying Devcert template...\n");
    ChkDR( VerifyDevcert( f_pState, &dstrClose ) );
    
    fResult = OEM_WriteFile( f_pState->fpDevcertTemplate,
                  (DRM_BYTE*)g_rgbFFFE,
                     SIZEOF( g_rgbFFFE ),
                            &cbWritten );

    if (!fResult || (cbWritten != SIZEOF(g_rgbFFFE)))
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }

    fResult = OEM_WriteFile( f_pState->fpDevcertTemplate, 
                             dstrClose.pwszString, 
                     CB_DSTR(&dstrClose),                        
                             &cbWritten);
    if (!fResult || (cbWritten != CB_DSTR(&dstrClose)))
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }
    
ErrorExit:
    if (dstrSignature.pwszString != NULL)
    {
        OEM_free(dstrSignature.pwszString);
    }
   return dr;
}


/******************************************************************************
** 
** Function :   GeneratePrivKeysFile
** 
** Synopsis :   Generate the private key file for device
** 
** Arguments :  f_pState
** 
** Returns :    
** 
** Notes :   
**  <PRIVATEKEYS>
**      <GROUP/>
**      <FALLBACK/>
**  </PRIVATEKEYS>
** 
******************************************************************************/
DRM_RESULT GeneratePrivKeysFile(DRMSTATE *f_pState)
{
    DRM_RESULT dr        = DRM_SUCCESS;
    DRM_BOOL   fResult   = FALSE;
    DRM_DWORD  ib        = 0;
    DRM_DWORD  cbWritten = 0;
    PRIVKEY    rgPrivKeys        [2];
        
    MEMCPY(&rgPrivKeys [0], (DRM_BYTE*) &f_pState->privkeyGC,       SIZEOF(PRIVKEY));
    MEMCPY(&rgPrivKeys [1], (DRM_BYTE*) &f_pState->privkeyFallback, SIZEOF(PRIVKEY));
    
    if (f_pState->fpDeviceKeys != NULL)
    {
        cbWritten = fwrite((DRM_BYTE*)rgPrivKeys, 
                            1, 
                            SIZEOF(rgPrivKeys), 
                            f_pState->fpDeviceKeys);

        if (cbWritten != SIZEOF(rgPrivKeys))
        {
            ChkDR(DRM_E_FILEWRITEERROR);
        }        
    }
    
ErrorExit:
    return dr;
}    

DRM_VOID DRM_API 
wmain(
    DRM_INT argc, 
    DRM_WCHAR** argv)
{
    DRM_RESULT       dr                           = DRM_SUCCESS;
    DRM_CONST_STRING dstrUnsignedTemplateFile     = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDACResponseFile          = EMPTY_DRM_STRING;    
    DRM_CONST_STRING dstrOEMPrivateKeyFile        = EMPTY_DRM_STRING; 
    DRM_CONST_STRING dstrDevcertTemplateFile      = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDeviceKeysFile           = EMPTY_DRM_STRING;
    DRM_INT          iParam                       = 0;
    DRM_CHAR         rgchFile [MAX_FILENAME + 1]  = { 0 };
    DRMSTATE        *pState                       = NULL;
    
    printf("Microsoft (R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "DAC Creation Tool");

    /*
    **  Check input
    */
    if((argc < 6) || (argc >7))
    {
        goto _PrintUsage;
    }

    for(iParam = 1; iParam < argc; iParam++)
    {
        DRM_WCHAR        wchOption = 0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;
        
        if (!DRM_CMD_ParseCmdLine(argv [iParam], &wchOption, &dstrParam, NULL))
        {
            goto _PrintUsage;
        }
        
        switch(towlower(wchOption))
        {
        case WCHAR_CAST('d'):  
            ASSIGN_DRM_STRING(dstrDACResponseFile, dstrParam);
            break;
                    
        case WCHAR_CAST('u'):  
            ASSIGN_DRM_STRING(dstrUnsignedTemplateFile, dstrParam);
            break;
        
        case WCHAR_CAST('f'): 
            ASSIGN_DRM_STRING(dstrOEMPrivateKeyFile, dstrParam);
            break;
                    
        case WCHAR_CAST('t'): 
            ASSIGN_DRM_STRING(dstrDevcertTemplateFile, dstrParam);
            break;

        case WCHAR_CAST('k'): 
            ASSIGN_DRM_STRING(dstrDeviceKeysFile, dstrParam);
                    break;                    
                    
        default:
            goto _PrintUsage;
        }
    }

    if (dstrDACResponseFile.cchString       == 0
     || dstrUnsignedTemplateFile.cchString  == 0
     || dstrOEMPrivateKeyFile.cchString     == 0
     || dstrDevcertTemplateFile.cchString   == 0) 
    {
        goto _PrintUsage;
    }
 
    if (dstrDACResponseFile.cchString          > MAX_FILENAME 
     || dstrUnsignedTemplateFile.cchString     > MAX_FILENAME 
     || dstrOEMPrivateKeyFile.cchString        > MAX_FILENAME 
     || dstrDevcertTemplateFile.cchString      > MAX_FILENAME 
     || dstrDeviceKeysFile.cchString           > MAX_FILENAME)
    {
        printf("File name is too big. Max Filename is %d \n", MAX_FILENAME);
        return;
    }

    /*
    **  Initialize state
    */
    printf("Initializing...\n");
    ChkDR(DRMInit(&pState));

    /*
    **  Open input files
    */
    ChkDR(DRMTOOLS_ReadFileData(&dstrDACResponseFile,      &(pState->dstrDACResponse)));
    ChkDR(DRMTOOLS_ReadFileData(&dstrUnsignedTemplateFile, &(pState->dstrUnsignedTemplate)));
    ChkDR(DRMTOOLS_ReadFileData(&dstrOEMPrivateKeyFile,    &(pState->dstrOEMPrivKeys)));
    
    /*
    **  Open output files
    */    
    
    pState->fpDevcertTemplate = OEM_OpenFile(dstrDevcertTemplateFile.pwszString, 
                                             OEM_GENERIC_READ|OEM_GENERIC_WRITE,
                                             OEM_FILE_SHARE_READ|OEM_FILE_SHARE_WRITE, 
                                             OEM_CREATE_ALWAYS, 
                                             OEM_ATTRIBUTE_NORMAL);
    if(pState->fpDevcertTemplate == OEM_INVALID_HANDLE_VALUE)
    {
        printf("%S could not be opened\n",  rgchFile);
        goto ErrorExit;
    }    

    if (dstrDeviceKeysFile.cchString > 0)
    {
        DRM_UTL_DemoteUNICODEtoANSI(dstrDeviceKeysFile.pwszString, 
                                    rgchFile, 
                                    dstrDeviceKeysFile.cchString);

        rgchFile [dstrDeviceKeysFile.cchString] = '\0';
        
        pState->fpDeviceKeys= (FILE *) fopen(rgchFile, "w+b");
        
        if (pState->fpDeviceKeys == NULL)
        {
            printf("%S could not be opened\n",  rgchFile);
            goto ErrorExit;
        } 
    }       

    printf("Parsing OEM keys file to obtain necessary private keys...\n");
    ChkDR(_ObtainOEMKeys(pState));
    
    printf("Generating Devcert template...\n");
    ChkDR(GenerateDevcert(pState));

    printf("Generating keys file for the device...\n");
    ChkDR(GeneratePrivKeysFile(pState));

    printf("Done\n");
    
ErrorExit:    
    if (pState)
    {
        DRMClose(&pState);
    }

    return;
_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\licenseviewstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <drmcrt.h>
#include <stdio.h>

/*Global HDS file name*/
DRM_WCHAR g_wszDeviceStoreName[DRM_MAX_PATH];

/* DRM_WCHAR g_wszDeviceStoreName[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('j', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('e', '\0'), TWO_BYTES('.', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\0', '\0')}; */

DRM_RESULT DumpLicenses( DRM_KID* pKid )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    DRM_BYTE *pbLicense = NULL;
    DRM_DWORD cbLicense = 0;
    DRM_WORD wSize=0;
    DRM_KID oKID;
    DRM_LID oLID;
    DRM_HDS_CONTEXT          *pHdsContext = NULL;
    DRM_LICSTOREENUM_CONTEXT *pLicEnum    = NULL;    
    DRM_LICSTORE_CONTEXT     *pcontextLST = NULL;
    DRM_BOOL fOpened = FALSE;

    ChkMem( pHdsContext = (DRM_HDS_CONTEXT*)      OEM_malloc( SIZEOF( DRM_HDS_CONTEXT ) ) );
    ChkMem( pcontextLST = (DRM_LICSTORE_CONTEXT*) OEM_malloc( SIZEOF( DRM_LICSTORE_CONTEXT ) ) );

    ZEROMEM(pHdsContext, SIZEOF( *pHdsContext ) );    
    ChkDR( DRM_HDS_Init( pHdsContext ) );

    dr = DRM_HDS_OpenStore( g_wszDeviceStoreName, pHdsContext );

    if ( dr == DRM_E_FILENOTFOUND )   /* store does not exist */
    {
        printf("Can not find data store\n ");        
    }
    
    ChkDR(dr);
    
    fOpened = TRUE;

    ChkDR( DRM_LST_Open(pcontextLST, pHdsContext) );

    /* Query for licenses based on KID */
    ChkMem( pLicEnum = OEM_malloc( SIZEOF(DRM_LICSTOREENUM_CONTEXT) ) );
    ChkDR( DRM_LST_InitEnum( pcontextLST, 
                             pKid, /* Could be NULL for all licenses */ 
                             FALSE, /* dump all licenses without care of the priority value */
                             pLicEnum) );

    while( TRUE )
    {
        DRM_HDS_SLOT_HINT slotHint;

        cbLicense = 0;
        dr = DRM_LST_EnumNext(pLicEnum, &oKID, &oLID, &slotHint, &cbLicense);
        if( dr == DRM_E_NOMORE )
        {
            dr = DRM_E_LICENSENOTFOUND;
            goto ErrorExit;
        }
        ChkDR(dr);

        ChkMem( pbLicense = OEM_malloc( cbLicense + SIZEOF( DRM_WCHAR ) ) );
        ChkDR( DRM_LST_GetLicense(pcontextLST, &oKID, &oLID, &slotHint, pbLicense, &cbLicense) );
        if( pbLicense[0] == 0xff && pbLicense[1] == 0xfe )
        {
            printf( "%S\n", (DRM_WCHAR*)(pbLicense+2) );
        }
        else
        {
            printf( "%S\n", (DRM_WCHAR*)pbLicense );
        }
        OEM_free( pbLicense );
    }

ErrorExit:
    if( pcontextLST != NULL )
    {
        OEM_free( pcontextLST );
    }
    if ( pLicEnum != NULL )
    {
        OEM_free(pLicEnum);
    }
    if ( fOpened )
    {
        DRM_HDS_CloseStore(pHdsContext);
        DRM_HDS_Uninit(pHdsContext);
        fOpened = FALSE;
    }
    if( pHdsContext != NULL )
    {
        OEM_free( pHdsContext );
    }
    
    return dr;
}

/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] [-s:DataStoreName] [-k:KID]\n", pwszAppName);
}

DRM_VOID DRM_API wmain( DRM_INT argc, DRM_WCHAR **argv )
{    
    DRM_CONST_STRING dstrStoreName = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrKID       = EMPTY_DRM_STRING;
    DRM_INT i = 0;

    printf( "Microsoft (R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "DRM License store dump tool" );

    for( i = 1; i<argc; i++ )
    {
        DRM_WCHAR wchOption =  0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;

        if ( !DRM_CMD_ParseCmdLine(argv[i], &wchOption, &dstrParam, NULL) )
        {
            goto _PrintUsage;
        }
        wchOption = towlower( wchOption );
        switch( wchOption )
        {
        case WCHAR_CAST('s'):  
            dstrStoreName = dstrParam;
            break;
        case WCHAR_CAST('k'):  
            dstrKID = dstrParam;
            break;
        default:
            goto _PrintUsage;
        }
    }

    if( dstrStoreName.cchString == 0 )
    {
        goto _PrintUsage;
    }

    if( dstrStoreName.cchString > (DRM_MAX_PATH - 1) )
    {
        printf("Data Store name is too long. Max length is %d.\n", (DRM_MAX_PATH - 1) );
        goto _PrintUsage;
    }

    ZEROMEM(g_wszDeviceStoreName, SIZEOF(g_wszDeviceStoreName));
    MEMCPY( g_wszDeviceStoreName, 
            PB_DSTR( &dstrStoreName ), 
            CB_DSTR( &dstrStoreName ) );

    if( dstrKID.cchString > 0 )
    {
        DRM_KID oKid;

        /* Dump licenses for a specific KID */
        printf( "Dumping licenses for single KID.\n");
        if( DRM_FAILED( DRM_UTL_DecodeKID( &dstrKID, &oKid ) ) )
        {
            printf( "--Bad KID\n");
            return;
        }
        DumpLicenses( &oKid );
    }
    else
    {
        /* Dump all licenses */
        printf( "Dumping all licenses from the license store.\n");
        DumpLicenses( NULL );
    }

    return;

_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\licensegeneratechallenge.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <stdio.h>

/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] -c:ContentFile -o:ChallengeOutputFile -s:DataStoreName [-u:URLFile]\n", pwszAppName);
}


#if DRM_SUPPORT_DLA
static void 
GenerateChallenge (DRM_CONST_STRING *pdstrContentFilename, 
                   DRM_CONST_STRING *pdstrOutputFileName, 
                   DRM_CONST_STRING *f_pdstrFileURL,
                   DRM_CONST_STRING *pdstrDataStoreFile)
{
    DRM_MANAGER_CONTEXT    *poManagerContext  = NULL;
    const DRM_CONST_STRING *rgpdstrRights [1] = { 0 };
    DRM_DWORD   cbChunk      = 0,
                cbFile       = 0,
                cbRead       = 0,
                cbXML        = 0,
                cbWritten    = 0,
                cchUrl       = 0,
                cchChallenge = 0;
    DRM_DWORD   dwBytes      = 0;
    DRM_BYTE   *pbXML        = NULL;
    OEM_FILEHDL hfileIn      = OEM_INVALID_HANDLE_VALUE,
                hfileOut     = OEM_INVALID_HANDLE_VALUE;
    OEM_FILEHDL hfileURL     = OEM_INVALID_HANDLE_VALUE;
    DRM_WCHAR  *pwszUrl      = NULL;
    DRM_CHAR   *pszChallenge   = NULL;
    DRM_RESULT dr = DRM_SUCCESS;

    ChkMem(poManagerContext = OEM_malloc (SIZEOF (DRM_MANAGER_CONTEXT)));
    ZEROMEM(poManagerContext, SIZEOF (DRM_MANAGER_CONTEXT));

    hfileIn = OEM_OpenFile(pdstrContentFilename->pwszString, 
                           OEM_GENERIC_READ,
                           OEM_FILE_SHARE_READ, 
                           OEM_OPEN_EXISTING, 
                           OEM_ATTRIBUTE_NORMAL);
            
    if (hfileIn == OEM_INVALID_HANDLE_VALUE)
    {
        printf( "Input file not opened\n" );
        goto ErrorExit;
    }

    /* File structure: | cbChunk | cbXML | byte data .... | */

    ChkFAIL(OEM_GetFileSize (hfileIn, &cbFile));
    ChkFAIL(cbFile >= SIZEOF (cbChunk));

    if (OEM_ReadFile(hfileIn, &cbChunk, SIZEOF (cbChunk), &cbRead) == FALSE 
	||  cbRead != SIZEOF (cbChunk))
    {
        printf( "Block size could not be read\n");
        goto ErrorExit;
    }

    FIX_ENDIAN_DWORD( cbChunk );
        
    if (OEM_ReadFile (hfileIn, &cbXML, SIZEOF (cbXML), &cbRead) == FALSE 
	 || cbRead != SIZEOF (cbXML))
    {
        printf( "XML text size could not be read\n");
        goto ErrorExit;
    }

    FIX_ENDIAN_DWORD( cbXML );
    
    if ((cbXML % SIZEOF (DRM_WCHAR)) != 0)
    {
        ChkDR(DRM_E_INVALIDARG);
    }
    
    ChkMem(pbXML = OEM_malloc(cbXML));

    if (OEM_ReadFile (hfileIn, pbXML, cbXML, &cbRead) == FALSE
    ||  cbRead != cbXML)
    {
        printf ("License data could not be read\n");
        goto ErrorExit;
    }
    
    rgpdstrRights [0] = &g_dstrWMDRM_RIGHT_PLAYBACK;
    
    ChkDR (DRM_MGR_Initialize  (poManagerContext, pdstrDataStoreFile));
    ChkDR (DRM_MGR_SetV2Header (poManagerContext, pbXML, cbXML));

    /* We don't have a valid license */
    dr = DRM_MGR_GenerateLicenseChallenge (poManagerContext, 
                                           rgpdstrRights,
                                           1,
                                           NULL, 
                                          &cchUrl, 
                                           NULL, 
                                          &cchChallenge );
    if( dr != DRM_E_BUFFERTOOSMALL )
    {
        goto ErrorExit;
    }
    ChkMem(pwszUrl      = (DRM_WCHAR *) OEM_malloc(cchUrl       * SIZEOF (DRM_WCHAR)));
    ChkMem(pszChallenge = (DRM_CHAR  *) OEM_malloc(cchChallenge));
    
    ChkDR(DRM_MGR_GenerateLicenseChallenge(poManagerContext, 
                                           rgpdstrRights,
                                           NO_OF(rgpdstrRights),
                                           pwszUrl, 
                                          &cchUrl, 
                                           pszChallenge, 
                                          &cchChallenge));

    hfileOut = OEM_OpenFile(pdstrOutputFileName->pwszString, 
                                  OEM_GENERIC_READ    | OEM_GENERIC_WRITE,
                                  OEM_FILE_SHARE_READ | OEM_FILE_SHARE_WRITE, 
                                  OEM_CREATE_ALWAYS, 
                                  OEM_ATTRIBUTE_NORMAL);
                                  
    if (hfileOut != OEM_INVALID_HANDLE_VALUE)
    {
        if (! OEM_WriteFile(hfileOut, pszChallenge, cchChallenge, &cbRead) 
        ||  cbRead != cchChallenge)
        {
            printf("Failed to write challenge\n");
            goto ErrorExit;
        }
    }
    else
    {
        printf( "Challenge file not opened\n" );
        goto ErrorExit;
    }

    /* if Url output file requested */

    if (f_pdstrFileURL->cchString > 0)
    {
        hfileURL = OEM_OpenFile(f_pdstrFileURL->pwszString, 
                                OEM_GENERIC_READ    | OEM_GENERIC_WRITE,
                                OEM_FILE_SHARE_READ | OEM_FILE_SHARE_WRITE, 
                                OEM_CREATE_ALWAYS, 
                                OEM_ATTRIBUTE_NORMAL);

        if (hfileURL != OEM_INVALID_HANDLE_VALUE)
        {
            DRM_DWORD cbUrl = cchUrl * SIZEOF (DRM_WCHAR);
            
            if (! OEM_WriteFile(hfileURL, pwszUrl, cbUrl, &cbWritten) 
            ||  cbWritten != cbUrl)
            {
                printf("Failed to write Url file\n");
            }
            
            OEM_CloseFile(hfileURL);
        }
        else
        {
            printf("Url file not opened\n");
        }
    }
    
ErrorExit:
    
    if (hfileOut != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile(hfileOut);
    }
    
    if (hfileIn != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile(hfileIn);
    }
    
    if (pwszUrl != NULL)
    {
        OEM_free(pwszUrl);
    }

    if (pszChallenge != NULL)
    {
        OEM_free(pszChallenge);
    }

    if (poManagerContext != NULL)
    {
        DRM_MGR_Uninitialize(poManagerContext);
        OEM_free(poManagerContext);
    }
}
#endif

/******************************************************************************
** 
*******************************************************************************
*/
DRM_VOID DRM_API wmain( 
    DRM_INT argc, 
    DRM_WCHAR** argv )
{
    DRM_CONST_STRING dstrContentFile   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrOutputFile    = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrFileURL       = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataStoreFile = EMPTY_DRM_STRING;
    DRM_INT i;

    printf( "Microsoft (R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "Generate DRM License Challenge" );

    if (argc < 4  
     || argc > 5)
    {
        goto _PrintUsage;
    }

    for( i = 1; i < argc; i++ )
    {
        DRM_WCHAR        wchOption;
        DRM_CONST_STRING dstrParam;

        if (! DRM_CMD_ParseCmdLine(argv [i], &wchOption, &dstrParam, NULL))
        {
            goto _PrintUsage;
        }

        wchOption = towlower( wchOption );
        
        switch (wchOption)
        {
            case WCHAR_CAST('c'):  
                dstrContentFile.pwszString = dstrParam.pwszString;
                dstrContentFile.cchString  = dstrParam.cchString;
                break;

            case WCHAR_CAST('o'):  
                dstrOutputFile.pwszString = dstrParam.pwszString;
                dstrOutputFile.cchString  = dstrParam.cchString;
                break;

            case WCHAR_CAST('s'):  
                dstrDataStoreFile.pwszString = dstrParam.pwszString;
                dstrDataStoreFile.cchString  = dstrParam.cchString;
                break;

            case WCHAR_CAST('u'):  
                ASSIGN_DRM_STRING(dstrFileURL, dstrParam);
                break;

        default:
            goto _PrintUsage;
        }
    }

    /* dstrFileURL is optional */

    if( !dstrContentFile.cchString || !dstrOutputFile.cchString || !dstrDataStoreFile.cchString )
    {
        goto _PrintUsage;
    }

#if DRM_SUPPORT_DLA
    GenerateChallenge( &dstrContentFile, &dstrOutputFile, &dstrFileURL, &dstrDataStoreFile);
#else
    printf( "DLA not supported.\n" );
#endif
    return;

_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\licensecleanstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/**
 ** FILE: CleanupStore.c
 **
 ** DESCRIPTION: Tool to cleanup a license store. 
 **              Involving two main steps:
 **                 - Delete licenses not required any more
 **                 - Defrag the store
 **
 ** OWNER: vikask
 **
 ** CREATED: 11/13/03
 **/
 
#include <drmcommon.h>
#include <drmcrt.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include "drmmanager.h"

#include <stdio.h>


/******************************************************************************
** Print a command menu to console
*******************************************************************************/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] [-s:DataStoreName]\n", pwszAppName);
}

/********************************************************************
** Function :   ReportProgress
** Synopsis :   Callback function to report progress
*********************************************************************/
DRM_RESULT DRM_API  ReportProgress(
    IN const DRM_VOID  *pvCallerData, 
    IN       DRM_DWORD  cLicensesProcessed,
    IN       DRM_DWORD  cTotalLicenses  /*  # of licenses remaining */
    )
{
    DRM_RESULT   dr = DRM_SUCCESS;

    printf("%d license(s) out of %d licenses processed\n", cLicensesProcessed, cTotalLicenses );
    if (pvCallerData)
    {
        dr = DRM_E_DEVICENOTINIT;
    }
    
   return dr;
}

/********************************************************************
** Function :   wmain
** Synopsis :   Cleanup a license store. Involving two main steps:
**              - Delete licenses not required any more
**              - Defrag the store
*********************************************************************/
DRM_VOID DRM_API wmain( DRM_INT argc, DRM_WCHAR **argv )
{    
    DRM_CONST_STRING    dstrStoreName = EMPTY_DRM_STRING;
    DRM_INT             i = 0;
    DRM_MANAGER_CONTEXT *poManagerContext = NULL;
    DRM_RESULT          dr = DRM_SUCCESS;
    
    printf( "Microsoft (R) %s\nCopyright (C) Microsoft Corporation. "\
            "All rights reserved.\n\n", 
            "DRM License store cleanup tool" );

    for( i = 1; i < argc; i++ )
    {
        DRM_WCHAR           wchOption = 0;
        DRM_CONST_STRING    dstrParam = EMPTY_DRM_STRING;

        if ( !DRM_CMD_ParseCmdLine(argv[i], &wchOption, &dstrParam, NULL) )
        {
            goto _PrintUsage;
        }
        wchOption = towlower( wchOption );
        switch( wchOption )
        {
        case WCHAR_CAST('s'):
            dstrStoreName = dstrParam;
            break;
        default:
            goto _PrintUsage;
        }
    }

    if( dstrStoreName.cchString == 0 )
    {
        goto _PrintUsage;
    }

    /*  Initialize DRM Manager  */
    ChkMem( poManagerContext = OEM_malloc( SIZEOF(DRM_MANAGER_CONTEXT) ) );
    ZEROMEM(poManagerContext, SIZEOF(DRM_MANAGER_CONTEXT));

    ChkDR(DRM_MGR_Initialize(poManagerContext, &dstrStoreName));        
    ChkDR(DRM_MGR_CleanupLicenseStore( poManagerContext, 
                                       NULL,
                                       5,
                                       ReportProgress));
    printf( "100 percent done\n" );
    
ErrorExit:    
    DRM_MGR_Uninitialize(poManagerContext);
    return;

_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\licenseprocessresponse.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <oemimpl.h>
#include <stdio.h>
#include <drmcmdlnpars.h>


/*#define EMBEDDED_WITH_NO_PARAMS*/

#if EMBEDDED_WITH_NO_PARAMS

DRM_INT   g_argc = 3;

DRM_WCHAR g_Arg1[] = { TWO_BYTES('p', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('\0', '\0')};

/* 1k1s.response.xml */
DRM_WCHAR g_Arg2[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('w', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('1', '\0'),  TWO_BYTES('k', '\0'),  TWO_BYTES('1', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('r', '\0'), TWO_BYTES('e', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('\0', '\0')};

/* sample.hds */
DRM_WCHAR g_Arg3[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('w', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('e', '\0'), TWO_BYTES('.', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\0', '\0')};
DRM_WCHAR *g_argv[] = { g_Arg1, g_Arg2, g_Arg3 };
#endif

/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] [-r:ResponseFile] [-s:DataStore]\n", pwszAppName);
}


static void 
ProcessResponse( DRM_CONST_STRING *pwszResponseFilename, DRM_CONST_STRING *pwszDataStoreFile)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dw;
    DRM_MANAGER_CONTEXT *poManagerContext = NULL;
    DRM_BYTE* pbData = NULL;
    OEM_FILEHDL fpResponse = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD iIO=0;
#if DRM_SUPPORT_REVOCATION
    DRM_BYTE *pbRevocationBuffer = NULL;
#endif
 
    ChkMem( poManagerContext = OEM_malloc( SIZEOF(DRM_MANAGER_CONTEXT) ) );
    ZEROMEM(poManagerContext, SIZEOF(DRM_MANAGER_CONTEXT));

    wcsncpy( (DRM_WCHAR*)poManagerContext, pwszResponseFilename->pwszString, pwszResponseFilename->cchString );
    ((DRM_WCHAR*)poManagerContext)[pwszResponseFilename->cchString] = g_wchNull;
    fpResponse = OEM_OpenFile(((DRM_WCHAR*)poManagerContext), 
                              OEM_GENERIC_READ,
                              OEM_FILE_SHARE_READ, 
                              OEM_OPEN_EXISTING, 
                              OEM_ATTRIBUTE_NORMAL);
    if( OEM_INVALID_HANDLE_VALUE == fpResponse )
    {
        printf( "Input file not opened\n" );
        goto ErrorExit;
    }


    ChkDR (DRM_MGR_Initialize(poManagerContext, pwszDataStoreFile));
#if DRM_SUPPORT_REVOCATION
    ChkMem( pbRevocationBuffer = OEM_malloc( REVOCATION_BUFFER_SIZE ) );
    ChkDR( DRM_MGR_SetRevocationBuffer( poManagerContext, pbRevocationBuffer, REVOCATION_BUFFER_SIZE ) );
#endif

    OEM_GetFileSize(fpResponse, &dw);
        
    OEM_SetFilePointer(fpResponse, 0, OEM_FILE_BEGIN, NULL);
    ChkMem( pbData = (DRM_BYTE*) OEM_malloc( dw ) );

    if (!OEM_ReadFile(fpResponse, pbData, dw, &iIO) || iIO!=dw)
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    
    ChkDR( DRM_MGR_ProcessLicenseResponse( poManagerContext, NULL, NULL, pbData, dw ) );

ErrorExit:
    DRM_MGR_Uninitialize(poManagerContext);

    if (fpResponse != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile (fpResponse);
    }

    if (pbData != NULL)
    {
        OEM_free (pbData);
    }

    if (poManagerContext != NULL)
    {
        OEM_free (poManagerContext);
    }
    
#if DRM_SUPPORT_REVOCATION
    SAFE_OEM_FREE( pbRevocationBuffer );
#endif
}


DRM_VOID DRM_API wmain( 
    DRM_INT argc, 
    DRM_WCHAR** argv )
{
    DRM_CONST_STRING dstrStoreName    = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrResponseFile = EMPTY_DRM_STRING;
    DRM_INT          i;

    printf( "Microsoft (R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "Process DRM License Response tool" );

#if EMBEDDED_WITH_NO_PARAMS
    argc = g_argc;
    argv = g_argv;
#endif

    if( argc == 1 || argc > 4 )
    {
        goto _PrintUsage;
    }

    for( i = 1; i<argc; i++ )
    {
        DRM_WCHAR        wchOption;
        DRM_CONST_STRING dstrParam;

        if (DRM_CMD_ParseCmdLine(argv[i], &wchOption, &dstrParam, NULL) == FALSE)
        {
            goto _PrintUsage;
        }
        wchOption = towlower( wchOption );
        switch( wchOption )
        {
        case WCHAR_CAST('r'):  
            dstrResponseFile.pwszString = dstrParam.pwszString;
            dstrResponseFile.cchString  = dstrParam.cchString;
            break;
        case WCHAR_CAST('s'):  
            dstrStoreName.pwszString = dstrParam.pwszString;
            dstrStoreName.cchString  = dstrParam.cchString;
            break;
        default:
            goto _PrintUsage;
        }
    }

    if (dstrResponseFile.cchString == 0
    ||  dstrStoreName   .cchString == 0)
    {
        goto _PrintUsage;
    }
    ProcessResponse( &dstrResponseFile, &dstrStoreName);

    return;
_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\meterrespond.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <drmcrt.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <drmxmlparser.h>
#include <drmxmlbuilder.h>
#include <drmmetercertprivkey.h>
#include <stdio.h> /* for missing CRT functions like printf */

#if DRM_SUPPORT_METERING
/*************** CHALLENGE *************
   <METERDATA type=challenge>
      <DATA>
         <MID>UiW5yBMep2CuevGg5+FgA3==</MID>
         <TID>Mep2CuevGgUiW5yB5+FgA3==</TID>
         <RECORDS>
            <KID value=KID1>
               <ACTION value=Play>5</ACTION>
            </KID>
            <KID value=KID2>
               <ACTION value=Play>71</ACTION>
               <ACTION value=Burn>2</ACTION>
            </KID>
            
         </RECORDS>
         <PARTIALDATA>1</PARTIALDATA>
      </DATA>
      <MSDRM_SIGNATURE_VALUE>
         dW1*kFht1AFwIH!VA4PjjHoV4jN2K6Jksga1FXMzaePVi6ISfOEIEA==
      </MSDRM_SIGNATURE_VALUE> 
      <CERTIFICATE private="1">
         TEALKodF8A70IWtir0fcZLgNuITbAj!Y4Zmja9Xc4U8DuFCCKrwdewIDAAKnU3O11yi
         dK4YXBaHPLZifoE4wf9KbKccf50fUzaIcjFArH2KH*1BO
      </CERTIFICATE> 
   </METERDATA>


************** RESPONSE *************

   <METERDATA type=response>
      <DATA>
         <MID>UiW5yBMep2CuevGg5+FgA3==</MID>
         <TID>Mep2CuevGgUiW5yB5+FgA3==</TID>
         <COMMAND>RESET</COMMAND>
         <RECORDS>
           <DATA>
             <KID value=KID1 />
             <KID value=KID2 />
              
           </DATA>
         </RECORDS>
         <PARTIALDATA>1</PARTIALDATA>
      </DATA>
      <MSDRM_SIGNATURE_VALUE>
         4PjjHoV4jN2K6Jksga1FXMzaePVi6ISfOEIEA dW1*kFht1AFwIH!VA==
      </MSDRM_SIGNATURE_VALUE> 
      <METERCERT version=1.0>
         <DATA>
            <MID>UiW5yBMep2CuevGg5+FgA3==</MID>
            <PUBLICKEY>meter cert public key</PUBLICKEY>
            <URL>http://www.mymeterservice.com</URL>
         </DATA>
         <SIGNATURE>
            
         </SIGNATURE>
         <CERTIFICATECHAIN>
            <CERTIFICATE>
               
            </CERTIFICATE>
            <CERTIFICATE>
               
            </CERTIFICATE>
         </CERTIFICATECHAIN>
      </METERCERT>
   </METERDATA>
*/


const PUBKEY pubkeyRoot = 
{
    0x05, 0x9B, 0xB0, 0x4F, 0xE1, 0x58, 0xBC, 0x27, 
    0x47, 0x63, 0xD4, 0x52, 0x73, 0xCB, 0xFA, 0x36, 
    0xF8, 0xA2, 0x6B, 0x4A, 0xA6, 0xCA, 0xE0, 0xB1, 
    0xC0, 0x84, 0xD6, 0x62, 0xC9, 0xBF, 0xB8, 0x2D, 
    0xC8, 0x67, 0x8A, 0x35, 0xCA, 0xB5, 0x02, 0x13
};

extern PUBKEY g_pubkeyRootMeteringCert;

DRM_BOOL GetFileData(
    const DRM_WCHAR *pszFileData,
    DRM_DWORD       *pcbFile,
    DRM_WCHAR      **ppwszFile)
{
    DRM_BOOL    bOK     = FALSE;
    DRM_DWORD   cbRead  = 0;
    OEM_FILEHDL hfileIn = OEM_INVALID_HANDLE_VALUE;

    if ((hfileIn = OEM_OpenFile (pszFileData,
                                 OEM_GENERIC_READ,
                                 OEM_FILE_SHARE_NONE,
                                 OEM_OPEN_EXISTING,
                                 OEM_ATTRIBUTE_NORMAL)) != OEM_INVALID_HANDLE_VALUE)
    {
        /* read the input file and cache it */

        OEM_GetFileSize (hfileIn, pcbFile);

        if ((*ppwszFile = OEM_malloc (*pcbFile)))
        {
            if (OEM_ReadFile (hfileIn, *ppwszFile, *pcbFile, &cbRead))
            {
                bOK = TRUE;
            }
            else
            {
                OEM_free (*ppwszFile);
                *ppwszFile = NULL;
                printf ("error reading file\n");
            }
        }
        else
        {
            printf ("error allocating memory\n");
        }

        OEM_CloseFile (hfileIn);
    }
    else
    {
        printf ("error opening input file %S\n", pszFileData);
    }

    return bOK;
}



DRM_BOOL GetMASPrivateKey(
    const DRM_WCHAR *pszFilePrivKey,
    PRIVKEY         *pprivkey)
{
    DRM_DWORD        cbFile       = 0,
                     cbRead       = 0,
                     cbPrivKey    = SIZEOF (PRIVKEY);
    DRM_BOOL         bOK          = FALSE;
    DRM_BYTE        *pbFile       = NULL;
    DRM_CONST_STRING dstrXML      = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrPrivKey  = EMPTY_DRM_STRING;
    OEM_FILEHDL      hfilePrivKey = OEM_INVALID_HANDLE_VALUE;

    if ((hfilePrivKey = OEM_OpenFile (pszFilePrivKey,
                                      OEM_GENERIC_READ,
                                      OEM_FILE_SHARE_NONE,
                                      OEM_OPEN_EXISTING,
                                      OEM_ATTRIBUTE_NORMAL)) != OEM_INVALID_HANDLE_VALUE)
    {
        if (OEM_GetFileSize (hfilePrivKey, &cbFile))
        {
            if ((pbFile = OEM_malloc (cbFile)) != NULL)
            {
                if (OEM_ReadFile (hfilePrivKey, pbFile, cbFile, &cbRead))
                {
                    DRM_RESULT dr = DRM_SUCCESS;
                    
                    DSTR_FROM_PB(&dstrXML, pbFile, cbFile);

                    ChkDR(DRM_XML_GetNode(&dstrXML, 
                                          &g_dstrTagPrivateKey, 
                                           NULL, 
                                           NULL, 
                                           0, 
                                           NULL, 
                                          &dstrPrivKey));

                    ChkDR(DRM_B64_DecodeW(&dstrPrivKey, 
                                          &cbPrivKey, 
                              (DRM_BYTE *) pprivkey, 
                                           0));

                    bOK = TRUE;
                }
ErrorExit:                    
                OEM_free (pbFile);
            }
            else
            {
                printf ("error allocating memory\n");
            }
        }

        OEM_CloseFile (hfilePrivKey);
    }
    else
    {
        printf ("error opening private key file %S\n", pszFilePrivKey);
    }

    return bOK;
}

/*******************************************************************
*                    PRIVATE FUNCTION DoSetup
*
* purpose: set up everything needed; open both files and allocate
*          a buffer to image the input file.  If anything fails,
*          release all resources
*******************************************************************/

static DRM_BOOL DoSetup(
    const DRM_WCHAR  *pszFilePrivKey,
    const DRM_WCHAR  *pszFileChallenge,
    const DRM_WCHAR  *pszFileResponse,
    const DRM_WCHAR  *pszFileMeterCert,
    PRIVKEY          *pprivkey,
    OEM_FILEHDL      *phfileOut,
    DRM_WCHAR       **ppwszFile,
    DRM_DWORD        *pcbFile,
    DRM_WCHAR       **ppszCertFile,
    DRM_DWORD        *pcbCertFile)
{
    DRM_BOOL    fOK          = FALSE;
    DRM_DWORD   cbRead       = 0;

    *phfileOut = OEM_INVALID_HANDLE_VALUE;

    if (GetMASPrivateKey     (pszFilePrivKey,   pprivkey)
    &&  GetFileData (pszFileChallenge, pcbFile, ppwszFile)
    &&  GetFileData (pszFileMeterCert, pcbCertFile, ppszCertFile))
    {
        if ((*phfileOut = OEM_OpenFile(pszFileResponse,
                                       OEM_GENERIC_WRITE,
                                       OEM_FILE_SHARE_NONE,
                                       OEM_CREATE_ALWAYS,
                                       OEM_ATTRIBUTE_NORMAL)) != OEM_INVALID_HANDLE_VALUE)
        {
            fOK = TRUE;
        }
        else
        {
            OEM_free(*ppwszFile);
            printf ("error opening output file %S\n", pszFileResponse);
        }
    }

    return fOK;
} /* DoSetup */

/*******************************************************************
*               PRIVATE FUNCTION ParseMeterChallenge
*
* purpose: verify that all required entries are present in the
*          UNICODE XML and that they are properly formed
*          write the file to the passed-in buffer as UNICODE
*******************************************************************/

static DRM_RESULT ParseMeterChallenge(
    DRM_WCHAR        *pwszFile,
    DRM_DWORD         cchFile,
    DRM_CONST_STRING *pdstrMID,
    DRM_CONST_STRING *pdstrTID,
    DRM_CONST_STRING *pdstrRecords,
    PUBKEY           *ppubkeyEnceypt,
    PRIVKEY          *pprivkeyMAS,
    DRM_BOOL         *pfPartialData)
{
    DRM_CRYPTO_CONTEXT *pcontextCrypto   = NULL;
    DRM_WCHAR          *pszDataCopy      = NULL;
    DRM_RESULT          dr               = DRM_SUCCESS;
    DRM_CONST_STRING    dstrXML          = EMPTY_DRM_STRING,
                        dstrNodeData     = EMPTY_DRM_STRING,
                        dstrListData     = EMPTY_DRM_STRING,
                        dstrSignature    = EMPTY_DRM_STRING,
                        dstrPartialData  = EMPTY_DRM_STRING,
                        dstrListTop      = EMPTY_DRM_STRING,
                        dstrTemp         = EMPTY_DRM_STRING,
                        dstrFallbackCert = EMPTY_DRM_STRING;
    PKCERT              fallbackCert;
    DRM_DWORD           cbB64Decode=0;
    DRM_BYTE            rgbSignature[__CB_DECL(PK_ENC_SIGNATURE_LEN)];

    ChkMem(pcontextCrypto = OEM_malloc(SIZEOF (DRM_CRYPTO_CONTEXT)));

    dstrXML.pwszString   = pwszFile;
    dstrXML.cchString    = cchFile;
    *pfPartialData       = FALSE;

    ChkDR(DRM_XML_GetNode(&dstrXML, &g_dstrTagMetering, NULL, NULL, 0, NULL, &dstrListTop));

    /* get <DATA> */
    ChkDR(DRM_XML_GetNode(&dstrListTop,  &g_dstrTagData,        NULL, NULL, 0, &dstrNodeData, &dstrListData));
    /* verify the signature over the <DATA> tags against the secure
    ** store key sent to the MAS in the challenge 
    */

    /* get <MSDRM_SIGNATURE_VALUE> */
    ChkDR(DRM_XML_GetNode(&dstrListTop,  &g_dstrTagMSDRMSignature, NULL, NULL, 0, NULL, &dstrSignature));
    if (dstrSignature.cchString != PK_ENC_SIGNATURE_B64LEN)
    {
        printf("SIGNATURE string malformed\n");
        ChkDR(DRM_E_INVALIDARG);
    }
    cbB64Decode = __CB_DECL(PK_ENC_SIGNATURE_LEN);
    ChkDR(DRM_B64_DecodeW(&dstrSignature, &cbB64Decode, rgbSignature, 0));

    /* get <CERTIFICATE private="1"> */
    ChkDR(DRM_XML_GetNode(&dstrListTop,  &g_dstrTagCertificate, NULL, NULL, 0, NULL, &dstrFallbackCert));

    if (dstrFallbackCert.cchString != CCH_BASE64_EQUIV(SIZEOF(PKCERT)))
    {
        printf("CERTIFICATE string malformed\n");

        ChkDR(DRM_E_INVALIDARG);
    }

    cbB64Decode = SIZEOF(PKCERT);

    ChkDR(DRM_B64_DecodeW(&dstrFallbackCert, &cbB64Decode, (DRM_BYTE *)&fallbackCert, 0));

    /* verify fallbackCert with pubkeyRoot */

    if (!DRM_PK_Verify(pcontextCrypto->rgbCryptoContext, 
                      &pubkeyRoot, 
         (DRM_BYTE *) &fallbackCert.pk, 
                       SIZEOF(PK), 
                       fallbackCert.sign))
    {
        ChkDR(DRM_E_CH_BAD_KEY);
    }

    /* verify signature of <DATA> node with pubkey in fallback cert */

    if (!DRM_PK_Verify(pcontextCrypto->rgbCryptoContext, 
                      &fallbackCert.pk.pk, 
              PB_DSTR(&dstrNodeData), 
              CB_DSTR(&dstrNodeData), 
                       rgbSignature))
    {
        ChkDR(DRM_E_CH_BAD_KEY);
    }

    /*Copy the pubkey*/

    MEMCPY((DRM_BYTE *) ppubkeyEnceypt, (DRM_BYTE *) &fallbackCert.pk.pk, SIZEOF(PUBKEY));

    /* get <MID> */

    ChkDR(DRM_XML_GetNode(&dstrListData, &g_dstrTagMID,  NULL, NULL, 0, NULL, pdstrMID));

    if (pdstrMID->cchString != CCH_BASE64_EQUIV (SIZEOF (DRM_MID)))
    {
        printf("MID string malformed\n");
        ChkDR(DRM_E_CH_BAD_KEY);
    }

    /* get <TID> */

    ChkDR(DRM_XML_GetNode(&dstrListData, &g_dstrTagTID, NULL, NULL, 0, NULL, pdstrTID));

    if (pdstrTID->cchString != CCH_BASE64_EQUIV (SIZEOF (DRM_TID)))
    {
        printf("TID string malformed\n");
        ChkDR(DRM_E_CH_BAD_KEY);
    }

    /* get <PARTIALDATA> */

    dr  = DRM_XML_GetNode(&dstrListData, &g_dstrTagPartialData, NULL, NULL, 0, NULL, &dstrPartialData);

    if (DRM_SUCCEEDED (dr)
     && dstrPartialData.cchString      == 1
     && dstrPartialData.pwszString [0] == g_wch1)
    {
        *pfPartialData = TRUE;
    }

    ChkMem(pszDataCopy = OEM_malloc(CB_DSTR(&dstrNodeData)));
    MEMCPY(pszDataCopy, PB_DSTR(&dstrNodeData), CB_DSTR(&dstrNodeData)); 
            
    dstrNodeData.pwszString = pszDataCopy;            

    ChkDR(DRM_XML_GetNode(&dstrListData, &g_dstrTagRecords, NULL, NULL, 0, NULL, &dstrTemp));
    if (dstrTemp.cchString > 0)
    {
        /* decrypt the <RECORDS> section with the MAS' private key */

        ChkDR(DRM_XML_GetAndDecryptNode(&dstrListData,
                                        &g_dstrTagRecords,
                                         NULL,
                                         NULL,
                                         0,
                                         pcontextCrypto,
                                         pprivkeyMAS,
                                         NULL,
                                         pdstrRecords));

    }
    else
    {
        printf("This metering challenge does not have any records\n");
        pdstrRecords->cchString  = 0;
        pdstrRecords->pwszString = NULL;
        ChkDR(DRM_E_INVALIDARG);
   }

ErrorExit:

    if (pszDataCopy != NULL)
    {
        OEM_free (pszDataCopy);
    }

    if (pcontextCrypto != NULL)
    {
        OEM_free (pcontextCrypto);
    }

    return dr;
}

/*******************************************************************
*               PRIVATE FUNCTION ParseMeterCert
*
* purpose: verify that all required entries are present in the
*          UNICODE XML and that they are properly formed
*          write the file to the passed-in buffer as UNICODE
*******************************************************************/

static DRM_RESULT ParseMeterCert(
    DRM_WCHAR        *pwszFile,
    DRM_DWORD         cchFile,
    DRM_CONST_STRING *pdstrMID,
    PRIVKEY          *pprivkey)
{
    DRM_LICEVAL_CONTEXT contextLEVL      = { 0 };
    DRM_BB_CONTEXT     *pcontextBBX      = NULL;
    HMAC_CONTEXT       *pcontextHMAC     = NULL;
    DRM_WCHAR          *pszDataCopy      = NULL;
    DRM_RESULT          dr               = DRM_SUCCESS;
    DRM_CONST_STRING    dstrXML          = EMPTY_DRM_STRING,
                        dstrPubkey       = EMPTY_DRM_STRING,
                        dstrNodeData     = EMPTY_DRM_STRING,
                        dstrListData     = EMPTY_DRM_STRING,
                        dstrNodeSign     = EMPTY_DRM_STRING,
                        dstrNodeCert     = EMPTY_DRM_STRING,
                        dstrNodeRoot     = EMPTY_DRM_STRING;
                        

    ChkMem(pcontextBBX = OEM_malloc(SIZEOF (DRM_BB_CONTEXT)));

    contextLEVL.pcontextBBX = pcontextBBX;

    dstrXML.pwszString   = pwszFile;
    dstrXML.cchString    = cchFile;

    ChkDR(DRM_XML_GetNode(&dstrXML,         &g_dstrTagMeterCert,        NULL, NULL, 0, NULL,          &dstrNodeRoot));
    ChkDR(DRM_XML_GetNode(&dstrNodeRoot,    &g_dstrTagData,             NULL, NULL, 0, &dstrNodeData, &dstrListData));
    ChkDR(DRM_XML_GetNode(&dstrNodeRoot,    &g_dstrTagSignature,        NULL, NULL, 0, &dstrNodeSign, NULL));
    ChkDR(DRM_XML_GetNode(&dstrNodeRoot,    &g_dstrTagCertificateChain, NULL, NULL, 0, &dstrNodeCert, NULL));

    ChkDR( DRM_UTL_VerifyXMLSignature( &dstrNodeData, &dstrNodeSign, &dstrNodeCert, FALSE, TRUE, WM_DRM_ROOTPUBKEY_MTR, &contextLEVL ) );  

    ChkDR(DRM_XML_GetNode(&dstrListData,    &g_dstrTagMID,              NULL, NULL, 0, NULL, pdstrMID));

    ChkDR(DRM_XML_GetNode(&dstrListData,    &g_dstrTagDataPubKey,       NULL, NULL, 0, NULL, &dstrPubkey));

    /*Test the pubkey in Meter cert against the given private key to sign*/

    if (pprivkey)
    {
        DRM_BYTE    *pInbuf         = NULL;
        DRM_BYTE    *pOutbuf        = NULL;
        DRM_BYTE    *pEncryptedbuf  = NULL;
        DRM_DWORD    cbBuffer       = SIZEOF(PUBKEY); 
        ChkDR(DRM_B64_DecodeW(&dstrPubkey, &cbBuffer,(DRM_BYTE*) &(pcontextBBX->CryptoContext.pubKey), 0) );
        
        DRMCASSERT(PK_ENC_PLAINTEXT_LEN <= SIZEOF(pcontextBBX->CryptoContext.pubKey2));

        pInbuf = (DRM_BYTE *)&(pcontextBBX->CryptoContext.pubKey2);
        MEMSET(pInbuf, 'a', SIZEOF(PUBKEY));
        DRMCASSERT(PK_ENC_CIPHERTEXT_LEN <= SIZEOF(pcontextBBX->CryptoContext.union_cert.cert ) );

        pEncryptedbuf =  (DRM_BYTE *)&(pcontextBBX->CryptoContext.union_cert.cert);
        pOutbuf = (DRM_BYTE *)&(pcontextBBX->CryptoContext.signature);


        ChkDR( DRM_PK_Encrypt(&(pcontextBBX->CryptoContext.rgbCryptoContext ),
                               (const PUBKEY *)&(pcontextBBX->CryptoContext.pubKey) , 
                                pInbuf,
                                pEncryptedbuf));

        ChkDR( DRM_PK_Decrypt(&pcontextBBX->CryptoContext.rgbCryptoContext, 
                               pprivkey,
                               pEncryptedbuf, 
                               pOutbuf));

        if (MEMCMP(pInbuf, pOutbuf, PK_ENC_PLAINTEXT_LEN) !=0)
        {
            ChkDR (DRM_E_KEY_MISMATCH);
        }
    }


ErrorExit:
    if (pcontextBBX != NULL)
    {
        OEM_free (pcontextBBX);
    }

    return dr;
}


static DRM_DWORD _RequiredCharsForResponse(
    DRM_CONST_STRING *pdstrRecords,
    DRM_BOOL          fPartialData,
    DRM_DWORD        *pcchKIDs)
{
    DRM_DWORD  cchRequired = 25;
    DRM_INT    iKid        = 0;
    DRM_RESULT dr          = DRM_SUCCESS;

    ChkArg (pdstrRecords != NULL);
    ChkArg (pcchKIDs     != NULL);

    *pcchKIDs = 0;
    
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagMetering.cchString, 
                                               0,       
                                               g_dstrAttributeType.cchString,
                                               g_dstrResponse.cchString);
                                                 
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagData.cchString,     
                                               0,        
                                               0,                 
                                               0);
                                                 
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagMID.cchString,      
                                               CCH_BASE64_EQUIV (SIZEOF (DRM_MID)),     
                                               0,                 
                                               0);
                                                 
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagTID.cchString,
                                               CCH_BASE64_EQUIV (SIZEOF (DRM_TID)),
                                               0,
                                               0);
                                                 
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagRecords.cchString,
                                               0,
                                               0,
                                               0);
                                                 
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagCmd.cchString,
                                               g_dstrReset.cchString, 
                                               0,
                                               0);
                                                 
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagHash.cchString,     
                                               0,
                                               0,
                                               0);
                                                 
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagHashAlg.cchString,
                                               0,
                                               g_dstrAttributeType.cchString, 
                                               g_dstrHMAC.cchString);
                                                 
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagValue.cchString,
                                               CCH_BASE64_EQUIV (SHA_DIGEST_LEN),
                                               0,
                                               0);
                                                 
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagKID.cchString,
                                               0,
                                               0,
                                               0);

    if (fPartialData)
    {
        cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagPartialData.cchString, 
                                                   g_dstr1.cchString, 
                                                   0, 
                                                   0);
    }

    while (TRUE)
    {
        DRM_CONST_STRING dstrKIDCurr = EMPTY_DRM_STRING;

        if (DRM_SUCCEEDED (DRM_XML_GetNode (pdstrRecords, &g_dstrTagKID, NULL, NULL, iKid++, NULL, &dstrKIDCurr)))
        {
            *pcchKIDs += DRM_XMB_RequiredCharsForTag(g_dstrTagKID.cchString, 
                                                     0, 
                                                     g_dstrLabelValue.cchString, 
                                                     CCH_BASE64_EQUIV (SIZEOF (DRM_KID)));
        }
        else
        {
            break;
        }
    }

    cchRequired += CCH_BASE64_EQUIV ((*pcchKIDs + PK_ENC_CIPHERTEXT_LEN) * SIZEOF (DRM_WCHAR));
    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagMSDRMSignature.cchString,
                                               CCH_BASE64_EQUIV (PK_ENC_SIGNATURE_LEN),
                                               0,
                                               0);


ErrorExit:    
    return cchRequired;
}

/*******************************************************************
*                  PRIVATE FUNCTION WriteMeterResponse
*
* purpose: Write the XML with signature to the output file
*******************************************************************/

static DRM_RESULT WriteMeterResponse(
    OEM_FILEHDL       hfileIn,
    DRM_CONST_STRING *pdstrMID,
    DRM_CONST_STRING *pdstrTID,
    DRM_CONST_STRING *pdstrRecords,
    PUBKEY           *ppubkeEncrypt,
    DRM_BOOL          fPartialData,
    DRM_WCHAR        *pwszCertFile,
    DRM_DWORD         cchCertFile,
    PRIVKEY          *pSignKey)
{
    DRM_RESULT       dr         = DRM_SUCCESS;
    DRM_DWORD        cbOut      = 0;
    DRM_DWORD        cbWritten  = 0;
    DRM_DWORD        cchKIDs    = 0;
    DRM_DWORD        cchRecords = 0;
    DRM_DWORD        cbBuffer   = 0;
    DRM_INT          iKID       = 0;
    DRM_STRING       strXML     = EMPTY_DRM_STRING;
    DRM_STRING       strRecords = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrData   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrKID    = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrKIDB64 = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSign   = EMPTY_DRM_STRING;
    DRM_STRING       dstrClose  = EMPTY_DRM_STRING;
    DRM_BYTE        *pbOut      = NULL;
    DRM_WCHAR       *pwszOut    = NULL;
    DRM_CRYPTO_CONTEXT *pcontextCrypto   = NULL;

    ChkMem(pcontextCrypto = OEM_malloc(SIZEOF (DRM_CRYPTO_CONTEXT)));

    cbOut     =  SIZEOF (DRM_WCHAR) * _RequiredCharsForResponse(pdstrRecords, fPartialData, &cchKIDs) ;
    cbOut     += SIZEOF (DRM_WCHAR) * cchCertFile ;
       
    if (cchKIDs ==0)
    {
        printf("This challenge does not have any KIDS\n");
        ChkDR(DRM_E_INVALIDARG);
    }

    ChkMem(pbOut = OEM_malloc(cbOut));

    ChkDR(DRM_XMB_CreateDocument(cbOut,  pbOut,               &g_dstrTagMetering));              /* <METERDATA type="response"> */
    ChkDR(DRM_XMB_AddAttribute  (pbOut, &g_dstrAttributeType, &g_dstrResponse));

    ChkDR(DRM_XMB_WriteTag(pbOut, &g_dstrTagData, NULL,        NULL, NULL, wttOpen));   /*   <DATA> */
    ChkDR(DRM_XMB_WriteTag(pbOut, &g_dstrTagMID,  pdstrMID,    NULL, NULL, wttClosed)); /*     <MID>base64</MID> */
    ChkDR(DRM_XMB_WriteTag(pbOut, &g_dstrTagTID,  pdstrTID,    NULL, NULL, wttClosed)); /*     <TID>base64</TID> */
    ChkDR(DRM_XMB_WriteTag(pbOut, &g_dstrTagCmd, &g_dstrReset, NULL, NULL, wttClosed)); /*     <COMMAND>RESET</COMMAND> */
    ChkDR(DRM_XMB_WriteTag(pbOut, &g_dstrTagRecords, NULL,     NULL, NULL, wttOpen)); /*     <RECORDS> */

    while (TRUE)
    {
        dr = DRM_XML_GetNode(pdstrRecords, &g_dstrTagKID, NULL, NULL, iKID++, &dstrKID, NULL);

        if (DRM_SUCCEEDED (dr))
        {
            /* extract the value="KIDasbase64" from the challenge */

            ChkDR(DRM_XML_GetNodeAttribute(&dstrKID, &g_dstrLabelValue, &dstrKIDB64));

            /* write the KID entries in the response */

            ChkDR(DRM_XMB_WriteTag(pbOut, &g_dstrTagKID, NULL, &g_dstrLabelValue, &dstrKIDB64, wttClosed));   /*   <KID value="base64"/> */
        }
        else if (dr == DRM_E_NOMORE
             ||  dr == DRM_E_XMLNOTFOUND)
        {
            dr = DRM_SUCCESS;
            break;
        }
        else
        {
            ChkDR(dr);
        }
    } /* end while more KIDs */

    ChkDR(DRM_XMB_EncryptAndCloseCurrNode(pbOut, 
                                          pcontextCrypto,
                                          ppubkeEncrypt,
                                          NULL)); /* </RECORDS> */
   
    if (fPartialData)
    {                                                                 /*     <PARTIALDATA>1</PARTIALDATA> */
        ChkDR(DRM_XMB_WriteTag(pbOut, &g_dstrTagPartialData, &g_dstr1, NULL, NULL, wttClosed));
    }

    /*Close the data node */
    ChkDR(DRM_XMB_CloseCurrNode(pbOut,  &dstrClose));

    /*Sign it with Signing key*/

    ChkDR(DRM_PK_Sign(pcontextCrypto->rgbCryptoContext, 
                      pSignKey,
             PB_DSTR(&dstrClose), 
             CB_DSTR(&dstrClose), 
                      pcontextCrypto->union_cert.cert.sign));

    /*Base64 encode signature*/
    cbBuffer = PK_ENC_SIGNATURE_B64LEN;

    ChkDR(DRM_B64_EncodeW((DRM_BYTE *)pcontextCrypto->union_cert.cert.sign, 
                           PK_ENC_SIGNATURE_LEN, 
             (DRM_WCHAR *) pcontextCrypto->rgbCryptoContext, 
                          &cbBuffer, 
                           0));
    /*Write to tag*/

    DSTR_FROM_PB(&dstrSign, pcontextCrypto->rgbCryptoContext, cbBuffer * SIZEOF(DRM_WCHAR));
    
    ChkDR(DRM_XMB_WriteTag(pbOut, &g_dstrTagMSDRMSignature, &dstrSign, NULL, NULL, wttClosed));

    DSTR_FROM_PB(&dstrSign, pwszCertFile, cchCertFile*SIZEOF(DRM_WCHAR));

    ChkDR(DRM_XMB_AppendNode   (pbOut, &dstrSign));
    ChkDR(DRM_XMB_CloseDocument(pbOut, &strXML));  /* </METERDATA> */

    memmove (pbOut,
             PB_DSTR(&strXML),
             CB_DSTR(&strXML));

    pwszOut = (DRM_WCHAR *) pbOut;
    pwszOut [strXML.cchString] = g_wchNull;

    dr = OEM_WriteFile(hfileIn, (DRM_VOID *) pwszOut, CB_DSTR(&strXML), &cbWritten)
                ? DRM_SUCCESS
                : DRM_E_FILEWRITEERROR;

ErrorExit:

    if (pbOut != NULL)
    {
        OEM_free(pbOut);
    }
    if (pcontextCrypto != NULL)
    {
        OEM_free(pcontextCrypto);
    }


    return dr;
}

/*******************************************************************
*              PRIVATE FUNCTION RespondToChallenge
*
* purpose: high-level driver of this tool.
*          opens the files and calls next-lower-level functions
*          to verify, sign, and write the metering response
*******************************************************************/

static DRM_RESULT RespondToChallenge (
    const DRM_WCHAR  *pszFilePrivKey,
    const DRM_WCHAR  *pszFileChallenge,
    const DRM_WCHAR  *pszFileResponse,
    const DRM_WCHAR  *pszFileMeterCert)
{
    PRIVKEY              privkeyMAS    = { 0 };
    PUBKEY               pubkeyEncrypt = { 0 };
    DRM_RESULT           dr            = DRM_SUCCESS;
    OEM_FILEHDL          hfileOut      = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD            cbFile        = 0;
    DRM_DWORD            cbCertFile    = 0;
    DRM_BOOL             fPartialData  = FALSE;
    DRM_WCHAR           *pwszFile      = NULL;
    DRM_WCHAR           *pwszCertFile  = NULL;
    DRM_CONST_STRING     dstrListData  = EMPTY_DRM_STRING,
                         dstrMID       = EMPTY_DRM_STRING,
                         dstrCertMID   = EMPTY_DRM_STRING,
                         dstrTID       = EMPTY_DRM_STRING,
                         dstrPassword  = EMPTY_DRM_STRING,
                         dstrRecords   = EMPTY_DRM_STRING;

    ZEROMEM(&privkeyMAS, SIZEOF (privkeyMAS));

    ChkFAIL (DoSetup (pszFilePrivKey,
                      pszFileChallenge,
                      pszFileResponse,
                      pszFileMeterCert,
                     &privkeyMAS,
                     &hfileOut,
                     &pwszFile,
                     &cbFile,
                     &pwszCertFile,
                     &cbCertFile));

    ChkDR(ParseMeterChallenge (pwszFile,
                               cbFile / SIZEOF (DRM_WCHAR),
                               &dstrMID,
                               &dstrTID,
                               &dstrRecords,
                               &pubkeyEncrypt,
                               &privkeyMAS,
                               &fPartialData));

    ChkDR(ParseMeterCert (pwszCertFile,
                          cbCertFile / SIZEOF (DRM_WCHAR),
                          &dstrCertMID,
                          &privkeyMAS ));

    /*Verify MIDs*/
    if (! DRM_UTL_DSTRStringsEqual(&dstrCertMID,&dstrMID))
    {
        ChkDR(DRM_E_METERING_MID_MISMATCH);
    }

    ChkDR(WriteMeterResponse(hfileOut,
                            &dstrMID,
                            &dstrTID,
                            &dstrRecords,
                            &pubkeyEncrypt,
                             fPartialData,
                             pwszCertFile,
                             cbCertFile / SIZEOF (DRM_WCHAR),
                            &privkeyMAS));

    printf ("metering reset is %s\n", fPartialData ? "partial" : "entire");

ErrorExit:

    if (pwszFile != NULL)
    {
        OEM_free (pwszFile);
    }
    if (pwszCertFile != NULL)
    {
        OEM_free (pwszCertFile);
    }

    if (hfileOut != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile (hfileOut);
    }

    return dr;
}

/******************************************************************************
** Print a command menu to console
*******************************************************************************/

static void PrintUsage (
    DRM_WCHAR *pwszAppName)
{
    printf ("Syntax: %S [-?] -p:PrivKeyFile -i:InputFile -o:ResponseFile, -m:metercert.xml\n", pwszAppName);
    printf ("PrivKeyFile   - UNICODE XML with MAS' private key\n"
            "InputFile     - UNICODE XML of metering challenge\n"
            "ResponseFile  - UNICODE XML of metering response\n"
            "metercert.xml - UNICODE XML of metering cert\n");
}

/*******************************************************************
*                      PUBLIC FUNCTION wmain
*
* purpose: entrypoint; validates args and calls driver
*******************************************************************/

DRM_VOID DRM_API wmain (
    DRM_INT     argc,
    DRM_WCHAR **argv)
{
    DRM_CONST_STRING dstrPrivKey        = EMPTY_DRM_STRING,
                     dstrResponse       = EMPTY_DRM_STRING,
                     dstrInput          = EMPTY_DRM_STRING,
                     dstrFileMeterCert  = EMPTY_DRM_STRING;
    DRM_INT          iArg               =   0;

    printf ("Microsoft (r) %s\nCopyright (c) Microsoft Corporation. All rights reserved.\n\n", "DRM create metering response tool");

    for (iArg = 1; iArg < argc; iArg++)
    {
        DRM_WCHAR        wchOption = 0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;

        if( !DRM_CMD_ParseCmdLine (argv [iArg], &wchOption, &dstrParam, NULL))
        {
            goto _PrintUsage;
        }
        
        wchOption = towlower (wchOption);

        switch (wchOption)
        {
        case WCHAR_CAST('i'):
            ASSIGN_DRM_STRING(dstrInput, dstrParam);
            break;

        case WCHAR_CAST('o'):
            ASSIGN_DRM_STRING(dstrResponse, dstrParam);
            break;

        case WCHAR_CAST('p'):
            ASSIGN_DRM_STRING(dstrPrivKey, dstrParam);
            break;

        case WCHAR_CAST('m'):  
            ASSIGN_DRM_STRING(dstrFileMeterCert, dstrParam);
            break;
            
        default:
            goto _PrintUsage;
        }
    }
   
    if (dstrPrivKey .cchString      == 0
     || dstrResponse.cchString      == 0
     || dstrInput.cchString         == 0 
     || dstrFileMeterCert.cchString == 0 )
    {
        printf ("Missing arguments.\n");
        goto _PrintUsage;
    }
   
    RespondToChallenge (dstrPrivKey .pwszString,
                        dstrInput   .pwszString,
                        dstrResponse.pwszString,
                        dstrFileMeterCert.pwszString);
    return;

_PrintUsage:
    PrintUsage (argv [0]);
}
#else
#include <stdio.h> /* for missing CRT functions like printf */
DRM_VOID DRM_API wmain(
    DRM_INT     argc, 
    DRM_WCHAR **argv)
{
    printf ("your build settings don't support this feature");
}                        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\generatekeypair.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <drmpkcrypto.h>
#include <drmlicense.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <drmdevcert.h>
#include <stdio.h>

#include <drmtoolsconstants.h>
#include <drmtoolsmacros.h>
#include <drmtoolsutils.h>

#define XML_INIT_SIZE   1024

typedef struct DRMSTATE
{
    PUBKEY              PubKey;
    PRIVKEY             PrivKey;
    FILE                *Outfp;
    FILE                *OutfpXml;
    DRM_BYTE            *pbOut;
    DRM_CRYPTO_CONTEXT  *pCrypto;
}DRMSTATE;

/****************************************************************************/
void DRMClose( DRMSTATE **ppState )
{
    if ( *ppState )
    {
        if ( (*ppState)->Outfp != NULL )
        {
            fclose( (*ppState)->Outfp );
        }
        if ( (*ppState)->OutfpXml != NULL )
        {
            fclose( (*ppState)->OutfpXml );
        }
        if ( (*ppState)->pCrypto )
        {
            OEM_free( (*ppState)->pCrypto );
        }

        if ( (*ppState)->pbOut )
        {
            OEM_free( (*ppState)->pbOut );
        }
        OEM_free( *ppState );

        *ppState = NULL;

    }
}
/****************************************************************************/


DRM_RESULT DRMInit( DRMSTATE **ppState )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkMem( *ppState = ( DRMSTATE* ) OEM_malloc( SIZEOF(DRMSTATE ) ) );
    ZEROMEM(*ppState, SIZEOF(DRMSTATE ) );
    (*ppState)->Outfp = NULL;
    ChkMem( (*ppState)->pCrypto = (DRM_CRYPTO_CONTEXT *)OEM_malloc( SIZEOF( DRM_CRYPTO_CONTEXT ) ) );
    ZEROMEM((*ppState)->pCrypto, SIZEOF( DRM_CRYPTO_CONTEXT ) );

ErrorExit:
    return dr;
}


/****************************************************************************/
DRM_RESULT CreateKeyPair( DRMSTATE *pState )
{

    DRM_RESULT                  dr = DRM_SUCCESS;
    DRM_STRING                  dstrPubkey  = EMPTY_DRM_STRING;
    DRM_STRING                  dstrPrivkey = EMPTY_DRM_STRING;
    DRM_STRING                  dstrClose   = EMPTY_DRM_STRING;
    DRM_DWORD                   dwSize = 0;

    ChkDR( DRM_PK_GenKeyPair( pState->pCrypto->rgbCryptoContext, &(pState->PubKey) , &( pState->PrivKey ) ) );
   
    ChkDR( DRMTOOLS_TestKeyPair( &(pState->PubKey), &(pState->PrivKey), pState->pCrypto ) );

    if (NULL != pState->Outfp)
    {
        /*Write to text file*/
    
        fprintf(pState->Outfp, "\n\nPRIVKEY: \n{" );
        for( dwSize = 0; dwSize < SIZEOF( pState->PrivKey ); dwSize++ )
        {
            if ( dwSize % 10 )
            {
                if ( dwSize == SIZEOF( pState->PrivKey ) -1 )
                {
                    fprintf(pState->Outfp," 0x%2.2x", ((DRM_BYTE*)&(pState->PrivKey))[dwSize] );
                }
                else
                {
                    fprintf(pState->Outfp," 0x%2.2x, ", ((DRM_BYTE*)&(pState->PrivKey))[dwSize] );
                }
            }
            else
            {
                fprintf(pState->Outfp,"\n 0x%2.2x, ", ((DRM_BYTE*)&(pState->PrivKey))[dwSize]);
            }
        }

        fprintf(pState->Outfp, "\n}\n\nPUBKEY: \n{" );
        for( dwSize = 0; dwSize< SIZEOF( pState->PubKey ); dwSize++ )
        {
  
            
           if ( dwSize % 10 )
            {
                if ( dwSize == SIZEOF( pState->PubKey ) -1 )
                {
                    fprintf(pState->Outfp," 0x%2.2x", ((DRM_BYTE*)&(pState->PubKey))[dwSize] );
                }
                else
                {
                    fprintf(pState->Outfp," 0x%2.2x, ", ((DRM_BYTE*)&(pState->PubKey))[dwSize] );
                }
            }
            else
            {
                fprintf(pState->Outfp,"\n 0x%2.2x, " , ((DRM_BYTE*)&(pState->PubKey))[dwSize]);
            }
        }
        fprintf( pState->Outfp, "\n}\n\n");
    }
    if (NULL != pState->OutfpXml)
    {        
        dstrPubkey.cchString = CCH_BASE64_EQUIV( SIZEOF(pState->PubKey) );
        ChkMem( dstrPubkey.pwszString = (DRM_WCHAR *)OEM_malloc( dstrPubkey.cchString * SIZEOF ( DRM_WCHAR ) ) );
        ChkDR(DRM_B64_EncodeW((const DRM_BYTE * ) &(pState->PubKey), 
                              SIZEOF(pState->PubKey), 
                              dstrPubkey.pwszString, 
                             &dstrPubkey.cchString, 
                              0));
                
        dstrPrivkey.cchString = CCH_BASE64_EQUIV( SIZEOF(pState->PrivKey) );
        ChkMem( dstrPrivkey.pwszString = (DRM_WCHAR *)OEM_malloc( dstrPrivkey.cchString * SIZEOF ( DRM_WCHAR ) ) );
        ChkDR(DRM_B64_EncodeW((const DRM_BYTE * )&(pState->PrivKey), SIZEOF(pState->PrivKey), dstrPrivkey.pwszString, &dstrPrivkey.cchString, 0 ) );

        ChkMem( pState->pbOut = (DRM_BYTE*) OEM_malloc( XML_INIT_SIZE ) );
        ZEROMEM(pState->pbOut, XML_INIT_SIZE );
       
        ChkDR( DRM_XMB_CreateDocument( XML_INIT_SIZE, pState->pbOut, &g_dstrTagKeypair));

        /* Add PUBKEY node */

        CallXmlBuilder(pState->pbOut, 
            DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagPubkey ));

        CallXmlBuilder(pState->pbOut, 
            DRM_XMB_AddData( pState->pbOut, (DRM_CONST_STRING *)&dstrPubkey ));

        CallXmlBuilder(pState->pbOut, 
            DRM_XMB_CloseCurrNode( pState->pbOut, NULL ) );

        /* Add PRIVKEY node */

        CallXmlBuilder(pState->pbOut, 
            DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagPrivkey ));

        CallXmlBuilder(pState->pbOut, 
            DRM_XMB_AddData( pState->pbOut, (DRM_CONST_STRING *)&dstrPrivkey ));

        CallXmlBuilder(pState->pbOut, 
            DRM_XMB_CloseCurrNode( pState->pbOut, NULL ) );

        /* close the root node */
        CallXmlBuilder(pState->pbOut, 
            DRM_XMB_CloseDocument(pState->pbOut, &dstrClose));
  
        dwSize = dstrClose.cchString * SIZEOF(DRM_WCHAR);

        if ( fwrite(dstrClose.pwszString, 1, dwSize, pState->OutfpXml ) != dwSize ) ;
        {
            ChkDR(DRM_E_FILEWRITEERROR);
        }
    }

ErrorExit:

    if (pState        != NULL
    &&  pState->pbOut != NULL)
    {
        OEM_free(pState->pbOut);
        pState->pbOut = NULL;
    }
    
    if ( dstrPubkey.pwszString )
    {
        OEM_free( dstrPubkey.pwszString );
    }
    if ( dstrPrivkey.pwszString )
    {
        OEM_free( dstrPrivkey.pwszString );
    }
   return dr;
}

/****************************************************************************/


/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] -o:OutputFile -x:OutputXmlFile \n", pwszAppName);
}

/******************************************************************************
** 
*******************************************************************************
*/

DRM_VOID DRM_API wmain( 
    DRM_INT     argc, 
    DRM_WCHAR **argv )
{
    DRM_CONST_STRING dstrOutputFile = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrXMLFile    = EMPTY_DRM_STRING;

    DRM_INT i;
    DRM_RESULT dr = DRM_SUCCESS;
    DRMSTATE *pState = NULL;

    printf( "Microsoft (R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "Key Pair Generation Tool" );

    for( i = 1; i<argc; i++ )
    {
        DRM_WCHAR        wchOption = 0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;
        if ( !DRM_CMD_ParseCmdLine(argv[i], &wchOption, &dstrParam, NULL) )
        {
            goto _PrintUsage;
        }
        wchOption = towlower( wchOption );
        switch( wchOption )
        {
        case WCHAR_CAST('o'):
            dstrOutputFile = dstrParam;
            break;
        case WCHAR_CAST('x'):
            dstrXMLFile = dstrParam;
            break;
         default:
            goto _PrintUsage;
        }
    }

    if( dstrOutputFile.cchString == 0
     && dstrXMLFile   .cchString == 0 )
    {
        goto _PrintUsage;
    }
    if ( dstrOutputFile.cchString > (DRM_MAX_PATH-1)
      || dstrXMLFile   .cchString > (DRM_MAX_PATH-1) )
    {
        printf( "File name is too big. Max Filename is %d \n", DRM_MAX_PATH );
        goto ErrorExit;
    }

    ChkDR( DRMInit( &pState ) );


    if( dstrOutputFile.cchString )
    {
        DRM_CHAR rgchFileName[DRM_MAX_PATH];
        
        DRM_UTL_DemoteUNICODEtoANSI( dstrOutputFile.pwszString, rgchFileName, dstrOutputFile.cchString );
        pState->Outfp = (FILE*)fopen(rgchFileName, "w+b");
        if( NULL == pState->Outfp )
        {
            printf( "Output text file not opened\n" );
            goto ErrorExit;
        }
    }

    if( dstrXMLFile.cchString )
    {
        DRM_CHAR rgchFileName[DRM_MAX_PATH];
        
        DRM_UTL_DemoteUNICODEtoANSI( dstrXMLFile.pwszString, rgchFileName, dstrXMLFile.cchString );
        pState->OutfpXml = (FILE*)fopen(rgchFileName, "w+b");
        if( NULL == pState->OutfpXml )
        {
            printf( "Output XML file not opened\n" );
            goto ErrorExit;
        }
    }

    if ( pState->Outfp || pState->OutfpXml )
    {
        ChkDR( CreateKeyPair( pState ) );
    }

ErrorExit:
    
    if ( pState )
    {
        DRMClose( &pState );
    }

    return;
_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\meterview.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <drmcrt.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <stdio.h> /* for missing CRT functions like printf */

#if DRM_SUPPORT_METERING

DRM_RESULT DumpMeteringForMID (DRM_CONST_STRING *f_pdstrXMLMeterCert,
                               DRM_CONST_STRING *f_pdstrFileChallenge,
                               DRM_CONST_STRING *f_pdstrFileURL,
                               DRM_CONST_STRING *f_pdstrFileDataStore)
{
    DRM_MANAGER_CONTEXT *pcontextManager;
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   *pbMeteringData = NULL;
    DRM_DWORD   cbMeteringData = 0;
    DRM_DWORD   cchURL         = 0;
    DRM_WCHAR  *pwszURL        = NULL;
    OEM_FILEHDL hfile = OEM_INVALID_HANDLE_VALUE;

    ChkMem(pcontextManager = OEM_malloc(SIZEOF (DRM_MANAGER_CONTEXT)))
    
    ZEROMEM(pcontextManager, SIZEOF (DRM_MANAGER_CONTEXT));
    
    ChkDR(DRM_MGR_Initialize(pcontextManager, f_pdstrFileDataStore));
    
    dr = DRM_MGR_GenerateMeterChallenge(pcontextManager, f_pdstrXMLMeterCert, NULL, &cchURL, NULL, &cbMeteringData);
    
    if (dr != DRM_E_BUFFERTOOSMALL)
    {
        ChkDR(dr);
    }
    
    ChkMem(pbMeteringData = (DRM_BYTE  *) OEM_malloc(cbMeteringData));
    ChkMem(pwszURL        = (DRM_WCHAR *) OEM_malloc(cchURL * SIZEOF (DRM_WCHAR)));
    
    ChkDR(DRM_MGR_GenerateMeterChallenge(pcontextManager, 
                                         f_pdstrXMLMeterCert, 
                                         pwszURL, 
                                        &cchURL, 
                                         pbMeteringData, 
                                        &cbMeteringData));

    printf ("output:\n%S", (DRM_WCHAR *) pbMeteringData);    

    if ((hfile = OEM_OpenFile(f_pdstrFileChallenge->pwszString, 
                              OEM_GENERIC_WRITE, 
                              OEM_FILE_SHARE_READ, 
                              OEM_CREATE_ALWAYS, 
                              OEM_ATTRIBUTE_NORMAL)) != OEM_INVALID_HANDLE_VALUE)
    {
        DRM_DWORD cbWritten    = 0;
                
        OEM_WriteFile(hfile, pbMeteringData, cbMeteringData, &cbWritten);
        OEM_CloseFile(hfile);
    }
    else
    {
        printf ("error opening file %S\n", f_pdstrFileChallenge->pwszString);
    }

    /* if requested write URL to a separate file */

    if (f_pdstrFileURL->cchString > 0)
    {
        OEM_FILEHDL hfileURL = OEM_INVALID_HANDLE_VALUE;
        
        hfileURL = OEM_OpenFile(f_pdstrFileURL->pwszString, 
                                OEM_GENERIC_WRITE, 
                                OEM_FILE_SHARE_READ, 
                                OEM_CREATE_ALWAYS, 
                                OEM_ATTRIBUTE_NORMAL);
                                  
        if (hfileURL != OEM_INVALID_HANDLE_VALUE)
        {
            DRM_DWORD cbWritten    = 0;
                    
            OEM_WriteFile(hfileURL, pwszURL, cchURL * SIZEOF (DRM_WCHAR), &cbWritten);
            OEM_CloseFile(hfileURL);
        }
        else
        {
            printf("error opening file %S\n", f_pdstrFileURL->pwszString);
        }
    }
ErrorExit:

    if (DRM_FAILED(dr))
    {
        printf("error 0x%08X\n", dr);
    }

    if (pbMeteringData != NULL)
    {
        OEM_free(pbMeteringData);
    }
    
    if (pwszURL != NULL)
    {
        OEM_free(pwszURL);
    }
    
    if (pcontextManager != NULL)
    {
        DRM_MGR_Uninitialize(pcontextManager);

        OEM_free(pcontextManager);
    }

    return dr;
}

/******************************************************************************
** Print a command menu to console
*******************************************************************************/

static void PrintUsage (DRM_WCHAR *pwszAppName)
{
    printf ("Syntax: %S [-?] -s:DataStoreName -m:metercert.xml -o:OutputFile [-u:URLFile]\n", pwszAppName);
}

#if EMBEDDED_WITH_NO_PARAMS

/* metergen.exe */
DRM_WCHAR g_Arg1 [] = { TWO_BYTES('m', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('g', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('\0', '\0')};
/*-s:datastore.hds */
DRM_WCHAR g_Arg2 [] = { TWO_BYTES('-', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('s', '\0'), TWO_BYTES('\0', '\0')};
/*-m:metercertsignedU.xml */
DRM_WCHAR g_Arg3 [] = { TWO_BYTES('-', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('i', '\0'),  TWO_BYTES('g', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('U', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('\0', '\0')};
/*-o:challenge.xml*/ 
DRM_WCHAR g_Arg4 [] = { TWO_BYTES('-', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('g', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('\0', '\0')};
/*-u:url.txt*/
DRM_WCHAR g_Arg5 [] = { TWO_BYTES('-', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('\0', '\0')};

DRM_WCHAR *g_argv [] = 
{ 
    g_Arg1, 
    g_Arg2, 
    g_Arg3,
    g_Arg4,
    g_Arg5
};

DRM_INT   g_argc = 5;

#endif

DRM_VOID DRM_API wmain (DRM_INT     argc, 
                        DRM_WCHAR **argv)
{    
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrStoreName      = EMPTY_DRM_STRING,
                     dstrOutput         = EMPTY_DRM_STRING,
                     dstrFileMeterCert  = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrXMLMeterCert   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrFileURL        = EMPTY_DRM_STRING;
    DRM_INT          iArg               = 0;
    OEM_FILEHDL hfile    = OEM_INVALID_HANDLE_VALUE;
    DRM_WCHAR  *pwchFile = NULL;
    DRM_DWORD   cbFile   = 0,
                cbRead   = 0;
                
                
    printf ("Microsoft(R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "DRM Metering store dump tool");

#if EMBEDDED_WITH_NO_PARAMS
    argc = g_argc;
    argv = g_argv;
#endif

    for (iArg = 1; iArg < argc; iArg++)
    {
        DRM_WCHAR        wchOption = 0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;

        if( !DRM_CMD_ParseCmdLine(argv [iArg], &wchOption, &dstrParam, NULL))
        {
            goto _PrintUsage;
        }
        wchOption = towlower(wchOption);

        switch (wchOption)
        {
        case WCHAR_CAST('s'):  
            ASSIGN_DRM_STRING(dstrStoreName, dstrParam);
            break;
            
        case WCHAR_CAST('m'):  
            ASSIGN_DRM_STRING(dstrFileMeterCert, dstrParam);
            break;
            
        case WCHAR_CAST('o'):  
            ASSIGN_DRM_STRING(dstrOutput, dstrParam);
            break;
            
        case WCHAR_CAST('u'):  
            ASSIGN_DRM_STRING(dstrFileURL, dstrParam);
            break;
            
        default:
            goto _PrintUsage;
        }
    }

    if( dstrStoreName    .cchString == 0
     || dstrFileMeterCert.cchString == 0
     || dstrOutput       .cchString == 0 )
    {
        goto _PrintUsage;
    }
    
    if( dstrStoreName    .cchString > (DRM_MAX_PATH-1)
     || dstrFileMeterCert.cchString > (DRM_MAX_PATH-1)
     || dstrOutput       .cchString > (DRM_MAX_PATH-1) )
    {
        printf ("File name too long. Max length is %d.\n", DRM_MAX_PATH - 1);
        goto _PrintUsage;
    }
    
    hfile = OEM_OpenFile (dstrFileMeterCert.pwszString, 
                          OEM_GENERIC_READ, 
                          OEM_FILE_SHARE_NONE, 
                          OEM_OPEN_EXISTING, 
                          OEM_ATTRIBUTE_NORMAL);
    if( hfile == OEM_INVALID_HANDLE_VALUE)
    {
        printf( "Input file %S could not open.\n", dstrFileMeterCert.pwszString );
        goto _PrintUsage;
    }
    
    if (!OEM_GetFileSize (hfile, &cbFile))
    {
        printf ("Unable to get size for file %S.\n", dstrFileMeterCert.pwszString);
        goto ErrorExit;
    }
    
    ChkMem(pwchFile = (DRM_WCHAR*)OEM_malloc (cbFile));
    if (OEM_ReadFile (hfile, pwchFile, cbFile, &cbRead))
    {
        DSTR_FROM_PB( &dstrXMLMeterCert, pwchFile, cbFile )
        DumpMeteringForMID(&dstrXMLMeterCert, 
                           &dstrOutput, 
                           &dstrFileURL, 
                           &dstrStoreName);
    }
    else
    {
        printf ("Unable to read input file %S.\n", dstrFileMeterCert.pwszString);
    }
  
ErrorExit:
    if( hfile != OEM_INVALID_HANDLE_VALUE )
    {
        OEM_CloseFile( hfile );
    }
    if( pwchFile != NULL )
    {
        OEM_free (pwchFile);
    }
    return;
    
_PrintUsage:
    PrintUsage (argv [0]);
}
#else
#include <stdio.h> /* for missing CRT functions like printf */
DRM_VOID DRM_API wmain (DRM_INT     argc, 
                        DRM_WCHAR **argv)
{
    printf ("your build settings don't support this feature");
}                        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\meterresponse.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <drmcrt.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <drmxmlparser.h>
#include <drmxmlbuilder.h>
#include <stdio.h> /* for missing CRT functions like printf */

#if DRM_SUPPORT_METERING
/*    <METERDATA type="response">
        <DATA>
            <MID>UiW5yBMep2CuevGg5+FgA3==</MID>
            <TID>Mep2CuevGgUiW5yB5+FgA3==</TID>
            <COMMAND>RESET</COMMAND>
            <RECORDS>
                <KID value="KID1" />
                <KID value="KID2" />
                ...
            </RECORDS>
            <PARTIALDATA>1</PARTIALDATA>
        </DATA>
        <HASH>
            <HASHALGORITHM type="HMAC" />
            <VALUE>
                Base64-encoded hash
            </VALUE>
        </HASH>
    </METERDATA> */

DRM_RESULT ProcessMeterResponse (const DRM_WCHAR  *pszInput,
                                 DRM_DWORD        *pflagsResponse,
                                 DRM_CONST_STRING *pdstrDataStore)
{
    DRM_MANAGER_CONTEXT *pcontextManager = NULL;
    DRM_CONST_STRING     dstrMeterResp   = EMPTY_DRM_STRING;
    DRM_RESULT           dr              = DRM_SUCCESS;

    dstrMeterResp.cchString  = wcslen (pszInput);
    dstrMeterResp.pwszString = pszInput;
    
    ChkMem (pcontextManager = OEM_malloc (SIZEOF (DRM_MANAGER_CONTEXT)))
    
    ChkDR (DRM_MGR_Initialize (pcontextManager, pdstrDataStore));
    
    ChkDR  (DRM_MGR_ProcessMeterResponse (pcontextManager,
                             (DRM_BYTE *) PB_DSTR (&dstrMeterResp),
                                          CB_DSTR (&dstrMeterResp),
                                          pflagsResponse));
ErrorExit:

    if (pcontextManager != NULL)
    {
        OEM_free (pcontextManager);
    }

    return dr;
}

/******************************************************************************
** Print a command menu to console
*******************************************************************************/

static void PrintUsage (DRM_WCHAR *pwszAppName)
{
    printf ("Syntax: %S [-?] -s:DataStoreName -i:meterreponse.xml \n", pwszAppName);
}

#if EMBEDDED_WITH_NO_PARAMS

/* meterresp.exe */
DRM_WCHAR g_Arg1 [] = { TWO_BYTES('m', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('\0', '\0')};
/*-s:datastore.hds */
DRM_WCHAR g_Arg2 [] = { TWO_BYTES('-', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('s', '\0'), TWO_BYTES('\0', '\0')};
/*-i:response.xml*/ 
DRM_WCHAR g_Arg3 [] = { TWO_BYTES('-', '\0'),  TWO_BYTES('i', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('\0', '\0')};

DRM_WCHAR *g_argv [] = 
{ 
    g_Arg1, 
    g_Arg2, 
    g_Arg3
};

DRM_INT g_argc = 3;

#endif

DRM_VOID DRM_API wmain (DRM_INT     argc, 
                        DRM_WCHAR **argv)
{   
    DRM_RESULT dr = DRM_SUCCESS; 
    DRM_CONST_STRING dstrStoreName      = EMPTY_DRM_STRING,
                     dstrFileMeterResp  = EMPTY_DRM_STRING;
    DRM_INT          iArg               = 0;
    OEM_FILEHDL hfile         = OEM_INVALID_HANDLE_VALUE;
    DRM_WCHAR  *pwchFile      = NULL;
    DRM_DWORD   cbFile        = 0,
                cbRead        = 0,
                flagsResponse = 0;

    printf ("Microsoft(R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "DRM metering response tool");

#if EMBEDDED_WITH_NO_PARAMS
    argc = g_argc;
    argv = g_argv;
#endif

    for (iArg = 1; iArg < argc; iArg++)
    {
        DRM_WCHAR        wchOption = 0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;

        if(!DRM_CMD_ParseCmdLine(argv [iArg], &wchOption, &dstrParam, NULL))
        {
            goto _PrintUsage;
        }
        wchOption = towlower (wchOption);

        switch (wchOption)
        {
        case WCHAR_CAST('s'):  
            dstrStoreName = dstrParam;
            break;
        case WCHAR_CAST('i'):  
            dstrFileMeterResp = dstrParam;
            break;
        default:
            goto _PrintUsage;
        }
    }
      
    if ( dstrStoreName    .cchString == 0
      || dstrFileMeterResp.cchString == 0)
    {
        /* argument not supplied */
        printf ("Missing arguments.\n");
        goto _PrintUsage;
    }
    
    hfile = OEM_OpenFile (dstrFileMeterResp.pwszString, 
                          OEM_GENERIC_READ, 
                          OEM_FILE_SHARE_NONE, 
                          OEM_OPEN_EXISTING, 
                          OEM_ATTRIBUTE_NORMAL);
    if( hfile == OEM_INVALID_HANDLE_VALUE)
    {
        printf( "Unable to open file %S\n", dstrFileMeterResp.pwszString );
        ChkDR( DRM_E_FILENOTFOUND );
    }
    if (!OEM_GetFileSize (hfile, &cbFile))
    {
        printf( "Unable to get the size of file %S\n", dstrFileMeterResp.pwszString );
        ChkDR( DRM_E_FILEREADERROR );
    }
    
    ChkMem( pwchFile = (DRM_WCHAR*)OEM_malloc (cbFile));
    if (!OEM_ReadFile (hfile, pwchFile, cbFile, &cbRead))
    {
        printf ("Unable to input file read file %S.\n", dstrFileMeterResp.pwszString);
        ChkDR( DRM_E_FILEREADERROR );
    }
    ChkDR(ProcessMeterResponse (pwchFile, &flagsResponse, &dstrStoreName));
    printf ("Success processing file %S.\nPartial Data: %s\n", dstrFileMeterResp.pwszString,
             ((flagsResponse & DRM_METER_RESPONSE_PARTIAL) ? "yes" : "no"));
                  
ErrorExit:
    if( hfile != OEM_INVALID_HANDLE_VALUE )
    {
        OEM_CloseFile (hfile);
    }
    if( pwchFile != NULL )
    {
        OEM_free(pwchFile);
    }
    
    return;
    
_PrintUsage:
    PrintUsage (argv [0]);
}
#else
#include <stdio.h> /* for missing CRT functions like printf */
DRM_VOID DRM_API wmain (DRM_INT     argc, 
                        DRM_WCHAR **argv)
{
    printf ("your build settings don't support this feature");
}                        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\oemcriticalsection.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#if defined (_WIN32)
#if _MULTI_THREADING_SUPPORT
#include <windows.h>
#else
#include <stdlib.h>
#endif
#define NO_DRM_CRT 1
#include <drmcommon.h>
#include <oemimpl.h>


/* ============================================================================ */
DRM_VOID DRM_API 
OEM_InitializeCriticalSection(
    IN OUT OEM_CRITICAL_SECTION *pCS)
{
#if _MULTI_THREADING_SUPPORT==1
    CRITICAL_SECTION *poCS=(CRITICAL_SECTION *)pCS;
    DRMSIZEASSERT(SIZEOF(OEM_CRITICAL_SECTION), SIZEOF(CRITICAL_SECTION));
    InitializeCriticalSection(poCS);
#endif
}


/* ============================================================================ */
DRM_VOID DRM_API 
OEM_DeleteCriticalSection(
    IN OUT OEM_CRITICAL_SECTION *pCS)
{
#if _MULTI_THREADING_SUPPORT==1
    CRITICAL_SECTION *poCS=(CRITICAL_SECTION *)pCS;
    DRMSIZEASSERT(SIZEOF(OEM_CRITICAL_SECTION), SIZEOF(CRITICAL_SECTION));
    DeleteCriticalSection(poCS);

    ZEROMEM(poCS, SIZEOF(CRITICAL_SECTION));
#endif
}
    

/* ============================================================================ */
DRM_VOID DRM_API 
OEM_EnterCriticalSection(
    IN OUT OEM_CRITICAL_SECTION *pCS)
{
#if _MULTI_THREADING_SUPPORT==1
    CRITICAL_SECTION *poCS=(CRITICAL_SECTION *)pCS;
    DRMSIZEASSERT(SIZEOF(OEM_CRITICAL_SECTION), SIZEOF(CRITICAL_SECTION));
    EnterCriticalSection(poCS);
#endif
}


/* ============================================================================ */
DRM_VOID DRM_API 
OEM_LeaveCriticalSection(
    IN OUT OEM_CRITICAL_SECTION *pCS)
{
#if _MULTI_THREADING_SUPPORT==1
    CRITICAL_SECTION *poCS=(CRITICAL_SECTION *)pCS;
    DRMSIZEASSERT(SIZEOF(OEM_CRITICAL_SECTION), SIZEOF(CRITICAL_SECTION));
    LeaveCriticalSection(poCS);
#endif
}

#endif   /* (_WIN32) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\oemimpl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMIMPL_H__
#define __OEMIMPL_H__

#include <drmsha1.h>
#include <drmpkcrypto.h>


#ifdef __cplusplus
extern "C" {
#endif

#define MAX_UNIQUEID_LEN 256
#define MAX_URL_LEN 256

/* Device information functions */

/**********************************************************************
** Function:    OEM_GetDeviceCert
** Synopsis:    Retreives the local device certificate.
** Arguments:   [pbDevCert] -- buffer to hold the device certificate
**              [pcbDevCert] -- pointer to DWORD that is the length of 
**              pbDevCert in bytes.  The length of the certicficate is 
**              returned here on function exit.
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL
**              DRM_E_FILEREADERROR
** Notes:       To get the minimum size required, first call with 
**              pbDevCert=NULL and pcbData points to value 0. This 
**              will return DRM_E_BUFFERTOOSMALL 
**              and pcbData will point to a value of minimum pbDevCert
***********************************************************************/
DRM_RESULT DRM_API OEM_GetDeviceCert(
    OUT    DRM_BYTE  *pbDevCert,
    IN OUT DRM_DWORD *pcbDevCert);

/**********************************************************************
** Function:    OEM_GetDeviceCertTemplate
** Synopsis:    Retreives the local device certificate.
** Arguments:   [pbDevCert] -- buffer to hold the device certificate
**              [pcbDevCert] -- pointer to DWORD that is the length of 
**              pbDevCert in bytes.  The length of the certicficate is 
**              returned here on function exit.
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL
**              DRM_E_FILEREADERROR
** Notes:       To get the minimum size required, first call with 
**              pbDevCert=NULL and pcbData points to value 0. This 
**              will return DRM_E_BUFFERTOOSMALL 
**              and pcbData will point to a value of minimum pbDevCert
***********************************************************************/
DRM_RESULT DRM_API OEM_GetDeviceCertTemplate(
    OUT    DRM_BYTE  *pbDevCert,
    IN OUT DRM_DWORD *pcbDevCert);



/**********************************************************************
** Function:    OEM_SetDeviceCert
** Synopsis:    Stores the local device certificate.
** Arguments:   [pbDevCert] -- buffer holding the device certificate
**              [cbDevCert] -- Length of pbDevCert in bytes.  
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_FILEWRITEERROR
***********************************************************************/

DRM_RESULT DRM_API OEM_SetDeviceCert(
    IN const DRM_BYTE *pbDevCert,
    IN DRM_DWORD       cbDevCert);


/**********************************************************************
** Function:    OEM_GetSecureStoreGlobalPasswordSeed
** Synopsis:    Retreives the local device global secure store password.
** Arguments:   [rgbSecStorePassword] -- buffer to hold the secure store
**              global password
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
***********************************************************************/
DRM_RESULT DRM_API OEM_GetSecureStoreGlobalPasswordSeed( 
    OUT DRM_BYTE rgbSecStorePassword [__CB_DECL(SHA_DIGEST_LEN)] );

/**********************************************************************
** Function:    OEM_GetGroupCertPrivateKey
** Synopsis:    Get the GroupCert private key
** Arguments:   [pPrivKey] -- Buffer to hold the device private key
***********************************************************************/
DRM_RESULT DRM_API OEM_GetGroupCertPrivateKey( 
    OUT PRIVKEY *pPrivKey );

/**********************************************************************
** Function:    OEM_GetFallbackPrivateKey
** Synopsis:    Get the Fallback private key
** Arguments:   [pPrivKey] -- Buffer to hold the device private key
***********************************************************************/
DRM_RESULT DRM_API OEM_GetFallbackSigningKey( 
    OUT PRIVKEY *pPrivKey);

/**********************************************************************
** Function:    OEM_GetUniqueID
** Synopsis:    Get the unique id of the device in WCHAR * format. 
**              It is compared in OEM_CompareMachineId.
** Arguments:   [wchUniqueId] -- Buffer to hold the device unique id.
**              Max len is MAX_UNIQUEID_LEN
**              [pLen] -- size of unique id in WCHAR
***********************************************************************/
DRM_RESULT DRM_API OEM_GetUniqueID( 
    IN DRM_WCHAR      wchUniqueId[MAX_UNIQUEID_LEN], 
    IN OUT DRM_DWORD *pLen );

/**********************************************************************
** Function:    OEM_GenRandomBytes
** Synopsis:    Generate random bytes using an OEM provided random 
**              number generator.
** Arguments:   [pbData] -- Buffer to hold the random bytes
**              [cbData] -- Count of bytes to generate and fill in pbData
***********************************************************************/
DRM_RESULT DRM_API OEM_GenRandomBytes( 
    OUT DRM_BYTE  *pbData,
    IN  DRM_DWORD  cbData );

/**********************************************************************
** Function:    OEM_GetClockResetState
** Synopsis:    Get the Secure Clock Reset state.
** Arguments:   [pfReset] -- Bool to get the state
***********************************************************************/
DRM_RESULT DRM_API OEM_GetClockResetState( 
    DRM_BOOL *pfReset );

/**********************************************************************
** Function:    OEM_SetClockResetState
** Synopsis:    Set the Secure Clock Reset state.
** Arguments:   [fReset] -- Bool to set the state
***********************************************************************/
DRM_RESULT DRM_API OEM_SetClockResetState( 
    DRM_BOOL fReset );


/* File IO functions
** =========================================================== 
*/

/* File Handle */
typedef DRM_VOID *OEM_FILEHDL;
#define OEM_INVALID_HANDLE_VALUE ((OEM_FILEHDL)-1)

#ifdef UNDER_CE
#define OEM_CRITICAL_SECTION_SIZE     20
#elif defined(_WIN64)
#define OEM_CRITICAL_SECTION_SIZE     40
#else
#define OEM_CRITICAL_SECTION_SIZE     24
#endif
typedef struct __tagOEM_CRITICAL_SECTION
{
    DRM_BYTE rgb [__CB_DECL(OEM_CRITICAL_SECTION_SIZE)];
} OEM_CRITICAL_SECTION;

/* OEM_OpenFile Access modes */

#define OEM_GENERIC_READ       (0x80000000L)
#define OEM_GENERIC_WRITE      (0x40000000L)
#define OEM_GENERIC_EXECUTE    (0x20000000L)
#define OEM_GENERIC_ALL        (0x10000000L)

/* OEM_OpenFile Share modes */

#define OEM_FILE_SHARE_NONE     0x00000000  
#define OEM_FILE_SHARE_READ     0x00000001  
#define OEM_FILE_SHARE_WRITE    0x00000002  

/* OEM_OpenFile Creation dispositions */

#define OEM_CREATE_NEW          1
#define OEM_CREATE_ALWAYS       2
#define OEM_OPEN_EXISTING       3
#define OEM_OPEN_ALWAYS         4
#define OEM_TRUNCATE_EXISTING   5

#define OEM_ATTRIBUTE_HIDDEN    0x00000002
#define OEM_ATTRIBUTE_SYSTEM    0x00000004
#define OEM_ATTRIBUTE_NORMAL    0x00000080

/* SetFilePointer move methods */

#define OEM_FILE_BEGIN          0
#define OEM_FILE_CURRENT        1
#define OEM_FILE_END            2

/* For information on these functions and parameters see MSDN 
   For OEM_OpenFile see CreateFile in MSDN -- not all flags are supported.*/

/**********************************************************************
** Function:    OEM_OpenFile
** Synopsis:    Creates, opens, reopens a file
** Arguments:   [pwFileName]--Pointer to DRM_WCHAR buffer holding File
**              name.
**              [dwAccessMode]--Type of access to the object. 
**              OEM_GENERIC_READ, OEM_GENERIC_WRITE,
**              OEM_GENERIC_EXECUTE and OEM_GENERIC_ALL
**              [dwShareMode]--Sharing mode of the object
**              OEM_FILE_SHARE_NONE, OEM_FILE_SHARE_READ
**              and OEM_FILE_SHARE_WRITE
**              [dwCreationDisposition]--Action to take on files 
**              that exist, and on files that do not exist.
**              OEM_CREATE_NEW, OEM_CREATE_ALWAYS, OEM_OPEN_EXISTING
**              OEM_OPEN_ALWAYS and OEM_TRUNCATE_EXISTING
**              [dwAttributes]--File attributes and flags.
**              OEM_ATTRIBUTE_HIDDEN, OEM_ATTRIBUTE_SYSTEM and
**              OEM_ATTRIBUTE_NORMAL
** Returns:     Valid OEM FILE HANDLE. If fails, 
**              returns OEM_INVALID_HANDLE_VALUE 
***********************************************************************/

OEM_FILEHDL DRM_API OEM_OpenFile(
    const DRM_WCHAR *pwFileName,
    DRM_DWORD        dwAccessMode,
    DRM_DWORD        dwShareMode,
    DRM_DWORD        dwCreationDisposition,
    DRM_DWORD        dwAttributes);

/**********************************************************************
** Function:    OEM_CloseFile
** Synopsis:    Closes an open handle opened by OEM_OpenFile.
** Arguments:   [hFile]--File Handle
** Returns:     Non zero value if succeeds, zero if failed.
***********************************************************************/
DRM_BOOL DRM_API OEM_CloseFile(
    OEM_FILEHDL hFile);

/**********************************************************************
** Function:    OEM_ReadFile
** Synopsis:    Reads data from a file.
** Arguments:   [hFile]--File Handle
**              [pvBuffer]--Pointer to the buffer that receives the 
**              data read from the file. 
**              [nNumberOfBytesToRead]--Number of bytes to read.
**              [pNumberOfBytesRead]--Total number of bytes read. 
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_BOOL DRM_API OEM_ReadFile(
    OEM_FILEHDL hFile,
    DRM_VOID   *pvBuffer,
    DRM_DWORD   nNumberOfBytesToRead,
    DRM_DWORD  *pNumberOfBytesRead);

/**********************************************************************
** Function:    OEM_WriteFile
** Synopsis:    Writes data to a file.
** Arguments:   [hFile]--File Handle
**              [pvBuffer]--Pointer to the buffer holding the 
**              data read to the file. 
**              [nNumberOfBytesToWrite]--Number of bytes to write.
**              [pNumberOfBytesWritten]--Total number of bytes written. 
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/

DRM_BOOL DRM_API OEM_WriteFile(
    OEM_FILEHDL hFile,
    DRM_VOID   *pvBuffer,
    DRM_DWORD   nNumberOfBytesToWrite,
    DRM_DWORD  *pNumberOfBytesWritten);

/**********************************************************************
** Function:    OEM_SetFilePointer
** Synopsis:    Sets File pointer.
** Arguments:   [lDistanceToMove]--Number of bytes to move
**              [dwMoveMethod]--Starting point for the file pointer move 
**              OEM_FILE_BEGIN, OEM_FILE_CURRENT and  OEM_FILE_END
**              [pdwNewFilePointer]--New File pointer.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/

DRM_BOOL DRM_API OEM_SetFilePointer(
    OEM_FILEHDL hFile,
    DRM_LONG    lDistanceToMove,
    DRM_DWORD   dwMoveMethod,
    DRM_DWORD  *pdwNewFilePointer);

/**********************************************************************
** Function:    OEM_LockFile
** Synopsis:    Immidiately locks the portion of specified file. 
** Arguments:   [hFile]--File Handle
**              [fExclusive]-- If TRUE, locks file for exclusive access  
**              by the calling process.
**              [dwFileOffset]--Offset from begining of file.
**              [nNumberOfBytesToLock]--Number of bytes to lock. 
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/

DRM_BOOL DRM_API OEM_LockFile(
    OEM_FILEHDL hFile,
    DRM_BOOL    fExclusive,
    DRM_DWORD   dwFileOffset,
    DRM_DWORD   nNumberOfBytesToLock,
    DRM_BOOL    fWait);

/**********************************************************************
** Function:    OEM_UnlockFile
** Synopsis:    Unlocks the locked portion of specified file. 
** Arguments:   [hFile]--File Handle
**              [dwFileOffset]--Offset from begining of file.
**              [nNumberOfBytesToLock]--Number of bytes to lock. 
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/

DRM_BOOL DRM_API OEM_UnlockFile(
    OEM_FILEHDL hFile,
    DRM_DWORD   dwFileOffset,
    DRM_DWORD   nNumberOfBytesToUnlock);

/**********************************************************************
** Function:    OEM_SetEndOfFile
** Synopsis:    Moves the end-of-file (EOF) position for the 
**              specified file to the current position of the file 
**              pointer. 
** Arguments:   [hFile]--File Handle
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/

DRM_BOOL DRM_API OEM_SetEndOfFile(
    OEM_FILEHDL hFile);

/**********************************************************************
** Function:    OEM_GetFileSize
** Synopsis:    Gets size of the file. 
** Arguments:   [hFile]--File Handle
**              [pdwFileSize]--Pointer to DRM_DWORD to get the size.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/

DRM_BOOL DRM_API OEM_GetFileSize(
    OEM_FILEHDL hFile,
    DRM_DWORD  *pdwFileSize);

/**********************************************************************
** Function:    OEM_FlushFileBuffers
** Synopsis:    Flushes the buffers of the specified file and causes 
**              all buffered data to be written to the file. 
** Arguments:   [hFile]--File Handle
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/

DRM_BOOL DRM_API OEM_FlushFileBuffers(
    OEM_FILEHDL hFile);


/* Memory allocation functions */

/**********************************************************************
** Function:    OEM_malloc
** Synopsis:    Allocates memory from heap. 
** Arguments:   [size]--Number of bytes to allocate.
** Returns:     Valid pointer if succeeds, NULL if failed. 
***********************************************************************/

DRM_VOID* DRM_API OEM_malloc(
    DRM_DWORD size);

/**********************************************************************
** Function:    OEM_free
** Synopsis:    Frees allocated memory. 
** Arguments:   [pv]--Pointer to memory buffer.
***********************************************************************/

DRM_VOID  DRM_API OEM_free( 
    DRM_VOID* pv );

#define SAFE_OEM_FREE(p) \
    if (p != NULL) \
    { \
        OEM_free((DRM_VOID *) p); \
        p = NULL; \
    }



/**********************************************************************
** Function:    OEM_realloc
** Synopsis:    Re-allocates memory from heap. 
** Arguments:   [pv]--Pointer to previous allocated memory buffer.
**              [size]--Number of bytes to allocate.
** Returns:     Valid pointer if succeeds, NULL if failed. 
***********************************************************************/

DRM_VOID* DRM_API OEM_realloc(
    DRM_VOID*pv, DRM_DWORD size);


/* Time functions -- See MSDN for more information */

/**********************************************************************
** Function:    OEM_SystemTimeToFileTime
** Synopsis:    Converts System Time format to File time format. 
** Arguments:   [lpSystemTime]--Pointer to DRMSYSTEMTIME structure 
**              containing system time
**              [lpFileTime]--Pointer to DRMFILETIME structure to get
**              the time.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/

DRM_BOOL DRM_API OEM_SystemTimeToFileTime(
    IN const DRMSYSTEMTIME *lpSystemTime,
    OUT      DRMFILETIME   *lpFileTime
    );

/**********************************************************************
** Function:    OEM_FileTimeToSystemTime
** Synopsis:    Converts File time format to System Time format. 
** Arguments:   [lpFileTime]--Pointer to DRMFILETIME structure 
**              containing file time
**              [lpSystemTime]--Pointer to DRMSYSTEMTIME structure to 
**              get the time.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/

DRM_BOOL DRM_API OEM_FileTimeToSystemTime(
    IN const DRMFILETIME   *lpFileTime,
    OUT      DRMSYSTEMTIME *lpSystemTime
    );

/**********************************************************************
** Function:    OEM_GetDeviceDateTime
** Synopsis:    Gets current System time. It is expressed in UTC. 
** Arguments:   [lpSystemTime]--Pointer to DRMSYSTEMTIME structure 
**              to get the time.
***********************************************************************/

DRM_VOID DRM_API OEM_GetDeviceDateTime(
    OUT DRMSYSTEMTIME* lpSystemTime
    );

/**********************************************************************
** Function:    OEM_GetDeviceTime
** Synopsis:    Gets current System time. It is expressed in UTC. 
** Arguments:   [pfiletime]--Pointer to DRMFILETIME structure 
**              to get the time.
***********************************************************************/

DRM_VOID DRM_API OEM_GetDeviceTime(
    OUT DRMFILETIME *pfiletime);

/**********************************************************************
** Function:    OEM_SetSystemTime
** Synopsis:    Sets the System time. It is expressed in UTC. 
** Arguments:   [lpSystemTime]--Pointer to DRMSYSTEMTIME structure 
**              holding the time.
***********************************************************************/

DRM_VOID DRM_API OEM_SetSystemTime(
    IN DRMSYSTEMTIME* lpSystemTime
    );

/**********************************************************************
** Function:    OEM_InitializeCriticalSection
** Synopsis:    Initializes critical section. 
** Arguments:   [pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
**              initialized.
***********************************************************************/

DRM_VOID DRM_API OEM_InitializeCriticalSection(
    IN OUT OEM_CRITICAL_SECTION *pCS);

/**********************************************************************
** Function:    OEM_DeleteCriticalSection
** Synopsis:    Deletes existing critical section. 
** Arguments:   [pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
**              deleted.
***********************************************************************/

DRM_VOID DRM_API OEM_DeleteCriticalSection(
    IN OUT OEM_CRITICAL_SECTION *pCS);

/**********************************************************************
** Function:    OEM_EnterCriticalSection
** Synopsis:    Enters critical section. 
** Arguments:   [pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
**              entered.
***********************************************************************/

DRM_VOID DRM_API OEM_EnterCriticalSection(
    IN OUT OEM_CRITICAL_SECTION *pCS);

/**********************************************************************
** Function:    OEM_LeaveCriticalSection
** Synopsis:    Leaves critical section. 
** Arguments:   [pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
**              left.
***********************************************************************/

DRM_VOID DRM_API OEM_LeaveCriticalSection(
    IN OUT OEM_CRITICAL_SECTION *pCS);


/**********************************************************************
** Function:    OEM_GetSetDataStoreRedundancy
** Synopsis:    Leaves critical section. 
** Arguments:   
***********************************************************************/

DRM_RESULT DRM_API OEM_GetSetDataStoreRedundancy(
    IN     DRM_VOID  *f_pvOpaqueData,
    IN OUT DRM_BYTE  *f_pbKey,
    IN     DRM_DWORD  f_cbKey,
    IN     DRM_BOOL   f_fGet);


#if DRM_SUPPORT_PROFILING
/**********************************************************************
** Function:    OEM_GetProfileLogPath
** Synopsis:    Get the path to the profiling log
** Arguments:   
***********************************************************************/

DRM_RESULT DRM_API OEM_GetProfileLogPath(
       OUT DRM_WCHAR *f_rgwchPath, 
    IN     DRM_DWORD *f_pcchPath);

#endif



/*************************  RSA SUPPORT *******************************/

#define MAX_RSA_PUB_KEY_BIT_LEN  4096
#define MAX_RSA_PUB_KEY_BYTE_LEN (MAX_RSA_PUB_KEY_BIT_LEN / 8 )

#define CB_SIGNATURE_RSA 128
#define CCH_SIGNATURE_RSA CCH_BASE64_EQUIV(CB_SIGNATURE_RSA)
#define CB_BSAFE_KEY_MIN 20 /* BSAFE header is five DWORDs */

/*
 * RSA public key
 *
 * The actual contents of the structure is opaque.
 *
 * The opaque data is represented as a byte array below.
 * Don't access the array or assume the size of this structure.
 */
typedef struct
{
    DRM_BYTE opaque[__CB_DECL(CB_BSAFE_KEY_MIN)];
} DRM_RSA_PUBLIC_KEY;

/*
 * RSA private key
 *
 * The actual contents of the structure is opaque.
 *
 * The opaque data is represented as a byte array below.
 * Don't access the array or assume the size of this structure.
 */
typedef struct
{
    DRM_BYTE opaque[__CB_DECL(CB_BSAFE_KEY_MIN)];
} DRM_RSA_PRIVATE_KEY;

enum DRM_RSA_KEY_TYPE
{
    DRM_RSA_KEY_TYPE_UNKNOWN,
    DRM_RSA_KEY_TYPE_PUBLIC,
    DRM_RSA_KEY_TYPE_PRIVATE
};

typedef struct
{
    DRM_RSA_PUBLIC_KEY  *pkeyRSAPublic;
    DRM_RSA_PRIVATE_KEY *pkeyRSAPrivate;
} DRM_KEYPAIR_RSA;

typedef struct
{
    PUBKEY  keyECCPublic;
    PRIVKEY keyECCPrivate;
} DRM_KEYPAIR_ECC;

/*
** The OEM_DrmRsa_IdentifyKey identifies a pointer as a public key, private key, or not a key
**
** Parameters:
**
**      f_pvKey - pointer to either form of RSA key
*/

enum DRM_RSA_KEY_TYPE OEM_DrmRsaIdentifyKey(
    IN const DRM_VOID *f_pvKey);

/*
 * The DrmRsaSetPublicKey function allocates an internal form of an RSA public key
 *
 * Parameters:
 *
 *      dwPubKeyExp - Specifies the exponent of the RSA public key
 *
 *      pbPubKeyMod - Specifies the modulus of the RSA public key
 *
 *      cbPubKeyMod - Speicifies the size (in bytes) of the modulus of the RSA public key
 *
 *      pPublicKey - Returns a pointer to the internal form of an RSA public key
 *          Buffer must be freed using OEM_free()
 *
 * Return Value:
 *  DRM_SUCCESS - Operation completed successfully
 *  DRM_E_OUTOFMEMORY - There is no enough memory to complete the operation
 */

DRM_RESULT DRM_API OEM_DrmRsaSetPublicKey(
    IN       DRM_DWORD dwPubKeyExp,
    IN       DRM_BYTE *pbPubKeyMod,
    IN       DRM_DWORD cbPubKeyMod,
       OUT   DRM_RSA_PUBLIC_KEY **pPublicKey );

/*
 * The DrmRsaSetPrivateKey function allocates an internal form of an RSA private key
 *
 * Parameters:
 *
 *      pbPrivateKey - Specifies the RSA private key.
 *          This buffer is in an OEM specific format.
 *          The format of this buffer is not necessarily the same as the one returned.
 *
 *      cbPrivateKey - Specifies the size (in bytes) of the RSA private key
 *
 *      ppPrivateKey - Returns the RSA private key.
 *          Buffer must be freed using OEM_free()
 *
 * Return Value:
 *  DRM_SUCCESS - Operation completed successfully
 *  DRM_E_OUTOFMEMORY - There is no enough memory to complete the operation
 */

DRM_RESULT DRM_API OEM_DrmRsaSetPrivateKey(
    IN       DRM_BYTE *pbPrivateKey,
    IN       DRM_DWORD cbPrivateKey,
       OUT   DRM_RSA_PRIVATE_KEY **ppPrivateKey );

/*
 * The DrmRsaKeySize routine determines the key size for the specific key.
 *
 * The key size is the size of the buffer used during encryption or decryption with the key.
 * A buffer of this size should be passed into the DrmRsaEncPublic and DrmRsaDecPrivate routines.
 *
 * Notice that this key size shouldn't be used for any other purpose.  Specifically,
 * note that this size may be larger then DrmRsaModulusSize.
 *
 * Parameters:
 *
 *      pKey - Specifies the key to determine the size of
 *          This key must be either of type DRM_RSA_PUBLIC_KEY or DRM_RSA_PRIVATE_KEY.
 *          NULL indicates that the private key baked into the device should be used
 *
 * Return Value:
 *      Size of the key in bytes
 *      0 indicates that the key isn't properly formatted
 */

DRM_DWORD DRM_API OEM_DrmRsaKeySize( const DRM_VOID *pKey );

/*
 * The OEM_DrmRsaBufferSize routine determines the size for the specific key.
 *
 * Parameters:
 *
 *      f_pvKey - Specifies the key to determine the size of
 *          This key must be either of type DRM_RSA_PUBLIC_KEY or DRM_RSA_PRIVATE_KEY.
 *
 *      f_pcbKey- on success this is filled in with the buffer size for the key
 *
 * Notes: while public keys are intrinsically self-describing, RSA private keys
 *        only reveal their total size by the implicit relationship between the
 *        size of the public key modulus and the buffer size
 */

DRM_RESULT DRM_API OEM_DrmRsaGetBufferSize (IN  const DRM_VOID  *f_pvKey,
                                            OUT       DRM_DWORD *f_pcbKey);

/*
 * The DrmRsaModulusSize routine determines the modulus size for the specific key.
 *
 * The modulus size represents the publicly visible strength of the key.
 *
 * Parameters:
 *
 *      pKey - Specifies the key to determine the modulus size of
 *          This key must be either of type DRM_RSA_PUBLIC_KEY or DRM_RSA_PRIVATE_KEY.
 *          NULL indicates that the private key baked into the device should be used
 *
 * Return Value:
 *      Modulus size of the key in bytes
 *      0 indicates that the key isn't properly formatted
 */

DRM_DWORD DRM_API OEM_DrmRsaModulusSize( DRM_VOID *pKey );



/*
 * The DrmRsaEncPublic routine RSA encrypts a fixed size buffer with an RSA public key
 *
 * Parameters:
 *
 *      pKey - Specifies the public key
 *
 *      pbDataIn - Specifies the input data
 *          The array must be DrmRsaKeySize bytes long.
 *          Only the first DrmRsaModulusSize bytes are encrypted.
 *          Any unused bytes in the array should be zeroed.
 *
 *      pbDataOut - Specifies the output data
 *          The array must be DrmRsaKeySize() bytes long.
 *          Only the first DrmRsaModulusSize bytes represent the encrypted value.
 *
 * Return Value:
 *      TRUE - encryption succeeded.
 *      FALSE - encryption failed.
 */

DRM_BOOL DRM_API OEM_DrmRsaEncPublic(
    IN       DRM_RSA_PUBLIC_KEY *pKey,
    IN       DRM_BYTE           *pbDataIn,
       OUT   DRM_BYTE           *pbDataOut );

/*
 * The DrmRsaDecPrivate routine RSA decrypts a fixed size buffer with an RSA private key
 *
 * Parameters:
 *
 *      pKey - Specifies the private key
 *          NULL indicates that the private key baked into the device should be used
 *
 *      pbDataIn - Specifies the input data
 *          The array must be DrmRsaKeySize bytes long.
 *          Only the first DrmRsaModulusSize bytes are encrypted.
 *          Any unused bytes in the array should be zeroed.
 *
 *      pbDataOut - Specifies the output data
 *          The array must be DrmRsaKeySize() bytes long.
 *
 * Return Value:
 *      TRUE - decryption succeeded.
 *      FALSE - decryption failed.
 */

DRM_BOOL DRM_API OEM_DrmRsaDecPrivate(
    IN       DRM_RSA_PRIVATE_KEY *pKey,
    IN       DRM_BYTE            *pbDataIn,
       OUT   DRM_BYTE            *pbDataOut );

DRM_RESULT OEM_DrmRsaGenKeys(
    IN        DRM_DWORD             f_cBits,
    IN        DRM_DWORD             f_exponentPublic,
    OUT       DRM_RSA_PUBLIC_KEY  **f_ppkeyRSAPublic,
    OUT       DRM_DWORD            *f_pcbPublic,
    OUT       DRM_RSA_PRIVATE_KEY **f_ppkeyRSAPrivate,
    OUT       DRM_DWORD            *f_pcbPrivate);

DRM_RESULT DRM_API OEM_DrmRsaParsePublicKey(
    IN          DRM_RSA_PUBLIC_KEY *f_pkeyRSAPublic,
    OUT         DRM_DWORD          *f_pdwExponent,
    OUT         DRM_BYTE          **f_ppbModulus,
    OUT         DRM_DWORD          *f_pcbModulus);

DRM_RESULT DRM_API OEM_DrmRsaParsePrivateKey(
    IN    DRM_RSA_PRIVATE_KEY *f_pkeyRSAPrivate,
    OUT   DRM_DWORD           *f_pdwExponent,
    OUT   DRM_BYTE           **f_ppbModulus,
    OUT   DRM_DWORD           *f_pcbModulus,
    OUT   DRM_BYTE           **f_ppbPrivate,
    OUT   DRM_DWORD           *f_pcbPrivate);

/*
 * The DrmRsaReleaseKey routines free keys created with OEM_DrmRsaSetPublicKey and OEM_DrmRsaSetPrivateKey
 *
 * Parameters:
 *
 *      Specifies the key
 *
 * Return Value:
 *      DRM_E_INVALIDARG - the given pointer does not point to a valid RSA key struct
 */

DRM_RESULT DRM_API OEM_DrmRsaReleaseKey(
       IN DRM_VOID *f_pPrivateKey);


/* TBD: write a real function for this that cannot be optimized away */

#define OEM_SecureZeroMemory(pb,cb) ZEROMEM(pb,cb)



#define SAFE_SECURE_OEM_FREE(p, c) \
    if (p != NULL) \
    { \
        OEM_SecureZeroMemory(p,c);  \
        OEM_free((DRM_VOID *) p); \
        p = NULL; \
    }

    

#ifdef __cplusplus
}
#endif

#endif /* __OEMIMPL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\oeminfo.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcrt.h>
#include <drmbase64.h>
#include <drmstrings.h>
#include <oemimpl.h>

#if DRM_SUPPORT_PROFILING
static const DRM_WCHAR g_rgwchProfileLog [] = { ONE_WCHAR('C', '\0'), ONE_WCHAR(':', '\0'), ONE_WCHAR('\\', '\0'), ONE_WCHAR('W', '\0'), ONE_WCHAR('M', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('M', '\0'), ONE_WCHAR('P', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('\\', '\0'), ONE_WCHAR('p', '\0'), ONE_WCHAR('r', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('f', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('l', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('.', '\0'), ONE_WCHAR('l', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('g', '\0'), ONE_WCHAR('\0', '\0') };
#endif

static const PRIVKEY oPrivKey = 
{
    TWO_BYTES(0xB6,  0xEE),  TWO_BYTES(0x01,  0x6A),  TWO_BYTES(0x47,  0x2B),  TWO_BYTES(0x20, 0xD4),  
    TWO_BYTES(0x44,  0x84),  TWO_BYTES(0x94,  0x0A),  TWO_BYTES(0xFE,  0xDC),  TWO_BYTES(0x89, 0xD5),  
    TWO_BYTES(0x36,  0x81),  TWO_BYTES(0x8D,  0x5E)
};
static const PRIVKEY oBootStrapPrivKey = 
{
    TWO_BYTES(0x15,  0xA1),  TWO_BYTES(0xA3,  0xF6),  TWO_BYTES(0x2D,  0xD4),  TWO_BYTES(0xC6, 0xA3),  
    TWO_BYTES(0x9C,  0x0D),  TWO_BYTES(0xEC,  0xDB),  TWO_BYTES(0xA7,  0x14),  TWO_BYTES(0xF4, 0x2C),  
    TWO_BYTES(0xFB,  0x8F),  TWO_BYTES(0x75,  0x50) 
};

/* C:\\WMDRMPD\\ */
static const DRM_WCHAR g_rgwchDrmPath [] =
{
    ONE_WCHAR('C', '\0'),  ONE_WCHAR(':', '\0'),  ONE_WCHAR('\\', '\0'), ONE_WCHAR('w', '\0'),
    ONE_WCHAR('m', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('m', '\0'),
    ONE_WCHAR('p', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\\', '\0'), ONE_WCHAR('\0', '\0')
};

/* priv.dat */
static const DRM_WCHAR g_rgwchPrivKey [] = 
{
    ONE_WCHAR('p', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('v', '\0'),
    ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),
    ONE_WCHAR('\0', '\0')
};

/* devcert.dat */
static const DRM_WCHAR g_rgwchDevcert [] =
{
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('c', '\0'),
    ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')
};

/* devcerttemplate.dat */
static const DRM_WCHAR g_rgwchDevcerttemplate [] =
{
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('c', '\0'),
    ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('t', '\0'),
    ONE_WCHAR('e', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('l', '\0'),
    ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')
};

static const DRM_CONST_STRING   g_dstrDrmPath           = CREATE_DRM_STRING( g_rgwchDrmPath );
static const DRM_CONST_STRING   g_dstrPrivKey           = CREATE_DRM_STRING( g_rgwchPrivKey );
static const DRM_CONST_STRING   g_dstrDevcert           = CREATE_DRM_STRING( g_rgwchDevcert );
static const DRM_CONST_STRING   g_dstrDevcerttemplate   = CREATE_DRM_STRING( g_rgwchDevcerttemplate );


DRM_BOOL g_fDeviceResetState = TRUE;


static DRM_RESULT DRM_API _GetDRMFullPathName( 
       OUT   DRM_WCHAR       **ppwszFullPath, 
    IN const DRM_CONST_STRING *pdstrFilename)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchPath = 0;

    ChkArg( ppwszFullPath );
    ChkDRMString( pdstrFilename );

    *ppwszFullPath = NULL;
    cchPath = pdstrFilename->cchString 
            + g_dstrDrmPath.cchString 
            + 2;
    ChkMem( *ppwszFullPath = ( DRM_WCHAR * )OEM_malloc( cchPath*SIZEOF( DRM_WCHAR ) ) );
    wcsncpy( *ppwszFullPath, g_dstrDrmPath.pwszString, g_dstrDrmPath.cchString );

    cchPath = g_dstrDrmPath.cchString;

    /* Need to check whether it is ended with "/" */
    if ( (*ppwszFullPath)[ cchPath - 1 ] != g_wchPathSeperator )
    {
        (*ppwszFullPath)[ cchPath ] = g_wchPathSeperator;
        cchPath++;
    }

    wcsncpy( (*ppwszFullPath) + cchPath, pdstrFilename->pwszString, pdstrFilename->cchString );
    
    /* Null Terminate it */
    (*ppwszFullPath)[cchPath + pdstrFilename->cchString] = g_wchNull;

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API OEM_GetUniqueID( 
    DRM_WCHAR  wchUniqueId[MAX_UNIQUEID_LEN], 
    DRM_DWORD *pcchLen )
{    
    DRM_BYTE shaOut [__CB_DECL(SHA_DIGEST_LEN)];
    DRM_DWORD dwSize =0;
    DRM_RESULT dr=DRM_SUCCESS;

    ChkArg( pcchLen!=NULL );
    if ( wchUniqueId==NULL || *pcchLen<CCH_BASE64_EQUIV(SHA_DIGEST_LEN) )
    {
        *pcchLen = CCH_BASE64_EQUIV(SHA_DIGEST_LEN);
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }
    else
    {
        MEMSET( shaOut, 0xa, SHA_DIGEST_LEN );
        dwSize = MAX_UNIQUEID_LEN;
        ChkDR( DRM_B64_EncodeW( shaOut, SHA_DIGEST_LEN, wchUniqueId, &dwSize, 0 ) );
        *pcchLen = dwSize;
    }
    
ErrorExit:
    
    return dr;
}


/**********************************************************************
** Function:    _GetPrivateKey
** Synopsis:    
** Arguments:   [f_fGCprivkey] -- TRUE for GC privkey, FALSE for Fallback signing key
**              [f_pPrivkey]   -- returned privkey
** Returns:     DRM_SUCCESS when success.
** Notes:       GC privkey and Fallback privkey are saying in order in
**              the file.
***********************************************************************/
static DRM_RESULT _GetPrivateKey(
    IN  DRM_BOOL  f_fGCprivkey,
    OUT PRIVKEY  *f_pPrivkey)
{
    DRM_RESULT  dr=DRM_SUCCESS;
    OEM_FILEHDL fp = OEM_INVALID_HANDLE_VALUE;
    DRM_WCHAR  *pwszPath = NULL; 
    DRM_DWORD   iRead=0;
    DRM_DWORD   cbFile=0;

    ChkArg( f_pPrivkey );
    ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrPrivKey ) );
    fp = OEM_OpenFile( pwszPath, 
                       OEM_GENERIC_READ, 
                       OEM_FILE_SHARE_READ, 
                       OEM_OPEN_EXISTING, 
                       OEM_ATTRIBUTE_HIDDEN );
    if ( fp == OEM_INVALID_HANDLE_VALUE )
    {
        ChkDR( DRM_E_FILENOTFOUND );
    }

    /* load file content in memory */
    if ( !OEM_GetFileSize( fp, &cbFile ) )
    {
        ChkDR( DRM_E_FILEREADERROR );
    }

    if ( cbFile != (2 * SIZEOF( PRIVKEY )) )
    {
        ChkDR( DRM_E_PRIVKEYREADERROR );
    }

    if ( !OEM_SetFilePointer(fp, (f_fGCprivkey? 0 : SIZEOF(PRIVKEY)),
        OEM_FILE_BEGIN, NULL) )
    {
        ChkDR(DRM_E_FILESEEKERROR);
    }
    if ( !OEM_ReadFile(fp, (DRM_BYTE *)f_pPrivkey, SIZEOF(PRIVKEY), &iRead) 
        || iRead!=SIZEOF(PRIVKEY) )
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    
ErrorExit:
    if( fp != OEM_INVALID_HANDLE_VALUE )
    {
        OEM_CloseFile( fp );
    }
    fp = OEM_INVALID_HANDLE_VALUE;
    if ( pwszPath )
    {
        OEM_free( pwszPath );
    }
    pwszPath = NULL;
    if ( DRM_FAILED ( dr ) )
    {
        dr = DRM_E_PRIVKEYREADERROR;
    }
    return dr;
}


DRM_RESULT DRM_API OEM_GetGroupCertPrivateKey( 
    OUT PRIVKEY *f_pPrivkey)
{
    return _GetPrivateKey(TRUE, f_pPrivkey);
}

DRM_RESULT DRM_API OEM_GetFallbackSigningKey( 
    OUT PRIVKEY *f_pPrivkey)
{
    return _GetPrivateKey(FALSE, f_pPrivkey);
}

static const DRM_BYTE _rgbSecStorePassword[__CB_DECL(SHA_DIGEST_LEN)]= 
{
    TWO_BYTES('1','2'), TWO_BYTES('3','4'), TWO_BYTES('5','6'), TWO_BYTES('7','8'), TWO_BYTES('9','0'),
    TWO_BYTES('1','2'), TWO_BYTES('3','4'), TWO_BYTES('5','6'), TWO_BYTES('7','8'), TWO_BYTES('9','0')
};

/**********************************************************************
** Function:    _GetDeviceCert
** Synopsis:    
** Arguments:   []
** Returns:     None
** Notes:
***********************************************************************/
DRM_RESULT _GetDeviceCert(
    OUT    DRM_BYTE  *pbDevCert,
    IN OUT DRM_DWORD *pcbDevCert,
    IN     DRM_BOOL   fTemplate )
{
    DRM_RESULT dr=DRM_SUCCESS;
    OEM_FILEHDL fp = OEM_INVALID_HANDLE_VALUE;
    DRM_WCHAR *pwszPath = NULL; 

    ChkArg( pcbDevCert );

    if ( fTemplate )
    {
        ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrDevcerttemplate ) );
    }
    else
    {
        ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrDevcert ) );
    }

    fp = OEM_OpenFile( pwszPath, 
                       OEM_GENERIC_READ, 
                       OEM_FILE_SHARE_READ, 
                       OEM_OPEN_EXISTING, 
                       OEM_ATTRIBUTE_HIDDEN );

    if (fp != OEM_INVALID_HANDLE_VALUE)
    {
        DRM_DWORD iRead=0;
        DRM_DWORD  cbFile =0;
        /* load file content in memory */
        if ( !OEM_GetFileSize(fp, &cbFile ) )
        {
            ChkDR(DRM_E_FILEREADERROR);
        }

        if ( *pcbDevCert < cbFile )
        {
            *pcbDevCert = cbFile;
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
        
        if ( !OEM_SetFilePointer( fp, 0, OEM_FILE_BEGIN, NULL ) )
        {
            ChkDR(DRM_E_FILESEEKERROR);
        }
        *pcbDevCert = cbFile;    
        if (!OEM_ReadFile( fp, pbDevCert, cbFile, &iRead ) ||
            iRead!=cbFile )
        {
            ChkDR( DRM_E_FILEREADERROR );
        }
    }
    else
    {
        ChkDR( DRM_E_FILENOTFOUND );
    }
ErrorExit:    
    if( fp != OEM_INVALID_HANDLE_VALUE )
    {
        OEM_CloseFile( fp );
    }
    fp = OEM_INVALID_HANDLE_VALUE;
    if ( pwszPath )
    {
        OEM_free( pwszPath );
    }
    pwszPath = NULL;
    return dr;

}

/**********************************************************************
** Function:    OEM_GetDeviceCert
** Synopsis:    
** Arguments:   []
** Returns:     None
** Notes:
***********************************************************************/
DRM_RESULT DRM_API OEM_GetDeviceCert(
    OUT    DRM_BYTE  *pbDevCert,
    IN OUT DRM_DWORD *pcbDevCert)
{
    DRM_RESULT dr=DRM_SUCCESS;
    ChkDR( _GetDeviceCert( pbDevCert, pcbDevCert, FALSE ) );

ErrorExit:    
    if ( DRM_FAILED ( dr ) )
    {
        if (DRM_E_BUFFERTOOSMALL != dr) 
        {
            dr = DRM_E_DEVCERTREADERROR;
        }
    }
    return dr;
}

/**********************************************************************
** Function:    OEM_GetDeviceCertTemplate
** Synopsis:    
** Arguments:   []
** Returns:     None
** Notes:
***********************************************************************/
DRM_RESULT DRM_API OEM_GetDeviceCertTemplate(
    OUT    DRM_BYTE  *pbDevCert,
    IN OUT DRM_DWORD *pcbDevCert)
{
    DRM_RESULT dr=DRM_SUCCESS;
    dr = _GetDeviceCert( pbDevCert, pcbDevCert, TRUE );
    if ( DRM_FAILED ( dr ) )
    {
        if ( DRM_E_BUFFERTOOSMALL != dr ) 
        {
            ChkDR( DRM_E_DEVCERTTEMPLATEREADERROR );
        }
    }

ErrorExit:    
    return dr;
}



/**********************************************************************
** Function:    OEM_GetSecureStoreGlobalPasswordSeed
** Synopsis:    
** Arguments:   []
** Returns:     None
** Notes:
***********************************************************************/
DRM_RESULT DRM_API
OEM_GetSecureStoreGlobalPasswordSeed( 
    OUT DRM_BYTE rgbSecStorePassword[__CB_DECL(SHA_DIGEST_LEN)])
{
    DRM_RESULT dr=DRM_SUCCESS;
    
    ChkArg( rgbSecStorePassword != NULL );
        
    MEMCPY(rgbSecStorePassword, _rgbSecStorePassword, SHA_DIGEST_LEN);

ErrorExit:    
    return dr;
}

/**********************************************************************
** Function:    OEM_SetDeviceCert
** Synopsis:    
** Arguments:   []
** Returns:     None
** Notes:
***********************************************************************/
DRM_RESULT DRM_API
OEM_SetDeviceCert(
    IN const DRM_BYTE *pbDevCert,
    IN DRM_DWORD cbDevCert)
{
    DRM_RESULT dr=DRM_SUCCESS;
    OEM_FILEHDL fp = OEM_INVALID_HANDLE_VALUE;
    DRM_WCHAR *pwszPath = NULL; 

    ChkArg( pbDevCert != NULL
         && cbDevCert != 0    );

    ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrDevcert ) );


    fp = OEM_OpenFile( pwszPath, 
                       OEM_GENERIC_READ    | OEM_GENERIC_WRITE,
                       OEM_FILE_SHARE_READ | OEM_FILE_SHARE_WRITE, 
                       OEM_CREATE_ALWAYS, 
                       OEM_ATTRIBUTE_HIDDEN );

    if ( fp != OEM_INVALID_HANDLE_VALUE )
    {
        DRM_DWORD iWrite =0;
        if ( !OEM_WriteFile( fp, ( DRM_BYTE * )pbDevCert, cbDevCert, &iWrite ) ||
            iWrite!=cbDevCert )
        {
            ChkDR( DRM_E_FILEWRITEERROR );
        }
    }
    else
    {
        ChkDR( DRM_E_FILENOTFOUND );
    }
ErrorExit:
    if( fp != OEM_INVALID_HANDLE_VALUE )
    {
        OEM_CloseFile( fp );
    }
    fp = OEM_INVALID_HANDLE_VALUE;
    if ( pwszPath )
    {
        OEM_free( pwszPath );
    }

    if ( DRM_FAILED ( dr ) )
    {
        dr = DRM_E_DEVCERTWRITEERROR;
    }

    return dr;
}



/* BUGBUG. Full implementation required */
/**********************************************************************
** Function:    OEM_GetClockResetState
** Synopsis:    Get the Secure Clock Reset state.
** Arguments:   [pfReset] -- Bool to get the state
***********************************************************************/
DRM_RESULT DRM_API OEM_GetClockResetState( DRM_BOOL *pfReset )
{
    DRM_RESULT dr=DRM_SUCCESS;
    ChkArg( pfReset != NULL );

    *pfReset = g_fDeviceResetState;

ErrorExit:
    
    return dr;

}
/* BUGBUG. Full implementation required */
/**********************************************************************
** Function:    OEM_SetClockResetState
** Synopsis:    Set the Secure Clock Reset state.
** Arguments:   [fReset] -- Bool to set the state
***********************************************************************/
DRM_RESULT DRM_API OEM_SetClockResetState( DRM_BOOL fReset )
{
    DRM_RESULT dr=DRM_SUCCESS;
    
    g_fDeviceResetState = fReset;
   
    return dr;

}

#if DRM_SUPPORT_PROFILING

/**********************************************************************
** Function:    OEM_GetProfileLogPath
** Synopsis:    Get the path to the profiling log file
** Arguments:   [f_rgwchPath] -- buffer to fill in with path
**              [f_cchPath]   -- size of f_rgwchPath in chars
***********************************************************************/

DRM_RESULT DRM_API OEM_GetProfileLogPath(
       OUT DRM_WCHAR *f_rgwchPath, 
    IN     DRM_DWORD *f_pcchPath)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg(f_pcchPath != NULL);

    if (*f_pcchPath < NO_OF(g_rgwchProfileLog))
    {
        *f_pcchPath = NO_OF(g_rgwchProfileLog);
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    wcsncpy(f_rgwchPath, g_rgwchProfileLog, NO_OF(g_rgwchProfileLog));
   *f_pcchPath = NO_OF(g_rgwchProfileLog);

ErrorExit:
    return dr;
}
#endif /* DRM_SUPPORT_PROFILING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\oemfileio.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#undef __STRICT_ANSI__
#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <stdio.h>
#include <stdarg.h>
#include <oemimpl.h>

#if CB_NATIVE_BYTE > 1
/* The size of the buffer when reading files on 16-bit */
/* Must be an even number */
#define OEM_READFILE_CHUNK_SIZE 1024
#endif

void NativeBytesToPacked(DRM_BYTE *f_pNativeString, DRM_BYTE *f_pPackedString, DRM_DWORD cch)
{
	DRM_DWORD ich;

    if( f_pNativeString == NULL
            || f_pPackedString == NULL
            || cch == 0 )
    {
        return;
    }


	for(ich = (cch - 1); ich > 0; ich--)
	{
		PUT_CHAR(f_pPackedString, ich, f_pNativeString[ich]);
	}

	PUT_CHAR(f_pPackedString, 0, f_pNativeString[0]);

	return;
}

static void PackedCharsToNative( DRM_CHAR *f_pPackedString, DRM_DWORD cch )
{
	DRM_DWORD ich;

	if( f_pPackedString == NULL
			|| cch == 0 )
	{
		return;
	}
    for( ich = cch; ich > 0; ich-- )
    {
        f_pPackedString[ich] = GET_CHAR( f_pPackedString, ich );
    }
    f_pPackedString[0]   = GET_CHAR( f_pPackedString, 0 ) ;
    f_pPackedString[cch] = '\0';
}

static DRM_BOOL FileExists (const DRM_CHAR *pszFileName)
{
    FILE     *pfile   = NULL;
    DRM_BOOL  bExists = FALSE;

    if ((pfile = (FILE*)fopen (pszFileName, "r")) != NULL)
    {
        bExists = TRUE;
        
        fclose (pfile);
    }
    
    return bExists;
}

/*
** return 0xFFFFFFFF if failed
*/
OEM_FILEHDL DRM_API OEM_OpenFile(
    const DRM_WCHAR *pwszFileName,
    DRM_DWORD        fModeAccess,
    DRM_DWORD        fModeShare,
    DRM_DWORD        fModeCreateOpen,
    DRM_DWORD        fAttributes)
{
    FILE      *pfile    = OEM_INVALID_HANDLE_VALUE;
    DRM_CHAR  *pszMode = NULL;
    DRM_DWORD  fShare   = 0;
    DRM_BOOL   bOK      = FALSE;

    DRM_DWORD cch = 0;
    DRM_CHAR rgchFileName[DRM_MAX_PATH];    
    DRM_CHAR *pszFName = rgchFileName;
    
    cch = DRMCRT_wcslen( pwszFileName );
    DRM_UTL_DemoteUNICODEtoANSI( pwszFileName, rgchFileName, cch );
    PackedCharsToNative( rgchFileName, cch );

    if  (fModeCreateOpen == OEM_CREATE_NEW) 
    {
        DRMASSERT ((fModeAccess & OEM_GENERIC_WRITE) != 0);

        bOK = (FileExists (pszFName) == FALSE);

        pszMode = "w+b";
    }
    else if (fModeCreateOpen == OEM_TRUNCATE_EXISTING)
    {
        DRMASSERT ((fModeAccess & OEM_GENERIC_WRITE) != 0);

        bOK = FileExists (pszFName);

        pszMode = "w+b";
    }
    else if (fModeCreateOpen == OEM_CREATE_ALWAYS)
    {
        DRMASSERT ((fModeAccess & OEM_GENERIC_WRITE) != 0);

        bOK      = TRUE;
        pszMode = "w+b";
    }
    else if (fModeCreateOpen == OEM_OPEN_EXISTING)
    {
        if (FileExists (pszFName))
        {
            if (fModeAccess & OEM_GENERIC_WRITE)
            {
                pszMode = "r+b";
                bOK      = TRUE;
            }
            else if (fModeAccess & OEM_GENERIC_READ)
            {
                pszMode = "rb";
                bOK      = TRUE;
            }
            else
            {
                DRMASSERT (0);
            }
        }
    }
    else if (fModeCreateOpen == OEM_OPEN_ALWAYS)
    {
        pszMode = "a+b";
        bOK      = TRUE;
    }

	/* translate our I/O share flags to standard C's */
#if DRM_SUPPORT_LOCKING	
    if ((fModeShare & OEM_FILE_SHARE_WRITE)
    &&  (fModeShare & OEM_FILE_SHARE_READ))
    {
        fShare = _SH_DENYNO;
    }
    else if (fModeShare & OEM_FILE_SHARE_WRITE)
    {
        fShare = _SH_DENYRD;
    }
    else if (fModeShare & OEM_FILE_SHARE_READ)
    {
        fShare = _SH_DENYWR;
    }
    else
    {
        fShare = _SH_DENYRW;
    }

#endif
    if (bOK)
    {
        pfile = (FILE *) fopen (pszFName, pszMode);

        if (pfile == NULL)
        {
            pfile = (FILE *) OEM_INVALID_HANDLE_VALUE;
        }
    }

    return (OEM_FILEHDL) pfile;
}

/*
**
*/
DRM_BOOL DRM_API OEM_CloseFile(
    OEM_FILEHDL hFile)
{
    return fclose((FILE *)hFile)==0;
}


/*
**
*/
DRM_BOOL DRM_API OEM_ReadFile(
    OEM_FILEHDL hFile,
    DRM_VOID   *pBuffer,
    DRM_DWORD   cbRead,
    DRM_DWORD  *pcbRead)
{
#if CB_NATIVE_BYTE > 1
    static DRM_BYTE rgbNative[OEM_READFILE_CHUNK_SIZE]; /* static to keep this local var off the stack */
    DRM_DWORD actual = 0;
    DRM_DWORD ib = 0;

    *pcbRead = 0;
    while ( cbRead )
    {
        actual = fread(rgbNative, 1, min(cbRead, OEM_READFILE_CHUNK_SIZE), (FILE *)hFile);
        if ( 0 == actual )
        {
            break;
        }
        NativeBytesToPacked(rgbNative, (DRM_BYTE*)pBuffer + __CB_DECL(ib * OEM_READFILE_CHUNK_SIZE), actual);
        cbRead -= actual;
        *pcbRead += actual;
        ib++;
    }
#else	
    *pcbRead = fread(pBuffer, 1, (size_t)cbRead, (FILE *)hFile);
#endif
    return TRUE;
}

/*
**
*/
DRM_BOOL DRM_API OEM_WriteFile(
    OEM_FILEHDL hFile,
    DRM_VOID   *pBuffer,
    DRM_DWORD   cbWrite,
    DRM_DWORD  *pcbWritten)
{
    DRM_DWORD ib = 0;

#if CB_NATIVE_BYTE > 1
    DRM_BYTE rgbNative[2];
    for( ib = 0; cbWrite > 1; ib+=2, cbWrite-=2 )
    {
        rgbNative[0] = GET_BYTE( pBuffer, ib );
        rgbNative[1] = GET_BYTE( pBuffer, ib+1 );        
        if( 1 != fwrite(rgbNative, sizeof(rgbNative), 1, (FILE *)hFile) )
        {
            break;
        }
    }
    if( cbWrite == 1 )
    {    
        rgbNative[0] = GET_BYTE( pBuffer, ib );
    	if( fwrite(rgbNative, 1, 1, (FILE *)hFile) == 1 )
        {            
            ib++;
        }
    }    
    *pcbWritten = ib;
#else
    *pcbWritten = fwrite(pBuffer, 1, (size_t)cbWrite, (FILE *)hFile);
#endif

    return TRUE;
}


/*
**
*/
DRM_BOOL DRM_API OEM_SetFilePointer(
    OEM_FILEHDL hFile,
    DRM_LONG    lDistanceToMove,
    DRM_DWORD   dwMoveMethod,
    DRM_DWORD  *pdwNewFilePointer)
{
    DRM_BOOL fResult = FALSE;
#if DRM_PROFILE_DRIVESEEK
    DRM_PROFILING_ENTER_SCOPE(L"OEM_SetFilePointer", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
#endif

#if DRM_SUPPORT_PROFILING
    g_contextPRO.dwNumSeeks++;
#endif

    if (fseek((FILE *)hFile,lDistanceToMove,(DRM_INT)dwMoveMethod)==0)
    {
        if (pdwNewFilePointer!=NULL)
        {
            *pdwNewFilePointer = ftell((FILE *)hFile);
        }
        fResult = TRUE;
    }

#if DRM_PROFILE_DRIVESEEK
    DRM_PROFILING_LEAVE_SCOPE(L"OEM_SetFilePointer", g_pwszLeavingFunction);
#endif
    return fResult;
}

/*
**
*/
DRM_BOOL DRM_API OEM_LockFile(
    OEM_FILEHDL hFile,
    DRM_BOOL    fExclusive,
    DRM_DWORD   dwFileOffset,
    DRM_DWORD   nNumberOfBytesToLock,
    DRM_BOOL    fWait)
{
#if DRM_SUPPORT_LOCKING
    DRM_INT flag = 0;

    flag = fWait? _LK_LOCK : _LK_NBLCK;

    if (fseek((FILE *)hFile, dwFileOffset, SEEK_SET) == 0 )
    {
        /* _locking does not support non-exclusive mode, we ignore fExclusive */
        if (_locking(_fileno((FILE *)hFile), flag, (DRM_LONG)nNumberOfBytesToLock)==0)
        {
            return TRUE;
        }
    }
    return FALSE;
#else
    return TRUE;
#endif
}

/*
**
*/
DRM_BOOL DRM_API OEM_UnlockFile(
    OEM_FILEHDL hFile,
    DRM_DWORD   dwFileOffset,
    DRM_DWORD   nNumberOfBytesToUnlock)
{
#if DRM_SUPPORT_LOCKING
    if (fseek((FILE *)hFile, dwFileOffset, SEEK_SET) == 0)
    {
        if (_locking(_fileno((FILE *)hFile), _LK_UNLCK, (DRM_LONG)nNumberOfBytesToUnlock)==0)
        {
            return TRUE;
        }
    }
    return FALSE;
#else
    return TRUE;
#endif
}


/*
**
*/
DRM_BOOL DRM_API OEM_SetEndOfFile(
    OEM_FILEHDL hFile)
{
    /* no CRT support */
    return FALSE;
}

/*
**
*/
DRM_BOOL DRM_API OEM_GetFileSize(
    OEM_FILEHDL hfile,
    DRM_DWORD  *pcbFile)
{
    DRM_DWORD oFileCurr = 0;
    DRM_BOOL  fOK       = FALSE;
    FILE     *pfile     = (FILE *) hfile;
    
    DRMASSERT (pcbFile != NULL);
    DRMASSERT (hfile   != OEM_INVALID_HANDLE_VALUE);

    oFileCurr = ftell (pfile);

    if (fseek (pfile, 0, SEEK_END) == 0)
    {
        *pcbFile = ftell (pfile);
        fOK      = TRUE;
        fseek (pfile, oFileCurr, SEEK_SET);        
    }
    return fOK;
}

/*
**
*/
DRM_BOOL DRM_API OEM_FlushFileBuffers(
    OEM_FILEHDL hFile)
{
    return fflush((FILE *)hFile)==0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\oemimpl.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <drmcommon.h>
#include <drmcrt.h>
#include <oemimpl.h>


fncdrmassert g_OEMAssertCallback = NULL;
/**********************************************************************
** Function:		_trace
**
** Synopsis:		Trace function that prints information to a file.  
**
** Arguments:	[szFmt] -- Format string of the variable arguments to follow.
**
** Returns:		None
**
** Notes:			
**
***********************************************************************/


/**********************************************************************
**
***********************************************************************
*/
DRM_VOID DRM_API
_oem_trace (
    IN DRM_CHAR * szFmt, ...)
{
    va_list alist;
    va_start (alist, szFmt);
    vprintf(szFmt, alist);
    va_end (alist);
}


/**********************************************************************
** Memory allocation functions 
***********************************************************************
*/
DRM_VOID* DRM_API 
OEM_malloc(
    DRM_DWORD size)
{
#if SIXTEEN_BIT_ADDRESSING
    DRM_DWORD cb = size / CB_NATIVE_BYTE;
    
    if ((size % CB_NATIVE_BYTE) != 0)
    {
        cb++;
    }
    
    return malloc(cb);
#else
    return malloc( size );
#endif    
}


DRM_VOID DRM_API 
OEM_free( 
    DRM_VOID* pv )
{
    free( pv );
}


DRM_VOID* DRM_API 
OEM_realloc(
    DRM_VOID*pv, 
    DRM_DWORD size)
{
    if( pv )
    {
        return realloc( pv, size );
    }

    return malloc( size );
}


/**********************************************************************
** Random number generation functions 
***********************************************************************
*/
static       DRM_UINT64 random_seed       =  DRM_UI64LITERAL(0x25B946EB, 0xC0B36173);
static const DRM_UINT64 random_multiplier =  DRM_UI64LITERAL(0x2B992DDF, 0xA23249D5); /* odd */


/*
Set the random number seed.
*/
void DRM_API set_random_seed(
    const DRM_UINT64 new_seed)
{
    random_seed = DRM_UI64Mul(DRM_UI64(14142135), new_seed);
}




/*
Return pseudorandom array of bytes.

CAVEAT: This generator has not been designed to be fast,
nor to have good cryptographic or statistical properties.
It is not designed for multitasking.
*/
#define PACKED_CHAR_BIT (CHAR_BIT/CB_NATIVE_BYTE)
DRM_RESULT DRM_API OEM_GenRandomBytes( 
       OUT DRM_BYTE* pbData, 
    IN     DRM_DWORD cbData )
{
    static DRM_BOOL fFirst=TRUE;
    size_t nbyte_left = cbData;
    DRM_DWORD ib = 0;

    /* set random seed the first time */
    if ( fFirst )
    {
        DRMFILETIME ft;
        DRM_UINT64 u64;
        
        OEM_GetDeviceTime (&ft);
        FILETIME_TO_UI64( ft, u64 );
        
        set_random_seed(u64);
        fFirst = FALSE;
    }

    while (nbyte_left != 0)
    {
        size_t nbyte_now = min(nbyte_left, SIZEOF(DRM_DWORD));
        DRM_DWORD value_now;
        const DRM_INT shift_count = PACKED_CHAR_BIT*(SIZEOF(random_seed) - SIZEOF(value_now));

        nbyte_left -= nbyte_now;
        random_seed = DRM_UI64Add( DRM_UI64Mul(random_seed,random_multiplier), DRM_UI64(1));
        value_now = DRM_I64ToUI32(DRM_UI2I64(DRM_UI64ShR(random_seed, shift_count)));
        do 
        {
            PUT_BYTE(pbData, ib, (DRM_BYTE)(value_now & UCHAR_MAX) );
            ib++;
            value_now >>= PACKED_CHAR_BIT;
            nbyte_now--;
        } while (nbyte_now != 0);
    }
    return DRM_SUCCESS;
} /* OEM_GenRandomBytes */
 
#if DRM_SUPPORT_SST_REDUNANCY
#include <drmtoken.h>
DRM_RESULT DRM_API VariableSSTRedundancyGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    return DRM_E_NOTIMPL;
}
#endif


DRM_RESULT DRM_API OEM_GetSetDataStoreRedundancy(
    IN     DRM_VOID  *f_pvOpaqueData,
    IN OUT DRM_BYTE  *f_pbKey,
    IN     DRM_DWORD  f_cbKey,
    IN     DRM_BOOL   f_fGet) 
{
    return DRM_E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\pkcrypto.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <time.h>
#include <assert.h>
#include <limits.h>
#include <bignum.h>
#include <field.h>
#include <ecurve.h>
#include <mprand.h>
#include <stdio.h>
#include <drmcommon.h>
#include <drmprofile.h>
#include <drmpkcrypto.h>
#include <drmsha1.h>
#include <string.h>

#define USE_REAL_MEMORY_ALLOCATION 0

#if USE_REAL_MEMORY_ALLOCATION
#ifdef __cplusplus
extern "C" {
#endif
DWORD cbMax = 0;
DWORD cbCur = 0;
#ifdef __cplusplus
}
#endif
#endif


typedef struct __DRMBIGNUM_CONTEXT_STRUCT
{
    DRM_STACK_ALLOCATOR_CONTEXT oHeap;
    DRM_BYTE rgbHeap[__CB_DECL(DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE)];
}DRMBIGNUM_CONTEXT_STRUCT;

#define LNGQDW 5
#define LNGQ DWORDS_TO_DIGITS(LNGQDW)
#define QBITS (LNGQDW * DWORD_BITS)

static const DWORD ecdw_q[5] = 
{
    0x141424F7, 0x31415926, 0x27182818, 0x01234567, 0x89ABCDEF
};
/* ecdw_q = 785963102379428822376694789446897396207498568951 */

static const DWORD ecdw_order[5] = 
{
    0x28C2A675, 0xEC149044, 0x2716B26E, 0x01234567, 0x89ABCDEF
};
/* ecdw_order = 785963102379428822376693024881714957612686157429 */

static const DWORD ecdw_a[5] = 
{
    0xEBE41497, 0x4780C009, 0x7632FF3D, 0xD277BCE8, 0x37A5ABCC
};
/* ecdw_a = 317689081251325503476317476413827693272746955927 */

static const DWORD ecdw_b[5] = 
{
    0x9328239E, 0xD78FDEDF, 0x28E85F1A, 0x725E2F32, 0x0DD8DABF
};
/* ecdw_b = 79052896607878758718120572025718535432100651934 */

static const DWORD ecdw_genx[5] = 
{
    0x109FA120, 0xBA38DAF0, 0x3510C07D, 0xD6A3A1E5, 0x8723947F
};
/* ecdw_genx = 771507216262649826170648268565579889907769254176 */

static const DWORD ecdw_geny[5] = 
{
    0xA379936F, 0xD4ED7ACD, 0x8C3C5856, 0x1075522D, 0x44574491
};
/* ecdw_geny = 390157510246556628525279459266514995562533196655 */


static void endian_reverse_dwords( const DWORD f_rgdwIn[], DWORD f_rgdwOut[], DWORD cdw )
{
    if( f_rgdwOut != f_rgdwIn )
    {
        MEMCPY( f_rgdwOut, f_rgdwIn, cdw*SIZEOF(DWORD) );
    }

#if !TARGET_LITTLE_ENDIAN
    while( cdw>0 )
    {
        DWORD dw;

        cdw--;
        BYTES_TO_DWORD( dw, (DRM_BYTE*) &f_rgdwOut[cdw] );
        FIX_ENDIAN_DWORD( dw );
        DWORD_TO_BYTES( (DRM_BYTE*) &f_rgdwOut[cdw], dw );
    }
#endif

}

static BOOL dw_to_modular(               
    DWORDC        *dwnum,
    DWORDC         lngdw,
    digit_t       *answer,      /* OUT, length LNGQ */
    mp_modulus_tc *modulo,
    PBIGCTX_ARG    )
{
    digit_t *temp1;
    BOOL OK = FALSE;

    temp1 = (digit_t *) bignum_alloc (SIZEOF (digit_t) * LNGQ, PBIGCTX_PASS);
    if( temp1 != NULL )
    {

        if (DWORDS_TO_DIGITS(lngdw) <= LNGQ)
        {        
            dwords_to_digits(dwnum, temp1, lngdw, PBIGCTX_PASS);
            OK = to_modular(temp1, DWORDS_TO_DIGITS(lngdw), answer, modulo, PBIGCTX_PASS);
        }

        BignumSecureZeroMemory( temp1, SIZEOF (digit_t) * LNGQ );
        bignum_free (temp1, PBIGCTX_PASS);
    }

    return OK;
} /* end dw_to_modular */


BOOL words_to_ecaffine( DWORDC *in, ecaffine_t *P,        /* OUT */
                       ecurve_tc  *E,
                       PBIGCTX_ARG)  
                       /* map bits of "in" to a point on the curve such that the first n-1 bytes can be recovered

                          NOTE: this is only supposed to work for my ec over FIELD_Q_MP and not intended to be
                                used as a general purpose library function.    marcuspe

                         NOTE -- We never return the point at infinity,
                                 so this may fail if the group has no other points,
                                 such as y^2 == x^3 - x - 1 (mod 3)
                         NOTE -- A given point of order 2 (with y = 0) is twice as
                                 likely to be chosen as a given point of order > 2.
                       */
{
    BOOL found = FALSE;
    INT tries;    
    flongest_t *t1;
    DWORD *tmp; /*[LNGQDW] */

    tmp = (DWORD*) bignum_alloc (SIZEOF (DWORD) * LNGQDW + SIZEOF (flongest_t), PBIGCTX_PASS);
    if( tmp == NULL )
    {
        return found;
    }

    t1 = (flongest_t*)(tmp + LNGQDW);
    mp_copy( in, tmp, LNGQDW-1, PBIGCTX_PASS );
    switch(E->fdesc->ftype) {
    case FIELD_Q_MP:
    case FIELD_2_POLYNOMIAL: 
    case FIELD_2_NORMAL:
        for (tries = 0; 
            tries < 100 && !found;
            tries++) {

                tmp[LNGQDW-1] = tries; 
                if( !dw_to_modular( tmp, LNGQDW, P, E->fdesc->modulo, PBIGCTX_PASS) )
                {
                    found = FALSE;
                    break;
                }
                if (E->fdesc->ftype == FIELD_Q_MP || Kiszero(P, E->fdesc, PBIGCTX_PASS) )
                {
                    if (Kmuladd (P, P,   E->a, *t1, E->fdesc, digit_NULL, PBIGCTX_PASS) 
                    &&  Kmuladd (P, *t1, E->b, *t1, E->fdesc, digit_NULL, PBIGCTX_PASS))
                    /*      t1 = x^2 + a                      t1 = x^3 + ax + b */
                    {
                        /* fSquare must be volatile to work in optimized builds of some compilers */
                        volatile BOOL fSquare = FALSE;
                        found = Kprime_sqrter(*t1, (P + E->fdesc->elng), 1, E->fdesc, ( BOOL* )&fSquare, PBIGCTX_PASS) && fSquare;/* Is x^3 + ax + b  a square? */
                        continue;
                    }
                    found = FALSE;
                    break;
                } 
                else 
                {   
                    BOOL fSuccess = FALSE;
                    /* 
                       Characteristic 2, P nonzero
                       Solve y^2 + x*y = x^3 + a*x^2 + b for y.
                       This is equivalent to (y/x)^2 + (y/x) = x + a + b/x^2
                    */
                    if (Kmul     (P,     P, *t1, E->fdesc, digit_NULL, PBIGCTX_PASS) 
                    &&  Kdiv     (E->b, *t1, *t1,      E->fdesc, digit_NULL, PBIGCTX_PASS) 
                    &&  Kadd     (*t1,   P, *t1, E->fdesc, PBIGCTX_PASS) 
                    &&  Kadd     (*t1,   E->a, *t1, E->fdesc, PBIGCTX_PASS) 
                    &&  K2_quad1 (*t1, (P + E->fdesc->elng), E->fdesc, &fSuccess, PBIGCTX_PASS) 
                    &&  fSuccess
                    &&  Kmul     (P, (P + E->fdesc->elng), (P + E->fdesc->elng), E->fdesc, digit_NULL, PBIGCTX_PASS) ) 
                    {
                        found = TRUE;
                        continue;
                    }
                }
            } /* for tries */
            break;
    } /* switch */

    BignumSecureZeroMemory( tmp, SIZEOF (DWORD) * LNGQDW + SIZEOF (flongest_t) );
    bignum_free (tmp, PBIGCTX_PASS);
    return found;
} /* words_to_ecaffine */


static BOOL ecaffine_to_dwords( ecaffine_t *P, DWORD *out, ecurve_tc  *E, PBIGCTX_ARG)
{
    /* inverts the mapping of dwords_to_ecaffine */
    DWORD *tmp; /*[LNGQDW]; */
    digit_t *digs; /*[LNGQ]; */

    tmp =(DWORD*) bignum_alloc( SIZEOF(DWORD) * LNGQDW + SIZEOF( digit_t ) * LNGQ, PBIGCTX_PASS);
    if( tmp != NULL )
    {
    
        digs = (digit_t*)(tmp + LNGQDW );
        from_modular ( P, digs, E->fdesc->modulo, PBIGCTX_PASS);
        digits_to_dwords( digs, tmp, LNGQDW, PBIGCTX_PASS );
        endian_reverse_dwords( (const DWORD *)tmp, out, LNGQDW-1 );
        
        BignumSecureZeroMemory( tmp, SIZEOF(DWORD) * LNGQDW + SIZEOF( digit_t ) * LNGQ );
        bignum_free (tmp, PBIGCTX_PASS);
        return( TRUE );
    }

    return FALSE;
}


#define TABLE_SPACING 4
#define TABLE_LAST 60


#if USE_REAL_MEMORY_ALLOCATION
#define PK_DATA_HEAP_SIZE 1
#else
#define PK_DATA_HEAP_SIZE 250
#endif
typedef struct {
    digit_t q[LNGQ]; 
    digit_t a[LNGQ];
    digit_t b[LNGQ];
    digit_t r[LNGQ];         /* from singature file,   order of g */
    DWORD   lngr;            /* Length of r (digits) */

    ecaffine_t g[2*LNGQ];
    ecaffine_t TABLE[ 2 * LNGQ * (TABLE_LAST+1) ];  /* TEST */

    mp_modulus_t   qmodulus;
    ecurve_t       ecurve;
    field_desc_t   fdesc;    
    reciprocal_1_t rrecip;             /* For division by r */
    
    DRM_STACK_ALLOCATOR_CONTEXT pkdHeap;
    BYTE rgbHeap[__CB_DECL(PK_DATA_HEAP_SIZE)];
} PK_DATA;


static PK_DATA g_pkd;

static DRM_RESULT DRM_API _ThreadUnSafePKInit( DRM_VOID* pContext );
DRM_RESULT DRM_API _ThreadSafeInit( DRM_VOID* pContext );
static DRM_VOID _PKLock();
static DRM_VOID _PKUnlock();

#if DRM_THREAD_SAFE
#define USEPKLOCK DRM_BOOL fLocked = FALSE;
#define PKLOCK {_PKLock();fLocked=TRUE;}
#define PKUNLOCK {if(fLocked){_PKUnlock();}}
#define PKUNINIT {_PKUnInit();}
#else
#define USEPKLOCK
#define PKLOCK
#define PKUNLOCK
#define PKUNINIT
#endif

/*
**  All DRM_PK_MAX_SECRET_ARRAYS pointers are initialized to NULL.
*/
PK_SET_SECRET_FUNCS g_SetSecretFuncs = 
{
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

static HRESULT ec_init( PK_DATA *pEc, 
                       const DWORD *q, 
                       const DWORD *order, 
                       const DWORD *a, 
                       const DWORD *b, 
                       const DWORD *genx, 
                       const DWORD *geny, 
                       PBIGCTX_ARG) 
{
    DRM_DWORD i =0;
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( pEc   != NULL 
         || q     != NULL 
         || order != NULL 
         || a     != NULL 
         || b     != NULL 
         || genx  != NULL 
         || geny  != NULL );
    
    dwords_to_digits( q, pEc->q, LNGQDW, PBIGCTX_PASS );
    dwords_to_digits( order, pEc->r, LNGQDW, PBIGCTX_PASS );

    ChkBOOL( create_modulus( pEc->q, LNGQ, FROM_RIGHT, &pEc->qmodulus, PBIGCTX_PASS, (struct bigctx_t*)&g_pkd.pkdHeap ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( dw_to_modular( a, LNGQDW, pEc->a, &pEc->qmodulus, PBIGCTX_PASS ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( dw_to_modular( b, LNGQDW, pEc->b, &pEc->qmodulus, PBIGCTX_PASS ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( Kinitialize_prime( &pEc->qmodulus, &pEc->fdesc, PBIGCTX_PASS , (struct bigctx_t*)&g_pkd.pkdHeap ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( ec_initialize( pEc->a, pEc->b, &pEc->fdesc, &pEc->ecurve, PBIGCTX_PASS, (struct bigctx_t*)&g_pkd.pkdHeap ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( dw_to_modular( ecdw_genx, LNGQDW, pEc->g, &pEc->qmodulus, PBIGCTX_PASS ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( dw_to_modular( ecdw_geny, LNGQDW, pEc->g + LNGQ, &pEc->qmodulus, PBIGCTX_PASS ), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( ecaffine_on_curve(pEc->g, &pEc->ecurve, NULL, digit_NULL, PBIGCTX_PASS), DRM_E_PKCRYPTO_FAILURE);
    ChkBOOL( ecaffine_table_construction( pEc->g, TABLE_SPACING, TABLE_LAST, pEc->TABLE, &pEc->ecurve, PBIGCTX_PASS ), DRM_E_PKCRYPTO_FAILURE);

    for( i = 0; i < DRM_PK_MAX_SECRET_ARRAYS; i++ )
    {
        if( (*(g_SetSecretFuncs.secretArray[i]))       != NULL
         && (*(g_SetSecretFuncs.secretArray[i]))[6]    != NULL
         && (*(g_SetSecretFuncs.secretArray[i]))[6]( ) != DRM_SUCCESS )
        {
            ChkDR( DRM_E_PKCRYPTO_FAILURE );
        }
        if( (*(g_SetSecretFuncs.secretArray[i])) != NULL )
        {
            (*(g_SetSecretFuncs.secretArray[i]))[6] = NULL;
        }
    }

    pEc->lngr = LNGQ;
    divide_precondition_1( pEc->r, pEc->lngr, &pEc->rrecip, PBIGCTX_PASS );

ErrorExit:
    return dr;
}


static DRM_RESULT DRM_API _ThreadUnSafePKInit( DRM_VOID* f_pContext )
{
    static DRM_BOOL fInited = FALSE;
    DRM_RESULT dr = DRM_E_PKCRYPTO_FAILURE;
    DRM_DWORD i =0;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT*) f_pContext;

    DRMCASSERT( SIZEOF( DRMBIGNUM_CONTEXT_STRUCT ) == DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE );    

    if( fInited )
    {
        return DRM_SUCCESS;
    }
    
    MEMSET( (DRM_BYTE*)&g_pkd, 0, SIZEOF( g_pkd ));    

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack = pContext->rgbHeap;

    mp_initialization((struct bigctx_t*)&pContext->oHeap);

    g_pkd.pkdHeap.nStackTop = 0;
    g_pkd.pkdHeap.cbStack = PK_DATA_HEAP_SIZE;
    g_pkd.pkdHeap.pbStack = g_pkd.rgbHeap;

    for( i = 0; i < DRM_PK_MAX_SECRET_ARRAYS; i++ )
    {
        if( (*(g_SetSecretFuncs.secretArray[i]))       != NULL
         && (*(g_SetSecretFuncs.secretArray[i]))[0]    != NULL
         && (*(g_SetSecretFuncs.secretArray[i]))[0]( ) != DRM_SUCCESS )
        {
            return DRM_E_PKCRYPTO_FAILURE;
        }
        if( (*(g_SetSecretFuncs.secretArray[i])) != NULL )
        {
            (*(g_SetSecretFuncs.secretArray[i]))[0] = NULL;
        }
    }

    dr = ec_init(&g_pkd, ecdw_q, ecdw_order, ecdw_a, ecdw_b, ecdw_genx, ecdw_geny, (struct bigctx_t*)&pContext->oHeap);
    if( DRM_SUCCEEDED( dr ) )
    {
        fInited = TRUE;
    }
    return dr;
}

#if DRM_THREAD_SAFE
#define PKInit( pContext ) _ThreadSafeInit( pContext )
#else
#define PKInit( pContext ) _ThreadUnSafePKInit( pContext )
#endif

/*********************************************************************
**
**  Function:  DRM_PK_GenKeyPair
**
**  Synopsis:  Generate a matched public and private key pair
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]  -- New public key
**     [f_pprivkey] -- New private key
**
*********************************************************************/
DRM_RESULT DRM_API DRM_PK_GenKeyPair( 
    IN     DRM_VOID *f_pContext,
       OUT PUBKEY   *f_ppubkey,
       OUT PRIVKEY  *f_pprivkey )
{
    HRESULT dr = DRM_E_PKCRYPTO_FAILURE;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT *)f_pContext;
    PBIGCTX_ARG         = NULL;
    digit_t    *tmp     = NULL; /* [LNGQ] */
    digit_t    *priv    = NULL; /* [LNGQ] */
    ecaffine_t *pub     = NULL; /* [2*LNGQ] */
    USEPKLOCK;

    ChkArg( f_pContext != NULL 
         && f_ppubkey  != NULL 
         && f_pprivkey != NULL );

    ChkDR( PKInit(pContext) );

    PKLOCK;

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack = pContext->rgbHeap;

    pbigctx = (struct bigctx_t *) &pContext->oHeap;

    ChkMem( tmp  = (digit_t*) bignum_alloc( (SIZEOF ( digit_t ) * 2 * LNGQ) + ( SIZEOF( ecaffine_t ) * 2 *LNGQ ), PBIGCTX_PASS) );

    priv = (digit_t*)   (tmp  + LNGQ);
    pub  = (ecaffine_t*)(priv + LNGQ);
    
    random_mod_nonzero( g_pkd.q, priv, LNGQ, PBIGCTX_PASS );
    if( ecaffine_exponentiation_tabular( g_pkd.TABLE, TABLE_SPACING, TABLE_LAST, priv, LNGQ, pub, &(g_pkd.ecurve), PBIGCTX_PASS ) )
    {

        digits_to_dwords( priv, (DWORD*)f_pprivkey->x, LNGQDW, PBIGCTX_PASS );
        endian_reverse_dwords( (DWORD*)f_pprivkey->x, (DWORD*)f_pprivkey->x, PK_ENC_PRIVATE_KEY_LEN / SIZEOF( DWORD ) );
        
        from_modular ( pub, tmp, &(g_pkd.qmodulus), PBIGCTX_PASS );
        digits_to_dwords( tmp, (DWORD*)f_ppubkey->y, LNGQDW, PBIGCTX_PASS ); 

        from_modular ( pub+LNGQ, tmp, &(g_pkd.qmodulus), PBIGCTX_PASS );
        digits_to_dwords( tmp, ((DWORD*)f_ppubkey->y) + LNGQDW, LNGQDW, PBIGCTX_PASS ); 
        endian_reverse_dwords( (DWORD*)f_ppubkey->y, (DWORD *)f_ppubkey->y, PK_ENC_PUBLIC_KEY_LEN / SIZEOF( DWORD ) );

        dr = DRM_SUCCESS;
    }

    BignumSecureZeroMemory( tmp, (SIZEOF ( digit_t ) * 2 * LNGQ) + ( SIZEOF( ecaffine_t ) * 2 *LNGQ ) );
    bignum_free( tmp, PBIGCTX_PASS );

ErrorExit:
    PKUNLOCK;
    return dr;    
}


/*********************************************************************
**
**  Function:  DRM_PK_Encrypt
**
**  Synopsis:  Encrypt a block of data with a given public key.
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]  -- Public key to encrypt with
**     [f_rgbIn]    -- Data to be encrypted
**     [f_rgbOut]   -- Buffer to hold the encrypted data value.
**
**  Notes:  Data is not encrpyted in place.  It is put in the rgbOut buffer.
*********************************************************************/
DRM_RESULT DRM_API DRM_PK_Encrypt( 
    IN        DRM_VOID *f_pContext, 
    IN  const PUBKEY   *f_ppubkey,
    IN  const DRM_BYTE  f_rgbIn[__CB_DECL(PK_ENC_PLAINTEXT_LEN)],
        OUT   DRM_BYTE  f_rgbOut[__CB_DECL(PK_ENC_CIPHERTEXT_LEN)] )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT *)f_pContext;
    DWORD rgdwPubKey[ PK_ENC_PUBLIC_KEY_LEN / SIZEOF( DWORD )  ];
    PBIGCTX_ARG     = NULL;
    digit_t    *k   = NULL; /* [LNGQ]   */
    ecaffine_t *a   = NULL; /* [2*LNGQ] */
    ecaffine_t *b   = NULL; /* [2*LNGQ] */
    ecaffine_t *tmp = NULL; /* [2*LNGQ] */
    ecaffine_t *ecM = NULL; /* [2*LNGQ] */
    ecaffine_t *pk  = NULL; /* [2*LNGQ] */
    USEPKLOCK;

    ChkArg( f_pContext    != NULL
         && f_ppubkey     != NULL
         && f_rgbIn       != NULL
         && f_rgbOut      != NULL );

    ChkDR( PKInit( pContext ) );

    PKLOCK;

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack   = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack   = pContext->rgbHeap;

    pbigctx = (struct bigctx_t *) &pContext->oHeap;

    ChkMem( k = (digit_t*) bignum_alloc( (SIZEOF( digit_t) * LNGQ ) + ( SIZEOF (ecaffine_t) * 5*2*LNGQ ), PBIGCTX_PASS ) ); 

    a   = (ecaffine_t*)(k   + LNGQ);
    b   = (ecaffine_t*)(a   + 2 * LNGQ);
    tmp = (ecaffine_t*)(b   + 2 * LNGQ);
    ecM = (ecaffine_t*)(tmp + 2 * LNGQ);
    pk  = (ecaffine_t*)(ecM + 2 * LNGQ);

    endian_reverse_dwords( (const DWORD*)f_ppubkey->y, rgdwPubKey, PK_ENC_PUBLIC_KEY_LEN / SIZEOF( DWORD ) );

    dw_to_modular( rgdwPubKey,          LNGQDW, pk,      &(g_pkd.qmodulus), PBIGCTX_PASS );
    dw_to_modular( rgdwPubKey + LNGQDW, LNGQDW, pk+LNGQ, &(g_pkd.qmodulus), PBIGCTX_PASS );

    if( !ecaffine_on_curve(pk, &(g_pkd.ecurve), NULL, digit_NULL, PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    
    endian_reverse_dwords( (const DWORD*)f_rgbIn, (DWORD*)f_rgbOut, PK_ENC_PLAINTEXT_LEN / SIZEOF(DRM_DWORD) );
    if( !words_to_ecaffine( (DWORD *)f_rgbOut, ecM, &(g_pkd.ecurve), PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    random_mod_nonzero( g_pkd.q, k, LNGQ, PBIGCTX_PASS );

    if( !ecaffine_exponentiation_tabular( g_pkd.TABLE, TABLE_SPACING, TABLE_LAST, k, LNGQ, a, &(g_pkd.ecurve), PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    if( !ecaffine_on_curve( pk, &g_pkd.ecurve, NULL, digit_NULL, PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    if( !ecaffine_exponentiation_tabular( pk, TABLE_SPACING, 0, k, LNGQ, tmp, &(g_pkd.ecurve), PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    if( !ecaffine_addition( tmp, ecM, b, 1, &(g_pkd.ecurve), digit_NULL, PBIGCTX_PASS  ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }


    from_modular ( a, tmp, &(g_pkd.qmodulus), PBIGCTX_PASS );
    digits_to_dwords( tmp, (DWORD *)f_rgbOut, LNGQDW, PBIGCTX_PASS ); 
    from_modular ( a+LNGQ, tmp, &g_pkd.qmodulus, PBIGCTX_PASS );
    digits_to_dwords( tmp, ((DWORD *)f_rgbOut)+LNGQDW, LNGQDW, PBIGCTX_PASS ); 

    from_modular ( b, tmp, &g_pkd.qmodulus, PBIGCTX_PASS );
    digits_to_dwords( tmp, ((DWORD *)f_rgbOut) + 2*LNGQDW, LNGQDW, PBIGCTX_PASS ); 
    from_modular ( b+LNGQ, tmp, &g_pkd.qmodulus, PBIGCTX_PASS );
    digits_to_dwords( tmp, ((DWORD *)f_rgbOut) + 3*LNGQDW, LNGQDW, PBIGCTX_PASS ); 

    endian_reverse_dwords( (DWORD *)f_rgbOut, (DWORD*)f_rgbOut, 4*LNGQDW );

ErrorExit:
    PKUNLOCK;
    if( k )
    {
        BignumSecureZeroMemory( k, (SIZEOF( digit_t) * LNGQ ) + ( SIZEOF (ecaffine_t) * 5*2*LNGQ ) );
    }
    bignum_free( k, PBIGCTX_PASS );
    return dr;
}


/*********************************************************************
**
**  Function:  DRM_PK_Decrypt
**
**  Synopsis:  
**
**  Arguments:  
**     [f_pContext] -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_pprivkey] -- Private key to decrypt with
**     [f_rgbIn]    -- Encrypted bytes that are to be decrypted
**     [f_rgbOut]   -- Clear text result
**
**  Notes:  Data is not decrpyted in place.  It is put in the rgbOut buffer.
**
*********************************************************************/
DRM_RESULT DRM_API DRM_PK_Decrypt(
    IN        DRM_VOID *f_pContext,
    IN  const PRIVKEY  *f_pprivkey,
    IN  const DRM_BYTE  f_rgbIn[__CB_DECL(PK_ENC_CIPHERTEXT_LEN)],
        OUT   DRM_BYTE  f_rgbOut[__CB_DECL(PK_ENC_PLAINTEXT_LEN)] )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT *)f_pContext;
    DWORD rgdwPrivKey[ PK_ENC_PRIVATE_KEY_LEN / SIZEOF( DWORD ) ];
    DWORD rgdwIn     [PK_ENC_CIPHERTEXT_LEN / SIZEOF( DWORD )];
    ecaffine_t *a   = NULL; /* [2*LNGQ] */
    ecaffine_t *b   = NULL; /* [2*LNGQ] */
    ecaffine_t *tmp = NULL; /* [2*LNGQ] */
    ecaffine_t *ecM = NULL; /* [2*LNGQ] */
    digit_t    *pk  = NULL; /* [LNGQ]   */
    PBIGCTX_ARG     = NULL;
    USEPKLOCK;
    
    ChkArg( f_pContext    != NULL
         && f_pprivkey    != NULL 
         && f_rgbIn       != NULL 
         && f_rgbOut      != NULL );

    ChkDR( PKInit( pContext ) );

    PKLOCK;

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack   = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack   = pContext->rgbHeap;

    pbigctx = (struct bigctx_t *) &pContext->oHeap;

    ChkMem( pk = (digit_t*)bignum_alloc( (SIZEOF( digit_t) * LNGQ ) + ( SIZEOF (ecaffine_t) * 4*2*LNGQ ), PBIGCTX_PASS ) );

    a   = (ecaffine_t*)(pk  +     LNGQ);
    b   = (ecaffine_t*)(a   + 2 * LNGQ);
    tmp = (ecaffine_t*)(b   + 2 * LNGQ);
    ecM = (ecaffine_t*)(tmp + 2 * LNGQ);


    endian_reverse_dwords( (const DWORD *)f_pprivkey->x, rgdwPrivKey, PK_ENC_PRIVATE_KEY_LEN / SIZEOF( DWORD ) );
    dwords_to_digits( rgdwPrivKey, pk, LNGQDW, PBIGCTX_PASS );

    endian_reverse_dwords( (const DWORD *)f_rgbIn, rgdwIn, PK_ENC_CIPHERTEXT_LEN / SIZEOF(DWORD) );

    dw_to_modular( rgdwIn,          LNGQDW, a,      &g_pkd.qmodulus, PBIGCTX_PASS );
    dw_to_modular( rgdwIn + LNGQDW, LNGQDW, a+LNGQ, &g_pkd.qmodulus, PBIGCTX_PASS );
    dw_to_modular( rgdwIn+2*LNGQDW, LNGQDW, b,      &g_pkd.qmodulus, PBIGCTX_PASS );
    dw_to_modular( rgdwIn+3*LNGQDW, LNGQDW, b+LNGQ, &g_pkd.qmodulus, PBIGCTX_PASS );

    if( !ecaffine_on_curve( a, &g_pkd.ecurve, NULL, digit_NULL, PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    if( !ecaffine_exponentiation_tabular( a, TABLE_SPACING, 0, pk, LNGQ, tmp, &(g_pkd.ecurve), PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( !ecaffine_addition( b, tmp, ecM, -1, &(g_pkd.ecurve), digit_NULL, PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( !ecaffine_to_dwords( ecM, (DWORD *)f_rgbOut, &(g_pkd.ecurve), PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    
ErrorExit:
    PKUNLOCK;
    if( pContext )
    {
        if( pk )
        {
            BignumSecureZeroMemory( pk, (SIZEOF( digit_t) * LNGQ ) + ( SIZEOF (ecaffine_t) * 4*2*LNGQ ) );
        }

        bignum_free( pk, PBIGCTX_PASS );
    }
    return( dr );
}

#define SIGN_BUF_LEN  (LNGQDW*SIZEOF(DWORD))

static BOOL DRM_API byte_array_mod_bignum(
    const BYTE              buf[__CB_DECL(SIGN_BUF_LEN)],                                  
          digit_t           remainder[],
          PBIGCTX_ARG )               /* Given a message to be signed, in byte form reduce it modulo g_pkd.r[].  */
{

#define PACKED_CHAR_BIT (CHAR_BIT/CB_NATIVE_BYTE)
#define BYTES_PER_DIGIT (RADIX_BITS/PACKED_CHAR_BIT)

#if (RADIX_BITS % CHAR_BIT != 0) 
#error "Radix_bits not multiple of CHAR_BIT"
#endif    
    digit_t *dividend; /*[SIGN_BUF_LEN] */
    DWORD ib;

    dividend = (digit_t*)bignum_alloc( SIGN_BUF_LEN * SIZEOF( digit_t ), PBIGCTX_PASS );
    if( dividend == NULL )
    {
        return FALSE;
    }

    mp_clear(dividend, SIGN_BUF_LEN, PBIGCTX_PASS);
        
    for (ib = 0; ib < SIGN_BUF_LEN; ib++) 
    {
        DWORDC idigit = ib/BYTES_PER_DIGIT;
        DWORDC ishift = PACKED_CHAR_BIT*ib - RADIX_BITS*idigit;
        dividend[idigit] |= ((digit_t)GET_BYTE(buf,ib)) << ishift;
    }

    /* Do the division, discard quotient. */
    divide(dividend, SIGN_BUF_LEN, g_pkd.r, g_pkd.lngr, &g_pkd.rrecip, digit_NULL, remainder, PBIGCTX_PASS);
    BignumSecureZeroMemory( dividend, SIGN_BUF_LEN * SIZEOF( digit_t ) );
    bignum_free( dividend, PBIGCTX_PASS );
    return TRUE;
} /* end byte_array_mod_bignum */

static BOOL FE2IPmod(digit_tc         *fdata,
                     field_desc_tc    *fdesc,
                     digit_tc          divisor[],
                     DWORDC            ldivisor,
                     reciprocal_1_tc  *recip,
                     digit_t           remainder[],    /* OUT */
                     VOID* pContext )
                     /* Convert (i.e., cast) a field element to an integer, */
                     /* reduce the value modulo divisor.  FE2IP is a P1363 function. */
                     /* TBD -- Do we need byte reversal? */
{
    BOOL OK = TRUE;
    digit_t *mdata; /*[MP_LONGEST]; */
    digit_tc *data;
    PBIGCTX_ARG = (struct bigctx_t*) pContext;

    mdata = (digit_t*)bignum_alloc( SIZEOF( digit_t ) * MP_LONGEST, PBIGCTX_PASS );
    if( mdata == NULL )
    {
        return FALSE;
    }

    if (fdesc->ftype == FIELD_Q_MP)
    {
        from_modular(fdata, mdata, fdesc->modulo, PBIGCTX_PASS);    /* Get standard representation */
        data = mdata;
    }
    else
    {  /* Characteristic 2 */
        data = fdata;
        if( !(mp_significant_bit_count(fdata, fdesc->elng, PBIGCTX_PASS) <= fdesc->degree) )
        {
            OK = FALSE;
            /* Leading zeros expected */
        }        
    }
    if( OK )
    {
        divide(data, fdesc->elng, divisor, ldivisor, recip, digit_NULL, remainder, PBIGCTX_PASS);
    }
    BignumSecureZeroMemory( mdata, SIZEOF( digit_t ) * MP_LONGEST );
    bignum_free( mdata, PBIGCTX_PASS );
    return OK;
} /* end FE2IPmod */



/*********************************************************************
**
**  Function:  DRM_PK_Sign
**
**  Synopsis:  Generate a digital signature with a private key
**
**  Arguments:  
**     [f_pContext]     -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_privkey]      -- Private key to create a signature with
**     [f_pbData]       -- Array of bytes to create a signature over
**     [f_cbData]       -- Length of pbBuffer in bytes
**     [f_rgbSignature] -- Buffer to hold result signature
*********************************************************************/
DRM_RESULT DRM_API DRM_PK_Sign(
    IN       DRM_VOID  *f_pContext,
    IN const PRIVKEY   *f_privkey,
    IN const DRM_BYTE  *f_pbData,
    IN       DRM_DWORD  f_cbData,
       OUT   DRM_BYTE   f_rgbSignature[__CB_DECL(PK_ENC_SIGNATURE_LEN)] )
{    
    DRM_RESULT dr = DRM_SUCCESS;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT *)f_pContext;
    DWORD rgdwPrivKey[ PK_ENC_PRIVATE_KEY_LEN / SIZEOF( DWORD )];
    DWORD ntry = 0;
    DWORDREG    lgcd   = 0;
    ecaffine_t *Gpriv2 = NULL;  /* [2*MP_LONGEST] */
    digit_t *gcd       = NULL;  /* [MP_LONGEST] */
    digit_t *priv2     = NULL;  /* [MP_LONGEST] */
    digit_t *priv2inv  = NULL;  /* [MP_LONGEST] */
    digit_t *sigc      = NULL;  /* [LNGQ] */
    digit_t *sigd      = NULL;  /* [LNGQ] */
    digit_t *privexpon = NULL;  /* [LNGQ] */
    BYTE    *buffer    = NULL;  /* [SIGN_BUF_LEN]     */
    PBIGCTX_ARG        = NULL;
    USEPKLOCK;
    
    ChkArg( f_pContext     != NULL 
         && f_privkey      != NULL 
         && f_pbData       != NULL 
         && f_cbData       != 0 
         && f_rgbSignature != NULL );

    ChkDR( PKInit( pContext ) );

    PKLOCK;

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack   = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack   = pContext->rgbHeap;

    pbigctx = (struct bigctx_t *) &pContext->oHeap;

    ChkMem( gcd = (digit_t*)bignum_alloc( (SIZEOF( digit_t) * (3*LNGQ + 3*MP_LONGEST) ) 
                                         +(SIZEOF(ecaffine_t) * 2*MP_LONGEST ) 
                                         +SIGN_BUF_LEN,
                                         PBIGCTX_PASS ) );

    priv2     = gcd      + MP_LONGEST;
    priv2inv  = priv2    + MP_LONGEST;
    sigc      = priv2inv + MP_LONGEST;
    sigd      = sigc     + LNGQ;
    privexpon = sigd     + LNGQ;

    Gpriv2    = (ecaffine_t*)(privexpon + LNGQ);
    buffer    = (BYTE*)(Gpriv2      + 2 * MP_LONGEST);

    endian_reverse_dwords( (const DWORD *)f_privkey->x, rgdwPrivKey, PK_ENC_PRIVATE_KEY_LEN / SIZEOF( DWORD ) );
    dwords_to_digits( rgdwPrivKey, privexpon, LNGQDW, PBIGCTX_PASS );

    {
        SHA_CONTEXT shadata;

        MEMSET( buffer, 0, SIGN_BUF_LEN );

        DRM_SHA_Init( &shadata );
        DRM_SHA_Update( (DRM_BYTE*) f_pbData, f_cbData, &shadata );
        DRM_SHA_Finalize( &shadata, buffer );
    }

    for( ntry = 0; ntry < 1000; ntry++ )
    {
        // BUGBUG: This should be the same logic as the original but I'm not sure if the logic is really perfect
        random_mod_nonzero( g_pkd.q, priv2, LNGQ, PBIGCTX_PASS );
        
        if( !ecaffine_exponentiation_tabular( g_pkd.TABLE, TABLE_SPACING, TABLE_LAST, priv2, LNGQ, Gpriv2, &g_pkd.ecurve, PBIGCTX_PASS ) )
        {
            ChkDR( DRM_E_PKCRYPTO_FAILURE );
        }

        if( ecaffine_is_infinite(Gpriv2, &g_pkd.ecurve, PBIGCTX_PASS ) )
        {
            break;
        }

        if( !FE2IPmod(Gpriv2, g_pkd.ecurve.fdesc, g_pkd.r, g_pkd.lngr, &g_pkd.rrecip, sigc, PBIGCTX_PASS ) )
        {
            break;
        }

        if( compare_immediate(gcd, 1, mp_gcdex(priv2, g_pkd.lngr, g_pkd.r, g_pkd.lngr,  priv2inv, digit_NULL, gcd, digit_NULL, &lgcd, NULL, PBIGCTX_PASS)) != 0 )
        {
            break;
        }

        multiply(sigc, g_pkd.lngr, privexpon, g_pkd.lngr, Gpriv2, PBIGCTX_PASS);   
        if( !byte_array_mod_bignum(buffer, gcd, PBIGCTX_PASS ) )
        {
            break;
        }
        
        add_diff(Gpriv2, 2*g_pkd.lngr, gcd, g_pkd.lngr, Gpriv2, digit_NULL, PBIGCTX_PASS);  /* Overflow impossible */
        divide(Gpriv2, 2*g_pkd.lngr, g_pkd.r, g_pkd.lngr, &g_pkd.rrecip, digit_NULL, gcd, PBIGCTX_PASS);
        multiply(priv2inv, g_pkd.lngr, gcd, g_pkd.lngr, Gpriv2, PBIGCTX_PASS);
        divide(Gpriv2, 2*g_pkd.lngr, g_pkd.r, g_pkd.lngr, &g_pkd.rrecip, digit_NULL, sigd, PBIGCTX_PASS);            
        
        /* TBD -- should check more error codes */

        if( !all_zero(sigc, g_pkd.lngr) 
         && !all_zero(sigd, g_pkd.lngr) )
        {
            break;
        }

    }

    mp_clear(priv2, g_pkd.lngr, PBIGCTX_PASS);    /* P1363 recommends this for security */
    mp_clear(priv2inv, g_pkd.lngr, PBIGCTX_PASS);
    mp_clear(Gpriv2, MAX(2*g_pkd.lngr, 2*g_pkd.ecurve.fdesc->elng), PBIGCTX_PASS);

    digits_to_dwords( sigc, (DWORD *)f_rgbSignature, LNGQDW, PBIGCTX_PASS );
    digits_to_dwords( sigd, ((DWORD *)f_rgbSignature) + LNGQDW, LNGQDW, PBIGCTX_PASS );

    endian_reverse_dwords( (const DWORD *)f_rgbSignature, (DWORD*) f_rgbSignature, 2*LNGQDW );

ErrorExit:
    PKUNLOCK;
    if( pContext )
    {
        if( gcd )
        {
            BignumSecureZeroMemory( gcd, (SIZEOF( digit_t) * (3*LNGQ + 3*MP_LONGEST) ) + (SIZEOF(ecaffine_t) * 2*MP_LONGEST ) + SIGN_BUF_LEN );
        }
        bignum_free( gcd, PBIGCTX_PASS );
    }
    return dr;
} /* end DRM_PK_Sign */


/*********************************************************************
**
**  Function:  DRM_PK_Verify
**
**  Synopsis:  Verify a digital signature created by DRM_PK_Sign.
**
**  Arguments:  
**     [f_pContext]     -- Pointer to context the size of DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE
**     [f_ppubkey]      -- Pubkey to check the signature with
**     [f_pbData]       -- Data buffer that the signature was created over
**     [f_cbData]       -- Length of pbBuffer in bytes
**     [f_rgbSignature] -- The signature to verify
**
**  Returns:  TRUE if the signature verified correctly.  FALSE is it didn't
**
*********************************************************************/
DRM_BOOL DRM_API DRM_PK_Verify( 
    IN       DRM_VOID  *f_pContext,
    IN const PUBKEY    *f_ppubkey, 
    IN const DRM_BYTE  *f_pbData, 
    IN       DRM_DWORD  f_cbData, 
    IN const DRM_BYTE   f_rgbSignature[__CB_DECL(PK_ENC_SIGNATURE_LEN)] )
{    
    DRM_RESULT dr = DRM_SUCCESS;
    DRMBIGNUM_CONTEXT_STRUCT *pContext = (DRMBIGNUM_CONTEXT_STRUCT *)f_pContext;
    DWORD rgdwPubKey[ PK_ENC_PUBLIC_KEY_LEN / SIZEOF( DWORD ) ];
    DWORD rgdwSignature[ 2*LNGQDW ];
    DWORDREG    lgcd     = 0;
    digit_t    *sigdinv  = NULL; /* [MP_LONGEST] */
    digit_t    *gcd      = NULL; /* [MP_LONGEST] */
    digit_t    *sigc     = NULL; /* [LNGQ] */
    digit_t    *sigd     = NULL; /* [LNGQ] */
    ecaffine_t *h1G      = NULL; /* [2*MP_LONGEST] */
    ecaffine_t *h2pubkey = NULL; /* [2*MP_LONGEST] */
    ecaffine_t *pubkey   = NULL; /* [2*LNGQ] */
    BYTE       *buffer   = NULL; /* [SIGN_BUF_LEN] */
    PBIGCTX_ARG          = NULL;
    ecurve_tc  *ecurve   = NULL;
    USEPKLOCK;
    
    ChkArg( f_pContext     != NULL 
         && f_ppubkey      != NULL 
         && f_pbData       != NULL 
         && f_cbData       != 0 
         && f_rgbSignature != NULL );

    ChkDR( PKInit( pContext ) );

    PKLOCK;

    pContext->oHeap.nStackTop = 0;
    pContext->oHeap.cbStack   = DRM_PKCRYPTO_CONTEXT_BUFFER_INTERNAL_SIZE;
    pContext->oHeap.pbStack   = pContext->rgbHeap;

    pbigctx = (struct bigctx_t *) &pContext->oHeap;

    ChkMem( sigdinv = (digit_t*)bignum_alloc( (SIZEOF( digit_t) * (2*LNGQ + 2*MP_LONGEST) ) 
                                             +(SIZEOF(ecaffine_t) * (2*2*MP_LONGEST + 2*LNGQ) )
                                             + SIGN_BUF_LEN, 
                                             PBIGCTX_PASS ) );

    gcd      = sigdinv  + MP_LONGEST;
    sigc     = gcd      + MP_LONGEST;
    sigd     = sigc     + LNGQ;
    h1G      = (ecaffine_t*)(sigd     +  LNGQ);
    h2pubkey = h1G      + 2*MP_LONGEST;
    pubkey   = h2pubkey + 2*MP_LONGEST;
    buffer   = (BYTE*)(pubkey   +2*LNGQ);

    ecurve = &g_pkd.ecurve;

    endian_reverse_dwords( (const DWORD *)f_rgbSignature, rgdwSignature, 2*LNGQDW );

    dwords_to_digits( rgdwSignature,          sigc, LNGQDW, PBIGCTX_PASS );
    dwords_to_digits( rgdwSignature + LNGQDW, sigd, LNGQDW, PBIGCTX_PASS );

    endian_reverse_dwords( (const DWORD *)f_ppubkey->y, rgdwPubKey, PK_ENC_PUBLIC_KEY_LEN / SIZEOF( DWORD ) );

    dw_to_modular( rgdwPubKey,        LNGQDW, pubkey,      &(g_pkd.qmodulus), PBIGCTX_PASS );
    dw_to_modular( rgdwPubKey+LNGQDW, LNGQDW, pubkey+LNGQ, &(g_pkd.qmodulus), PBIGCTX_PASS );


    {
        SHA_CONTEXT shadata;

        MEMSET( buffer, 0, SIGN_BUF_LEN);

        DRM_SHA_Init( &shadata );
        DRM_SHA_Update( (BYTE*)f_pbData, f_cbData, &shadata );
        DRM_SHA_Finalize( &shadata, buffer ); 
    }


    if( !ecaffine_on_curve(pubkey, ecurve, NULL, digit_NULL, PBIGCTX_PASS) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if(  all_zero(sigc, g_pkd.lngr) 
     && !all_zero(sigd, g_pkd.lngr) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( compare_same(sigc, g_pkd.r, g_pkd.lngr) >= 0 )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( compare_same(sigd, g_pkd.r, g_pkd.lngr) >= 0 )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }


    if( compare_immediate(gcd, 1, mp_gcdex(sigd, g_pkd.lngr, g_pkd.r, g_pkd.lngr, sigdinv, digit_NULL, gcd, digit_NULL, &lgcd, NULL, PBIGCTX_PASS)) != 0 )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( !byte_array_mod_bignum(buffer, gcd, PBIGCTX_PASS) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    multiply(sigdinv, g_pkd.lngr, gcd, g_pkd.lngr, h1G, PBIGCTX_PASS);      
    divide(h1G, 2*g_pkd.lngr, g_pkd.r, g_pkd.lngr, &(g_pkd.rrecip), digit_NULL, gcd, PBIGCTX_PASS);
    
    if( !ecaffine_exponentiation_tabular(g_pkd.TABLE, TABLE_SPACING, TABLE_LAST, gcd, g_pkd.lngr, h1G, ecurve, PBIGCTX_PASS) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    multiply(sigdinv, g_pkd.lngr, sigc, g_pkd.lngr, h2pubkey, PBIGCTX_PASS);
    divide(h2pubkey, 2*g_pkd.lngr, g_pkd.r, g_pkd.lngr, &(g_pkd.rrecip), digit_NULL, gcd, PBIGCTX_PASS);

    if( !ecaffine_on_curve( pubkey, ecurve, NULL, digit_NULL, PBIGCTX_PASS) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( !ecaffine_exponentiation_tabular(pubkey, TABLE_SPACING, 0, gcd, g_pkd.lngr, h2pubkey, ecurve, PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    
    ecaffine_addition(h1G, h2pubkey, h1G, +1, ecurve, digit_NULL, PBIGCTX_PASS );
    
    if( ecaffine_is_infinite(h1G, ecurve, PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }
    if( !FE2IPmod(h1G, ecurve->fdesc, g_pkd.r, g_pkd.lngr, &(g_pkd.rrecip), gcd, PBIGCTX_PASS ) )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

    if( compare_same(sigc, gcd, g_pkd.lngr) != 0 )
    {
        ChkDR( DRM_E_PKCRYPTO_FAILURE );
    }

ErrorExit:
    PKUNLOCK;
    if( pContext )
    {
        if( sigdinv )
        {
            BignumSecureZeroMemory( sigdinv, (SIZEOF( digit_t) * (2*LNGQ + 2*MP_LONGEST) ) + (SIZEOF(ecaffine_t) * (2*2*MP_LONGEST + 2*LNGQ) ) + SIGN_BUF_LEN );
        }
        bignum_free( sigdinv, PBIGCTX_PASS );
    }
    return DRM_SUCCEEDED( dr );
} /* end ecvp_dsa */

#ifdef __cplusplus
extern "C"
#endif
DRM_RESULT DRM_API OEM_GenRandomBytes( DRM_BYTE*, DRM_DWORD );

#ifdef __cplusplus
extern "C"
#endif
BOOL WINAPI random_bytes(BYTE* byte_array, const size_t nbyte, PBIGCTX_ARG)
{
    if( DRM_SUCCEEDED( OEM_GenRandomBytes( byte_array, nbyte) ) )
    {
        return TRUE;
    }

    return FALSE;
}


void* WINAPI bignum_alloc(const size_t cblen, PBIGCTX_ARG )
{
#if USE_REAL_MEMORY_ALLOCATION
    DRM_DWORD cchLen = 0;

    cbCur += cblen;
    if( cbCur > cbMax )
    {
        cbMax = cbCur;
    }
    return HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, cblen );

#else
    VOID *pbRet = NULL;

    if( NULL == PBIGCTX_PASS )
    {  
        return OEM_malloc( cblen );
    }
    else if (DRM_FAILED (DRM_STK_Alloc ((DRM_STACK_ALLOCATOR_CONTEXT*) PBIGCTX_PASS, cblen, &pbRet)))
    {
        return NULL;
    }
    return pbRet;
#endif
}

void WINAPI bignum_free(void *pvMem, PBIGCTX_ARG)
{
    if( NULL == PBIGCTX_PASS )
    {
        SAFE_OEM_FREE( pvMem );
    }
    else if ( pvMem != NULL )
    {
#if USE_REAL_MEMORY_ALLOCATION
#if TRACK_MAX_HEAP_USAGE
        cbCur -= HeapSize( GetProcessHeap(), 0, pvMem );
#endif
        HeapFree( GetProcessHeap(), 0, pvMem );
#else

        DRM_STK_Free( (DRM_STACK_ALLOCATOR_CONTEXT*) PBIGCTX_PASS, pvMem );
#endif
    }
}

/*********************************************************************
**
**  Function:  DRM_PK_Uninitialize
**
**  Synopsis:  Uninitializes PK Crypto code
**
*********************************************************************/
DRM_VOID DRM_API DRM_PK_Uninitialize()
{
    PKUNINIT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\oemtime.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <stdlib.h>
#include <time.h>
#define NO_DRM_CRT 1
#include <drmcommon.h>
#include <oemimpl.h>

#define C_SECONDS_FROM_1601_TO_1970  DRM_UI64Mul(DRM_UI64(1164447360), DRM_UI64(10))
#define C_TICS_PER_SECOND 10000000

/* convert a 32-bit time_t to a 64-bit DRMFILETIME 
   only valid for 1970-2038 AD */

static void _time_t_To_FILETIME (IN  time_t         time_tA, 
                                OUT DRMFILETIME   *pfiletime)
{
    DRM_UINT64 tics;

    /* convert a time_t (seconds since 1970) to seconds-since-1601 */ 

    tics = DRM_UI64Add(DRM_UI64(time_tA),C_SECONDS_FROM_1601_TO_1970);

    /* convert seconds to 100-nanosecond tics */

    tics = DRM_UI64Mul( tics, DRM_UI64(C_TICS_PER_SECOND));
    
    UI64_TO_FILETIME( tics, *pfiletime );
}

static DRM_VOID _struct_tm_To_SYSTEMTIME (IN struct tm       *ptm,
                                         OUT DRMSYSTEMTIME  *psystime)
{
    psystime->wYear         = (DRM_WORD) ptm->tm_year + 1900;
    psystime->wMonth        = (DRM_WORD) ptm->tm_mon  + 1;
    psystime->wDay          = (DRM_WORD) ptm->tm_mday;
    psystime->wHour         = (DRM_WORD) ptm->tm_hour;
    psystime->wMinute       = (DRM_WORD) ptm->tm_min;
    psystime->wSecond       = (DRM_WORD) ptm->tm_sec;
    psystime->wDayOfWeek    = (DRM_WORD) ptm->tm_wday;
    psystime->wMilliseconds = 0;
}

static DRM_VOID _SYSTEMTIME_To_struct_tm (IN  const DRMSYSTEMTIME  *psystime,
                                         OUT struct tm            *ptm)
{
    ptm->tm_year = psystime->wYear  - 1900; /* current minus 1900 */
    ptm->tm_mon  = psystime->wMonth - 1;    /* (0-11) */
    ptm->tm_mday = psystime->wDay;          /* (1-31) */
    ptm->tm_hour = psystime->wHour;         /* (0-23) */
    ptm->tm_min  = psystime->wMinute;       /* (0-59) */
    ptm->tm_sec  = psystime->wSecond;       /* (0-59) */
    ptm->tm_wday = psystime->wDayOfWeek;    /* (0-6)  */
}

static DRM_BOOL _SystemTimeToTime_t(IN const DRMSYSTEMTIME *psystime,
                                    OUT      time_t        *ptimet)
{
    struct tm  tmA   = {0};
    struct tm  tmB   = {0};
    time_t     timeA = 0;
    time_t     timeB = 0;

    /* internal function, no need to test ptimet == NULL */
    
    if( ( psystime->wYear  <  1601 || psystime->wYear > 2032 ) ||
        ( psystime->wMonth == 0    || psystime->wMonth > 12 ) ||
        ( psystime->wDay   == 0    || psystime->wMonth > 31 ) ||
        ( psystime->wHour   > 23 ) ||
        ( psystime->wMinute > 59 ) ||
        ( psystime->wSecond > 59 ) )
    {
        return FALSE;
    }
        
    _SYSTEMTIME_To_struct_tm (psystime, &tmA);

    /* The mktime function needs some care.  The tm struct we give it is in the TZ we want but maketime feels the need
       to adjust for the current machine time zone.  To work around this we have to figure out through more calls to
       gmtime and mktime what that TZ offset is so we can later remove it from the original result of mktime */
    timeA = mktime (&tmA);
    MEMCPY( &tmB, gmtime( &timeA ), SIZEOF(tmB) );

    timeB = mktime (&tmB);
   
    if( timeB > timeA )
    {
        timeA -= (timeB - timeA);
    }
    else
    {
        timeA += (timeA - timeB );
    }

    *ptimet = timeA;
    return TRUE;
}


DRM_BOOL DRM_API OEM_SystemTimeToFileTime (IN const DRMSYSTEMTIME *psystime,
                                           OUT      DRMFILETIME   *pfiletime)
{
    DRM_UINT64 ui64;
    time_t     timeA = 0;

    if (!_SystemTimeToTime_t(psystime, &timeA))
    {
        return FALSE;
    }

    _time_t_To_FILETIME (timeA, pfiletime);
    
    FILETIME_TO_UI64( *pfiletime, ui64 );
    DRM_UI64Add( ui64, DRM_UI64(psystime->wMilliseconds * 10000) );
    UI64_TO_FILETIME( ui64, *pfiletime );
    
    return TRUE;
}

DRM_BOOL DRM_API OEM_FileTimeToSystemTime (IN const DRMFILETIME *pfiletime,
                                           OUT DRMSYSTEMTIME    *psystime)
{
    DRM_UINT64 tics;
    DRM_UINT64 ui64;
    struct tm *ptm   = NULL;
    time_t     timeA = 0;
    DRM_BOOL   fOK   = FALSE;
    DRM_DWORD  cMilliseconds = 0;

    if ( pfiletime == NULL  ||  psystime == NULL )
    {
        return FALSE;
    }

    FILETIME_TO_UI64( *pfiletime, ui64 );
    FILETIME_TO_UI64( *pfiletime, tics );

    cMilliseconds  = DRM_I64ToUI32(DRM_UI2I64(DRM_UI64Mod( ui64, DRM_UI64( C_TICS_PER_SECOND ) )));
    cMilliseconds /= 10000;
    
    /* convert to seconds */
    
    tics = DRM_UI64Div( tics, DRM_UI64(C_TICS_PER_SECOND) );
    
    /* change base to ANSI time's */
    
    tics = DRM_UI64Sub( tics, C_SECONDS_FROM_1601_TO_1970);
        
    timeA = (time_t) DRM_I64ToUI32(DRM_UI2I64(tics));
    
    if ((ptm = gmtime (&timeA)) != NULL)
    {
        _struct_tm_To_SYSTEMTIME (ptm, psystime);
        psystime->wMilliseconds = (DRM_WORD) cMilliseconds;
        fOK = TRUE;
    }

    return fOK;
}

DRM_VOID DRM_API OEM_GetDeviceTime (OUT DRMFILETIME *pfiletime)
{
    time_t timeNow = 0;    

    if ( pfiletime != NULL )
    {
        time (&timeNow);
        _time_t_To_FILETIME (timeNow, pfiletime);
    }
}

DRM_VOID DRM_API OEM_GetDeviceDateTime (OUT DRMSYSTEMTIME* psystime)
{
    time_t     timeNow = 0;
    struct tm *ptm = NULL;

    if ( psystime != NULL )
    {
        time (&timeNow);
        
        if ((ptm = gmtime (&timeNow)) != NULL)
        {
            _struct_tm_To_SYSTEMTIME (ptm, psystime);
        }
    }
}

DRM_VOID DRM_API OEM_SetSystemTime(IN DRMSYSTEMTIME* psystime)
{
    struct tm *plocaltime = NULL;
    time_t     timeA      = 0;

    /* convert it to time_t structure  */
    if (psystime != NULL  
     && _SystemTimeToTime_t(psystime, &timeA))
    {
        /* convert gmt time from time_t to local time in struct tm */
        plocaltime = localtime(&timeA);

#if !defined( __TMS320C55X__ ) && !defined( __arm )
        /*OEMNOTE: this function is not in ANSI C.  Setting the system time is now entirely OS-dependent and there is no
        **         standard ANSI C way to do it.  Porting kit users should replace this with a non-portable API call 
        **         _setsystem() expects a local time 
        */
        
        _setsystime (plocaltime, 0);
#endif    
    }
}

DRM_DWORD DRM_API OEM_GetTickCount()
{
    return clock();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\packageinit.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <stdio.h>
#include <oemimpl.h>
#include <drmxmlbuilder.h>
#include <drmkeygenerator.h>
#include <drmcmdlnpars.h>

#include <drmtoolsconstants.h>
#include <drmtoolsmacros.h>
#include <drmtoolsutils.h>

/* ---------------------------------------------------------------------------
** local constants
** ---------------------------------------------------------------------------
*/
const DRM_DWORD _majorVersion   = 1;
const DRM_DWORD _minorVersion   = 0;

/*
**
*/
static DRM_RESULT _ReallocXmlContext ( DRM_BYTE **ppbXmlContext )
{
    DRM_RESULT  dr              = DRM_SUCCESS;
    DRM_DWORD   cbXmlContext    = 0;
    DRM_BYTE   *pbNewXmlContext = NULL;

    ChkDR( DRM_XMB_GetContextSize( *ppbXmlContext, &cbXmlContext ) );  /* get current size */
    ChkMem( pbNewXmlContext = ( DRM_BYTE * ) OEM_malloc( 2 * cbXmlContext ) );  /* alloc double of the current size */
    ChkDR( DRM_XMB_ReallocDocument( *ppbXmlContext, 2 * cbXmlContext, pbNewXmlContext ) );
    OEM_free( *ppbXmlContext );
    *ppbXmlContext = pbNewXmlContext;

    ErrorExit : return dr;
}

/*
** 
** <PACKAGEKEYS>
**     <KEYSEED></KEYSEED>
**     <SIGNINGKEY></SIGNINGKEY>
**     <VERIFICATIONKEY></VERIFICATIONKEY>
**     <LAURL>http://v2srv/WM/getv2lic.asp</LAURL>
**     <ENCBLKSIZE></ENCBLKSIZE>
** </PACKAGEKEYS>
** 
*/
static DRM_RESULT _GenInitFile ( const DRM_CONST_STRING *f_pdstrLAURL,
                                 const DRM_CONST_STRING *f_pdstrBlockSize,
                                 const DRM_CONST_STRING *f_pdstrFileName)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CRYPTO_CONTEXT *pCrypto      = NULL;
    DRM_DWORD           cbXmlContext = 257;     /* use an odd size to cause reallocation */
    DRM_BYTE           *pbXmlContext = NULL;
    DRM_STRING          dstrKeySeed  = EMPTY_DRM_STRING;
    DRM_STRING          dstrPrivKey  = EMPTY_DRM_STRING;
    DRM_STRING          dstrPubKey   = EMPTY_DRM_STRING;
    DRM_STRING          dstrBlockSize= EMPTY_DRM_STRING;
    DRM_STRING          dstrXML      = EMPTY_DRM_STRING;
    DRM_WCHAR          *pwszFile     = NULL;
    OEM_FILEHDL         fp           = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD           dwNumberOfBytesWritten  = 0;

    pCrypto = ( DRM_CRYPTO_CONTEXT * ) OEM_malloc( SIZEOF( DRM_CRYPTO_CONTEXT ) );
    if ( pCrypto == NULL )
    {
        printf( "\n** Out of memory. ** \n" );
        ChkDR( DRM_E_OUTOFMEMORY );
    }

    /* use XMLBuilder to build the PkgKeys.xml file */
    pbXmlContext = ( DRM_BYTE * ) OEM_malloc( cbXmlContext );
    ChkDR( DRM_XMB_CreateDocument( cbXmlContext, pbXmlContext, &g_dstrTagRoot));

    /* generate Keyseed */
    dr = DRM_KG_GenerateKeyseed( NULL, &dstrKeySeed.cchString );
    if ( dr != DRM_E_BUFFERTOOSMALL )
    {
        ChkDR( dr );
    }

    dstrKeySeed.pwszString = ( DRM_WCHAR * ) OEM_malloc(CB_DSTR(&dstrKeySeed));
    ChkDR( DRM_KG_GenerateKeyseed( dstrKeySeed.pwszString, &dstrKeySeed.cchString ) );
    dstrKeySeed.cchString--; /* Drop off the NULL terminator */

    /* add Keyseed node */
    CallXmlBuilder( pbXmlContext, DRM_XMB_OpenNode(pbXmlContext, &g_dstrTagKeySeed));
    CallXmlBuilder( pbXmlContext, DRM_XMB_AddData( pbXmlContext, ( DRM_CONST_STRING * ) &dstrKeySeed ) );
    CallXmlBuilder( pbXmlContext, DRM_XMB_CloseCurrNode( pbXmlContext, NULL ) );

    /* generate signing key pair */
    ZEROMEM(pCrypto, SIZEOF( DRM_CRYPTO_CONTEXT ) );    

    dr = DRM_KG_GenerateSigningKeys( pCrypto, NULL, &dstrPrivKey.cchString, NULL, &dstrPubKey.cchString );
    if ( dr != DRM_E_BUFFERTOOSMALL )
    {
        ChkDR( dr );
    }

    dstrPrivKey.pwszString = ( DRM_WCHAR * ) OEM_malloc(CB_DSTR(&dstrPrivKey));
    dstrPubKey.pwszString  = ( DRM_WCHAR * ) OEM_malloc(CB_DSTR(&dstrPubKey));
    ChkDR( DRM_KG_GenerateSigningKeys( pCrypto,
                                       dstrPrivKey.pwszString,
                                      &dstrPrivKey.cchString,
                                       dstrPubKey.pwszString,
                                      &dstrPubKey.cchString ) );
    dstrPrivKey.cchString--; /* Drop off the NULL terminator */
    dstrPubKey.cchString--; /* Drop off the NULL terminator */

    /* add privkey node */
    CallXmlBuilder( pbXmlContext, DRM_XMB_OpenNode( pbXmlContext, &g_dstrSigningKey ) );
    CallXmlBuilder( pbXmlContext, DRM_XMB_AddData( pbXmlContext, ( DRM_CONST_STRING * ) &dstrPrivKey ) );
    CallXmlBuilder( pbXmlContext, DRM_XMB_CloseCurrNode( pbXmlContext, NULL ) );

    /* add pubkey node */
    CallXmlBuilder( pbXmlContext, DRM_XMB_OpenNode( pbXmlContext, &g_dstrVerifyKey ) );
    CallXmlBuilder( pbXmlContext, DRM_XMB_AddData( pbXmlContext, ( DRM_CONST_STRING * ) &dstrPubKey ) );
    CallXmlBuilder( pbXmlContext, DRM_XMB_CloseCurrNode( pbXmlContext, NULL ) );

    /* add LaUrl node */
    CallXmlBuilder( pbXmlContext, DRM_XMB_OpenNode( pbXmlContext, &g_dstrTagURLLicAcq ) );
    CallXmlBuilder( pbXmlContext, DRM_XMB_AddData( pbXmlContext, f_pdstrLAURL ) );
    CallXmlBuilder( pbXmlContext, DRM_XMB_CloseCurrNode( pbXmlContext, NULL ) );

    /* add blocksize node */
    CallXmlBuilder( pbXmlContext, DRM_XMB_OpenNode( pbXmlContext, &g_dstrEncBlkSize ) );
    CallXmlBuilder( pbXmlContext, DRM_XMB_AddData( pbXmlContext, f_pdstrBlockSize ) );
    CallXmlBuilder( pbXmlContext, DRM_XMB_CloseCurrNode( pbXmlContext, NULL ) );

    /* close the root node */
    CallXmlBuilder( pbXmlContext, DRM_XMB_CloseDocument( pbXmlContext, &dstrXML ) );

    /* write to file */
    ChkMem(pwszFile = ( DRM_WCHAR * ) OEM_malloc(CB_DSTR(f_pdstrFileName) + SIZEOF (DRM_WCHAR)));
    ZEROMEM(pwszFile, CB_DSTR(f_pdstrFileName) + SIZEOF (DRM_WCHAR));
    MEMCPY( pwszFile, f_pdstrFileName->pwszString, CB_DSTR(f_pdstrFileName));
    fp = OEM_OpenFile( pwszFile,
                       OEM_GENERIC_READ    | OEM_GENERIC_WRITE,
                       OEM_FILE_SHARE_READ | OEM_FILE_SHARE_WRITE,
                       OEM_CREATE_ALWAYS,
                       OEM_ATTRIBUTE_NORMAL );
    if ( fp == OEM_INVALID_HANDLE_VALUE )
    {
        ChkDR( DRM_E_FILEWRITEERROR );
    }

    if (! OEM_WriteFile( fp, (DRM_BYTE*)g_rgbFFFE, SIZEOF(g_rgbFFFE), &dwNumberOfBytesWritten ) 
    ||  dwNumberOfBytesWritten != SIZEOF(g_rgbFFFE))
    {
        ChkDR( DRM_E_FILEWRITEERROR );
    }

    if (! OEM_WriteFile( fp, dstrXML.pwszString, CB_DSTR(&dstrXML), &dwNumberOfBytesWritten ) 
    ||  dwNumberOfBytesWritten != CB_DSTR(&dstrXML))
    {
        ChkDR( DRM_E_FILEWRITEERROR );
    }

    OEM_CloseFile( fp );

    ErrorExit:
    if ( pwszFile )
    {
        OEM_free( pwszFile );
    }
    if ( pCrypto )
    {
        OEM_free( pCrypto );
    }
    if ( dstrPrivKey.pwszString )
    {
        OEM_free( dstrPrivKey.pwszString );
    }
    if ( dstrPubKey.pwszString )
    {
        OEM_free( dstrPubKey.pwszString );
    }
    if ( dstrKeySeed.pwszString )
    {
        OEM_free( dstrKeySeed.pwszString );
    }
    if ( pbXmlContext )
    {
        OEM_free( pbXmlContext );
    }

    if ( DRM_FAILED( dr ) )
    {
        printf( "Failed: 0x%X\n", dr );
    }

    return dr;
}

/*
** syntax: PkgInit <LicAcqURL> <EncryptBlockSize>
*/
static void _DoSyntax ()
{
    printf( "usage: PackageInit [-?] -u:LicenseAcqURL [-b:BlockSize] -d:DataFile\n" );
}

/*
**
*/
static DRM_RESULT Dispatch ( DRM_INT argc,
                             DRM_WCHAR *argv[] )
{
    DRM_RESULT          dr              = DRM_SUCCESS;
    DRM_INT             i               = 0;
    DRM_CONST_STRING    dstrURL         = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrParam       = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrBlocksize   = g_dstrDefaultBlksize;
    DRM_CONST_STRING    dstrFilename    = EMPTY_DRM_STRING;

    if ( argc == 1 )
    {
        goto ShowMenu;
    }

    for ( i = 1; i < argc; i++ )
    {
        DRM_WCHAR wchOption;
        if ( !DRM_CMD_ParseCmdLine( argv[i], &wchOption, &dstrParam, NULL ) )
        {
            goto ShowMenu;
        }
        wchOption = towlower( wchOption );
        switch( wchOption )
        {
        case WCHAR_CAST('u'):
            dstrURL = dstrParam;
            break;
        case WCHAR_CAST('b') :
        {
            DRM_LONG dwBlocksize = 0;
            wcsntol( dstrParam.pwszString, dstrParam.cchString, &dwBlocksize );
            if ( dwBlocksize == 0 )
            {
                goto ShowMenu;
            }

            dstrBlocksize = dstrParam;
            break;
        }
        case WCHAR_CAST('d'):
            dstrFilename = dstrParam;
            break;
        case WCHAR_CAST('?'):
        default:
            goto ShowMenu;
        }
    }
    if( dstrFilename.cchString == 0
     || dstrURL     .cchString == 0 )
    {
        goto ShowMenu;
    }

    ChkDR( _GenInitFile( &dstrURL, &dstrBlocksize, &dstrFilename ) );
    goto ErrorExit;

ShowMenu:
    _DoSyntax();

ErrorExit:
    if ( DRM_FAILED( dr ) )
    {
        printf( "\n\tFailed to generate Init file.\n\tError: 0x%08X\n", dr );
    }

    return dr;
}


/*
**
*/
DRM_VOID DRM_API wmain ( DRM_INT argc,
                         DRM_WCHAR *argv[] )
{
    printf( "Microsoft (R) Package Initializer version %d.%d\n", _majorVersion, _minorVersion );
    printf( "Copyright (C) Microsoft Corporation. All rights reserved.\n\n" );
    Dispatch( argc, argv );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\rc4.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmrc4.h>


/******************************************************************************/
DRM_VOID DRM_API DRM_RC4_KeySetup(
        OUT   RC4_KEYSTRUCT  *pKS,
    IN        DRM_DWORD       cbKey,
    IN  const DRM_BYTE       *pbKey )
{
    DRM_BYTE j;
    DRM_BYTE k;
    DRM_BYTE t;
    DRM_INT  i;

    for (i=0;i<RC4_TABLESIZE;i++)
    {
        PUT_BYTE( pKS->S, i, (DRM_BYTE)i);
    }
    
    pKS->i = 0;
    pKS->j = 0;
    j      = 0;
    k      = 0;
    for (i=0;i<RC4_TABLESIZE;i++)
    {
        t = GET_BYTE(pKS->S,i);
        j = (DRM_BYTE)((j + t + GET_BYTE(pbKey, k)) % RC4_TABLESIZE);        
        PUT_BYTE( pKS->S, i, GET_BYTE(pKS->S, j) );
        PUT_BYTE(pKS->S, j, t);
        k = (DRM_BYTE) ((k + 1) % cbKey);
    }
}

/******************************************************************************/
DRM_VOID DRM_API DRM_RC4_Cipher(
    IN OUT RC4_KEYSTRUCT *pKS,
    IN     DRM_UINT       cbBuffer,
    IN OUT DRM_BYTE      *pbBuffer )
{
    DRM_BYTE  i = pKS->i;
    DRM_BYTE  j = pKS->j;    
    DRM_BYTE *p = pKS->S;
    DRM_DWORD ib = 0;

    while (cbBuffer--)
    {
        DRM_BYTE bTemp1 = 0;
        DRM_BYTE bTemp2 = 0;

        i = ((i + 1) & (RC4_TABLESIZE - 1));
        bTemp1 = GET_BYTE(p,i);
        j = ((j + bTemp1) & (RC4_TABLESIZE - 1));
        
        PUT_BYTE(p,i,GET_BYTE(p,j));
        PUT_BYTE(p,j,bTemp1);
        bTemp2 = GET_BYTE(pbBuffer,ib);

        bTemp2 ^= GET_BYTE(p, (GET_BYTE(p,i) + bTemp1) & (RC4_TABLESIZE - 1));
        PUT_BYTE(pbBuffer,ib,bTemp2);
        ib++;
    }

    pKS->i = i;
    pKS->j = j;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\rsaimpl.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include "rsaimpl.h"
/*
       File rsapimpl.c .  Version 12 October 2002

       This file has bignum interfaces
       unique to Microsoft's impl operating system.

       The main objective is to provide RSA support
       (encryption, decryption, key generation).
       The implementation uses the CRT to speed RSA decryption
       but avoids marginal optimizations which would
       significantly lengthen this open-source code.

       A separate file has impl interfaces needed
       by bignum, such as heap allocation and
       secure random number generation.
*/

/**********************************************************************
**
** Function:    big_endian_bytes_to_digits
**
** Synopsis:    Copy a big-endian DRM_BYTE array to a digit_t array.
**
** Arguments:   [barray]  - input array of DRM_BYTEs
**              [bitlen]  - length of array in bits
**              [darray]  - output array of digit_ts
**
** Returns:     TRUE  on success
**              FALSE on error
**
**********************************************************************/
DRM_BOOL big_endian_bytes_to_digits
        (   const DRM_BYTE  *barray,    /* IN */
            DWORDREGC       bitlen,     /* IN */
            digit_t         *darray)    /* OUT */
{
    DWORDREGC diglen = BITS_TO_DIGITS(bitlen);
    DWORDREG ibyte, idig;
    DRM_BOOL OK = TRUE;

    if (bitlen == 0)
    {
        return OK;
    }

    if (   NULL == barray 
        || NULL == darray)
    {
      TRACE(("NULL == barray || NULL == darray (%s:%d)\n", __FILE__, __LINE__));
        return FALSE;
    }

    mp_clear(darray, diglen, NULL);

    for (idig = 0; idig != diglen; idig++)
    {
        DWORDREGC bytremain = (bitlen + 7)/8 - RADIX_BYTES*idig;
        digit_t dvalue = 0;
        for (ibyte = 0; ibyte != MIN(RADIX_BYTES, bytremain); ibyte++)
        {
            dvalue ^= (digit_t)GET_BYTE(barray, bytremain - 1 - ibyte) << (8*ibyte);
        }
        darray[idig] = dvalue;
    } /* for idig */

    /* Strip high bits */
    darray[diglen-1] &= RADIXM1 >> (RADIX_BITS*diglen - bitlen);

    return OK;
} /* end big_endian_bytes_to_digits */


/**********************************************************************
**
** Function:    little_endian_bytes_to_digits
**
** Synopsis:    Copy a little-endian DRM_BYTE array to a digit_t array.
**
** Arguments:   [barray]  - input array of DRM_BYTEs
**              [bitlen]  - length of array in bits
**              [darray]  - output array of digit_ts
**
**
** Returns:     TRUE  on success
**              FALSE on error
**
**********************************************************************/
DRM_BOOL little_endian_bytes_to_digits
        (   const DRM_BYTE *barray,     /* IN */
            DWORDREGC       bitlen,     /* IN */
            digit_t         *darray)    /* OUT */
{
    DWORDREGC diglen = BITS_TO_DIGITS(bitlen);
    DWORDREG ibyte, idig;
    DRM_BOOL OK = TRUE;

    if (bitlen == 0)
    {
        return OK;
    }

    if (   NULL == barray 
        || NULL == darray)
    {
        return FALSE;
    }

    mp_clear(darray, diglen, NULL);

    for (idig = 0; idig != diglen; idig++)
    {
        DWORDREGC bytremain = (bitlen + 7)/8 - RADIX_BYTES*idig;
        digit_t dvalue = 0;
        for (ibyte = 0; ibyte != MIN(RADIX_BYTES, bytremain); ibyte++)
        {
            dvalue ^= (digit_t)GET_BYTE(barray, idig*RADIX_BYTES + ibyte) << (8*ibyte);
        }
        darray[idig] = dvalue;
    } /* for idig */


    /* Strip high bits */
    darray[diglen-1] &= RADIXM1 >> (RADIX_BITS*diglen - bitlen);

    return OK;
} /* end little_endian_bytes_to_digits */


/**********************************************************************
**
** Function:    digits_to_big_endian_bytes
**
** Synopsis:    Convert digit_t array to bytes, putting most significant byte first.
**
** Arguments:   [darray]  - input array of digit_ts
**              [bitlen]  - length of array in bits
**              [barray]  - output array of DRM_BYTEs
**
** Returns:     TRUE  on success
**              FALSE on error
**
**********************************************************************/
DRM_BOOL digits_to_big_endian_bytes
       (digit_tc    *darray,   /* IN */
        DWORDREGC    bitlen,   /* IN */
        DRM_BYTE    *barray)   /* OUT */
{
    DWORDREG ibyte, idig;
    DRM_BOOL OK = TRUE;

    if (   NULL == barray 
        || NULL == darray)
    {
        return FALSE;
    }

    for (idig = 0; idig != BITS_TO_DIGITS(bitlen); idig++)
    {
        digit_t dvalue = darray[idig];
        DWORDREGC bytremain = (bitlen + 7)/8 - RADIX_BYTES*idig;
        for (ibyte = 0; ibyte != MIN(bytremain, RADIX_BYTES); ibyte++)
        {
            PUT_BYTE(barray, bytremain - 1 - ibyte, (DRM_BYTE)(dvalue & 0xff));
            dvalue >>= 8;
        }
    } /* for idig */

    return OK;
} /* end digits_to_big_endian_bytes */


/**********************************************************************
**
** Function:    digits_to_little_endian_bytes
**
** Synopsis:    Convert digit_t array to bytes, putting least significant byte first.
**
** Arguments:   [darray]  - input array of digit_ts
**              [bitlen]  - length of array in bits
**              [barray]  - output array of DRM_BYTEs
**
**
** Returns:     TRUE  on success
**              FALSE on error
**
**********************************************************************/
DRM_BOOL digits_to_little_endian_bytes
       (digit_tc    *darray,    /* IN */
        DWORDREGC   bitlen,     /* IN */
        DRM_BYTE    *barray)    /* OUT */
{
    DWORDREG ibyte, idig;
    DRM_BOOL OK = TRUE;

    if (   NULL == barray 
        || NULL == darray)
    {
        return FALSE;
    }

    for (idig = 0; idig != BITS_TO_DIGITS(bitlen); idig++)
    {
        digit_t dvalue = darray[idig];
        DWORDREGC bytremain = (bitlen + 7)/8 - RADIX_BYTES*idig;
        for (ibyte = 0; ibyte != MIN(bytremain, RADIX_BYTES); ibyte++)
        {
            PUT_BYTE(barray, RADIX_BYTES*idig + ibyte, (DRM_BYTE)(dvalue & 0xff));
            dvalue >>= 8;
        }
    } /* for idig */
    return OK;
} /* end digits_to_little_endian_bytes */

/**********************************************************************
**
** Function:    rsa_key_internalize
**
** Synopsis:    Creates an internal (public) key based upon an existing 
**              external (private) key
**
** Arguments:   [prsaext]  - input pointer to an existing external key
**              [prsaint]  - output pointer to corresponding internal 
**                           key
**
**
** Returns:     TRUE on success
**              FALSE on error
**
**********************************************************************/
DRM_BOOL rsa_key_internalize(
            const external_rsa_key_t  *prsaext,    /* IN */
            internal_rsa_key_t        *prsaint)    /* OUT */
{
    DRM_BOOL OK = TRUE;

    if (   NULL == prsaext 
        || NULL == prsaint)
    {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "rsa_key_internalize", NULL);
        /* Should check here that prsaext is really an external private key. */
    } 
    else
    {
        DWORDREGC diglen_pubexp = BITS_TO_DIGITS(prsaext->bitlen_pubexp);
        DWORDREGC diglen_p1 = BITS_TO_DIGITS(prsaext->bitlen_primes[0]);
        DWORDREGC diglen_p2 = BITS_TO_DIGITS(prsaext->bitlen_primes[1]);
        DWORDREGC diglen_p12 = diglen_p1 + diglen_p2;

        /* TBD Perhaps create_modulus should let the application supply its temporaries. */
        /* Then there will be a single heap allocation per internal_rsa_key_t, */
        /* not three smaller ones. */
        digit_t *dtemps = digit_allocate(3*diglen_p12 + diglen_pubexp,
                                         "rsa_key_internalize", NULL);
        if (dtemps == digit_NULL)
        {
            OK = FALSE;
        }

        if (OK)
        {
            digit_t *temp1 = dtemps;    /* Overlaps modulus */
            DWORDREG ip, moduli_created = 0;

            prsaint->bitlen_modulus = prsaext->bitlen_modulus;
            prsaint->diglen_pubexp = (DRM_DWORD)diglen_pubexp;
            prsaint->free_me = dtemps;
            prsaint->modulus = dtemps;
            prsaint->pubexp = dtemps + 3*diglen_p12;
            OK = OK && big_endian_bytes_to_digits(prsaext->pubexp,
                                    prsaext->bitlen_pubexp, prsaint->pubexp);
            for (ip = 0; ip != 2; ip++)
            {
                digit_t *temp1 = prsaint->modulus;
                DWORDC bitlen_p = prsaext->bitlen_primes[ip];

                prsaint->privexps[ip] = dtemps + diglen_p12 + ip*diglen_p1;
                prsaint->chineses[ip] = prsaint->privexps[ip] + diglen_p12;

                OK = OK && big_endian_bytes_to_digits(prsaext->primes[ip],
                                            bitlen_p, temp1);
                OK = OK && create_modulus(temp1,
                               BITS_TO_DIGITS(prsaext->bitlen_primes[ip]),
                               FROM_RIGHT, &prsaint->moduli[ip], NULL, NULL);
                if (OK)
                {
                    moduli_created++;
                }

                OK = OK && big_endian_bytes_to_digits(prsaext->privexps[ip],
                                            bitlen_p, prsaint->privexps[ip]);
            } /* for ip */

            if (OK)
            {
                DWORDREG lgcd = 0;
                OK = OK && mp_gcdex(prsaint->moduli[0].modulus, diglen_p1,
                                    prsaint->moduli[1].modulus, diglen_p2,
                                    prsaint->chineses[1], prsaint->chineses[0],
                                    temp1, digit_NULL, &lgcd, digit_NULL, NULL);
                if (OK && compare_immediate(temp1, 1, lgcd) != 0)
                {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "rsa_key_internalize, GCD(p1, p2) <> 1", NULL);
                }

                mp_clear(prsaint->modulus, diglen_p12, NULL);

                /* Possibly insert leading zero */
                OK = OK && big_endian_bytes_to_digits(prsaext->modulus,
                                                      prsaext->bitlen_modulus,
                                                      prsaint->modulus);
            }
            while (!OK && moduli_created != 0)
            {
                moduli_created--;
                uncreate_modulus(&prsaint->moduli[moduli_created], NULL);
            }
        } /* if */

        if (!OK && dtemps != digit_NULL)
        {
            Free_Temporaries(dtemps, NULL);
        }
    } /* if */
    return OK;
} /* rsa_key_internalize */


/**********************************************************************
**
** Function:    RSA_Encrypt
**
** Synopsis:    Encrypts a buffer of plain text using an external key
**
** Arguments:   [pRSAkey]            - pointer to external (public) key
**              [pbPlainText]        - pointer to buffer holding the plaintext
**                                     plaintext must be smaller than modulus
**              [nPlainTextLength]   - length of plaintext
**              [pbCipherText]       - output buffer containing ciphertext
**              [pcCipherTextLength] - length of output buffer
**
** Returns:     none
**
**********************************************************************/
DRM_VOID 
RSA_Encrypt(
    IN external_rsa_key_t* pRSAkey,
    IN DRM_BYTE* pbPlainText,
    IN DRM_DWORD nPlainTextLength,
    OUT DRM_BYTE* pbCipherText,
    IN OUT DRM_DWORD* pcCipherTextLength
    )
{
    DRM_BOOL status = 0;

    if (   NULL == pRSAkey 
        || NULL == pbPlainText
        || NULL == pbCipherText
        || NULL == pcCipherTextLength)
    {
        return;
    }

    if (nPlainTextLength && pcCipherTextLength)
    {
        status = rsa_encryption(pRSAkey, pbPlainText, pbCipherText);
    }
}


/**********************************************************************
**
** Function:    rsa_encryption
**
** Synopsis:    Encrypt msgin -> msgout, using the RSA public key in prsaext
**              This funtion is an intermediate to RSA_Encrypt 
**
** Arguments:   [prsaext]   - pointer to external rsa key
**              [msgin]     - input buffer
**              [msgout]    - ouput buffer
**
** Returns:     TRUE on success
**              FALSE on error
**
**********************************************************************/
DRM_BOOL rsa_encryption
       (const external_rsa_key_t    *prsaext,   /* IN */
        const DRM_BYTE              *msgin,     /* IN */
                                                /*     prsaext->bitlen_modulus bits */
        DRM_BYTE                    *msgout)    /* OUT */
/*
     This code encrypts msgin, using the RSA public key in prsaext.
     The output is stored in msgout.
     msgin and msgout are big-endian DRM_BYTE arrays.
*/
{
    DRM_BOOL OK = TRUE;
    digit_t *dtemps = digit_NULL;
    DWORDREG bitlen_pubexp = 0, bitlen_mod = 0;
    DWORDREG diglen_pubexp = 0, diglen_mod = 0;

    if (   NULL == prsaext
        || NULL == msgin
        || NULL == msgout)
    {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "rsa_encryption", NULL);

    /* Do other validation checks here */
    } else {
        bitlen_pubexp = prsaext->bitlen_pubexp;
        bitlen_mod    = prsaext->bitlen_modulus;
        diglen_pubexp = BITS_TO_DIGITS(bitlen_pubexp);
        diglen_mod    = BITS_TO_DIGITS(bitlen_mod);

        dtemps = digit_allocate(diglen_mod + diglen_pubexp, "rsa_encryption", NULL);
        if (dtemps == digit_NULL) OK = FALSE;
    }
    if (OK)
    {
        digit_t *dmsg        =  dtemps;              /* Length diglen_mod */
        digit_t *dexponent   =  dtemps + diglen_mod; /* Length diglen_pubexp */
        DRM_BOOL modulus_created;
        mp_modulus_t modulo;

        OK = OK && big_endian_bytes_to_digits(prsaext->modulus,
                                              bitlen_mod, dmsg);
	if(!OK) TRACE(("big_endian_bytes_to_digits 1 failed (mp_errno = %d)\n", GetMpErrno(NULL))) ;
	
        OK = OK && create_modulus(dmsg, diglen_mod, FROM_RIGHT, &modulo, NULL, NULL);
	if(!OK) TRACE(("create_modulus failed (mp_errno = %d)\n", GetMpErrno(NULL))) ;
        modulus_created = OK;

        OK = OK && big_endian_bytes_to_digits(prsaext->pubexp,
                                              bitlen_pubexp, dexponent);
	if(!OK) TRACE(("big_endian_bytes_to_digits 2 failed (mp_errno = %d)\n", GetMpErrno(NULL))) ;

        OK = OK && big_endian_bytes_to_digits(msgin, bitlen_mod, dmsg);
	if(!OK) TRACE(("big_endian_bytes_to_digits 3 failed (mp_errno = %d)\n", GetMpErrno(NULL))) ;
        OK = OK && to_modular(dmsg, diglen_mod, dmsg, &modulo, NULL);
	if(!OK) TRACE(("to_modular failed (mp_errno = %d)\n", GetMpErrno(NULL))) ;
        OK = OK && mod_exp(dmsg, dexponent, diglen_pubexp, dmsg, &modulo, NULL);
	if(!OK) TRACE(("mod_exp failed (mp_errno = %d)\n", GetMpErrno(NULL))) ;
        OK = OK && from_modular(dmsg, dmsg, &modulo, NULL);
	if(!OK) TRACE(("from_modular failed (mp_errno = %d)\n", GetMpErrno(NULL))) ;

        OK = OK && digits_to_big_endian_bytes(dmsg, bitlen_mod, msgout);
	if(!OK) TRACE(("digits_to_big_endian_bytes failed (mp_errno = %d)\n", GetMpErrno(NULL))) ;
        if (modulus_created)
        {
            uncreate_modulus(&modulo, NULL);
        }
    }

    if (dtemps != digit_NULL)
    {
        Free_Temporaries(dtemps, NULL);
    }

    return OK;
} /* rsa_encryption */


/**********************************************************************
**
** Function:    RSA_Decrypt
**
** Synopsis:    Decrypts a ciphertext buffer using an internal key
**
** Arguments:   [pRSAkey]               - pointer to the internal key
**              [pbCipherText]          - pointer to the input buffer with the ciphertext
**              [nCipherTextLength]     - length of the ciphertext
**              [pbDecryptedData]       - pointer to the output plaintext
**              [pcDecryptedDataLength] - length of the plaintext
**
** Returns:     none
**
**********************************************************************/
DRM_VOID 
RSA_Decrypt(
    IN external_rsa_key_t* pRSAkey,
    IN DRM_BYTE* pbCipherText,
    IN DRM_DWORD nCipherTextLength,
    OUT DRM_BYTE* pbDecryptedData,
    IN OUT DRM_DWORD* pcDecryptedDataLength
    )
{
    DRM_BOOL status = 0;
    internal_rsa_key_t pRSAKey_internal;

    if (   NULL == pRSAkey
        || NULL == pbCipherText
        || NULL == pbDecryptedData
        || NULL == pcDecryptedDataLength)
    {
        return;
    }

    status = rsa_key_internalize(pRSAkey, &pRSAKey_internal);

    if (status && (nCipherTextLength && pcDecryptedDataLength))
    {
        status = rsa_decryption(&pRSAKey_internal, pbCipherText, pbDecryptedData);
    }
}


/**********************************************************************
**
** Function:    rsa_decryption
**
** Synopsis:    Decrypt msgin -> msgout, using the RSA public key in prsaext
**              This funtion is an intermediate to RSA_Decrypt 
**
** Arguments:   [prsaint]   - pointer to internal key
**              [msgin]     - input buffer with the ciphertext
**              [msgout]    - output buffer with the plaintext
**
**
** Returns:     TRUE on success
**              FALSE on error
**
**********************************************************************/
DRM_BOOL rsa_decryption
       (const internal_rsa_key_t    *prsaint,   /* IN/OUT */
        const DRM_BYTE              *msgin,     /* IN, length */
                                                /*    prsaext->bitlen_modulus bits */
        DRM_BYTE                    *msgout)    /* OUT */
{
/*
     This code decrypts msgin, using the RSA private key in prsaint.
     The output is stored in msgout.
     msgin and msgout are big-endian DRM_BYTE arrays.

     Using the Chinese Remainder Theorem, we reduce the original message
     (copied into dmsg[1]) modulo the two private primes p1 and p2, getting
     remainders in1 and in2 (say).  Form out1 = in1^(private exponent 1) mod p1
     and out2 == in2^(private exponent 2) mod p2.
     The desired output will have remainder out1 modulo p1 and out2 modulo p2.
     Such a result is p2*(out1/p2 mod p1) + p1*(out2/p1 mod p2).
     The final sum (of dmsg[0] and dmsg[1]) is done modulo p1*p2 = modulus.
*/
    DRM_BOOL OK = TRUE;

    if (   NULL == prsaint
        || NULL == msgin
        || NULL == msgout)
    {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "rsa_decryption", NULL);

    /* Do other validation checks here, */
    /* such as ensuring we have private (not public) key */
    }
    else
    {
        digit_t dtemps[82];
        mp_modulus_tc *moduli = prsaint->moduli;    /* Shorthand */
        DWORDREGC diglen_modulus = BITS_TO_DIGITS(prsaint->bitlen_modulus);

        if (moduli[0].length + moduli[1].length - diglen_modulus > 1)
        {
            /* N.B. Unsigned compare */
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA, "rsa_decryption", NULL);
        }

        if (OK)
        {
            DWORDREG ip;
            digit_t *dmsg[2];
            digit_t *res = &dtemps[2*(diglen_modulus + 1)];
            /* Length diglen_plonger; */
            dmsg[0] = &dtemps[0];
            dmsg[1] = &dtemps[diglen_modulus + 1];

            OK = OK && big_endian_bytes_to_digits(msgin,
                                    prsaint->bitlen_modulus, dmsg[1]);
            for (ip = 0; OK && ip != 2; ip++)
            {
                OK = OK && to_modular(dmsg[1], diglen_modulus, res, &moduli[ip], NULL)
                        && mod_exp(res, prsaint->privexps[ip],
                                   moduli[ip].length, res, &moduli[ip], NULL)
                        && mod_mul(res, prsaint->chineses[ip], res,
                                   &moduli[ip], digit_NULL, NULL)

                        /* N.B.  from_modular call omitted since chineses[ip] lacks FROM_RIGHT scaling, */
                        && multiply(res, moduli[ip].length,
                                    moduli[1-ip].modulus,
                                    moduli[1-ip].length, dmsg[ip], NULL);
            } /* for ip */
            OK = OK && add_mod(dmsg[0], dmsg[1], dmsg[0],
                               prsaint->modulus, diglen_modulus, NULL)
                    && digits_to_big_endian_bytes(dmsg[0],
                                          prsaint->bitlen_modulus, msgout);
        } /* if */
    }

    return OK;
} /* end rsa_decryption */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\player.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <stdio.h>


#if EMBEDDED_WITH_NO_PARAMS

DRM_INT   g_argc = 4;

/* player.exe */
DRM_WCHAR g_Arg1[] = { TWO_BYTES('p', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('y', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('\0', '\0')};

/* 1k1s.pkg */
DRM_WCHAR g_Arg2[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('w', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('1', '\0'),  TWO_BYTES('k', '\0'),  TWO_BYTES('1', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('p', '\0'), TWO_BYTES('k', '\0'),  TWO_BYTES('g', '\0'),  TWO_BYTES('\0', '\0')};

/* 1k1s.out */
DRM_WCHAR g_Arg3[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('w', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('1', '\0'),  TWO_BYTES('k', '\0'),  TWO_BYTES('1', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('o', '\0'), TWO_BYTES('u', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('\0', '\0')};

/* sample.hds */
DRM_WCHAR g_Arg4[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('w', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('e', '\0'), TWO_BYTES('.', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\0', '\0')};
DRM_WCHAR *g_argv[] = { g_Arg1, g_Arg2, g_Arg3, g_Arg4 };
#endif


DRM_RESULT PrintLicenseStateData( DRM_CHAR* szOutputPrefix, DRM_LICENSE_STATE_DATA* pDRMLicenseStateData )
{
    DRM_RESULT hr = DRM_SUCCESS;
    DRM_DWORD dwCountIndex;
    DRM_DWORD dwDateIndex;
    
    do
    {
        /* */
        /* Print the type of right given by aggregating all the licenses for the content */
        /* */
        printf( ( "%sDRM_LICENSE_DATA.dwStreamId: %ld\n" ), szOutputPrefix, pDRMLicenseStateData->dwStreamId );
        switch( pDRMLicenseStateData->dwCategory )
        {
        case WM_DRM_LICENSE_STATE_NORIGHT: /* No rights to perform this action */
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: WM_DRM_LICENSE_STATE_NORIGHT\n" ), szOutputPrefix );
            break;
    
        case WM_DRM_LICENSE_STATE_UNLIM: /* Unlimited rights to perform this action */
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: WM_DRM_LICENSE_STATE_UNLIM\n" ), szOutputPrefix );
            break;
    
        case WM_DRM_LICENSE_STATE_COUNT: /* Action may only be performed a certain number of times */
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: WM_DRM_LICENSE_STATE_COUNT\n" ), szOutputPrefix );
            break;
    
        case WM_DRM_LICENSE_STATE_FROM: /* Action cannot be performed until a specific date */
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: WM_DRM_LICENSE_STATE_FROM\n" ), szOutputPrefix );
            break;
    
        case WM_DRM_LICENSE_STATE_UNTIL: /* Action cannot be performed after a certain date */
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: WM_DRM_LICENSE_STATE_UNTIL\n" ), szOutputPrefix );
            break;
    
        case WM_DRM_LICENSE_STATE_FROM_UNTIL: /* Action can only be performed within a specific range of dates */
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: WM_DRM_LICENSE_STATE_FROM_UNTIL\n" ), szOutputPrefix );
            break;
    
        case WM_DRM_LICENSE_STATE_COUNT_FROM: /* Action can only be performed a certain number of times, starting from a specific date */
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: WM_DRM_LICENSE_STATE_COUNT_FROM\n" ), szOutputPrefix );
            break;
    
        case WM_DRM_LICENSE_STATE_COUNT_UNTIL: /* Action can be performed a certain number of times until a specific date */
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: WM_DRM_LICENSE_STATE_COUNT_UNTIL\n" ), szOutputPrefix );
            break;
    
        case WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL: /* Action can only be performed a certain number of times, and only is a specific range of dates */
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL\n" ), szOutputPrefix );
            break;
    
        case WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE: /* License restrictions don't occur until after the first use */
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE\n" ), szOutputPrefix );
            break;
            
        default:
            printf( ( "%sDRM_LICENSE_DATA.dwCategory: Unknown! - %d\n" ), szOutputPrefix, pDRMLicenseStateData->dwCategory );
        }
        
        /* */
        /* If count limited, print the number of times the action can be performed */
        /* */
        if ( 0 != pDRMLicenseStateData->dwNumCounts )
        {
            printf( ( "%sDRM_LICENSE_DATA.dwCount:" ), szOutputPrefix );
            for( dwCountIndex = 0; dwCountIndex < pDRMLicenseStateData->dwNumCounts; dwCountIndex++ )
            {
                printf( ( "  %ld" ), pDRMLicenseStateData->dwCount[ dwCountIndex ] );
            }
            printf( ( "\n" ) );
        }
        
        /* */
        /* If the action is date limited, print the date restriction(s) */
        /* */
        if ( 0 != pDRMLicenseStateData->dwNumDates )
        {
            printf( ( "%sDRM_LICENSE_DATA.datetime:" ), szOutputPrefix );
            for( dwDateIndex = 0; dwDateIndex < pDRMLicenseStateData->dwNumDates; dwDateIndex++ )
            {
                DRMSYSTEMTIME  st;
                OEM_FileTimeToSystemTime( &(pDRMLicenseStateData->datetime[ dwDateIndex ]), &st );
                printf( ( "  On %04d/%02d/%02d at %02d:%02d:%02d.%03d" ), st.wYear,
                    st.wMonth,
                    st.wDay,
                    st.wHour,
                    st.wMinute,
                    st.wSecond,
                    st.wMilliseconds);
            }
            printf( ( "\n" ) );
        }
        
        /* */
        /* If the aggregate license data cannot easily be represented, the "vague" value will be set. */
        /* This will happen when two or more licenses with different right types (like COUNT and */
        /* and FROM_UNTIL) make it impossible to represent the information simply.  For instance, */
        /* if license 1 allows 5 plays and license 2 allows unlimited playback during the current */
        /* month, then the user is guaranteed at least 5 plays, but possibly an unlimited number, */
        /* if done within the current month. */
        /* */
        printf( ( "%sDRM_LICENSE_DATA.dwVague: %ld \n" ), szOutputPrefix, pDRMLicenseStateData->dwVague );
    }
    while ( FALSE );
    
    return hr;
}

/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
DoPlay (DRM_CONST_STRING *pdstrContentFilename, 
        DRM_CONST_STRING *pdstrOutputFileName, 
        DRM_CONST_STRING *pdstrDataStoreFile)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dw;
    const DRM_CONST_STRING    *apdcsRights [1];
    DRM_MANAGER_CONTEXT *poManagerContext = NULL;
    DRM_MANAGER_DECRYPT_CONTEXT oDecryptContext;
    const DRM_CONST_STRING *proparray[] = { &g_dstrWMDRM_RIGHT_PLAYBACK };
    DRM_LICENSE_STATE_DATA statedatavales[NO_OF(proparray)];
    DRM_DWORD cbChunk = 0,
              cbXML   = 0, 
              cbFile  = 0;
    DRM_BYTE *pbXML   = NULL;
    DRM_BYTE *pbChunk = NULL;
    OEM_FILEHDL Infp  = OEM_INVALID_HANDLE_VALUE;
    OEM_FILEHDL Outfp = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD cbRead  = 0;
    DRM_WCHAR *pszFile= NULL;
    DRM_BYTE  *pbRevocationBuffer = NULL;

    ChkMem (poManagerContext = OEM_malloc( SIZEOF(DRM_MANAGER_CONTEXT) ) );
    ZEROMEM(poManagerContext, SIZEOF (DRM_MANAGER_CONTEXT));

    pszFile= (DRM_WCHAR *) poManagerContext;
    
    wcsncpy (pszFile, 
	         pdstrContentFilename->pwszString, 
             pdstrContentFilename->cchString );
    pszFile [pdstrContentFilename->cchString] = (DRM_WCHAR) '\0';
    
    Infp = OEM_OpenFile (pszFile, 
                         OEM_GENERIC_READ, 
                         OEM_FILE_SHARE_READ, 
                         OEM_OPEN_EXISTING, 
                         OEM_ATTRIBUTE_NORMAL);

    if (OEM_INVALID_HANDLE_VALUE == Infp)
    {
        printf( "Input file not opened\n" );
        goto ErrorExit;
    }

    wcsncpy (pszFile, pdstrOutputFileName->pwszString, pdstrOutputFileName->cchString);
    pszFile [pdstrOutputFileName->cchString] = (DRM_WCHAR) '\0';
    
    Outfp = OEM_OpenFile (pszFile, 
                          OEM_GENERIC_WRITE, 
                          OEM_FILE_SHARE_NONE, 
                          OEM_CREATE_ALWAYS, 
                          OEM_ATTRIBUTE_NORMAL);

    if( OEM_INVALID_HANDLE_VALUE == Outfp )
    {
        printf( "Output file not opened\n" );
        goto ErrorExit;
    }

    /* file structure: | cbChunk | cbXML | byte data ... | */

    ChkFAIL (OEM_GetFileSize (Infp, &cbFile));
    ChkFAIL (cbFile >= SIZEOF (cbChunk));
    
    /* get block size */

    if (OEM_ReadFile (Infp, &cbChunk, SIZEOF (cbChunk), &cbRead) == FALSE
    ||  cbRead != (SIZEOF (cbChunk)))
    {
        printf( "Header chunk size could not be read\n");
        goto ErrorExit;
    }
    FIX_ENDIAN_DWORD( cbChunk );
    
    /* get size of XML (bytes) */

    if (OEM_ReadFile (Infp, &cbXML, SIZEOF (cbXML), &cbRead) == FALSE
    ||  cbRead != (SIZEOF (cbXML)))
    {
        printf( "Header XML size could not be read\n");
        goto ErrorExit;
    }
    
    FIX_ENDIAN_DWORD( cbXML );
    
    if (cbXML % SIZEOF (DRM_WCHAR) != 0)
    {
        ChkDR (DRM_E_INVALIDARG);
    }
    
    ChkMem (pbXML   = OEM_malloc (cbXML));
    ChkMem (pbChunk = OEM_malloc (cbChunk));
    
    if (OEM_ReadFile(Infp, pbXML, cbXML, &cbRead) == FALSE
    ||  cbRead != cbXML)
    {
        printf( "Header couldn't be read\n");
        goto ErrorExit;
    }
    
    ChkDR (DRM_MGR_Initialize  (poManagerContext, pdstrDataStoreFile));

#if DRM_SUPPORT_REVOCATION
    ChkMem( pbRevocationBuffer = OEM_malloc( REVOCATION_BUFFER_SIZE ) );
    ChkDR( DRM_MGR_SetRevocationBuffer( poManagerContext, pbRevocationBuffer, REVOCATION_BUFFER_SIZE ) );
    ChkDR( DRM_MGR_UpdateRevocationVersionsCache( poManagerContext, NULL ) );
#endif
    
    ChkDR (DRM_MGR_SetV2Header (poManagerContext, pbXML, cbXML));

    ChkDR( DRM_MGR_GetLicenseData( poManagerContext, proparray, statedatavales, NO_OF( proparray ) ) );

    printf( ( "  Content rights information:\n" ) );

    for( dw = 0; dw < NO_OF( proparray ); dw++ )
    {
        printf( ( "    %ws:\n" ), proparray[dw]->pwszString );
        PrintLicenseStateData( ("      "), &(statedatavales[ dw ]) );
    }

    apdcsRights [0] = (DRM_CONST_STRING *) &g_dstrWMDRM_RIGHT_PLAYBACK;

    dr = DRM_MGR_Bind (poManagerContext, 
                       apdcsRights, 
                NO_OF (apdcsRights), 
                       NULL,
                       NULL,
                      &oDecryptContext );
                          
    if (dr == DRM_E_LICENSENOTFOUND)
    {
       printf( "No licenses found\n");
       goto ErrorExit;
    }
    else if( DRM_FAILED( dr ) )
    {
        printf( "Unexpected failure during bind. 0x%x\n", dr);
        goto ErrorExit;
    }
    /* Decrypt and play content */
    ChkDR( DRM_MGR_Commit( poManagerContext ) );
    if (!OEM_ReadFile(Infp, pbChunk, cbChunk, &dw))
    {
        printf( "Failed to read header 0x%x\n", dr);
        goto ErrorExit;
    }
        
    while( dw > 0 )
    {
        if ( dw < DRM_CPHR_CB_FOR_INITDECRYPT )
        {
            ChkDR( DRM_MGR_InitDecrypt( &oDecryptContext, pbChunk, dw) );      
        }
        else
        {
            DRM_BYTE    rgbLast15[__CB_DECL(DRM_CPHR_CB_FOR_INITDECRYPT)];
            DRM_BYT_CopyBytes( rgbLast15, 
                               0, 
                               pbChunk, 
                               dw - DRM_CPHR_CB_FOR_INITDECRYPT, 
                               DRM_CPHR_CB_FOR_INITDECRYPT );
            ChkDR( DRM_MGR_InitDecrypt( &oDecryptContext, rgbLast15, dw ) ); 
        }

        ChkDR (DRM_MGR_Decrypt (&oDecryptContext, pbChunk, dw));

        if (!OEM_WriteFile(Outfp, pbChunk, dw, &cbRead) || dw!=cbRead)
        {
            printf( "Failed to write header 0x%x\n", dr);
            goto ErrorExit;
        }
            
        if (!OEM_ReadFile(Infp, pbChunk, cbChunk, &dw))
        {
            printf( "Failed to read header 0x%x\n", dr);
            goto ErrorExit;
        }
    }

ErrorExit:
    if (Outfp != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile (Outfp);
    }
    
    if (Infp != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile (Infp);
    }
    
    if (pbChunk != NULL)
    {
        OEM_free (pbChunk);
    }
    
    if (pbXML != NULL)
    {
        OEM_free (pbXML);
    }
    
    if (poManagerContext != NULL)
    {
        DRM_MGR_Uninitialize (poManagerContext);
        OEM_free (poManagerContext);
    }

    SAFE_OEM_FREE( pbRevocationBuffer );
}

/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] -c:ContentFile -o:OutputFile -s:StoreName\n", pwszAppName);
}

/******************************************************************************
** 
*******************************************************************************
*/
DRM_VOID DRM_API wmain( 
    DRM_INT argc, 
    DRM_WCHAR** argv )
{
    DRM_CONST_STRING dstrStoreName   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrContentFile = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrOutputFile  = EMPTY_DRM_STRING;
    DRM_INT i;

    printf( "Microsoft (R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "Sample DRM player application" );

#if EMBEDDED_WITH_NO_PARAMS
    argc = g_argc;
    argv = g_argv;
#endif

    if( argc == 1 || argc > 4 )
    {
        goto _PrintUsage;
    }

    for( i = 1; i<argc; i++ )
    {
        DRM_WCHAR wchOptionChar;
        DRM_CONST_STRING dstrParam;
        if ( !DRM_CMD_ParseCmdLine(argv[i], &wchOptionChar, &dstrParam, NULL) )
        {
            goto _PrintUsage;
        }
        wchOptionChar = towlower( wchOptionChar );
        switch( wchOptionChar )
        {
	    case WCHAR_CAST('c'):  
            dstrContentFile.pwszString = dstrParam.pwszString;
            dstrContentFile.cchString  = dstrParam.cchString;
            break;
        case WCHAR_CAST('o'):  
            dstrOutputFile.pwszString = dstrParam.pwszString;
            dstrOutputFile.cchString  = dstrParam.cchString;
            break;
        case WCHAR_CAST('s'):
            dstrStoreName.pwszString = dstrParam.pwszString;
            dstrStoreName.cchString  = dstrParam.cchString;
            break;
        default:
            goto _PrintUsage;
        }
    }

    if( !dstrContentFile.cchString || !dstrOutputFile.cchString || !dstrStoreName.cchString )
    {
        goto _PrintUsage;
    }

    DoPlay( &dstrContentFile, &dstrOutputFile, &dstrStoreName );
    return;
_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\secureclockgeneratechallenge.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <drmsecureclock.h>
#include <drmsecureclockstatus.h>
#include <stdio.h>


#define EMBEDDED_WITH_NO_PARAMS 0

#if EMBEDDED_WITH_NO_PARAMS

DRM_INT   g_argc = 4;

DRM_WCHAR g_Arg1[] = { TWO_BYTES('s', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('k', '\0'),  TWO_BYTES('g', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('g', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('\0', '\0')};
DRM_WCHAR g_Arg2[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('j', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('\0', '\0')};
DRM_WCHAR g_Arg3[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('j', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\0', '\0')};
DRM_WCHAR g_Arg4[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('j', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('\0', '\0')};
DRM_WCHAR *g_argv[] = { g_Arg1, g_Arg2, g_Arg3, g_Arg4 };
#endif

/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] -l:ChallengeOutputFile -s:DataStoreFile [-u:URLFile]\n", pwszAppName);
}


/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
GenerateChallenge( 
    DRM_CONST_STRING *pwszOutputFileName, 
    DRM_CONST_STRING *f_pdstrFileURL, 
    DRM_CONST_STRING *pwszDataStoreFile)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_MANAGER_CONTEXT *poManagerContext = NULL;
    DRM_DWORD  cchChallenge = 0;
    DRM_DWORD  cchURL       = 0;
    DRM_CHAR  *pszChallenge = NULL;
    DRM_DWORD  cchSecTime   = 0;
    DRM_WCHAR *pwszSecTime  = NULL;
    DRM_BYTE  *pbTimeStatus = NULL;
    DRM_DWORD  cbTimeStatus = 0;
    OEM_FILEHDL Outfp       = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD  iIO          = 0;
    DRM_DWORD  dwFlag       = 0;
    DRM_WCHAR *pwszURL      = NULL;

    ChkMem(poManagerContext = OEM_malloc(SIZEOF (DRM_MANAGER_CONTEXT)));
    ZEROMEM(poManagerContext, SIZEOF (DRM_MANAGER_CONTEXT));

    /* strings from argv's will be NUL-terminated by the runtime */ 

    Outfp = OEM_OpenFile(pwszOutputFileName->pwszString, 
                                  OEM_GENERIC_READ    | OEM_GENERIC_WRITE,
                                  OEM_FILE_SHARE_READ | OEM_FILE_SHARE_WRITE, 
                                  OEM_CREATE_ALWAYS, OEM_ATTRIBUTE_NORMAL);

    if (Outfp == OEM_INVALID_HANDLE_VALUE)
    {
        printf("Output file not opened\n");
        goto ErrorExit;
    }
    
    ChkDR( DRM_MGR_Initialize( poManagerContext, pwszDataStoreFile ) );

    dr = DRM_MGR_GetSecureClock( poManagerContext, pwszSecTime, &cchSecTime, &dwFlag, pbTimeStatus, &cbTimeStatus );

    if ( dr != DRM_E_BUFFERTOOSMALL )
    {
        goto ErrorExit;
    }
    ChkMem( pwszSecTime = (DRM_WCHAR*) OEM_malloc( cchSecTime * SIZEOF( DRM_WCHAR ) ) );
    ChkMem( pbTimeStatus = (DRM_BYTE*) OEM_malloc( cbTimeStatus ) );
	MEMSET( pwszSecTime, 'a', cchSecTime * SIZEOF( DRM_WCHAR ) );
	MEMSET( pbTimeStatus, 'b', cbTimeStatus );
    ChkDR( DRM_MGR_GetSecureClock( poManagerContext, pwszSecTime, &cchSecTime, &dwFlag, pbTimeStatus, &cbTimeStatus ) );

    if ( DRM_CLK_NOT_SET == dwFlag || DRM_CLK_NEEDS_REFRESH == dwFlag )
    {
        dr = DRM_MGR_ClkGenerateChallenge(poManagerContext, 
                                          NULL,
                                         &cchURL,
                                          NULL,
                                         &cchChallenge );
        
        if( dr != DRM_E_BUFFERTOOSMALL )
        {
            goto ErrorExit;
        }
        ChkMem(pszChallenge = (DRM_CHAR *)  OEM_malloc(cchChallenge));
        ChkMem(pwszURL      = (DRM_WCHAR *) OEM_malloc(cchURL * SIZEOF (DRM_WCHAR)));

        ChkDR( DRM_MGR_ClkGenerateChallenge(poManagerContext,
                                            pwszURL,
                                           &cchURL,
                                           (DRM_BYTE *) pszChallenge,
                                           &cchChallenge));
     
    
    }
    
    if (! OEM_WriteFile( Outfp, pszChallenge , cchChallenge, &iIO) 
      || iIO != cchChallenge)
    {
        printf("Failed to write challenge\n");
        goto ErrorExit;
    }

    if (f_pdstrFileURL->cchString > 0)
    {
        OEM_FILEHDL hfileURL = OEM_INVALID_HANDLE_VALUE;
        
        hfileURL = OEM_OpenFile(f_pdstrFileURL->pwszString, 
                                OEM_GENERIC_READ    | OEM_GENERIC_WRITE,
                                OEM_FILE_SHARE_READ | OEM_FILE_SHARE_WRITE, 
                                OEM_CREATE_ALWAYS, 
                                OEM_ATTRIBUTE_NORMAL);

        if (hfileURL != OEM_INVALID_HANDLE_VALUE)
        {
            DRM_DWORD cbURL = cchURL * SIZEOF (DRM_WCHAR);
            
            if (! OEM_WriteFile(hfileURL, pwszURL, cbURL, &iIO) 
              ||  iIO != cbURL)
            {
                printf("Failed to write URL file\n");
            }

            OEM_CloseFile(hfileURL);
        }
        else
        {
            printf("URL file not opened\n");
        }
    }
    
ErrorExit:

    if (Outfp != OEM_INVALID_HANDLE_VALUE)
    {
        OEM_CloseFile(Outfp);
    }
    
    if (pszChallenge != NULL)
    {
        OEM_free(pszChallenge);
    }

    if (pwszSecTime != NULL)
    {
        OEM_free(pwszSecTime);
    }

    if (pbTimeStatus != NULL)
    {
        OEM_free(pbTimeStatus);
    }
    
    if (poManagerContext != NULL)
    {
        DRM_MGR_Uninitialize(poManagerContext);
        OEM_free(poManagerContext);
    }
}


/******************************************************************************
** 
*******************************************************************************
*/
DRM_VOID DRM_API wmain( 
    DRM_INT     argc, 
    DRM_WCHAR **argv)
{
    DRM_CONST_STRING dstrOutputFile = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrStoreName  = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrFileURL    = EMPTY_DRM_STRING;
    DRM_INT i;

    printf( "Microsoft (R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "Generate Secure Clock Challenge" );

#if EMBEDDED_WITH_NO_PARAMS
    argc = g_argc;
    argv = g_argv;
#endif
	
    for( i = 1; i < argc; i++ )
    {
        DRM_WCHAR        wchOption = 0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;
        
        if (! DRM_CMD_ParseCmdLine(argv[i], &wchOption, &dstrParam, NULL) )
        {
            goto _PrintUsage;
        }

        wchOption = towlower( wchOption );

        switch( wchOption )
        {
        case WCHAR_CAST('l'):
            dstrOutputFile = dstrParam;
            break;
        case WCHAR_CAST('s'):
            dstrStoreName = dstrParam;
            break;            
        case WCHAR_CAST('u'):
            dstrFileURL = dstrParam;
            break;
        default:
            goto _PrintUsage;
        }
    }

    if( dstrOutputFile.cchString == 0
     || dstrStoreName .cchString == 0 )
    {
        goto _PrintUsage;
    }

    GenerateChallenge( &dstrOutputFile, &dstrFileURL, &dstrStoreName);

    return;

_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\secureclockprocessresponse.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <stdio.h>

#define EMBEDDED_WITH_NO_PARAMS 0

#if EMBEDDED_WITH_NO_PARAMS

DRM_INT   g_argc = 3;

DRM_WCHAR g_Arg1[] = { TWO_BYTES('s', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('k', '\0'),  TWO_BYTES('g', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('g', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('\0', '\0')};
DRM_WCHAR g_Arg2[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('j', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('\0', '\0')};
DRM_WCHAR g_Arg3[] = { TWO_BYTES('-', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('j', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('u', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\\', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('p', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('\0', '\0')};
DRM_WCHAR *g_argv[] = { g_Arg1, g_Arg2, g_Arg3};
#endif

/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] -r:ResponseFile -s:DataStoreFile\n", pwszAppName);
}


static void 
ProcessResponse(DRM_CONST_STRING *f_dstrFileResponse, 
				DRM_CONST_STRING *f_dstrFileDataStore )
{
    DRM_RESULT  dr            = DRM_SUCCESS;
    DRM_BYTE*   pbData        = NULL;
    OEM_FILEHDL hfileResponse = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD   cbWritten     = 0;
    DRM_RESULT  drResponse    = DRM_SUCCESS;
    DRM_DWORD   cbFile        = 0;
    DRM_MANAGER_CONTEXT *pcontextMGR = NULL;

    ChkMem( pcontextMGR = OEM_malloc(SIZEOF(DRM_MANAGER_CONTEXT)));
    ZEROMEM(pcontextMGR, SIZEOF(DRM_MANAGER_CONTEXT));

    hfileResponse = OEM_OpenFile(f_dstrFileResponse->pwszString, 
                                 OEM_GENERIC_READ,
                                 OEM_FILE_SHARE_READ, 
                                 OEM_OPEN_EXISTING, 
                                 OEM_ATTRIBUTE_NORMAL);

    if (hfileResponse == OEM_INVALID_HANDLE_VALUE)
    {
        printf( "Input file not opened\n" );
        goto ErrorExit;
    }

    OEM_GetFileSize(hfileResponse, &cbFile);
        
    OEM_SetFilePointer(hfileResponse, 0, OEM_FILE_BEGIN, NULL);
    ChkMem( pbData = (DRM_BYTE*) OEM_malloc(cbFile) );

    if (! OEM_ReadFile(hfileResponse, pbData, cbFile, &cbWritten) 
     || cbWritten != cbFile)
    {
        ChkDR(DRM_E_FILEREADERROR);
    }

    dr = DRM_MGR_Initialize( pcontextMGR, f_dstrFileDataStore );
    
    dr = DRM_MGR_ClkProcessResponse(pcontextMGR, 
                                    pbData, 
                                    cbFile, 
                                   &drResponse);

    if ( drResponse != DRM_SUCCESS )
    {
        printf("Response contains error %d\n", drResponse );
    }
    if ( dr != DRM_SUCCESS )
    {
        printf("Error Processing response %d\n", dr );
    
    }
    
    
ErrorExit:
    OEM_CloseFile(hfileResponse);
    OEM_free     (pbData);
    
    if (pcontextMGR != NULL)
    {
	    DRM_MGR_Uninitialize(pcontextMGR);
	    OEM_free            (pcontextMGR);
    }
}

DRM_VOID DRM_API wmain( 
    DRM_INT     argc, 
    DRM_WCHAR **argv )
{
    DRM_CONST_STRING dstrResponseFile = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrStoreName    = EMPTY_DRM_STRING;
    DRM_INT i;

    printf( "Microsoft (R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "Process DRM Devcert Response tool" );

#if EMBEDDED_WITH_NO_PARAMS
    argc = g_argc;
    argv = g_argv;
#endif

    if( argc !=3 )
    {
        goto _PrintUsage;
    }

    for (i = 1; i < argc; i++)
    {
        DRM_WCHAR        wchOption = 0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;

        if ( !DRM_CMD_ParseCmdLine(argv[i], &wchOption, &dstrParam, NULL) )
        {
            goto _PrintUsage;
        }

        switch (towlower (wchOption))
        {
        case WCHAR_CAST('r'):
            ASSIGN_DRM_STRING (dstrResponseFile, dstrParam);
            break;

        case WCHAR_CAST('s'):
            ASSIGN_DRM_STRING (dstrStoreName, dstrParam);
            break;

        default:
            goto _PrintUsage;
        }
    }

    if( dstrResponseFile.cchString == 0
     || dstrStoreName   .cchString == 0 )
    {
        goto _PrintUsage;
    }


    ProcessResponse(&dstrResponseFile, &dstrStoreName);
    return;
_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\secureclockcreateresponse.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <drmpkcrypto.h>
#include <drmlicense.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <drmdevcert.h>
#include <stdio.h>
#include <drmtoolsconstants.h>

#define FILE_BUFFER_SIZE 4096
#define MIN_OBJ_SIZE 24
#define DATA_OBJECT_SIZE 50
#define MIN_WANTED FILE_BUFFER_SIZE
#define CLK_RESPONSE_EXTRA_SIZE 4096
#define MAX_FILENAME 1023
#define ZULU_TIME_SIZE 20



typedef struct DRMSTATE
{
    DRM_BYTE            *pbChl;
    DRM_DWORD           dwChlsize; 
    OEM_FILEHDL         Outfp;

    PUBKEY              DevicePubKey;
    PRIVKEY             DACPrivKey;
    DRM_BYTE            *pbOut;
    DRM_CRYPTO_CONTEXT  *pCrypto;

}DRMSTATE;

#define CallXmlBuilder(context, fn)   {\
    while (TRUE)\
    {\
        dr = (fn);\
        if ( dr == DRM_E_BUFFERTOOSMALL )\
        {\
            ChkDR(_ReallocXmlContext(&(context)));\
            continue;\
        }\
        ChkDR(dr);\
        break;\
    }\
}

/*This is dummy private key.*/
const PRIVKEY oSigningKey =
{
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), 
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00)
};

static const PRIVKEY oGlobalPrivKey = 
{
    TWO_BYTES(0xAC, 0xE7), TWO_BYTES(0x9C, 0x53), TWO_BYTES(0x40, 0xFD), TWO_BYTES(0xF3, 0xA1), TWO_BYTES(0xE2, 0x4A), 
    TWO_BYTES(0x27, 0x15), TWO_BYTES(0x0B, 0x49), TWO_BYTES(0x5C, 0xDD), TWO_BYTES(0x37, 0xE0), TWO_BYTES(0x54, 0x2F)
};

static DRM_RESULT
_ReallocXmlContext(
    DRM_BYTE **ppbXmlContext)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD cbXmlContext=0;
    DRM_BYTE *pbNewXmlContext=NULL;

	/* get current size */
    ChkDR(DRM_XMB_GetContextSize(*ppbXmlContext, &cbXmlContext));  
	/* alloc double of the current size */
    ChkMem(pbNewXmlContext = (DRM_BYTE*)OEM_malloc(2 * cbXmlContext));  
    ChkDR(DRM_XMB_ReallocDocument(*ppbXmlContext,    2 * cbXmlContext, pbNewXmlContext));
    OEM_free(*ppbXmlContext);
    *ppbXmlContext = pbNewXmlContext;

ErrorExit:
    return dr;
}

static DRM_VOID _NumberToFormatString (DRM_DWORD  dwValue, 
                                 DRM_WCHAR *pszBuffer, 
                                 DRM_DWORD  cchBuffer)
{
    DRM_WCHAR *p = pszBuffer + cchBuffer - 1;     /* last digit at end of buffer */
    DRM_DWORD  cchOut = 0;


    while ( p >= pszBuffer ) 
    {
        *p-- = g_wch0 ; 
    }
    if( dwValue == 0 )
    {
        return ;
    }
    p = pszBuffer + cchBuffer - 1;
    while ( dwValue != 0 && p >= pszBuffer) 
    {
        cchOut++;
        *p-- = WCHAR_CAST(NATIVE_WCHAR(g_wch0) + (dwValue % 10)); /* store the digit */
        dwValue /= 10;            /* reduce number */        
    }
    return; /* compute length of number & return */
}




/****************************************************************************/
void DRMCertClose( DRMSTATE **ppState )
{
    if ( *ppState )
    {
        if ( (*ppState)->Outfp != OEM_INVALID_HANDLE_VALUE )
        {
            OEM_CloseFile( (*ppState)->Outfp );
        }
        if ( (*ppState)->pbChl )
        {
            OEM_free( (*ppState)->pbChl );
        }
        if ( (*ppState)->pCrypto )
        {
            OEM_free( (*ppState)->pCrypto );
        }

        OEM_free( *ppState );

        *ppState = NULL;

    }
}
/****************************************************************************/


DRM_RESULT DRMCertInit( DRMSTATE **ppState )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkMem( *ppState = ( DRMSTATE* ) OEM_malloc( SIZEOF(DRMSTATE ) ) );
    ZEROMEM(*ppState, SIZEOF(DRMSTATE ) );
    (*ppState)->Outfp = OEM_INVALID_HANDLE_VALUE;
    ChkMem( (*ppState)->pCrypto = (DRM_CRYPTO_CONTEXT *)OEM_malloc( SIZEOF( DRM_CRYPTO_CONTEXT ) ) );
    ZEROMEM((*ppState)->pCrypto, SIZEOF( DRM_CRYPTO_CONTEXT ) );

ErrorExit:
    return dr;
}

/****************************************************************************/

DRM_RESULT DRMGetZULUTime( DRM_WCHAR wszZulu[ZULU_TIME_SIZE], DRM_WORD wMonthsAhead )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwSize =0;
    DRM_WCHAR *pwszTemp = NULL;
    DRMSYSTEMTIME oSystemTime;

    ChkArg( wszZulu );

    OEM_GetDeviceDateTime( &oSystemTime );

    if (oSystemTime.wMonth + wMonthsAhead > 12)
    {
        oSystemTime.wYear += ( (oSystemTime.wMonth + wMonthsAhead) /12 );
        oSystemTime.wMonth = (oSystemTime.wMonth + wMonthsAhead)%12;
    }
    else
    {
        oSystemTime.wMonth += wMonthsAhead %12;
    }


    /* Convert system time in ZULU format */
    pwszTemp = wszZulu;
    *pwszTemp = g_wchPound;
    pwszTemp +=1;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wYear, pwszTemp, ( DRM_DWORD ) 4 );
    pwszTemp +=4;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wMonth, pwszTemp, ( DRM_DWORD ) 2 );
    pwszTemp +=2;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wDay, pwszTemp, ( DRM_DWORD ) 2 );
    pwszTemp +=2;
    *pwszTemp = g_wchSpace;
    pwszTemp +=1;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wHour, pwszTemp, ( DRM_DWORD ) 2 );
    pwszTemp +=2;
    *pwszTemp = g_wchColon;
    pwszTemp +=1;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wMinute, pwszTemp, ( DRM_DWORD ) 2 );
    pwszTemp +=2;
    *pwszTemp = g_wchColon;
    pwszTemp +=1;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wSecond, pwszTemp, ( DRM_DWORD ) 2 );
    pwszTemp +=2;
    *pwszTemp = g_wchZ;
    pwszTemp +=1;
    *pwszTemp = g_wchPound;

ErrorExit:
    return dr;
}

/****************************************************************************/
DRM_RESULT CreateResponse( DRMSTATE *pState )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwApproxSize =0;
    DRM_CONST_STRING dstrTemp;
    DRM_CONST_STRING dstrTID;
    DRM_CONST_STRING dstrData;
    DRM_CONST_STRING dstrDevInfo;
    DRM_DWORD dwSize =0;
#if DRM_SECURE_CLOCK_RESPONSE_TEST_MODE == 0
    DRM_BYTE  bSignature[PK_ENC_SIGNATURE_LEN] ={0};
    DRM_STRING dstrSignature = {NULL, 0};
#endif
    DRM_STRING dstrClose = {NULL,0};
    DRM_CONST_STRING dstrNodeRead;
    DRM_BYTE *pbEncode = NULL;

    DRM_WCHAR wszZulu[ZULU_TIME_SIZE];

    DRM_CONST_STRING dstrChl;
    DRM_DWORD cbEncodedSize =0;

    dstrChl.pwszString = (DRM_WCHAR *)pState->pbChl;
    dstrChl.cchString = pState->dwChlsize / SIZEOF(DRM_WCHAR);

    ChkDR( DRM_XML_GetNode( &dstrChl, &g_dstrTagDRMReqRoot, NULL, NULL, 0, NULL, &dstrTemp));

    ChkDR( DRM_XML_GetNode( &dstrTemp, &g_dstrTagData, NULL, NULL, 0, &dstrData, NULL ));

    /* Read Data section */

    ChkDR( DRM_XML_GetNode( &dstrTemp, &g_dstrTagData, NULL, NULL, 0, NULL, &dstrData));

    /* Get TID */
    ChkDR( DRM_XML_GetNode( &dstrData, &g_dstrTagTID, NULL, NULL, 0, NULL, &dstrTID));

    dwSize = 0;

    dwApproxSize = CLK_RESPONSE_EXTRA_SIZE;
        
    ChkMem( pState->pbOut = (DRM_BYTE*) OEM_malloc( dwApproxSize ) );
    ZEROMEM(pState->pbOut, dwApproxSize );
   
    ChkDR( DRM_XMB_CreateDocument( dwApproxSize, pState->pbOut, &g_dstrTagDRMReqRoot ) );
    ChkDR( DRM_XMB_AddAttribute( pState->pbOut, &g_dstrAttributeType, &g_dstrResponse ) );

    /* Add DATA node */

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagData ));

    /* Add TID node */

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagTID ));

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_AddData( pState->pbOut, &dstrTID ) );

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_CloseCurrNode( pState->pbOut, NULL ) );


    /* Add GMTTIME node */

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagGmtTime ));

    ChkDR( DRMGetZULUTime( wszZulu, (DRM_WORD)0 ) );
    dstrChl.pwszString = (DRM_WCHAR *)pState->pbChl;
    dstrChl.cchString = pState->dwChlsize / SIZEOF(DRM_WCHAR);

    dstrTID.pwszString = wszZulu;
    dstrTID.cchString = ZULU_TIME_SIZE;

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_AddData( pState->pbOut, &dstrTID ) );

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_CloseCurrNode( pState->pbOut, NULL ) );

    /* Add REFRESHDATE node */

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagRefreshDate ));

    /*Make Refresh Date 1 month ahead*/
    ChkDR( DRMGetZULUTime( wszZulu, (DRM_WORD)1 ) );
    dstrChl.pwszString = (DRM_WCHAR *)pState->pbChl;
    dstrChl.cchString = pState->dwChlsize / SIZEOF(DRM_WCHAR);

    dstrTID.pwszString = wszZulu;
    dstrTID.cchString = ZULU_TIME_SIZE;

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_AddData( pState->pbOut, &dstrTID ) );

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_CloseCurrNode( pState->pbOut, NULL ) );

    /* Close data node */
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_CloseCurrNode( pState->pbOut, &dstrClose ));

#if DRM_SECURE_CLOCK_RESPONSE_TEST_MODE == 0
    /* Add CERTIFICATECHAIN node */
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagCertificateChain ) );
   
    /* Add CERTIFICATE node */
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagCertificate ) );

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_AddData( pState->pbOut, (DRM_CONST_STRING *)&g_dstrCertSecureClock ) ); 

    /* Close Certificate node */
    CallXmlBuilder( pState->pbOut, 
        DRM_XMB_CloseCurrNode( pState->pbOut, NULL ) );

    /* Close CERTIFICATECHAIN node */
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_CloseCurrNode( pState->pbOut, NULL ) );

    /* Close CERTIFICATECHAIN node */

    /* Sign data portion with private key */
    ChkDR( DRM_PK_Sign( pState->pCrypto->rgbCryptoContext, &oSigningKey, ( DRM_BYTE * ) dstrClose.pwszString, dstrClose.cchString * SIZEOF( DRM_WCHAR ), bSignature ) );

    dwSize = 0;

    dr = DRM_B64_EncodeW(bSignature, PK_ENC_SIGNATURE_LEN, NULL, &dwSize, 0);
    if( dr != DRM_E_BUFFERTOOSMALL )
    {
        goto ErrorExit;
    }
    ChkMem( dstrSignature.pwszString = (DRM_WCHAR *)OEM_malloc( dwSize * SIZEOF ( DRM_WCHAR ) ) );
    dstrSignature.cchString = dwSize;
    ChkDR( DRM_B64_EncodeW(bSignature, PK_ENC_SIGNATURE_LEN, dstrSignature.pwszString, &dstrSignature.cchString, 0 ) );
    
    /* Got base64 encoded signature. Now Make Signature node */

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagSignature ));

    /* Open HASH node */

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagHashAlg ));
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_AddAttribute( pState->pbOut, &g_dstrAttributeType, &g_dstrSHA ));

    /* Close HASH node */
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_CloseCurrNode( pState->pbOut, NULL ));


    /* Open SIGN node */

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagSignAlg ));
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_AddAttribute( pState->pbOut, &g_dstrAttributeType, &g_dstrMSDRM ));

    /* Close SIGN node */
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_CloseCurrNode( pState->pbOut, NULL ));

    /* Open VALUE node */

    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_OpenNode( pState->pbOut, &g_dstrTagValue ));
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_AddAttribute( pState->pbOut, &g_dstrRootSigValueVersionTag, &g_dstrRootSigValueVersionVal ));

    /* Add Data to node */
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_AddData( pState->pbOut, (DRM_CONST_STRING *)&dstrSignature ));

    /* Close VALUE node */
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_CloseCurrNode( pState->pbOut, NULL ));

    /* Close SIGNATURE node */
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_CloseCurrNode( pState->pbOut, NULL ));
#endif /* DRM_SECURE_CLOCK_RESPONSE_TEST_MODE == 0 */

    /* close the root node */
    CallXmlBuilder(pState->pbOut, 
        DRM_XMB_CloseDocument(pState->pbOut, &dstrClose));


    /* Now encode this blob */

    dwSize = dstrClose.cchString * SIZEOF(DRM_WCHAR);
    ChkMem( pbEncode = (DRM_BYTE *) OEM_malloc( dwSize*2 ) );
   
    /* Now Base64Encode it in ANSI. */
    cbEncodedSize = dwSize*2;
    ChkDR( DRM_B64_EncodeA((DRM_BYTE *) dstrClose.pwszString, 
                            dwSize,
                           (DRM_CHAR *) pbEncode, 
                          &cbEncodedSize, 
                           0));

    if (!OEM_WriteFile(pState->Outfp, pbEncode, cbEncodedSize,
        &dwSize) || dwSize != cbEncodedSize )
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }
ErrorExit:
    
#if DRM_SECURE_CLOCK_RESPONSE_TEST_MODE == 0
    if ( dstrSignature.pwszString )
    {
        OEM_free( dstrSignature.pwszString );
    }
#endif

    if ( pbEncode )
    {
        OEM_free( pbEncode );
    }


    return dr;
}

/****************************************************************************/


/******************************************************************************
** Print a command menu to console
*******************************************************************************
*/
static void 
PrintUsage(DRM_WCHAR *pwszAppName)
{
    printf("Syntax: %S [-?] -l:ChallengeFile -r:OutputresponseFile \n", pwszAppName);
}

/******************************************************************************
** 
*******************************************************************************
*/

DRM_VOID DRM_API wmain( 
    DRM_INT     argc, 
    DRM_WCHAR **argv )
{
    DRM_CONST_STRING dstrChallengeFile = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrResponseFile  = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrTemp          = EMPTY_DRM_STRING;

    OEM_FILEHDL InfpChl = OEM_INVALID_HANDLE_VALUE;

    DRM_DWORD iIO=0, dw=0;
    DRM_INT i;
    DRM_RESULT dr = DRM_SUCCESS;
    DRMSTATE *pState = NULL;
    /* Expected maximum pathname. */
    DRM_WCHAR    wTemp[MAX_FILENAME + 1] = {0}; 
    DRM_BYTE *pbIn = NULL;


    printf( "Microsoft (R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "Clock response creation tool" );

    if( argc != 3 )
    {
        goto _PrintUsage;
    }

    for( i = 1; i<argc; i++ )
    {
        DRM_WCHAR wchOption = 0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;
        if ( !DRM_CMD_ParseCmdLine(argv[i], &wchOption, &dstrParam, NULL) )
        {
            goto _PrintUsage;
        }
        wchOption = towlower( wchOption );
        switch( wchOption )
        {
        case WCHAR_CAST('l'):
            dstrChallengeFile = dstrParam;
            break;
        
        case WCHAR_CAST('r'): 
            dstrResponseFile = dstrParam;
            break;
         default:
            goto _PrintUsage;
        }
    }

    if( dstrChallengeFile.cchString == 0
     || dstrResponseFile .cchString == 0 )
    {
        goto _PrintUsage;
    }
    if( dstrResponseFile .cchString > MAX_FILENAME 
     || dstrChallengeFile.cchString > MAX_FILENAME )
    {
        printf( "File name is too big. Max Filename is %d \n", MAX_FILENAME );
        return;
    }


    ChkDR( DRMCertInit( &pState ) );

    if( dstrChallengeFile.cchString )
    {
        DRM_SUBSTRING    dasstrEncoded = { 0 };
        DRM_DWORD        cbDecoded     = 0;
        DRM_CONST_STRING dstrTemp = EMPTY_DRM_STRING;

        wcsncpy( wTemp, dstrChallengeFile.pwszString, dstrChallengeFile.cchString );
        wTemp[dstrChallengeFile.cchString] = g_wchNull;
        
        InfpChl = OEM_OpenFile(wTemp, OEM_GENERIC_READ,
            OEM_FILE_SHARE_READ, OEM_OPEN_EXISTING, OEM_ATTRIBUTE_NORMAL);
        if( OEM_INVALID_HANDLE_VALUE == InfpChl )
        {
            printf( "Challenge file not opened\n" );
            goto ErrorExit;
        }
        OEM_GetFileSize(InfpChl, &dw);
        OEM_SetFilePointer(InfpChl, 0, OEM_FILE_BEGIN, NULL);
       
        ChkMem( pbIn = (DRM_BYTE*) OEM_malloc( dw ) );
        if (!OEM_ReadFile(InfpChl, pbIn, dw, &iIO) || iIO!=dw)
        {
            ChkDR(DRM_E_FILEREADERROR);
        }
        OEM_CloseFile( InfpChl );
        InfpChl = OEM_INVALID_HANDLE_VALUE;

        dasstrEncoded.m_ich = 0;
        dasstrEncoded.m_cch = dw;
        
        /* Decode this ANSI encoded blob in place */
        cbDecoded = dw;
        ChkDR( DRM_B64_DecodeA((DRM_CHAR*) pbIn, &dasstrEncoded, &cbDecoded, NULL, DRM_BASE64_DECODE_IN_PLACE ) );

        ChkMem( pState->pbChl = (DRM_BYTE*) OEM_malloc( cbDecoded ) );

        MEMCPY(pState->pbChl,
               pbIn + dasstrEncoded.m_ich, 
               cbDecoded);
       
        pState->dwChlsize = cbDecoded ;

        OEM_free( pbIn );
        pbIn = NULL;
    }


    if( dstrResponseFile.cchString )
    {
        wcsncpy( wTemp, dstrResponseFile.pwszString, dstrResponseFile.cchString );
        wTemp[dstrResponseFile.cchString] = g_wchNull;
        
        pState->Outfp = OEM_OpenFile(wTemp, OEM_GENERIC_READ|OEM_GENERIC_WRITE,
            OEM_FILE_SHARE_READ|OEM_FILE_SHARE_WRITE, OEM_CREATE_ALWAYS, OEM_ATTRIBUTE_NORMAL);
        if( OEM_INVALID_HANDLE_VALUE == pState->Outfp )
        {
            printf( "Output DecCert file not opened\n" );
            goto ErrorExit;
        }
    }

    if ( pState->pbChl && pState->Outfp )
    {
        ChkDR( CreateResponse( pState ) );
    }


ErrorExit:
    
    if ( InfpChl != OEM_INVALID_HANDLE_VALUE )
    {
        OEM_CloseFile( InfpChl );
    }
    
    if ( pState )
    {
        DRMCertClose( &pState );
    }
    if ( pbIn )
    {
       OEM_free( pbIn );
       pbIn = NULL; 
    }

    return;
_PrintUsage:
    PrintUsage(argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\rsaimpl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __rsaimpl_h
#define __rsaimpl_h 1

/*
       File bigimpl.h.   Version 19 November 2002
*/

/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

#include <bigpriv.h>
#include <bignum.h>
#include <mprand.h>
#ifndef assert
#include <assert.h>
#endif

static DWORDREGC NUM_RABIN_TEST = 50;
static DWORDREGC MAX_PRIME_CANDIDATES = 5000;

/******************************************************************************/
extern DRM_BOOL big_endian_bytes_to_digits
        (const DRM_BYTE  *barray,   /* IN */
         DWORDREGC    bitlen,   /* IN */
         digit_t     *darray);  /* OUT */

extern DRM_BOOL little_endian_bytes_to_digits
        (const DRM_BYTE  *barray,   /* IN */
         DWORDREGC    bitlen,   /* IN */
         digit_t     *darray);  /* OUT */

extern DRM_BOOL digits_to_big_endian_bytes
        (digit_tc    *darray,   /* IN */
         DWORDREGC    bitlen,   /* IN */
         DRM_BYTE        *barray);  /* OUT */

extern DRM_BOOL digits_to_little_endian_bytes
        (digit_tc    *darray,   /* IN */
         DWORDREGC    bitlen,   /* IN */
         DRM_BYTE        *barray);  /* OUT */


/*
 external_rsakey_t is used in a broad context,
 including network transfers.
 The declaration should likely be elsewhere.

 TBD -- Is there a big/little endian problem
        reading the DWORD lengths at the start of the struct?

 Do we want only one pointer within the struct, with other addresses
 computed from this pointer (i.e, as offsets from free_me)?
*/

typedef struct {
      DRM_DWORD   bitlen_modulus;   /* Length of modulus in bits */
      DRM_DWORD   bitlen_pubexp;    /* Length of public exponent in bits */
      DRM_DWORD   bitlen_primes[2]; /* Lengths of primes in bits */
                                /* (zero in public key) */
      DRM_BYTE  *free_me;           /* Address to be passed to free() */
                                /* when done with struct */

/* Next fields are in big-endian order (most significant byte first). */
/* Their lengths are (bitlen_modulus + 7)/8 to (bitlen_primes[1] + 7)/8. */

      DRM_BYTE  *modulus;           /* Public key modulus p1*p2 */
      DRM_BYTE  *pubexp;            /* Public key exponent */
      DRM_BYTE  *primes[2];         /* Primes p1 and p2 (private key only) */
      DRM_BYTE  *privexps[2];       /* Private exponents (private key only */
                                /*                  -- same lengths as primes) */
/* privexps is easily computed from the primes -- */
/* we can suppress these from the external key */
} external_rsa_key_t;

typedef struct {
      DRM_DWORD     bitlen_modulus; /* Lengths of messages to encrypt/decrypt (bits) */
      DRM_DWORD     diglen_pubexp;
      digit_t  *free_me;
      digit_t  *pubexp;         /* Public exponent.  Length diglen_pubexp */
      digit_t  *modulus;        /* p1*p2   Length */
                                /*     BITS_TO_DIGITS(bitlen_modulus), */
 /* Private key data */
      mp_modulus_t moduli[2];   /* Moduli, including primes and their lengths */
      digit_t  *privexps[2];    /* Private exponents.  Same lengths as primes */
      digit_t  *chineses[2];    /* Chinese Remainder Theorem constants: */
                                /* (1/p2) mod p1  and  (1/p1) mod p2 */
                                /*                (private key only) */
                                /* Same lengths as the primes. */
} internal_rsa_key_t;

extern DRM_BOOL rsa_encryption
        (const external_rsa_key_t  *prsaext,   /* IN */
         const DRM_BYTE      *msgin,     /* IN, length prsaext->bitlen_modulus bits */
         DRM_BYTE            *msgout);   /* OUT */

extern DRM_BOOL rsa_key_internalize
        (const external_rsa_key_t  *prsaext,   /* IN */
         internal_rsa_key_t        *prsaint);  /* OUT */

extern DRM_BOOL rsa_decryption
        (const internal_rsa_key_t  *prsaint,   /* IN */
         const DRM_BYTE      *msgin,     /* IN, length prsaint->bitlen_modulus bits */
         DRM_BYTE            *msgout);   /* OUT */

#ifdef __cplusplus
}
#endif
#endif /* __rsaimpl_h */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\secureclockrequest.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <drmlicense.h>
#include <drmsha1.h>
#include <oemimpl.h>
#include <drmdevcert.h>
#include <drmsecureclock.h>
#include <drmsecureclockstatus.h>


#define CLK_CHALLENGE_EXTRA_SIZE 255
 /*Date has to be in ZULU format     #yyyymmdd hh:mm:ssZ# */
#define CLK_ZULU_POUND_SIZE 1
#define CLK_ZULU_YEAR_SIZE 4
#define CLK_ZULU_MONTH_SIZE 2
#define CLK_ZULU_DAY_SIZE 2
#define CLK_ZULU_SPACE_SIZE 1
#define CLK_ZULU_HOUR_SIZE 2
#define CLK_ZULU_FIRST_COLON_SIZE 1
#define CLK_ZULU_MINUTE_SIZE 2
#define CLK_ZULU_SECOND_COLON_SIZE 1
#define CLK_ZULU_SECOND_SIZE 2
#define CLK_ZULU_Z_SIZE 1
#define CLK_ZULU_POUND_SIZE 1
#define CLK_ZULU_NULL_SIZE 1

#define CLK_ZULU_TIME_SIZE  CLK_ZULU_POUND_SIZE + \
                            CLK_ZULU_YEAR_SIZE + \
                            CLK_ZULU_MONTH_SIZE + \
                            CLK_ZULU_DAY_SIZE + \
                            CLK_ZULU_SPACE_SIZE + \
                            CLK_ZULU_HOUR_SIZE + \
                            CLK_ZULU_FIRST_COLON_SIZE + \
                            CLK_ZULU_MINUTE_SIZE + \
                            CLK_ZULU_SECOND_COLON_SIZE + \
                            CLK_ZULU_SECOND_SIZE + \
                            CLK_ZULU_Z_SIZE + \
                            CLK_ZULU_POUND_SIZE + \
                            CLK_ZULU_NULL_SIZE

#define CLK_WITH_STATUS_XML_SIZE 250

const DRM_ID g_idSData     = { TWO_BYTES('S', 0), TWO_BYTES('E', 0), TWO_BYTES('C', 0), TWO_BYTES('U', 0), TWO_BYTES('R', 0), TWO_BYTES('E', 0), TWO_BYTES('1', 0), TWO_BYTES('\0', 0) };
const DRM_ID g_idSDataPrev = { TWO_BYTES('S', 0), TWO_BYTES('E', 0), TWO_BYTES('C', 0), TWO_BYTES('U', 0), TWO_BYTES('R', 0), TWO_BYTES('E', 0), TWO_BYTES('2', 0), TWO_BYTES('\0', 0) };



DRM_VOID _PrepareSecureClockDataForWriting( DRM_SECSTORE_CLOCK_DATA *pData )
{
    FIX_ENDIAN_DWORD( pData->flag  );
    FIX_ENDIAN_DWORD( pData->fInGracePeriod );
    FIX_ENDIAN_QWORD( pData->LastKnownGoodSecureClock );
    FIX_ENDIAN_QWORD( pData->LastKnownRealtimeSecureClock );
    FIX_ENDIAN_QWORD( pData->LastKnownGracePeriodStartTime );
    FIX_ENDIAN_QWORD( pData->RefreshDate );
    FIX_ENDIAN_QWORD( pData->ChallengeTime );
}

/* BUGBUG:  There is a similar function in the utils.  Can it be used instead? */
static DRM_VOID _NumberToFormatString (DRM_DWORD  dwValue, 
                                 DRM_WCHAR *pszBuffer, 
                                 DRM_DWORD  cchBuffer)
{
    DRM_WCHAR *p = pszBuffer + cchBuffer - 1;     /* last digit at end of buffer */


    while ( p >= pszBuffer ) 
    {
        *p-- = g_wch0 ; 
    }
    if( dwValue == 0 )
    {
        return ;
    }
    p = pszBuffer + cchBuffer - 1;
    while ( dwValue != 0 && p >= pszBuffer) 
    {
        *p-- = WCHAR_CAST((NATIVE_WCHAR(g_wch0) + (dwValue % 10))); /* store the digit */
        dwValue /= 10;            /* reduce number */        
    }
    return; /* compute length of number & return */
}



/*******************************************************************
 *              PRIVATE FUNCTION _CreateNewTID
 *
 * purpose: create a new TID-sized blob of random bytes
 *******************************************************************/

static DRM_RESULT _CreateNewTID (DRM_TID *ptid)
{
    return OEM_GenRandomBytes ((DRM_BYTE *) ptid, SIZEOF (DRM_TID));
}

/******************************************************************************/
DRM_RESULT DRM_API DRM_CLK_CreateChallenge(
    IN const DRM_CONST_STRING      *pdstrURL,
    IN const DRM_BYTE               rgbSecStoreInPswd [__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_CRYPTO_CONTEXT    *pContext, 
    IN       DRM_HDS_CONTEXT       *poHdsContext,
    IN       DRM_SECSTORE_CONTEXT  *poSecureStoreContext,
    OUT      DRM_WCHAR             *pwszUrl,
    IN OUT   DRM_DWORD             *pcchUrl,
    IN       DRM_BYTE              *pbData,
    IN OUT   DRM_DWORD             *pcbData )
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD dwSize = 0;
    DRM_DWORD_PTR dwpSize = 0;
    DRM_BYTE *pbXmlData = NULL;
    DRM_DWORD cbXmlData = 0;
    DRM_DWORD cbEncodedSize = 0;
    DRM_DWORD cbSecureData  = 0;
    DRM_SECSTORE_CLOCK_DATA oClkData;
    DRM_STRING       dstrSignature    = EMPTY_DRM_STRING;
    DRM_STRING       dstrClose        = EMPTY_DRM_STRING;    
    DRM_CONST_STRING dstrTid          = EMPTY_DRM_STRING;
    DRM_DWORD dwLen =0;
    DRMSYSTEMTIME oSystemTime;
    DRMFILETIME   filetime;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_CLK_CreateChallenge", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
    
    ChkArg( pcbData             != NULL
         && pContext            != NULL
         && rgbSecStoreInPswd   != NULL  
         && poHdsContext        != NULL       
         && poSecureStoreContext!= NULL );
    ChkDRMString( pdstrURL );
    
    dwLen = pdstrURL->cchString;

    /* Calculate safe size  including base64 ANSI encoding */
    
    dwSize = ( dwLen*SIZEOF(DRM_WCHAR) + CLK_CHALLENGE_EXTRA_SIZE );

    /* For final ANSI encoding */
    dwSize = CCH_BASE64_EQUIV( dwSize ) ;


    if ( pbData  == NULL  
      || *pcbData < dwSize 
      || ( pcchUrl != NULL 
        && ( pwszUrl == NULL 
          || *pcchUrl < dwLen+1 ) 
          )  
       )

    {
        /* safe size */
        *pcbData = dwSize;
        if ( pcchUrl )
        {
            *pcchUrl = dwLen+1;
        }
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }


    /* Initialize buffer */
    ZEROMEM(pbData, *pcbData );

    pbXmlData =  pbData;
    cbXmlData = *pcbData;


    /*Check the byte alignment of pbXmlData */
    ChkDR( DRM_UTL_EnsureDataAlignment( pbXmlData, cbXmlData, &pbXmlData, &cbXmlData, SIZEOF(DRM_DWORD_PTR), NULL ) );

    /* Init XML Builder 
    ** Add document root tag: <DRMCLOCK type="challenge"> 
    */
    ChkDR( DRM_XMB_CreateDocument( cbXmlData, pbXmlData,            &g_dstrTagDRMReqRoot ) );
    ChkDR( DRM_XMB_AddAttribute(   pbXmlData, &g_dstrAttributeType, &g_dstrChallenge ) );

    /* Add <DATA> node to the root node */
    ChkDR( DRM_XMB_OpenNode( pbXmlData, &g_dstrTagData ) );

    if ( pcchUrl != NULL && pwszUrl != NULL )
    {
        *pcchUrl = pdstrURL->cchString+1;
        wcsncpy( pwszUrl, pdstrURL->pwszString, pdstrURL->cchString );
        pwszUrl[pdstrURL->cchString] = g_wchNull;
    }

    /* Add <URL> node to data node */
    ChkDR( DRM_XMB_OpenNode( pbXmlData, &g_dstrTagURL ) );
    ChkDR( DRM_XMB_AddData( pbXmlData, pdstrURL ) );
    ChkDR( DRM_XMB_CloseCurrNode( pbXmlData, NULL ) );
    /* Read secure store */
    ZEROMEM(&oClkData, SIZEOF( oClkData ));
    cbSecureData = SIZEOF( oClkData );
    dr = DRM_SST_GetData(   poSecureStoreContext, 
                           &g_idSData, 
                           &g_idSDataPrev, 
                            rgbSecStoreInPswd, 
                            SECURE_STORE_GLOBAL_DATA,
                            poHdsContext,
              (DRM_BYTE *) &oClkData, 
                           &cbSecureData);
    _PrepareSecureClockDataForReading( &oClkData );
    /*Read can Fail. But it doesnt matter */
    if ( DRM_SUCCESS != dr )
    {
        ZEROMEM(&oClkData, SIZEOF(oClkData));
    }

    /* Now create a new TID and write it to the secure store */
    ChkDR( _CreateNewTID ( &oClkData.tid ) );
    oClkData.flag |= CLK_TID_VALID;
    
    /*Get Time and store it in secure store. Response should not come after 5 min of this time*/
    OEM_GetDeviceDateTime( &oSystemTime );
    if ( !OEM_SystemTimeToFileTime( &oSystemTime, &filetime ) )
    {
        ChkDR( DRM_E_CLK_INVALID_DATE );
    }
    FILETIME_TO_UI64( filetime, oClkData.ChallengeTime );

    oClkData.flag |= CLK_CHALLENGETIME_VALID;

    /*Write it to secure store*/
    cbSecureData = SIZEOF( oClkData );

    _PrepareSecureClockDataForWriting( &oClkData );
    ChkDR( DRM_SST_SetData( poSecureStoreContext,
                           &g_idSData,
                           &g_idSDataPrev,
                            rgbSecStoreInPswd,
                            SECURE_STORE_GLOBAL_DATA,
                            poHdsContext,
              (DRM_BYTE *) &oClkData, 
                            cbSecureData ) );
    _PrepareSecureClockDataForReading( &oClkData );

    /*Encode it*/
    /* We are using Cryto buffer as working buffer. 
    Clear this buffer before using any crypto API*/
    DSTR_FROM_PB( &dstrTid, pContext->rgbCryptoContext, DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE );

    ChkDR( DRM_B64_EncodeW((const DRM_BYTE * )&oClkData.tid, 
                            SIZEOF(DRM_TID), 
                            (DRM_WCHAR *) dstrTid.pwszString, 
                            &dstrTid.cchString,
                             0));

    /* Add TID */
    ChkDR( DRM_XMB_OpenNode( pbXmlData, &g_dstrTagTID ) );
    ChkDR( DRM_XMB_AddData( pbXmlData, &dstrTid ) );
    ChkDR(DRM_XMB_CloseCurrNode( pbXmlData, NULL ) );

    /* Close data node */
    ChkDR(DRM_XMB_CloseCurrNode( pbXmlData, &dstrClose ) );

    /* Close Document */
    ChkDR( DRM_XMB_CloseDocument( pbXmlData, &dstrClose ) );


    /* Now Base64Encode it in ANSI. Use Crypto context as working buffer */
    cbEncodedSize = CCH_BASE64_EQUIV( CB_DSTR( &dstrClose ) );
    if ( *pcbData < cbEncodedSize )
    {
        *pcbData = cbEncodedSize;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }

    /*Move this data to front as we want to encode in place*/
    MEMMOVE(pbData, PB_DSTR( &dstrClose ), CB_DSTR( &dstrClose ) );

    cbEncodedSize = *pcbData;
    
    ChkDR( DRM_B64_EncodeA(pbData, 
                           CB_DSTR(&dstrClose),
               (DRM_CHAR *)pbData, 
                          &cbEncodedSize,
                           0));
    *pcbData = cbEncodedSize;

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_CLK_CreateChallenge", g_pwszLeavingFunction);
    
    return dr;
}

/******************************************************************************/

DRM_RESULT DRM_API DRM_CLK_GetSecureClock(
    OUT      DRM_WCHAR            *pwszSecureTime,
    IN OUT   DRM_DWORD            *pcchSecureTime, 
    OUT      DRM_DWORD            *pdwFlags,
    IN       DRM_BYTE             *pbSecureTimeWithStatus,
    IN OUT   DRM_DWORD            *pcbSecureTimeWithStatus, 
    IN const DRM_BYTE              rgbSecStoreInPswd [__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_CRYPTO_CONTEXT   *pContext,
    IN       DRM_HDS_CONTEXT      *poHdsContext,
    IN       DRM_SECSTORE_CONTEXT *poSecureStoreContext)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_SECSTORE_CLOCK_DATA oClkData;
    DRMSYSTEMTIME oSystemTime;
    DRMFILETIME   filetime;
    DRM_UINT64    u64DRMTime;
    DRM_DWORD cbSecureData =0;
    DRM_BOOL fResetState = FALSE;
    DRM_DWORD i=0;
    DRM_WCHAR *pwszTemp = NULL;
    DRM_BYTE *pbXmlData = NULL;
    DRM_DWORD cbXmlData = 0;
    DRM_DWORD dwFlags = 0;
    const DRM_CONST_STRING *pdstrStatus = &g_dstrSecureClockNotSet;
    DRM_CONST_STRING dstrZuluTime =  EMPTY_DRM_STRING;

    ChkArg( pContext             != NULL
         && rgbSecStoreInPswd    != NULL
         && poHdsContext         != NULL
         && poSecureStoreContext != NULL );

    /*Date has to be in ZULU format     #yyyymmdd hh:mm:ssZ# */

    if ( ( NULL != pcchSecureTime
        && (  NULL == pwszSecureTime 
          || *pcchSecureTime < CLK_ZULU_TIME_SIZE ) )
      || ( NULL != pcbSecureTimeWithStatus ) 
        &&  ( NULL == pbSecureTimeWithStatus 
           || *pcbSecureTimeWithStatus < CLK_WITH_STATUS_XML_SIZE ) )
    {
        if ( NULL != pcchSecureTime )
        {
            *pcchSecureTime = CLK_ZULU_TIME_SIZE;
        }
        if ( NULL != pcbSecureTimeWithStatus )
        {
            *pcbSecureTimeWithStatus = CLK_WITH_STATUS_XML_SIZE;
        }
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /* Read secure store */
    ZEROMEM(&oClkData, SIZEOF( oClkData ));
    cbSecureData = SIZEOF( oClkData );
  
    ChkDR( DRM_SST_GetData( poSecureStoreContext, 
                            &g_idSData, 
                            &g_idSDataPrev, 
                            rgbSecStoreInPswd, 
                            SECURE_STORE_GLOBAL_DATA,
                            poHdsContext,
                            (DRM_BYTE *) &oClkData, 
                            &cbSecureData ) );

    _PrepareSecureClockDataForReading( &oClkData );
    OEM_GetDeviceDateTime( &oSystemTime );
    /*Use DRM Crypto context as buffer*/
    pwszTemp = ( DRM_WCHAR * )pContext->rgbCryptoContext;

    /* Convert system time in ZULU format */
    *pwszTemp = g_wchPound;
    pwszTemp +=CLK_ZULU_POUND_SIZE;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wYear, pwszTemp, ( DRM_DWORD ) CLK_ZULU_YEAR_SIZE );
    pwszTemp +=CLK_ZULU_YEAR_SIZE;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wMonth, pwszTemp, ( DRM_DWORD ) CLK_ZULU_MONTH_SIZE );
    pwszTemp +=CLK_ZULU_MONTH_SIZE;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wDay, pwszTemp, ( DRM_DWORD ) CLK_ZULU_DAY_SIZE );
    pwszTemp +=CLK_ZULU_DAY_SIZE;
    *pwszTemp = g_wchSpace;
    pwszTemp +=CLK_ZULU_SPACE_SIZE;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wHour, pwszTemp, ( DRM_DWORD ) CLK_ZULU_HOUR_SIZE );
    pwszTemp +=CLK_ZULU_HOUR_SIZE;
    *pwszTemp = g_wchColon;
    pwszTemp +=CLK_ZULU_FIRST_COLON_SIZE;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wMinute, pwszTemp, ( DRM_DWORD ) CLK_ZULU_MINUTE_SIZE );
    pwszTemp +=CLK_ZULU_MINUTE_SIZE;
    *pwszTemp = g_wchColon;
    pwszTemp +=CLK_ZULU_SECOND_COLON_SIZE;
    _NumberToFormatString ( ( DRM_DWORD )  oSystemTime.wSecond, pwszTemp, ( DRM_DWORD ) CLK_ZULU_SECOND_SIZE );
    pwszTemp +=CLK_ZULU_SECOND_SIZE;
    *pwszTemp = g_wchZ;
    pwszTemp +=CLK_ZULU_Z_SIZE;
    *pwszTemp = g_wchPound;
    pwszTemp +=CLK_ZULU_POUND_SIZE;
    *pwszTemp = g_wchNull;

    if ( !OEM_SystemTimeToFileTime( &oSystemTime, &filetime ) )
    {
        ChkDR( DRM_E_CLK_INVALID_DATE );
    }

    FILETIME_TO_UI64( filetime, u64DRMTime );

    ChkDR( OEM_GetClockResetState( &fResetState ) );

    /*If Clock was never set or device is in grace period = NOT_SET*/

    if ( fResetState 
      || ( ( oClkData.flag & CLK_LK_RSC_VALID ) == 0 ) 
      || ( ( oClkData.flag & CLK_EVER_SET )     == 0 )
      || ( ( oClkData.flag & CLK_IN_GP_VALID ) && oClkData.fInGracePeriod ) )
    {
        dwFlags = DRM_CLK_NOT_SET;
        pdstrStatus = &g_dstrSecureClockNotSet;
    }
    else if ( ( oClkData.flag & CLK_REFRESHDATE_VALID ) 
         && ( DRM_UI64Les( u64DRMTime, oClkData.RefreshDate ) ) )
    {
        dwFlags = DRM_CLK_SET;
        pdstrStatus = &g_dstrSecureClockSet;
    }
    else 
    {
        dwFlags = DRM_CLK_NEEDS_REFRESH;
        pdstrStatus = &g_dstrSecureClockNeedsRefresh;
    }


    
    if ( NULL != pcbSecureTimeWithStatus
      && NULL != pbSecureTimeWithStatus 
      && *pcbSecureTimeWithStatus >= CLK_WITH_STATUS_XML_SIZE )
    {
       /* < DRMCLOCK type = status >
            <VALUE> Secure tine value in ZULU format</VALUE>            
            <FLAG> 0 1 or 2 depending on status</FLAG>           
          </ DRMCLOCK > */

        ChkDR(DRM_UTL_EnsureDataAlignment(pbSecureTimeWithStatus,
                                         *pcbSecureTimeWithStatus,
                                         &pbXmlData,
                                         &cbXmlData,
                                          SIZEOF(DRM_DWORD),
                                          NULL));

        ChkDR( DRM_XMB_CreateDocument( cbXmlData, pbXmlData, &g_dstrTagDRMReqRoot ) );
        ChkDR( DRM_XMB_AddAttribute( pbXmlData, &g_dstrAttributeType, &g_dstrStatus ) );
        /*Open Value Node*/
        ChkDR( DRM_XMB_OpenNode( pbXmlData, &g_dstrTagValue ) );
        dstrZuluTime.pwszString = ( DRM_WCHAR * )pContext->rgbCryptoContext;
        /*Dont copy null termination*/
        dstrZuluTime.cchString = CLK_ZULU_TIME_SIZE -1;
        ChkDR( DRM_XMB_AddData( pbXmlData, &dstrZuluTime ) );
        ChkDR(DRM_XMB_CloseCurrNode( pbXmlData, NULL ) );

        ChkDR( DRM_XMB_OpenNode( pbXmlData, &g_dstrFlag ) );

        ChkDR( DRM_XMB_AddData( pbXmlData, pdstrStatus ) );
        ChkDR(DRM_XMB_CloseCurrNode( pbXmlData, NULL ) );
        ChkDR( DRM_XMB_CloseDocument( pbXmlData, (DRM_STRING *)&dstrZuluTime ) );
        MEMMOVE( pbSecureTimeWithStatus, PB_DSTR(&dstrZuluTime), CB_DSTR(&dstrZuluTime) );
        *pcbSecureTimeWithStatus = CB_DSTR(&dstrZuluTime);
    }

    if ( NULL != pcchSecureTime 
      && NULL != pwszSecureTime 
      && *pcchSecureTime >= CLK_ZULU_TIME_SIZE )
    {
        *pcchSecureTime = CLK_ZULU_TIME_SIZE;
        MEMCPY( (DRM_BYTE *)pwszSecureTime, pContext->rgbCryptoContext, (*pcchSecureTime)*SIZEOF( DRM_WCHAR ) );
    }
    if (NULL != pdwFlags)
    {
        *pdwFlags = dwFlags;
    }

ErrorExit:
    return dr;
}

/******************************************************************************/

DRM_RESULT DRM_API DRM_CLK_InitCheckSecureClock(
    IN const DRM_BYTE              rgbSecStoreInPswd [__CB_DECL(SHA_DIGEST_LEN)],
    IN       DRM_CRYPTO_CONTEXT   *pContext,
    IN       DRM_HDS_CONTEXT      *poHdsContext,
    IN OUT   DRM_BOOL             *pfClockSet,
    IN       DRM_SECSTORE_CONTEXT *poSecureStoreContext,
    IN       DRM_LICEVAL_CONTEXT  *poLicEvalContext )
{
    DRM_RESULT      dr = DRM_SUCCESS;
    DRM_DWORD       cbSecureData = 0;
    DRM_BOOL        fResetState = FALSE;
    DRM_BOOL        fEvalResult = FALSE;
    DRMSYSTEMTIME   oSystemTime;
    DRM_SECSTORE_CLOCK_DATA oClkData;

    ChkArg( pContext            != NULL
        && rgbSecStoreInPswd    != NULL
        && poHdsContext         != NULL
        && poSecureStoreContext != NULL
        && poLicEvalContext     != NULL
        && pfClockSet           != NULL );
    
    ZEROMEM(&oClkData, SIZEOF( oClkData ) );

    /*
     * There can be 3 situations.
     * 1. Data store CLK_EVER_SET is not set and Clock is reset = New Device
     * 2. Data store CLK_EVER_SET is set and Clock is reset = Go in Grace period.
     * 3. Clock is set and data store don't care = Normal operation.
     */
    
    /*Get reset state*/
    ChkDR( OEM_GetClockResetState( &fResetState ) );

    /* Read secure store */
    cbSecureData = SIZEOF(oClkData);
    dr = DRM_SST_GetData( poSecureStoreContext, 
                          &g_idSData, 
                          &g_idSDataPrev, 
                          rgbSecStoreInPswd, 
                          SECURE_STORE_GLOBAL_DATA,
                          poHdsContext,
                          (DRM_BYTE *) &oClkData, 
                          &cbSecureData );
    _PrepareSecureClockDataForReading( &oClkData );
    if ( fResetState )
    {
        /*State 1 or 2*/
        if ( DRM_SUCCEEDED(dr) 
          && (oClkData.flag & CLK_EVER_SET) )
        {
            /*Device is in (or going to be in) Grace Period*/

            ChkDR( OEM_SetClockResetState( FALSE ) );
            if ( oClkData.flag & CLK_LK_RSC_VALID )
            {
                DRMFILETIME filetime;
                UI64_TO_FILETIME( oClkData.LastKnownRealtimeSecureClock, filetime );
                if ( !OEM_FileTimeToSystemTime( &filetime, &oSystemTime ) )
                {
                    ChkDR( DRM_E_CLK_INVALID_DATE );
                }

                OEM_SetSystemTime( &oSystemTime );

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK               
                /* Write it in Anti Rollback Store. It must already be in writable state */
                poLicEvalContext->fGlobalSecStoreWritable = TRUE;
                DRM_LEVL_EvaluateExpression( poLicEvalContext, &g_dstrResetRollbackedClock, &fEvalResult );
#endif
            }
            if ( ( ( oClkData.flag & CLK_IN_GP_VALID ) == 0 ) 
              || ( !oClkData.fInGracePeriod ) )
            {
                oClkData.fInGracePeriod = TRUE;
                oClkData.flag |= CLK_IN_GP_VALID;
                MEMCPY( &oClkData.LastKnownGracePeriodStartTime, &oClkData.LastKnownRealtimeSecureClock, SIZEOF( oClkData.LastKnownGracePeriodStartTime ) );
                oClkData.flag |= CLK_LK_GP_VALID;
            }
        }
    }
    else
    {
        /*Normal Operation*/
        /*Get System Time and Put it in LastKnownRealtimeSecureClock */
        DRMFILETIME filetime;
        OEM_GetDeviceTime ( &filetime );
        FILETIME_TO_UI64( filetime, oClkData.LastKnownRealtimeSecureClock );
        oClkData.flag |= CLK_LK_RSC_VALID;
        oClkData.flag |= CLK_EVER_SET;
    }

 
    /*Write to secure store */
    cbSecureData = SIZEOF( oClkData );
    _PrepareSecureClockDataForWriting( &oClkData );
    ChkDR( DRM_SST_SetData( poSecureStoreContext,
                            &g_idSData,
                            &g_idSDataPrev,
                            rgbSecStoreInPswd,
                            SECURE_STORE_GLOBAL_DATA,
                            poHdsContext,
                            (DRM_BYTE *) &oClkData, 
                            cbSecureData ) );
    _PrepareSecureClockDataForReading( &oClkData );

    *pfClockSet = ( oClkData.flag & CLK_EVER_SET ) ? TRUE : FALSE ;        

ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\sel.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

const DRM_DWORD _DRM_Sel[8][64]={
    0x00000000,0x00000010,0x20000000,0x20000010,
    0x00010000,0x00010010,0x20010000,0x20010010,
    0x00000800,0x00000810,0x20000800,0x20000810,
    0x00010800,0x00010810,0x20010800,0x20010810,
    0x00000020,0x00000030,0x20000020,0x20000030,
    0x00010020,0x00010030,0x20010020,0x20010030,
    0x00000820,0x00000830,0x20000820,0x20000830,
    0x00010820,0x00010830,0x20010820,0x20010830,
    0x00080000,0x00080010,0x20080000,0x20080010,
    0x00090000,0x00090010,0x20090000,0x20090010,
    0x00080800,0x00080810,0x20080800,0x20080810,
    0x00090800,0x00090810,0x20090800,0x20090810,
    0x00080020,0x00080030,0x20080020,0x20080030,
    0x00090020,0x00090030,0x20090020,0x20090030,
    0x00080820,0x00080830,0x20080820,0x20080830,
    0x00090820,0x00090830,0x20090820,0x20090830,
    0x00000000,0x02000000,0x00002000,0x02002000,
    0x00200000,0x02200000,0x00202000,0x02202000,
    0x00000004,0x02000004,0x00002004,0x02002004,
    0x00200004,0x02200004,0x00202004,0x02202004,
    0x00000400,0x02000400,0x00002400,0x02002400,
    0x00200400,0x02200400,0x00202400,0x02202400,
    0x00000404,0x02000404,0x00002404,0x02002404,
    0x00200404,0x02200404,0x00202404,0x02202404,
    0x10000000,0x12000000,0x10002000,0x12002000,
    0x10200000,0x12200000,0x10202000,0x12202000,
    0x10000004,0x12000004,0x10002004,0x12002004,
    0x10200004,0x12200004,0x10202004,0x12202004,
    0x10000400,0x12000400,0x10002400,0x12002400,
    0x10200400,0x12200400,0x10202400,0x12202400,
    0x10000404,0x12000404,0x10002404,0x12002404,
    0x10200404,0x12200404,0x10202404,0x12202404,
    0x00000000,0x00000001,0x00040000,0x00040001,
    0x01000000,0x01000001,0x01040000,0x01040001,
    0x00000002,0x00000003,0x00040002,0x00040003,
    0x01000002,0x01000003,0x01040002,0x01040003,
    0x00000200,0x00000201,0x00040200,0x00040201,
    0x01000200,0x01000201,0x01040200,0x01040201,
    0x00000202,0x00000203,0x00040202,0x00040203,
    0x01000202,0x01000203,0x01040202,0x01040203,
    0x08000000,0x08000001,0x08040000,0x08040001,
    0x09000000,0x09000001,0x09040000,0x09040001,
    0x08000002,0x08000003,0x08040002,0x08040003,
    0x09000002,0x09000003,0x09040002,0x09040003,
    0x08000200,0x08000201,0x08040200,0x08040201,
    0x09000200,0x09000201,0x09040200,0x09040201,
    0x08000202,0x08000203,0x08040202,0x08040203,
    0x09000202,0x09000203,0x09040202,0x09040203,
    0x00000000,0x00100000,0x00000100,0x00100100,
    0x00000008,0x00100008,0x00000108,0x00100108,
    0x00001000,0x00101000,0x00001100,0x00101100,
    0x00001008,0x00101008,0x00001108,0x00101108,
    0x04000000,0x04100000,0x04000100,0x04100100,
    0x04000008,0x04100008,0x04000108,0x04100108,
    0x04001000,0x04101000,0x04001100,0x04101100,
    0x04001008,0x04101008,0x04001108,0x04101108,
    0x00020000,0x00120000,0x00020100,0x00120100,
    0x00020008,0x00120008,0x00020108,0x00120108,
    0x00021000,0x00121000,0x00021100,0x00121100,
    0x00021008,0x00121008,0x00021108,0x00121108,
    0x04020000,0x04120000,0x04020100,0x04120100,
    0x04020008,0x04120008,0x04020108,0x04120108,
    0x04021000,0x04121000,0x04021100,0x04121100,
    0x04021008,0x04121008,0x04021108,0x04121108,
    0x00000000,0x10000000,0x00010000,0x10010000,
    0x00000004,0x10000004,0x00010004,0x10010004,
    0x20000000,0x30000000,0x20010000,0x30010000,
    0x20000004,0x30000004,0x20010004,0x30010004,
    0x00100000,0x10100000,0x00110000,0x10110000,
    0x00100004,0x10100004,0x00110004,0x10110004,
    0x20100000,0x30100000,0x20110000,0x30110000,
    0x20100004,0x30100004,0x20110004,0x30110004,
    0x00001000,0x10001000,0x00011000,0x10011000,
    0x00001004,0x10001004,0x00011004,0x10011004,
    0x20001000,0x30001000,0x20011000,0x30011000,
    0x20001004,0x30001004,0x20011004,0x30011004,
    0x00101000,0x10101000,0x00111000,0x10111000,
    0x00101004,0x10101004,0x00111004,0x10111004,
    0x20101000,0x30101000,0x20111000,0x30111000,
    0x20101004,0x30101004,0x20111004,0x30111004,
    0x00000000,0x08000000,0x00000008,0x08000008,
    0x00000400,0x08000400,0x00000408,0x08000408,
    0x00020000,0x08020000,0x00020008,0x08020008,
    0x00020400,0x08020400,0x00020408,0x08020408,
    0x00000001,0x08000001,0x00000009,0x08000009,
    0x00000401,0x08000401,0x00000409,0x08000409,
    0x00020001,0x08020001,0x00020009,0x08020009,
    0x00020401,0x08020401,0x00020409,0x08020409,
    0x02000000,0x0A000000,0x02000008,0x0A000008,
    0x02000400,0x0A000400,0x02000408,0x0A000408,
    0x02020000,0x0A020000,0x02020008,0x0A020008,
    0x02020400,0x0A020400,0x02020408,0x0A020408,
    0x02000001,0x0A000001,0x02000009,0x0A000009,
    0x02000401,0x0A000401,0x02000409,0x0A000409,
    0x02020001,0x0A020001,0x02020009,0x0A020009,
    0x02020401,0x0A020401,0x02020409,0x0A020409,
    0x00000000,0x00000100,0x00080000,0x00080100,
    0x01000000,0x01000100,0x01080000,0x01080100,
    0x00000010,0x00000110,0x00080010,0x00080110,
    0x01000010,0x01000110,0x01080010,0x01080110,
    0x00200000,0x00200100,0x00280000,0x00280100,
    0x01200000,0x01200100,0x01280000,0x01280100,
    0x00200010,0x00200110,0x00280010,0x00280110,
    0x01200010,0x01200110,0x01280010,0x01280110,
    0x00000200,0x00000300,0x00080200,0x00080300,
    0x01000200,0x01000300,0x01080200,0x01080300,
    0x00000210,0x00000310,0x00080210,0x00080310,
    0x01000210,0x01000310,0x01080210,0x01080310,
    0x00200200,0x00200300,0x00280200,0x00280300,
    0x01200200,0x01200300,0x01280200,0x01280300,
    0x00200210,0x00200310,0x00280210,0x00280310,
    0x01200210,0x01200310,0x01280210,0x01280310,
    0x00000000,0x04000000,0x00040000,0x04040000,
    0x00000002,0x04000002,0x00040002,0x04040002,
    0x00002000,0x04002000,0x00042000,0x04042000,
    0x00002002,0x04002002,0x00042002,0x04042002,
    0x00000020,0x04000020,0x00040020,0x04040020,
    0x00000022,0x04000022,0x00040022,0x04040022,
    0x00002020,0x04002020,0x00042020,0x04042020,
    0x00002022,0x04002022,0x00042022,0x04042022,
    0x00000800,0x04000800,0x00040800,0x04040800,
    0x00000802,0x04000802,0x00040802,0x04040802,
    0x00002800,0x04002800,0x00042800,0x04042800,
    0x00002802,0x04002802,0x00042802,0x04042802,
    0x00000820,0x04000820,0x00040820,0x04040820,
    0x00000822,0x04000822,0x00040822,0x04040822,
    0x00002820,0x04002820,0x00042820,0x04042820,
    0x00002822,0x04002822,0x00042822,0x04042822,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\serverdevcert.c ===
// -------------------------------------------------------------------------------------
//
// Copyright (c) 2006 Microsoft Corporation
//
// serverdevcert.c
//
// Server API to create device certificate
// 
// -------------------------------------------------------------------------------------

#include <drmcommon.h>
#include <drmcontextsizes.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmxmlparser.h>
#include <drmdevcert.h>
#include <drmpkcrypto.h>
#include <oemimpl.h>

// I like C_ASSERT
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

// -------------------------------------------------------------------------------------
// ServerCreateDeviceCertificate
//
// Server API to create a Janus device certificate
//
//   * pwszDeviceUniqueId - unicode string with the device's unique id. For Xbox 360 
//   consoles this will be the console-id.
//   * cchDeviceUniqueId - size in characters of pwszDeviceUniqueId. Must be greater than 
//   zero and less than MAX_UNIQUEID_LEN.
//   * pbDevicePublicKey - pointer to device's public key.
//   * cbDevicePublicKey - size of pbDevicePublicKey in bytes. Must be exactly 
//   PK_ENC_PUBLIC_KEY_LEN.
//   * pbGroupCertTemplate - pointer to group cert template
//   * cbGroupCertTemplate - size of pbGroupCertTemplate. Must be greater than zero and 
//   less than MAX_DEVICE_CERT_TEMPLATE_SIZE.
//   * pbGroupCertPrivateKey - pointer to group cert private key
//   * cbGroupCertPrivateKey - size of pbGroupCertPrivateKey. Must be exactly 
//   PK_ENC_PRIVATE_KEY_LEN.
//   * pbFallbackSigningKey - pointer to fallback private key.
//   * cbFallbackSigningKey - size of pbFallbackSigningKey. Must be exactly 
//   PK_ENC_PRIVATE_KEY_LEN.
//   * pbDeviceCertificate - OUT: pointer to buffer to receive the device certificate.
//   * pcbDeviceCertificate - IN: size of buffer pointed to pbDeviceCertificate. Must be 
//   greater or equal to MAX_DEVICE_CERT_SIZE. OUT: size of device certificate written to 
//   pbDeviceCertificate in bytes.
//
// Returns:
//   DRM_SUCCESS(0) if succeeded and a device certificate was written to 
//   pbDeviceCertificate. A DRM_RESULT error will be returned otherwise.
//
// -------------------------------------------------------------------------------------
DRM_RESULT __stdcall ServerCreateDeviceCertificate(
    IN     DRM_WCHAR*  pwszDeviceUniqueId,
    IN     DRM_DWORD   cchDeviceUniqueId,
    IN     DRM_BYTE*   pbDevicePublicKey,
    IN     DRM_DWORD   cbDevicePublicKey,
    IN     DRM_BYTE*   pbGroupCertTemplate,
    IN     DRM_DWORD   cbGroupCertTemplate,
    IN     DRM_BYTE*   pbGroupCertPrivateKey,
    IN     DRM_DWORD   cbGroupCertPrivateKey,
    IN     DRM_BYTE*   pbFallbackSigningKey,
    IN     DRM_DWORD   cbFallbackSigningKey,
    OUT    DRM_BYTE*   pbDeviceCertificate,
    IN OUT DRM_DWORD*  pcbDeviceCertificate
)
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_DWORD        cbDevCert     = 0;
    DRM_DWORD        cchMaxDevCert = 0;
    DRM_CONST_STRING dstrCertNodeData = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataNodeData = EMPTY_DRM_STRING; 
    DRM_CONST_STRING dstrInsert       = EMPTY_DRM_STRING;
    DRM_CRYPTO_CONTEXT contextCRYP;
    DRM_STRING       dstrDevCert;
    
    /*
     * Check parameters
     */

    C_ASSERT(sizeof(PRIVKEY) == PK_ENC_PRIVATE_KEY_LEN);
    ChkArg(pwszDeviceUniqueId != NULL);
    ChkArg(cchDeviceUniqueId > 0 && cchDeviceUniqueId < MAX_UNIQUEID_LEN);
    ChkArg(pbDevicePublicKey != NULL);
    ChkArg(cbDevicePublicKey == PK_ENC_PUBLIC_KEY_LEN);
    ChkArg(pbGroupCertTemplate != NULL);
    ChkArg(cbGroupCertTemplate > 0 && cbGroupCertTemplate <= MAX_DEVICE_CERT_TEMPLATE_SIZE);
    ChkArg(pbGroupCertPrivateKey != NULL);
    ChkArg(cbGroupCertPrivateKey == PK_ENC_PRIVATE_KEY_LEN);
    ChkArg(pbFallbackSigningKey != NULL);
    ChkArg(cbFallbackSigningKey == PK_ENC_PRIVATE_KEY_LEN);
    ChkArg(pbDeviceCertificate != NULL);
    ChkArg(pcbDeviceCertificate != NULL && *pcbDeviceCertificate >= MAX_DEVICE_CERT_SIZE);

    ZEROMEM(&contextCRYP, SIZEOF(contextCRYP));
    DSTR_FROM_PB(&dstrDevCert, pbDeviceCertificate, *pcbDeviceCertificate);
    cchMaxDevCert = dstrDevCert.cchString;

    /* 
    ** Get devcert template. 
    */
    MEMCPY(dstrDevCert.pwszString, pbGroupCertTemplate, cbGroupCertTemplate);
    dstrDevCert.cchString = cbGroupCertTemplate / SIZEOF( DRM_WCHAR );

    /* 
    ** Don't bother to verify the signature of the DAC and GC certificates.
    ** If they are bad there is no recovery anyway.  Upstream applications will 
    ** (PC and WMRM) will validate this before issuing licenses anyway.
    */
    
    /* calc size needed */
    dstrDevCert.cchString = dstrDevCert.cchString
                              + cchDeviceUniqueId                                               /* size of B64 encoded unique id */
                              + CCH_BASE64_EQUIV(PK_ENC_PUBLIC_KEY_LEN)                   /* size of B64 encoded Device Pubkey */
//                               + CCH_BASE64_EQUIV(SIZEOF(PRIVKEY) + PK_ENC_CIPHERTEXT_LEN) /* size of B64 encoded encrypted Device Privkey */
                              + CCH_BASE64_EQUIV(SIZEOF(PKCERT))                          /* size of B64 encoded PKCERT */
#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
                              + CCH_BASE64_EQUIV(SHA_DIGEST_LEN)                          /* size of B64 encoded symmetric signature of device/data node */
#endif
                              + CCH_BASE64_EQUIV(PK_ENC_SIGNATURE_LEN);                   /* size of B64 encoded signature of device/data node */
                              
    if ( cchMaxDevCert < dstrDevCert.cchString )
    {
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    /* 
    ** fill in uniqueID in "DEVCERT/CERTIFICATE type="DEVICE"/DATA/UNIQUEID" 
    */
    ChkDR(DRM_DCP_GetAttribute((DRM_CONST_STRING*)&dstrDevCert, DRM_DEVCERT_SERIALNUMBER, NULL, &dstrInsert));
    ChkDR(DRM_UTL_StringRemoveSubString(&dstrDevCert, &dstrInsert));
    ChkDR(DRM_UTL_StringInsertBlankSubString( &dstrDevCert,
            (DRM_DWORD)(dstrInsert.pwszString - dstrDevCert.pwszString),
            cchDeviceUniqueId));
    MEMCPY((DRM_BYTE*)dstrInsert.pwszString, pwszDeviceUniqueId, cchDeviceUniqueId * sizeof(DRM_WCHAR));

    /* 
    ** Fill in Pubkey in DEVCERT/CERTIFICATE type="DEVICE"/DATA/PUBLICKEY 
    */
    {
        PUBKEY           GCPubkey = { 0 };       /* parse from GC <DATA>/<PUBLICKEY> */
        DRM_CONST_STRING dstrPubkey  = EMPTY_DRM_STRING; 
        DRM_DWORD        cbDestination = SIZEOF(GCPubkey);
        DRM_BYTE        *pbTmp = NULL;

        /* locate GC Pubkey */
        ChkDR(DRM_DCP_GetAttribute((DRM_CONST_STRING*)&dstrDevCert, DRM_DEVCERT_GROUPCERTPUBKEY, NULL, &dstrInsert));
        DRM_B64_DecodeW(&dstrInsert, &cbDestination, (DRM_BYTE*)&GCPubkey, 0);

        /* Make room for Device Pubkey in DEVCERT/CERTIFICATE type="DEVICE"/DATA/PUBKEY*/
        ChkDR(DRM_DCP_GetAttribute((DRM_CONST_STRING*)&dstrDevCert, DRM_DEVCERT_DEVICEPUBKEY, NULL, &dstrPubkey));
        ChkDR(DRM_UTL_StringRemoveSubString(&dstrDevCert, &dstrPubkey));        
        ChkDR(DRM_UTL_StringInsertBlankSubString(
                &dstrDevCert,
                (DRM_DWORD)(dstrPubkey.pwszString - dstrDevCert.pwszString), 
                CCH_BASE64_EQUIV(PK_ENC_PUBLIC_KEY_LEN)));

        /* Copy public key from parameter */
        dstrPubkey.cchString = CCH_BASE64_EQUIV(PK_ENC_PUBLIC_KEY_LEN);
        MEMCPY((DRM_BYTE*)dstrPubkey.pwszString, pbDevicePublicKey, PK_ENC_PUBLIC_KEY_LEN);

#if 0
        /* Make room for Device Privkey in DEVCERT/CERTIFICATE type="DEVICE"/DATA/KEYDATA */
        ChkDR(DRM_DCP_GetAttribute((DRM_CONST_STRING*)&dstrDevCert, DRM_DEVCERT_DEVICEPRIVKEY, NULL, &dstrPrivkey));
        ChkDR(DRM_UTL_StringRemoveSubString(&dstrDevCert, &dstrPrivkey));

        dstrPrivkey.cchString = CCH_BASE64_EQUIV(SIZEOF(PRIVKEY));              
        ChkDR(DRM_UTL_StringInsertBlankSubString(
                &dstrDevCert,
                (DRM_DWORD)(dstrPrivkey.pwszString - dstrDevCert.pwszString),
                dstrPrivkey.cchString ) );

        /* generate key pair */    
        ChkDR(DRM_PK_GenKeyPair(contextCRYP.rgbCryptoContext, (PUBKEY*)(dstrPubkey.pwszString), (PRIVKEY*)(dstrPrivkey.pwszString)));
#endif
        
        /* Save Device Pubkey in fallback cert
        */
        {
            PKCERT cert={0};
            DRM_CONST_STRING dstrSecurityVersion = EMPTY_DRM_STRING;

            /* locate FALLBACK/SECURITYVERSION */
            ChkDR(DRM_XML_GetSubNode((DRM_CONST_STRING*)&dstrDevCert, &g_dstrFallBack, NULL, NULL, 0, NULL, &dstrCertNodeData, 1));
            ChkDR(DRM_XML_GetNode( 
                    &dstrCertNodeData, 
                    &g_dstrTagDataSecVer, 
                    NULL, 
                    NULL,
                    0, 
                    NULL, 
                    &dstrInsert));
            {
                DRM_WORD rgwVersion[VERSION_LEN];
                DRM_INT  i = 0;
                ChkDR( DRM_UTL_GetVersionFromString( dstrInsert.pwszString, dstrInsert.cchString, rgwVersion ) );
                for( i=0; i < VERSION_LEN; i++ )
                {
                    PUT_BYTE(cert.pk.version, i, (DRM_BYTE)rgwVersion[i] );
                }
            }

            /* Make room and sign the data node with GC Privkey */
            ChkDR(DRM_XML_GetSubNode( 
                    (DRM_CONST_STRING*)&dstrDevCert, 
                    &g_dstrFallBack, 
                    NULL, 
                    NULL, 
                    0, 
                    NULL, 
                    &dstrCertNodeData, 
                    1));

            ChkDR(DRM_XML_GetNode( 
                    &dstrCertNodeData, 
                    &g_dstrTagCertificate, 
                    &g_dstrRootSigValueVersionTag, 
                    &g_dstrRootSigValueVersionVal, 
                    0, 
                    NULL, 
                    &dstrInsert));

            ChkDR(DRM_UTL_StringRemoveSubString(&dstrDevCert, &dstrInsert));
            ChkDR(DRM_UTL_StringInsertBlankSubString(
                    &dstrDevCert,
                    (DRM_DWORD)(dstrInsert.pwszString - dstrDevCert.pwszString),
                    CCH_BASE64_EQUIV(SIZEOF(PKCERT))));
            dstrInsert.cchString = CCH_BASE64_EQUIV(PK_ENC_SIGNATURE_LEN);

            MEMCPY(&cert.pk.pk, PB_DSTR(&dstrPubkey), SIZEOF(PUBKEY));

            ChkDR(DRM_PK_Sign( 
                    contextCRYP.rgbCryptoContext, 
                    (PRIVKEY*) pbFallbackSigningKey,
                    (DRM_BYTE *)&cert.pk, 
                    SIZEOF(PK), 
                    cert.sign));

            MEMCPY( PB_DSTR(&dstrInsert), &cert, SIZEOF(PKCERT));

            /* B64 encode in place */
            dstrInsert.cchString = CCH_BASE64_EQUIV(SIZEOF(PKCERT));
            ChkDR(DRM_B64_EncodeW( 
                    PB_DSTR(&dstrInsert), 
                    SIZEOF(PKCERT), 
                    (DRM_WCHAR*)dstrInsert.pwszString, 
                    &dstrInsert.cchString, 
                    0));
        }

        /* B64 encode pubkey in place */
        ChkDR(DRM_B64_EncodeW( 
                PB_DSTR(&dstrPubkey), 
                SIZEOF(PUBKEY), 
                (DRM_WCHAR*)dstrPubkey.pwszString,
                &dstrPubkey.cchString,
                0) );
        
#if 0
        ChkDR( DRM_PK_SymmetricCrypt( pbGroupCertPrivateKey,
                                      SIZEOF(PRIVKEY),
                                      SIZEOF(PRIVKEY),
                                      PB_DSTR(&dstrPrivkey), 
                                      0,
                                      NULL ) );

        ChkDR(DRM_B64_EncodeW(
                PB_DSTR(&dstrPrivkey), 
                SIZEOF(PRIVKEY),
                (DRM_WCHAR*)dstrPrivkey.pwszString, 
                &dstrPrivkey.cchString, 
                0));        
#endif

        /* Make room and sign the data node with GC Privkey */
        ChkDR(DRM_XML_GetSubNode( 
                (DRM_CONST_STRING*)&dstrDevCert, 
                &g_dstrTagCertificate, 
                &g_dstrAttributeType, 
                &g_dstrTagDevice, 
                0, 
                NULL, 
                &dstrCertNodeData, 
                1));
        
        ChkDR(DRM_XML_GetNode( 
                &dstrCertNodeData, 
                &g_dstrTagMSDRMSignature, 
                NULL, 
                NULL, 
                0, 
                NULL, 
                &dstrInsert));

        ChkDR(DRM_UTL_StringRemoveSubString(&dstrDevCert, &dstrInsert));
        ChkDR(DRM_UTL_StringInsertBlankSubString(
                &dstrDevCert,
                (DRM_DWORD)(dstrInsert.pwszString - dstrDevCert.pwszString), 
                CCH_BASE64_EQUIV(PK_ENC_SIGNATURE_LEN)));
        dstrInsert.cchString = CCH_BASE64_EQUIV(PK_ENC_SIGNATURE_LEN);

        /* sign the devcert with GC privkey */
        ChkDR(DRM_XML_GetNode(&dstrCertNodeData, &g_dstrTagData, NULL, NULL, 0, &dstrDataNodeData, NULL));
        
        ChkDR(DRM_PK_Sign( 
                contextCRYP.rgbCryptoContext,
                (PRIVKEY*)pbGroupCertPrivateKey,
                PB_DSTR(&dstrDataNodeData),
                CB_DSTR(&dstrDataNodeData),
                PB_DSTR(&dstrInsert)));        

        /* B64 encode the signature in place */
        ChkDR(DRM_B64_EncodeW( 
                PB_DSTR(&dstrInsert), 
                PK_ENC_SIGNATURE_LEN, 
                (DRM_WCHAR*)dstrInsert.pwszString, 
                &dstrInsert.cchString, 
                0));

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
        /*
        ** Create the symmetric signature for the device to use 
        */
        ChkDR(DRM_XML_GetSubNode( (DRM_CONST_STRING*)&dstrDevCert, 
                                  &g_dstrTagCertificate, 
                                  &g_dstrAttributeType, 
                                  &g_dstrTagDevice, 
                                   0, 
                                   NULL, 
                                  &dstrCertNodeData, 
                                  1));

        ChkDR(DRM_XML_GetNode( &dstrCertNodeData,
                               &g_dstrTagSymSig, 
                                NULL, 
                                NULL, 
                                0, 
                                NULL, 
                               &dstrInsert));

        ChkDR(DRM_UTL_StringRemoveSubString(&dstrDevCert, &dstrInsert));
        ChkDR(DRM_UTL_StringInsertBlankSubString( &dstrDevCert,
                                      (DRM_DWORD)(dstrInsert.pwszString - dstrDevCert.pwszString), 
                                                 CCH_BASE64_EQUIV(SHA_DIGEST_LEN) ) );
        
        dstrInsert.cchString = CCH_BASE64_EQUIV(SHA_DIGEST_LEN);

        ChkDR(DRM_PK_SymmetricSign( pbGroupCertPrivateKey,
                                    SIZEOF( PRIVKEY ),
                                    PB_DSTR(&dstrDataNodeData),
                                    CB_DSTR(&dstrDataNodeData),
                                    PB_DSTR(&dstrInsert) ) );

        /* B64 encode the signature in place */
        ChkDR(DRM_B64_EncodeW( PB_DSTR(&dstrInsert), 
                               SHA_DIGEST_LEN, 
                   (DRM_WCHAR*)dstrInsert.pwszString, 
                              &dstrInsert.cchString, 
                               0));
#endif
    }

    /* certificate is done. Update output size parameter */
    
    *pcbDeviceCertificate = CB_DSTR( &dstrDevCert );
        
ErrorExit:    

    return dr;
}

// -------------------------------------------------------------------------------------
// ServerCreateDeviceKeyPair
//
// Server API to create a device key pair for test-only purposes.
//
//   * pbPublicKey - OUT: pointer to buffer to receive public key.
//   * pcbPublicKey - IN: size of buffer pointed by pbPublicKey. Must be greater or equal 
//   to PK_ENC_PUBLIC_KEY_LEN.
//   * pbPrivateKey - OUT: pointer to buffer to receive private key.
//   * pcbPrivateKey - IN: size of buffer pointed by pbPrivateKey. Must be greater or 
//   equal to PK_ENC_PRIVATE_KEY_LEN.
//
// Returns:
//   DRM_SUCCESS(0) if succeeded and the keys were written to pbPublicKey and 
//   pbPrivateKey. A DRM_RESULT error will be returned otherwise.
// -------------------------------------------------------------------------------------
DRM_RESULT __stdcall ServerCreateDeviceKeyPair(
    OUT    DRM_BYTE*   pbPublicKey,
    IN OUT DRM_DWORD*  pcbPublicKey,
    OUT    DRM_BYTE*   pbPrivateKey,
    IN OUT DRM_DWORD*  pcbPrivateKey
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CRYPTO_CONTEXT contextCRYP;

    ChkArg(pbPublicKey != NULL);
    ChkArg(pcbPublicKey != NULL && *pcbPublicKey >= PK_ENC_PUBLIC_KEY_LEN);
    ChkArg(pbPrivateKey != NULL);
    ChkArg(pcbPrivateKey != NULL && *pcbPrivateKey >= PK_ENC_PRIVATE_KEY_LEN);

    ZEROMEM(&contextCRYP, SIZEOF(contextCRYP));

    ChkDR(DRM_PK_GenKeyPair(
            contextCRYP.rgbCryptoContext, 
            (PUBKEY*)pbPublicKey, 
            (PRIVKEY*)pbPrivateKey));

    *pcbPublicKey  = PK_ENC_PUBLIC_KEY_LEN;
    *pcbPrivateKey = PK_ENC_PRIVATE_KEY_LEN;

ErrorExit:

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\secureclockresponse.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmlicenseparser.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <drmblackbox.h>
#include <drmlicacq.h>
#include <drmexpreval.h>
#include <drmsha1.h>
#include <oemimpl.h>
#include <drmsecureclock.h>
#include <drmcrt.h>

#define ONE_MIN_IN_FILETIME 10000000*60

/******************************************************************************/

DRM_RESULT DRM_API DRM_CLK_ProcessResponse(
    IN const PUBKEY                *ppubkeySecureClockServer,
    IN       DRM_BYTE              *pbResponse,
    IN       DRM_DWORD              cbResponse,
    IN const DRM_BYTE               rgbSecStoreInPswd [__CB_DECL(SHA_DIGEST_LEN)],
    OUT      DRM_RESULT            *pResult,
    IN       DRM_CRYPTO_CONTEXT    *pContext,
    IN       DRM_HDS_CONTEXT       *poHdsContext,
    IN       DRM_SECSTORE_CONTEXT  *poSecureStoreContext,
    IN       DRM_LICEVAL_CONTEXT   *poLicEvalContext )
{
    DRM_RESULT       dr          = DRM_SUCCESS;
    DRM_DWORD        cbDecoded   = 0;    
    DRM_DWORD        cbLGPUBKEY  = SIZEOF(PUBKEY);
    DRM_LONG         lResult     = 0;
    DRM_DWORD        cbSecureData= 0;
    DRM_BOOL         fEvalResult = FALSE;
    TOKEN            Token;
    DRM_UINT64       u64DRMTime;
    DRMSYSTEMTIME    oSystemTime;
    DRMFILETIME      filetime;
    DRM_TID          tid;

    DRM_CONST_STRING dstrResponse          = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrData              = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSign              = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrCert              = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrValue             = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrErrorNodes        = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSecureClockPubKey = EMPTY_DRM_STRING;
    DRM_SUBSTRING    dasstrEncoded         = { 0 };
    DRM_SECSTORE_CLOCK_DATA oClkData       = { 0 };
    DRM_BYTE *pbAligned                     = NULL;
    DRM_DWORD cbAligned                     = 0;
    

    DRM_PROFILING_ENTER_SCOPE(L"DRM_CLK_ProcessResponse", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    ChkArg( pbResponse           != NULL
         && pContext             != NULL
         && cbResponse            > 0 
         && pResult              != NULL
         && rgbSecStoreInPswd    != NULL 
         && poHdsContext         != NULL
         && poSecureStoreContext != NULL
         && poLicEvalContext     != NULL );
    
    *pResult = DRM_SUCCESS;
    dasstrEncoded.m_ich = 0;
    dasstrEncoded.m_cch = cbResponse;
    cbDecoded           = cbResponse;

    ChkDR(DRM_B64_DecodeA((DRM_CHAR *) pbResponse,
                          &dasstrEncoded, 
                          &cbDecoded, 
                           NULL, 
                           DRM_BASE64_DECODE_IN_PLACE ) );

    ChkDR( DRM_UTL_EnsureDataAlignment( pbResponse, cbResponse, &pbAligned, &cbAligned, SIZEOF( DRM_DWORD_PTR ) / CB_NATIVE_BYTE, NULL ) );

    if( cbAligned < cbDecoded )
    {
        /* Shouldn't ever happen since the B64 decode gives us lots of extra slack */
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    if( pbAligned != pbResponse )
    {
        DRM_BYT_MoveBytes( pbAligned, 0, pbResponse, 0, cbDecoded );
        pbResponse = pbAligned;
    }
    

    /* Decode this ANSI encoded blob in place */

    DSTR_FROM_PB(&dstrResponse, pbResponse + dasstrEncoded.m_ich, cbDecoded);

    ChkDR( DRM_XML_GetNode( 
            &dstrResponse, 
            &g_dstrTagDRMReqRoot, 
            NULL, 
            NULL, 
            0, 
            NULL, 
            &dstrValue ) );



    if ( DRM_SUCCEEDED( DRM_XML_GetNode( &dstrValue, &g_dstrTagError,  NULL, NULL, 0, NULL, &dstrErrorNodes )  )  )
    {
        /* We have error code */
        ChkDR( wcsntol( dstrErrorNodes.pwszString, dstrErrorNodes.cchString, pResult ) );
        goto ErrorExit;    
    }
    else
    {
        if (dr == DRM_E_XMLNOTFOUND)
        {
            dr = DRM_SUCCESS; 
        }
        else
        {
            ChkDR(dr);  /* other errors */
        }
     }

#if DRM_SECURE_CLOCK_RESPONSE_TEST_MODE == 0
    /*Here verify the response*/
    /*
    **  Extract the signature, data and cert chain nodes from the response
    */
    ChkDR( DRM_XML_GetNode( &dstrValue, &g_dstrTagSignature,        NULL, NULL, 0, &dstrSign, NULL  ) );
    ChkDR( DRM_XML_GetNode( &dstrValue, &g_dstrTagCertificateChain, NULL, NULL, 0, &dstrCert, NULL ) );
    ChkDR( DRM_XML_GetNode( &dstrValue, &g_dstrTagData,             NULL, NULL, 0, &dstrData, NULL  ) );

    /*
    **  Extract the public key from the devcert
    */    

    MEMCPY( pContext->pubKey.y, ppubkeySecureClockServer, SIZEOF( PUBKEY ) );
    ChkDR( DRM_UTL_VerifyXMLSignature( &dstrData, &dstrSign, &dstrCert, TRUE, TRUE, WM_DRM_ROOTPUBKEY_CLK, poLicEvalContext ) );  
#endif

    /* Open secure stote and Read the Values If it cant be opened, FAIL
       as we dont have any TID to verify with */
    ZEROMEM(&oClkData, SIZEOF(oClkData));
    cbSecureData = SIZEOF(oClkData);
  
    ChkDR( DRM_SST_GetData(
            poSecureStoreContext, 
            &g_idSData, 
            &g_idSDataPrev, 
            rgbSecStoreInPswd, 
            SECURE_STORE_GLOBAL_DATA,
            poHdsContext,
            (DRM_BYTE *) &oClkData, 
            &cbSecureData) );
    _PrepareSecureClockDataForReading( &oClkData );
    
    ChkDR( DRM_XML_GetNode( 
            &dstrValue, 
            &g_dstrTagData, 
            NULL, 
            NULL, 
            0, 
            NULL, 
            &dstrData ) );

#if DRM_SECURE_CLOCK_RESPONSE_TEST_MODE == 0
    /*Get TID, Decode it and compare it with stored TID*/
    ChkDR( DRM_XML_GetNode( 
            &dstrData, 
            &g_dstrTagTID, 
            NULL, 
            NULL, 
            0, 
            NULL, 
            &dstrValue ) );

    cbDecoded = dstrValue.cchString;

    ChkDR(DRM_B64_DecodeW(
            (const DRM_CONST_STRING *)&dstrValue, 
                                      &cbDecoded, 
                          (DRM_BYTE *)&tid, 
                                       0));

    if (cbDecoded != SIZEOF(DRM_TID))
    {
        ChkDR( DRM_E_CLK_INVALID_RESPONSE );
    }

    if (MEMCMP(&tid, &oClkData.tid, SIZEOF(DRM_TID)) != 0 )
    {
        ChkDR( DRM_E_CLK_INVALID_RESPONSE );
    }

    /*Check whether the response is received within 5 minutes */

    /*Get Time and store it in secure store. Response should not come after 5 min of this time*/
    OEM_GetDeviceDateTime( &oSystemTime );
    if ( !OEM_SystemTimeToFileTime( &oSystemTime, &filetime ) )
    {
        ChkDR( DRM_E_CLK_INVALID_DATE );
    }

    FILETIME_TO_UI64( filetime, u64DRMTime );

    if ( !( oClkData.flag & CLK_CHALLENGETIME_VALID )
      || DRM_UI64Les( u64DRMTime, oClkData.ChallengeTime )
      || DRM_UI64Les( DRM_UI64Add( oClkData.ChallengeTime, DRM_UI64Mul(DRM_UI64(5),DRM_UI64(ONE_MIN_IN_FILETIME))), u64DRMTime ) )
    {
        ChkDR( DRM_E_CLK_INVALID_RESPONSE );
    }
#endif /* ! DRM_SECURE_CLOCK_RESPONSE_TEST_MODE */

    ChkDR( DRM_XML_GetNode( 
            &dstrData, 
            &g_dstrTagGmtTime, 
            NULL, 
            NULL, 
            0, 
            NULL, 
            &dstrValue ) );

    ChkDR( ExtractDateToken( &dstrValue, &Token ) );
    MEMCPY(&oClkData.LastKnownGoodSecureClock, &Token.val.u64DateTime, SIZEOF(DRM_UINT64));
    oClkData.flag |= CLK_LK_GSC_VALID;

    MEMCPY(&oClkData.LastKnownRealtimeSecureClock, &Token.val.u64DateTime, SIZEOF(DRM_UINT64));
    oClkData.flag |= CLK_LK_RSC_VALID;

    oClkData.fInGracePeriod = FALSE;
    oClkData.flag |= CLK_IN_GP_VALID;
   
    ZEROMEM(&oClkData.LastKnownGracePeriodStartTime, SIZEOF( oClkData.LastKnownGracePeriodStartTime ) );
    oClkData.flag |= CLK_LK_GP_VALID;

    ChkDR( DRM_XML_GetNode( 
            &dstrData, 
            &g_dstrTagRefreshDate, 
            NULL, 
            NULL, 
            0, 
            NULL, 
            &dstrValue ) );

    ChkDR( ExtractDateToken( &dstrValue, &Token ) );
    MEMCPY(&oClkData.RefreshDate, &Token.val.u64DateTime, SIZEOF(DRM_UINT64));
    
    oClkData.flag |= CLK_REFRESHDATE_VALID;
    oClkData.flag |= CLK_EVER_SET;


    /*Write it to secure store*/
    cbSecureData = SIZEOF( oClkData );
    
    _PrepareSecureClockDataForWriting( &oClkData );
    ChkDR( DRM_SST_SetData( 
            poSecureStoreContext,
            &g_idSData,
            &g_idSDataPrev,
            rgbSecStoreInPswd,
            SECURE_STORE_GLOBAL_DATA,
            poHdsContext,
            (DRM_BYTE *) &oClkData, 
            cbSecureData ) );

    _PrepareSecureClockDataForReading( &oClkData );

    ChkDR( OEM_SetClockResetState( FALSE ) );
    UI64_TO_FILETIME( oClkData.LastKnownGoodSecureClock, filetime );
    if (! OEM_FileTimeToSystemTime( &filetime, &oSystemTime ) )
    {
        ChkDR( DRM_E_CLK_INVALID_RESPONSE );
    }

    OEM_SetSystemTime( &oSystemTime );

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK    
    /* Write it in Anti Rollback Store. It must already be in writable state */
    poLicEvalContext->fGlobalSecStoreWritable = TRUE;
    DRM_LEVL_EvaluateExpression( poLicEvalContext, &g_dstrResetRollbackedClock, &fEvalResult );
#endif

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_CLK_ProcessResponse", g_pwszLeavingFunction);

    if( DRM_FAILED( dr ) )
    {
        dr = DRM_E_CLK_INVALID_RESPONSE;
    }
    return( dr );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\tipatch.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "tipatch.h"
         
unsigned long DRM_CHARS2LONG(unsigned char *cc)
{   
    unsigned long rtnVal;
    
    rtnVal   =  ((unsigned long)cc[0])       |
               (((unsigned long)cc[1])<< 8)  |
               (((unsigned long)cc[2])<<16)  |
               (((unsigned long)cc[3])<<24)  ;
    return rtnVal;         
}

void DRM_LONG2CHARS(long val, unsigned char *aa)
{   
    aa[0] =  val      & 0xFF;
    aa[1] = (val>> 8) & 0xFF;
    aa[2] = (val>>16) & 0xFF;
    aa[3] = (val>>24) & 0xFF;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\spb.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

const DRM_DWORD _DRM_Spbox[8][64] = {
    0x02080800,0x00080000,0x02000002,0x02080802,
    0x02000000,0x00080802,0x00080002,0x02000002,
    0x00080802,0x02080800,0x02080000,0x00000802,
    0x02000802,0x02000000,0x00000000,0x00080002,
    0x00080000,0x00000002,0x02000800,0x00080800,
    0x02080802,0x02080000,0x00000802,0x02000800,
    0x00000002,0x00000800,0x00080800,0x02080002,
    0x00000800,0x02000802,0x02080002,0x00000000,
    0x00000000,0x02080802,0x02000800,0x00080002,
    0x02080800,0x00080000,0x00000802,0x02000800,
    0x02080002,0x00000800,0x00080800,0x02000002,
    0x00080802,0x00000002,0x02000002,0x02080000,
    0x02080802,0x00080800,0x02080000,0x02000802,
    0x02000000,0x00000802,0x00080002,0x00000000,
    0x00080000,0x02000000,0x02000802,0x02080800,
    0x00000002,0x02080002,0x00000800,0x00080802,
    0x40108010,0x00000000,0x00108000,0x40100000,
    0x40000010,0x00008010,0x40008000,0x00108000,
    0x00008000,0x40100010,0x00000010,0x40008000,
    0x00100010,0x40108000,0x40100000,0x00000010,
    0x00100000,0x40008010,0x40100010,0x00008000,
    0x00108010,0x40000000,0x00000000,0x00100010,
    0x40008010,0x00108010,0x40108000,0x40000010,
    0x40000000,0x00100000,0x00008010,0x40108010,
    0x00100010,0x40108000,0x40008000,0x00108010,
    0x40108010,0x00100010,0x40000010,0x00000000,
    0x40000000,0x00008010,0x00100000,0x40100010,
    0x00008000,0x40000000,0x00108010,0x40008010,
    0x40108000,0x00008000,0x00000000,0x40000010,
    0x00000010,0x40108010,0x00108000,0x40100000,
    0x40100010,0x00100000,0x00008010,0x40008000,
    0x40008010,0x00000010,0x40100000,0x00108000,
    0x04000001,0x04040100,0x00000100,0x04000101,
    0x00040001,0x04000000,0x04000101,0x00040100,
    0x04000100,0x00040000,0x04040000,0x00000001,
    0x04040101,0x00000101,0x00000001,0x04040001,
    0x00000000,0x00040001,0x04040100,0x00000100,
    0x00000101,0x04040101,0x00040000,0x04000001,
    0x04040001,0x04000100,0x00040101,0x04040000,
    0x00040100,0x00000000,0x04000000,0x00040101,
    0x04040100,0x00000100,0x00000001,0x00040000,
    0x00000101,0x00040001,0x04040000,0x04000101,
    0x00000000,0x04040100,0x00040100,0x04040001,
    0x00040001,0x04000000,0x04040101,0x00000001,
    0x00040101,0x04000001,0x04000000,0x04040101,
    0x00040000,0x04000100,0x04000101,0x00040100,
    0x04000100,0x00000000,0x04040001,0x00000101,
    0x04000001,0x00040101,0x00000100,0x04040000,
    0x00401008,0x10001000,0x00000008,0x10401008,
    0x00000000,0x10400000,0x10001008,0x00400008,
    0x10401000,0x10000008,0x10000000,0x00001008,
    0x10000008,0x00401008,0x00400000,0x10000000,
    0x10400008,0x00401000,0x00001000,0x00000008,
    0x00401000,0x10001008,0x10400000,0x00001000,
    0x00001008,0x00000000,0x00400008,0x10401000,
    0x10001000,0x10400008,0x10401008,0x00400000,
    0x10400008,0x00001008,0x00400000,0x10000008,
    0x00401000,0x10001000,0x00000008,0x10400000,
    0x10001008,0x00000000,0x00001000,0x00400008,
    0x00000000,0x10400008,0x10401000,0x00001000,
    0x10000000,0x10401008,0x00401008,0x00400000,
    0x10401008,0x00000008,0x10001000,0x00401008,
    0x00400008,0x00401000,0x10400000,0x10001008,
    0x00001008,0x10000000,0x10000008,0x10401000,
    0x08000000,0x00010000,0x00000400,0x08010420,
    0x08010020,0x08000400,0x00010420,0x08010000,
    0x00010000,0x00000020,0x08000020,0x00010400,
    0x08000420,0x08010020,0x08010400,0x00000000,
    0x00010400,0x08000000,0x00010020,0x00000420,
    0x08000400,0x00010420,0x00000000,0x08000020,
    0x00000020,0x08000420,0x08010420,0x00010020,
    0x08010000,0x00000400,0x00000420,0x08010400,
    0x08010400,0x08000420,0x00010020,0x08010000,
    0x00010000,0x00000020,0x08000020,0x08000400,
    0x08000000,0x00010400,0x08010420,0x00000000,
    0x00010420,0x08000000,0x00000400,0x00010020,
    0x08000420,0x00000400,0x00000000,0x08010420,
    0x08010020,0x08010400,0x00000420,0x00010000,
    0x00010400,0x08010020,0x08000400,0x00000420,
    0x00000020,0x00010420,0x08010000,0x08000020,
    0x80000040,0x00200040,0x00000000,0x80202000,
    0x00200040,0x00002000,0x80002040,0x00200000,
    0x00002040,0x80202040,0x00202000,0x80000000,
    0x80002000,0x80000040,0x80200000,0x00202040,
    0x00200000,0x80002040,0x80200040,0x00000000,
    0x00002000,0x00000040,0x80202000,0x80200040,
    0x80202040,0x80200000,0x80000000,0x00002040,
    0x00000040,0x00202000,0x00202040,0x80002000,
    0x00002040,0x80000000,0x80002000,0x00202040,
    0x80202000,0x00200040,0x00000000,0x80002000,
    0x80000000,0x00002000,0x80200040,0x00200000,
    0x00200040,0x80202040,0x00202000,0x00000040,
    0x80202040,0x00202000,0x00200000,0x80002040,
    0x80000040,0x80200000,0x00202040,0x00000000,
    0x00002000,0x80000040,0x80002040,0x80202000,
    0x80200000,0x00002040,0x00000040,0x80200040,
    0x00004000,0x00000200,0x01000200,0x01000004,
    0x01004204,0x00004004,0x00004200,0x00000000,
    0x01000000,0x01000204,0x00000204,0x01004000,
    0x00000004,0x01004200,0x01004000,0x00000204,
    0x01000204,0x00004000,0x00004004,0x01004204,
    0x00000000,0x01000200,0x01000004,0x00004200,
    0x01004004,0x00004204,0x01004200,0x00000004,
    0x00004204,0x01004004,0x00000200,0x01000000,
    0x00004204,0x01004000,0x01004004,0x00000204,
    0x00004000,0x00000200,0x01000000,0x01004004,
    0x01000204,0x00004204,0x00004200,0x00000000,
    0x00000200,0x01000004,0x00000004,0x01000200,
    0x00000000,0x01000204,0x01000200,0x00004200,
    0x00000204,0x00004000,0x01004204,0x01000000,
    0x01004200,0x00000004,0x00004004,0x01004204,
    0x01000004,0x01004200,0x01004000,0x00004004,
    0x20800080,0x20820000,0x00020080,0x00000000,
    0x20020000,0x00800080,0x20800000,0x20820080,
    0x00000080,0x20000000,0x00820000,0x00020080,
    0x00820080,0x20020080,0x20000080,0x20800000,
    0x00020000,0x00820080,0x00800080,0x20020000,
    0x20820080,0x20000080,0x00000000,0x00820000,
    0x20000000,0x00800000,0x20020080,0x20800080,
    0x00800000,0x00020000,0x20820000,0x00000080,
    0x00800000,0x00020000,0x20000080,0x20820080,
    0x00020080,0x20000000,0x00000000,0x00820000,
    0x20800080,0x20020080,0x20020000,0x00800080,
    0x20820000,0x00000080,0x00800080,0x20020000,
    0x20820080,0x00800000,0x20800000,0x20000080,
    0x00820000,0x00020080,0x20020080,0x20800000,
    0x00000080,0x20820000,0x00820080,0x00000000,
    0x20000000,0x20800080,0x00020000,0x00820080,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\managed\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_wmdrm_none_12.4.56.0_none_f493b605c6441657
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wmdrm
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf.manifest
XP_MANIFEST_PATH=manifests\x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf.cat
XP_CATALOG_PATH=manifests\x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf.cat
XP_PAYLOAD_PATH=x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wmdrm,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\tipatch.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifdef __cplusplus
extern "C" {
#endif

unsigned long DRM_CHARS2LONG(unsigned char *cc);
void DRM_LONG2CHARS(long val, unsigned char *aa);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\synclistgeneratechallenge.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <drmcrt.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <stdio.h> /* for missing CRT functions like printf */

#if DRM_SUPPORT_LICENSE_SYNC

DRM_RESULT GenerateSyncChallenge (const DRM_WCHAR  *pszOutput,
                                  DRM_CONST_STRING *pdstrDataStore,
                                  DRM_DWORD         cCountMax,
                                  DRM_DWORD         cHoursMax)
{
    DRM_MANAGER_CONTEXT *pcontextManager = NULL;
    DRM_RESULT           dr              = DRM_SUCCESS;
    DRM_BYTE            *pbXML           = NULL;
    DRM_DWORD            cbXML           = 0;
    DRM_DWORD            cKIDs           = 0;
    DRM_DWORD            iKIDNext        = 0;
    OEM_FILEHDL          hfile           = OEM_INVALID_HANDLE_VALUE;

    ChkMem (pcontextManager = OEM_malloc (SIZEOF (DRM_MANAGER_CONTEXT)))
    
    ChkDR (DRM_MGR_Initialize (pcontextManager, pdstrDataStore));
    
    dr = DRM_MGR_GenerateSyncChallenge (pcontextManager, 
                                        cCountMax, 
                                        cHoursMax, 
                                        0,
                                        1000,
                                       &cKIDs,
                                       &iKIDNext,
                                        NULL, 
                                       &cbXML);
    
    ChkFAIL (dr == DRM_E_BUFFERTOOSMALL 
          || DRM_SUCCEEDED (dr))
    
    ChkMem (pbXML = OEM_malloc (cbXML));
    
    ChkDR  (DRM_MGR_GenerateSyncChallenge (pcontextManager, 
                                           cCountMax, 
                                           cHoursMax, 
                                           0,
                                           1000,
                                          &cKIDs,
                                          &iKIDNext,
                                           pbXML, 
                                          &cbXML));

    printf ("output:\n%S", (DRM_WCHAR *) pbXML);    

    if ((hfile = OEM_OpenFile (pszOutput, 
                               OEM_GENERIC_WRITE, 
                               OEM_FILE_SHARE_READ, 
                               OEM_CREATE_ALWAYS, 
                               OEM_ATTRIBUTE_NORMAL)) != OEM_INVALID_HANDLE_VALUE)
    {
        DRM_DWORD       cbWritten    = 0;
                        
        OEM_WriteFile (hfile, pbXML, cbXML, &cbWritten);
        OEM_CloseFile (hfile);
    }
    else
    {
        printf ("error opening file %S", pszOutput);
    }

ErrorExit:

    if (pbXML != NULL)
    {
        OEM_free (pbXML);
    }
    
    if (pcontextManager != NULL)
    {
    	DRM_MGR_Uninitialize(pcontextManager);
        OEM_free            (pcontextManager);
    }

    return dr;
}

/******************************************************************************
** Print a command menu to console
*******************************************************************************/

static void PrintUsage (DRM_WCHAR *pwszAppName)
{
    printf ("Syntax: %S [-?] -s:DataStoreName -o:OutputFile [-c:MaxCount] [-h:MaxHours]]\n", pwszAppName);
}

#if EMBEDDED_WITH_NO_PARAMS

/* syncchal.exe */
DRM_WCHAR g_Arg1 [] = { TWO_BYTES('s', '\0'),  TWO_BYTES('y', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('\0', '\0')};
/*-s:datastore.hds */
DRM_WCHAR g_Arg2 [] = { TWO_BYTES('-', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('s', '\0'),  TWO_BYTES('t', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES('r', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('d', '\0'),  TWO_BYTES('s', '\0'), TWO_BYTES('\0', '\0')};
/*-o:challenge.xml*/ 
DRM_WCHAR g_Arg3 [] = { TWO_BYTES('-', '\0'),  TWO_BYTES('o', '\0'),  TWO_BYTES(':', '\0'),  TWO_BYTES('c', '\0'),  TWO_BYTES('h', '\0'),  TWO_BYTES('a', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('n', '\0'),  TWO_BYTES('g', '\0'),  TWO_BYTES('e', '\0'),  TWO_BYTES('.', '\0'),  TWO_BYTES('x', '\0'),  TWO_BYTES('m', '\0'),  TWO_BYTES('l', '\0'),  TWO_BYTES('\0', '\0')};

DRM_WCHAR *g_argv [] = 
{ 
    g_Arg1, 
    g_Arg2, 
    g_Arg3
};

DRM_INT g_argc = 3;

#endif

DRM_VOID DRM_API wmain (DRM_INT     argc, 
                        DRM_WCHAR **argv)
{    
    DRM_CONST_STRING dstrStoreName      = EMPTY_DRM_STRING,
                     dstrOutput         = EMPTY_DRM_STRING;
    DRM_INT          iArg               = 0;
    DRM_DWORD        cHoursMax          = DRM_SYNC_IGNORE_THRESHOLD_PARAMETER,
                     cCountMax          = DRM_SYNC_IGNORE_THRESHOLD_PARAMETER;

    printf ("Microsoft(R) %s\nCopyright (C) Microsoft Corporation. All rights reserved.\n\n", "DRM synclist challenge generation tool");

#if EMBEDDED_WITH_NO_PARAMS
    argc = g_argc;
    argv = g_argv;
#endif

    for (iArg = 1; iArg < argc; iArg++)
    {
        DRM_WCHAR        wchOption = 0;
        DRM_CONST_STRING dstrParam = EMPTY_DRM_STRING;

        if (!DRM_CMD_ParseCmdLine (argv [iArg], &wchOption, &dstrParam, NULL))
        {
            goto _PrintUsage;
        }
        wchOption = towlower (wchOption);

        switch (wchOption)
        {
            case WCHAR_CAST('s'):  
                dstrStoreName = dstrParam;
                break;
                
            case WCHAR_CAST('o'):  
                dstrOutput = dstrParam;
                break;

            case WCHAR_CAST('h'):
                if( DRM_FAILED( wcsntol(dstrParam.pwszString, dstrParam.cchString, (DRM_LONG*)&cHoursMax) ) )
                {
                   printf( "Invalid number %S\n", dstrParam.pwszString );
                   goto _PrintUsage;
                }
                break;
                                        
            case WCHAR_CAST('c'):
                if( DRM_FAILED( wcsntol(dstrParam.pwszString, dstrParam.cchString, (DRM_LONG*)&cCountMax) ) )
                {
                   printf( "Invalid number %S\n", dstrParam.pwszString );
                   goto _PrintUsage;
                }
                break;
                                        
            default:
                goto _PrintUsage;
        }
    }
      
    if (dstrStoreName.cchString == 0
      ||dstrOutput   .cchString == 0)
    {
        printf( "Missing arguments.\n");
        goto _PrintUsage;
    }

    if (dstrStoreName.cchString > (DRM_MAX_PATH - 1))
    {
        printf ("Data Store name is too long. Max length is %d.\n", DRM_MAX_PATH - 1);
        goto _PrintUsage;
    }

    GenerateSyncChallenge (dstrOutput.pwszString, 
                          &dstrStoreName,
                           cCountMax,
                           cHoursMax);

    return;
    
_PrintUsage:
    PrintUsage (argv [0]);
}
#else
DRM_VOID DRM_API wmain (DRM_INT     argc, 
                        DRM_WCHAR **argv)
{
    printf ("your build settings don't support this feature");
}                        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\managed\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__managed_1_none_12.4.56.0_none_e720d8d841c9f806
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_managed_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8.manifest
XP_MANIFEST_PATH=manifests\x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8.cat
XP_CATALOG_PATH=manifests\x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8.cat
XP_PAYLOAD_PATH=x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_managed_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_wmdrm_none_12.4.56.0_none_f493b605c6441657
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wmdrm
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf.manifest
XP_MANIFEST_PATH=manifests\x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf.cat
XP_CATALOG_PATH=manifests\x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf.cat
XP_PAYLOAD_PATH=x86_wmdrm_no-public-key_12.4.56.0_x-ww_702b3abf
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wmdrm,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\managed\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__managed_1_none_12.4.56.0_none_e720d8d841c9f806
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_managed_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8.manifest
XP_MANIFEST_PATH=manifests\x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8.cat
XP_CATALOG_PATH=manifests\x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8.cat
XP_PAYLOAD_PATH=x86__managed_1_no-public-key_12.4.56.0_x-ww_24b6ccc8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_managed_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cutil.h ===
/*
 *
 * Copyright (c) 2004 Microsoft Corporation
 * 
 * cutil.h
 * Header of leaderboard server utilities classes, functions and macros.
 * Source: cutil.cpp
 * 
 */

#pragma once
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

#include "cu_base.h"
#include "cu_collection.h"
#include "cu_string.h"
#include "cu_error.h"
#include "cu_system.h"
#include "cu_timer.h"
#include "cu_trace.h"
#include "cu_system.h"
#include "cu_tpool.h"
#include "cu_stream.h"
#include "cu_base64.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_base.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_base.cpp
// Don't include this file directly. Instead include cutil.h
// 
// Base stuff for cutil. You know, macros, types, that sort of stuff
// --------------------------------------------------------------------------------------

#include "precomp.h"

volatile UINT32 CFastLock::_globalCollisionCount;
volatile UINT32 CFastLock::_globalSleepCount;
volatile UINT32 CFastLock::_globalLockCount;

UINT64 GetUTCTimeAsUint64()
{
    UINT64 ft;
    ::GetSystemTimeAsFileTime(reinterpret_cast<LPFILETIME>(&ft));
    return ft;
}


//------------------------------------------------------------------
// GetFILETIMEFromDATE:  Gets a filetime value from a given date.
//------------------------------------------------------------------
HRESULT GetFILETIMEFromDATE( DATE dtVal, FILETIME *pftVal )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stVal;

    // convert to everyones favourite standard  --  system time
    if ( !VariantTimeToSystemTime( dtVal, &stVal ) )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // convert from systemtime to filetime.
    if ( !SystemTimeToFileTime( &stVal, pftVal ) )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        goto Cleanup;
    }

Cleanup:
    return hr;
}


//------------------------------------------------------------------
// GetDATEFromFILETIME:  Gets a variant time from a filetime.
//------------------------------------------------------------------
HRESULT GetDATEFromFILETIME( FILETIME *pftVal, DATE *pdtVal )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stVal;

    // convert from systemtime to filetime.
    if ( !FileTimeToSystemTime( pftVal, &stVal ) )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        goto Cleanup;
    }

    // convert to everyones favourite standard  --  system time
    if ( !SystemTimeToVariantTime( &stVal, pdtVal ) )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cutilp.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

// System includes
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <winsock2.h>
#include <windows.h>
#include <tchar.h>
#include <atlbase.h>
#include <atlcom.h>
#include <addref.h>
#include <oledb.h>
#include <oledberr.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

// Local includes
#include "cutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_base.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_base.h
// Don't include this file directly. Instead include cutil.h
// 
// Base stuff for cutil. You know, macros, types, that sort of stuff
// --------------------------------------------------------------------------------------

#pragma once

/*****************************************************************************
  DBGASSERT
*****************************************************************************/
#if _DEBUG
    #define DBGASSERT(x) \
        if(!(x)) \
        { \
            printf("\nAssert failed (%s, %d): %s\n", __FILE__, __LINE__, #x); \
            DebugBreak(); \
        } 
#else
    #define DBGASSERT(x)
#endif

/*****************************************************************************
 * Other useful macros
*****************************************************************************/
#if _DEBUG
    #define CUTIL_INLINE __declspec(noinline)
#else
    #define CUTIL_INLINE __forceinline
#endif

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

#pragma warning (default: 4035)

// --------------------------------------------------------------------------------------
// IMemAlloc
// Generic memory allocator interface
// --------------------------------------------------------------------------------------
class IMemAlloc
{
public:    
    // Allocate memory. This method must be implemented by sub-classes
    virtual void* Alloc(size_t size) = 0;
    
    // Release memory. This method must be implemented by sub-classes
    virtual void  Free(void* memblock) = 0;
};

//
// Macros to override the allocator of a class
//
// E.g.
//
// class Test
// {
//     USE_ALLOC(g_TestLookAside);
// public:
//     Test(int data) : _data(data) {}
// protected:
//     int _data;
// };
//
// Assuming g_TestLookAside is a object that inherits from IMemAlloc, the class can be 
// estantiated using new/delete.
//

#define USE_ALLOC(alloc) \
    public: \
        void* operator new(size_t size) { \
            return alloc.Alloc(size); \
        } \
        void* operator new[](size_t size) { \
            return alloc.Alloc(size); \
        } \
        void operator delete(void* ptr) { \
            alloc.Free(ptr); \
        } \
        void operator delete[](void* ptr) { \
            alloc.Free(ptr); \
        } \

//
// Macros to allow a different allocator per object allocation
//
// class Test
// {
//     USE_IMEMALLOC(Test);
// public:
//     Test(int data) : _data(data) {}
// protected:
//     int _data;
// };
//
// now the class must be instantiated as follows:
//
// Test* pTest = IMEMALLOC_NEW(pMyMemAlloc) Test(123);
//
// it can be deleted using either the delete operator or, for consistency, the 
// IMEMALLOC_DELETE macro as follows:
//
// IMEMALLOC_DELETE pTest;
// 

#define USE_IMEMALLOC(classname) \
    public: \
        void* operator new(size_t size, IMemAlloc& alloc) { \
            void* ptr = alloc.Alloc(size); \
            if(ptr) { \
                ((classname*)ptr)->__pAlloc = &alloc; \
            } \
            return ptr; \
        } \
        void* operator new[](size_t size, IMemAlloc& alloc) { \
            void* ptr = alloc.Alloc(size); \
            if(ptr) { \
                ((classname*)ptr)->__pAlloc = &alloc; \
            } \
            return ptr; \
        } \
        void operator delete(void* ptr) { \
            if(ptr) { \
                IMemAlloc* pAlloc = ((classname*)ptr)->__pAlloc; \
                pAlloc->Free(ptr); \
            } \
        } \
        void operator delete[](void* ptr) { \
            if(ptr) { \
                IMemAlloc* pAlloc = ((classname*)ptr)->__pAlloc; \
                pAlloc->Free(ptr); \
            } \
        } \
    private: \
        void* operator new(size_t size) { \
            DBGASSERT("This should have never been called"); \
            return NULL; \
        } \
        void* operator new[](size_t size) { \
            DBGASSERT("This should have never been called"); \
            return NULL; \
        } \
    private: \
        IMemAlloc* __pAlloc; 


#define IMEMALLOC_NEW(pMemAlloc) new (*((IMemAlloc*)pMemAlloc))
#define IMEMALLOC_DELETE delete

// ----------------------------------------------------------------------------
// CCrtMemAlloc
// Wrapper over the CRT memory allocation functions
// ----------------------------------------------------------------------------
class CCrtMemAlloc : public IMemAlloc
{
public:
    
    // Allocate memory using 'malloc'
    void* Alloc(size_t size)
    {
        return malloc(size);
    }

    // Release memory using 'free'
    void Free(void* pBuffer)
    {
        free(pBuffer);
    }
};

// --------------------------------------------------------------------------------------
// CMemAlloc
// Static methods to initialize and get the default memory allocator object.  Most of the 
// classes declared in this file that need to make memory allocations will use the 
// Default() static method to retrieve the default allocator.  They should also provide a 
// way to override the default allocator.
// --------------------------------------------------------------------------------------
class CMemAlloc
{
public:
    
    // Set the default allocator. This static method should be called during 
    // the initialization of the application before any other class or function 
    // declared in this file is used.
    // If pDefaultAlloc is not supplied, the default allocator will be used 
    // (CCrtMemAlloc)
    static bool Init(IMemAlloc* pDefaultAlloc = NULL)
    {
        if(!pDefaultAlloc)
        {
            // Use the Crt allocator as the default allocator
            pDefaultAlloc = &_crtMemAlloc;
        }

        if(_pDefaultAlloc != NULL && pDefaultAlloc != _pDefaultAlloc)
        {
            DBGASSERT(!"Default allocator already initialized");
            return false;
        }

        _pDefaultAlloc = pDefaultAlloc;

        return true;
    }

    // Returns the default allocator
    static IMemAlloc* Default()
    {
        DBGASSERT(_pDefaultAlloc != NULL);
        return _pDefaultAlloc;
    }

    static IMemAlloc* Crt()
    {
        return &_crtMemAlloc;
    }

protected:

    static CCrtMemAlloc _crtMemAlloc;           // CRT memory allocator
    static IMemAlloc*   _pDefaultAlloc;         // Application's default allocator
};

class CArenaAlloc : public IMemAlloc
{
public:

    CArenaAlloc() :
        _pAlloc(NULL),
        _pBufferList(NULL),
        _incrementSize(0),
        _pBuffer(NULL),
        _bufferSize(0),
        _bufferUsed(0)
    {
    }

    ~CArenaAlloc()
    {
        Term();
    }

    inline void Init(IMemAlloc* pAlloc, UINT32 incrementSize)
    {
        DBGASSERT(pAlloc);
        DBGASSERT(incrementSize > sizeof(BUFFER));

        _pAlloc        = pAlloc;
        _incrementSize = incrementSize;
    }

    inline void Attach(
        void* pBuffer, 
        UINT32 bufferSize, 
        IMemAlloc* pAlloc, 
        UINT32 incrementSize
        )
    {
        DBGASSERT(pBuffer);
        DBGASSERT(bufferSize);
        DBGASSERT(pAlloc == NULL || incrementSize > 0);

        _pBuffer       = (BYTE*) pBuffer;
        _bufferSize    = bufferSize;
        _pAlloc        = pAlloc;
        _incrementSize = incrementSize;
    }

    void Term()
    {
        BUFFER* pAllocBuffer = _pBufferList;
        while(pAllocBuffer)
        {
            BUFFER* pNext = pAllocBuffer->pNext;
            _pAlloc->Free(pAllocBuffer);
            pAllocBuffer = pNext;
        }

        _pBufferList = NULL;
        _pBuffer     = NULL;
        _bufferSize  = 0;
        _bufferUsed  = 0;
    }

    virtual void* Alloc(size_t size)
    {
        DBGASSERT(_pAlloc || _pBuffer);

        void*   pRet         = NULL;

        // round size to multiple of pointer size
        size = (size + sizeof(void*) - 1) & ~(sizeof(void*) - 1);

        UINT32 remaining = _bufferSize - _bufferUsed;

        if(remaining < size)
        {
            if(!_pAlloc)
            {
                goto Exit;
            }
            
            // Allocate a new buffer - the default size of the buffer will be 
            // _incrementSize. Adjust it if it's not enough.

            UINT32 bufferSize = _incrementSize + sizeof(BUFFER);
            if(bufferSize < size + sizeof(BUFFER))
            {
                bufferSize = sizeof(BUFFER) + size;
            }

            // Allocate

            BUFFER* pAllocBuffer = (BUFFER*)_pAlloc->Alloc(bufferSize);

            if(!pAllocBuffer)
            {
                goto Exit;
            }

            // Make it the current buffer

            _pBuffer    = pAllocBuffer->ab;
            _bufferSize = bufferSize - sizeof(BUFFER);
            _bufferUsed = 0;

            // Add buffer to list of buffers to be released later

            pAllocBuffer->pNext = _pBufferList;
            _pBufferList = pAllocBuffer;
            pAllocBuffer = NULL;
        }

        pRet = _pBuffer + _bufferUsed;
        _bufferUsed += size;
        DBGASSERT(_bufferUsed <= _bufferSize);

    Exit:

        return pRet;
    }
    
    virtual void  Free(void* memblock)
    {
        UNREFERENCED_PARAMETER(memblock);
    }

protected:

    struct BUFFER
    {
        BUFFER* pNext;
        BYTE    ab[1];
    };

    IMemAlloc* _pAlloc;
    BUFFER*    _pBufferList;
    UINT32     _incrementSize;
    BYTE*      _pBuffer;
    UINT32     _bufferSize;
    UINT32     _bufferUsed;
};

inline PVOID operator new(size_t size, CArenaAlloc& alloc)
{
    return alloc.Alloc(size);
}

inline PVOID operator new[](size_t size, CArenaAlloc& alloc)
{
    return alloc.Alloc(size);
}

/*****************************************************************************
 USE_DEFAULT_ALLOC
 Want a class or structure to use g_pDefaultMemAlloc.
 Just add USE_DEFAULT_ALLOC to a class declaration.
*****************************************************************************/
#define USE_DEFAULT_ALLOC \
    PVOID operator new( size_t cSize ) \
    { return (PVOID) CMemAlloc::Default()->Alloc(cSize); } \
    \
    PVOID operator new[]( size_t cSize ) \
    { return (PVOID) CMemAlloc::Default()->Alloc(cSize); } \
    \
    void operator delete( PVOID pObj ) \
    { CMemAlloc::Default()->Free(pObj); } \
    \
    void operator delete[]( PVOID pObj ) \
    { CMemAlloc::Default()->Free(pObj); }

/*****************************************************************************
  CFastLock
*****************************************************************************/
class CFastLock
{
public:

    CFastLock()
    {
        _lTid = 0;
    }

#if _DEBUG

    ~CFastLock()
    {
        DBGASSERT(_lTid == 0);
    }

#endif

    void Init()
    {
        _lTid = 0;
    }

    __declspec(noinline) void Lock()
    {
        DWORD dwSleep;
        LONG lTid = (DWORD) ::GetCurrentThreadId();

#ifdef CUTIL_FEATURE_FASTLOCK_INSTRUMENTATION
        ::InterlockedIncrement((LONG*)&_globalLockCount);
#endif
        while(::InterlockedCompareExchange(&_lTid, lTid, 0) != 0)
        {
#ifdef CUTIL_FEATURE_FASTLOCK_INSTRUMENTATION
            ::InterlockedIncrement((LONG*)&_globalCollisionCount);
#endif
            
            for(int i=0; i < MAXSPIN; i++)
            {
                YieldProcessor();
                if(_lTid == 0) break;
            }
            
            if(_lTid == 0)
                continue;

            // Spinning didn't work out. Let's yield. Prevent priority inversion by 
            // oscilating between 0 and 1 sleep intervals.
            
            dwSleep = 0;
            for(dwSleep=0; _lTid != 0; dwSleep = !dwSleep)
            {
#ifdef CUTIL_FEATURE_FASTLOCK_INSTRUMENTATION
                ::InterlockedIncrement((LONG*)&_globalSleepCount);
#endif
                ::Sleep(dwSleep);
            }
        }
    }

    CUTIL_INLINE void Unlock()
    {
        DBGASSERT(_lTid != 0);
        ::InterlockedExchange(&_lTid,0);
    }
    
    bool IsLocked() const
    {
        return _lTid != 0;
    }

    static UINT64 GetGlobalLockCount()
    {
        return _globalLockCount;
    }

    static UINT64 GetGlobalCollisionCount()
    {
        return _globalCollisionCount;
    }

    static UINT64 GetGlobalSleepCount()
    {
        return _globalSleepCount;
    }

protected:

    enum {
        MAXSPIN=0xFFFF
    };

    volatile LONG _lTid;

    volatile static UINT32 _globalLockCount;
    volatile static UINT32 _globalCollisionCount;
    volatile static UINT32 _globalSleepCount;
};

C_ASSERT(sizeof(CFastLock) == sizeof(LONG));

// Compare 2 *unsigned* integers
inline int UINT32Compare(
    UINT32 ui1,
    UINT32 ui2
)
{
    if(ui1 < ui2)
        return -1;
    if(ui1 > ui2)
        return 1;
    else
        return 0;    
}

// Compare 2 *unsigned* 64 bit integers
inline int UINT64Compare(
    UINT64 ui1,
    UINT64 ui2
)
{
    if(ui1 < ui2)
        return -1;
    if(ui1 > ui2)
        return 1;
    else
        return 0;    
}

// Revert Dword (for big-little-endian conversions)
inline DWORD RevertDword(DWORD dw)
{
    DWORD dw2;
    
    reinterpret_cast<BYTE*>(&dw2)[0] = reinterpret_cast<BYTE*>(&dw)[3];
    reinterpret_cast<BYTE*>(&dw2)[1] = reinterpret_cast<BYTE*>(&dw)[2];
    reinterpret_cast<BYTE*>(&dw2)[2] = reinterpret_cast<BYTE*>(&dw)[1];
    reinterpret_cast<BYTE*>(&dw2)[3] = reinterpret_cast<BYTE*>(&dw)[0];
    
    return dw2;
}

UINT64 GetUTCTimeAsUint64();

// --------------------------------------------------------------------------------------
// IsBetween
// Returns true if 'number' lies between 'low' and 'high' (inclusive)
// --------------------------------------------------------------------------------------
#define IS_BETWEEN(number, low, high) ((number) >= (low) && (number) <= (high))


//
// useful tools for database conversions
//
HRESULT GetFILETIMEFromDATE( DATE dtVal, FILETIME *pftVal );
HRESULT GetDATEFromFILETIME( FILETIME *pftVal, DATE *dtVal );


//
// Inherit from this to disable copying of your class.
//
class UnCopyable
{
public:
    UnCopyable() {}

private:
        UnCopyable& operator=(const UnCopyable&);
        UnCopyable(const UnCopyable&);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\managed\wmdrm.cs ===
// -------------------------------------------------------------------------------------
//
// Copyright (c) 2006 Microsoft Corporation
//
// wmdrm.c
//
// Stuff to create a WMDRM (Janus) device certificate for a Xbox 360 console. Depends on 
// wmdrm.dll
// 
// -------------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;

using xonline.common.diagnostics;

namespace xonline.common.wmdrm
{
    [SuppressUnmanagedCodeSecurity, HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
    internal sealed class SafeLibraryHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
    {
        // Methods
        internal SafeLibraryHandle() : base(true)
        {
        }

        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success), DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
        private static extern bool FreeLibrary(IntPtr hModule);

        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        internal static extern SafeLibraryHandle LoadLibraryEx(string libFilename, IntPtr reserved, int flags);

        protected override bool ReleaseHandle()
        {
            return FreeLibrary(base.handle);
        }
    }


    public class Wmdrm    
    {
        const UInt32 DeviceUniqueIdMaxLen     = 256;
        const UInt32 DevicePublicKeyLen       = 40;
        const UInt32 DevicePrivateKeyLen      = 20;
        const UInt32 GroupCertPrivateKeyLen   = 20;
        const UInt32 FallbackSigningKeyLen    = 20;
        const UInt32 DeviceCertificateMaxLen  = 10 * 1024;
        const UInt32 GroupCertTemplateMaxLen  = ((DeviceCertificateMaxLen*6)/10);

        public class WmdrmException : Exception
        {
            public WmdrmException(string message, UInt32 hr) :
                base(string.Format("{0}. hr=0x{1}", message, hr.ToString("X")))
                { _hr = hr; }

            public UInt32 Hr { get { return _hr; } }

            protected UInt32 _hr;
        }

        static object wmdrmLock = new object();
        static SafeLibraryHandle wmdrmLibrary = null;

        public static void Load()
        {
            if (wmdrmLibrary == null)
            {
                lock (wmdrmLock)
                {
                    if (wmdrmLibrary == null)
                    {
                        string path = Path.Combine(AppDomain.CurrentDomain.RelativeSearchPath, "wmdrm.dll");
                        wmdrmLibrary = SafeLibraryHandle.LoadLibraryEx(path, IntPtr.Zero, 0);
                        Debug.Assert(wmdrmLibrary != null && wmdrmLibrary.IsInvalid == false);
                    }
                }
            }
        }
        
        // CreateDeviceCertificate
        //
        // Creates the device certificate for a Xbox 360 console.
        //
        //   * deviceUniqueId - Xbox 360 console id as a string
        //   * devicePublicKey - device Public key that was sent by the 360.
        //   * deviceCertificate (OUT) - receives the device certificate that was just 
        //   created
        public static void CreateDeviceCertificate(
            byte[] certTemplate,
            byte[] groupPrivateKey,
            byte[] fallbackSigningKey,
            string deviceUniqueId,
            byte[] devicePublicKey,
            out byte[] deviceCertificate)
        {
            // Allocate a buffer to accomodate the largest certificate possible

            byte[] buffer = new byte[DeviceCertificateMaxLen];

            UInt32 bufferlen = (UInt32) buffer.Length;

            // make sure wmdrm.dll is loaded
            Load();

            UInt32 hr = Dll_ServerCreateDeviceCertificate(
                deviceUniqueId,
                (UInt32) deviceUniqueId.Length,
                devicePublicKey,
                (UInt32) devicePublicKey.Length,
                certTemplate,
                (UInt32) certTemplate.Length,
                groupPrivateKey,
                (UInt32) groupPrivateKey.Length,
                fallbackSigningKey,
                (UInt32) fallbackSigningKey.Length,
                buffer,
                ref bufferlen);

            if(hr != 0)
            {
                throw new WmdrmException(
                    "Dll_ServerCreateDeviceCertificate failed", hr);
            }

            // Copy certificate to output buffer

            deviceCertificate = new byte[bufferlen];
            Buffer.BlockCopy(buffer, 0, deviceCertificate, 0, deviceCertificate.Length);
        }

        // CreateDeviceKeyPair
        //
        // Creates a device key pair for test purposes.
        //
        //   * publiKey - receives the newly created public key
        //   * privateKey - receives the newly create private key
        //
        public static void CreateDeviceKeyPair(
            out byte[] publicKey,
            out byte[] privateKey )
        {
            publicKey  = new byte[DevicePublicKeyLen];
            privateKey = new byte[DevicePrivateKeyLen];

            UInt32 publicKeyLen  = (UInt32) publicKey.Length;
            UInt32 privateKeyLen = (UInt32) privateKey.Length;

            // make sure wmdrm.dll is loaded
            Load();

            UInt32 hr = Dll_ServerCreateDeviceKeyPair(
                publicKey,
                ref publicKeyLen,
                privateKey,
                ref privateKeyLen);

            if(hr != 0)
            {
                throw new WmdrmException(
                    "Dll_ServerCreateDeviceKeyPair failed", hr);
            }

            Assert.AreEqual(publicKeyLen,  publicKey.Length);
            Assert.AreEqual(privateKeyLen, privateKey.Length);
        }


        // -----------------------------------------------------------------------------
        // Wmdrm.dll imports
        // -----------------------------------------------------------------------------

        [DllImport(
            "wmdrm.dll",
            EntryPoint="ServerCreateDeviceCertificate",
            ExactSpelling=true,
            CharSet=CharSet.Unicode,
            CallingConvention=CallingConvention.StdCall)]
            protected static extern UInt32 Dll_ServerCreateDeviceCertificate(
                string      pwszDeviceUniqueId,
                UInt32      cchDeviceUniqueId,
                byte[]      pbDevicePublicKey,
                UInt32      cbDevicePublicKey,
                byte[]      pbGroupCertTemplate,
                UInt32      cbGroupCertTemplate,
                byte[]      pbGroupCertPrivateKey,
                UInt32      cbGroupCertPrivateKey,
                byte[]      pbFallbackSigningKey,
                UInt32      cbFallbackSigningKey,
                byte[]      pbDeviceCertificate,        // OUT
                ref UInt32  cbDeviceCertificate         // IN OUT
                );
        
        [DllImport(
            "wmdrm.dll",
            EntryPoint="ServerCreateDeviceKeyPair",
            ExactSpelling=true,
            CharSet=CharSet.Unicode,
            CallingConvention=CallingConvention.StdCall)]
            protected static extern UInt32 Dll_ServerCreateDeviceKeyPair(
                byte[]      pbPublicKey,                // OUT
                ref UInt32  pcbPublicKey,               // IN OUT
                byte[]      pbPrivateKey,               // OUT
                ref UInt32  pcbPrivateKey               // IN OUT
                );
    }

    class WmdrmGroupCertificate
    {
        public byte[] Certificate = null;
        public byte[] PrivateKey  = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\configlistener\ConfigListener.h ===
#pragma once

//
// This file implements the CConfigListenerBase class, which is
// intended to make it easier for C++ components to dynamically
// consume configuration chnages from NPDB.
//
// The C# Config class exposes the following public events:
//
// Config.ServerListChange
// Config.InterfaceChange
// Config.InterfaceBucketChange
// Config.VirtualInterfaceChange
// Config.VirtualInterfaceListChange
// Config.SettingChange
// Config.MultiSettingChange
// Config.GameConfigChange
//
// All of these events (except the last) also have custom
// EventArgs classes used to communicate the nature of the
// configuration change detected in NPDB.
//
// While this is an excellent way for .Net applications to
// receive notification when config information is changed
// in NPDB, non .Net applications (like our unmanaged C++
// components) can't easily create delegates to attach
// to the event (at least, I couldn't figure out how...)
//
// To make this easier for COM config clients, the 
// ConfigInterop class will translate the .Net events
// into calls on a client-provided COM interface.
//
// If a COM client wants to be notifed when some config
// information changes in NPDB, it should create a class
// that implements the IConfigListener interface, and pass
// a pointer to that interface to ConfigInterop class
// via IConfig::put_ConfigListener.
//
// This purpose of the class below is to make it easier
// for COM components to implement the IConfigListener
// interface. The CConfigListenerBase is a complete
// implementation of the IConfigListener COM interface.
// 
// Each of the C# events above is translated into a 
// method on the IConfigListener COM interface. The
// EventArgs passed to the C# event handler are passed
// as the first parameter to the method.
//
// For a complete working example, see:
//
// private\common\test\configtlb\configtlbtest.cpp
//

#import "CommonConfig.tlb" raw_interfaces_only no_smart_pointers

using namespace XblConfig;

class CConfigListenerBase :
    public CComObjectRoot,
    public IConfigListener
{
public:
    BEGIN_COM_MAP(CConfigListenerBase)
        COM_INTERFACE_ENTRY(IConfigListener)
    END_COM_MAP()

    virtual HRESULT __stdcall ServerListChange (
        /*[in]*/ struct IServerListChangeEventArgs * e )
    {
        return S_OK;
    }

    virtual HRESULT __stdcall InterfaceChange (
        /*[in]*/ struct IInterfaceChangeEventArgs * e )
    {
        return S_OK;
    }

    virtual HRESULT __stdcall InterfaceBucketChange (
        /*[in]*/ struct IInterfaceBucketChangeEventArgs * e )
    {
        return S_OK;
    }

    virtual HRESULT __stdcall VirtualInterfaceChange (
        /*[in]*/ struct IVirtualInterfaceChangeEventArgs * e )
    {
        return S_OK;
    }

    virtual HRESULT __stdcall VirtualInterfaceListChange (
        /*[in]*/ struct IVirtualInterfaceListChangeEventArgs * e )
    {
        return S_OK;
    }

    virtual HRESULT __stdcall SettingChange (
        /*[in]*/ struct ISettingChangeEventArgs * e )
    {
        return S_OK;
    }

    virtual HRESULT __stdcall MultiSettingChange (
        /*[in]*/ struct IMultiSettingChangeEventArgs * e )
    {
        return S_OK;
    }

    virtual HRESULT __stdcall GameConfigChange ( )
    {
        return S_OK;
    }

    virtual HRESULT __stdcall XdelaySettingsChange ( )
    {
        return S_OK;
    }

    virtual HRESULT __stdcall XrlMappingsChange ( )
    {
        return S_OK;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_base64.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation
//
// cu_base64.h
//
// Base-64 transformation
//
// Don't include this file directly. Instead include cutil.h
// --------------------------------------------------------------------------------------

#pragma once

class CBase64
{
public:

    inline static UINT32 GetMinEncodeSize(UINT32 originalSize) 
    {
        return (((((originalSize) + 2) / 3) * 4) + 1);
    }

    inline static UINT32 GetMinDecodeSize(UINT32 encodedSize)
    {
        return ((((encodedSize) / 4) * 3) + 1);
    }

    static BOOL Decode(
        CConstStr*    pSrc, 
        OUT CBuffer*  pBuffer);
    
    static BOOL Encode(
        CConstBuffer* pBuffer, 
        OUT CStr*     pDst);

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_base64.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation
//
// cu_base64.cpp
//
// Base-64 transformation
//
// --------------------------------------------------------------------------------------

#include "precomp.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL CBase64::Decode(
    CConstStr*     pSrc, 
    OUT CBuffer*   pBuffer
    )
{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;
    BYTE*   pDst;
    LPCSTR  pszSrc;
    DWORD   ulSrcSize;
    UINT32  c;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;
    pszSrc = pSrc->cstr();
    ulSrcSize = pSrc->GetLength();

    if(ulSrcSize % 4 != 0)
    {
        return FALSE;
    }
    
    if(!pBuffer->HasRoom(GetMinDecodeSize(ulSrcSize)))
    {
        return FALSE;
    }

    pDst = (BYTE*) pBuffer->StartWrite(&c);
    DBGASSERT(c >= GetMinDecodeSize(ulSrcSize));

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        DBGASSERT( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    pBuffer->SetSize(ulCurOut);
    DBGASSERT(ulCurOut <= GetMinDecodeSize(ulSrcSize));
    
    return TRUE;
}

BOOL CBase64::Encode(
    CConstBuffer* pBuffer, 
    OUT CStr*     pDst
    )
{
    const BYTE* pSrc = (const BYTE*) pBuffer->GetConstPtr();
    DWORD   dwGroup;
    ULONG   ulSrcSize = pBuffer->GetSize();
    ULONG   ulCurGroup = 0, ulIndex;
    LPSTR   pszDst;
    UINT32  c;

    if(!pDst->HasRoom(GetMinEncodeSize(ulSrcSize)))
    {
        return FALSE;
    }

    pszDst = pDst->StartWrite(&c);
    DBGASSERT(c >= GetMinEncodeSize(ulSrcSize));

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    DBGASSERT(ulCurGroup < GetMinEncodeSize(ulSrcSize));
    pDst->EndWrite(ulCurGroup);
    
    return TRUE;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_collection.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_collection.cpp
// Don't include this file directly. Instead include cutil.h
// 
// Collections classes and functions
// --------------------------------------------------------------------------------------

#include "precomp.h"

/*****************************************************************************
 * CMemAlloc
*****************************************************************************/

CCrtMemAlloc CMemAlloc::_crtMemAlloc;
IMemAlloc* CMemAlloc::_pDefaultAlloc = NULL;

// --------------------------------------------------------------------------------------
// CLookAsideList
// --------------------------------------------------------------------------------------

void CLookAsideList::Init(DWORD cbObject, DWORD cMaxPooled, IMemAlloc* pAlloc)
{
    DBGASSERT(!_pAlloc);
    
    _cbObject   = cbObject;
    _cMaxPooled = cMaxPooled;
    _pAlloc     = pAlloc ? pAlloc : CMemAlloc::Default();
}

void CLookAsideList::Term()
{
    void* pObject;

    while(pObject = _lookAsideList.Pop())
    {
        _pAlloc->Free(pObject);
    }

    _cbObject = 0;
    _pAlloc = NULL;
}

BOOL CLookAsideList::PreAlloc(DWORD objectCount)
{
    for(DWORD i=0; i < objectCount; i++)
    {
        void* pObject = _pAlloc->Alloc(_cbObject);

        if(!pObject)
        {
            return FALSE;
        }

        _lookAsideList.Push((CSingleLink*)pObject);
    }
    
    return TRUE;
}

void* CLookAsideList::Alloc(size_t size)
{
    if(size != _cbObject)
    {
        return NULL;
    }

    return Alloc();
}

void* CLookAsideList::Alloc()
{
    void* pObject = _lookAsideList.Pop();

    if(!pObject)
    {
        pObject = _pAlloc->Alloc(_cbObject);
    }

    return pObject;
}

void CLookAsideList::Free(void* pObject)
{
    if(pObject)
    {
        if(_cMaxPooled != 0 && (DWORD)_lookAsideList.GetCount() < _cMaxPooled)
        {
            // Return object to the pool
            _lookAsideList.Push((CSingleLink*)pObject);
        }
        else
        {
            // The pool is already "full". Release object.
            _pAlloc->Free(pObject);
        }
    }
}
      
// --------------------------------------------------------------------------------------
// CArrayBase
// --------------------------------------------------------------------------------------

bool CArrayBase::SetAllocator(IMemAlloc* pAlloc)
{
    if((_pData == NULL || _pData == _pLocalData) && _iSize == 0)
    {
        _pAlloc = pAlloc;
        return true;
    }
    else
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER " Cannot set allocator after array has been used");
        return false;
    }
}
 
bool CArrayBase::Grow(int iNewCapacity)
{
    if(!_pAlloc)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER " Cannot grow array without an allocator");
        return false;
    }

    bool fRet        = false;
    void* pNewBuffer = NULL;
    
    if(iNewCapacity > _iCapacity)
    {
        // 48763 - Check for overflow
        if(iNewCapacity > (0x7fffffff/_iDataSize))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER "New capacity is too large");
            DBGASSERT(false);
            goto lDone;
        }

        pNewBuffer = _pAlloc->Alloc(iNewCapacity * _iDataSize);
        if(pNewBuffer == NULL)
            goto lDone;

        memcpy(pNewBuffer, _pData, _iSize * _iDataSize);

        if(_pData != _pLocalData)
            _pAlloc->Free(_pData);
    
        _pData     = pNewBuffer;
        _iCapacity = iNewCapacity;

        pNewBuffer = NULL;
    }
    
    fRet = true;
    
lDone:
    
    if(pNewBuffer != NULL)
        _pAlloc->Free(pNewBuffer);
        
    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    
    return fRet;
}
         
bool CArrayBase::SetSize(int iSize)
{
    bool fRet=false; 
    
    if(iSize > _iCapacity)
    {
        int iNewCapacity = __max(_iCapacity * 2, iSize);
        
        if(!Grow(iNewCapacity))
            goto lDone;
    }
    
    _iSize = iSize;
    fRet = true;

lDone:
    
    return fRet;
}

DWORD GetNearestPrime(DWORD dwTarget)
{
    static const DWORD rgPrimes[] = { 
        59, 73, 97, 109, 137, 157, 179, 197, 227, 241, 269, 283, 313, 347,
        367, 389, 419, 439, 461, 487, 509, 547, 571, 599, 617, 643, 661, 691, 727, 751,
        773, 811, 829, 859, 883, 919, 947, 977, 1009, 1031, 1051, 1087, 1103, 1129, 1171, 1201,
        1229, 1259, 1289, 1303, 1327, 1381, 1427, 1447, 1471, 1489, 1523, 1553, 1579, 1607, 1621, 1663,
        1697, 1723, 1753, 1787, 1823, 1867, 1879, 1913, 1951, 1993, 2011, 2039, 2081, 2099, 2131, 2153,
        2207, 2239, 2269, 2293, 2333, 2351, 2381, 2399, 2437, 2467, 2521, 2549, 2591, 2621, 2659, 2683,
        2699, 2719, 2749, 2789, 2803, 2843, 2879, 2909, 2953, 2971, 3019, 3049, 3083, 3121, 3169, 3203,
        3229, 3259, 3307, 3329, 3359, 3389, 3433, 3463, 3499, 3529, 3547, 3581, 3613, 3637, 3673, 3701,
        3733, 3769, 3803, 3847, 3877, 3911, 3929, 3967, 4007, 4027, 4073, 4099, 4133, 4159, 4217, 4241,
        4261, 4289, 4339, 4373, 4421, 4451, 4483, 4517, 4549, 4591, 4637, 4651, 4679, 4723, 4759, 4793,
        4817, 4877, 4919, 4943, 4969, 4999, 5003, 5023, 5077, 5101, 5147, 5179, 5227, 5261, 5297, 5333,
        5387, 5413, 5437, 5471, 5501, 5521, 5563, 5591, 5647, 5659, 5693, 5737, 5779, 5807, 5839, 5857,
        5879, 5923, 5981, 6029, 6053, 6089, 6121, 6151, 6199, 6221, 6263, 6287, 6317, 6343, 6367, 6397,
        6451, 6491, 6551, 6571, 6607, 6659, 6689, 6709, 6761, 6791, 6827, 6857, 6883, 6917, 6961, 6983,
        7013, 7043, 7103, 7129, 7187, 7213, 7243, 7297, 7331, 7369, 7433, 7477, 7499, 7529, 7549, 7577,
        7603, 7643, 7681, 7703, 7741, 7789, 7829, 7873, 7901, 7933, 7963, 8017, 8069, 8093, 8123, 8171,
        8219, 8237, 8273, 8297, 8353, 8387, 8429, 8461, 8521, 8543, 8597, 8627, 8663, 8689, 8713, 8741,
        8779, 8819, 8839, 8867, 8929, 8963, 9001, 9029, 9059, 9109, 9151, 9181, 9209, 9241, 9283, 9323,
        9349, 9397, 9421, 9439, 9473, 9511, 9547, 9613, 9631, 9677, 9719, 9743, 9781, 9811, 9839, 9871,
        9907, 9941, 10007, 10111, 10177, 10289, 10321, 10453, 10513, 10639, 10667, 10789, 10867, 10987, 11047, 11149,
        11239, 11329, 11383, 11491, 11587, 11717, 11777, 11863, 11933, 12041, 12073, 12197, 12263, 12379, 12413, 12511,
        12577, 12671, 12713, 12829, 12917, 13007, 13043, 13163, 13241, 13367, 13411, 13523, 13619, 13711, 13751, 13873,
        13921, 14057, 14087, 14249, 14341, 14447, 14489, 14593, 14669, 14767, 14797, 14897, 14983, 15013, 15161, 15299,
        15439, 15601, 15737, 15887, 16061, 16193, 16369, 16547, 16693, 16883, 17027, 17189, 17351, 17483, 17627, 17807,
        17959, 18119, 18251, 18397, 18539, 18743, 18947, 19139, 19289, 19433, 19559, 19751, 19913, 20011, 20147, 20327,
        20477, 20641, 20807, 20981, 21139, 21283, 21467, 21587, 21739, 21881, 22051, 22171, 22367, 22541, 22697, 22853,
        23017, 23143, 23311, 23531, 23633, 23801, 23929, 24083, 24223, 24419, 24611, 24799, 24971, 25013, 25171, 25343,
        25523, 25667, 25841, 25997, 26161, 26309, 26459, 26669, 26783, 26947, 27091, 27281, 27481, 27689, 27799, 27953,
        28109, 28307, 28493, 28619, 28751, 28909, 29101, 29243, 29401, 29581, 29761, 29959 };
    
    // Use binary search to find the prime immediatelly greater than dwTarget
    int l = 0;
    int r = ARRAY_SIZE(rgPrimes)-1;
    int m;
        
    for(;;)
    {
        if(r - l > 30)
        {
            m = (l + r) / 2;
            
            if(dwTarget < rgPrimes[m])
                r = m - 1;
            else
                l = m + 1;
                
            if(dwTarget == rgPrimes[m])
                break;
        }
        else
        {
            for(m=l; m < r && dwTarget > rgPrimes[m]; m++)
                ;
                
            break;
        }
    }
    
    if(dwTarget < rgPrimes[m])
    {
        return rgPrimes[m];
    }
    else
    {
        // iTarget is larger than what we have in our table so we'll just have to
        // use it instead. At least make sure it's not an even number.
        if((dwTarget & 1) == 0)
            dwTarget++;
            
        return dwTarget;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_error.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_error.h
// Don't include this file directly. Instead include cutil.h
// 
// Error handling utility classes and functions
// --------------------------------------------------------------------------------------

#pragma once

/*****************************************************************************
  Error Utilities
  Macros and classes used in LBS to manage errors, error messages and all 
  kinds of error stuff
*****************************************************************************/

#define STRINGIZE_IT1(x) #x
#define STRINGIZE_IT(x) STRINGIZE_IT1(x)
#define GLOBAL_ERROR_HEADER \
    "-------------------------------------" \
    "\n"__FILE__","STRINGIZE_IT(__LINE__)"\n"__FUNCTION__"\n" 

class CGlobalError
{
USE_DEFAULT_ALLOC;
public:
    
    // Init
    // Call this method on a thread right after creating it. It will 
    // initialize the error framework for the thread. Don't try to use the 
    // error framework on the thread before calling Init. Don't call Init
    // on the same thread more than once. 
    // Returns true if succeeded and false if failed.
    static bool Init();
    
    // Term
    // Call Term on a thread right before terminating it. Don't use the error 
    // framework after Term has been called.
    static void Term();
    
    // Reset
    // Resets message. Should be called at the beginning of a new request and
    // stuff like that.
    static void Reset();
    
    // SetMessage
    // Sets a new message
    static void SetMessage(LPCSTR pszMsg, ...);
    
    // AddMessage
    // Add to the current existing message
    static void AddMessage(LPCSTR pszMsg, ...);
    
    // GetCurrentMessage
    // Get current message
    static LPCSTR GetCurrentMessage();
    
    static void ProcessComError();
    
protected:

    CGlobalError()
    {
    }
    
    CLargeStr _strMessage;
    static DWORD _dwTlsSlotLbsError;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_stream.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// cu_stream.cpp
// --------------------------------------------------------------------------------------

#include "precomp.h"

#define VERIFY(x) \
    DBGASSERT(x) \
    if(!(x)) return FALSE;

// --------------------------------------------------------------------------------------
// CMemoryStream::Attach
// --------------------------------------------------------------------------------------
void CMemoryStream::Attach(void* pbuffer, UINT32 capacity, UINT32 length)
{
    DBGASSERT(pbuffer);
    DBGASSERT(capacity >= length);

    _pbuffer  = (BYTE*) pbuffer;
    _capacity = capacity;
    _length   = length;
    _position = 0;

    _cap = 
        CAN_READ            | 
        CAN_WRITE           | 
        CAN_SEEK            | 
        CAN_GET_POSITION    |
        CAN_GET_LENGTH      |
        CAN_SET_LENGTH;
}

// --------------------------------------------------------------------------------------
// CMemoryStream::GetCapabilities
// CStream override. Check out CStream's declaration for description.
// --------------------------------------------------------------------------------------
UINT32 CMemoryStream::GetCapabilities() const
{
    return _cap;
}

// --------------------------------------------------------------------------------------
// CMemoryStream::Read
// CStream override. Check out CStream's declaration for description.
// --------------------------------------------------------------------------------------
BOOL CMemoryStream::Read(
    OUT void*   pbuffer,
    UINT32      cbbuffer,
    OUT UINT32* pcbread)
{
    DBGASSERT(pbuffer);
    DBGASSERT(pcbread);
    VERIFY(_cap & CAN_READ);

    UINT32 available = _length - _position;

    // adjust number of bytes to read if necessary to accomodate the ammount of data 
    // that's available

    if(cbbuffer > available)
    {
        cbbuffer = available;
    }

    // copy data

    memcpy(pbuffer, _pbuffer + _position, cbbuffer);
    *pcbread = cbbuffer;

    // adjust 

    _position += cbbuffer;

    return TRUE;
}

// --------------------------------------------------------------------------------------
// CMemoryStream::Write
// CStream override. Check out CStream's declaration for description.
// --------------------------------------------------------------------------------------
BOOL CMemoryStream::Write(
    const void* pbuffer,
    UINT32      cbbuffer)
{
    DBGASSERT(pbuffer);
    VERIFY(_cap & CAN_WRITE);
    
    UINT32 available = _capacity - _position;

    if(cbbuffer > available)
    {
        return FALSE;
    }

    // copy data

    memcpy(_pbuffer + _position, pbuffer, cbbuffer);

    // adjust 

    _position += cbbuffer;

    if(_length < _position)
    {
        _length = _position;
    }
        
    return TRUE;
}

// --------------------------------------------------------------------------------------
// CMemoryStream::Seek
// CStream override. Check out CStream's declaration for description.
// --------------------------------------------------------------------------------------
BOOL CMemoryStream::Seek(
    SEEK_FROM   from,
    INT64       offset)
{
    INT64 newpos = 0;

    switch(from)
    {
    case SEEK_FROM_BEGINNING:
        newpos = offset;
        break;

    case SEEK_FROM_CURRENT:
        newpos = _position + offset;
        break;

    case SEEK_FROM_END:
        newpos = _length + offset;
        break;

    default:
        DBGASSERT(!"Invalid 'from'");
        return FALSE;
    }

    if(newpos < 0 || newpos > _length)
    {
        return FALSE;
    }

    _position = (UINT32) newpos;

    return TRUE;
}

// --------------------------------------------------------------------------------------
// CMemoryStream::GetPos
// CStream override. Check out CStream's declaration for description.
// --------------------------------------------------------------------------------------
UINT64 CMemoryStream::GetPos() const
{
    return _position;
}

// --------------------------------------------------------------------------------------
// CMemoryStream::GetLength
// CStream override. Check out CStream's declaration for description.
// --------------------------------------------------------------------------------------
UINT64 CMemoryStream::GetLength() const
{
    return _length;
}

// --------------------------------------------------------------------------------------
// CMemoryStream::SetLength
// CStream override. Check out CStream's declaration for description.
// --------------------------------------------------------------------------------------
BOOL CMemoryStream::SetLength(
    UINT64 length
    )
{
    VERIFY(_cap & CAN_SET_LENGTH);

    if(length > _capacity)
        return FALSE;

    if(length > _length)
    {
        memset(_pbuffer, 0, (int)(length - _length));
    }

    _length = (UINT32) length;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_stream.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// cu_stream.h
//
// - CStream defines the skeleton for streaming classes. But it also has utility methods 
// to read and write values.
// - CMemoryStream is a streamming class for memory buffers.
// --------------------------------------------------------------------------------------

#pragma once

// --------------------------------------------------------------------------------------
// CStream
// Defines the skeleton for streaming classes. Can't be instantiated directly.
// --------------------------------------------------------------------------------------
class CStream
{
public:

    enum CAPABILITY
    {
        CAN_READ            = 0x01,
        CAN_WRITE           = 0x02,
        CAN_SEEK            = 0x04,
        CAN_GET_POSITION    = 0x08,
        CAN_GET_LENGTH      = 0x10,
        CAN_SET_LENGTH      = 0x20
    };

    // GetCapabilities
    // Return a combination of zero or more CAN_* flags that describe what this stream 
    // object can do
    virtual UINT32 GetCapabilities() const = 0;
    
    // Read
    // Read bytes from the stream. Requires CAN_READ capability.
    // - pbbuffer: buffer to receive the bytes read
    // - cbbuffer: size of the buffer and the number of bytes to read
    // - pcbread: receives the number of bytes actually read
    // Returns:
    //  Method returns FALSE if operation fails
    // Remarks:
    //  This method might return TRUE even if no bytes were read like, for example, when 
    //  we're at the end of the stream.  Check the value returned in pcbread if you care 
    //  about that.
    virtual BOOL Read(
        OUT void*   pbuffer,
        UINT32      cbbuffer,
        OUT UINT32* pcbread) = 0;

    // Write
    // Write bytes to the stream. Requires CAN_WRITE capability
    // - pbuffer: buffer with bytes to be written
    // - cbbuffer: number of bytes to write
    // Returns:
    //  Method returns FALSE if operation fails including when there is not enough space 
    //  in the stream to write all of bytes specified by cbbuffer
    virtual BOOL Write(
        const void* pbuffer,
        UINT32      cbbuffer) = 0;

    enum SEEK_FROM
    {
        SEEK_FROM_BEGINNING = 1,
        SEEK_FROM_CURRENT   = 2,
        SEEK_FROM_END       = 3
    };

    // Seek
    // Change current position in the stream. Requires CAN_SEEK capability.
    // - from: one of the SEEK_FROM_* constants
    // - offset: offset starting from the location indicated by the 'from' parameter to 
    // move to.
    // Returns:
    //  Method returns FALSE if the operation fails, including when the new position lies 
    //  beyound the boundaries of the stream.
    // Remarks:
    //  Seek cannot be used to resize the stream. Use SetLength instead
    virtual BOOL Seek(
        SEEK_FROM   from,
        INT64       offset) = 0;
    
    // GetPos
    // Returns current position in the stream. Requires CAN_GET_POSITION capability.
    virtual UINT64 GetPos() const = 0;

    // GetLength
    // Returns length of the stream. Requires CAN_GET_LENGTH.
    virtual UINT64 GetLength() const = 0;

    // SetLength
    // Sets the length of the stream. Requires CAN_SET_LENGTH
    // - length: new length
    // Returns:
    //  Method returns FALSE if operation fails
    virtual BOOL SetLength(
        UINT64 length) = 0;
    
    // ReadValue
    // Read a typed value from the stream. Requires CAN_READ
    // - pval: pointer to receive value read
    // Returns:
    //  Method returns FALSE if operation fails including if there was not enough data 
    //  available to read the value
    template <class t>
    inline BOOL ReadValue(OUT t* pval)
    {
        DBGASSERT(pval);
        UINT32 cbread;
        return Read(pval, sizeof(t), &cbread) && cbread == sizeof(t);
    }

    // ReadBytes
    // Read an array of bytes from the stream. Requires CAN_READ
    // - pbuffer: buffer to receive the bytes
    // - cbbuffer: number of bytes to read
    // Returns:
    //  Method returns FALSE if operation fails including if there was not enough data 
    //  available to read the number of bytes specified in cbbuffer
    // Remarks:
    //  The difference between ReadBytes and Read is that ReadBytes fails if it can't 
    //  read the number of bytes that was specified.
    inline BOOL ReadBytes(OUT void* pbuffer, UINT32 cbbuffer)
    {
        DBGASSERT(pbuffer);
        UINT32 cbread;
        return Read(pbuffer, cbbuffer, &cbread) && cbread == cbbuffer;
    }
    
    // WriteValue
    // Write a typed value to the stream. Requires CAN_WRITE
    // - val: value to write to the stream
    // Returns:
    //  Method returns FALSE if operation fails.
    template <class t>
    inline BOOL WriteValue(const t& val)
    {
        return Write(&val, sizeof(t));
    }

    inline BOOL WriteByte(BYTE val)     { return WriteValue(val); }
    inline BOOL WriteInt16(INT16 val)   { return WriteValue(val); }
    inline BOOL WriteUInt16(UINT16 val) { return WriteValue(val); }
    inline BOOL WriteInt32(INT32 val)   { return WriteValue(val); }
    inline BOOL WriteUInt32(UINT32 val) { return WriteValue(val); }
    inline BOOL WriteInt64(INT64 val)   { return WriteValue(val); }
    inline BOOL WriteUInt64(UINT64 val) { return WriteValue(val); }
};

// --------------------------------------------------------------------------------------
// CMemoryStream
// Stream class for memory buffers.
//
// It provides the following capabilities:
//  - CAN_READ
//  - CAN_WRITE
//  - CAN_SEEK
//  - CAN_GET_POSITION
//  - CAN_GET_LENGTH
//  - CAN_SET_LENGTH
//  
//  To use this class provide the buffer (with or without data) to the constructor or to 
//  the method Attach.
//
//  There is currently no support for automatic buffer allocation. This also means that 
//  Write and SetLength will fail on attempts to write beyound the buffer's capacity.
//
// --------------------------------------------------------------------------------------
class CMemoryStream : public CStream
{
public:

    // Default constructor
    CMemoryStream() :
        _pbuffer(NULL),
        _capacity(0),
        _length(0),
        _position(0),
        _cap(0)
    {
    }
    
    // Constructor
    // Check out the method Attach for parameters
    CMemoryStream(void* pbuffer, UINT32 capacity, UINT32 length)
    {
        Attach(pbuffer, capacity, length);
    }
    
    // Attach
    // Attach to a memory buffer and set current position at the beginning.
    // - pbuffer: buffer to attach to.
    // - capacity: real size of the buffer in bytes
    // - length: how much data there is in the buffer
    void Attach(void* pbuffer, UINT32 capacity, UINT32 length);
    
    /* ------------- CStream overrides ----------- */
    
    virtual UINT32 GetCapabilities() const;
    
    virtual BOOL Read(
        OUT void*   pbuffer,
        UINT32      cbbuffer,
        OUT UINT32* pcbread);

    virtual BOOL Write(
        const void* pbuffer,
        UINT32      cbbuffer);
    
    virtual BOOL Seek(
        SEEK_FROM   from,
        INT64       offset);
    
    virtual UINT64 GetPos() const;

    virtual UINT64 GetLength() const;

    virtual BOOL SetLength(
        UINT64 length);
    
    /* -------- End of CStream overrides --------- */

    inline void* GetBuffer() const
    {
        return (void*)_pbuffer;
    }

    inline void* GetPointer() const
    {
        return (void*)(_pbuffer + _position);
    }

    inline BOOL GetPointerAndAdvance(OUT void** ppointer, UINT32 offset)
    {
        *ppointer = GetPointer();
        return Seek(SEEK_FROM_CURRENT, offset);
    }

    inline UINT32 GetCapacity() const
    {
        return _capacity;
    }

protected:

    BYTE*   _pbuffer;   // buffer we're attached to
    UINT32  _capacity;  // real size of the buffer in bytes
    UINT32  _length;    // size of the data in the buffer
    UINT32  _position;  // current position in the stream
    UINT32  _cap;       // stream's capabilities (combination of CAN_* flags)
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_error.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_error.cpp
// 
// Error handling utility classes and functions
// --------------------------------------------------------------------------------------

#include "precomp.h"
// --------------------------------------------------------------------------------------
// CGlobalError
// --------------------------------------------------------------------------------------

DWORD CGlobalError::_dwTlsSlotLbsError = TLS_OUT_OF_INDEXES;

bool CGlobalError::Init()
{
    CGlobalError* plbsError = NULL;
    bool fRet = true;
    
    // On the first call we must allocate the TLS slot
    if(_dwTlsSlotLbsError == TLS_OUT_OF_INDEXES)
    {
        _dwTlsSlotLbsError = TlsAlloc();
        
        if(_dwTlsSlotLbsError == TLS_OUT_OF_INDEXES)
        {
            fRet = false;
            goto lDone;
        }
    }
    
    // We use the TLS slot to store an instance of CGlobalError
    plbsError = new CGlobalError();
    
    if(plbsError == NULL)
    {
        fRet = false;
        goto lDone;
    }
        
    // Assign the new instance of CGlobalError to the TLS slot
    if(!TlsSetValue(_dwTlsSlotLbsError, (LPVOID)plbsError))
    {
        fRet = false;
        goto lDone;
    }
    
    plbsError = NULL;
    
lDone:
    
    if(!fRet)
    {
        if(plbsError != NULL)
        {
            delete plbsError;
            plbsError = NULL;
        }
    }
    
    return fRet;
}

void CGlobalError::Term()
{
    if(_dwTlsSlotLbsError != TLS_OUT_OF_INDEXES)
    {
        CGlobalError* plbsError = (CGlobalError*) TlsGetValue(_dwTlsSlotLbsError);
        
        if(plbsError != NULL)
        {
            delete plbsError;
            TlsSetValue(_dwTlsSlotLbsError, NULL);
        }
    }
}

void CGlobalError::Reset()
{
    CGlobalError* plbsError = (CGlobalError*) TlsGetValue(_dwTlsSlotLbsError);
    plbsError->_strMessage.Reset();
}

void CGlobalError::SetMessage(LPCSTR pszMsg, ...)
{
    va_list args;
    va_start(args, pszMsg);
    
    if(_dwTlsSlotLbsError == TLS_OUT_OF_INDEXES)
        return; // Not initialized

    CGlobalError* plbsError = (CGlobalError*) TlsGetValue(_dwTlsSlotLbsError);
    if(!plbsError) 
        return; // Not initialized

    plbsError->_strMessage.Reset();
    plbsError->_strMessage.FormatV(pszMsg, args);
    plbsError->_strMessage.CopyFrom("\n");
    
    va_end(args);
}

void CGlobalError::AddMessage(LPCSTR pszMsg, ...)
{
    va_list args;
    va_start(args, pszMsg);
    
    if(_dwTlsSlotLbsError == TLS_OUT_OF_INDEXES)
        return; // Not initialized

    CGlobalError* plbsError = (CGlobalError*) TlsGetValue(_dwTlsSlotLbsError);
    if(!plbsError) 
        return; // Not initialized

    plbsError->_strMessage.FormatV(pszMsg, args);
    plbsError->_strMessage.CopyFrom("\n");
    
    va_end(args);
}

LPCSTR CGlobalError::GetCurrentMessage()
{
    if(_dwTlsSlotLbsError == TLS_OUT_OF_INDEXES)
        return ""; // Not initialized

    CGlobalError* plbsError = (CGlobalError*) TlsGetValue(_dwTlsSlotLbsError);
    if(!plbsError) 
        return ""; // Not initialized

    return plbsError->_strMessage.cstr();
}

static void ProcessErrorInfo(
    IErrorInfo* pErrorInfo
)
{
    CComBSTR bstrDescription;
    CComBSTR bstrSource;
    
    if(FAILED(pErrorInfo->GetDescription(&bstrDescription)) ||
       FAILED(pErrorInfo->GetSource(&bstrSource)))
    {
        CGlobalError::AddMessage("Failed to get error description");
        goto lDone;
    }
    
    CGlobalError::AddMessage(
        "\n>>Source:"
        "\n%S"
        "\n>>Description:"
        "\n%S"
        "\n",
        (LPCWSTR)bstrSource,
        (LPCWSTR)bstrDescription);
    
lDone:

    return;
}

void CGlobalError::ProcessComError()
{
    LCID lcid = GetUserDefaultLCID();
    CComPtr<IErrorInfo> pErrorInfo;
    CComQIPtr<IErrorRecords> pErrorRecords;
    CComPtr<IErrorInfo> pRecord;
    ULONG cRecords = 0;
    
    if(FAILED(GetErrorInfo(0, &pErrorInfo)) || pErrorInfo == NULL)
    {
        AddMessage("(GetErrorInfo returned no information)");
        goto lDone;
    }
    
    pErrorRecords = pErrorInfo;
    if(pErrorRecords != NULL)
    {
        if(FAILED(pErrorRecords->GetRecordCount(&cRecords)))
        {
            AddMessage("pErrorRecords->GetRecordCount failed");
            goto lDone;
        }
        
        for(ULONG i=0; i < cRecords; i++)
        {
            if(FAILED(pErrorRecords->GetErrorInfo(i, lcid, &pRecord)))
            {
                AddMessage("pErrorRecords->GetErrorInfo failed");
                continue;
            }
            
            ProcessErrorInfo(pRecord);
            
            pRecord = NULL;
        }
    }
    else
    {
        ProcessErrorInfo(pErrorInfo);
    }
    
lDone:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_collection.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_collection.h
// Don't include this file directly. Instead include cutil.h
// 
// Collections classes and functions
// --------------------------------------------------------------------------------------

#pragma once

// --------------------------------------------------------------------------------------
// TLFStack
// Efficient thread-safe list-based stack template
// --------------------------------------------------------------------------------------
template <int n=0>
struct TSingleLink : public SLIST_ENTRY
{
};

typedef TSingleLink<0> CSingleLink;

template <class c, int n=0>
class TLFStack
{
public:
    
    typedef TSingleLink<n> LINK;

    TLFStack()
    {
        Init();
    }

    // Init
    // initialize members
    void Init()
    {
        ::InitializeSListHead(&_listHead);
    }

    // IsEmpty
    // Check if the list is empty
    bool IsEmpty()
    {
        return GetCount() == 0;
    }
    
    // Push
    // Push an item into the stack. This method is thread-safe.
    void Push(c* pEntry)
    {
        ((LINK*)pEntry)->Next = NULL;
        ::InterlockedPushEntrySList(&_listHead, (PSLIST_ENTRY)(LINK*)pEntry);
    }
    
    // Pop
    // Remove and return the top element from the stack. This method is 
    // thread-safe.
    c* Pop()
    {
        return (c*)(LINK*) ::InterlockedPopEntrySList(&_listHead);
    }

    // GetCount
    // Return the number of entries in the stack
    int GetCount()
    {
        return (int) ::QueryDepthSList(&_listHead);
    }

    // Iterator
    class Iterator
    {
    public:

        Iterator() :
            _pLink(NULL)
        {
        }

        c* Get()
        {
            return (c*) _pLink;
        }

        c* Next()
        {
            if(_pLink != NULL)
            {
                _pLink = (LINK*) _pLink->Next;
            }

            return (c*) _pLink;
        }

    protected:

        friend TLFStack;

        void Attach(LINK* pLink)
        {
            _pLink = pLink;
        }

        LINK* _pLink;
    };
    
    // PopAll
    // Remove all the entries from the stack and return them in form of an iterator
    bool PopAll(Iterator* pIt)
    {
        LINK* pLink = (LINK*) ::InterlockedFlushSList(&_listHead);
        pIt->Attach(pLink);
        return pLink != NULL;
    }
    
protected:

    SLIST_HEADER _listHead;         // List head
};

// --------------------------------------------------------------------------------------
// CList & CListEntry
// Double linked list 
//
// Usage example:
// **************
//
// CList list;
// CListEntry a, b, c;
// CListEntry* ple;
//
// /* Stack */
// list.Push(&a);
// list.Push(&b);
// Assert(list.Pop() == &b);
// Assert(list.Pop() == &a);
// Assert(list.Pop() == NULL);
//
// /* Queue */
// list.Enqueue(&a);
// list.Enqueue(&b);
// Assert(list.Dequeue() == &a);
// Assert(list.Dequeue() == &b);
// Assert(list.Dequeue() == NULL);
//
// /* Iterating */
// list.InsertTail(&a);
// list.InsertTail(&b);
// list.InsertTail(&c);
// for(ple = list.GetFirst(); !ple->IsTail(); ple = ple->GetNext())
// {
//     /* forwards */
// }
// for(ple = list.GetLast(); !ple->IsHead(); ple = ple->GetPrev())
// {
//     /* backwards */
// }
//
// The macro CONTAINING_RECORD can be very useful to hide the pointer magic required to go 
// from a CListEntry pointer to the struct/class that owns it:
//
// struct STUFF
// {
//     int data;
//     CListEntry le1;
//     CListEntry le2;
// };
//
// STUFF s;
// CList l1;
// CList l2;
// CListEntry* ple;
//
// l1.Enqueue(&s.le1);
// l2.Enqueue(&s.le2);
//
// ple = l1.Dequeue();
// Assert(CONTAINING_RECORD(ple, STUFF, le1) == &s);
// ple = l2.Dequeue();
// Assert(CONTAINING_RECORD(ple, STUFF, le2) == &s);
//
// --------------------------------------------------------------------------------------

class CList;

class CListEntry
{
public:

    inline CListEntry() :
        Blink(NULL),
        Flink(NULL)
    {
    }

    inline CListEntry(CListEntry* b, CListEntry* f) :
        Blink(b),
        Flink(f)
    {
    }
    
    inline void Init()
    {
        this->Blink = NULL;
        this->Flink = NULL;
    }

    inline void InsertAfter(CListEntry* ple)
    {
        DBGASSERT(ple->Flink);

        this->Blink       = ple;
        this->Flink       = ple->Flink;
        ple->Flink->Blink = this;
        ple->Flink        = this;
    }

    inline void InsertBefore(CListEntry* ple)
    {
        DBGASSERT(ple->Blink);

        this->Blink       = ple->Blink;
        this->Flink       = ple;
        ple->Blink->Flink = this;
        ple->Blink        = this;
    }

    inline void Remove()
    {
        DBGASSERT(this->Blink && this->Flink);
        this->Blink->Flink = this->Flink;
        this->Flink->Blink = this->Blink;
        this->Flink = NULL;
        this->Blink = NULL;
    }

    inline CListEntry* GetNext()
    {
        return this->Flink;
    }

    inline CListEntry* GetPrev()
    {
        return this->Blink;
    }

    inline BOOL IsHead()
    {
        return this->Blink == NULL;
    }

    inline BOOL IsTail()
    {
        return this->Flink == NULL;
    }

protected:

    friend CList;

    CListEntry* Blink;
    CListEntry* Flink;
};

class CList
{
public:

    inline CList() :
        Head(NULL, &Tail),
        Tail(&Head, NULL)
    {
    }

    inline void Init()
    {
        this->Head.Blink = NULL;
        this->Head.Flink = &this->Tail;
        this->Tail.Blink = &this->Head;
        this->Tail.Flink = NULL;
    }

    inline BOOL IsEmpty() const
    {
        return this->Head.Flink == &this->Tail;
    }

    inline CListEntry* GetHead()
    {
        return &this->Head;
    }

    inline CListEntry* GetTail()
    {
        return &this->Tail;
    }

    inline CListEntry* GetFirst()
    {
        return this->Head.Flink;
    }

    inline CListEntry* GetLast()
    {
        return this->Tail.Blink;
    }

    inline void InsertHead(CListEntry* ple)
    {
        ple->InsertAfter(&this->Head);
    }
    
    inline CListEntry* RemoveHead()
    {
        CListEntry* ple = Head.GetNext();

        if(!ple->IsTail())
        {
            ple->Remove();
            return ple;
        }
        else
        {
            return NULL;
        }
    }

    inline void InsertTail(CListEntry* ple)
    {
        ple->InsertBefore(&this->Tail);
    }

    inline CListEntry* RemoveTail()
    {
        CListEntry* ple = Tail.GetPrev();
        
        if(!ple->IsHead())
        {
            ple->Remove();
            return ple;
        }
        else
        {
            return NULL;
        }
    }

    inline void Enqueue(CListEntry* ple)
    {
        InsertHead(ple);
    }

    inline CListEntry* Dequeue()
    {
        return RemoveTail();
    }

    inline void Push(CListEntry* ple)
    {
        InsertHead(ple);
    }

    inline CListEntry* Pop()
    {
        return RemoveHead();
    }

    inline void MoveToDifferentList(CList* pList)
    {
        DBGASSERT(pList != this);

        if(this->IsEmpty())
        {
            return;
        }

        CListEntry* pFirst = this->Head.Flink;
        CListEntry* pLast  = this->Tail.Blink;

        pList->Tail.Blink->Flink = pFirst;
        pFirst->Blink = pList->Tail.Blink;
        pList->Tail.Blink = pLast;
        pLast->Flink = &pList->Tail;

        this->Init();
    }

protected:

    CListEntry Head;
    CListEntry Tail;
};

// --------------------------------------------------------------------------------------
// TList
// Double linked list template
// --------------------------------------------------------------------------------------
template <int n=0>
struct TDoubleLink : public LIST_ENTRY
{
};

typedef TDoubleLink<0> CDoubleLink;

template <class c, int n=0>
class TList
{
public:
    
    typedef TDoubleLink<n> LINK;

    // constructor
    TList() 
    {
        Init();
    }

    // Init
    // initialize member variables
    void Init()
    {
        _Head.Blink = NULL;
        _Head.Flink = &_Tail;
        _Tail.Blink = &_Head;
        _Tail.Flink = NULL;
    }

    // IsEmpty
    // Return whether the list is empty
    bool IsEmpty() const
    {
        return _Head.Flink == &_Tail;
    }

    // Enqueue
    // Add entry to the end of the list
    void Enqueue(c* pNewNode)
    {
        InsertBefore(&_Tail, (LINK*) pNewNode);
    }

    // Dequeue
    // Remove entry from the beginning of the list. Return NULL if the list is empty
    c* Dequeue()
    {
        if(_Head.Flink == &_Tail)
        {
            return NULL;
        }

        LINK* pNode = (LINK*)_Head.Flink;
        Remove(pNode);
        return (c*) pNode;
    }
    
    // Push
    // Add entry to the beginning of the list
    void Push(c* pNewNode)
    {
        InsertBefore((LINK*)_Head.Flink, (LINK*)pNewNode);
    }
    
    // Pop
    // Remove entry from the beginning of the list. Return NULL if the list is empty
    c* Pop()
    {
        return Dequeue();
    }

    // Iterator
    // Initialize it using either TList::Begin or TList::End
    class Iterator
    {
    public:
   
        // constructor
        Iterator() :
            _pList(NULL),
            _pLink(NULL)
        {}
        
        // Next
        // Advance the iterator and return the next entry. Return NULL if the end of the 
        // list was reached
        c* Next()
        {
            if(_pLink == &_pList->_Tail)
            {
                return NULL;
            }

            _pLink = (LINK*)_pLink->Flink;
                
            return Get();
        }

        // Prev
        // Move the iterator back and return the previous entry. Return NULL if the 
        // beginning of the list was reached
        c* Prev()
        {
            if(_pLink == &_pList->_Head)
            {
                return NULL;
            }
            
            _pLink = _pLink->Blink;
            
            return Get();
        }
        
        // Remove
        // Remove and return the current entry. Return NULL if at the end of the list or 
        // the beginning of the list
        c* Remove()
        {
            LINK* pRet = NULL;
            
            if(_pLink == &_pList->_Head ||
               _pLink == &_pList->_Tail)
            {
                return NULL;
            }
             
            pRet = _pLink;
            _pLink = (LINK*)_pLink->Blink;
            _pList->Remove(pRet);
            
            return (c*) pRet;
        }

        // Get
        // Return the current entry. Return NULL if the list is empty or the iterator is 
        // at the end or the beginning of the list
        c* Get()
        {
            if(_pLink == &_pList->_Head ||
               _pLink == &_pList->_Tail)
            {
                return NULL;
            }

            return (c*) _pLink;
        }
        
    protected:
    
        friend TList<c,n>;
        
        void Attach(TList* pList, LINK* pLink)
        {
            _pList = pList;
            _pLink = pLink;
        }
        
        TList* _pList;
        LINK* _pLink;
    };

    // Begin
    // Initialize an iterator at the first element of the list
    void Begin(Iterator* pit)
    {
        pit->Attach(this, (LINK*)_Head.Flink);
    }
    
    // End
    // Initialize an iterator at the last element of the list
    void End(Iterator* pit)
    {
        pit->Attach(this, (LINK*)_Tail.Blink);
    }
    
protected:

    void InsertBefore(LINK* pRef, LINK* pNewNode)
    {
        DBGASSERT(pRef != &_Head);
        
        pNewNode->Blink    = pRef->Blink;
        pNewNode->Flink    = pRef;
        pRef->Blink->Flink = pNewNode;
        pRef->Blink        = pNewNode;
    }
    
    void Remove(LINK* pRef)
    {
        DBGASSERT(pRef != &_Head);
        DBGASSERT(pRef != &_Tail);
        
        pRef->Blink->Flink = pRef->Flink;
        pRef->Flink->Blink = pRef->Blink;
        pRef->Blink = NULL;
        pRef->Flink = NULL;
    }

    friend Iterator;
    
    LINK _Head;
    LINK _Tail;
};

// --------------------------------------------------------------------------------------
// CLookAsideList
// Look-aside list 
// --------------------------------------------------------------------------------------
class CLookAsideList : public IMemAlloc
{
public:
    
    CLookAsideList() : 
        _pAlloc(NULL)
    {
    }
    
    virtual ~CLookAsideList()
    {
        Term();
    }

    // Init
    // initialize look-aside list
    // - cbObject: size of the object in bytes. This is the size of the buffer returned by 
    // each call to Alloc()
    // - pAlloc: optional allocator
    void Init(DWORD cbObject, DWORD cMaxPooled, IMemAlloc* pAlloc = NULL);
    
    // Term
    // Release resources
    void Term();

    BOOL PreAlloc(DWORD objectCount);
    
    // Alloc
    // IMemAlloc allocation method.
    // - size: size of the object. It must be equal to _cbObject or the call will fail
    // Return: pointer to object
    virtual void* Alloc(size_t size);
    
    // Alloc
    // Allocate an object
    // Return: pointer to object
    void* Alloc();
    
    // Free
    // Return an object to the pool
    // - pObject: must be a pointer previously allocated by Alloc()
    virtual void Free(void* pObject);
    
protected:

    
    DWORD _cbObject;                        // Size of object in bytes
    DWORD _cMaxPooled;                      // Max number of objects in pool (0 = infinite)
    IMemAlloc* _pAlloc;                     // Allocator
    DECLSPEC_ALIGN(16) TLFStack<CSingleLink> _lookAsideList;   // lock-free stack for the pool
};

/*****************************************************************************
  CArrayBase
  Don't use this. Use TArray instead.
*****************************************************************************/
class CArrayBase
{
public:

    ~CArrayBase()
    {
        Term();
    }

    void Term()
    {
        if(_pData != NULL && _pData != _pLocalData)
        {
            _pAlloc->Free(_pData);
            _pData = NULL;
        }
    }

    bool SetAllocator(IMemAlloc* pAlloc);

    // GetSize
    // Return the size of the array
    int GetSize() const
    {
        return _iSize;
    }
    
    // Grow
    // Grows the array, if necessary, to a new capacity
    bool Grow(int iNewCapacity);
    
    // SetSize
    // Use it to manually set the size of the array
    bool SetSize(int iSize);

protected:

    CArrayBase(int iDataSize, int iCapacity, void* pLocalData) : 
        _pLocalData(pLocalData),
        _pData(pLocalData),
        _iDataSize(iDataSize),
        _iCapacity(iCapacity),
        _iSize(0),
        _pAlloc(NULL)
    {
    }

    void*      _pLocalData;
    void*      _pData;
    int        _iDataSize;
    int        _iCapacity;
    volatile int _iSize;
    IMemAlloc* _pAlloc;
};

/*****************************************************************************
  TArray
  Generic array. 
*****************************************************************************/
template <
    class DATATYPE, // Type of the data stored in the array
    int CAPACITY    // Initial capacity of the array
>
class TArray : public CArrayBase
{
public:
    
    CUTIL_INLINE TArray() : CArrayBase(sizeof(DATATYPE), CAPACITY, _rgLocalData)
    {
    }
    
    CUTIL_INLINE void Set(int iNdx, DATATYPE data)
    {
        DBGASSERT(iNdx < _iSize);
        ((DATATYPE*)_pData)[iNdx] = data;
    }

    CUTIL_INLINE DATATYPE Get(int iNdx)
    {
        DBGASSERT(iNdx < _iSize);
        return ((DATATYPE*)_pData)[iNdx];
    }

    CUTIL_INLINE bool Add(DATATYPE data)
    {
        if(SetSize(_iSize+1))
        {
            Set(_iSize-1, data);
            return true;
        }
        else
        {
            return false;
        }
    }
    
    // Inherited from CArrayBase:
    //   int GetSize()
    //   bool SetSize(int iSize) 

protected:

    DATATYPE  _rgLocalData[CAPACITY];
};

template <class KEYTYPE>
class TDefaultHashClass
{
public:
    
    CUTIL_INLINE DWORD GetHash(KEYTYPE key)
    {
        static const DWORD largest_prime_dword = 4294967279;
        return (DWORD) ((SIZE_T)key % largest_prime_dword);
    }
    
    CUTIL_INLINE bool IsEqual(KEYTYPE keyA, KEYTYPE keyB)
    {
        return keyA == keyB;
    }
};

class CStringHashClass
{
public:
    
    static DWORD GetHash(const char* p)
    {
        DWORD hash = 5381;
        
        for(; *p != 0; p++)
        {
            hash = ((hash << 5) + hash) + *p;
        }

        return hash;
    }

    static bool IsEqual(const char* pa, const char* pb)
    {
        return _stricmp(pa, pb) == 0;
    }
};

DWORD GetNearestPrime(DWORD dwTarget);

template <
    class KEYTYPE,
    class DATATYPE,
    class HASHCLASS = TDefaultHashClass<KEYTYPE>
>
class THashtable
{
public:
    
    THashtable() :
        _pSlots(NULL), 
        _fLocal(false), 
        _loadFactor(1.00),
        _dwCapacity(0),
        _dwMaxCount(0),
        _dwCount(0),
        _pAlloc(NULL)
    {
    }
    
    ~THashtable()
    {
        Term();
    }

    void Term()
    {
        if(!_fLocal && _pSlots != NULL)
        {
            _pAlloc->Free(_pSlots);
            _pSlots = NULL;
        }
    }

    
    bool SetAllocator(IMemAlloc* pAlloc)
    {
        if((_fLocal || !_pSlots) && _dwCount == 0)
        {
            _pAlloc = pAlloc;
            return true;
        }
        else
        {
            DBGASSERT(!"Can't call SetAllocator after the array was used");
            return false;
        }
    }
    
    void SetLoadFactor(float lf)
    {
        DBGASSERT(lf > 0.1 && lf <= 1.0);
        _loadFactor = lf;
    }
    
    bool Set(KEYTYPE key, DATATYPE data)
    {
        if(_dwCount+1 >= _dwMaxCount)
        {
            if(!Grow(_dwCapacity*2 + 1))
                return false;
        }
        
        DWORD dwIdealSlot = HASHCLASS().GetHash(key) % _dwCapacity;
        DWORD dwSlot      = dwIdealSlot;
        
        while(_pSlots[dwSlot].dwIdealSlot != AVAILABLE && !HASHCLASS().IsEqual(key, _pSlots[dwSlot].key))
        {
            dwSlot = (dwSlot + 1) % _dwCapacity;
        }
        
        if(_pSlots[dwSlot].dwIdealSlot == AVAILABLE)
            _dwCount++;
        
        _pSlots[dwSlot].key         = key;
        _pSlots[dwSlot].data        = data;
        _pSlots[dwSlot].dwIdealSlot = dwIdealSlot;
        
        return true;
    }
    
    DATATYPE* GetReference(KEYTYPE key)
    {
        if(_dwCount == 0)
            return NULL;
        
        DWORD dwSlot = HASHCLASS().GetHash(key) % _dwCapacity;
        
        while(_pSlots[dwSlot].dwIdealSlot != AVAILABLE)
        {
            if(HASHCLASS().IsEqual(key, _pSlots[dwSlot].key))
            {
                return &_pSlots[dwSlot].data;
            }
           
            dwSlot = (dwSlot + 1) % _dwCapacity;
        }
        
        return NULL;
    }
    
    bool Get(KEYTYPE key, DATATYPE* pData)
    {
        if(_dwCount == 0)
            return false;
        
        DATATYPE* pDataRef;
        
        if((pDataRef = GetReference(key)) != NULL)
        {
            if(pData != NULL)
            {
                *pData = *pDataRef;
            }
            
            return true;
        }
        else
        {
            return false;
        }
    }
    
    bool Remove(KEYTYPE key, DATATYPE* pData)
    {
        if(_dwCount == 0) // BUGBUG: Nasty bug on boundaries
            return false;
        
        DWORD dwSlot = HASHCLASS().GetHash(key) % _dwCapacity;
        
        while(_pSlots[dwSlot].dwIdealSlot != AVAILABLE)
        {
            if(HASHCLASS().IsEqual(key, _pSlots[dwSlot].key))
            {
                break;
            }
           
            dwSlot = (dwSlot + 1) % _dwCapacity;
        }
        
        if(AVAILABLE == _pSlots[dwSlot].dwIdealSlot)
            return false;
            
        if(pData != NULL)
            *pData = _pSlots[dwSlot].data;
            
        DWORD dwEmptySlot = dwSlot;
        dwSlot = (dwSlot + 1) % _dwCapacity;

        int nCurrentDistance = 0;
        int nNewDistance     = 0;
        
        while(_pSlots[dwSlot].dwIdealSlot != AVAILABLE)
        {
            if(_pSlots[dwSlot].dwIdealSlot != dwSlot)
            {
                //You can only scan to the right
               nCurrentDistance = (dwSlot      >= _pSlots[dwSlot].dwIdealSlot)? dwSlot      - _pSlots[dwSlot].dwIdealSlot: (_dwCapacity - _pSlots[dwSlot].dwIdealSlot) + dwSlot;
               nNewDistance     = (dwEmptySlot >= _pSlots[dwSlot].dwIdealSlot)? dwEmptySlot - _pSlots[dwSlot].dwIdealSlot: (_dwCapacity - _pSlots[dwSlot].dwIdealSlot) + dwEmptySlot;
                
               if (nNewDistance < nCurrentDistance)
               {
                   _pSlots[dwEmptySlot].key         = _pSlots[dwSlot].key;
                   _pSlots[dwEmptySlot].data        = _pSlots[dwSlot].data;
                   _pSlots[dwEmptySlot].dwIdealSlot = _pSlots[dwSlot].dwIdealSlot;
                    
                   dwEmptySlot = dwSlot;
               }
            }
            
            dwSlot = (dwSlot + 1) % _dwCapacity;
        }
        
        _pSlots[dwEmptySlot].dwIdealSlot = AVAILABLE;    
        _dwCount--;
        
        return true;
    }
    
    bool Grow(DWORD dwTargetCapacity)
    {
        if(!_pAlloc)
        {
            // can't allocate without a buffer
            return false;
        }
        
        bool fRet          = true;
        slot_t* pNewBuffer = NULL;

        if(dwTargetCapacity > _dwCapacity)
        {
            // Allocate a new buffer
            DWORD dwNewCapacity = GetNearestPrime(dwTargetCapacity);
            
            pNewBuffer = (slot_t*) _pAlloc->Alloc(dwNewCapacity * sizeof(slot_t));
            if(NULL == pNewBuffer)
            {
                fRet = false;
                goto lDone;
            }
            
            // Use a temporary hashtable object to rehash the data
            THashtable temphash(pNewBuffer, dwNewCapacity);
            for(DWORD i=0; i < _dwCapacity; i++)
            {
                // Shortcut
                if(_dwCount == temphash.GetCount())
                    break;
                    
                if(_pSlots[i].dwIdealSlot != AVAILABLE)
                    temphash.Set(_pSlots[i].key, _pSlots[i].data);
            }
            
            // Replace the previous buffer with the new one
            if(_pSlots != NULL && !_fLocal)
            {
                _pAlloc->Free(_pSlots);
            }
            
            _pSlots     = pNewBuffer;
            _fLocal     = false;
            _dwCapacity = dwNewCapacity;
            _dwMaxCount = (DWORD)(_dwCapacity * _loadFactor) - 1;
            
            pNewBuffer  = NULL;
        }
        
    lDone:
    
        if(pNewBuffer != NULL)
        {
            _pAlloc->Free(pNewBuffer);
            pNewBuffer = NULL;
        }
            
        return fRet;
    }
    
    void Reset()
    {
        for(int i=0; i < _dwCapacity; i++)
        {
            _pSlots[i].dwIdealSlot = AVAILABLE;
        }
        
        _dwCount = 0;
    }
    
    DWORD GetCount() const
    {
        return _dwCount;
    }
    
    class Iterator
    {
    friend THashtable;
    public:
    
        Iterator()
        {
            _pHashtable    = NULL;
            _dwCurrentSlot = 0;
        }
        
        Iterator(THashtable* pHashtable)
        {
            _pHashtable    = pHashtable;
            _dwCurrentSlot = 0;
        }
        
        void Reset()
        {
            _dwCurrentSlot = 0;
        }
        
        bool GetNext(KEYTYPE* pKey, DATATYPE* pData)
        {
            while(_dwCurrentSlot < _pHashtable->_dwCapacity && 
                 _pHashtable->_pSlots[_dwCurrentSlot].dwIdealSlot == AVAILABLE)
            {
                _dwCurrentSlot++;
            }

            if(_dwCurrentSlot < _pHashtable->_dwCapacity)
            {
                if(pKey != NULL)
                    *pKey  = _pHashtable->_pSlots[_dwCurrentSlot].key;
                    
                if(pData != NULL)
                    *pData = _pHashtable->_pSlots[_dwCurrentSlot].data;
                    
                _dwCurrentSlot++;
                return true;
            }
            else
            {
                return false;
            }
        }
        
    protected:
    
        void Init(THashtable* pHashtable)
        {
            _pHashtable = pHashtable;
            _dwCurrentSlot = 0;
        }
    
        THashtable* _pHashtable;
        DWORD       _dwCurrentSlot;
    };

    void InitializeIterator(Iterator* pit)
    {
        pit->Init(this);        
    }

protected:

    enum
    {
        AVAILABLE     = 0xFFFFFFFF
    };
    
    typedef struct 
    {
        KEYTYPE  key;
        DATATYPE data;
        DWORD    dwIdealSlot;
    } slot_t;
    
    enum
    {
        SLOT_SIZE = sizeof(slot_t)
    };
    
    THashtable(void* pLocalData, DWORD dwCapacity) :
        _pSlots((slot_t*)pLocalData), 
        _fLocal(true), 
        _loadFactor(0.75),
        _dwCapacity(dwCapacity),
        _dwMaxCount((DWORD)(_dwCapacity * _loadFactor) - 1),
        _dwCount(0),
        _pAlloc(NULL)
    {
        FillMemory(_pSlots, sizeof(slot_t) * _dwCapacity, 0xFF);
    }

    friend Iterator;
    
    float      _loadFactor;
    slot_t*    _pSlots;
    bool       _fLocal;
    DWORD      _dwCapacity;
    DWORD      _dwMaxCount;
    DWORD      _dwCount;
    IMemAlloc* _pAlloc;
};

template <
    int CAPACITY, 
    class KEYTYPE,
    class DATATYPE,
    class HASHCLASS = TDefaultHashClass<KEYTYPE>
>
class TStackHashtable : public THashtable<KEYTYPE, DATATYPE, HASHCLASS>
{
public:

    typedef THashtable<KEYTYPE, DATATYPE, HASHCLASS> HASHTABLE;

    TStackHashtable() : THashtable<KEYTYPE, DATATYPE, HASHCLASS> (_rgLocal, CAPACITY)
    {
    }

protected:
    BYTE _rgLocal[CAPACITY * HASHTABLE::SLOT_SIZE];
};

template <class T>
class THeapNoNotify
{
public:
    static void OnHeapNewPosition(T v, DWORD nNewPos)
    {
        // NO-OP
    }
};

template <
    class T,
    int INITIAL_CAPACITY,
    class COMPARE,
    class NOTIFYONNEWPOSITION=THeapNoNotify<T>
>
class THeap
{
public:
    
    void Term()
    {
        _array.Term();
    }
    
    bool SetAllocator(IMemAlloc* pAlloc)
    {
        return _array.SetAllocator(pAlloc);
    }
    
    bool Grow(DWORD dwCapacity)
    {   
        DWORD dwSize = _array.GetSize();
        
        if(dwSize >= dwCapacity)
            return true;
        
        bool fRet = _array.SetSize(dwCapacity);
        
        if(fRet)
        {
            _array.SetSize(dwSize);
        }
        
        return fRet;
    }

#if _TEST
    bool Verify(DWORD nIndex, int nLevel)
    {
        if (nIndex >= GetCount())
        {
            return true;
        }
        
        bool fRet = true;

        int nStartIndex = (1<< nLevel)      - 1;
        int nEndIndex  =  (1<<(nLevel + 1)) - 1;

        DWORD nChildrenIndexStart = (nIndex - nStartIndex) * 2 + nEndIndex ;        

        T node  = _array.Get(nIndex);

        if (nChildrenIndexStart >= GetCount() )
        {
            return fRet;
        }
        
        T node1 = _array.Get(nChildrenIndexStart);
        fRet = COMPARE::HeapCompare(node1, node) >= 0;

        if (nChildrenIndexStart + 1>=GetCount())
        {
            return fRet;
        }
        
        T node2 = _array.Get(nChildrenIndexStart + 1);        
        fRet = fRet && COMPARE::HeapCompare(node2, node) >= 0;

        if (!fRet)
            return false;
        else
            return Verify(nChildrenIndexStart, nLevel + 1) && Verify(nChildrenIndexStart + 1, nLevel + 1);
    }
#endif

    bool Insert(
        T node
    )
    {
        bool fRet = false;
        
        DWORD dwSlot = _array.GetSize();
        
        if(!_array.SetSize(_array.GetSize()+1))
            goto lDone;
            
        _array.Set(dwSlot, node);
        
        NOTIFYONNEWPOSITION::OnHeapNewPosition(node, dwSlot);
        
        UpHeap(dwSlot);
        
        fRet = true;
    
    lDone:
        
        return fRet;
    }

    T Remove(
        DWORD dwIndex
    )
    {
        DBGASSERT(dwIndex < GetCount());
    
        T ret = _array.Get(dwIndex);

        _array.Set(dwIndex, _array.Get(GetCount()-1));
        
        NOTIFYONNEWPOSITION::OnHeapNewPosition(_array.Get(dwIndex), dwIndex);

        _array.SetSize(_array.GetSize()-1);

        if(GetCount() > 0)
        {   
            if (dwIndex < GetCount() - 1)
            {
                DownHeap(dwIndex);
            }

            if (dwIndex != 0 && dwIndex < GetCount())
            {
                //random removal may require an upheap
                UpHeap(dwIndex);
            }
        }

        return ret;
    }

    T Peek(
        DWORD dwIndex
    )
    {
        return _array.Get(dwIndex);
    }

    DWORD GetCount()
    {
        return _array.GetSize();
    }

//     void Dump()
//     {
//         int iCount = GetCount();
//
//         for(int i=0; i < iCount; i++)
//         {
//             printf("%d(%d) ", _array.Get(i)->iValue, _array.Get(i)->dwIndex);
//         }
//         printf("\n");
//     }

protected:

    void UpHeap(
        DWORD dwIndex
    )
    {
        T v = _array.Get(dwIndex);

        while(dwIndex > 0 && COMPARE::HeapCompare(_array.Get((dwIndex-1) / 2), v) > 0)
        {
            _array.Set(dwIndex, _array.Get((dwIndex-1) / 2));
    
            NOTIFYONNEWPOSITION::OnHeapNewPosition(_array.Get(dwIndex), dwIndex);

            dwIndex = (dwIndex-1)/2;
        }

        _array.Set(dwIndex, v);

        NOTIFYONNEWPOSITION::OnHeapNewPosition(_array.Get(dwIndex), dwIndex);
    }

    void DownHeap(
        DWORD dwIndex
    )
    {
        T v = _array.Get(dwIndex);
    
        DWORD dwSize = GetCount();

        while(dwIndex < dwSize / 2)
        {
            DWORD j = (dwIndex * 2) + 1;

            if(j < (dwSize-1) && COMPARE::HeapCompare(_array.Get(j),_array.Get(j+1)) > 0)
            {
                j++;
            }

            if(COMPARE::HeapCompare(v, _array.Get(j)) <= 0)
            {
                break;
            }

            _array.Set(dwIndex, _array.Get(j));

            NOTIFYONNEWPOSITION::OnHeapNewPosition(_array.Get(dwIndex), dwIndex);

            dwIndex = j;
        }

        _array.Set(dwIndex, v);

        NOTIFYONNEWPOSITION::OnHeapNewPosition(_array.Get(dwIndex), dwIndex);
    }
    
    TArray<T,INITIAL_CAPACITY> _array;
};

__forceinline int WrapDWORDCompare(DWORD dwLeft, DWORD dwRight, DWORD* pdwDiff)
{
    DWORD dwDiffLR;
    DWORD dwDiffRL;

    if (dwLeft == dwRight)
    {
        if(pdwDiff != NULL)
            *pdwDiff = 0;
            
        return 0;
    }
    else
    {
        // Shorest distance will tell us which is likely later (within 20+ days)
        dwDiffLR = dwLeft  - dwRight;
        dwDiffRL = dwRight - dwLeft;
        
        if(dwDiffLR < dwDiffRL)
        {
            if(pdwDiff != NULL)
                *pdwDiff = dwDiffLR;
            
            return 1; // dwLeft is likely later
        }
        else
        {
            if(pdwDiff != NULL)
                *pdwDiff = dwDiffRL;
            
            return -1; // dwRight is likely later
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_string.h ===
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// cu_string.h
//
// String classes and utilities
// Don't include this file directly. Instead include cutil.h
//
// * Use CConstStr and CConstWStr to manipulate constant strings. The CSTR and 
// CWSTR macros can help. As a matter of fact, the macros should be used in 
// most cases.
//
// * Use CTinyStr, CSmallStr or CLargeStr (or their unicode friends) for 
// mutable strings. You can also use TLocalStr to declare strings with 
// different local buffer sizes. All these strings can (but will not by 
// default) dynamically grow on demand.
// 
// * Use CStr or CWStr to pass string references around.
//
// Some usage examples:
//
// CTinyStr s;
// s.CopyFrom("Hello world ineficiently \n");     // This works
// s.CopyFrom(CSTR("Hello world eficiently \n")); // but this works even better
//
// // cstr() can be used to access the null terminated string buffer
// // Btw, CopyFrom will concatenate instead of overwrite so, in this case,
// // both 'Hello Worlds' will be displayed.
// puts(s.cstr());
//
// // Strings inherited from TLocalStr have fixed size local buffers that
// // by default won't grow. All TStr methods will try to write as much as they
// // can (always null terminating).
// CLargeStr l1;
// l1.CopyFrom(pszSuperLargeString);  // truncate and return false!
//
// CLargeStr l2
// l2.SetAllowGrow();
// l2.CopyFrom(pszSuperLargeString);  // grow, copy and return true!
//
// // Format functions follow the same rules. They can cause the buffer to grow
// // if necessary (and AutoGrow is enabled)
// struct {
//     int x;
//     int y;
// } coords = { 10, 20 };
// printf("Coords: %s \n",
//        CTinyStr().Format("[x=%d,y=%d]", coords.x, coords.y).cstr());
//
//
// 64bit code readiness: The code compiles on 64bit, but it uses UINT42 bit as
// types for size. It could be argued that size_t is the appropriate type, but,
// alas, making the change after the code was build would require signature
// type changes. It is correct that not all of the functions need to be changed, 
// however, it doesn't seem that having string classes with more than 4M characters
// is a requirement for this.
//
// ----------------------------------------------------------------------------

#pragma once

// --------------------------------------------------------------------------------------
// CBuffer
// Byte buffer utility class that supports local (static) buffers and dynamic 
// allocations, growth and automatic clean-up.
// --------------------------------------------------------------------------------------

class CConstBuffer
{
public:

    CConstBuffer(const void* pBuffer, DWORD size) :
        _pBuffer((void*)pBuffer),
        _size(size)
    {
    }
    
    // GetSize
    inline DWORD GetSize() const
    {
        return _size;
    }
    
    // GetConstPtr
    // Get pointer to internal buffer
    inline const void* GetConstPtr() const
    {
        return (const void*) _pBuffer;
    }

protected:
    
    void*  _pBuffer;        // pointer to internal buffer
    DWORD  _size;           // logical size
};

class CBuffer : public CConstBuffer
{
public:
    
    CBuffer(void* plocalBuffer, DWORD capacity, DWORD size) :
        CConstBuffer(plocalBuffer, size),
        _palloc(NULL),
        _capacity(capacity),
        _flags(FLAG_LOCAL_BUFFER)
    {
    }

    ~CBuffer()
    {
        if(!IsLocalBuffer() && _pBuffer)
        {
            _palloc->Free(_pBuffer);
        }
    }
    
    // IsLocalBuffer
    // Returns whether the internal buffer is local (static)
    bool IsLocalBuffer() const 
    {
        return (_flags & FLAG_LOCAL_BUFFER) != 0;
    }

    // HasFailed
    // Returns whether an error (most likely a memory allocation error) happened since 
    // the last Reset
    bool HasFailed() const
    {
        return (_flags & FLAG_ERROR) != 0;
    }
    
    // GetPtr
    // Get pointer to internal buffer
    inline const void* GetPtr() const
    {
        return _pBuffer;
    }

    // SetAllocator
    // Sets the allocator used to grow the buffer. Must be called before calling 
    // SetCapacity. E.g. buffer.SetAllocator(CMemAlloc::GetDefaultAlloc())
    void SetAllocator(IMemAlloc* palloc)
    {
        DBGASSERT(palloc || "Allocator cannot be set to NULL");
        DBGASSERT(!_palloc || "Allocator cannot be changed once it's set");
        
        _palloc = palloc;
    }

    // SetCapacity
    // Sets the internal capacity, or the real buffer size. If the specified capacity is 
    // less or equal to the current capacity, nothing is changed. Otherwise the internal 
    // buffer is expanded. SetAllocator must be called before calling SetCapacity.
    bool SetCapacity(DWORD capacity)
    {
        if(capacity < _capacity)
        {
            return true;
        }

        if(!_palloc)
        {
            // Can't grow without an allocator. Use SetAllocator to specify a allocator 
            // first.
            
            _flags |= FLAG_ERROR;
            return false;
        }

        void* pnewBuffer = NULL;

        pnewBuffer = _palloc->Alloc(capacity);

        if(!pnewBuffer)
        {
            _flags |= FLAG_ERROR;
            return false;
        }

        if(_size != 0)
        {
            memcpy(pnewBuffer, _pBuffer, _size);
        }

        //
        // Release original buffer 
        //
        
        if(_pBuffer != NULL && !IsLocalBuffer())
        {
            _palloc->Free(_pBuffer);
        }
        else
        {
            // original buffer was local but the new one is not
            _flags &= ~FLAG_LOCAL_BUFFER;
        }

        _pBuffer  = pnewBuffer;
        _capacity = capacity;

        return true;
    }

    // GetCapacity
    // Returns the capacity or real buffer size
    inline DWORD GetCapacity() const
    {
        return _capacity;
    }

    // SetSize
    // Sets the logical buffer size or how much space is allocated in the internal 
    // buffer. If the new size if greater than the capacity, the buffer is expanded. 
    bool SetSize(DWORD size)
    {
        if(size > _capacity)
        {
            if(!SetCapacity(size))
            {
                return false;
            }
        }

        _size = size;

        return true;
    }

    // Reset
    // Set buffer size to zero and reset error flags. This doesn't change the capacity or 
    // release any resources.
    void Reset()
    {
        _size  = 0;
        _flags  &= ~FLAG_ERROR;
    }

    // CopyFrom
    // Copy from another buffer. This *adds* to the current buffer. For example, copying 
    // two 10 byte buffers will result in 20 bytes.
    bool CopyFrom(void* pbuffer, DWORD size)
    {
        if(!SetSize(_size + size))
        {
            _flags |= FLAG_ERROR;
            return false;
        }

        void* ptarget = ((BYTE*)_pBuffer) + _size - size;

        memcpy(ptarget, pbuffer, size);

        return true;
    }
    
    // HasRoom
    // Checks whether the buffer size can grow by a specified amount. If there is not enough 
    // space left, try to grow the buffer.
    //   * size: size in bytes that should be available
    // Returns:
    //  true - if there is enough space
    //  false - if there isn't and it failed to grow (for example, if the buffer isn't 
    //  configured with an allocator)
    bool HasRoom(UINT32 size)
    {
        return SetCapacity(_size + size);
    }
    
    // StartWrite
    // This method allows the programmer to write to the buffer "manually". It returns a 
    // pointer to the end of the buffer and the maximum number of bytes that can be 
    // written. When you're done writting, call EndWrite to adjust the length of the 
    // buffer.
    //  * pMaxWrite: OUT: the number of bytes that can written.
    // Returns:
    //  Pointer to the end of the buffer
    BYTE* StartWrite(UINT32* pMaxWrite)
    {
        DBGASSERT(pMaxWrite);
        *pMaxWrite = _capacity - _size;
        return ((BYTE*)_pBuffer) + _size;
    }

    // EndWrite
    // Called after StartWrite to adjust the length of the buffer
    //  * written: number of characters written to the end of the buffer
    void EndWrite(UINT32 written)
    {
        _size += written;
        DBGASSERT(_size <= _capacity);
    }

protected:
    
    enum
    {
        FLAG_LOCAL_BUFFER   = 0x01,     // _pBuffer points to a local buffer (allocator was not used)
        FLAG_ERROR          = 0x02,     // indicates that a previous operation found an error
    };

    IMemAlloc* _palloc;         // memory allocator used to grow the internal buffer
    DWORD      _capacity;       // real internal buffer size
    DWORD      _flags;          // combination of FLAG_*
};

// --------------------------------------------------------------------------------------
// TLocalBuffer
// Like CBuffer but with a starting static buffer
// --------------------------------------------------------------------------------------
template <int size>
class TLocalBuffer : public CBuffer
{
public:

    TLocalBuffer() :
        CBuffer(_localbuffer, sizeof(_localbuffer), 0)
    {
    }

protected:

    BYTE _localbuffer[size];
};

typedef TLocalBuffer<80>       CTinyBuffer;
typedef TLocalBuffer<250>      CSmallBuffer;
typedef TLocalBuffer<4000>     CLargeBuffer;

// ----------------------------------------------------------------------------
// CStrCharTrait
// Define the characteristics of ANSI strings
// ----------------------------------------------------------------------------
class CStrCharTrait
{
public:

    typedef char CHARTYPE;

    inline static UINT32 GetLength(const CHARTYPE* pStr)
    {
        return strlen(pStr);
    }

    inline static INT32 ToLower(CHARTYPE c)
    {
        return tolower((unsigned char)c);
    }

    inline static INT32 ToUpper(CHARTYPE c)
    {
        return toupper((unsigned char)c);
    }

    inline static INT32 IsPrint(CHARTYPE c)
    {
        return isprint((unsigned char)c);
    }

    inline static int FormatV(CHARTYPE* buffer, size_t count, const CHARTYPE* format, va_list argptr)
    {
        // msdn says if "count" is 0, this function should return -1. My experience says 
        // it doesn't, it actually returns the number of characters written (or to be 
        // written?).
        if (count == 0)
        {
            return -1;
        }
        return _vsnprintf(buffer, count, format, argptr);
    }

    inline static CHARTYPE* EmptyString()
    {
        return "";
    }
};

// ----------------------------------------------------------------------------
// CWStrCharTrait
// Define the characteristics of UNICODE strings
// ----------------------------------------------------------------------------
class CWStrCharTrait
{
public:

    typedef wchar_t CHARTYPE;

    static UINT32 GetLength(const CHARTYPE* pStr)
    {
        return wcslen(pStr);
    }
    
    inline static INT32 ToLower(CHARTYPE c)
    {
        return towlower(c);
    }
    
    inline static INT32 ToUpper(CHARTYPE c)
    {
        return towupper(c);
    }
    
    inline static INT32 IsPrint(CHARTYPE c)
    {
        return iswprint(c);
    }

    inline static int FormatV(CHARTYPE* buffer, size_t count, const CHARTYPE* format, va_list argptr)
    {
        // msdn says if "count" is 0, this function should return -1. My experience says 
        // it doesn't, it actually returns the number of characters written (or to be 
        // written?).
        if (count == 0)
        {
            return -1;
        }
        return _vsnwprintf(buffer, count, format, argptr);
    }

    inline static CHARTYPE* EmptyString()
    {
        return L"";
    }
};

// ----------------------------------------------------------------------------
// TConstStr
// Abstraction of a constant, null-terminated string.
// ----------------------------------------------------------------------------
template <class ct>
class TConstStr
{
public:
    
    typedef ct                           CHAR_TRAIT;     // Char trait class
    typedef TConstStr<ct>                CSTR_T;         // Alias for the templated class
    typedef typename ct::CHARTYPE        CHARTYPE;       // Alias for char type
    typedef typename ct::CHARTYPE*       PCHARTYPE;      // Pointer to char type
    typedef typename const ct::CHARTYPE* PCCHARTYPE;     // Const pointer to char type

    TConstStr()
    {
        _pBuffer = CHAR_TRAIT::EmptyString();
        _length  = 0;
    }

    TConstStr(PCCHARTYPE pStr)
    {
        _pBuffer = (PCHARTYPE) pStr;
        _length  = CHAR_TRAIT::GetLength(pStr);
    }

    TConstStr(PCCHARTYPE pStr, UINT32 length)
    {
        _pBuffer = (PCHARTYPE) pStr;
        _length  = length;
    }
    
    PCCHARTYPE cstr() const
    {
        return (PCCHARTYPE) _pBuffer;
    }

    UINT32 GetLength() const
    {
        return _length;
    }

    bool IsEmpty() const
    {
        return (_length == 0);
    }

    const CHARTYPE& operator[] (size_t index) const
    {
        //if (index >= _length)
        //    return NULL;
        //else
            return _pBuffer[index];
    }

    bool IsEqualTo(CSTR_T& str) const
    {
        if(_length != str._length)
            return false;

        for(UINT32 i = 0; i < _length; i++)
        {
            if(_pBuffer[i] != str._pBuffer[i])
                return false;
        }

        return true;
    }

    bool IsEqualTo(PCCHARTYPE pszStr)
    {
        return IsEqualTo(CSTR_T(pszStr));
    }

    bool IsCaseInsensitiveEqualTo(CSTR_T& str)
    {
        if(_length != str._length)
            return false;

        for(UINT32 i = 0; i < _length; i++)
        {
            if(CHAR_TRAIT::ToLower(_pBuffer[i]) != CHAR_TRAIT::ToLower(str._pBuffer[i]))
                return false;
        }
        
        return true;
    }

    bool IsCaseInsensitiveEqualTo(PCCHARTYPE pszStr)
    {
        return IsCaseInsensitiveEqualTo(CSTR_T(pszStr));
    }

    // For some reason TStr cannot access these if they are protected. I'm
    // leaving them public for now. Ugly but not critical.

    UINT32          _length;            // Length of the string in characters
    PCHARTYPE       _pBuffer;           // Pointer to buffer where the string is being stored
};

typedef TConstStr<CStrCharTrait>         CConstStr;
typedef TConstStr<CWStrCharTrait>        CConstWStr;

// CConstStr is more efficient if the 2 parameter constructor is used. These
// macros should help.
#define REF_AND_SIZE(x)     x, ARRAY_SIZE(x)-1
#define CSTR(x)             CConstStr(REF_AND_SIZE(x))
#define CWSTR(x)            CConstWStr(REF_AND_SIZE(x))

// ----------------------------------------------------------------------------
// TStr
// Abstraction of a null-terminated string.
// This class cannot be instantiated directly. Notice the lack of a public 
// constructor. It can be used, or better, it SHOULD be used, to reference 
// objects of classes that inherit from TStr.
// ----------------------------------------------------------------------------
template <class ct>
class TStr : public TConstStr<ct>
{
public:
    
    TStr(PCHARTYPE pLocalBuffer, UINT32 bufferSize)
    {
        DBGASSERT(bufferSize > 0);
        
        _length     = 0;
        _pBuffer    = pLocalBuffer;
        _pAlloc     = NULL;
        _capacity   = bufferSize-1;
        _flags      = FLAG_LOCAL_BUFFER;
        _pBuffer[0] = 0;
    }

    ~TStr()
    {
        if((_flags & FLAG_LOCAL_BUFFER) == 0)
        {
            _pAlloc->Free(_pBuffer);
        }
    }

    CHARTYPE& operator[] (size_t index)
    {
        //if (index >= _length)
        //    return NULL;
        //else
            return _pBuffer[index];
    }

    // IsLocalBuffer
    // If true, the underlying buffer is local to the string object - meaning it wasn't 
    // dynamically allocated.
    // If false, the buffer was dynamically allocated
    bool IsLocalBuffer() const 
    {
        return (_flags & FLAG_LOCAL_BUFFER) != 0;
    }

    // HasFailed
    // If true, an error has occurred since the last time Reset() was called. It can be a 
    // memory allocation error, parameter error, etc.
    bool HasFailed() const
    {
        return (_flags & FLAG_ERROR) != 0;
    }

    // HasTruncated
    // If true, an operation resulted in the string being truncated for lack of buffer 
    // space since the last time Reset() was called.
    bool HasTruncated() const
    {
        return (_flags & FLAG_TRUNCATED) != 0;
    }

    // HasFailedOrTruncated
    // Equivalent to (HasFailed() || HasTruncated())
    bool HasFailedOrTruncated() const
    {
        return HasFailed() || HasTruncated();
    }

    // GetCapacity
    // Get the size of the underlying buffer. This is not the current size of the string 
    // but the maximum string size possible without having to grow the buffer
    UINT32 GetCapacity() const
    {
        return _capacity;
    }

    // SetCapacity
    // Set the size of the underlying buffer. If the new capacity is less than the 
    // current capacity nothing is changed. Also remember that an allocator must be 
    // specified through SetAllocator() before the string can grow.
    //   * capacity: new capacity in characters
    // Returns:
    //   true if succeeded, false if it failed to allocate the buffer or if no allocator 
    //   was configured
    bool SetCapacity(UINT32 capacity)
    {
        PCHARTYPE  pNewBuffer = NULL;
        bool   ret = false;
        
        if(_capacity > capacity)
        {
            // No need to do anything
            ret = true;
            goto Cleanup;
        }
        
        if(!_pAlloc)
        {
            // Can't do anything without an allocator
            goto Cleanup;
        }

        // Allocate new buffer
        pNewBuffer = (PCHARTYPE)_pAlloc->Alloc((capacity+1) * sizeof(CHARTYPE));

        if(!pNewBuffer)
        {
            goto Cleanup;
        }

        // Copy string with the NULL terminator to new buffer
        memcpy(pNewBuffer, _pBuffer, (_length+1) * sizeof(CHARTYPE));

        // Release previous buffer if it wasn't a local buffer
        if(!IsLocalBuffer())
        {
            _pAlloc->Free(_pBuffer);
        }

        // Reference new buffer and update capacity
        _pBuffer    = pNewBuffer;
        pNewBuffer  = NULL;
        _capacity   = capacity;

        // Unset FLAG_LOCAL_BUFFER so that buffer is released appropriatelly
        RememberToReleaseBuffer();

        ret = true;

    Cleanup:

        if(!ret)
        {
            _flags |= FLAG_ERROR;
        }

        if(pNewBuffer)
        {
            _pAlloc->Free(pNewBuffer);
        }
        
        return ret;
    }
    
    // SetAllocator
    // Configure a memory allocator for this string object. This allocator will be used 
    // on operations that require the string buffer to grow
    //   * pAlloc: pointer to allocator object
    bool SetAllocator(IMemAlloc* pAlloc)
    {
        if(!IsLocalBuffer() ||
           _length != 0)
        {
            DBGASSERT(!"Cannot set allocator after string object was used");
            return false;
        }

        _pAlloc = pAlloc;
        return true;
    }

    // Reset
    // Assign an empty string (length = 0) and reset error and truncation flags. The 
    // capacity of the string remains unchanged.
    void Reset()
    {
        _pBuffer[0] = 0;
        _length     = 0;
        _flags     &= ~(FLAG_TRUNCATED | FLAG_ERROR);
    }

    // CopyFrom
    // Append a fragment of another string to the end of this string.
    //  - str: source
    //  - start: character index in source at which the copying should start
    //  - count: number of characters to copy
    // Returns:
    //  Reference to local object.
    // Remarks:
    //  To detect if an error has occurred or if the string was truncated use 
    //  HasFailed(), HasTruncated() or HasFailedOrTruncated()
    TStr<ct>& CopyFrom(CSTR_T& str, INT32 start, INT32 count)
    {
        INT32 spaceAvailable = (INT32)_capacity - _length;
       
        if(count == 0)
        {
            // shortcut
            
            return *this;
        }

        if(start < 0 || count < 0)
        {
            // Negative indexes are not allowed
            
            _flags |= FLAG_ERROR;
            return *this; 
        }

        if(start >= (INT32)str._length)
        {
            // 'start' is beyound the end of the string. Don't copy anything.
            
            count = 0;
        }

        if(count > (INT32)str._length - start)
        {
            // there aren't 'count' characters to be copied in str starting from 
            // 'start'. Copy as much as we can

            count = (INT32)str._length - start;
        }

        if(count > spaceAvailable)
        {
            // The internal buffer is not large enough. Let's try to grow it.
            
            int minCapacity = _length + count;
            
            if(!Grow(minCapacity))
            {
                // Failed to grow buffer. The reason could be that the string is 
                // not configured to grow automatically or that the allocation 
                // itself failed. Either way we'll copy as much as we can but 
                // we'll flag the truncation

                count   = spaceAvailable;
                _flags |= FLAG_TRUNCATED;
            }
        }

        for(int i=0; i < count; i++)
        {
            _pBuffer[_length + i] = str._pBuffer[start + i];
        }

        _length += count;
        _pBuffer[_length] = 0;      // Null terminate

        return *this;
    }

    // CopyFrom
    // Override that copies the entire source string (str)
    TStr<ct>& CopyFrom(CSTR_T& str) 
    {
        return CopyFrom(str, 0, str._length);
    }

    // CopyFrom
    // Override for null-terminated string pointers
    TStr<ct>& CopyFrom(PCCHARTYPE psz, INT32 start, INT32 count)
    {
        return CopyFrom(CSTR_T(psz), start, count);
    }

    // CopyFrom
    // Override for null-terminated string pointers
    TStr<ct>& CopyFrom(PCCHARTYPE psz)
    {
        return CopyFrom(CSTR_T(psz));
    }

    // FormatV
    // Like vsprintf but with all the good stuff from a string object abstraction like 
    // protection against buffer overruns and auto-growth.
    TStr<ct>& FormatV(PCCHARTYPE psz, va_list args)
    {
        int  copied = 0;

        for(;;)
        {
            copied = ct::FormatV(_pBuffer + _length, 
                                 _capacity - _length,
                                 psz,
                                 args);

            if(copied >= 0)
            {
                _length += copied;
                DBGASSERT(_length <= _capacity);
                _pBuffer[_length] = 0;
                
                return *this;
            }
            else
            {
                // there wasn't enough space. Unfortunatelly vsnprintf doesn't 
                // return how many characters we would need to perform the 
                // operation so just doubling the buffer size will have to 
                // suffice.

                if(!Grow(_capacity * 2))
                {
                    // either the object is not configured to grow (most 
                    // likely) or we ran out of memory

                    _length = _capacity;
                    _pBuffer[_length] = 0;
                    _flags |= FLAG_TRUNCATED; 

                    return *this;
                }
                else
                {
                    continue;
                }
            }
        }
    }

    // Format
    // Like sprintf but with all the good stuff from a string object abstraction like 
    // protection against buffer overruns and auto-growth.
    //  - pszFmt: format string
    //  - ...: format parameters
    // Returns:
    //  Reference to local object
    TStr<ct>& Format(PCCHARTYPE pszFmt, ...)
    {
        va_list args;
        va_start(args, pszFmt);
        FormatV(pszFmt, args);
        va_end(args);
        
        return *this;
    }

    // Trim
    // Removes trailing spaces from the beginning and from the end of the string
    // Returns:
    //  Reference to local object
    TStr<ct>& Trim()
    {
        PCHARTYPE pFirstNonSpace = NULL;
        PCHARTYPE pLastNonSpace  = NULL;
        PCHARTYPE p              = _pBuffer;

        //
        // find first non-space character
        //

        for(; *p == (CHARTYPE) ' '; p++)
            ;

        pFirstNonSpace = p;

        //
        // find last non-space character
        //

        for(;;)
        {
            // find next bundle of spaces - walk the string until we find a space or the 
            // null terminator
            for(; *p != (CHARTYPE) ' ' && *p != 0; p++)
                ;

            // remember the position of the last non-space character. Actually, 
            // pLastNonSpace points to the next character in front of the last non-space 
            // character 
            pLastNonSpace = p;

            if(*p == 0)
            {
                // end-of-string
                break;
            }


            // find the next non-space character
            for(; *p == (CHARTYPE) ' '; p++)
                ;

            if(*p == 0)
            {
                // end-of-string
                break;
            }
        }
    
        // remove spaces to the right by adjusting the string's length and replacing the 
        // null-terminator

        _length = (UINT32)(pLastNonSpace - _pBuffer);
        _pBuffer[_length] = (CHARTYPE) 0;

        // remove spaces to the left by moving data. Again, adjust the string's length and 
        // replace the null-terminator

        UINT32 countSpacesLeft = (UINT32)(pFirstNonSpace - _pBuffer);
        _length -= countSpacesLeft;
        memmove(_pBuffer, pFirstNonSpace, _length);
        _pBuffer[_length] = (CHARTYPE) 0;

        return *this;
    }

    // TruncateLength
    // Shorten the string
    TStr<ct>& TruncateLength(UINT32 length)
    {
        if (length < _length)
        {
            _length = length;
            _pBuffer[_length] = (CHARTYPE) 0;
        }
        return *this;
    }

    // ToUpper
    // Convert characters to upper-case
    TStr<ct>& ToUpper()
    {
        for(UINT32 i=0; i < _length; i++)
        {
            _pBuffer[i] = (CHARTYPE)CHAR_TRAIT::ToUpper(_pBuffer[i]);
        }

        return *this;
    }
    
    // ToLower
    // Convert characters to lower-case
    TStr<ct>& ToLower()
    {
        for(UINT32 i=0; i < _length; i++)
        {
            _pBuffer[i] = (CHARTYPE)CHAR_TRAIT::ToLower(_pBuffer[i]);
        }

        return *this;
    }

    // MakeAllPrintableCharacters
    // Ensure string is safe to print. Modifies in-place.
    TStr<ct>& MakeAllPrintableCharacters()
    {
        for(UINT32 i=0; i < _length; i++)
        {
            // No unprintable characters allowed
            if (0 == CHAR_TRAIT::IsPrint(_pBuffer[i]))
            {
                _pBuffer[i] = (CHARTYPE)'?';
            }
        }
        
        return *this;
    }

    // MakeAllLoggableCharacters
    // Ensure string is safe to log. Modifies in-place.
    TStr<ct>& MakeAllLoggableCharacters()
    {
        for(UINT32 i=0; i < _length; i++)
        {
            // No pipes or unprintable characters allowed
            if (0 == CHAR_TRAIT::IsPrint(_pBuffer[i]) ||
                (CHARTYPE)'|' == _pBuffer[i])
            {
                _pBuffer[i] = (CHARTYPE)'?';
            }
        }
        
        return *this;
    }

    // HasRoom
    // Checks whether the string can grow by a specified amount. If there is not enough 
    // space left, try to grow the buffer.
    //   * size: size in characters that should be available
    // Returns:
    //  true - if there is enough space
    //  false - if there isn't and it failed to grow (for example, if the string isn't 
    //  configured with an allocator)
    bool HasRoom(UINT32 size)
    {
        if(_length + size > _capacity)
        {
            // There isn't enough space left. Try to grow.
            return Grow(_length + size);
        }
        else
        {
            // There is enough space left
            return true;
        }
    }

    // StartWrite
    // This method allows the programmer to write to the string "manually". It returns a 
    // pointer to the end of the string and the maximum number of characters that can be 
    // written (not including null-terminator). When you're done writting, call EndWrite 
    // to adjust the length of the string.
    //  * pMaxWrite: OUT: the number of characters that can written not including the 
    //  null-terminator
    // Returns:
    //  Pointer to the end of the string
    PCHARTYPE StartWrite(UINT32* pMaxWrite)
    {
        DBGASSERT(pMaxWrite);
        *pMaxWrite = _capacity - _length;
        return _pBuffer + _length;
    }

    // EndWrite
    // Called after StartWrite to adjust the length of the string
    //  * written: number of characters written to the end of the string not counting 
    //  with the null-terminator
    void EndWrite(UINT32 written)
    {
        _length += written;
        DBGASSERT(_length <= _capacity);
        _pBuffer[_length] = (CHARTYPE) 0;
    }

protected:

    TStr(PCHARTYPE pLocalBuffer, UINT32 capacity, BOOL internal)
    {
        _length     = 0;
        _pBuffer    = pLocalBuffer;
        _pAlloc     = NULL;
        _capacity   = capacity;
        _flags      = FLAG_LOCAL_BUFFER;
        _pBuffer[0] = 0;
    }

    void RememberToReleaseBuffer()
    {
        _flags &= ~FLAG_LOCAL_BUFFER;
    }

    bool Grow(UINT32 minCapacity)
    {
        if((INT32)_capacity >= minCapacity)
        {
            // No need to grow
            return true;
        }

        if(!_pAlloc)
        {
            // can't grow without an allocator specified
            return false;
        }

        // Grow at least by 50%
        minCapacity = max(minCapacity, _capacity + _capacity / 2);

        return SetCapacity(minCapacity);
    }

    enum
    {
        FLAG_LOCAL_BUFFER   = 0x01,     // _pBuffer points to a local buffer (allocator was not used)
        FLAG_TRUNCATED      = 0x02,     // indicates the string was truncated in a previous operation
        FLAG_ERROR          = 0x04,     // indicates that a previous operation found an error
    };

    IMemAlloc*      _pAlloc;            // Allocator for growing
    UINT32          _capacity;          // Size of the buffer in characters
    UINT32          _flags;             // Combination of FLAG_* 
};

typedef TStr<CStrCharTrait>     CStr; 
typedef TStr<CWStrCharTrait>    CWStr;

// ----------------------------------------------------------------------------
// TLocalStr
// If you want modifiable strings, TLocalStr classes are the way to go. It 
// inherits everything from TStr but it also has public constructors. The 
// template parameter 'c' specifies the size of the class' local buffer.  
// Usually you will want to use CTinyStr, CSmallStr or CLargeStr (or their 
// unicode friends) instead of declaring TLocalStr directly.
// ----------------------------------------------------------------------------
template <int c>
class TLocalStr : public TStr<CStrCharTrait>
{
public:
    
    __forceinline TLocalStr() : TStr<CStrCharTrait>(_abBuffer, c, TRUE)
    {
    }
    
    __forceinline TLocalStr(CSTR_T& str) : TStr<CStrCharTrait>(_abBuffer, c, TRUE)
    {
        CopyFrom(str);
    }

    __forceinline TLocalStr(PCCHARTYPE pStr) : TStr<CStrCharTrait>(_abBuffer, c, TRUE)
    {
        CopyFrom(pStr);
    }
    
    __forceinline ~TLocalStr()
    {
    }

protected:
    
    CHARTYPE _abBuffer[c+1];                    // Local buffer
};

template <int c>
class TLocalWStr : public TStr<CWStrCharTrait>
{
public:
    
    __forceinline TLocalWStr() : TStr<CWStrCharTrait>(_abBuffer, c)
    {
    }
    
    __forceinline TLocalWStr(CSTR_T& str) : TStr<CWStrCharTrait>(_abBuffer, c)
    {
        CopyFrom(str);
    }

    __forceinline TLocalWStr(PCCHARTYPE pStr) : TStr<CWStrCharTrait>(_abBuffer, c)
    {
        CopyFrom(pStr);
    }

    __forceinline ~TLocalWStr()
    {
    }

protected:
    
    CHARTYPE _abBuffer[c+1];                    // Local buffer
};

typedef TLocalStr<80>        CTinyStr;
typedef TLocalStr<250>       CSmallStr;
typedef TLocalStr<MAX_PATH>  CMaxPathStr;
typedef TLocalStr<4000>      CLargeStr;

typedef TLocalWStr<80>       CTinyWStr;
typedef TLocalWStr<250>      CSmallWStr;
typedef TLocalStr<MAX_PATH>  CMaxPathWStr;
typedef TLocalWStr<4000>     CLargeWStr;

// deprecated
typedef CTinyStr    CVerySmallStr;
typedef CTinyWStr   CVerySmallWStr;

// ----------------------------------------------------------------------------
// CStrUtil
// String utility stuff. 
//
// Here is an example of how to use it:
//
// void PrintIp(in_addr ina)

// {
//     printf("The IP is : %s \n", CStrUtil().FormatIp(ina.S_un.S_addr));
// }
//
// Cool, huh?
// ----------------------------------------------------------------------------
class CStrUtil : public TLocalStr<40>
{
public:
    // FormatIp
    PCCHARTYPE FormatIp(UINT8 a, UINT8 b, UINT8 c, UINT8 d)
    {
        Format("%u.%u.%u.%u", a, b, c, d);
        return cstr();
    }

    // FormatIpN
    // format Ip where dwIp is in network byte order
    PCCHARTYPE FormatIpN(UINT32 dwIp)
    {
        return FormatIp((UINT8)(dwIp         & 0xFF),
                        (UINT8)((dwIp >> 8)  & 0xFF),
                        (UINT8)((dwIp >> 16) & 0xFF),
                        (UINT8)((dwIp >> 24) & 0xFF));
    }
    
    // FormatIpH
    // format Ip where dwIp is in host byte order
    PCCHARTYPE FormatIpH(UINT32 dwIp)
    {
        return FormatIp(
                        (UINT8)((dwIp >> 24) & 0xFF),
                        (UINT8)((dwIp >> 16) & 0xFF),
                        (UINT8)((dwIp >> 8)  & 0xFF),
                        (UINT8)(dwIp         & 0xFF));
    }

    // FormatIpPort
    // Remark: port is in host byte order 
    PCCHARTYPE FormatIpPort(UINT8 a, UINT8 b, UINT8 c, UINT8 d, UINT16 port)
    {
        Format("%u.%u.%u.%u:%u", a, b, c, d, port);
        return cstr();
    }

    // FormatIpPortH
    // format ip and port where both dwIp and port are in host byte order 
    PCCHARTYPE FormatIpPortH(DWORD dwIp, UINT16 port)
    {
        return FormatIpPort((UINT8)((dwIp >> 24) & 0xFF),
                            (UINT8)((dwIp >> 16) & 0xFF),
                            (UINT8)((dwIp >> 8)  & 0xFF),
                            (UINT8)(dwIp         & 0xFF),
                            port);
    }
    
    // FormatIpPortN
    // format ip and port where both dwIp and port are in network byte order 
    PCCHARTYPE FormatIpPortN(DWORD dwIp, UINT16 port)
    {
        port = ((port >> 8) & 0xFF) | ((port & 0xFF) << 8);
        return FormatIpPort((UINT8)(dwIp         & 0xFF),
                            (UINT8)((dwIp >> 8)  & 0xFF),
                            (UINT8)((dwIp >> 16) & 0xFF),
                            (UINT8)((dwIp >> 24) & 0xFF),
                            port);
    }

    // FormatEnetAddr
    // format ethernet address provided as an array of 6 bytes
    PCCHARTYPE FormatEnetAddr(BYTE* pEnetAddr)
    {
        return Format("%02X-%02X-%02x-%02x-%02x-%02x", 
                      pEnetAddr[0], pEnetAddr[1], pEnetAddr[2],
                      pEnetAddr[3], pEnetAddr[4], pEnetAddr[5]).cstr();
    }

    PCCHARTYPE FormatGuid(const GUID* pguid)
    {
        return Format("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                      pguid->Data1, pguid->Data2, pguid->Data3,
                      pguid->Data4[0], pguid->Data4[1], pguid->Data4[2], pguid->Data4[3],
                      pguid->Data4[4], pguid->Data4[5], pguid->Data4[6], pguid->Data4[7]).cstr();
    }

    // FormatConsoleId
    // takes in the awkward 64-bit version and turns it into the "dashboard" 
    // representation.
    PCCHARTYPE FormatConsoleId(UINT64 qwConsoleId)
    {
        // only 40 bits are used, the remaining high 24 bits should be stripped, namely 
        // the PUID_BASE_XENON_CONSOLE bit. This logic was inspired by consoleid.cs tool.
        UINT64 qwChksum = qwConsoleId & 0xF;
        UINT64 qwCid = (qwConsoleId & 0xFFFFFFFFFF) >> 4;
        return Format("XE.%011I64d%d", qwCid, qwChksum).cstr();
    }

    // FormatConsoleId
    // takes in the awkward 5-byte array version and turns it into the "dashboard" 
    // representation.
    PCCHARTYPE FormatConsoleId(const BYTE *pbConsoleId)
    {
        UINT64 qwConsoleId = 0;
        // CONSOLE_ID_SIZE is 5
        for(DWORD i = 0; i < 5; i++)
        {
            qwConsoleId <<= 8;
            qwConsoleId |= pbConsoleId[i];
        }
        return FormatConsoleId(qwConsoleId);
    }
};

// --------------------------------------------------------------------------------------
// TToString
// Utility template to create string converters for structs and classes.
//
// Use it like in the following example:
//
// struct S
// {
//     S(int a, int b, int c) :
//         _a(a), _b(b), _c(c)
//     {
//     }
// 
//     void WriteToString(CStr* pstr) const
//     {
//         pstr->Format("a: %u, b: %u, c: %u", _a, _b, _c);
//     }
// 
//     typedef TToString<S, 40> ToString;
// 
//     int _a;
//     int _b;
//     int _c;
// };
// 
// void __cdecl main()
// {
//     S s(1, 2, 3);
//     printf("%s\n", (LPCSTR) S::ToString(s));
// }
//
// This will print:
// a: 1, b: 2, c: 3
//
// Remarks:
// The signature of WriteToString is important. It must have the const modifier.
//
// --------------------------------------------------------------------------------------
template <class t, int c>
class TToString
{
public:

    __forceinline TToString(const t& reft)
    {
        _pt = &reft;
    }

    __forceinline operator LPCSTR ()
    {
        _str.Reset();
        _pt->WriteToString(&_str);
        return _str.cstr();
    }

protected:

    const t*     _pt;
    TLocalStr<c> _str;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_system.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_system.cpp
//
// Objects and functions for system stuff
// --------------------------------------------------------------------------------------

#include "precomp.h"

// --------------------------------------------------------------------------------------
// CSystem::GetModuleFileName
// Writes the full module file name (with the path) into pModuleFileName.
// Returns false if it fails or if the result was truncated.
// --------------------------------------------------------------------------------------
bool CSystem::GetModuleName(HMODULE hModule, CStr* pModuleFileName)
{
    CHAR szFileName[MAX_PATH*2];

    bool ok = false;

    if(::GetModuleFileNameA(hModule, szFileName, ARRAY_SIZE(szFileName)))
    {
        szFileName[ARRAY_SIZE(szFileName)-1] = 0;
        pModuleFileName->Reset();
        pModuleFileName->CopyFrom(szFileName);
        ok = !pModuleFileName->HasFailedOrTruncated();
    }

    return ok;
}

// --------------------------------------------------------------------------------------
// CSystem::ParseFileName
// Parse a part of a filename and write it to pPart. The part type is specified 
// in parseType which must be one of the following:
//
// PARSE_NAME_WITHOUT_EXTENSION: writes just the filename without extension.  
// e.g.  notepad
// PARSE_NAME_WITH_EXTENSION: writes the filename with extension. e.g.  
// notepad.exe
// PARSE_DRIVE: writes the drive. e.g. D:
// PARSE_PATH: writes the path. e.g. \programs\accessories
// PARSE_DRIVE_AND_PATH: writes the drive and the path. e.g.  
// D:\programs\accessories
// 
// Returns false in case of error or if the result was truncated
// --------------------------------------------------------------------------------------
bool CSystem::ParseFileName(
    LPCSTR      pFileName,
    ParseType   parseType,
    CStr*       pPart
    )
{
    CHAR szDrive[_MAX_DRIVE];
    CHAR szDir[_MAX_DIR];
    CHAR szFileName[_MAX_FNAME];
    CHAR szExt[_MAX_EXT];

    _splitpath(pFileName, szDrive, szDir, szFileName, szExt);

    pPart->Reset();
    
    switch(parseType)
    {
    case PARSE_NAME_WITHOUT_EXTENSION:
        
        if(szFileName[0] == 0)
        {
            return false;
        }
        
        pPart->CopyFrom(szFileName);
        break;

    case PARSE_NAME_WITH_EXTENSION:
        
        if(szFileName[0] == 0)
        {
            return false;
        }

        pPart->CopyFrom(szFileName);
        pPart->CopyFrom(szExt);
        break;

    case PARSE_DRIVE:
        pPart->CopyFrom(szDrive);
        break;

    case PARSE_PATH:
        pPart->CopyFrom(szDir);
        break;

    case PARSE_DRIVE_AND_PATH:
        pPart->CopyFrom(szDrive);
        pPart->CopyFrom(szDir);
        break;

    default:
        DBGASSERT(!"Invalid parse-type");
        return false;
    }

    return !pPart->HasFailedOrTruncated();
}

bool CSystem::EnumerateFiles(
    LPCSTR                   pPattern,
    ENUMERATE_FILES_CALLBACK callback,
    void*                    userData
    )
{
    bool ok = false;
    CHAR absolutePath[MAX_PATH+1];
    char* pSlash = NULL;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    DWORD err = NO_ERROR;

    // Get absolute path from pattern

    if(!_fullpath(absolutePath, pPattern, ARRAY_SIZE(absolutePath)))
    {
        goto Exit;
    }

    // Find the last slash and truncate absolute path

    pSlash = strrchr(absolutePath, '\\' );
    if(pSlash)
    {
        pSlash[1] = 0;
    }

    // Search

    WIN32_FIND_DATAA find;
    hFind = FindFirstFileA(pPattern, &find);
    
    if(INVALID_HANDLE_VALUE == hFind)
    {
        goto Exit;
    }

    for(;;)
    {
        if(!callback(userData, absolutePath, find.cFileName))
        {
            break;
        }
        
        if(!FindNextFileA(hFind, &find))
        {
            if(GetLastError() != ERROR_NO_MORE_FILES)
            {
                goto Exit;
            }
            else
            {
                break;
            }
        }
    }

    ok = true;

Exit:
    
    if(INVALID_HANDLE_VALUE != hFind)
    {
        FindClose(hFind);
        hFind = INVALID_HANDLE_VALUE;
    }

    return ok;
}

// --------------------------------------------------------------------------------------
// CSystem::ReadRegistryString
// Read a REG_SZ registry value. Example:
//
// TLocalStr<100> npdbServer;
// CSystem::ReadRegistryString(
//      HKEY_LOCAL_MACHINE,
//      "\Software\Microsoft\XboxLive\CommonConfig",
//      "Server",
//      &npdbServer);
//
//  - hKey: Registry key handle opened by RegOpenKey or one of the HKEY_* pre-opened 
//  handles (e.g. HKEY_LOCAL_MACHINE)
//  - key: key path under hKey
//  - value: value name under key (must be REG_SZ type)
//  - data: OUT: receives the data value
//
//  Returns:
//   true if succeeds
//   false if it fails. GetLastError() should contain the error.
// --------------------------------------------------------------------------------------
bool CSystem::ReadRegistryString(
    HKEY        hKey,
    LPCSTR      key,
    LPCSTR      value,
    OUT CStr*   pData
    )
{
    LONG error;
    DWORD size = 0;
    DWORD dwType = 0;

    // First make a call to figure out the size of the string

    error = ::RegGetValueA(
            hKey,
            key,
            value,
            RRF_RT_ANY,
            &dwType,        // pdwType
            NULL,           // pvData
            &size);

    if(error != ERROR_SUCCESS)
    {
        ::SetLastError(error);
        return false;
    }

    if(dwType != REG_SZ &&
       dwType != REG_EXPAND_SZ)
    {
        // We only support string types
        ::SetLastError(REGDB_E_INVALIDVALUE);
        return false;
    }

    // Make sure string object has enough space for the value

    if(!pData->HasRoom(size))
    {
        ::SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Get pointer to the end of the string object and use it to read the value from the 
    // registry

    LPSTR pPtr = pData->StartWrite((UINT32*)&size);
    
    error = ::RegGetValueA(
        hKey,
        key,
        value,
        RRF_RT_ANY,
        &dwType,            // pdwType
        pPtr,
        &size);

    if(error != ERROR_SUCCESS)
    {
        ::SetLastError(error);
        return FALSE;
    }

    // Adjust string's size

    pData->EndWrite(size != 0 ? size - 1 : 0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_timer.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_timer.h
// Don't include this file directly. Instead include cutil.h
//
// Server timer classes and functions
// --------------------------------------------------------------------------------------

#pragma once

// timer callback
typedef VOID (WINAPI *PSERVER_TIMER_APPOINTMENT_CALLBACK)(VOID*);

// --------------------------------------------------------------------------------------
// SERVER_TIMER_APPOINTMENT
// stores a timer appointment created with CServerTimer::CreateAppointment. I recommend 
// initializing it with all zeros before using it but CreateAppointment doesn't require 
// it. If you call CancelAppointment without initializing it first, you could get 
// unexpected results
// --------------------------------------------------------------------------------------
struct SERVER_TIMER_APPOINTMENT
{
    PSERVER_TIMER_APPOINTMENT_CALLBACK pCallback; // when the timer is due call this
    void*               pParam;        // parameter for the callback
    DWORD               dwWhen;        // next occurrance
    DWORD               dwHeapIndex;   // position in the heap
    LONG                fInHeap;       // appointment is currently in the heap
    volatile LONG       fExecuting;    // appointment is being executed as we speak
};

// --------------------------------------------------------------------------------------
// CServerTimerApptHeapImpl
// (internal) timer heap support class
// --------------------------------------------------------------------------------------
class CServerTimerApptHeapImpl
{
public:
    static void OnHeapNewPosition(SERVER_TIMER_APPOINTMENT* pv, DWORD nNewPos)
    {
        DBGASSERT(pv->fInHeap);
        pv->dwHeapIndex = nNewPos;
    }
    
    static int HeapCompare(SERVER_TIMER_APPOINTMENT* pv1, SERVER_TIMER_APPOINTMENT* pv2)
    {
        return WrapDWORDCompare(pv1->dwWhen, pv2->dwWhen, NULL);
    }
};

// --------------------------------------------------------------------------------------
// CServerTimer
// Objects of this class represent a single timer thread. Appointments can be created for 
// this object which are basically scheduled tasks. These appointments will be executed in 
// the same thread.
// --------------------------------------------------------------------------------------
class CServerTimer
{
public:

    CServerTimer();
    
    ~CServerTimer();
    
    // Init
    // Initialize the timer and creates the timer thread
    //   fHighPriority - if true, the timer thread will run at THREAD_PRIORITY_ABOVE_NORMAL.  
    //   Otherwise it will run at normal priority
    //   pAlloc - pass in an allocator if you want dynamic growth, which you more than 
    //   likely do. The default limit is 200 items. Suggested allocator is 
    //   "CMemAlloc::Default()"
    bool Init(bool fHighPriority, IMemAlloc *pAlloc = NULL);
    
    // Term
    // Shutdown the timer. Drop pending appointments. Release resources.
    void Term();
    
    // CreateAppointment
    // Create an appointment. The CServerTimerAppt object referenced by pAppt must not be 
    // scheduled for a pending appointment. Call CancelAppointment first if you want to 
    // reschedule.
    //   pCallback is a reference to whoever should get called when the appointment is due
    //   pParam is an optional parameter to the callback
    //   dwInterval is the number of milliseconds before the appointment is due
    //   pAppt is a CServerTimerAppt object that represents this appointment
    bool CreateAppointment(
        PSERVER_TIMER_APPOINTMENT_CALLBACK pCallback,
        VOID* pParam,
        DWORD dwInterval,
        SERVER_TIMER_APPOINTMENT* pAppt
    );
    
    // CancelAppointment
    // Cancel a previously scheduled appointment. It's safe to call on a appointment that's 
    // not scheduled though.
    //   pAppt is the pointer to the CServerTimerAppt object that represents the appointment 
    //   to be cancelled
    void CancelAppointment(
        SERVER_TIMER_APPOINTMENT* pAppt
    );
    
#if _TEST
    DWORD _dwTimeAdjust;
    
    DWORD GetNow()
    {
        return GetTickCount() + _dwTimeAdjust;
    }
#else
    
    // GetNow
    // Get current time in milliseconds
    static DWORD GetNow()
    {
        return GetTickCount();
    }

#endif

protected:

    static DWORD StaticThreadProc(void* pRawThis);
    
    void ThreadProc();

    static void ApptReset(SERVER_TIMER_APPOINTMENT* pAppt);
    
    HANDLE        _hThread;     // handle to timer thread
    DWORD         _dwThreadId;  // thread-id of the timer thread
    CFastLock     _lock;        // lock to synchronize access to heap
    HANDLE        _hWait;       // event to control thread
    volatile LONG _fShutdown;   // to signal the shutdown

    // the timer's priority queue
    THeap<
        SERVER_TIMER_APPOINTMENT*,      // item type
        200,                            // capacity
        CServerTimerApptHeapImpl,       // template function for comparing appointments
        CServerTimerApptHeapImpl>       // template function for notifying when an item was moved
            _heap;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_timer.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_timer.cpp
//
// Server timer classes and functions
// --------------------------------------------------------------------------------------

#include "precomp.h"

// --------------------------------------------------------------------------------------
// CServerTimer
// constructor
// --------------------------------------------------------------------------------------
CServerTimer::CServerTimer()
{
    _hThread    = NULL;
    _dwThreadId = 0;
    _hWait      = NULL;
    _fShutdown  = FALSE;
    
#if _TEST
    _dwTimeAdjust = 0;
#endif
}

// --------------------------------------------------------------------------------------
// ~CServerTimer
// destructor
// --------------------------------------------------------------------------------------
CServerTimer::~CServerTimer()
{
    DBGASSERT(NULL == _hThread);
    DBGASSERT(NULL == _hWait);
}

// --------------------------------------------------------------------------------------
// Init
// Initialize the timer and creates the timer thread
//   fHighPriority - if true, the timer thread will run at THREAD_PRIORITY_ABOVE_NORMAL.  
//   Otherwise it will run at normal priority
// --------------------------------------------------------------------------------------
bool CServerTimer::Init(bool fHighPriority, IMemAlloc* pAlloc)
{
    bool fRet = false;
    
    DBGASSERT(NULL == _hWait);
    
    _hWait = CreateEventA(NULL, true, false, NULL);
    if(NULL == _hWait)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "CreateEventA failed. Error=%u", GetLastError());
        goto lDone;
    }
    
    DBGASSERT(NULL == _hThread);
    _hThread = CreateThread(NULL, 0, StaticThreadProc, this, 0, &_dwThreadId);
    if(NULL == _hThread)
    {
        CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
            "CreateThread failed. Error=%u", GetLastError());
        goto lDone;
    }
    
    if(fHighPriority)
    {
        if(!::SetThreadPriority(_hThread, THREAD_PRIORITY_ABOVE_NORMAL))
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                                     "SetThreadPriority failed. Error=%d", GetLastError());
            goto lDone;
        }
    }

    if (pAlloc)
    {
        _heap.SetAllocator(pAlloc);
    }
    
    fRet = true;
    
lDone:

    if(!fRet)
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
        
    return fRet;
}

// --------------------------------------------------------------------------------------
// Term
// Shutdown the timer. Drop pending appointments. Release resources.
// --------------------------------------------------------------------------------------
void CServerTimer::Term()
{
    if(_fShutdown)
    {
        // term has already been called
        return;
    }
    
    _lock.Lock();

    //
    // signal the shutdown. New appointments will not be allowed
    //
    
    _fShutdown =  TRUE;

    //
    // drop pending appointments
    //

    while(_heap.GetCount() > 0)
    {
        _heap.Remove(0);
    }

    _lock.Unlock();

    //
    // shutdown the thread
    //

    if(_hThread != NULL)
    {
        do
        {
            SetEvent(_hWait);
        } while(WaitForSingleObject(_hThread, 100) == WAIT_TIMEOUT);
    }
    
    DBGASSERT(_heap.GetCount() == 0);
    
    if(_hWait != NULL)
    {
        CloseHandle(_hWait);
        _hWait = NULL;
    }
    
    if(_hThread != NULL)
    {
        CloseHandle(_hThread);
        _hThread = NULL;
    }
    
    _heap.Term();
}

// --------------------------------------------------------------------------------------
// CreateAppointment
// Create an appointment. The CServerTimerAppt object referenced by pAppt must not be 
// scheduled for a pending appointment. Call CancelAppointment first if you want to 
// reschedule.
//   pCallback is a reference to whoever should get called when the appointment is due
//   pParam is an optional parameter to the callback
//   dwInterval is the number of milliseconds before the appointment is due
//   pAppt is a CServerTimerAppt object that represents this appointment
// --------------------------------------------------------------------------------------
bool CServerTimer::CreateAppointment(
    PSERVER_TIMER_APPOINTMENT_CALLBACK     pCallback,
    VOID*                                  pParam,
    DWORD                                  dwInterval,
    SERVER_TIMER_APPOINTMENT*              pAppt
)
{
    bool ok = false;

    _lock.Lock();
    
    if(_fShutdown)
    {
        // server time is shutting down
        _lock.Unlock();
        goto Exit;
    }
    
    //
    // initialize appointment object
    //
    
    ApptReset(pAppt);
    pAppt->pCallback   = pCallback;
    pAppt->pParam      = pParam;
    pAppt->dwWhen      = GetNow() + dwInterval;
    pAppt->fInHeap     = TRUE;
    
    //
    // and insert appointment on the heap
    //
    
    ok = _heap.Insert(pAppt);

    if(!ok)
    {
        _lock.Unlock();
        goto Exit;
    }

    // 
    // if appointment ended up as the first in line, wake up the timer thread
    //
        
    if(pAppt->dwHeapIndex == 0)
    {
        SetEvent(_hWait);
    }
        
    _lock.Unlock();
    
    ok = true;
    
Exit:
    
    if(!ok && !_fShutdown)
    {
        DBGASSERT(!"Failed to insert new appointment");
        ApptReset(pAppt);
        CGlobalError::AddMessage(GLOBAL_ERROR_HEADER);
    }
        
    return ok;
}

// --------------------------------------------------------------------------------------
// CancelAppointment
// Cancel a previously scheduled appointment. It's safe to call on a appointment that's 
// not scheduled though.
//   pAppt is the pointer to the CServerTimerAppt object that represents the appointment 
//   to be cancelled
// --------------------------------------------------------------------------------------
void CServerTimer::CancelAppointment(
    SERVER_TIMER_APPOINTMENT* pAppt
)
{
    //
    // unschedule appointment
    //

    _lock.Lock();

    if(pAppt->fInHeap)
    {
        if(!_fShutdown)
        {
            SERVER_TIMER_APPOINTMENT* pRemovedAppt = _heap.Remove(pAppt->dwHeapIndex); 
            if(pRemovedAppt != pAppt)
            {   
                DBGASSERT(!"The timer's heap is corrupted");
            }
        }
        
        ApptReset(pAppt);
    }
    
    _lock.Unlock();

    //
    // at this point the appointment is not scheduled anymore - but it could be executing, 
    // though. Let's wait until that's done - unless the calling thread is the timer 
    // thread in which case, we'd deadlock waiting for the appointment to finish.
    //
    // kgoodier: this creates a very complicated race condition in the SG's ARP code. I 
    // can't see a good reason we need to wait for completion of the appointment if it's 
    // already running, and not waiting solves the deadlock / wrong timeout cases in the 
    // SG.
    
#if 0
    if(pAppt->fExecuting && 
       ::GetCurrentThreadId() != _dwThreadId )
    {
        while(pAppt->fExecuting)
        {
            ::Sleep(1);
        }
    }
#endif

}

DWORD CServerTimer::StaticThreadProc(void* pRawThis)
{
    ((CServerTimer*)pRawThis)->ThreadProc();
    
    return 0;
}

void CServerTimer::ThreadProc()
{
    SERVER_TIMER_APPOINTMENT* pAppt = NULL;
    VOID* pParam                = NULL;
    DWORD dwSleep               = 0;
    DWORD dwNow                 = 0;
    DWORD dwWhen                = 0;
    PSERVER_TIMER_APPOINTMENT_CALLBACK pCallback = NULL;
    
    while(!_fShutdown)
    {
        dwNow       = GetNow();
        
        //
        // get next appointment in the heap
        //
        
        _lock.Lock();
        
        if(_heap.GetCount() == 0)
        {
            //
            // heap is empty. Prepare to put the thread to sleep for a undetermined 
            // ammount of time (until some external event wakes it up)
            //
            
            dwSleep = INFINITE;

            // 
            // Remark: to avoid race conditions, the event must be reset inside the 
            // critical-section. Please resist the temptation to move it closer to the 
            // WaitForSingleObject.
            //
            
            ResetEvent(_hWait);
        }
        else
        {
            //
            // evaluate how long the thread should wait until the next appointment is due
            //
            
            dwWhen = _heap.Peek(0)->dwWhen;
            int cmp = WrapDWORDCompare(dwNow, dwWhen,&dwSleep);
            
            if(cmp >= 0)
            {
                // no wait. Appointment is due now
                dwSleep   = 0;
                pAppt     = _heap.Remove(0);
                pCallback = pAppt->pCallback;
                pParam    = pAppt->pParam;
                
                ApptReset(pAppt);
                ::InterlockedExchange(&pAppt->fExecuting, TRUE);
            }
            else
            {
                //
                // there is some waiting to be done. 
                // Remark: to avoid race conditions, the event must be reset inside the 
                // critical-section. Please resist the temptation to move it closer to the 
                // WaitForSingleObject.
                //

                ResetEvent(_hWait);
            }
        }
        
        _lock.Unlock();

        if(dwSleep != 0)
        {
            //
            // do the waiting and then start over. If something happens like a new 
            // appoinment is scheduled at the top of the heap or a shutdown, the _hWait 
            // event will be set
            // 
            
            DBGASSERT(pAppt == NULL);
            
            WaitForSingleObject(_hWait, dwSleep);
            
            if(_fShutdown)
            {
                break;
            }
        }
        else
        {
            //
            // execute the appointment
            //

            pCallback(pParam);
            
            DBGASSERT(pAppt != NULL);
            ::InterlockedExchange(&pAppt->fExecuting, FALSE);

            pAppt       = NULL;
            pCallback   = NULL;
            pParam      = NULL;
        }
    }
}

void CServerTimer::ApptReset(SERVER_TIMER_APPOINTMENT* pAppt)
{
    pAppt->pCallback      = NULL;
    pAppt->pParam         = NULL;
    pAppt->dwWhen         = 0;
    pAppt->dwHeapIndex    = 0;
    pAppt->fInHeap        = FALSE;
    pAppt->fExecuting     = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_trace.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_trace.cpp
// 
// Trace classes and functions
// --------------------------------------------------------------------------------------

#include "precomp.h"

// Utility function to write to ITraceCallback::Write in printf style
void TraceCallbackFormattedWrite(
        ITraceCallback* pOut, 
        const char* pszFmt, 
        ... )
{
    CLargeStr str;
    va_list args;
    
    va_start(args, pszFmt);
    str.FormatV(pszFmt,args);
    va_end(args);

    pOut->Write(str.cstr());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_tpool.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_tpool.h
// Don't include this file directly. Instead include cutil.h
// 
// Thread pool
// Use class CThreadPool to instantiate a threadpool. Define a function to process 
// workitems using function type PFNWORKITEM.
// --------------------------------------------------------------------------------------

#pragma once

// --------------------------------------------------------------------------------------
// Forward declarations
// --------------------------------------------------------------------------------------
class CThread;
class CWorkThread;
class CThreadPool;
class CIoWorkThread;
class CIoThreadPool;

// --------------------------------------------------------------------------------------
// PFNWORKITEM
// Pointer to function to process work-items.
// --------------------------------------------------------------------------------------
typedef void (CALLBACK *PFNWORKITEM) (void* param);

// --------------------------------------------------------------------------------------
// CThread
// Encapsulates a Win32 thread.  ThreadProc must be overriden for the thread to do 
// something useful
// --------------------------------------------------------------------------------------
class CThread
{
protected:

    // constructor
    CThread();

    // destructor
    virtual ~CThread();

    // Create and start the thread
    BOOL CreateThread();

    // Terminate the thread. This function waits for the thread to finish before closing 
    // the thread handle and returning therefore it's the responsability of the 
    // super-class to signal the shutdown and ensure that the thread proc terminates 
    // gracefully. Otherwise this method might wait forever for the thread to finish.
    void TermThread();
    
    // The most important method of all - and it's not implemented. It's up to you to 
    // write an implementation worth of this noble class.
    virtual DWORD ThreadProc() = 0;

    // Static method to be passed in to CreateThread. It should receive the pointer to the 
    // CThread instance as param. It immediatelly uses it to call the object method 
    // ThreadProc.
    static DWORD WINAPI StaticThreadProc(LPVOID param);

    HANDLE _hThread; // handle of the Win32 thread
};

// --------------------------------------------------------------------------------------
// CWorkThread
// Thread that processes work-items. Don't use this directly. Use CThreadPool instead
// --------------------------------------------------------------------------------------
class CWorkThread : public CThread
{
    // We'd like to let the caller pick whichever allocator he/she wishes to instantiate 
    // this class with
    USE_IMEMALLOC(CWorkThread);

public:

    CListEntry _leThreadList;       // List-entry in CThreadPool::_threadList
    CListEntry _leIdleThreadList;   // List-entry in CThreadPool::_idleThreadList

    // constructor
    CWorkThread();
    
    // destructor
    ~CWorkThread();

    // Initialize object
    //  - pThreadPool: pointer to CThreadPool that owns this object
    //  - Returns TRUE if succeeded, FALSE otherwise
    BOOL Init(CThreadPool* pThreadPool);

    // Terminate the thread, gracefully
    void Term();
    
    // Set thread priority
    // - priority: usually THREAD_PRIORITY_NORMAL, THREAD_PRIORITY_BELOW_NORMAL or 
    // THREAD_PRIORITY_ABOVE_NORMAL. Check out MSDN for more details.
    // - Returns TRUE if succeeded, FALSE otherwise
    BOOL SetPriority(int priority);
    
    // Called by _pThreadPool to wakeup thread to process work-items
    // - pWorkItemList: list of work-items to process
    void WakeUp(CList* pWorkItemList);

    // Returns the total number of times that the thread went to sleep because it ran out 
    // of work to do. 
    inline UINT32 GetWaitCount() const
    {
        return _waitCount;
    }

protected:

    // The all important thread procedure. Retrieves a bunch of workitems, process them 
    // and repeat until it's time to shutdown.
    // - Returns 0
    virtual DWORD ThreadProc();

    // Called by ThreadProc to retrieve work-items from _pThreadPool to process.
    BOOL GetWorkItems();
    
    CThreadPool* _pThreadPool;          // Pointer to CThreadPool that owns this object
    HANDLE _hWait;                      // Event to control when the thread sleeps and awakes
    CList _workItemList;                // Local list of work-items to process
    volatile UINT32 _waitCount;         // Total number of times the thread went to sleep because it ran out of work to do
};

// --------------------------------------------------------------------------------------
// CThreadPool
// Finally, the thread-pool itself. Manages the list of work-items and the working 
// threads.
// --------------------------------------------------------------------------------------
class CThreadPool
{
public:

    enum WorkItemPriority
    {
        PriorityNormal = 0,  // Wake an idle thread based on affinity heuristic
        PriorityLow    = 1,  // Never wake an idle thread for this workitem
        PriorityHigh   = 2   // Immediately wake up an idle thread to process workitem
    };

    // constructor
    CThreadPool();
    
    // destructor
    virtual ~CThreadPool();

    // Initialize thread pool
    // - cThreads: number of threads in the thread pool. If zero, the number of threads 
    // will default to the number of logical processors.
    // - fBatch: if TRUE, when a thread calls GetWorkItems(), it will retrieve all 
    // work-items currently available. If FALSE, the thread will retrieve only one 
    // work-item per call.
    // - pAlloc: the allocator to be used for memory allocation. If NULL, 
    // CMemAlloc::Default() will be used.
    // - cWorkItemsAffinityLimit: work item count threshold before waking up a new idle 
    // thread
    // - Returns true if succeeded, false otherwise
    bool Init(
        DWORD cThreads, 
        BOOL fBatch,
        DWORD cWorkItemsAffinityLimit = 100,
        IMemAlloc* pAlloc = NULL);

    // Stop accepting new workitems and block until all work-items currently scheduled 
    // have been processed
    void Drain();

    // Drain workitems and terminate thread pool.
    void Term();
    
    // CThreadPool::SetPriority
    // Set priority of threads in the pool
    // - priority: usually THREAD_PRIORITY_NORMAL, THREAD_PRIORITY_BELOW_NORMAL or 
    // THREAD_PRIORITY_ABOVE_NORMAL. Check out MSDN for more details.
    // - Returns TRUE if succeeded, FALSE otherwise
    BOOL SetPriority(int priority);

    // Add a work-item to be processed in the thread-pool
    // - pfn: function to be executed
    // - param: parameter to be passed to pfn
    // - priority: process immediately, a little later, or never
    // - Returns true if succeeded, false otherwise
    bool AddWorkItem(PFNWORKITEM pfn, void* param, WorkItemPriority priority = PriorityNormal);

    // Entry point for an external thread to process some of the work items. Outside 
    // threads should call this if they want to help out, but bear in mind this may take a 
    // while to return from.
    void ExternalThreadProcessWorkItems();

    // Get the number of pending work-items
    UINT32 GetCount()
    {
        return _workItemCount;
    }

    // Returns the total number of times individual threads went to sleep because they ran 
    // out of work to do.
    // - Returns: Total number of waits
    UINT32 GetWaitCount();

    // Accessors for perf-counter / stats related variables
    UINT32 GetActiveThreadCount()   { return _activeThreadCount; }
    UINT64 GetWorkItemsCallsMiss()  { return _workItemsCallsMiss; }
    UINT64 GetWorkItemsCallsHit()   { return _workItemsCallsHit; }
    UINT64 GetWorkItemsRetrieved()  { return _workItemsRetrieved; }
    
    // Accessor for number of io threads in this pool
    DWORD GetNumThreads() { return _cThreads; }


protected:

    // CWorkThread must have access to our protected area
    friend CWorkThread;

    // Structure to represent a work-item to be executed
    struct WORKITEM
    {
        CListEntry  leWorkItems;    // list-entry into lists that store work-items
        PFNWORKITEM pfnWorkItem;    // pointer to function to be executed
        void* param;                // parameter to pass to pfnWorkItem
    };

    // Distributes work-items to idle-threads.
    void DistributeWorkItems(WorkItemPriority priority = PriorityNormal);
    
    // Process a list of work items previously retrieved from the global list. This should 
    // be a separate list so we don't have to worry about locks!
    // - pWorkItemList: pointer to list of work items to process.
    // Returns the number of items processed.
    DWORD ProcessWorkItems(CList* pWorkItemList);
    
    // Retrieve one or more work-items. If there are no work-items available, this 
    // function will not block. In which case, no work-items will be copied to the 
    // pWorkItemList.
    // - pWorkItemList: pointer to list to copy work-items to. The list must be empty.
    void GetWorkItems(CList* pWorkItemList);

    // Remove and return a idle-thread from the list.
    // - Returns the pointer to CWorkThread if available. Returns NULL if the list of 
    // idle-threds is empty.
    CWorkThread* GetIdleThread();
    
    // Add a thread to the list of idle-threads. CThreadPool will use this list to 
    // distribute work-items as they become available. The thread must go to sleep after 
    // it adds itself to the idle-list.
    // - pThread: pointer to thread that should be put in the idle-list
    void AddIdleThread(CWorkThread* pThread);
    
    // Returns a WORKITEM structure back to the look-aside list. This function must be 
    // used to release WORKITEM structures.
    // - pWorkItem: pointer to WORKITEM to be released.
    void ReleaseWorkItem(WORKITEM* pWorkItem);

    CList           _workItemQueue;     // List of work-items to process
    UINT32          _workItemCount;     // Number of work-items in _workItemQueue
    CFastLock       _lockWorkItemQueue; // To synchronize access to _workItemQueue and _workItemCount
    CLookAsideList  _workItemLookAside; // look-aside list of WORKITEM structs
    CList           _threadList;        // list of threads
    CList           _idleThreadList;    // list of threads that are idle
    CFastLock       _lockIdleThreadList;// To synchronize access to _idleThreadList
    IMemAlloc*      _pAlloc;            // allocator
    LONG            _fDrain;            // if TRUE, the pool is draining
    BOOL            _fBatch;            // if TRUE, work-items are processed in bundles

    UINT32          _cThreads;           // Number of threads in the pool
    volatile UINT32 _activeThreadCount;  // Number of active threads (versus idle threads)
    UINT64          _workItemsCallsMiss; // GetWorkItems() calls, no items
    UINT64          _workItemsCallsHit;  // GetWorkItems() calls, items returned
    UINT64          _workItemsRetrieved; // GetWorkItems() hits, # of items retrieved
   
    // Setting, how many work items to queue before launching another idle thread
    UINT32          _workItemsAffinityLimit;  
    
};

// --------------------------------------------------------------------------------------
// PFNIOCOMPLETED
// Pointer to function to process completed IO items
//   - error: the win32 error of the operation
//   - numberOfBytes: number of bytes transmitted/received/affected. Depends on 
//   operation.
//   - pOverlapped: pointer to OVERLAPPED structure that was passed in the original IO 
//   call
// --------------------------------------------------------------------------------------
typedef void (CALLBACK *PFNIOCOMPLETED) (
    DWORD error,
    DWORD numberOfBytes, 
    OVERLAPPED* pOverlapped);

// --------------------------------------------------------------------------------------
// CIoWorkThread
// Thread that processes IO completion notifications. Don't use this directly. Use 
// CIoThreadPool instead.
// --------------------------------------------------------------------------------------
class CIoWorkThread : public CThread, public CDoubleLink
{
    // We'd like to let the caller pick whichever allocator he/she wishes to instantiate 
    // this class with
    USE_IMEMALLOC(CIoWorkThread);

public:

    // constructor
    CIoWorkThread();

    // Initialize the thread
    // - hIoCp: handle to IO completion port
    // - pShutdownMessage: pointer to special OVERLAPPED structure that will posted on 
    // the completion queue to indicate that the threads should terminate.
    bool Init(HANDLE hIoCp, OVERLAPPED* pShutdownMessage);

    // Block until thread terminates and release resources
    void Term();

    // Set thread priority
    BOOL SetPriority(int priority);

    BOOL SetPriorityBoost(BOOL disablePriorityBoost);

protected:

    // The all important thread procedure. Retrieves a bunch of workitems, process them 
    // and repeat until it's time to shutdown.
    virtual DWORD ThreadProc();

    HANDLE          _hIoCp;             // Handle to IO completion port
    OVERLAPPED*     _pShutdownMessage;  // pointer to special OVERLAPPED structure that indicates a shutdown
};

// --------------------------------------------------------------------------------------
// CIoThreadPool
// This is the IO thread pool itself. Instantiate this class, call Init() to initialize, 
// Bind() to bind sockets, files, etc. to the thread pool and Post() to post user items 
// in the IO completion port.  
// --------------------------------------------------------------------------------------
class CIoThreadPool
{
public:

    // constructor
    CIoThreadPool();
    
    // destructor
    virtual ~CIoThreadPool();

    // Initialize IO thread pool
    // - cThreads: number of threads in the pool. If 0, the number of logical processors 
    // in the machine will be used instead.
    // - pAlloc: custom memory allocator. If NULL, CMemAlloc::Default() will be used.
    bool Init(
        DWORD cThreads = 0, 
        IMemAlloc* pAlloc = NULL);
    
    // Terminate the thread-pool. It first signals all threads to shutdown and waits 
    // until all of them are terminated. 
    void Term();

    // Set priority of threads in the pool
    // - priority: usually THREAD_PRIORITY_NORMAL, THREAD_PRIORITY_BELOW_NORMAL or 
    // THREAD_PRIORITY_ABOVE_NORMAL. Check out MSDN for more details.
    // Returns:
    //  TRUE if succeeded, FALSE if otherwise.
    BOOL SetPriority(int priority);

    BOOL SetPriorityBoost(BOOL disablePriorityBoost);

    // Bind a file, socket, etc. handle to the IO completion port.
    // - hFile: the file, socket, etc. handle to be bound
    // - pCallback: Pointer to PFNIOCOMPLETED callback function that will be called for 
    // each IO operation completed on hFile. 
    bool Bind(
        HANDLE hFile, 
        PFNIOCOMPLETED pCallback);

    // Post a user item in the IO completion port.
    // - numberOfBytes: this is usually the number of bytes affected in a IO operation - 
    // but since this is a user item, it can be anything. Just make sure your callback 
    // function can handle it.
    // - pCallback: callback function to be called when the item is taken from the queue.
    // - pOverlapped: also usually a pointer to a OVERLAPPED structure - but it can be 
    // anything here
    bool Post(
        DWORD numberOfBytes,
        PFNIOCOMPLETED pCallback,
        OVERLAPPED* pOverlapped);

    // Accessor for number of io threads in this pool
    DWORD GetNumThreads() { return _cThreads; }

protected:
    
    typedef TList<CIoWorkThread> CThreadList;

    CThreadList _threadList;        // List of threads in the pool
    DWORD       _cThreads;          // Number of threads in the pool
    HANDLE      _hIoCp;             // Handle to IO completion port
    IMemAlloc*  _pAlloc;            // Memory allocator
    OVERLAPPED  _shutdownMessage;   // We'll send this to the completion port to indicate the shutdown
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_system.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_system.h
//
// Objects and functions for system stuff
// Don't include this file directly. Instead include cutil.h
// --------------------------------------------------------------------------------------

#pragma once

class CSystem
{
public:
    
    // CSystem::GetModuleName
    // Writes the full module file name (with the path) into pModuleFileName.
    // Returns false if it fails or if the result was truncated.
    static bool GetModuleName(HMODULE hModule, CStr* pModuleFileName);

    enum ParseType
    {
        PARSE_NAME_WITHOUT_EXTENSION,
        PARSE_NAME_WITH_EXTENSION,
        PARSE_DRIVE,
        PARSE_PATH,
        PARSE_DRIVE_AND_PATH
    };

    // CSystem::ParseFileName
    // Parse a part of a filename and write it to pPart. The part type is specified 
    // in parseType which must be one of the following:
    //
    // PARSE_NAME_WITHOUT_EXTENSION: writes just the filename without extension.  
    // e.g.  notepad
    // PARSE_NAME_WITH_EXTENSION: writes the filename with extension. e.g.  
    // notepad.exe
    // PARSE_DRIVE: writes the drive. e.g. D:
    // PARSE_PATH: writes the path. e.g. \programs\accessories
    // PARSE_DRIVE_AND_PATH: writes the drive and the path. e.g.  
    // D:\programs\accessories
    // 
    // Returns false in case of error or if the result was truncated
    static bool ParseFileName(
        LPCSTR      pFileName, 
        ParseType   parseType,
        CStr*       pPart );

    typedef bool (__stdcall *ENUMERATE_FILES_CALLBACK) (void* userData, LPCSTR pPath, LPCSTR pFileName);

    static bool EnumerateFiles(
        LPCSTR                   pPattern,
        ENUMERATE_FILES_CALLBACK callback,
        void*                    userData);


    // CSystem::ReadRegistryString
    // Read a REG_SZ registry value. Example:
    //
    // TLocalStr<100> npdbServer;
    // CSystem::ReadRegistryString(
    //      HKEY_LOCAL_MACHINE,
    //      "\Software\Microsoft\XboxLive\CommonConfig",
    //      "Server",
    //      &npdbServer);
    //
    //  - hKey: Registry key handle opened by RegOpenKey or one of the HKEY_* pre-opened 
    //  handles (e.g. HKEY_LOCAL_MACHINE)
    //  - key: key path under hKey
    //  - value: value name under key (must be REG_SZ type)
    //  - data: OUT: receives the data value
    //
    //  Returns:
    //   true if succeeds
    //   false if it fails. GetLastError() should contain the error.
    static bool ReadRegistryString(
        HKEY        hKey,
        LPCSTR      key,
        LPCSTR      value,
        OUT CStr*   data );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_trace.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_trace.h
// Don't include this file directly. Instead include cutil.h
// 
// Trace classes and functions
// --------------------------------------------------------------------------------------

#pragma once

// Trace callback interface
class ITraceCallback
{
public:
    virtual bool Write(const char* psz) = 0;
};

// Utility function to write to ITraceCallback::Write in printf style
void TraceCallbackFormattedWrite(
    ITraceCallback* pOut, 
    const char* pszFmt, 
    ... );

// Yet another utility function to write to ITraceCallback. This one to dump
// a binary blob as string of 2-digit hex numbers
inline void TraceCallbackWriteBinary(
    ITraceCallback* pOut,
    BYTE* pBin,
    DWORD dwSize
)
{
    for(DWORD i=0; i < dwSize; i++)
    {
        TraceCallbackFormattedWrite(pOut,"%02x",pBin[i]);
    }
}

// A file that implements ITraceCallback. Can be used as a black box to 
// conviniently dump information to when the application asserts or something
// like that
class CTraceFile : public ITraceCallback
{
public:
    
    CTraceFile()
    {
        _hFile = INVALID_HANDLE_VALUE;
    }

    ~CTraceFile()
    {
        DBGASSERT(_hFile == INVALID_HANDLE_VALUE);
    }

    bool Init(const char* pszFilename)
    {
        bool fRet = false;

        DBGASSERT(_hFile == INVALID_HANDLE_VALUE);
        
        _hFile = ::CreateFileA(pszFilename, GENERIC_WRITE, FILE_SHARE_READ,
                               NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if(INVALID_HANDLE_VALUE == _hFile)
        {
            CGlobalError::SetMessage(GLOBAL_ERROR_HEADER
                                     "CreateFileA failed. Error = %d", 
                                     ::GetLastError());
            goto lDone;
        }

    lDone:

        return fRet;
    }

    void Term()
    {
        if(_hFile != INVALID_HANDLE_VALUE)
        {
            ::CloseHandle(_hFile);
            _hFile = INVALID_HANDLE_VALUE;
        }
    }
    
    virtual bool Write(const char* psz)
    {
        DWORD dwWritten = 0;
        
        if(_hFile == INVALID_HANDLE_VALUE)
            return false;

        CConstStr str(psz);
        if(!::WriteFile(_hFile, str.cstr(), str.GetLength(), &dwWritten, NULL))
        {
            CGlobalError::SetMessage(
                GLOBAL_ERROR_HEADER "WriteFile failed. Error = %d",
                GetLastError());
            
            return false;
        }

        return true;
    }
        
protected:
    
    HANDLE _hFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\cu_tpool.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) 2004 Microsoft Corporation
//
// cu_tpool.cpp
// Don't include this file directly. Instead include cutil.h
// 
// Thread pool
// --------------------------------------------------------------------------------------

#include "precomp.h"

// ************************************* CThread ****************************************

// --------------------------------------------------------------------------------------
// CThread::CThread
// constructor
// --------------------------------------------------------------------------------------
CThread::CThread() :
    _hThread(NULL)
{
}

// --------------------------------------------------------------------------------------
// CThread::~CThread
// destructor
// --------------------------------------------------------------------------------------
CThread::~CThread()
{
    TermThread();
}

// --------------------------------------------------------------------------------------
// CThread::CreateThread
// Create and start the thread
// --------------------------------------------------------------------------------------
BOOL CThread::CreateThread()
{
    DBGASSERT(!_hThread);

    DWORD dwThreadId;
    _hThread = ::CreateThread(NULL, 0, StaticThreadProc, this, 0, &dwThreadId);

    if(!_hThread)
    {
        return FALSE;
    }

    return TRUE;
}

// --------------------------------------------------------------------------------------
// CThread::TermThread
// Terminate the thread. This function waits for the thread to finish before closing the 
// thread handle and returning therefore it's the responsability of the super-class to 
// signal the shutdown and ensure that the thread proc terminates gracefully. Otherwise 
// this method might wait forever for the thread to finish.
// --------------------------------------------------------------------------------------
void CThread::TermThread()
{
    if(_hThread)
    {
        ::WaitForSingleObject(_hThread, INFINITE);
        ::CloseHandle(_hThread);
        _hThread = NULL;
    }
}

// --------------------------------------------------------------------------------------
// CThread::StaticThreadProc
// Static method to be passed in to CreateThread. It should receive the pointer to the 
// CThread instance as param. It immediatelly uses it to call the object method 
// ThreadProc.
// --------------------------------------------------------------------------------------
DWORD WINAPI CThread::StaticThreadProc(LPVOID param)
{
    CThread* pThis = (CThread*) param;
    return pThis->ThreadProc();
}

// *********************************** CWorkThread **************************************

// --------------------------------------------------------------------------------------
// CWorkThread::CWorkThread
// constructor
// --------------------------------------------------------------------------------------
CWorkThread::CWorkThread() :
    _pThreadPool(NULL),
    _hWait(NULL),
    _waitCount(0)
{
}

// --------------------------------------------------------------------------------------
// CWorkThread::~CWorkThread
// destructor
// --------------------------------------------------------------------------------------
CWorkThread::~CWorkThread()
{
    if(_hWait)
    {
        ::CloseHandle(_hWait);
        _hWait = NULL;
    }
}

// --------------------------------------------------------------------------------------
// CWorkThread::Init
// Initialize object
//  - pThreadPool: pointer to CThreadPool that owns this object
//  - Returns TRUE if succeeded, FALSE otherwise
//  --------------------------------------------------------------------------------------
BOOL CWorkThread::Init(CThreadPool* pThreadPool)
{
    DBGASSERT(_pThreadPool == NULL);
    DBGASSERT(pThreadPool != NULL);

    _pThreadPool = pThreadPool;

    _hWait = ::CreateEventA(NULL, TRUE, FALSE, NULL);

    if(!_hWait)
    {
        return FALSE;
    }

    return CreateThread();
}

// --------------------------------------------------------------------------------------
// CWorkThread::Term
// Terminate the thread, gracefully
// --------------------------------------------------------------------------------------
void CWorkThread::Term()
{
    DBGASSERT(_workItemList.IsEmpty());
    ::SetEvent(_hWait);
    TermThread();
}

// --------------------------------------------------------------------------------------
// CWorkThread::SetPriority
// Set thread priority
// - priority: usually THREAD_PRIORITY_NORMAL, THREAD_PRIORITY_BELOW_NORMAL or 
// THREAD_PRIORITY_ABOVE_NORMAL. Check out MSDN for more details.
// - Returns TRUE if succeeded, FALSE otherwise
// --------------------------------------------------------------------------------------
BOOL CWorkThread::SetPriority(int priority)
{
    DBGASSERT(_hThread != NULL);
    return ::SetThreadPriority(_hThread, priority);
}

// --------------------------------------------------------------------------------------
// CWorkThread::ThreadProc
// The all important thread procedure. Retrieves a bunch of workitems, process them and 
// repeat until it's time to shutdown.
// - Returns 0
// --------------------------------------------------------------------------------------
DWORD CWorkThread::ThreadProc()
{
    _workItemList.Init();
    
    // Call GetWorkItems() to retrieve work-items from the thread pool into 
    // _workItemList. It will block appropriatelly if there are no work-items avaialable.  
    // It will return FALSE if it's time to shutdown.

    while(GetWorkItems())
    {
        // If GetWorkItems() returned TRUE, _workItemList must contain at least one 
        // work-item
        DBGASSERT(!_workItemList.IsEmpty());

        // Execute the work-items. Use the helper function to achieve this.
        _pThreadPool->ProcessWorkItems(&_workItemList);
    }

    return 0;
}

// --------------------------------------------------------------------------------------
// CWorkThread::GetWorkItems
// Called by ThreadProc to retrieve work-items from _pThreadPool to process.
// --------------------------------------------------------------------------------------
BOOL CWorkThread::GetWorkItems()
{
    DBGASSERT(_workItemList.IsEmpty());

    // Get work-items from _pThreadPool

    _pThreadPool->GetWorkItems(&_workItemList);

    if(_workItemList.IsEmpty())
    {
        // There we no work-items. Add this thread to the list of idle-threads in 
        // _pThreadPool.

        _waitCount++;
        ::ResetEvent(_hWait);
        _pThreadPool->AddIdleThread(this);

        // Just before going to sleep, make sure no work items were queued while we were 
        // adding the thread to the idle list. Calling DistributeWorkItems will take care 
        // of this

        _pThreadPool->DistributeWorkItems();

        // Sleep until WakeUp is called
        
        ::WaitForSingleObject(_hWait, INFINITE);
    }

    // Return FALSE if the thread pool returned no work-items which means that we're 
    // supposed to shutdown.

    return !_workItemList.IsEmpty();
}

// --------------------------------------------------------------------------------------
// CWorkThread::WakeUp
// Called by _pThreadPool to wakeup thread to process work-items
// - pWorkItemList: list of work-items to process
// --------------------------------------------------------------------------------------
void CWorkThread::WakeUp(CList* pWorkItemList)
{
    // _pThreadPool should never call this function with no work-items
    DBGASSERT(_workItemList.IsEmpty());
    
    // Move work-items to _workItemList
    
    pWorkItemList->MoveToDifferentList(&_workItemList);
    
    // Wake up this thread to process the work-items
    
    ::SetEvent(_hWait);
}

// *********************************** CThreadPool **************************************

// --------------------------------------------------------------------------------------
// CThreadPool::CThreadPool
// constructor
// --------------------------------------------------------------------------------------
CThreadPool::CThreadPool() :
    _workItemCount(0),
    _pAlloc(NULL),
    _fDrain(FALSE),
    _fBatch(FALSE),
    _cThreads(0),
    _activeThreadCount(0),
    _workItemsCallsMiss(0),
    _workItemsCallsHit(0),
    _workItemsRetrieved(0),
    _workItemsAffinityLimit(0)
{
}

// --------------------------------------------------------------------------------------
// CThreadPool::~CThreadPool
// destructor
// --------------------------------------------------------------------------------------
CThreadPool::~CThreadPool()
{
    Term();
}

// --------------------------------------------------------------------------------------
// CThreadPool::Init
// Initialize thread pool
// - cThreads: number of threads in the thread pool. If zero, the number of threads will 
// default to the number of logical processors.
// - fBatch: if TRUE, when a thread calls GetWorkItems(), it will retrieve all work-items 
// currently available. If FALSE, the thread will retrieve only one work-item per call.
// - pAlloc: the allocator to be used for memory allocation. If NULL, 
// CMemAlloc::Default() will be used.
// - Returns true if succeeded, false otherwise
// --------------------------------------------------------------------------------------
bool CThreadPool::Init(
    DWORD cThreads, 
    BOOL fBatch,
    DWORD cWorkItemsAffinityLimit,
    IMemAlloc* pAlloc)
{
    DBGASSERT(_threadList.IsEmpty());

    bool ok = false;
    CWorkThread* pThread = NULL;

    _cThreads = cThreads;
    _fBatch = fBatch;
    _workItemsAffinityLimit = cWorkItemsAffinityLimit;

    if(_cThreads == 0)
    {
        // caller doesn't want to pick the number of threads. Let's default to the number 
        // of logical processors in the machine

        SYSTEM_INFO si;
        ::GetSystemInfo(&si);
        _cThreads = si.dwNumberOfProcessors;
    }

    // If specified, we're going to use the caller's allocator. If not use the default 
    // allocator

    _pAlloc = pAlloc ? pAlloc : CMemAlloc::Default();

    _fDrain = FALSE;

    // Initialize look aside list for work-items

    _workItemLookAside.Init(sizeof(WORKITEM), 1000000, _pAlloc);

    // @@@ this should be a parameter
    _workItemLookAside.PreAlloc(10000);

    // create work threads

    for(DWORD i=0; i < _cThreads; i++)
    {
        pThread = IMEMALLOC_NEW(_pAlloc) CWorkThread();

        if(!pThread)
        {
            goto Exit;
        }

        // thread starts active
        _activeThreadCount++;

        if(!pThread->Init(this))
        {
            goto Exit;
        }

        _threadList.InsertTail(&pThread->_leThreadList);

        pThread = NULL;
    }

    ok = true;

Exit:

    if(!ok)
    {
        Term();
    }

    if(pThread)
    {
        IMEMALLOC_DELETE pThread;
    }

    return ok;
}

// --------------------------------------------------------------------------------------
// CThreadPool::Drain
// Stop accepting new workitems and block until all work-items currently scheduled have 
// been processed
// --------------------------------------------------------------------------------------
void CThreadPool::Drain()
{
    ::InterlockedExchange(&_fDrain, TRUE);

    while(_workItemCount > 0)
    {
        ::Sleep(15);
    }
}

// --------------------------------------------------------------------------------------
// CThreadPool::Term
// Drain workitems and terminate thread pool.
// --------------------------------------------------------------------------------------
void CThreadPool::Term()
{
    // stop accepting new items and wait until all items are processed

    Drain();

    // Shutdown threads

    CListEntry* ple = NULL;

    while((ple = _threadList.RemoveHead()) != NULL)
    {
        CWorkThread* pThread = CONTAINING_RECORD(ple, CWorkThread, _leThreadList);

        // Wait until thread becomes

        while(pThread->_leIdleThreadList.GetNext() == NULL)
        {
            ::Sleep(15);
        }

        pThread->Term();

        IMEMALLOC_DELETE pThread;
    }

    // Release other resources

    _workItemLookAside.Term();
}

// --------------------------------------------------------------------------------------
// CThreadPool::SetPriority
// Set priority of threads in the pool
// - priority: usually THREAD_PRIORITY_NORMAL, THREAD_PRIORITY_BELOW_NORMAL or 
// THREAD_PRIORITY_ABOVE_NORMAL. Check out MSDN for more details.
// - Returns TRUE if succeeded, FALSE otherwise
// --------------------------------------------------------------------------------------
BOOL CThreadPool::SetPriority(int priority)
{
    for(CListEntry* ple = _threadList.GetFirst(); !ple->IsTail(); ple = ple->GetNext())
    {
        CWorkThread* pThread = CONTAINING_RECORD(ple, CWorkThread, _leThreadList);

        if(!pThread->SetPriority(priority))
        {
            return FALSE;
        }
    }

    return TRUE;
}

// --------------------------------------------------------------------------------------
// CThreadPool::AddWorkItem
// Add a work-item to be processed in the thread-pool
// - pfn: function to be executed
// - param: parameter to be passed to pfn
// - priority: controls when we wake an idle thread to process this workitem
// - Returns true if succeeded, false otherwise
// --------------------------------------------------------------------------------------
bool CThreadPool::AddWorkItem(PFNWORKITEM pfn, void* param, WorkItemPriority priority)
{
    if(_fDrain)
    {
        // we're shutting down
        return false;
    }

    // Allocate new work-item and fill it out with the parameters
    
    WORKITEM* pWorkItem = (WORKITEM*) _workItemLookAside.Alloc();

    if(!pWorkItem)
    {
        return false;
    }

    pWorkItem->leWorkItems.Init();
    pWorkItem->pfnWorkItem = pfn;
    pWorkItem->param = param;

    // Put work-item in the queue

    _lockWorkItemQueue.Lock();
    _workItemQueue.InsertTail(&pWorkItem->leWorkItems);
    _workItemCount++;
    _lockWorkItemQueue.Unlock();

    // Distribute work-items to work threads

    DistributeWorkItems(priority);

    return true;
}


// --------------------------------------------------------------------------------------
// CThreadPool::GetWaitCount
// Returns the total number of times individual threads went to sleep because they ran 
// out of work to do.
// - Returns: Total number of waits
// --------------------------------------------------------------------------------------
UINT32 CThreadPool::GetWaitCount()
{
    UINT32 count = 0;

    for(CListEntry* ple = _threadList.GetFirst(); !ple->IsTail(); ple = ple->GetNext())
    {
        CWorkThread* pThread = CONTAINING_RECORD(ple, CWorkThread, _leThreadList);
        count += pThread->GetWaitCount();
    }

    return count;
}

// --------------------------------------------------------------------------------------
// CThreadPool::DistributeWorkItems
// - priority: controls how we wake up an idle thread, assuming a new workitem was just 
// placed on the queue
// Distributes work-items to idle-threads.
// --------------------------------------------------------------------------------------
void CThreadPool::DistributeWorkItems(WorkItemPriority priority)
{
    CWorkThread* pThread = NULL;
    CList workItems;

    // Work item priority
    //
    // Low priority: just return immediately. These work items will hopefully be grabbed 
    // in the next go around, or processed by someone else.
    //
    // Normal priority: follow the affinity limit heuristic, if it was configured. If 
    // there is 1 active thread, and the work item queue is below a threshold, then we'll 
    // do nothing, otherwise we'll wake an idle thread.
    //
    // High priority: always wake an idle thread.
    //
 
    if (priority == PriorityLow)
    {
        return;
    }

    for(;;)
    {
        if(_workItemCount == 0)
        {
            // no work item
            break;
        }

        // Heuristic for allowing active threads to handle incoming work items. We won't 
        // waste a context switch waking up an idle thread if the work item queue is 
        // small; instead the currently active thread(s) will pull in the work items when 
        // they are done with their current set.

        if (_activeThreadCount > 0 &&
            _workItemCount < _workItemsAffinityLimit &&
            priority == PriorityNormal)
        {
            break;
        }

        // Get a thread that's idle

        pThread = GetIdleThread();

        if(!pThread)
        {
            // no thread
            break;
        }

        // Get one work-item (or all of them if the batch option was specified)

        GetWorkItems(&workItems);

        if(!workItems.IsEmpty())
        {
            // Wake up idle thread and give it some work-items. 

            pThread->WakeUp(&workItems);
            DBGASSERT(workItems.IsEmpty());
        }
        else
        {
            // There were no work-items. Add thread back to the idle list.

            AddIdleThread(pThread);
        }
    }
}

// --------------------------------------------------------------------------------------
// CThreadPool::GetIdleThread
// Remove and return a idle-thread from the list.
// - Returns the pointer to CWorkThread if available. Returns NULL if the list of 
// idle-threds is empty.
// --------------------------------------------------------------------------------------
CWorkThread* CThreadPool::GetIdleThread()
{
    CWorkThread* pThread = NULL;

    _lockIdleThreadList.Lock();

    if(!_idleThreadList.IsEmpty())
    {
        CListEntry* ple = _idleThreadList.RemoveTail();
        DBGASSERT(ple);

        pThread = CONTAINING_RECORD(ple, CWorkThread, _leIdleThreadList);
        InterlockedIncrement((LONG*)&_activeThreadCount);
    }

    _lockIdleThreadList.Unlock();

    return pThread;
}

// --------------------------------------------------------------------------------------
// CThreadPool::AddIdleThread
// Add a thread to the list of idle-threads. CThreadPool will use this list to distribute 
// work-items as they become available. The thread must go to sleep after it adds itself 
// to the idle-list.
// - pThread: pointer to thread that should be put in the idle-list
// --------------------------------------------------------------------------------------
void CThreadPool::AddIdleThread(CWorkThread* pThread)
{
    _lockIdleThreadList.Lock();

    DBGASSERT(pThread->_leIdleThreadList.GetNext() == NULL);
    DBGASSERT(_activeThreadCount > 0);

    _idleThreadList.InsertTail(&pThread->_leIdleThreadList);
    InterlockedDecrement((LONG*)&_activeThreadCount);

    _lockIdleThreadList.Unlock();
}

// --------------------------------------------------------------------------------------
// CThreadPool::GetWorkItems
// Retrieve one or more work-items. If there are no work-items available, this function 
// will not block. In which case, no work-items will be copied to the pWorkItemList.
// - pWorkItemList: pointer to list to copy work-items to. The list must be empty.
// --------------------------------------------------------------------------------------
void CThreadPool::GetWorkItems(CList* pWorkItemList)
{
    DBGASSERT(pWorkItemList->IsEmpty());
    
    _lockWorkItemQueue.Lock();

    if (_workItemCount > 0)
        _workItemsCallsHit++;
    else
        _workItemsCallsMiss++;

    if(_fBatch)
    {
        _workItemQueue.MoveToDifferentList(pWorkItemList);
        _workItemsRetrieved += _workItemCount;
        _workItemCount = 0;
    }
    else
    {
        CListEntry* ple = _workItemQueue.RemoveHead();
        
        if(ple)
        {
            pWorkItemList->InsertTail(ple);
            _workItemsRetrieved++;
            _workItemCount--;
        }
    }

    _lockWorkItemQueue.Unlock();
}

// --------------------------------------------------------------------------------------
// CThreadPool::ExternalThreadProcessWorkItems
// Grab one or multiple work items and process them. This should be called by threads 
// outside this thread pool, and is to be used as an entry point for 'helpers'. The idea 
// is to reduce context switches -- if another thread is already active, why not just come 
// in and do some work? We still need the worker threads for high-priority work items, 
// though.
//
// This may take an indefinite amount of time to return from.
// --------------------------------------------------------------------------------------
void CThreadPool::ExternalThreadProcessWorkItems()
{
    CList workItemList;
    workItemList.Init();

    InterlockedIncrement((LONG*)&_activeThreadCount);

    GetWorkItems(&workItemList);
    while (!workItemList.IsEmpty())
    {
        ProcessWorkItems(&workItemList);
        GetWorkItems(&workItemList);
    }

    InterlockedDecrement((LONG*)&_activeThreadCount);
}

// --------------------------------------------------------------------------------------
// CThreadPool::ProcessWorkItems
// Process work items by calling their callback functions. This should be called on a 
// worker thread, as who knows what the callbacks will do.
// - pWorkItemList: pointer to list of workitems to process.
// --------------------------------------------------------------------------------------
DWORD CThreadPool::ProcessWorkItems(CList* pWorkItemList)
{
    DBGASSERT(pWorkItemList);

    CListEntry* ple;
    DWORD count = 0;
    while((ple = pWorkItemList->RemoveHead()) != NULL)
    {
        CThreadPool::WORKITEM* pWorkItem = CONTAINING_RECORD(ple, CThreadPool::WORKITEM, leWorkItems);
        pWorkItem->pfnWorkItem(pWorkItem->param);
        count++;

        // Release the work-item structure (it keeps a look-aside list of them)
        ReleaseWorkItem(pWorkItem);
    }

    DBGASSERT(pWorkItemList->IsEmpty());
    return count;
}

// --------------------------------------------------------------------------------------
// CThreadPool::ReleaseWorkItem
// Returns a WORKITEM structure back to the look-aside list. This function must be used 
// to release WORKITEM structures.
// - pWorkItem: pointer to WORKITEM to be released.
// --------------------------------------------------------------------------------------
void CThreadPool::ReleaseWorkItem(WORKITEM* pWorkItem)
{
    _workItemLookAside.Free(pWorkItem);
}

// ********************************** CIoWorkThread *************************************

// --------------------------------------------------------------------------------------
// CIoWorkThread::CIoWorkThread
// constructor
// --------------------------------------------------------------------------------------
CIoWorkThread::CIoWorkThread() :
    _hIoCp(NULL),
    _pShutdownMessage(NULL)
{
}

// --------------------------------------------------------------------------------------
// CIoWorkThread::Init
// Initialize the thread
// - hIoCp: handle to IO completion port
// - pShutdownMessage: pointer to special OVERLAPPED structure that will posted on the 
// completion queue to indicate that the threads should terminate.
// --------------------------------------------------------------------------------------
bool CIoWorkThread::Init(HANDLE hIoCp, OVERLAPPED* pShutdownMessage)
{
    _hIoCp              = hIoCp;
    _pShutdownMessage   = pShutdownMessage;

    if(!CreateThread())
    {
        return false;
    }

    return true;
}

// --------------------------------------------------------------------------------------
// CIoWorkThread::Term
// Block until thread terminates and release resources
// --------------------------------------------------------------------------------------
void CIoWorkThread::Term()
{
    TermThread();
}
    
// --------------------------------------------------------------------------------------
// CIoWorkThread::SetPriority
// Set thread priority
// --------------------------------------------------------------------------------------
BOOL CIoWorkThread::SetPriority(int priority)
{
    DBGASSERT(_hThread != NULL);
    return ::SetThreadPriority(_hThread, priority);
}

BOOL CIoWorkThread::SetPriorityBoost(BOOL disablePriorityBoost)
{
    DBGASSERT(_hThread != NULL);
    return ::SetThreadPriorityBoost(_hThread, disablePriorityBoost);
}

// --------------------------------------------------------------------------------------
// CIoWorkThread::ThreadProc
// The all important thread procedure. Retrieves a bunch of workitems, process them and 
// repeat until it's time to shutdown.
// --------------------------------------------------------------------------------------
DWORD CIoWorkThread::ThreadProc()
{
    DWORD numberOfBytes;
    PFNIOCOMPLETED pCallback;
    OVERLAPPED* pOverlapped;
    DWORD error;
    BOOL success;

    for(;;)
    {
        C_ASSERT(sizeof(pCallback) == sizeof(ULONG_PTR));

        success = ::GetQueuedCompletionStatus(
            _hIoCp,
            &numberOfBytes,
            (ULONG_PTR*) &pCallback,
            &pOverlapped,
            INFINITE);

        if(pOverlapped == _pShutdownMessage)
        {
            // CIoThreadPool is telling us to quit
            break;
        }

        if(success)
        {
            error = 0;
        }
        else
        {
            error = GetLastError();

            if(error == 0)
            {
                error = 0xFFFFFFFF;
            }
        }

        DBGASSERT(pCallback);
        
        pCallback(error, numberOfBytes, pOverlapped);
    }

    return 0;
}

// ********************************** CIoThreadPool *************************************

// --------------------------------------------------------------------------------------
// CIoThreadPool::CIoThreadPool
// constructor
// --------------------------------------------------------------------------------------
CIoThreadPool::CIoThreadPool() :
    _cThreads(0),
    _hIoCp(NULL)
{
}

// --------------------------------------------------------------------------------------
// CIoThreadPool::~CIoThreadPool
// destructor
// --------------------------------------------------------------------------------------
CIoThreadPool::~CIoThreadPool()
{
    Term();
}

// --------------------------------------------------------------------------------------
// CIoThreadPool::Init
// Initialize IO thread pool
// - cThreads: number of threads in the pool. If 0, the number of logical processors in 
// the machine will be used instead.
// - pAlloc: custom memory allocator. If NULL, CMemAlloc::Default() will be used.
// --------------------------------------------------------------------------------------
bool CIoThreadPool::Init(
    DWORD cThreads,
    IMemAlloc* pAlloc
    )
{
    DBGASSERT(_threadList.IsEmpty());
    
    bool ok = false;
    CIoWorkThread* pThread = NULL;
    _cThreads = cThreads;

    if(_cThreads == 0)
    {
        // caller doesn't want to pick the number of threads. Let's default to the number 
        // of logical processors in the machine

        SYSTEM_INFO si;
        ::GetSystemInfo(&si);
        _cThreads = si.dwNumberOfProcessors;
    }
    
    // Create IO completion port

    _hIoCp = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 255);

    if(!_hIoCp)
    {
        goto Exit;
    }

    // If specified, we're going to use the caller's allocator. If not use the default 
    // allocator
    
    _pAlloc = pAlloc ? pAlloc : CMemAlloc::Default();

    for(DWORD i=0; i < _cThreads; i++)
    {
        pThread = IMEMALLOC_NEW(_pAlloc) CIoWorkThread();

        if(!pThread)
        {
            goto Exit;
        }

        if(!pThread->Init(_hIoCp, &_shutdownMessage))
        {
            goto Exit;
        }

        _threadList.Push(pThread);

        pThread = NULL;
    }

    ok = true;

Exit:
    
    if(!ok)
    {
        Term();
    }

    if(pThread)
    {
        IMEMALLOC_DELETE pThread;
    }

    return ok;
}

// --------------------------------------------------------------------------------------
// CIoThreadPool::Term
// Terminate the thread-pool. It first signals all threads to shutdown and waits until 
// all of them are terminated.
// --------------------------------------------------------------------------------------
void CIoThreadPool::Term()
{
    if(_hIoCp)
    {
        // Signal threads to terminate
        CThreadList::Iterator it;
        for(_threadList.Begin(&it); it.Get(); it.Next())
        {
            ::PostQueuedCompletionStatus(_hIoCp, 0, 0, &_shutdownMessage);
        }
    }
    
    // Release resources
    CIoWorkThread* pThread;
    while((pThread = _threadList.Pop()) != NULL)
    {
        pThread->Term();
        IMEMALLOC_DELETE pThread;
    }
    
    if(_hIoCp)
    {
        ::CloseHandle(_hIoCp);
        _hIoCp = NULL;
    }
}

// --------------------------------------------------------------------------------------
// CIoThreadPool::SetPriority
// Set priority of threads in the pool
// - priority: usually THREAD_PRIORITY_NORMAL, THREAD_PRIORITY_BELOW_NORMAL or 
// THREAD_PRIORITY_ABOVE_NORMAL. Check out MSDN for more details.
// Returns:
//  TRUE if succeeded, FALSE if otherwise.
// --------------------------------------------------------------------------------------
BOOL CIoThreadPool::SetPriority(int priority)
{
    CThreadList::Iterator it;
    for(_threadList.Begin(&it); it.Get(); it.Next())
    {
        if(!it.Get()->SetPriority(priority))
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL CIoThreadPool::SetPriorityBoost(BOOL disablePriorityBoost)
{
    CThreadList::Iterator it;
    for(_threadList.Begin(&it); it.Get(); it.Next())
    {
        if(!it.Get()->SetPriorityBoost(disablePriorityBoost))
        {
            return FALSE;
        }
    }

    return TRUE;
}

// --------------------------------------------------------------------------------------
// CIoThreadPool::Bind
// Bind a file, socket, etc. handle to the IO completion port.
// - hFile: the file, socket, etc. handle to be bound
// - pCallback: Pointer to PFNIOCOMPLETED callback function that will be called for each 
// IO operation completed on hFile. 
// --------------------------------------------------------------------------------------
bool CIoThreadPool::Bind(
    HANDLE hFile, 
    PFNIOCOMPLETED pCallback
    )
{
    DBGASSERT(hFile);
    DBGASSERT(pCallback);
    DBGASSERT(_hIoCp);

    if(!hFile || hFile == INVALID_HANDLE_VALUE)
    {
        return false;
    }

    if(!pCallback)
    {
        return false;
    }

    HANDLE h;

    C_ASSERT(sizeof(pCallback) == sizeof(ULONG_PTR));

    h = CreateIoCompletionPort(
        hFile,
        _hIoCp,
        (ULONG_PTR) pCallback,
        0);

    return h != NULL;
}

// --------------------------------------------------------------------------------------
// CIoThreadPool::Post
// Post a user item in the IO completion port.
// - numberOfBytes: this is usually the number of bytes affected in a IO operation - but 
// since this is a user item, it can be anything. Just make sure your callback function 
// can handle it.
// - pCallback: callback function to be called when the item is taken from the queue.
// - pOverlapped: also usually a pointer to a OVERLAPPED structure - but it can be 
// anything here
// --------------------------------------------------------------------------------------
bool CIoThreadPool::Post(
    DWORD numberOfBytes,
    PFNIOCOMPLETED pCallback,
    OVERLAPPED* pOverlapped
    )
{
    DBGASSERT(_hIoCp);

    C_ASSERT(sizeof(pCallback) == sizeof(ULONG_PTR));

    return ::PostQueuedCompletionStatus(
        _hIoCp, 
        numberOfBytes, 
        (ULONG_PTR) pCallback,
        pOverlapped) == TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\lib\precomp.h ===
#pragma once

#include "cutilp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\sources.inc ===
# Copyright (c) Microsoft Corporation.  All rights reserved

INCLUDES=\
    .\..\; \
    $(INCLUDES)

SOURCES=\
    cu_base.cpp         \
    cu_collection.cpp   \
    cu_error.cpp        \
    cu_system.cpp       \
    cu_timer.cpp        \
    cu_trace.cpp        \
    cu_system.cpp       \
    cu_tpool.cpp        \
    cu_stream.cpp       \
    cu_base64.cpp       \
    
USE_LIBCMT=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\dvt\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <atlbase.h>

#include "..\cutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\lib\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_cutil_none_12.4.56.0_none_e9dcb2f9cfe8e16b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=cutil
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b.manifest
XP_MANIFEST_PATH=manifests\x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b.cat
XP_CATALOG_PATH=manifests\x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b.cat
XP_PAYLOAD_PATH=x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=cutil,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\lib\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_cutil_none_12.4.56.0_none_e9dcb2f9cfe8e16b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=cutil
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b.manifest
XP_MANIFEST_PATH=manifests\x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b.cat
XP_CATALOG_PATH=manifests\x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b.cat
XP_PAYLOAD_PATH=x86_cutil_no-public-key_12.4.56.0_x-ww_01be2c7b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=cutil,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\dvt\dvt.cpp ===
// This is the main project file for VC++ application project 
// generated using an Application Wizard.

#include "stdafx.h"

void TC_CArenaMemAlloc_GlobalInit_Pos()
{
    bool bResult = CArenaMemAlloc::GlobalInit(16 * 1024, 1, true, NULL);

    printf("Test case TC_CArenaMemAlloc_GlobalInit_Pos %s.\r\n", bResult ? "succeeded" : "failed");

    CArenaMemAlloc::GlobalTerm();
}

void TC_CArenaMemAlloc_GlobalInit_Neg_48762()
{
    bool bResult = CArenaMemAlloc::GlobalInit(0xffffffff, 1, true, NULL);

    printf("Test case TC_CArenaMemAlloc_GlobalInit_Pos %s.\r\n", !bResult ? "succeeded" : "failed");    

    CArenaMemAlloc::GlobalTerm();
}

void TC_CArrayBase_Grow_Pos()
{
    TArray<int, 1024>* pArray = new TArray<int, 1024>();

    bool bResult = pArray->Grow(2048);

    printf("Test case TC_CArrayBase_Grow_Pos %s.\r\n", (bResult ? "succeeded" : "failed"));

    if(pArray != NULL)
        delete pArray;
}

void TC_CArrayBase_Grow_Neg_48763()
{
    TArray<int, 1024>* pArray = new TArray<int, 1024>();

    bool bResult = pArray->Grow(0x7fffffff);

    printf("Test case TC_CArrayBase_Grow_Pos %s.\r\n", (!bResult ? "succeeded" : "failed"));

    if(pArray != NULL)
        delete pArray;
}

int __cdecl _tmain()
{
    CMemAlloc::GlobalInit();

    TC_CArenaMemAlloc_GlobalInit_Pos();
    TC_CArenaMemAlloc_GlobalInit_Neg_48762();

    TC_CArrayBase_Grow_Pos();
    TC_CArrayBase_Grow_Neg_48763();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\test\precomp.h ===
#pragma once

#include "cutilp.h"
#include <math.h>
#include <crtdbg.h>
#include "tests.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\test\tests.h ===
#pragma once

#define TEST_ASSERT(x) \
    if(!(x)) \
    { \
        printf("Test error in %s line %d: %s", __FILE__, __LINE__, #x); \
        printf("LastError:\n%s", CGlobalError::GetCurrentMessage()); \
        DebugBreak(); \
    } \

#define HTONL_(ul) \
    ((unsigned long)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((unsigned short)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

inline unsigned long  HTONL(unsigned long  ul) { return(HTONL_(ul)); }
inline unsigned long  NTOHL(unsigned long  ul) { return(NTOHL_(ul)); }
inline unsigned short HTONS(unsigned short us) { return(HTONS_(us)); }
inline unsigned short NTOHS(unsigned short us) { return(NTOHS_(us)); }
    
// Test cases
void TestCStr();
void TestCLFStack();
void TestCList();
void TestCLFQueue();
void TestTList();
void TestCFixedSizeMemPool();
void TestCArenaMemAlloc();
void TestTArray();
void TestCHashtable();
void TestTHeap();
void TestStressHeapRemoveAt();
void TestCServerTimerSimple();
void TestCServerTimerWrap();
void TestCSystem();
void TestCSystem_EnumerateFiles();
void TestCThreadPool();
void TestCIoThreadPool();
void TestCMemoryStream();
void TestCBase64();
void TestCArenaAlloc();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_test_cutil_none_12.4.56.0_none_63eb249c450945b0
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=test_cutil
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e.manifest
XP_MANIFEST_PATH=manifests\x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e.cat
XP_CATALOG_PATH=manifests\x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e.cat
XP_PAYLOAD_PATH=x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=test_cutil,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\test\main.cpp ===
#include "precomp.h"

void __cdecl main()
{
    // Set the Crt allocator to debug mode
    _CrtSetReportMode(_CRT_WARN,    _CRTDBG_MODE_FILE);
    _CrtSetReportFile(_CRT_WARN,    _CRTDBG_FILE_STDERR);
    _CrtSetReportMode(_CRT_ERROR,   _CRTDBG_MODE_FILE);
    _CrtSetReportFile(_CRT_ERROR,   _CRTDBG_FILE_STDERR);
    _CrtSetReportMode(_CRT_ASSERT,  _CRTDBG_MODE_FILE);
    _CrtSetReportFile(_CRT_ASSERT,  _CRTDBG_FILE_STDERR);
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF ); 

    // Init CUtil stuff
    CMemAlloc::Init();
    CGlobalError::Init();
    
    // tutil.cpp
    TestCStr();
    TestCLFStack();
    TestCList();
    TestTList();
    TestTArray();
    TestCHashtable();
    TestTHeap();
    TestStressHeapRemoveAt();
    TestCServerTimerSimple();
    TestCServerTimerWrap();
    TestCSystem();
    TestCSystem_EnumerateFiles();
    TestCThreadPool();
    TestCIoThreadPool();
    TestCMemoryStream();
    TestCBase64();
    TestCArenaAlloc();

    printf("Done!\n");
    
    // Terminate
    CGlobalError::Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_test_cutil_none_12.4.56.0_none_63eb249c450945b0
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=test_cutil
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e.manifest
XP_MANIFEST_PATH=manifests\x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e.cat
XP_CATALOG_PATH=manifests\x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e.cat
XP_PAYLOAD_PATH=x86_test_cutil_no-public-key_12.4.56.0_x-ww_3d1dff8e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=test_cutil,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\cutil\test\tutil.cpp ===
#include "precomp.h"

void TestCStr()
{
    printf("TestCStr\n");
        
    // Write nothing
    {
        TLocalStr<10> str;
        TEST_ASSERT(!str.CopyFrom("").HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo(""));
        TEST_ASSERT(str.GetLength() == 0);
        str.Reset();
        TEST_ASSERT(!str.CopyFrom(CTinyStr("")).HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo(CTinyStr("")));
        TEST_ASSERT(str.GetLength() == 0);
        str.Reset();
        TEST_ASSERT(!str.Format("").HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo(""));
        TEST_ASSERT(str.GetLength() == 0);
    }
    // Write something
    {
        TLocalStr<10> str;
        TEST_ASSERT(!str.CopyFrom("12345").HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo("12345"));
        TEST_ASSERT(str.GetLength() == 5);
        str.Reset();
        TEST_ASSERT(!str.CopyFrom(CTinyStr("12345")).HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo(CTinyStr("12345")));
        TEST_ASSERT(str.GetLength() == 5);
        str.Reset();
        TEST_ASSERT(!str.Format("%s", "12345").HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo("12345"));
        TEST_ASSERT(str.GetLength() == 5);
    }
    // Write everything
    {
        TLocalStr<10> str;
        TEST_ASSERT(!str.CopyFrom("1234567890").HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo("1234567890"));
        TEST_ASSERT(str.GetLength() == 10);
        str.Reset();
        TEST_ASSERT(!str.CopyFrom(CTinyStr("1234567890")).HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo(CTinyStr("1234567890")));
        TEST_ASSERT(str.GetLength() == 10);
        str.Reset();
        TEST_ASSERT(!str.Format("%s", "1234567890").HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo("1234567890"));
        TEST_ASSERT(str.GetLength() == 10);
    }
    // Overload
    {
        TLocalStr<10> str;
        TEST_ASSERT(str.CopyFrom("1234567890ABC").HasTruncated());
        TEST_ASSERT(str.IsEqualTo("1234567890"));
        TEST_ASSERT(str.GetLength() == 10);
        str.Reset();
        TEST_ASSERT(str.CopyFrom(CTinyStr("1234567890ABC")).HasTruncated());
        TEST_ASSERT(str.IsEqualTo(CTinyStr("1234567890")));
        TEST_ASSERT(str.GetLength() == 10);
        str.Reset();
        TEST_ASSERT(str.Format("%s", "1234567890ABC").HasTruncated());
        TEST_ASSERT(str.IsEqualTo("1234567890"));
        TEST_ASSERT(str.GetLength() == 10);
    }
    // Autogrow
    {
        TLocalStr<10> str;
        str.SetAllocator(CMemAlloc::Default());
        TEST_ASSERT(!str.CopyFrom("12345678901234567890").HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo("12345678901234567890"));
        TEST_ASSERT(str.GetLength() == 20);
    }
    {
        TLocalStr<10> str;
        str.SetAllocator(CMemAlloc::Default());
        TEST_ASSERT(!str.CopyFrom("12345678901234567890").HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo(CTinyStr("12345678901234567890")));
        TEST_ASSERT(str.GetLength() == 20);
    }
    {
        TLocalStr<10> str;
        str.SetAllocator(CMemAlloc::Default());
        TEST_ASSERT(!str.Format("%s", "12345678901234567890").HasFailedOrTruncated());
        TEST_ASSERT(str.IsEqualTo("12345678901234567890"));
        TEST_ASSERT(str.GetLength() == 20);
    }
    {
        TEST_ASSERT(CSTR("AAA").IsEqualTo("AAA"));
        TEST_ASSERT(!CSTR("AAA").IsEqualTo("AAAA"));
        TEST_ASSERT(CSTR("AAA").IsEqualTo("AAA"));
        TEST_ASSERT(!CSTR("AAA").IsEqualTo("BBB"));
        TEST_ASSERT(!CSTR("AAa").IsEqualTo("AAA"));
        TEST_ASSERT(CSTR("AAa").IsCaseInsensitiveEqualTo("AAA"));
    }
    // Trim
    {
        TEST_ASSERT(CSmallStr("    ABC").Trim().IsEqualTo("ABC"));
        TEST_ASSERT(CSmallStr("ABC    ").Trim().IsEqualTo("ABC"));
        TEST_ASSERT(CSmallStr("  ABC  ").Trim().IsEqualTo("ABC"));
        TEST_ASSERT(CSmallStr("ABC")    .Trim().IsEqualTo("ABC"));
    }
    // StartWrite & EndWrite
    {
        TLocalStr<10> str;
        LPSTR p;
        UINT32 c;
        p = str.StartWrite(&c);
        TEST_ASSERT(c == 10);
        p[0] = 'A';
        p[1] = 'B';
        p[2] = 'C';
        p[3] = 'X';
        str.EndWrite(3);
        TEST_ASSERT(str.GetLength() == 3);
        TEST_ASSERT(str.IsEqualTo("ABC"));
        p = str.StartWrite(&c);
        TEST_ASSERT(c == 7);
        p[0] = 'D';
        p[1] = 'E';
        p[2] = 'F';
        str.EndWrite(3);
        TEST_ASSERT(str.GetLength() == 6);
        TEST_ASSERT(str.IsEqualTo("ABCDEF"));
        str.StartWrite(&c);
        TEST_ASSERT(c == 4);
        str.EndWrite(0);
        TEST_ASSERT(str.GetLength() == 6);
        TEST_ASSERT(str.IsEqualTo("ABCDEF"));
        TEST_ASSERT(str.HasRoom(4));
        TEST_ASSERT(!str.HasRoom(5));
    }
    // HasRoom
    {
        TLocalStr<10> str;
        str.SetAllocator(CMemAlloc::Default());
        TEST_ASSERT(str.HasRoom(10));
        TEST_ASSERT(str.GetCapacity() == 10);
        TEST_ASSERT(str.HasRoom(11));
        TEST_ASSERT(str.GetCapacity() >= 11);
        TEST_ASSERT(str.GetLength() == 0);
    }
    // TStrUtil
    {
        TEST_ASSERT(CConstStr(CStrUtil().FormatIp(255,254,253,252)).IsEqualTo("255.254.253.252"));
        TEST_ASSERT(CConstStr(CStrUtil().FormatIpH(0xFFFEFDFC)).IsEqualTo("255.254.253.252"));
        TEST_ASSERT(CConstStr(CStrUtil().FormatIpN(HTONL(0xFFFEFDFC))).IsEqualTo("255.254.253.252"));
        TEST_ASSERT(CConstStr(CStrUtil().FormatIpPort(255,254,253,252,0xBABE)).IsEqualTo("255.254.253.252:47806"));
        TEST_ASSERT(CConstStr(CStrUtil().FormatIpPortH(0xFFFEFDFC,0xBABE)).IsEqualTo("255.254.253.252:47806"));
        TEST_ASSERT(CConstStr(CStrUtil().FormatIpPortN(HTONL(0xFFFEFDFC),HTONS(0xBABE))).IsEqualTo("255.254.253.252:47806"));
    }
}


class CLFStackableTestData : 
    public TSingleLink<0>, 
    public TSingleLink<1>, 
    public TSingleLink<2>
{
public:
    
    void Init(int iKey)
    {
        _iKey      = iKey;
        _iVerifier = CalcVerifier(iKey);
    }
    
    void Verify(int iKey) const
    {
        TEST_ASSERT(iKey == _iKey);
        TEST_ASSERT(CalcVerifier(iKey) == _iVerifier);
    }
    
protected:
    
    int CalcVerifier(int iKey) const 
    {
        return (iKey+1) * 1001;
    }
    
    int _iKey;
    int _iVerifier;    
};

void TestCLFStack()
{
    printf("TestCLFStack\n");
    
    CLFStackableTestData rgData[5];
    
    for(int i=0; i < ARRAY_SIZE(rgData); i++)
    {
        rgData[i].Init(i);
    }
    
    // 1 - Push, pop
    {
        TLFStack<CLFStackableTestData> stk;
        
        stk.Push(&rgData[3]);
        stk.Pop();
        rgData[3].Verify(3);
    }
    
    // 2 - Push, push, pop, pop
    {
        TLFStack<CLFStackableTestData> stk;
        CLFStackableTestData* p;
        
        stk.Push(&rgData[1]);
        stk.Push(&rgData[2]);
        
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == &rgData[2]);
        p->Verify(2);
        
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
    }
    
    // 3 - Push, pop, pop, push, pop
    {
        TLFStack<CLFStackableTestData> stk;
        CLFStackableTestData* p;
        
        stk.Push(&rgData[4]);

        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == &rgData[4]);
        p->Verify(4);
    
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == NULL);
        
        stk.Push(&rgData[1]);
        
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
    }
    
    // 4 - Pop, push, pop
    {
        TLFStack<CLFStackableTestData> stk;
        CLFStackableTestData* p;
        
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == NULL);
        
        stk.Push(&rgData[1]);
        
        p = (CLFStackableTestData*) stk.Pop();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
    }
    
    // Multiple stacks
    {
        TLFStack<CLFStackableTestData, 0> stack1;
        TLFStack<CLFStackableTestData, 1> stack2;
        TLFStack<CLFStackableTestData, 2> stack3;
        
        stack1.Push(&rgData[0]);
        stack1.Push(&rgData[1]);
        stack1.Push(&rgData[2]);
        stack1.Push(&rgData[3]);
        stack1.Push(&rgData[4]);

        stack2.Push(&rgData[4]);
        stack2.Push(&rgData[3]);
        stack2.Push(&rgData[2]);
        stack2.Push(&rgData[1]);
        stack2.Push(&rgData[0]);
        
        stack3.Push(&rgData[0]);
        stack3.Push(&rgData[2]);
        stack3.Push(&rgData[4]);
        stack3.Push(&rgData[3]);
        stack3.Push(&rgData[1]);
        
        TEST_ASSERT(stack1.Pop() == &rgData[4]);
        TEST_ASSERT(stack1.Pop() == &rgData[3]);
        TEST_ASSERT(stack1.Pop() == &rgData[2]);
        TEST_ASSERT(stack1.Pop() == &rgData[1]);
        TEST_ASSERT(stack1.Pop() == &rgData[0]);
        TEST_ASSERT(stack1.Pop() == NULL);

        TEST_ASSERT(stack2.Pop() == &rgData[0]);
        TEST_ASSERT(stack2.Pop() == &rgData[1]);
        TEST_ASSERT(stack2.Pop() == &rgData[2]);
        TEST_ASSERT(stack2.Pop() == &rgData[3]);
        TEST_ASSERT(stack2.Pop() == &rgData[4]);
        TEST_ASSERT(stack2.Pop() == NULL);
        
        TEST_ASSERT(stack3.Pop() == &rgData[1]);
        TEST_ASSERT(stack3.Pop() == &rgData[3]);
        TEST_ASSERT(stack3.Pop() == &rgData[4]);
        TEST_ASSERT(stack3.Pop() == &rgData[2]);
        TEST_ASSERT(stack3.Pop() == &rgData[0]);
        TEST_ASSERT(stack3.Pop() == NULL);
    }

    // PopAll
    {
        TLFStack<CLFStackableTestData> stack;
        TLFStack<CLFStackableTestData>::Iterator it;

        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            stack.Push(&rgData[i]);
        }

        stack.PopAll(&it);

        for(int i=0; i < ARRAY_SIZE(rgData); i++, it.Next())
        {
            TEST_ASSERT(it.Get() == &rgData[ARRAY_SIZE(rgData) - i - 1]);
        }

        TEST_ASSERT(!it.Get());
        TEST_ASSERT(!it.Next());
        TEST_ASSERT(!stack.Pop());
        
        stack.PopAll(&it);
        TEST_ASSERT(!it.Get());
    }
}

void TestCList()
{
    printf("TestCList\n");
    CList list;
    CListEntry a, b, c, d;
    CListEntry* ple;
    
    /* Stack */
    list.Push(&a);
    list.Push(&b);
    TEST_ASSERT(list.Pop() == &b);
    TEST_ASSERT(list.Pop() == &a);
    TEST_ASSERT(list.Pop() == NULL);
    
    /* Queue */
    list.Enqueue(&a);
    list.Enqueue(&b);
    TEST_ASSERT(list.Dequeue() == &a);
    TEST_ASSERT(list.Dequeue() == &b);
    TEST_ASSERT(list.Dequeue() == NULL);
    
    /* Iterating */
    list.InsertTail(&a);
    list.InsertTail(&b);
    list.InsertTail(&c);
    
    // forwards 
    ple = list.GetFirst(); 
    TEST_ASSERT(!ple->IsTail() && ple == &a && (ple = ple->GetNext()) != NULL);
    TEST_ASSERT(!ple->IsTail() && ple == &b && (ple = ple->GetNext()) != NULL);
    TEST_ASSERT(!ple->IsTail() && ple == &c && (ple = ple->GetNext()) != NULL);
    TEST_ASSERT(ple->IsTail());
    
    // backwards
    ple = list.GetLast(); 
    TEST_ASSERT(!ple->IsHead() && ple == &c && (ple = ple->GetPrev()) != NULL);
    TEST_ASSERT(!ple->IsHead() && ple == &b && (ple = ple->GetPrev()) != NULL);
    TEST_ASSERT(!ple->IsHead() && ple == &a && (ple = ple->GetPrev()) != NULL);
    TEST_ASSERT(ple->IsHead());

    /* Insert after */
    list.Init();
    list.InsertTail(&a);
    list.InsertTail(&c);
    b.InsertAfter(&a);
    TEST_ASSERT(a.GetNext() == &b && b.GetNext() == &c);
    TEST_ASSERT(b.GetPrev() == &a && c.GetPrev() == &b);

    /* Insert before */
    list.Init();
    list.InsertTail(&a);
    list.InsertTail(&c);
    b.InsertBefore(&c);
    TEST_ASSERT(a.GetNext() == &b && b.GetNext() == &c);
    TEST_ASSERT(b.GetPrev() == &a && c.GetPrev() == &b);

    /* Remove */
    list.Init();
    list.InsertTail(&a);
    list.InsertTail(&b);
    list.InsertTail(&c);
    b.Remove();
    TEST_ASSERT(a.GetNext() == &c && c.GetPrev() == &a);

    /* MoveToDifferentList */
    {
        CList list1;
        CList list2;

        list1.InsertTail(&c);
        list1.InsertTail(&d);
        list2.InsertTail(&a);
        list2.InsertTail(&b);
        list1.MoveToDifferentList(&list2);
        TEST_ASSERT(list1.IsEmpty());
        TEST_ASSERT(list2.GetFirst() == &a);
        TEST_ASSERT(a.GetPrev() == list2.GetHead());
        TEST_ASSERT(a.GetNext() == &b);
        TEST_ASSERT(b.GetPrev() == &a);
        TEST_ASSERT(b.GetNext() == &c);
        TEST_ASSERT(c.GetPrev() == &b);
        TEST_ASSERT(c.GetNext() == &d);
        TEST_ASSERT(d.GetPrev() == &c);
        TEST_ASSERT(d.GetNext() == list2.GetTail());
    }
    
    /* MoveToDifferentList (empty list1) */
    {
        CList list1;
        CList list2;

        list2.InsertTail(&a);
        list2.InsertTail(&b);
        list1.MoveToDifferentList(&list2);
        
        TEST_ASSERT(list1.IsEmpty());
        TEST_ASSERT(list2.GetFirst() == &a);
        TEST_ASSERT(a.GetPrev() == list2.GetHead());
        TEST_ASSERT(a.GetNext() == &b);
        TEST_ASSERT(b.GetPrev() == &a);
        TEST_ASSERT(b.GetNext() == list2.GetTail());
    }
    
    /* MoveToDifferentList (empty list2) */
    {
        CList list1;
        CList list2;

        list1.InsertTail(&a);
        list1.InsertTail(&b);
        list1.MoveToDifferentList(&list2);
        
        TEST_ASSERT(list1.IsEmpty());
        TEST_ASSERT(list2.GetFirst() == &a);
        TEST_ASSERT(a.GetPrev() == list2.GetHead());
        TEST_ASSERT(a.GetNext() == &b);
        TEST_ASSERT(b.GetPrev() == &a);
        TEST_ASSERT(b.GetNext() == list2.GetTail());
    }
}

class CListTestData : public CDoubleLink
{
public:
    
    void Init(int iKey)
    {
        _iKey      = iKey;
        _iVerifier = CalcVerifier(iKey);
    }
    
    void Verify(int iKey) const
    {
        TEST_ASSERT(iKey == _iKey);
        TEST_ASSERT(CalcVerifier(iKey) == _iVerifier);
    }
    
    int CalcVerifier(int iKey) const 
    {
        return (iKey+1) * 1001;
    }
    
    int _iKey;
    int _iVerifier;    
};

void TestTList()
{
    printf("TestTList\n");
    
    CListTestData rgData[5];
    
    for(int i=0; i < ARRAY_SIZE(rgData); i++)
    {
        rgData[i].Init(i);
    }
    
    // 1 - Enqueue, dequeue
    {
        TList<CListTestData> q;
        
        q.Enqueue(&rgData[3]);
        TEST_ASSERT(q.Dequeue() == &rgData[3]);
        rgData[3].Verify(3);
    }
    
    // 2 - Enqueue, Enqueue, dequeue, dequeue
    {
        TList<CListTestData> q;
        CListTestData* p;
        
        q.Enqueue(&rgData[1]);
        q.Enqueue(&rgData[2]);
        
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
        
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[2]);
        p->Verify(2);
    }
    
    // 3 - Enqueue, dequeue, dequeue, enqueue, dequeue
    {
        TList<CListTestData> q;
        CListTestData* p;
        
        q.Enqueue(&rgData[4]);

        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[4]);
        p->Verify(4);
    
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == NULL);
        
        q.Enqueue(&rgData[1]);
        
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
    }
    
    // 4 - Dequeue, Enqueue, Dequeue
    {
        TList<CListTestData> q;
        CListTestData* p;
        
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == NULL);
        
        q.Enqueue(&rgData[1]);
        
        p = (CListTestData*) q.Dequeue();
        TEST_ASSERT(p == &rgData[1]);
        p->Verify(1);
    }
    
    // 5 - Enqueue x 5, Dequeue x 5
    {
        TList<CListTestData> q;
        CListTestData* p;
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            q.Enqueue(&rgData[i]);
        }
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            p = (CListTestData*) q.Dequeue();
            TEST_ASSERT(p == &rgData[i]);
            p->Verify(i);
        }
    }
    
    // Test iterator
    {
        TList<CListTestData> q;
        CListTestData* p;
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            q.Enqueue(&rgData[i]);
        }
        
        TList<CListTestData>::Iterator it;
        q.Begin(&it);
        
        for(int i=0; i < 2; i++)
        {
            int iIndex = 0;
           
            for(p = it.Get(); p != NULL; p = it.Next())
            {
                p->Verify(iIndex);
                iIndex++;
            }
            
            q.Begin(&it);
        }
    }

    // Test iterator with remove from beginning
    {
        TList<CListTestData> q;

        q.Enqueue(&rgData[1]);
        q.Enqueue(&rgData[2]);
        q.Enqueue(&rgData[3]);
        q.Enqueue(&rgData[4]);
        
        TList<CListTestData>::Iterator it;
        q.Begin(&it);
        
        it.Get()->Verify(1);
        it.Remove()->Verify(1);
        
        it.Next()->Verify(2);
        it.Remove()->Verify(2);
        
        it.Next()->Verify(3);
        it.Next()->Verify(4);
        TEST_ASSERT(it.Next() == NULL);
        
        q.Begin(&it);
        it.Get()->Verify(3);
        it.Next()->Verify(4);
        TEST_ASSERT(it.Next() == NULL);
        
    }

    // Test iterator with remove from center
    {
        TList<CListTestData> q;

        q.Enqueue(&rgData[1]);
        q.Enqueue(&rgData[2]);
        q.Enqueue(&rgData[3]);
        q.Enqueue(&rgData[4]);
        
        TList<CListTestData>::Iterator it;
        q.Begin(&it);
        
        it.Get()->Verify(1);
        
        it.Next()->Verify(2);
        it.Remove()->Verify(2);
        
        it.Next()->Verify(3);
        it.Remove()->Verify(3);
        
        it.Next()->Verify(4);
        TEST_ASSERT(it.Next() == NULL);
        
        q.Begin(&it);
        it.Get()->Verify(1);
        it.Next()->Verify(4);
        TEST_ASSERT(it.Next() == NULL);
    }

    // Test iterator with remove from end
    {
        TList<CListTestData> q;

        q.Enqueue(&rgData[1]);
        q.Enqueue(&rgData[2]);
        q.Enqueue(&rgData[3]);
        q.Enqueue(&rgData[4]);
        
        TList<CListTestData>::Iterator it;
        q.Begin(&it);
        
        it.Get()->Verify(1);
        it.Next()->Verify(2);
        
        it.Next()->Verify(3);
        it.Remove()->Verify(3);
        
        it.Next()->Verify(4);
        it.Remove()->Verify(4);
        
        TEST_ASSERT(it.Next() == NULL);
        
        q.Begin(&it);
        it.Get()->Verify(1);
        it.Next()->Verify(2);
        TEST_ASSERT(it.Next() == NULL);
    }
}

void TestTArray()
{
    printf("TestTArray\n");
    
    // Read/write access
    {
        TArray<int, 1024> array;
        array.SetSize(1024);
        
        for(int i=0; i < array.GetSize(); i++)
        {
            array.Set(i, i+1);
        }
        
        for(int i=0; i < array.GetSize(); i++)
        {
            TEST_ASSERT(array.Get(i) == i+1);
        }
    }
    
    // Add operator
    {
        TArray<int, 1024> array;
        
        for(int i=0; i < 1024; i++)
        {
            TEST_ASSERT(array.Add(i+1));
            TEST_ASSERT(array.GetSize() == i+1);
        }
        
        for(int i=0; i < array.GetSize(); i++)
        {
            TEST_ASSERT(array.Get(i) == i+1);
        }
    }
    
    // Try to grow without an allocator (expected: fail gracefully)
    {
        TArray<int, 10> array;
        int i;

        for(i=0; i < 10; i++)
        {
            TEST_ASSERT(array.Add(i+1));
            TEST_ASSERT(array.GetSize() == i+1);
        }

        for(;i < 20; i++)
        {
            TEST_ASSERT(!array.Add(i+1));
        }

        TEST_ASSERT(array.GetSize() == 10);
        
        for(i=0; i < array.GetSize(); i++)
        {
            TEST_ASSERT(array.Get(i) == i+1);
        }
    }
    
    // Dynamic Grow
    {
        TArray<int, 10> array;
        array.SetAllocator(CMemAlloc::Default());
        
        for(int i=0; i < 1024; i++)
        {
            TEST_ASSERT(array.Add(i+1));
            TEST_ASSERT(array.GetSize() == i+1);
        }
        
        for(int i=0; i < array.GetSize(); i++)
        {
            TEST_ASSERT(array.Get(i) == i+1);
        }
    }
    
    // Manual Grow
    {
        TArray<int, 1024> array;
        array.SetAllocator(CMemAlloc::Default());
        
        for(int i=0; i < 1024; i++)
        {
            TEST_ASSERT(array.Add(i+1));
            TEST_ASSERT(array.GetSize() == i+1);
        }
        
        array.SetSize(10240);
        
        for(int i=0; i < 1024; i++)
        {
            TEST_ASSERT(array.Get(i) == i+1);
        }
    }
}

class CHashClassStr
{
public:
    
    DWORD GetHash(CStr* key)
    {
        DWORD hash, i;
        
        for (hash=0, i=0; i<key->GetLength(); ++i)
        {
            hash += key->cstr()[i];
            hash += (hash << 10);
            hash ^= (hash >> 6);
        }
        hash += (hash << 3);
        hash ^= (hash >> 11);
        hash += (hash << 15);
        
        return hash;
    }
    
    bool IsEqual(CStr* keyA, CStr* keyB)
    {
        return keyA->IsEqualTo(*keyB);
    }
};

void TestCHashtable()
{
    printf("TestCHashtable\n");
    
    // No stack
    {
        THashtable<int, int> hash;
        hash.SetAllocator(CMemAlloc::Default());
        
        // Add a bunch
        for(int i=0; i < 1024; i++)
        {
            hash.Set(i * 101, i);
        }
        
        // Check if they are all there
        for(int i=0; i < 1024; i++)
        {
            int iData;
            TEST_ASSERT(hash.Get(i * 101, &iData));
            TEST_ASSERT(iData == i);
        }
        
        // key exists
        TEST_ASSERT(hash.Get(10 * 101, NULL));
        
        // key does not exist
        TEST_ASSERT(!hash.Get(1025 * 101, NULL));
    }

    // With stack
    {
        TStackHashtable<829, int, int> hash;
        hash.SetAllocator(CMemAlloc::Default());
        
        // Add a bunch
        for(int i=0; i < 1024; i++)
        {
            hash.Set(i * 101, i);
        }
        
        // Check if they are all there
        for(int i=0; i < 1024; i++)
        {
            int iData;
            TEST_ASSERT(hash.Get(i * 101, &iData));
            TEST_ASSERT(iData == i);
        }
        
        // key exists
        TEST_ASSERT(hash.Get(10 * 101, NULL));
        
        // key does not exist
        TEST_ASSERT(!hash.Get(1025 * 101, NULL));
    }
    
#if 0
    // using strings
    {
        CArenaMemAlloc arenaAlloc;
        TStackHashtable<THashtable<CStr*, UINT64, CHashClassStr>, 1024> hash;
        hash.SetAllocator(CMemAlloc::Default());

        for(int i=0; i < 1024; i++)
        {
            CStr* pStr = new(arenaAlloc) CTinyStr;
            pStr->Format("And the number is %d", i);
            hash.Set(pStr, i);
        }
        
        for(int i=0; i < 1024; i++)
        {
            CTinyStr key;
            UINT64 iData;
            
            key.Format("And the number is %d", i);
            TEST_ASSERT(hash.Get(&key, &iData));
            TEST_ASSERT(iData == i);
        }
    }
#endif    

    // Test remove
    {
        TStackHashtable<101, int, int> hash;
        hash.SetAllocator(CMemAlloc::Default());
        
        int rgData[]   = {0, 1, 101, 102, 4, 9, 100, 201, 50};
        int rgDelete[] = {100, 0, 101, 1, 102, 9, 4, 50, 201};
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
            hash.Set(rgData[i], rgData[i]);
        
        for(int i=0; i < ARRAY_SIZE(rgData); i++)
        {
            if(rgData[i] != -1)
                TEST_ASSERT(hash.Get(rgData[i], NULL));
        }
        
        TEST_ASSERT(!hash.Get(10, NULL));
        
        for(int i=0; i < ARRAY_SIZE(rgDelete); i++)
        {
            int iData;
            TEST_ASSERT(hash.Remove(rgDelete[i], &iData));
            TEST_ASSERT(iData == rgDelete[i]);
            
            for(int j=0; j < ARRAY_SIZE(rgData); j++)
            {
                int h;
                for(h=0; h <= i; h++)
                {
                    if(rgData[j] == rgDelete[h])
                        break;
                }
                
                if(h <= i)
                {
                    TEST_ASSERT(!hash.Get(rgData[j], NULL));
                }
                else
                {
                    TEST_ASSERT(hash.Get(rgData[j], &iData));
                    TEST_ASSERT(iData == rgData[j]);
                }
            }
        }
    }
    
    // Test iterator
    {
        TStackHashtable<829, int, int> hash;
        TStackHashtable<829, int, int>::Iterator it(&hash);
        hash.SetAllocator(CMemAlloc::Default());
        
        int n = 1024;
        
        // Add a bunch
        for(int i=1; i <= n; i++)
        {
            hash.Set(i * 101, i);
        }
        
        // Check if they are all there
        it.Reset();
        int iKey;
        int iData;
        int iTotal = 0;
        
        while(it.GetNext(&iKey,&iData))
        {
            TEST_ASSERT(iKey / 101 == iData);
            iTotal += iData;
        }   
        TEST_ASSERT(iTotal == ((n*n) + n)/2);
    }
}

struct TestTHeapData
{
    int   iValue;
    DWORD dwIndex;
};

class CTestTHeapHelper
{
public:
    
    static void OnHeapNewPosition(TestTHeapData* pv, DWORD nNewPos)
    {
        pv->dwIndex = nNewPos;
    }
    
    static int HeapCompare(TestTHeapData* pv1, TestTHeapData* pv2)
    {
        return pv1->iValue - pv2->iValue;
    }
};


void TestStressHeapRemoveAt()
{
    THeap<TestTHeapData*, 1, CTestTHeapHelper, CTestTHeapHelper> heap;
    heap.SetAllocator(CMemAlloc::Default());
    int nTrack = 0;
    while (true)
    {
        nTrack = nTrack + 1;
        if (nTrack == 100000)
        {
            break;
        }
        if (rand() % 10 > 5)
        {
            TestTHeapData *pData = new TestTHeapData();
            pData->iValue = rand();

            heap.Insert(pData);
        }

        if (rand() % 10 > 5)
        {
            if (heap.GetCount() !=0)
            {
                int nIndex = rand() % heap.GetCount();
                
                TestTHeapData *pRemove =  heap.Remove(nIndex);
                if (pRemove != NULL)
                {
                    delete (pRemove);
                }

                if (heap.Verify(0, 0) == false)
                {
                     TEST_ASSERT(false);
                }
            }
        }
    }

    int nCount = heap.GetCount();
    for (int i=0;i<nCount;i++)
    {
        TestTHeapData *pRemove =  heap.Remove(0);
        if (pRemove != NULL)
        {
            delete (pRemove);
        }
    }

}



void TestTHeap()
{
    printf("TestTHeap\n");
  
    TestTHeapData rgData[1000];
    
    const int prime = 703;
    const int prime2= 1307;


    for(int i=0; i<ARRAY_SIZE(rgData); i++)
    {
        rgData[i].iValue = (i * prime) % ARRAY_SIZE(rgData);
    }
    
    
    {
        THeap<TestTHeapData*, 1, CTestTHeapHelper, CTestTHeapHelper> heap;
        heap.SetAllocator(CMemAlloc::Default());
        
        // Insert data and verify order
        for(int i=0; i<ARRAY_SIZE(rgData); i++)
        {
            heap.Insert(&rgData[i]);
        }
    
        
        for(int i=0; i<ARRAY_SIZE(rgData); i++)
        {
            TEST_ASSERT(heap.Remove(0)->iValue == i);
            TEST_ASSERT(heap.GetCount() == ARRAY_SIZE(rgData)-i-1);
        }
    }
    
    {
        THeap<TestTHeapData*, 1, CTestTHeapHelper, CTestTHeapHelper> heap;
        heap.SetAllocator(CMemAlloc::Default());
    
        // Insert and remove in 'random' order
        for(int i=0; i<ARRAY_SIZE(rgData); i++)
        {
            heap.Insert(&rgData[i]);
        }
        
        for(int i=0; i<ARRAY_SIZE(rgData);i++)
        {
            int iIndex = (i * prime2) % ARRAY_SIZE(rgData);
            TEST_ASSERT(heap.Remove(rgData[iIndex].dwIndex) == &rgData[iIndex]);
        }
    }
}

class CTestServerTimer
{
public:
    
    CTestServerTimer()
    {
        _dwWhen    = 0;
        _fExecuted = false;
        _dwTimeAdjust = 0;
    }
    
    virtual void OnTimer()
    {
        TEST_ASSERT(!_fExecuted);
        
        _fExecuted = true;
        
        DWORD dwNow = GetTickCount() + _dwTimeAdjust;
        DWORD dwDiff;
        
        WrapDWORDCompare(dwNow, _dwWhen, &dwDiff);
        
        TEST_ASSERT(dwDiff <= 50);
    }

    static void TimerCallback(VOID* param)
    {
        CTestServerTimer* pCallback = (CTestServerTimer*) param;
        pCallback->OnTimer();
    }
    
    volatile DWORD _dwWhen;
    volatile bool _fExecuted;
    DWORD _dwTimeAdjust;
};

void TestCServerTimerSimple()
{
    printf("TestCServerTimerSimple\n");
    
    CServerTimer timer;
    
    TEST_ASSERT(timer.Init(false));
    
    {
        // Simple test
        // Create a bunch of appointments with non-sequential intervals.
        // Cancel one of the appointments before it happens.
        // Cancel another after it has happened.
        
        const int appts=50;
        const int interval=200;
        const int prime=67;
        
        CTestServerTimer rgTest[appts];
        SERVER_TIMER_APPOINTMENT rgAppts[appts];
        
        CTestServerTimer testCancelBefore;
        SERVER_TIMER_APPOINTMENT apptBefore;
        
        CTestServerTimer testCancelAfter;
        SERVER_TIMER_APPOINTMENT apptAfter;
        
        // Create appointments
        DWORD dwNow = GetTickCount();
        for(int i=0; i < ARRAY_SIZE(rgTest); i++)
        {
             DWORD dwInterval  = (DWORD)(((prime*i) % ARRAY_SIZE(rgTest))*interval);
             rgTest[i]._dwWhen = dwNow + dwInterval;
             TEST_ASSERT(timer.CreateAppointment(CTestServerTimer::TimerCallback, &rgTest[i], dwInterval, &rgAppts[i]));
        }
        
        // Create Cancel-Before appointment
         testCancelBefore._dwWhen = dwNow + interval * appts;
         TEST_ASSERT(timer.CreateAppointment(CTestServerTimer::TimerCallback, &testCancelBefore, 
                                             interval * appts, &apptBefore));
        
        // Create Cancel-After appointment
        testCancelAfter._dwWhen = dwNow + interval;
        TEST_ASSERT(timer.CreateAppointment(CTestServerTimer::TimerCallback, &testCancelAfter, 
                                            interval, &apptAfter));
        
        // Sleep a bit 
        Sleep(interval + 100);
        
        // Cancel the 'Cancel-Before' appointment
        timer.CancelAppointment(&apptBefore);
        
        // Wait 
        Sleep(interval * appts);
        
        // Check
        for(int i=0; i < ARRAY_SIZE(rgTest); i++)
        {
            TEST_ASSERT(rgTest[i]._fExecuted);
        }
        TEST_ASSERT(!testCancelBefore._fExecuted);
        TEST_ASSERT(testCancelAfter._fExecuted);
        
        // Cancel the 'Cancel-after' appointment. It has already been executed,
        // so it should not have any effect.
        timer.CancelAppointment(&apptAfter);
    }
    
    timer.Term();
}

void TestCServerTimerWrap()
{
    printf("TestCServerTimerWrap\n");
    
    CServerTimer timer;
    
    TEST_ASSERT(timer.Init(false));

    // Adjust timer to simulate the GetTickCount wrap around 
    timer._dwTimeAdjust = ~0 - GetTickCount() - 500;
    
    CTestServerTimer testBeforeWrap;
    SERVER_TIMER_APPOINTMENT apptBefore;
    
    CTestServerTimer testAfterWrap;
    SERVER_TIMER_APPOINTMENT apptAfter;
        
    DWORD dwNow = timer.GetNow();        
        
    // Before-wrap appointment
     testBeforeWrap._dwWhen       = dwNow + 250;
     testBeforeWrap._dwTimeAdjust = timer._dwTimeAdjust;
     TEST_ASSERT(timer.CreateAppointment(CTestServerTimer::TimerCallback, &testBeforeWrap, 250,
                                         &apptBefore));

    // After-wrap appointment
    testAfterWrap._dwWhen = dwNow + 750;
    testAfterWrap._dwTimeAdjust = timer._dwTimeAdjust;
    TEST_ASSERT(timer.CreateAppointment(CTestServerTimer::TimerCallback, &testAfterWrap, 750,
                                        &apptAfter));
    
    TEST_ASSERT(testBeforeWrap._dwWhen > testAfterWrap._dwWhen);
    
    // Wait
    Sleep(1000);
    
    // Check
    TEST_ASSERT(testBeforeWrap._fExecuted);
    TEST_ASSERT(testAfterWrap._fExecuted);
    
    timer.Term();
}

void TestCSystem()
{
    // GetModuleName
    {
        CSmallStr moduleFileName;
        TEST_ASSERT(CSystem::GetModuleName(NULL, &moduleFileName));
        printf("  Module-Filename: \n\n%s\n\n", moduleFileName.cstr());
    }

    // ParseFileName
    {
        CSmallStr part;
        LPCSTR pFullFileName = "c:\\programs\\accessories\\notepad.exe";

        TEST_ASSERT(CSystem::ParseFileName(pFullFileName, CSystem::PARSE_NAME_WITHOUT_EXTENSION, &part));
        TEST_ASSERT(part.IsEqualTo("notepad"));
        
        TEST_ASSERT(CSystem::ParseFileName(pFullFileName, CSystem::PARSE_NAME_WITH_EXTENSION, &part));
        TEST_ASSERT(part.IsEqualTo("notepad.exe"));

        TEST_ASSERT(CSystem::ParseFileName(pFullFileName, CSystem::PARSE_DRIVE, &part));
        TEST_ASSERT(part.IsEqualTo("c:"));

        TEST_ASSERT(CSystem::ParseFileName(pFullFileName, CSystem::PARSE_PATH, &part));
        TEST_ASSERT(part.IsEqualTo("\\programs\\accessories\\"));
        
        TEST_ASSERT(CSystem::ParseFileName(pFullFileName, CSystem::PARSE_DRIVE_AND_PATH, &part));
        TEST_ASSERT(part.IsEqualTo("c:\\programs\\accessories\\"));
    }

    // ReadRegistryString
    {
        TLocalStr<1> str;
        str.SetAllocator(CMemAlloc::Default());

        TEST_ASSERT(CSystem::ReadRegistryString(
                HKEY_LOCAL_MACHINE, 
                "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\\",
                "Path",
                &str));

        printf("Path-Environment-Variable: \n\n%s\n\n", str.cstr());
    }
}

struct TEST_ENUMERATE_FILES_CONTEXT
{
    CConstStr* pModuleName;
    BOOL fFound;
};

static bool __stdcall TestEnumerateFilesCallback(void* userData, LPCSTR path, LPCSTR filename)
{
    TEST_ENUMERATE_FILES_CONTEXT* pContext = (TEST_ENUMERATE_FILES_CONTEXT*) userData;

    if(pContext->pModuleName->IsCaseInsensitiveEqualTo(
            CSmallStr().Format("%s%s", path, filename)))
    {
        pContext->fFound = TRUE;
    }

    return true;
}

void TestCSystem_EnumerateFiles()
{
    printf("TestCSystem_EnumerateFiles\n");

    TLocalStr<MAX_PATH> moduleName;
    TEST_ASSERT(CSystem::GetModuleName(NULL, &moduleName));

    TLocalStr<MAX_PATH> pattern;
    TEST_ASSERT(CSystem::ParseFileName(moduleName.cstr(), CSystem::PARSE_DRIVE_AND_PATH, &pattern));

    pattern.CopyFrom("*.*");

    TEST_ENUMERATE_FILES_CONTEXT context;
    context.pModuleName = &moduleName;
    context.fFound = FALSE;

    TEST_ASSERT(CSystem::EnumerateFiles(pattern.cstr(), TestEnumerateFilesCallback, &context));
    TEST_ASSERT(context.fFound);

    TEST_ASSERT(!CSystem::EnumerateFiles("c:\\asjdfkasjd", TestEnumerateFilesCallback, &context));
    TEST_ASSERT(!CSystem::EnumerateFiles("c:", TestEnumerateFilesCallback, &context));
    TEST_ASSERT(!CSystem::EnumerateFiles("", TestEnumerateFilesCallback, &context));
}

class CWorkItem 
{
    USE_IMEMALLOC(CWorkItem);

public:
    
    void Init(DWORD id, DWORD dwSpin, volatile LONG* plCounter)
    {
        _id         = id;
        _dwSpin     = dwSpin;
        _plCounter  = plCounter;
    }

    static void CALLBACK WorkItemFunction(void* param)
    {
        CWorkItem* pThis = (CWorkItem*) param;
        pThis->Execute();
    }

    void Execute()
    {
        double v = 0.0;

        for(DWORD j=0; j < 10000; j++)
        {
            for(DWORD i=0; i < _dwSpin; i++)
            {
                v += pow((double)(i % 1000000), (double) 630);
                v -= sqrt(v);
            }         
        }
        
        _v = v;

        ::InterlockedIncrement(_plCounter);
    }

    DWORD           _id;
    DWORD           _dwSpin;
    volatile double _v;
    volatile LONG*  _plCounter;
};

void CALLBACK NullWorkItem(void* param)
{
    // no-op
}

void TestCThreadPoolWithParameters(
    DWORD cThreads,
    DWORD cWorkItems,
    DWORD dwMinSpin,
    DWORD dwMaxSpin,
    BOOL  fBatch
)
{
    CThreadPool threadPool;
    volatile LONG lCounter = 0;
    
    TEST_ASSERT(threadPool.Init(cThreads, fBatch));

    // warm-up. guarantee that all memory is pre-allocated and that the results of the 
    // test will not be tainted by the initial allocation cost

    for(DWORD i=0; i < cWorkItems; i++)
    {
        TEST_ASSERT(threadPool.AddWorkItem(NullWorkItem, NULL));
    }

    while(threadPool.GetCount() > 0)
    {
        ::Sleep(100);
    }
    
    DWORD dwTickStart = ::GetTickCount();

    CWorkItem* pWorkItem = IMEMALLOC_NEW(CMemAlloc::Default()) CWorkItem[cWorkItems];
    TEST_ASSERT(pWorkItem);

    for(DWORD i=0; i < cWorkItems; i++)
    {
        DWORD dwSpin = dwMinSpin + ((i * 8819) % (dwMaxSpin - dwMinSpin));

        pWorkItem[i].Init(i, dwSpin, &lCounter);

        TEST_ASSERT(pWorkItem);
        TEST_ASSERT(threadPool.AddWorkItem(CWorkItem::WorkItemFunction, pWorkItem));

        if(i % 1000 == 0)
        {
            ::Sleep(100);
        }
    }

    threadPool.Term();
    TEST_ASSERT(lCounter == (LONG)cWorkItems);
    DWORD dwElapsed = (::GetTickCount() - dwTickStart);

    IMEMALLOC_DELETE[] pWorkItem;
    
    printf("  %10u %10u %10u %10u %10u | %10u\n",
           cThreads,
           cWorkItems,
           dwMinSpin,
           dwMaxSpin,
           fBatch,
           dwElapsed);
}


void TestCThreadPool()
{
    printf("TestCThreadPool:\n\n");

    printf("  %10s %10s %10s %10s %10s | %10s\n",
           "threads",
           "items",
           "min-spin",
           "max-spin",
           "batch",
           "elapsed");

    DWORD dwBigLoad     = 5000000;
    DWORD dwMediumLoad  = 2500000;
    DWORD dwSmallLoad   = 100000;


    TestCThreadPoolWithParameters(1, 50000, 0, dwBigLoad, true);
    TestCThreadPoolWithParameters(4, 50000, 0, dwBigLoad, true);
    TestCThreadPoolWithParameters(0, 50000, 0, dwBigLoad, true);
    TestCThreadPoolWithParameters(1, 50000, 0, dwBigLoad, false);
    TestCThreadPoolWithParameters(4, 50000, 0, dwBigLoad, false);
    TestCThreadPoolWithParameters(0, 50000, 0, dwBigLoad, false);
    
    TestCThreadPoolWithParameters(1, 50000, 0, dwMediumLoad, true);
    TestCThreadPoolWithParameters(4, 50000, 0, dwMediumLoad, true);
    TestCThreadPoolWithParameters(0, 50000, 0, dwMediumLoad, true);
    TestCThreadPoolWithParameters(1, 50000, 0, dwMediumLoad, false);
    TestCThreadPoolWithParameters(4, 50000, 0, dwMediumLoad, false);
    TestCThreadPoolWithParameters(0, 50000, 0, dwMediumLoad, false);
    
    TestCThreadPoolWithParameters(1, 500000, 0, dwSmallLoad, true);
    TestCThreadPoolWithParameters(4, 500000, 0, dwSmallLoad, true);
    TestCThreadPoolWithParameters(0, 500000, 0, dwSmallLoad, true);
    TestCThreadPoolWithParameters(1, 500000, 0, dwSmallLoad, false);
    TestCThreadPoolWithParameters(4, 500000, 0, dwSmallLoad, false);
    TestCThreadPoolWithParameters(0, 500000, 0, dwSmallLoad, false);

    printf("\n");
}

struct IoThreadPoolData 
{
    OVERLAPPED o;
    DWORD numberOfBytes;
    ULONG_PTR completionKey;
    BOOL ok;
};

static void CALLBACK IoThreadPoolCallback(
    DWORD error,
    DWORD numberOfBytes, 
    OVERLAPPED* pOverlapped
    )
{
    TEST_ASSERT(error == 0);
    TEST_ASSERT(pOverlapped);
    
    IoThreadPoolData* pData = (IoThreadPoolData*) pOverlapped;

    TEST_ASSERT(numberOfBytes = pData->numberOfBytes);

    pData->ok = TRUE;
}

void TestCIoThreadPool()
{
    printf("TestCIoThreadPool");

    CIoThreadPool tp;

    TEST_ASSERT(tp.Init(10, NULL));
    
    IoThreadPoolData aData[100];

    for(int i=0; i < ARRAY_SIZE(aData); i++)
    {
        ZeroMemory(&aData[i].o, sizeof(OVERLAPPED));
        aData[i].numberOfBytes = 1000 + i;
        aData[i].ok = FALSE;

        TEST_ASSERT(tp.Post(
                aData[i].numberOfBytes,
                IoThreadPoolCallback,
                &aData[i].o));
    }

    tp.Term();

    for(int i=0; i < ARRAY_SIZE(aData); i++)
    {
        TEST_ASSERT(aData[i].ok == TRUE);
    }
}

void TestCMemoryStream()
{
    printf("TestCMemoryStream\n");
    BYTE buffer[100];

    // positive writes and reads
    {
        CMemoryStream ms(buffer, sizeof(buffer), 0);
        TEST_ASSERT(ms.GetPos() == 0);
        TEST_ASSERT(ms.WriteByte(0xaa));
        TEST_ASSERT(ms.WriteUInt16(0xdead));
        TEST_ASSERT(ms.WriteUInt32(0xcafebabe));
        TEST_ASSERT(ms.WriteUInt64(0x1020304050607080));
        TEST_ASSERT(ms.GetPos() == 15);
        TEST_ASSERT(ms.GetLength() == 15);
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_BEGINNING, 0));
        TEST_ASSERT(ms.GetPos() == 0);

        BYTE    bval;
        UINT16  ui16val;
        UINT32  ui32val;
        UINT64  ui64val;
        
        TEST_ASSERT(ms.ReadValue(&bval) && bval == 0xaa);
        TEST_ASSERT(ms.ReadValue(&ui16val) && ui16val == 0xdead);
        TEST_ASSERT(ms.ReadValue(&ui32val) && ui32val == 0xcafebabe);
        TEST_ASSERT(ms.ReadValue(&ui64val) && ui64val == 0x1020304050607080);
        TEST_ASSERT(!ms.ReadValue(&bval));
        TEST_ASSERT(ms.GetPos() == 15);
    }

    // read more bytes than available
    {
        CMemoryStream ms(buffer, sizeof(buffer), 0);
        TEST_ASSERT(ms.WriteByte(0xaa));
        TEST_ASSERT(ms.WriteUInt32(0xcafebabe));
        
        BYTE read[8];
        UINT32 cbread = 0;

        memset(read, 0x99, sizeof(read));

        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_BEGINNING, 1));
        TEST_ASSERT(ms.Read(read, sizeof(read), &cbread) && cbread == 4);
        TEST_ASSERT(ms.GetPos() == 5);
        TEST_ASSERT(((UNALIGNED UINT32*)read)[0] == 0xcafebabe);
        TEST_ASSERT(((UNALIGNED UINT32*)read)[1] == 0x99999999);
    }

    // write more bytes than capacity
    {
        C_ASSERT(sizeof(buffer) > 10);
        memset(buffer, 0x99, sizeof(buffer));
        CMemoryStream ms(buffer, 10, 0);
        TEST_ASSERT(ms.WriteUInt64(0x1020304050607080));
        TEST_ASSERT(!ms.WriteUInt32(0xcafebabe));
        TEST_ASSERT(ms.GetPos() == 8);
        TEST_ASSERT(ms.GetLength() == 8);
        TEST_ASSERT(ms.WriteUInt16(0xdead));
        TEST_ASSERT(ms.GetPos() == 10);
        TEST_ASSERT(ms.GetLength() == 10);
        TEST_ASSERT(!ms.WriteByte(0xaa));
        TEST_ASSERT(ms.GetPos() == 10);
        TEST_ASSERT(ms.GetLength() == 10);
        TEST_ASSERT(buffer[10] == 0x99);
    }

    // seek test cases
    {
        BYTE seekbuffer[] = { 0, 1, 2, 3, 4 };
        CMemoryStream ms(seekbuffer, sizeof(seekbuffer), sizeof(seekbuffer));
        
        BYTE bval;
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_BEGINNING, 0));
        TEST_ASSERT(ms.ReadValue(&bval) && bval == 0);
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_BEGINNING, 1));
        TEST_ASSERT(ms.ReadValue(&bval) && bval == 1);
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_BEGINNING, 4));
        TEST_ASSERT(ms.ReadValue(&bval) && bval == 4);
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_BEGINNING, 5));
        TEST_ASSERT(!ms.ReadValue(&bval));
        TEST_ASSERT(!ms.Seek(CStream::SEEK_FROM_BEGINNING, 6));
        
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_BEGINNING, 0));
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_CURRENT, 0));
        TEST_ASSERT(ms.ReadValue(&bval) && bval == 0);
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_CURRENT, 1));
        TEST_ASSERT(ms.ReadValue(&bval) && bval == 2);
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_CURRENT, 2));
        TEST_ASSERT(!ms.Seek(CStream::SEEK_FROM_CURRENT, 1));

        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_END, 0));
        TEST_ASSERT(!ms.ReadValue(&bval));
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_END, -1));
        TEST_ASSERT(ms.ReadValue(&bval) && bval == 4);
        TEST_ASSERT(ms.Seek(CStream::SEEK_FROM_END, -5));
        TEST_ASSERT(ms.ReadValue(&bval) && bval == 0);
        TEST_ASSERT(!ms.Seek(CStream::SEEK_FROM_END, -6));
    }
}

void TestCBase64()
{
    printf("TestCBase64\n");

    BYTE original[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    for(int i=0; i <= sizeof(original); i++)
    {
        CConstBuffer o(original, i);
        TLocalStr<40> e;
        TEST_ASSERT(CBase64::Encode(&o, &e));
        printf("  Encoded: %s\n", e.cstr());
        TLocalBuffer<15> n;
        TEST_ASSERT(CBase64::Decode(&e, &n));
        TEST_ASSERT(o.GetSize() == n.GetSize());
        TEST_ASSERT(memcmp(o.GetConstPtr(), n.GetConstPtr(), n.GetSize()) == 0);
    }
}

class CTestArenaAlloc : public CArenaAlloc
{
public:

    UINT32 GetBufferCount()
    {
        UINT32 count = 0;
        BUFFER* pAllocBuffer = _pBufferList;

        while(pAllocBuffer)
        {
            count++;
            pAllocBuffer = pAllocBuffer->pNext;
        }

        return count;
    }

    BYTE* GetBuffer()
    {
        return _pBuffer;
    }

    UINT32 GetBufferSize() const
    {
        return _bufferSize;
    }

    UINT32 GetBufferUsed() const
    {
        return _bufferUsed;
    }
};

void TestCArenaAlloc()
{
    printf("TestCArenaAlloc\n");

    {
        BYTE buffer[sizeof(void*) * 5 + (sizeof(void*) / 2)];
        CTestArenaAlloc alloc;
        alloc.Attach(buffer, sizeof(buffer), 0, 0);
        TEST_ASSERT(alloc.Alloc(1) == buffer);
        TEST_ASSERT(alloc.Alloc(sizeof(void*)) == buffer + sizeof(void*));
        TEST_ASSERT(alloc.Alloc(sizeof(void*)+1) == buffer + sizeof(void*)*2);
        TEST_ASSERT(alloc.Alloc(1) == buffer + sizeof(void*)*4);
        TEST_ASSERT(alloc.Alloc(1) == NULL);
    }

    {
        BYTE buffer[sizeof(void*) * 5 + (sizeof(void*) / 2)];
        CTestArenaAlloc alloc;
        alloc.Attach(buffer, sizeof(buffer), CMemAlloc::Default(), sizeof(buffer));
        TEST_ASSERT(alloc.Alloc(1) == buffer);
        TEST_ASSERT(alloc.Alloc(sizeof(void*)) == buffer + sizeof(void*));
        TEST_ASSERT(alloc.Alloc(sizeof(void*)+1) == buffer + sizeof(void*)*2);
        TEST_ASSERT(alloc.Alloc(1) == buffer + sizeof(void*)*4);
        TEST_ASSERT(alloc.Alloc(1) == alloc.GetBuffer());
        TEST_ASSERT(alloc.GetBuffer() != buffer);
        TEST_ASSERT(alloc.GetBufferCount() == 1);
        TEST_ASSERT(alloc.Alloc(sizeof(void*)) == alloc.GetBuffer() + sizeof(void*));
        TEST_ASSERT(alloc.Alloc(sizeof(void*)+1) == alloc.GetBuffer() + sizeof(void*)*2);
        TEST_ASSERT(alloc.Alloc(1) == alloc.GetBuffer() + sizeof(void*)*4);
        TEST_ASSERT(alloc.Alloc(1) == alloc.GetBuffer());
        TEST_ASSERT(alloc.GetBuffer() != buffer);
        TEST_ASSERT(alloc.GetBufferCount() == 2);
        TEST_ASSERT(alloc.Alloc(sizeof(buffer) + 100) == alloc.GetBuffer());
        TEST_ASSERT(alloc.GetBufferCount() == 3);
        TEST_ASSERT(alloc.GetBufferSize() >= sizeof(buffer) + 100);
        TEST_ASSERT(alloc.GetBufferUsed() >= sizeof(buffer) + 100);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\leakdetector.h ===
#pragma once
#ifndef LEAKDETECTOR_H
#define LEAKDETECTOR_H

#define DBG_MEM_LEAK        0

#endif // LEAKDETECTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\locks.cpp ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       locks.cpp

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#include "dstructp.h"


namespace xlocks 
{

#define LOCKS_SWITCH_TO_THREAD

static DWORD g_cProcessors = 0;

class CInitializeLocks
{
public:

	CInitializeLocks()
	{
		g_cProcessors = NumProcessors();
	}
};

static CInitializeLocks g_InitializeLocks;


#define LOCK_DEFAULT_SPIN_DATA(CLASS)                       \
  WORD   CLASS::sm_wDefaultSpinCount  = LOCK_DEFAULT_SPINS; \
  double CLASS::sm_dblDfltSpinAdjFctr = 0.5


#ifdef LOCK_INSTRUMENTATION

# define LOCK_STATISTICS_DATA(CLASS)            \
LONG        CLASS::sm_cTotalLocks       = 0;    \
LONG        CLASS::sm_cContendedLocks   = 0;    \
LONG        CLASS::sm_nSleeps           = 0;    \
LONGLONG    CLASS::sm_cTotalSpins       = 0;    \
LONG        CLASS::sm_nReadLocks        = 0;    \
LONG        CLASS::sm_nWriteLocks       = 0


# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)            \
CLockStatistics                 CLASS::Statistics() const       \
{return CLockStatistics();}                                     \
CGlobalLockStatistics           CLASS::GlobalStatistics()       \
{return CGlobalLockStatistics();}                               \
void                            CLASS::ResetGlobalStatistics()  \
{}


# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)             \
                                                                \
/* Per-lock statistics */                                       \
CLockStatistics                                                 \
CLASS::Statistics() const                                       \
{                                                               \
    CLockStatistics ls;                                         \
                                                                \
    ls.m_nContentions     = m_nContentions;                     \
    ls.m_nSleeps          = m_nSleeps;                          \
    ls.m_nContentionSpins = m_nContentionSpins;                 \
    if (m_nContentions > 0)                                     \
        ls.m_nAverageSpins = m_nContentionSpins / m_nContentions;\
    else                                                        \
        ls.m_nAverageSpins = 0;                                 \
    ls.m_nReadLocks       = m_nReadLocks;                       \
    ls.m_nWriteLocks      = m_nWriteLocks;                      \
    _tcscpy(ls.m_tszName, m_tszName);                           \
                                                                \
    return ls;                                                  \
}                                                               \
                                                                \
                                                                \
/* Global statistics for CLASS */                               \
CGlobalLockStatistics                                           \
CLASS::GlobalStatistics()                                       \
{                                                               \
    CGlobalLockStatistics gls;                                  \
                                                                \
    gls.m_cTotalLocks      = sm_cTotalLocks;                    \
    gls.m_cContendedLocks  = sm_cContendedLocks;                \
    gls.m_nSleeps          = sm_nSleeps;                        \
    gls.m_cTotalSpins      = sm_cTotalSpins;                    \
    if (sm_cContendedLocks > 0)                                 \
        gls.m_nAverageSpins = static_cast<LONG>(sm_cTotalSpins / \
                                                sm_cContendedLocks);\
    else                                                        \
        gls.m_nAverageSpins = 0;                                \
    gls.m_nReadLocks       = sm_nReadLocks;                     \
    gls.m_nWriteLocks      = sm_nWriteLocks;                    \
                                                                \
    return gls;                                                 \
}                                                               \
                                                                \
                                                                \
/* Reset global statistics for CLASS */                         \
void                                                            \
CLASS::ResetGlobalStatistics()                                  \
{                                                               \
    sm_cTotalLocks       = 0;                                   \
    sm_cContendedLocks   = 0;                                   \
    sm_nSleeps           = 0;                                   \
    sm_cTotalSpins       = 0;                                   \
    sm_nReadLocks        = 0;                                   \
    sm_nWriteLocks       = 0;                                   \
}


// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.
# define LOCK_INSTRUMENTATION_PROLOG()  \
    ++sm_cContendedLocks;               \
    LONG cTotalSpins = 0;               \
    WORD cSleeps = 0

// Don't need InterlockedIncrement or InterlockedExchangeAdd for 
// member variables, as the lock is now locked by this thread.
# define LOCK_INSTRUMENTATION_EPILOG()  \
    ++m_nContentions;                   \
    m_nSleeps += cSleeps;               \
    m_nContentionSpins += cTotalSpins;  \
    sm_nSleeps += cSleeps;              \
    sm_cTotalSpins += cTotalSpins

#else // !LOCK_INSTRUMENTATION
# define LOCK_STATISTICS_DATA(CLASS)
# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)
# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)
# define LOCK_INSTRUMENTATION_PROLOG()
# define LOCK_INSTRUMENTATION_EPILOG()
#endif // !LOCK_INSTRUMENTATION



//------------------------------------------------------------------------
// Function: RandomBackoffFactor
// Synopsis: A fudge factor to help avoid synchronization problems
//------------------------------------------------------------------------

double
RandomBackoffFactor()
{
    static const double s_aFactors[] = {
        1.020, 0.965,  0.890, 1.065,
        1.025, 1.115,  0.940, 0.995,
        1.050, 1.080,  0.915, 0.980,
        1.010,
    };
    const int nFactors = sizeof(s_aFactors) / sizeof(s_aFactors[0]);

    // Alternatives for nRand include a static counter
    // or the low DWORD of QueryPerformanceCounter().
    DWORD nRand = ::GetCurrentThreadId();

    return s_aFactors[nRand % nFactors];
}


//------------------------------------------------------------------------
// Function: SwitchOrSleep
// Synopsis: If possible, yields the thread with SwitchToThread. If that
//           doesn't work, calls Sleep.
//------------------------------------------------------------------------

void
SwitchOrSleep(
    DWORD dwSleepMSec)
{
#ifdef LOCKS_SWITCH_TO_THREAD
    if (!SwitchToThread())
#endif
        Sleep(dwSleepMSec);
}
    



// CSmallSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSmallSpinLock);

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION

LOCK_STATISTICS_DATA(CSmallSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSmallSpinLock);

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION


//------------------------------------------------------------------------
// Function: CSmallSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSmallSpinLock::_LockSpin()
{
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_PROLOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
    
    DWORD dwSleepTime = 0;
    LONG  cBaseSpins  = sm_wDefaultSpinCount;
    LONG  cBaseSpins2 = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    // This lock cannot be acquired recursively. Attempting to do so will
    // deadlock this thread forever. Use CSpinLock instead if you need that
    // kind of lock.
    if (m_lTid == _CurrentThreadId())
    {
        assert(
           !"CSmallSpinLock: Illegally attempted to acquire lock recursively");
        DebugBreak();
    }

    while (!_TryLock())
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  cBaseSpins != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins2;
        
            // Check no more than cBaseSpins2 times then yield.
            // It is important not to use the InterlockedExchange in the
            // inner loop in order to minimize system memory bus traffic.
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
                    cTotalSpins += cBaseSpins2;
                    ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins2 = (int) (cBaseSpins2 * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins2 <= LOCK_MAXIMUM_SPINS
                    cBaseSpins2 = min(LOCK_MAXIMUM_SPINS, cBaseSpins2);
                    cBaseSpins2 = max(cBaseSpins2, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins2;

                    // Using Sleep(0) leads to the possibility of priority
                    // inversion.  Sleep(0) only yields the processor if
                    // there's another thread of the same priority that's
                    // ready to run.  If a high-priority thread is trying to
                    // acquire the lock, which is held by a low-priority
                    // thread, then the low-priority thread may never get
                    // scheduled and hence never free the lock.  NT attempts
                    // to avoid priority inversions by temporarily boosting
                    // the priority of low-priority runnable threads, but the
                    // problem can still occur if there's a medium-priority
                    // thread that's always runnable.  If Sleep(1) is used,
                    // then the thread unconditionally yields the CPU.  We
                    // only do this for the second and subsequent even
                    // iterations, since a millisecond is a long time to wait
                    // if the thread can be scheduled in again sooner
                    // (~100,000 instructions).
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to do the
            // InterlockedExchange to atomically grab it for ourselves.
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            cTotalSpins += cBaseSpins2 - cSpins;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
        }

        // On a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
            SwitchOrSleep(dwSleepTime);

            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

    }

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_EPILOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
}



// CSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSpinLock);
LOCK_STATISTICS_DATA(CSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSpinLock);


//------------------------------------------------------------------------
// Function: CSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSpinLock::_LockSpin()
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime   = 0;
    bool  fAcquiredLock = false;
    LONG  cBaseSpins    = sm_wDefaultSpinCount;

    cBaseSpins = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    while (!fAcquiredLock)
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  sm_wDefaultSpinCount != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins;
        
            // Check no more than cBaseSpins times then yield
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_INSTRUMENTATION
                    cTotalSpins += cBaseSpins;
                    ++cSleeps;
#endif // LOCK_INSTRUMENTATION

                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
                    cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
                    cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins;
            
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to atomically
            // update m_cOwners and m_nThreadId to grab it for ourselves.
#ifdef LOCK_INSTRUMENTATION
            cTotalSpins += cBaseSpins - cSpins;
#endif // LOCK_INSTRUMENTATION
        }

        // on a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_INSTRUMENTATION
            SwitchOrSleep(dwSleepTime);
            
            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

        // Is the lock unowned?
        if (_TryLock())
            fAcquiredLock = true; // got the lock
    }

    assert((m_lTid & OWNER_MASK) > 0
               &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CCritSec static member variables

LOCK_DEFAULT_SPIN_DATA(CCritSec);
LOCK_STATISTICS_DATA(CCritSec);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CCritSec);

bool
CCritSec::TryWriteLock()
{
    return TryEnterCriticalSection(&m_cs) ? true : false;
}

//------------------------------------------------------------------------
// Function: CCritSec::SetSpinCount
// Synopsis: This function is used to call the appropriate underlying
//           functions to set the spin count for the supplied critical
//           section. The original function is supposed to be exported out
//           of kernel32.dll from NT 4.0 SP3. If the func is not available
//           from the dll, we will use a fake function.
//
// Arguments:
//   lpCriticalSection
//      Points to the critical section object.
//
//   dwSpinCount
//      Supplies the spin count for the critical section object. For UP
//      systems, the spin count is ignored and the critical section spin
//      count is set to 0. For MP systems, if contention occurs, instead of
//      waiting on a semaphore associated with the critical section, the
//      calling thread will spin for spin count iterations before doing the
//      hard wait. If the critical section becomes free during the spin, a
//      wait is avoided.
//
// Returns:
//      The previous spin count for the critical section is returned.
//------------------------------------------------------------------------

DWORD
CCritSec::SetSpinCount(
    LPCRITICAL_SECTION pcs,
    DWORD dwSpinCount)
{
    return SetCriticalSectionSpinCount(pcs, dwSpinCount);
}


// CFakeLock static member variables

LOCK_DEFAULT_SPIN_DATA(CFakeLock);
LOCK_STATISTICS_DATA(CFakeLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CFakeLock);



// CReaderWriterLock static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock);
LOCK_STATISTICS_DATA(CReaderWriterLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock);


void
CReaderWriterLock::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock()  :  _TryReadLock();
            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    assert(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock2 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock2);
LOCK_STATISTICS_DATA(CReaderWriterLock2);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock2);


void
CReaderWriterLock2::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(true);
}


void
CReaderWriterLock2::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    assert(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock3 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock3);
LOCK_STATISTICS_DATA(CReaderWriterLock3);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock3);


void
CReaderWriterLock3::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(SPIN_WRITE);
}


void
CReaderWriterLock3::_LockSpin(
    SPIN_TYPE st)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock;

            if (st == SPIN_WRITE)
                fLock = _TryWriteLock(0);
            else if (st == SPIN_READ)
                fLock = _TryReadLock();
            else
            {
                assert(st == SPIN_READ_RECURSIVE);
                fLock = _TryReadLockRecursive();
            }

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    assert((st == SPIN_WRITE)  ?  IsWriteLocked()  :  IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}


} // namespace xlocks
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\dstructp.h ===
#pragma once


#include <stdio.h>
#include <string.h>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT

#include "xlocks.h"
#include "wmsstd.h"
#include "mpcellpool.h"
#include "vavltable.h"
#include <assert.h>
#include "vbckhash.h"
#include "vcelpool.h"
#include "vfifolif.h"
#include "vleftist.h"
#include "vmAllocPool.h"
#include "vordlist.h"
#include "vptrarr.h"
#include "malloc.h"
#include "vptrlist.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\cellleak.h ===
#pragma once
#ifndef CellLeak_h_
#define CellLeak_h_

#if DBG

//////////////////////////////////////////////////////////////////////////////
// One of these objects is allocated for each cell pool.
//////////////////////////////////////////////////////////////////////////////
class CCellPoolTracker
{
public:
    virtual void Initialize( DWORD cbCellSize, int poolType ) = 0;
    virtual void Shutdown() = 0;

    virtual void SignPoolImpl( const char *pFileName, int lineNum ) = 0;
    virtual void SetPoolComment( const char *pComment ) = 0;

    virtual void CountAlloc() = 0;
    virtual void CountAlloc( const char *pFileName, int lineNum ) = 0;

    virtual void CountFree() = 0;

    virtual void RecordTotalPoolSize( DWORD dwSize ) = 0;
};
typedef CCellPoolTracker * (* TAllocCelltrackerProc)();




//////////////////////////////////////////////////////////////////////////////
// One of these objects is allocated for the entire program.
//////////////////////////////////////////////////////////////////////////////
class CMemoryTracker
{
public:
    virtual void CountNew( void *ptr, int numBytes, const char *pFileName, int lineNum ) = 0;
    virtual void CountFree( void *ptr, int numBytes, const char *pFileName, int lineNum ) = 0;
};









//////////////////////////////////////////////////////////////////////////////
// One of these objects is allocated for DLL and exe. This allows all DLL's
// to access a single instance of the tracking procedures.
//////////////////////////////////////////////////////////////////////////////
class CDebugTrackerProcRegistry
{
public:
    CDebugTrackerProcRegistry();
    ~CDebugTrackerProcRegistry();

    HRESULT RegisterTrackingProcs( 
                    TAllocCelltrackerProc pTrackerAllocator,
                    CMemoryTracker **ppMemoryTracker
                    );

    CCellPoolTracker *AllocCellTracker();
    void TrackMemAlloc( void* ptr, int numBytes, const char *pFileName, int lineNum ); 
    void TrackMemFree( void* ptr, int numBytes, const char *pFileName, int lineNum );

private:
    TAllocCelltrackerProc   m_pCellTrackerAllocator;
    CMemoryTracker          **m_ppMemoryTracker;
    HANDLE                  m_hMemoryMapFile;

    BOOL                    m_fLoadedSharedMemory;

    // This object is stored in a memory mapped file that is shared 
    // by all DLL's.
    class CSharedMemoryState
    {
    public:
        TAllocCelltrackerProc   m_pCellTrackerAllocator;
        CMemoryTracker          **m_ppMemoryTracker;
    };


    HRESULT CreateSharedMemory(  
                        LPHANDLE phMmapFile,
                        DWORD dwMmapSize,
                        LPBYTE *ppMmapStart,
                        LPWSTR pszMmapFile 
                        );

    HRESULT OpenSharedMemory(  
                        LPHANDLE phMmapFile,
                        DWORD dwMmapSize,
                        LPBYTE *ppMmapStart,
                        LPWSTR pszMmapFile 
                        );
}; // CDebugTrackerProcRegistry




// Globals
extern CDebugTrackerProcRegistry g_TrackerProcRegistry;

#define SignPool() SignPoolImpl( __FILE__, __LINE__ )


#define AssertValidRefCount( x ) do \
{ \
    int oldRef = x->AddRef(); \
    x->Release(); \
    NSASSERT( oldRef > 1 ); \
} while ( FALSE )










#else // #if !DBG

#define AssertValidRefCount( x ) 

#endif // #if DBG

#endif // CellLeak_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\mpcellpool.cpp ===
#include "dstructp.h"


#ifndef MAKESIG
#define MAKESIG( ch0, ch1, ch2, ch3 )                           \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#if DBG
#define MPCELLPOOLASSERT( exp )   if( !( exp ) ) { DebugBreak(); }
#define INCCOUNTER(x) x++
#else
#define MPCELLPOOLASSERT( exp )
#define INCCOUNTER(x)
#endif

DWORD g_sigFreeMPCell = MAKESIG( 'f','r','e','e' );
DWORD g_sigUsedMPCell = MAKESIG( 'u','s','e','d' );

#define SIG_FREE_MPCELL               g_sigFreeMPCell
#define SIG_USED_MPCELL               g_sigUsedMPCell

#define MP_ALLOC_PATTERN              0x99    // only in DBG builds
#define MP_DELETE_PATTERN             0xBB    // only in DBG builds

#if DBG
extern BOOL g_fUseNewDelete;
#endif


BOOL      CMPCellPool::s_fInitStaticVars = FALSE;
BOOL      CMPCellPool::s_fUseLockFreeStack = FALSE;
DWORD     CMPCellPool::s_dwParallelism = 1;

///////////////////////////////////////////////////////////////////////////////////
// The following section of code must be changed to support AMD & IA64
// The problem is that to use a lock free stack we need an interlock op which
// is the size of a ptr + the size of a DWORD. 
// With the increase size of ptrs in IA64 (32->64), IA64 won't support it
// so, g_fUseLockFreeStack needs to be false in these cases and I imagine
// we will need to do something wrt not including InterlockedCompareExchange64
// asm code in AMD builds
///////////////////////////////////////////////////////////////////////////////////
#ifdef _X86_
#pragma warning (disable: 4035)
__forceinline 
__int64 InterlockedCompareExchange64( volatile __int64* pqwDestination, 
                                      volatile __int64 qwExchange, 
                                      volatile __int64 qwComperand )
{
    __asm
    {
        mov esi, pqwDestination
        mov eax, DWORD PTR qwComperand[0]
        mov edx, DWORD PTR qwComperand[4]
        mov ebx, DWORD PTR qwExchange[0]
        mov ecx, DWORD PTR qwExchange[4]

        // lock cmpxchg8b [esi]
        _emit 0xF0  // lock
        _emit 0x0F  // cmpxchg8b [esi]
        _emit 0xC7
        _emit 0x0E

        // result is in DX,AX
    }        
}
#pragma warning (default: 4035)
#endif
///////////////////////////////////////////////////////////////////////////////////
// End of processor specific code
///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////

CMPCellPool::CMPCellPool()
{
    ///////////////////////////////////////////////////////////////////////////////////
    // A lock is not needed since it is just a simple comparison and assignments, and it 
    // doesn't matter if we assign it to the same number multiple of times..
    if( FALSE == s_fInitStaticVars )
    {
        SYSTEM_INFO si;
        HKEY hRegKey;
        BOOL fUseDefault = TRUE;
        LONG lResult;

        GetSystemInfo( &si );

        s_dwParallelism = si.dwNumberOfProcessors;
        
        lResult = RegOpenKeyExW( 
                        HKEY_LOCAL_MACHINE,
                        L"Software\\Microsoft\\Windows Media\\Platform",
                        0,
                        KEY_READ,
                        &hRegKey
                        );                        
        if ( ERROR_SUCCESS == lResult )
        {
            DWORD dwType;
            DWORD dwLength;
            DWORD dwRegistryValue;

            dwLength = sizeof( DWORD );
            lResult = RegQueryValueExW( 
                            hRegKey, 
                            L"Use LockFree Stack",
                            NULL,
                            &dwType, 
                            (LPBYTE) &dwRegistryValue, 
                            &dwLength 
                            );
            if ( ( ERROR_SUCCESS == lResult ) && ( REG_DWORD == dwType ) )
            {
                if( ( dwRegistryValue ) && ( sizeof(LPVOID) == 4 ) )
                {
                    s_fUseLockFreeStack = TRUE;
                    fUseDefault = FALSE;
                }
                else
                {
                    s_fUseLockFreeStack = FALSE;
                    fUseDefault = FALSE;
                }
            }
            
            RegCloseKey( hRegKey );
        }        

        if( fUseDefault )
        {
            BOOL f = IsProcessorFeaturePresent( PF_COMPARE_EXCHANGE_DOUBLE );
    
            if( ( si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ) &&
                ( si.wProcessorLevel >= 6) &&           // Pentium Pro/Pentium II +
                ( si.wProcessorRevision >= 0x0300 ) &&  // pentium II + 
                ( sizeof(DWORD *) == 4 ) )              // 32 bit architecture
            {
                s_fUseLockFreeStack = TRUE;
            }
            else
            {
                s_fUseLockFreeStack = FALSE;
            }
        }

        s_fInitStaticVars = TRUE;
    }
    ///////////////////////////////////////////////////////////////////////////////////

    m_rgPoolEntry = NULL;
    m_cPoolEntry = 0;

#if DBG_MEM_LEAK
    m_pLeakDetector = malloc( 1 );
#endif
}

///////////////////////////////////////////////////////////////////////////////////

CMPCellPool::~CMPCellPool()
{
    Cleanup();

#if DBG_MEM_LEAK
    if( NULL != m_pLeakDetector )
    {
        free( m_pLeakDetector );
    }
#endif

#if DBG
    SYSTEM_INFO si;
    GetSystemInfo( &si );
    MPCELLPOOLASSERT( s_dwParallelism == si.dwNumberOfProcessors );
#endif
}


///////////////////////////////////////////////////////////////////////////////
// [Initialize]
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CMPCellPool::Initialize(
    DWORD cbCellSize, 
    DWORD nCellsPerPage, 
    DWORD nInitialPages, 
    BOOL fFreeUnusedPages
    )
{
    HRESULT hr = S_OK;
    DWORD cbMpCellSize;

    MPCELLPOOLASSERT( m_rgPoolEntry == NULL );    

    m_cbCellSize = PROCESSOR_ALIGNMENT * ( ( cbCellSize + PROCESSOR_ALIGNMENT - 1 ) / PROCESSOR_ALIGNMENT );
    cbMpCellSize = m_cbCellSize + sizeof( MPCELLHEADER );

#if DBG
    if ( g_fUseNewDelete )
    {
        return( S_OK );
    }
#endif

    MPCELLPOOLASSERT( s_dwParallelism > 0 );
    m_rgPoolEntry = new MPPOOLENTRY[s_dwParallelism];
    if (m_rgPoolEntry == NULL) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        return(hr);
    }

    //
    // Initialize the MP pool structure
    //
    m_cPoolEntry = 0;
    m_fFreeUnusedPages = fFreeUnusedPages;
    
    //
    // Initialize all pools. Note that the pool has been
    // sufficiently initialized to use MpPoolDestroy for cleanup
    // if something bad happens.
    //
    for(DWORD i=0; i < s_dwParallelism; i++) 
    {
        hr = m_rgPoolEntry[i].m_Pool.Initialize( cbMpCellSize, nCellsPerPage,  nInitialPages, fFreeUnusedPages );

        if( FAILED( hr ) ) 
        {
            Cleanup();
            return(hr);
        }
        InitializeCriticalSection(&m_rgPoolEntry[i].m_Lock);

        m_rgPoolEntry[i].m_DelayedFreeList.m_Element.m_pFirst = NULL;
        m_rgPoolEntry[i].m_DelayedFreeList.m_Element.m_dwCount = 0;

        ZeroMemory( &m_rgPoolEntry[i].m_pLookaside, sizeof(MPPOOLLOOKASIDE) );
        ++m_cPoolEntry;
    }

    MPCELLPOOLASSERT( m_cPoolEntry == s_dwParallelism);

    return(hr);
}

///////////////////////////////////////////////////////////////////////////////
// [Cleanup]
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CMPCellPool::Cleanup()
{
    LONG i;
    LONG lPoolCount;
    
    lPoolCount = (LONG)m_cPoolEntry;

    //
    // Lock down all the pools so we don't end up hosing people
    // who may be allocating things while we are deleting the pools.
    // By setting MpPool->PoolCount = 0 we also attempt to prevent
    // people from getting hosed as soon as we delete the critical
    // sections and pools.
    //
    m_cPoolEntry = 0;
    for (i=0; i < lPoolCount; i++) 
    {
        EnterCriticalSection(&m_rgPoolEntry[i].m_Lock);
        FreeDFLCells( &m_rgPoolEntry[i] );
    }

    //
    // Delete the pools and their associated critical sections.
    // Note that the order is important here. Since the MpPool
    // structure was allocated from MpPool->Pool[0] we must
    // delete that last.
    //
    for (i=lPoolCount-1; i>=0; i--) 
    {
        DeleteCriticalSection(&m_rgPoolEntry[i].m_Lock);
    }

    SAFE_ARRAYDELETE( m_rgPoolEntry );
    return( S_OK );
}

#if !DBG
#pragma optimize ("t", on )
#endif
///////////////////////////////////////////////////////////////////////////////
// [AcquireCell]
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMPCellPool::AcquireCell( void **ppCell )
{
    PMPCELLHEADER pHeader = NULL;
    PMPPOOLENTRY pPoolEntry = NULL;
    DWORD dwPoolHint;
    DWORD i;

    if( NULL == ppCell )
    {
        return( E_INVALIDARG );
    }
    *ppCell = NULL;             // initialize var to NULL
    
#if DBG
    if ( g_fUseNewDelete )
    {
        *ppCell = ::new BYTE[ m_cbCellSize ];
        return( ( *ppCell != NULL ) ? S_OK : E_OUTOFMEMORY );
    }
#endif

    //
    // Iterate through the pool locks looking for one
    // that is not owned.
    //

    // PERF TODO:  improve this hash function
    // previously we used the same index used by the processor affinity code
    // but since mpcellpool is not a dll any more there is no clear way to get access to that
    // location (as it will need to have be initialized by each dll/exe which links
    // dstruct/mpcellpool)
    i = GetCurrentThreadId() % m_cPoolEntry;
    MPCELLPOOLASSERT( i < m_cPoolEntry );

    pPoolEntry = &m_rgPoolEntry[ i ];
    dwPoolHint = i;
    do
    {
        if( ( FALSE == m_fFreeUnusedPages ) && ( TRUE == s_fUseLockFreeStack ) )
        {
            pHeader = PopDFLCell( NULL, &pPoolEntry->m_DelayedFreeList );
            if( pHeader != NULL )
            {
                *ppCell = (char *) pHeader - m_cbCellSize;
                MPCELLPOOLASSERT( ( (QWORD) *ppCell % CELL_ALIGNMENT ) == 0 );
                INCCOUNTER( pPoolEntry->m_dwDFLAllocations );
                pHeader->m_pPoolEntry = pPoolEntry;
                goto done;
            }
        }
        else
        {
            //
            // Check the lookaside list for a suitable allocation.
            //
            if( ( pPoolEntry->m_pLookaside.m_pEntry != NULL ) &&
                ( ( pHeader = (PMPCELLHEADER)InterlockedExchangePointer( (volatile PVOID *) &(pPoolEntry->m_pLookaside.m_pEntry), 
                                                                         ( PVOID ) NULL ) ) != NULL ) )
            {
                //
                // We have a lookaside hit, return it immediately.
                //
                MPCELLPOOLASSERT( pHeader->m_pPoolEntry == pPoolEntry );

                *ppCell = (char *) pHeader - m_cbCellSize;
                MPCELLPOOLASSERT( ( (QWORD) *ppCell % CELL_ALIGNMENT ) == 0 );
                INCCOUNTER( pPoolEntry->m_dwLookasideAllocations );
                pHeader->m_pPoolEntry = pPoolEntry;
                goto done;
            }
        }

        // Attempt to lock this pool without blocking
        if( TryEnterCriticalSection( &pPoolEntry->m_Lock ) )
        {
            goto LockAcquired;     // success, go allocation immediately
        }

        // This pool is owned by another thread, try the next one
        i++;
        if( i == m_cPoolEntry )
        {
            i = 0;
        }

        pPoolEntry = &m_rgPoolEntry[i];
    } while( i != dwPoolHint ); // if this is equal, we have gone all the way around and tried all pools

    // All of the critical sections were owned by someone else,
    // so we have no choice but to wait for a critical section
    EnterCriticalSection( &pPoolEntry->m_Lock );

LockAcquired:

    if( ( TRUE == m_fFreeUnusedPages ) && ( NULL != pPoolEntry->m_DelayedFreeList.m_Element.m_pFirst ) )
    {
        FreeDFLCells( pPoolEntry );
    }

    INCCOUNTER( pPoolEntry->m_dwAllocations );
    pPoolEntry->m_Pool.AcquireCell( ppCell );
    LeaveCriticalSection( &pPoolEntry->m_Lock );

    if( NULL != *ppCell )
    {
        MPCELLPOOLASSERT( ( (QWORD) *ppCell % CELL_ALIGNMENT ) == 0 );
        pHeader = (PMPCELLHEADER) ( (char *) *ppCell + m_cbCellSize );
        pHeader->m_pPoolEntry = pPoolEntry;
#if DBG
        pHeader->m_dwNumAllocations = 0;            // initialize the debug vars
        pHeader->fccSignature = SIG_FREE_MPCELL;
#endif
    }

done:
    //if( NULL != *ppCell )
    //{
    //    PrefetchNta( *ppCell );     // prefetch the first cache line
    //}

#if DBG
    MPCELLPOOLASSERT( *ppCell != NULL );

    // MPCELLPOOLASSERT( ++pHeader->m_dwNumAllocations == 1 );
    MPCELLPOOLASSERT( InterlockedIncrement( (LONG*) &pHeader->m_dwNumAllocations ) == 1 );

    MPCELLPOOLASSERT( pHeader->fccSignature == SIG_FREE_MPCELL );
    pHeader->fccSignature = SIG_USED_MPCELL;

    FillMemory( *ppCell, m_cbCellSize, MP_ALLOC_PATTERN );
#endif 

    return( ( *ppCell != NULL ) ? S_OK : E_OUTOFMEMORY );
}


///////////////////////////////////////////////////////////////////////////////
// [ReleaseCell]
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CMPCellPool::ReleaseCell( LPVOID lpMem )
{
#if DBG
    if ( g_fUseNewDelete )
    {
        ::delete [] lpMem;
        return( S_OK );
    }
#endif

    PMPCELLHEADER pHeader = (PMPCELLHEADER) ( (char *) lpMem + m_cbCellSize );
    PMPPOOLENTRY pPoolEntry = pHeader->m_pPoolEntry;
    HRESULT hr;
    
#if DBG
    MPCELLPOOLASSERT( ( (QWORD) lpMem % CELL_ALIGNMENT ) == 0 );

    // MPCELLPOOLASSERT( --pHeader->m_dwNumAllocations == 0 );
    MPCELLPOOLASSERT( InterlockedDecrement( (LONG*) &pHeader->m_dwNumAllocations ) == 0 );

    MPCELLPOOLASSERT( pHeader->fccSignature == SIG_USED_MPCELL );
    pHeader->fccSignature = SIG_FREE_MPCELL;

    FillMemory( lpMem, m_cbCellSize, MP_DELETE_PATTERN );
#endif

    if( ( FALSE == m_fFreeUnusedPages ) && ( TRUE == s_fUseLockFreeStack ) )
    {
        PushDFLCell( NULL, &pPoolEntry->m_DelayedFreeList, pHeader );
        return( S_OK );
    }
    else
    {
        // Try and put this back on the lookaside list
        if( InterlockedCompareExchangePointer( (PVOID*) &pPoolEntry->m_pLookaside, (PVOID) pHeader, NULL ) == NULL )
        {
            // Successfully freed to lookaside list.
            INCCOUNTER( pPoolEntry->m_dwLookasideFrees );
            return( S_OK );                
        }

        if( TRUE == s_fUseLockFreeStack )
        {
            if( TryEnterCriticalSection( &pPoolEntry->m_Lock ) )
            {
                hr = pPoolEntry->m_Pool.ReleaseCell( lpMem );
                INCCOUNTER( pPoolEntry->m_dwFrees );
                LeaveCriticalSection( &pPoolEntry->m_Lock );
                return(hr);
            }


            PushDFLCell( NULL, &pPoolEntry->m_DelayedFreeList, pHeader );

            return( S_OK );
        }
        else
        {
            EnterCriticalSection( &pPoolEntry->m_Lock );
            INCCOUNTER( pPoolEntry->m_dwFrees );
            hr = pPoolEntry->m_Pool.ReleaseCell( lpMem );
            LeaveCriticalSection( &pPoolEntry->m_Lock );

            return( hr );
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
// [FreeDFLCells]
///////////////////////////////////////////////////////////////////////////////
VOID
CMPCellPool::FreeDFLCells(
    IN MPPOOLENTRY *pPoolEntry
    )
{
    MPCELLHEADER *pFreeList;
    DFLSTACKPTR  *pDFLHead = &pPoolEntry->m_DelayedFreeList;

    //
    // Capture the entire delayed free list with a single interlocked exchange.
    // Once we have removed the entire list, free each entry in turn.
    //

    pFreeList = (MPCELLHEADER*) InterlockedExchangePointer( (volatile PVOID *) &pDFLHead->m_Element.m_pFirst, 
                                                            (PVOID) NULL);
    while (pFreeList != NULL) 
    {
        void* pCell = (void *) ( (char *) pFreeList - m_cbCellSize );
        MPCELLPOOLASSERT( ( (QWORD) pCell % CELL_ALIGNMENT ) == 0 );
        pFreeList = pFreeList->m_pNext;
        INCCOUNTER( pPoolEntry->m_dwFrees );
        pPoolEntry->m_Pool.ReleaseCell( (PVOID) pCell );
    }
}


///////////////////////////////////////////////////////////////////////////////
// [PushDFLCell]
///////////////////////////////////////////////////////////////////////////////
__forceinline
VOID
CMPCellPool::PushDFLCell( CRITICAL_SECTION *pLock, 
                          DFLSTACKPTR *pDFLHead, 
                          MPCELLHEADER *pNode )
{
    MPCELLPOOLASSERT( TRUE == s_fUseLockFreeStack );

//    if( s_fUseLockFreeStack )
//    {
        DFLSTACKPTR listComp;
        DFLSTACKPTR listExch;

        while(TRUE)
        {
            // listComp.m_i64 = pDFLHead->m_i64;
            listComp.m_Element.m_pFirst = pDFLHead->m_Element.m_pFirst;
            listComp.m_Element.m_dwCount = pDFLHead->m_Element.m_dwCount;
            pNode->m_pNext = (MPCELLHEADER *) listComp.m_Element.m_pFirst;
            listExch.m_Element.m_pFirst = pNode;
            listExch.m_Element.m_dwCount = listComp.m_Element.m_dwCount + 1;

            if( listComp.m_i64 == InterlockedCompareExchange64( &pDFLHead->m_i64,
                                                                listExch.m_i64,
                                                                listComp.m_i64 ) )
            {
                return;
            }
        }
//    }
//    else
//    {
//        EnterCriticalSection( pLock );
//        pNode->m_pNext = pDFLHead->m_Element.m_pFirst;
//        pDFLHead->m_Element.m_pFirst = pNode;
//        pDFLHead->m_Element.m_dwCount += 1;
//        LeaveCriticalSection( pLock );
//    }
}



///////////////////////////////////////////////////////////////////////////////
// [PopDFLCell]
///////////////////////////////////////////////////////////////////////////////
__forceinline
MPCELLHEADER *
CMPCellPool::PopDFLCell( CRITICAL_SECTION *pLock, 
                         DFLSTACKPTR *pDFLHead )
{
    MPCELLPOOLASSERT( TRUE == s_fUseLockFreeStack );

//    if( s_fUseLockFreeStack )
//    {
        MPCELLHEADER *pNode;
        DFLSTACKPTR listComp;
        DFLSTACKPTR listExch;

        while(TRUE)
        {
            // listComp.m_i64 = pDFLHead->m_i64;
            listComp.m_Element.m_pFirst = pDFLHead->m_Element.m_pFirst;
            listComp.m_Element.m_dwCount = pDFLHead->m_Element.m_dwCount;

            pNode = (MPCELLHEADER *) listComp.m_Element.m_pFirst;
            if( NULL != pNode )
            {
                listExch.m_Element.m_pFirst = pNode->m_pNext;
                listExch.m_Element.m_dwCount = listComp.m_Element.m_dwCount + 1;
                if( listComp.m_i64 == InterlockedCompareExchange64( &pDFLHead->m_i64,
                                                                    listExch.m_i64,
                                                                    listComp.m_i64 ) )
                {
                    return( pNode );
                }
            }
            else
            {
                return( NULL );
            }
        }
//    }
//    else
//    {
//        MPCELLHEADER *pNode;
//        EnterCriticalSection( pLock );
//        pNode = pDFLHead->m_Element.m_pFirst;
//        if( NULL != pNode )
//        {
//            pDFLHead->m_Element.m_pFirst = pNode->m_pNext;
//            pDFLHead->m_Element.m_dwCount += 1;
//        }
//        LeaveCriticalSection( pLock );
//        return( pNode );
//    }
}
#if !DBG
#pragma optimize ("", on )
#endif


#if DBG
///////////////////////////////////////////////////////////////////////////////
// [GetStatistics]
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMPCellPool::GetStatistics(
    LPDWORD lpdwSize,
    MPPOOLSTATISTICS pStats[]
    )
{
    
    PMPPOOLENTRY pPoolEntry;
    DWORD i;
    DWORD dwRequiredSize;

    
    dwRequiredSize = m_cPoolEntry * sizeof(MPPOOLSTATISTICS);
    if( *lpdwSize < dwRequiredSize )
    {
        *lpdwSize = dwRequiredSize;
        return( HRESULT_FROM_WIN32(ERROR_MORE_DATA) );
    }
    ZeroMemory(pStats, m_cPoolEntry * sizeof(MPPOOLSTATISTICS));
    for( i = 0; i < m_cPoolEntry; i++) 
    {
        pPoolEntry = &m_rgPoolEntry[i];

        pStats[i].m_dwContention = pPoolEntry->m_Lock.DebugInfo->ContentionCount;
        pStats[i].m_dwTotalAllocates = pPoolEntry->m_dwAllocations + pPoolEntry->m_dwLookasideAllocations + pPoolEntry->m_dwDFLAllocations;
        pStats[i].m_dwTotalFrees = pPoolEntry->m_dwFrees + pPoolEntry->m_dwLookasideFrees + pPoolEntry->m_dwDFLFrees;
        pStats[i].m_dwLookasideAllocates = pPoolEntry->m_dwLookasideAllocations;
        pStats[i].m_dwLookasideFrees = pPoolEntry->m_dwLookasideFrees;
        pStats[i].m_dwDFLFrees = pPoolEntry->m_dwDFLFrees;
        pStats[i].m_dwDFLAllocations = pPoolEntry->m_dwDFLAllocations;
    }
    *lpdwSize = dwRequiredSize;

    return( S_OK );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\mpcellpool.h ===
#pragma once
#ifndef _MPCELLPOOL_H_
#define _MPCELLPOOL_H_

#include "vcelpool.h"
#include "malloc.h"
#include "leakdetector.h"


class MPPOOLENTRY;

// Define the pool cell header that gets tacked on the front of
// every allocation. Eight bytes is a lot, but we can't make
// it any smaller or else the allocation will not be properly
// aligned for 64-bit quantities.Actually the Lookaside index is
// not used at all.
//
typedef struct _MPCELLHEADER 
{
#if DBG
    DWORD           fccSignature;              // signature
    DWORD           m_dwNumAllocations;        // remove from dbg builds later
#endif
    union
    {
        MPPOOLENTRY          *m_pPoolEntry;
        struct _MPCELLHEADER *m_pNext;
    };
} MPCELLHEADER, *PMPCELLHEADER;


typedef struct 
{
    union
    {
        __int64          volatile m_i64;
        struct
        {        
            MPCELLHEADER volatile *m_pFirst;
            DWORD        volatile m_dwCount;
        } m_Element;
    };
} DFLSTACKPTR;

typedef struct _MPPOOLLOOKASIDE 
{
    PMPCELLHEADER m_pEntry;
} MPPOOLLOOKASIDE, *PMPPOOLLOOKASIDE;


class MPPOOLENTRY 
{
public:
    MPPOOLENTRY() 
    { 
        m_DelayedFreeList.m_Element.m_pFirst = NULL;
        m_DelayedFreeList.m_Element.m_dwCount = 0;
#if DBG
        m_dwAllocations = 0; 
        m_dwFrees = 0;
        m_dwLookasideAllocations = 0;
        m_dwLookasideFrees = 0;
        m_dwDFLFrees = 0;
        m_dwDFLAllocations = 0;
#endif
    }

#if DBG
    DWORD m_dwAllocations;
    DWORD m_dwFrees;
    DWORD m_dwLookasideAllocations;
    DWORD m_dwLookasideFrees;
    DWORD m_dwDFLFrees;
    DWORD m_dwDFLAllocations;
#endif

    CRITICAL_SECTION m_Lock;
    DFLSTACKPTR      m_DelayedFreeList;
    MPPOOLLOOKASIDE  m_pLookaside;
    CVCellPool       m_Pool;
};

typedef MPPOOLENTRY *PMPPOOLENTRY;

//
// Statistics structure
//
typedef struct _MPPOOLSTATISTICS {
    DWORD m_dwContention;
    DWORD m_dwTotalAllocates;
    DWORD m_dwTotalFrees;
    DWORD m_dwLookasideAllocates;
    DWORD m_dwLookasideFrees;
    DWORD m_dwDFLFrees;
    DWORD m_dwDFLAllocations;
} MPPOOLSTATISTICS, *LPMPPOOLSTATISTICS;


class CMPCellPool
{
public:
    //////////////////////////////////////////////////////////////////////
    // Public Methods
    CMPCellPool();
    ~CMPCellPool();

    HRESULT       Initialize( DWORD cbCellSize, 
                              DWORD nCellsPerPage, 
                              DWORD nInitialPages, 
                              BOOL fFreeUnusedPages
                            );
    HRESULT       Cleanup();
    HRESULT       AcquireCell( void **pCell );
    HRESULT       ReleaseCell( void *pCell );

#if DBG
    HRESULT       GetStatistics( LPDWORD lpdwSize, MPPOOLSTATISTICS Statistics[] );
#endif

private:
    VOID          FreeDFLCells( MPPOOLENTRY *pPoolEntry );
    VOID          PushDFLCell( CRITICAL_SECTION *pLock, 
                               DFLSTACKPTR *pDFLHead, 
                               MPCELLHEADER *pNode );
    MPCELLHEADER *PopDFLCell( CRITICAL_SECTION *pLock, 
                              DFLSTACKPTR *pDFLHead );

    MPPOOLENTRY  *m_rgPoolEntry;
    DWORD         m_cPoolEntry;
    DWORD         m_cbCellSize;
    BOOL          m_fFreeUnusedPages;

private:
#if DBG_MEM_LEAK
    void         *m_pLeakDetector;
#endif

public:
    static BOOL   s_fInitStaticVars;
    static BOOL   s_fUseLockFreeStack;
    static DWORD  s_dwParallelism;
};

#endif //_MPCELLPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\tbckhash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File: 		tbckhash.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef TBCKHASH_H
#define TBCKHASH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "tcelpool.h"

extern BOOL g_fUseNewDelete;

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
class CTBucketHash
{
public:
    CTBucketHash();
   ~CTBucketHash();

   typedef DWORD (WINAPI *PFNTYPEDHASHINGFUNCTION)( const KeyType& Key, DWORD dwTableSize, DWORD dwParam );
   typedef int (WINAPI *PFNTYPEDCOMPAREFUNCTION)( const KeyType& Key1, const KeyType& Key2 );

   HRESULT Initialize( DWORD dwTableSize, 
                       PFNTYPEDHASHINGFUNCTION pfnHash = NULL, 
                       PFNTYPEDCOMPAREFUNCTION pfnCompare = NULL,
                       DWORD dwParam = 0 );

   HRESULT Insert( const KeyType& Key, const ValueType& Value );
   HRESULT Find( const KeyType& Key, ValueType& Value );
   HRESULT FindLast( const KeyType& Key, ValueType& Value );
   HRESULT Remove( const KeyType& Key, ValueType& Value );
   HRESULT RemoveAndGoToNext( const KeyType& Key, ValueType& Value );

   DWORD GetEntryCount() { return m_dwEntries; }
   DWORD RemoveAll();

   BOOL GetFirst( KeyType& Key, ValueType& Value );
   BOOL GetNext( KeyType& Key, ValueType& Value );

protected:
    struct NODE
    {
        KeyType Key;
        ValueType Value;
        NODE *pNext;
    };

    NODE **m_pTable;
    DWORD m_dwTableSize;
    DWORD m_dwEntries;
    DWORD m_dwHashParam;
    NODE *m_pCursor;

    PFNTYPEDHASHINGFUNCTION m_pfnHash;
    PFNTYPEDCOMPAREFUNCTION m_pfnCompare;

    CTCellPool<NODE> *m_pNodePool;

    DWORD Hash( const KeyType& Key );
    int Compare( const KeyType& Key1, const KeyType& Key2 );
};

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
inline DWORD CTBucketHash<KeyType, ValueType>::Hash( const KeyType& Key )
{
    if( !m_pfnHash )
    {
        //
        // WARNING: Default hash assumes KeyType is at least DWORD sized
        //
#if DBG
        if( sizeof(KeyType) < sizeof(DWORD) )
        {
            DebugBreak();
        }
#endif
        return( (*(DWORD*)&Key)%m_dwTableSize );
    }
    else
    {
        return( m_pfnHash( Key, m_dwTableSize, m_dwHashParam ) );
    }
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
CTBucketHash<KeyType, ValueType>::CTBucketHash()
{
    m_pTable = NULL;
    m_dwTableSize = 0;
    m_dwEntries = 0;
    m_pNodePool = NULL;
    m_pfnHash = NULL;
    m_pfnCompare = NULL;
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
CTBucketHash<KeyType, ValueType>::~CTBucketHash()
{
#if DBG
    if( ( g_fUseNewDelete ) && ( 0 != m_dwEntries ) )
    {
        RemoveAll();
    }
#endif

    delete [] m_pTable;
    delete m_pNodePool;
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
HRESULT CTBucketHash<KeyType, ValueType>::Initialize( DWORD dwTableSize, PFNTYPEDHASHINGFUNCTION pfnHash, PFNTYPEDCOMPAREFUNCTION pfnCompare, DWORD dwParam )
{
    if( m_pTable )
    {
        return( E_UNEXPECTED );   
    }
    if( !dwTableSize )
    {
        return( E_INVALIDARG );
    }

    m_pTable = new NODE *[ dwTableSize ];

    if( NULL == m_pTable )
    {
        return( E_OUTOFMEMORY );
    }

    ZeroMemory( m_pTable, ( sizeof(NODE *) * dwTableSize ) );

    m_pNodePool = new CTCellPool<NODE>;
    if( ( NULL == m_pNodePool ) ||
        FAILED( m_pNodePool->Initialize( dwTableSize, 1, FALSE ) ) )
    {
        delete m_pNodePool;
        m_pNodePool = NULL;
        return( E_OUTOFMEMORY );
    }

    m_pfnHash = pfnHash;
    m_pfnCompare = pfnCompare;
    m_dwTableSize = dwTableSize;
    m_dwEntries = 0;
    m_dwHashParam = dwParam;
    m_pCursor = NULL;

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
HRESULT CTBucketHash<KeyType, ValueType>::Insert( const KeyType& Key, const ValueType& Value )
{
    //
    // Find a node to use in the bucket
    //
    NODE *pNew = m_pNodePool->AcquireElement();

    if( NULL == pNew )
    {
        return( E_OUTOFMEMORY );
    }

    pNew->Key = Key;
    pNew->Value = Value;

    //
    // Find the right bucket to use
    //
    DWORD dwHash = Hash( Key );

    pNew->pNext = m_pTable[dwHash];
    m_pTable[dwHash] = pNew;

    m_dwEntries++;

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
DWORD CTBucketHash<KeyType, ValueType>::RemoveAll()
{
    if( !m_pTable )
    {
        return( 0 );
    }

    m_pCursor = NULL;

#if DBG
    if ( g_fUseNewDelete )
    {
        DWORD i;
        NODE *pNode,*pNode2;
        for ( i = 0; i < m_dwTableSize; ++i )
        {
            pNode = m_pTable[i];
            while( pNode )
            {
                pNode2 = pNode->pNext;
                m_pNodePool->ReleaseElement( pNode );
                pNode = pNode2;
            }
            
        }
    }
#endif

    if( FAILED( m_pNodePool->Initialize( m_dwTableSize, 1, FALSE ) ) )
    {
        delete m_pNodePool;
        m_pNodePool = NULL;
        return( 0 );
    }

    ZeroMemory( m_pTable, ( sizeof(NODE *) * m_dwTableSize ) );

    DWORD dwRemoved = m_dwEntries;
    m_dwEntries = 0;

    return( dwRemoved );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
HRESULT CTBucketHash<KeyType, ValueType>::Find( const KeyType& Key, ValueType& Value )
{
    if( !m_pTable )
    {
        return( E_UNEXPECTED );
    }

    DWORD dwHash = Hash( Key );

    NODE *pNode = m_pTable[dwHash];

    while( pNode )
    {
        if( Compare( pNode->Key, Key ) == 0 )
        {
            Value = pNode->Value;
            break;
        }
        pNode = pNode->pNext;
    }

    return( pNode ? S_OK : E_FAIL );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
HRESULT CTBucketHash<KeyType, ValueType>::FindLast( const KeyType& Key, ValueType& Value )
{
    if( !m_pTable )
    {
        return( E_UNEXPECTED );
    }

    DWORD dwHash = Hash( Key );

    NODE *pNode = m_pTable[dwHash];
    NODE *pLast = NULL;

    while( pNode )
    {
        if( Compare( pNode->Key, Key ) == 0 )
        {
            pLast = pNode;
            Value = pNode->Value;
        }
        pNode = pNode->pNext;
    }

    return( pLast ? S_OK : E_FAIL );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
HRESULT CTBucketHash<KeyType, ValueType>::Remove( const KeyType& Key, ValueType& Value )
{
    if( !m_pTable )
    {
        return( E_UNEXPECTED );
    }

    DWORD dwHash = Hash( Key );

    NODE *pPrev = NULL;
    NODE *pNode = m_pTable[dwHash];

    while( pNode )
    {
        if( Compare( pNode->Key, Key ) == 0 )
        {
            m_pCursor = NULL;
            Value = pNode->Value;
            m_dwEntries--;

            if( pPrev )
            {
                pPrev->pNext = pNode->pNext;
            }
            else
            {
                m_pTable[dwHash] = pNode->pNext;
            }

            m_pNodePool->ReleaseElement( pNode );

            break;
        }

        pPrev = pNode;
        pNode = pNode->pNext;
    }

    return( pNode ? S_OK : E_FAIL );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
HRESULT CTBucketHash<KeyType, ValueType>::RemoveAndGoToNext( const KeyType& Key, ValueType& Value )
{
    if( !m_pTable )
    {
        return( E_UNEXPECTED );
    }

    DWORD dwHash = Hash( Key );

    NODE *pPrev = NULL;
    NODE *pNode = m_pTable[dwHash];

    while( pNode )
    {
        if( Compare( pNode->Key, Key ) == 0 )
        {
            Value = pNode->Value;
            m_dwEntries--;

            if( pPrev )
            {
                pPrev->pNext = pNode->pNext;
            }
            else
            {
                m_pTable[dwHash] = pNode->pNext;
            }

            //
            // Ugliness! Set the cursor up to point to the next valid
            // entry in the table.  This is done so that we can remove
            // in the middle of iterating over the table entries and
            // then continue iterating on the next entry.
            //
            m_pCursor = pNode->pNext;

            if( NULL == m_pCursor )
            {
                for( DWORD i = Hash( Key ) + 1; i < m_dwTableSize; i++ )
                {
                    if( NULL != m_pTable[i] )
                    {
                        m_pCursor = m_pTable[i];
                        break;
                    }
                }
            }

            m_pNodePool->ReleaseElement( pNode );

            break;
        }

        pPrev = pNode;
        pNode = pNode->pNext;
    }

    return( pNode ? S_OK : E_FAIL );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTBucketHash<KeyType, ValueType>::GetFirst( KeyType& Key, ValueType& Value )
{  
    if( !m_pTable )
    {
        return( FALSE );
    }

    if( 0 == m_dwEntries )
    {
        return( FALSE );
    }

    BOOL fLookingForNext = FALSE;

    for( DWORD i = 0; i < m_dwTableSize; i++ )
    {
        if( NULL == m_pTable[i] )
        {
            continue;
        }
        if( fLookingForNext )
        {
            m_pCursor = m_pTable[i];
            return( TRUE );
        }
        
        Key = m_pTable[i]->Key;
        Value = m_pTable[i]->Value;

        m_pCursor = m_pTable[i]->pNext;

        if( !m_pCursor )
        {
            fLookingForNext = TRUE;
            continue;
        }

        return( TRUE );
    }

    return( fLookingForNext );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTBucketHash<KeyType, ValueType>::GetNext( KeyType& Key, ValueType& Value )
{
    if( !m_pTable || !m_pCursor )
    {
        return( FALSE );
    }

    Key = m_pCursor->Key;
    Value = m_pCursor->Value;

    m_pCursor = m_pCursor->pNext;

    if( !m_pCursor )
    {
        for( DWORD i = Hash( Key ) + 1; i < m_dwTableSize; i++ )
        {
            if( m_pTable[i] )
            {
                m_pCursor = m_pTable[i];
                break;
            }
        }
    }

    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
inline int CTBucketHash<KeyType, ValueType>::Compare( const KeyType& Key1, const KeyType& Key2 )
{
    if ( NULL == m_pfnCompare )
    {
        return( !( Key1 == Key2 ) );
    }
    else
    {
        return( m_pfnCompare( Key1, Key2 ) );
    }
}

#endif // TBCKHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\tavltable.h ===
#ifndef TAVLTABLE_H_INCLUDED
#define TAVLTABLE_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include "vavltable.h"
#include <assert.h>


//////////////////////////////////////////////////////////////////////////////
//
// Builds a templatized AVL tree using the C-style untyped API set.
// ItemType is required to support < and > operators for proper searching/sorting.
//
template <typename ItemType>
class CTAVLTable
{
public:
    CTAVLTable();
    ~CTAVLTable();

    BOOL Initialize();

    BOOL Add( const ItemType &item, BOOL *pfDuplicateFound = NULL );

    BOOL Remove( const ItemType &item );

    BOOL Find( const ItemType &item );

    DWORD NumElements()
    {
        return( m_Table.dwNumElements );
    }

    ItemType *Seek( const ItemType &item );

    ItemType *Next();

    ItemType *First();

protected:
    static AVL_COMPARE_RESULT AVLAPI CompareElements(
                                        struct _AVL_TABLE *pTable,
                                        void *pvFirst,
                                        void *pvSecond );

    static void * AVLAPI AllocateNode(
                            struct _AVL_TABLE *pTable,
                            DWORD cbTreeNode );

    static void AVLAPI FreeNode(
                            struct _AVL_TABLE *pTable,
                            void *pvTreeNode );

    AVL_TABLE m_Table;
};


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
CTAVLTable<ItemType>::CTAVLTable()
{
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
CTAVLTable<ItemType>::~CTAVLTable()
{
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
BOOL CTAVLTable<ItemType>::Initialize()
{
    AvlInitializeTable( &m_Table, CompareElements, AllocateNode, FreeNode, this );

    return( TRUE );
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
BOOL CTAVLTable<ItemType>::Add( const ItemType &item, BOOL *pfDuplicateFound OPTIONAL )
{
    void *pvNode = AvlInsertElement( &m_Table, (void *) &item, sizeof(item), pfDuplicateFound );

    return( NULL != pvNode );
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
BOOL CTAVLTable<ItemType>::Remove( const ItemType &item )
{
    return( AvlDeleteElement( &m_Table, (void *) &item ) );
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
BOOL CTAVLTable<ItemType>::Find( const ItemType &item )
{
    ItemType *pItemData = (ItemType *) AvlFindElement( &m_Table, &item );

    if( NULL == pItemData )
    {
        return( FALSE );
    }

    item = *pItemData;

    return( TRUE );
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
ItemType * CTAVLTable<ItemType>::Seek( const ItemType &item )
{
    //
    // We want to jump to the first tree node >= the given item
    //
    m_Table.pRestartKey = NULL;
    m_Table.dwRestartDeleteCount = 0;

    ItemType *pItemNode = (ItemType *) AvlEnumerateMatches(
                                            &m_Table,
                                            NULL,       // Use MatchAll routine
                                            NULL,       // don't need MatchData
                                            FALSE,      // don't skip to next
                                            (void **) &m_Table.pRestartKey,
                                            &m_Table.dwRestartDeleteCount,
                                            (void *) &item );

    return( pItemNode );
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
ItemType * CTAVLTable<ItemType>::Next()
{
    ItemType *pItemNode = (ItemType *) AvlEnumerateMatches(
                                            &m_Table,
                                            NULL,       // Use MatchAll routine
                                            NULL,       // don't need MatchData
                                            TRUE,       // skip to next
                                            (void **) &m_Table.pRestartKey,
                                            &m_Table.dwRestartDeleteCount,
                                            NULL );

    return( pItemNode );
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
ItemType * CTAVLTable<ItemType>::First()
{
    ItemType *pItemNode = (ItemType *) AvlEnumerate( &m_Table, TRUE );

    return( pItemNode );
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
AVL_COMPARE_RESULT AVLAPI CTAVLTable<ItemType>::CompareElements(
                                                    struct _AVL_TABLE *pTable,
                                                    void *pvFirst,
                                                    void *pvSecond )
{
    assert( ( NULL != pvFirst ) && ( NULL != pvSecond ) );

    ItemType *pFirst = (ItemType *) pvFirst;
    ItemType *pSecond = (ItemType *) pvSecond;

    if( *pFirst < *pSecond )
    {
        return( AvlLessThan );
    }
    else if( *pFirst > *pSecond )
    {
        return( AvlGreaterThan );
    }
    else
    {
        return( AvlEqual );
    }
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
void * AVLAPI CTAVLTable<ItemType>::AllocateNode(
                                        struct _AVL_TABLE *pTable,
                                        DWORD cbTreeNode )
{
    assert( cbTreeNode == sizeof(AVL_TREE_NODE) + sizeof(ItemType) );

    void *pvNode = new BYTE[ cbTreeNode ];

    // printf( "Allocating %d bytes @ %p\n", cbTreeNode, pvNode );

    return( pvNode );
}


//////////////////////////////////////////////////////////////////////////////
template <typename ItemType>
void AVLAPI CTAVLTable<ItemType>::FreeNode(
                                        struct _AVL_TABLE *pTable,
                                        void *pvTreeNode )
{
    // printf( "Freeing node @ %p\n", pvTreeNode );

    delete [] (BYTE *) pvTreeNode;
}


#endif  // TAVLTABLE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\tleftist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File: 		tleftist.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef TLEFTIST_H
#define TLEFTIST_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "vcelpool.h"

#if DBG
extern BOOL g_fUseNewDelete;
#endif

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
class CTLeftistTree
{
public:
    CTLeftistTree();

#if DBG
    ~CTLeftistTree();
#endif

    HRESULT Initialize( DWORD nCellsPerPage = 10, 
                        DWORD nInitialPages = 1, 
                        BOOL bFreeUnusedPages = FALSE );

    BOOL AddItem( KeyType Key, ValueType Value );
    BOOL GetNextItem( KeyType &Key, ValueType &Value );
    BOOL PeekNextItem( KeyType &Key, ValueType &Value );

    DWORD GetEntryCount() { return m_dwEntries; }

    BOOL ResetSortOrder( BOOL fLargestFirst );

private:
    struct TreeNode
    {
        KeyType      key;
        ValueType    value;
        TreeNode    *pLeft;
        TreeNode    *pRight;
        UINT         dist;
    };

    CVCellPool m_NodePool;
    TreeNode *m_pRoot;
    DWORD m_dwEntries;
    BOOL m_fLargestFirst;

    TreeNode *LeftistUnion( TreeNode *pTreeA, TreeNode *pTreeB );
    TreeNode *MergeRight( TreeNode *pTreeA, TreeNode *pTreeB );
};

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
CTLeftistTree<KeyType, ValueType>::CTLeftistTree<KeyType, ValueType>()
{
    m_pRoot = NULL;
    m_dwEntries = 0;
    m_fLargestFirst = FALSE;
}

//////////////////////////////////////////////////////////////////////////////
#if DBG
template<class KeyType, class ValueType>
CTLeftistTree<KeyType, ValueType>::~CTLeftistTree()
{
    if( ( g_fUseNewDelete ) && ( 0 != m_dwEntries ) )
    {
        KeyType KeyDummy;
        ValueType ValueDummy;
        
        while( GetNextItem( KeyDummy, ValueDummy ) )
        {
            ;
        }
    }
}
#endif


//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
HRESULT CTLeftistTree<KeyType, ValueType>::Initialize( DWORD nCellsPerPage, 
                                                       DWORD nInitialPages, 
                                                       BOOL bFreeUnusedPages )
{
    HRESULT hr = m_NodePool.Initialize( sizeof(TreeNode), nCellsPerPage, nInitialPages, bFreeUnusedPages );
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTLeftistTree<KeyType, ValueType>::AddItem( KeyType Key, ValueType Value )
{
    TreeNode *pNewNode;
    //
    // Get a new tree node from our pool and initialize it
    //
    HRESULT hr = m_NodePool.AcquireCell((void **) &pNewNode);
    if( FAILED( hr ) )
    {
        return( FALSE );
    }

    pNewNode->key = Key;
    pNewNode->value = Value;
    pNewNode->pLeft = NULL;
    pNewNode->pRight = NULL;
    pNewNode->dist = 1;

    //
    // Merge this new node into our tree
    //
    m_pRoot = LeftistUnion( m_pRoot, pNewNode );

    m_dwEntries++;

    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTLeftistTree<KeyType, ValueType>::GetNextItem( KeyType &Key, ValueType &Value )
{
    if( !m_pRoot )
    {
        return( FALSE );
    }

    HRESULT hr;
    
    //
    // Pull the root node (containing the smallest key) off the tree, and rebalance
    //
    TreeNode *pNextNode = m_pRoot;

    m_pRoot = LeftistUnion( pNextNode->pLeft, pNextNode->pRight );

    //
    // Give the key and value from the root node back to the caller, and recycle the node
    //
    Key = pNextNode->key;
    Value = pNextNode->value;

    hr = m_NodePool.ReleaseCell( pNextNode );
    XOASSERT( SUCCEEDED( hr ) );
    
    m_dwEntries--;

    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTLeftistTree<KeyType, ValueType>::PeekNextItem( KeyType &Key, ValueType &Value )
{
    if( !m_pRoot )
    {
        return( FALSE );
    }

    Key = m_pRoot->key;
    Value = m_pRoot->value;

    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTLeftistTree<KeyType, ValueType>::ResetSortOrder( BOOL fLargestFirst )
{
    if( m_fLargestFirst == fLargestFirst )
    {
        return( FALSE );
    }

    assert( 0 == m_dwEntries );

    m_fLargestFirst = fLargestFirst;

    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
CTLeftistTree<KeyType, ValueType>::TreeNode *CTLeftistTree<KeyType, ValueType>::LeftistUnion( TreeNode *pTreeA, TreeNode *pTreeB )
{
    if( !pTreeA )
    {
        return( pTreeB );
    }
    else if( !pTreeB )
    {
        return( pTreeA );
    }
    else if( ( m_fLargestFirst && ( pTreeA->key > pTreeB->key ) ) ||
             ( !m_fLargestFirst && ( pTreeA->key < pTreeB->key ) ) )
    {
        return( MergeRight( pTreeA, pTreeB ) );
    }
    else
    {
        return( MergeRight( pTreeB, pTreeA ) );
    }
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
CTLeftistTree<KeyType, ValueType>::TreeNode *CTLeftistTree<KeyType, ValueType>::MergeRight( TreeNode *pTreeA, TreeNode *pTreeB )
{
    pTreeA->pRight = LeftistUnion( pTreeA->pRight, pTreeB );

    if( !pTreeA->pLeft || ( pTreeA->pLeft->dist < pTreeA->pRight->dist ) )
    {
        //
        // Swap pTreeA->pLeft and pTreeA->pRight to preserve leftist property
        //
        TreeNode *pTemp = pTreeA->pLeft;
        pTreeA->pLeft = pTreeA->pRight;
        pTreeA->pRight = pTemp;
    }

    //
    //  Fix the distance field of node pTreeA
    //
    if( !pTreeA->pRight )
    {
        pTreeA->dist = 1;
    }
    else
    {
        pTreeA->dist = 1 + min( pTreeA->pLeft->dist, pTreeA->pRight->dist );
    }

    return( pTreeA );
}

#endif  // TLEFTIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\tdynarr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File:       tptrarr.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef TDYNARR_H
#define TDYNARR_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "TSparseBlock.h"

//////////////////////////////////////////////////////////////////////////////
template< class Type, int ValsPerBlock = 20 >
class CTDynArray : protected CTSparseBlock< DWORD, Type, ValsPerBlock, FALSE >
{
public:
    CTDynArray()
    {
        m_cElements = 0;
    }

    //
    // Clean up
    //
    void RemoveAll()
    {
        FreeList();
        m_cElements = 0;
    }

    //
    // Accessing existing elements
    //
    DWORD GetSize() const
    {
        return( m_cElements );
    }

    Type operator[]( DWORD nIndex ) const
    {
        Type element;
        
        GetAt( nIndex, &element );
        return( element );
    }
 
    Type* GetPtr( DWORD nIndex )
    {
        Type* pElement;
        
        if( SUCCEEDED( GetPointer( nIndex, &pElement ) ) )
        {
            return( pElement );
        }
        return( NULL );
    }

    BOOL GetAt( DWORD nIndex, Type *pElement ) const
    {
        if( nIndex >= m_cElements )
        {
            return( FALSE );
        }

        HRESULT hr;

        hr = GetValue( nIndex, pElement );

        return( SUCCEEDED( hr ) );
    }

    BOOL SetAt( DWORD nIndex, Type newElement )
    {
        if( nIndex >= m_cElements )
        {
            return( FALSE );
        }

        return( SetAtGrow( nIndex, newElement ) );
    }

    //
    // Appending elements
    //
    BOOL Add( Type newElement, DWORD *pdwIndex )
    {
        if( NULL != pdwIndex )
        {
            *pdwIndex = m_cElements;
        }

        HRESULT hr;

        hr = SetValue( m_cElements, newElement );

        if( SUCCEEDED( hr ) )
        {
            m_cElements++;
        }

        return( SUCCEEDED( hr ) );
    }

    BOOL SetAtGrow( DWORD nIndex, Type newElement )
    {
        HRESULT hr;

        hr = SetValue( nIndex, newElement );

        if( SUCCEEDED( hr ) )
        {
            m_cElements = max( m_cElements, nIndex + 1 );
        }

        return( SUCCEEDED( hr ) );
    }

    //
    // Expensive operations that move elements around
    //
    BOOL InsertAt( DWORD nIndex, Type newElement )
    {
        HRESULT hr;

        hr = InsertValue( nIndex, newElement );

        if( SUCCEEDED( hr ) )
        {
            m_cElements = max( m_cElements + 1, nIndex + 1 );
        }

        return( SUCCEEDED( hr ) );
    }

    BOOL RemoveAt( DWORD nIndex, DWORD nCount = 1 )
    {
        if( 0 == nCount )
        {
            return( TRUE );
        }

        if( nIndex + nCount > m_cElements )
        {
            return( FALSE );
        }

        HRESULT hr;

        for( DWORD i = 0; i < nCount; i++ )
        {
            hr = RemoveValue( nIndex );

            if( SUCCEEDED( hr ) )
            {
                m_cElements--;
            }
            else
            {
                break;
            }
        }

        return( SUCCEEDED( hr ) );
    }

    //
    // Very expensive brute force copy of all array elements
    //
    BOOL Copy( const CTDynArray& src )
    {
        RemoveAll();

        BOOL fOk = TRUE;
        DWORD cSrcElements = src.GetSize();

        for( DWORD i = 0; i < cSrcElements; i++ )
        {
            fOk = Add( src[ i ], NULL );

            if( !fOk )
            {
                break;
            }
        }

        return( fOk );
    }

protected:
    DWORD   m_cElements;
};


#endif  // TDYNARR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\tfifolif.h ===
#pragma once
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tfifolif.h
//
//--------------------------------------------------------------------------

#ifndef TFIFOLIF_H
#define TFIFOLIF_H

#include "tcelpool.h"

#if DBG
extern BOOL g_fUseNewDelete;
#endif


//////////////////////////////////////////////////////////////////////////////
template<class ElementType>
class CTLifo
{
public:
    CTLifo() { m_fInitialized = FALSE; m_dwCount = 0; }

#if DBG
    ~CTLifo();
#endif

    HRESULT Initialize( DWORD dwElementsPerPage = 10, BOOL fFreeUnusedPages = FALSE );
    
    HRESULT Push( const ElementType& Element );
    BOOL Pop( ElementType& Element );
    BOOL Peek( ElementType& Element );
    
    DWORD Count( void ) const { return( m_dwCount ); }

protected:
    struct NODE
    {
        ElementType Element;
        NODE *pNext;    
    };
    
    CTCellPool<NODE> m_NodePool;
    NODE *m_pHead;
    DWORD m_dwCount;
    BOOL m_fInitialized;
};
 
//////////////////////////////////////////////////////////////////////////////
template <class ElementType>
class CTFifo
{
public:
    CTFifo() { m_fInitialized = FALSE; m_dwCount = 0; }

#if DBG
    ~CTFifo();
#endif

    HRESULT Initialize( DWORD dwElementsPerPage = 10, BOOL fFreeUnusedPages = FALSE );
    
    HRESULT Push( const ElementType& Element );
    HRESULT PriorityPush( const ElementType& Element );
    BOOL Pop( ElementType& Element );
    BOOL Peek( ElementType& Element );
    
    DWORD Count( void ) const { return( m_dwCount ); }

protected:
    struct NODE
    {
        ElementType Element;
        NODE *pNext;    
    };
    
    CTCellPool<NODE> m_NodePool;
    NODE *m_pHead;
    NODE *m_pTail;
    DWORD m_dwCount;
    BOOL m_fInitialized;
};

//////////////////////////////////////////////////////////////////////////////
template <class ElementType, class CompareType>
class CTFifoEx : public CTFifo<ElementType>
{
public:
	BOOL Find( CompareType& Comp, ElementType *pFoundElement );
	BOOL Remove( CompareType& Comp, ElementType *pRemovedElement );

	virtual BOOL IsElement( ElementType& Element, CompareType& Comp ) = 0;
};	

//////////////////////////////////////////////////////////////////////////////

// CTLifo 

//////////////////////////////////////////////////////////////////////////////

#if DBG
template <class ElementType>
CTLifo<ElementType>::~CTLifo()
{
    if( ( g_fUseNewDelete ) && ( 0 != m_dwCount ) )
    {
        ElementType ElementDummy;
        
        while( Pop( ElementDummy ) )
        {
            ;
        }
    }
}
#endif

//////////////////////////////////////////////////////////////////////////////
template <class ElementType>
HRESULT CTLifo<ElementType>::Initialize( DWORD dwElementsPerPage, BOOL fFreeUnusedPages )
{
    if( m_fInitialized )
    {
        return( E_UNEXPECTED );
    }
    if( !dwElementsPerPage )
    {
        return( E_INVALIDARG );
    }

    if( FAILED( m_NodePool.Initialize( dwElementsPerPage, 1, fFreeUnusedPages ) ) )
    {
        return( E_OUTOFMEMORY );
    }

    m_pHead = NULL;
    m_dwCount = 0;
    
    m_fInitialized = TRUE;
    
    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
template <class ElementType>
HRESULT CTLifo<ElementType>::Push( const ElementType& Element )
{
    NODE *pNext = m_pHead;

    m_pHead = m_NodePool.AcquireElement();

    if( !m_pHead )
    {
        m_pHead = pNext;
        return( E_OUTOFMEMORY );
    }

    m_pHead->pNext = pNext;
    m_pHead->Element = Element;
    m_dwCount++;

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
template <class ElementType>
BOOL CTLifo<ElementType>::Pop( ElementType& Element )
{
    if( !m_pHead )
    {
        return( FALSE );
    }

    Element = m_pHead->Element;

    NODE *pNext = m_pHead->pNext;
    m_NodePool.ReleaseElement( m_pHead );
    m_pHead = pNext;

    m_dwCount--;
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template <class ElementType>
BOOL CTLifo<ElementType>::Peek( ElementType& Element )
{
    if( !m_pHead )
    {
        return( FALSE );
    }

    Element = m_pHead->Element;
    
    return( TRUE );
}


//////////////////////////////////////////////////////////////////////////////
// CTFifo 

//////////////////////////////////////////////////////////////////////////////

#if DBG
template <class ElementType>
CTFifo<ElementType>::~CTFifo()
{
    if( ( g_fUseNewDelete ) && ( 0 != m_dwCount ) )
    {
        ElementType ElementDummy;
        
        while( Pop( ElementDummy ) )
        {
            ;
        }

    }
}
#endif

//////////////////////////////////////////////////////////////////////////////
template <class ElementType>
HRESULT CTFifo<ElementType>::Initialize( DWORD dwElementsPerPage, BOOL fFreeUnusedPages )
{
    if( m_fInitialized )
    {
        return( E_UNEXPECTED );
    }
    if( !dwElementsPerPage )
    {
        return( E_INVALIDARG );
    }

    if( FAILED( m_NodePool.Initialize( dwElementsPerPage, 1, fFreeUnusedPages ) ) )
    {
        return( E_OUTOFMEMORY );
    }

    m_pHead = NULL;
    m_pTail = NULL;
    m_dwCount = 0;
    
    m_fInitialized = TRUE;
    
    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
template <class ElementType>
HRESULT CTFifo<ElementType>::Push( const ElementType& Element )
{
    NODE *pNew = m_NodePool.AcquireElement();

    if( !pNew )
    {
        return( E_OUTOFMEMORY );
    }

    pNew->pNext = NULL;
    pNew->Element = Element;

    if( m_pTail )
    {
        m_pTail->pNext = pNew;
    }
    else
    {
        m_pHead = pNew;
    }

    m_pTail = pNew;
    m_dwCount++;

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
template <class ElementType>
HRESULT CTFifo<ElementType>::PriorityPush( const ElementType& Element )
{
    NODE *pNew = m_NodePool.AcquireElement();

    if( !pNew )
    {
        return( E_OUTOFMEMORY );
    }

    pNew->pNext = m_pHead;
    pNew->Element = Element;

    m_pHead = pNew;

    if( NULL == m_pTail )
    {
        m_pTail = pNew;
    }

    m_dwCount++;

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
template <class ElementType>
BOOL CTFifo<ElementType>::Pop( ElementType& Element )
{
    if( !m_pHead )
    {
        return( FALSE );
    }

    Element = m_pHead->Element;

    NODE *pNext = m_pHead->pNext;
    m_NodePool.ReleaseElement( m_pHead );
    m_pHead = pNext;

    if( !m_pHead )
    {
        m_pTail = NULL;
    }

    m_dwCount--;
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template <class ElementType>
BOOL CTFifo<ElementType>::Peek( ElementType& Element )
{
    if( !m_pHead )
    {
        return( FALSE );
    }

    Element = m_pHead->Element;
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template <class ElementType,class CompareType>
BOOL CTFifoEx<ElementType,CompareType>::
Find( CompareType& Comp, ElementType *pElt )
{
	if( NULL == m_pHead )
	{
		return( FALSE );
	}	

	NODE *pNode = m_pHead;

	while( NULL != pNode )
	{
		if( IsElement( pNode->Element, Comp ) )
		{
			if( NULL != pFoundElement )
			{
				*pFoundElement = pNode->Element;
			}

			return( TRUE );
		}

		pNode = pNode->pNext;
	}

	return( FALSE );
}

//////////////////////////////////////////////////////////////////////////////
template <class ElementType,class CompareType>
BOOL CTFifoEx<ElementType,CompareType>::
Remove( CompareType& Comp, ElementType *pElt )
{
	if( NULL == m_pHead )
	{
		return( FALSE );
	}	

	NODE *pNode = m_pHead;
	NODE *pPrev = NULL;

	while( NULL != pNode )
	{
		if( IsElement( pNode->Element, Comp ) )
		{
			if( NULL == pPrev )
			{
				m_pHead = pNode->pNext;
				pPrev = m_pHead;
			}
			else
			{
				pPrev->pNext = pNode->pNext;
			}

			if( m_pTail == pNode )
			{
				m_pTail = pPrev;
			}

			if( NULL != pElt )
			{
				*pElt = pNode->Element;
			}

		    m_NodePool.ReleaseElement( pNode );

            m_dwCount--;

			return( TRUE );
		}

		pPrev = pNode;
		pNode = pNode->pNext;
	}

	return( FALSE );
}

#endif // TFIFOLIF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\tordlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File: 		tordlist.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef TORDLIST_H
#define TORDLIST_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "tcelpool.h"

#if DBG
extern BOOL g_fUseNewDelete;
#endif


//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
class CTOrderedList
{ 
public: 
    CTOrderedList();

#if DBG
    ~CTOrderedList();
#endif

    HRESULT Initialize( DWORD cInitialEntryAllocation );
    DWORD GetCount() const { return( m_cEntries ); }
    
    BOOL AddEntry( const KeyType& Key, const ValueType& Value );
    BOOL GetEntry( int index, KeyType& dwKey, ValueType& Value ) const;
    BOOL RemoveEntry( int index, KeyType& dwKey, ValueType& Value );
    void Clear();

    BOOL MoveFirst( KeyType& Key, ValueType& Value );
    BOOL MoveNext( KeyType& Key, ValueType& Value );

    BOOL Find( const KeyType& dwKey, int &index, ValueType& Value ) const;

private:
    struct NODE
    {
        KeyType Key;
        ValueType Value;
        NODE *pNext;
        NODE *pPrev;
    };
    
    NODE *m_pHead;
    NODE *m_pTail; 
    NODE *m_pCurrent;
    DWORD m_cEntries;

    CTCellPool<NODE> m_NodePool;
};

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
CTOrderedList<KeyType, ValueType>::CTOrderedList()
{
    m_pHead = m_pTail = m_pCurrent = NULL;
    m_cEntries = 0;
}

//////////////////////////////////////////////////////////////////////////////

#if DBG
template<class KeyType, class ValueType>
CTOrderedList<KeyType, ValueType>::~CTOrderedList()
{
    if( ( g_fUseNewDelete ) && ( 0 != m_cEntries ) )
    {
        Clear();
    }
}
#endif

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
HRESULT CTOrderedList<KeyType, ValueType>::Initialize( DWORD cInitialEntryAllocation )
{
    HRESULT hr = m_NodePool.Initialize( cInitialEntryAllocation, 1, FALSE );
    DEBUG_CELL_POOL( &m_NodePool );
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
void CTOrderedList<KeyType, ValueType>::Clear()
{
    NODE *pNext;

    while( m_pHead )
    {
        pNext = m_pHead->pNext;
        m_NodePool.ReleaseElement( m_pHead );
        m_pHead = pNext;
    }

    m_cEntries = 0;
    m_pTail = m_pCurrent = NULL;    
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTOrderedList<KeyType, ValueType>::AddEntry( const KeyType& Key, const ValueType& Value )
{
    NODE *pNew = m_NodePool.AcquireElement();

    if( !pNew )
    {
        return( FALSE );
    }

    pNew->Key = Key;
    pNew->Value = Value;
    pNew->pNext = NULL;
    pNew->pPrev = NULL;

    if( !m_pHead )
    {
        m_pHead = m_pTail = pNew;
    }
    else
    {               
        NODE *pNext = m_pHead;
        while( pNext )
        {
            if( pNext->Key > Key )
            {
                pNew->pNext = pNext;
                pNew->pPrev = pNext->pPrev;
                if( pNext->pPrev )
                {
                    pNext->pPrev->pNext = pNew;
                }
                pNext->pPrev = pNew;
                if( pNext == m_pHead )
                {
                    m_pHead = pNew;
                }                
                break;
            }
            pNext = pNext->pNext;
        }
        if( !pNext )
        {   
            pNew->pPrev = m_pTail;
            m_pTail->pNext = pNew;
            m_pTail = pNew;
        }
    }
    
    m_cEntries++;
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTOrderedList<KeyType, ValueType>::GetEntry( int index, KeyType& Key, ValueType& Value ) const
{
    NODE *pNext = m_pHead;

    for( int i = 0; ( i < index ) && pNext; i++ )
    {
        pNext = pNext->pNext;
    }

    if( !pNext )
    {
        return( FALSE );
    }

    Key = pNext->Key;
    Value = pNext->Value;
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTOrderedList<KeyType, ValueType>::RemoveEntry( int index, KeyType& Key, ValueType& Value )
{
    NODE *pNext = m_pHead;

    for( int i = 0; ( i < index ) && pNext; i++ )
    {
        pNext = pNext->pNext;
    }

    if( !pNext )
    {
        return( FALSE );
    }
    
    if( m_pCurrent == pNext )
    {
        m_pCurrent = NULL;
    }
    
    Key = pNext->Key;
    Value = pNext->Value;
    
    if( pNext == m_pTail )
    {
        m_pTail = pNext->pPrev;
    }
    if( pNext == m_pHead )
    {
        m_pHead = pNext->pNext;
    }
    if( pNext->pNext )
    {
        pNext->pNext->pPrev = pNext->pPrev;
    }
    if( pNext->pPrev )
    {
        pNext->pPrev->pNext = pNext->pNext;
    }

    m_NodePool.ReleaseElement( pNext );
    m_cEntries--;
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTOrderedList<KeyType, ValueType>::MoveFirst( KeyType& Key, ValueType& Value )
{
    m_pCurrent = m_pHead;

    return MoveNext( Key, Value );
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTOrderedList<KeyType, ValueType>::MoveNext( KeyType& Key, ValueType& Value )
{
    if( NULL == m_pCurrent ) 
    {
        return FALSE;
    }

    Value = m_pCurrent->Value; 
    Key = m_pCurrent->Key;

    m_pCurrent = m_pCurrent->pNext;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
template<class KeyType, class ValueType>
BOOL CTOrderedList<KeyType, ValueType>::Find( const KeyType& Key, 
                                              int &index,
                                              ValueType& Value ) const
{
    NODE *pNode;
    int i;

    for( pNode = m_pHead, i = 0; pNode; pNode = pNode->pNext, i++ )
    {
        if( pNode->Key == Key )
        {
            index = i;
            Value = pNode->Value;
            return( TRUE );
        }
    }

    return( FALSE );
}

#endif // TORDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\tcelpool.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File:         tcelpool.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef TCELPOOL_H
#define TCELPOOL_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "vcelpool.h"

#if !defined(USE_MFC) && !defined(__PLACEMENT_NEW_INLINE)
//////////////////////////////////////////////////////////////////////////////
// operator new with placement

inline void *operator new( size_t s, void *p ) { return p; }
inline void __cdecl operator delete(void *, void *) {return; }

#define __PLACEMENT_NEW_INLINE
#endif

#include "cellLeak.h"

#if DBG
#define USE_MEM_TRACKER 0
#else
#define USE_MEM_TRACKER 0
#endif

#if USE_MEM_TRACKER

#  ifndef _DEBUG
#    define __DEFINED_DEBUG
#    define _DEBUG
#  endif

#  include <crtdbg.h>

#  ifdef __DEFINED_DEBUG
#    undef _DEBUG
#  endif

#  ifndef DEBUG_NEW

#define TCELL_CLIENT_BLOCK  15          // Set the subtype of the client block to 15.

// Memory allocation tracking
inline void* __stdcall operator new( size_t nSize, const char* lpszFileName, int nLine , int dwMyType )
{
    

    void* ptr = ::operator new( nSize, _CLIENT_BLOCK | (TCELL_CLIENT_BLOCK<<16), lpszFileName, nLine );

    g_TrackerProcRegistry.TrackMemAlloc( ptr, ( int ) nSize, lpszFileName, nLine );

    return ptr;
    
//    return ::operator new( nSize ); 
}

inline  void operator delete( void *ptr, const char* lpszFileName, int nLine , int dwMyType )
{
    ::operator delete( ptr ); 
}

#  define DEBUG_NEW new( __FILE__, __LINE__ , 0xFEEDFEED )
#  define new DEBUG_NEW
#  endif // DEBUG_NEW

#endif // DBG



//////////////////////////////////////////////////////////////////////////////
//
// [CTCellPool] Template class for CVCellPool
//
//////////////////////////////////////////////////////////////////////////////
template<class Type>
class CTCellPool
{
public:
#if DBG
    CTCellPool();
    virtual ~CTCellPool();
#endif

    HRESULT Initialize( DWORD nCellsPerPage = 10, 
                        DWORD nInitialPages = 1, 
                        BOOL fFreeUnusedPages = FALSE
                        );
                   

    Type *AcquireElement();
#if DBG
    Type *AcquireElementDebug( const char *pFileName, int lineNum );
#endif
    BOOL ReleaseElement( Type *pElement );
 
    BOOL GetInfo( DWORD *pnTotalPages, DWORD *pnPagesOccupied, DWORD *pnCellsOccupied );

#if DBG
    CCellPoolTracker    *m_pCelltracker;
#endif

private:
    CVCellPool   m_Pool;
};


#if DBG
//////////////////////////////////////////////////////////////////////////////
template<class Type>
CTCellPool<Type>::CTCellPool()
{  
    m_pCelltracker = NULL;
}
//////////////////////////////////////////////////////////////////////////////
template<class Type>
CTCellPool<Type>::~CTCellPool()
{
    if ( NULL != m_pCelltracker )
    {
        m_pCelltracker->Shutdown();
        m_pCelltracker = NULL;
    }
}
#endif //DBG


//////////////////////////////////////////////////////////////////////////////
template<class Type>
HRESULT CTCellPool<Type>::Initialize( DWORD nCellsPerPage, 
                                      DWORD nInitialPages, 
                                      BOOL fFreeUnusedPages
                                      )
{
    HRESULT hr = m_Pool.Initialize( sizeof(Type), nCellsPerPage, nInitialPages, fFreeUnusedPages );

#if USE_MEM_TRACKER
    m_pCelltracker = g_TrackerProcRegistry.AllocCellTracker();

    if ( NULL != m_pCelltracker )
    {
        m_pCelltracker->Initialize( sizeof(Type), 1 );
        m_pCelltracker->RecordTotalPoolSize( m_Pool.GetTotalMemoryUsed() );
    }
#endif

    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
template<class Type>
__forceinline
Type* CTCellPool<Type>::AcquireElement()
{
    void *pCell = NULL;

    m_Pool.AcquireCell( &pCell );
    if( pCell != NULL )
    {
#if DBG
        if ( NULL != m_pCelltracker )
        {
            m_pCelltracker->CountAlloc();
            m_pCelltracker->RecordTotalPoolSize( m_Pool.GetTotalMemoryUsed() );
        }
#endif

#ifdef DEBUG_NEW 
#undef new
        return( new( pCell ) Type );
#define new DEBUG_NEW
#else    
        return( new( pCell ) Type );
#endif // !DEBUG_NEW
    }
    else
    {
        return( NULL );
    }
}



#if DBG

//////////////////////////////////////////////////////////////////////////////
template<class Type>
Type* CTCellPool<Type>::AcquireElementDebug( const char *pFileName, int lineNum )
{
    void *pCell = NULL;

    m_Pool.AcquireCell( &pCell);
    if( pCell == NULL )
    {
        return( NULL );
    }

    if ( NULL != m_pCelltracker )
    {
        m_pCelltracker->CountAlloc( pFileName, lineNum );
        m_pCelltracker->RecordTotalPoolSize( m_Pool.GetTotalMemoryUsed() );
    }

#ifdef DEBUG_NEW
#undef new
    return( new( pCell ) Type );
#define new DEBUG_NEW
#else    
    return( new( pCell ) Type );
#endif // !DEBUG_NEW
}
#endif




//////////////////////////////////////////////////////////////////////////////
// Ugly type name '_whoop_whoop_Type' is to allow objects with members
// called 'Type' without confusing the compiler.
template<class _whoop_whoop_Type>
__forceinline
BOOL CTCellPool<_whoop_whoop_Type>::ReleaseElement( _whoop_whoop_Type *pElement )
{
    pElement->~_whoop_whoop_Type();

    HRESULT hr = m_Pool.ReleaseCell( (void*)pElement );

#if DBG
    if ( NULL != m_pCelltracker )
    {
        m_pCelltracker->CountFree();
        m_pCelltracker->RecordTotalPoolSize( m_Pool.GetTotalMemoryUsed() );
    }
#endif

    return( SUCCEEDED( hr ) );
}


//////////////////////////////////////////////////////////////////////////////
template<class Type>
BOOL CTCellPool<Type>::GetInfo( DWORD *pnTotalPages, 
                                DWORD *pnPagesOccupied, 
                                DWORD *pnCellsOccupied )
{
    return( SUCCEEDED( m_Pool.GetInfo( pnTotalPages, pnPagesOccupied, pnCellsOccupied ) ) );
}


/////////////////////////////////////////////////////////////////////////////
// This signs a cell pool with a file name/line number. This allows us to
// easily read a cell dump log and figure out which cell pool is which.
#if DBG
#define DEBUG_CELL_POOL( pool )  do { \
    if ( NULL != ( pool ) ) \
    { \
        if ( NULL != ( pool )->m_pCelltracker ) \
        { \
            ( pool )->m_pCelltracker->SignPoolImpl( __FILE__, __LINE__ ); \
        } \
    } \
} while( 0 )

#define AcquireElement() AcquireElementDebug( __FILE__, __LINE__ )

#else
#define DEBUG_CELL_POOL( pool )
#endif

#endif // TCELPOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\tptrarr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File:       tptrarr.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef TPTRARR_H
#define TPTRARR_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "TSparseBlock.h"

//////////////////////////////////////////////////////////////////////////////
template< class Type, int ValsPerBlock = 20 >
class CTPtrArray : protected CTSparseBlock< DWORD, Type *, ValsPerBlock >
{
public:
    CTPtrArray()
    {
        m_cElements = 0;

        SetDefaultValue( NULL );
    }

    //
    // Clean up
    //
    void RemoveAll()
    {
        FreeList();
        m_cElements = 0;
    }

    //
    // Accessing existing elements
    //
    DWORD GetSize() const
    {
        return( m_cElements );
    }

    Type *operator[]( DWORD nIndex ) const
    {
        Type *pElement;
        
        return( GetAt( nIndex, &pElement ) ? pElement : NULL );
    }

    BOOL GetAt( DWORD nIndex, Type **ppElement ) const
    {
        *ppElement = NULL;

        if( nIndex >= m_cElements )
        {
            return( FALSE );
        }

        HRESULT hr;

        hr = GetValue( nIndex, ppElement );

        if( FAILED( hr ) )
        {
            *ppElement = NULL;
        }

        return( SUCCEEDED( hr ) );
    }

    BOOL SetAt( DWORD nIndex, Type *pNewElement )
    {
        if( nIndex >= m_cElements )
        {
            return( FALSE );
        }

        return( SetAtGrow( nIndex, pNewElement ) );
    }

    //
    // Appending elements
    //
    BOOL Add( Type *pNewElement, DWORD *pdwIndex )
    {
        if( NULL != pdwIndex )
        {
            *pdwIndex = m_cElements;
        }

        HRESULT hr;

        hr = SetValue( m_cElements, pNewElement );

        if( SUCCEEDED( hr ) )
        {
            m_cElements++;
        }

        return( SUCCEEDED( hr ) );
    }

    BOOL SetAtGrow( DWORD nIndex, Type *pNewElement )
    {
        HRESULT hr;

        hr = SetValue( nIndex, pNewElement );

        if( SUCCEEDED( hr ) )
        {
            m_cElements = max( m_cElements, nIndex + 1 );
        }

        return( SUCCEEDED( hr ) );
    }

    //
    // Expensive operations that move elements around
    //
    BOOL InsertAt( DWORD nIndex, Type *pNewElement )
    {
        HRESULT hr;

        hr = InsertValue( nIndex, pNewElement );

        if( SUCCEEDED( hr ) )
        {
            m_cElements = max( m_cElements + 1, nIndex + 1 );
        }

        return( SUCCEEDED( hr ) );
    }

    BOOL RemoveAt( DWORD nIndex, DWORD nCount = 1 )
    {
        if( 0 == nCount )
        {
            return( TRUE );
        }

        if( nIndex + nCount > m_cElements )
        {
            return( FALSE );
        }

        HRESULT hr = S_OK;

        for( DWORD i = 0; i < nCount; i++ )
        {
            hr = RemoveValue( nIndex );

            if( SUCCEEDED( hr ) )
            {
                m_cElements--;
            }
            else
            {
                break;
            }
        }

        return( SUCCEEDED( hr ) );
    }

    //
    // Very expensive brute force copy of all array elements
    //
    BOOL Copy( const CTPtrArray& src )
    {
        RemoveAll();

        BOOL fOk = TRUE;
        DWORD cSrcElements = src.GetSize();

        for( DWORD i = 0; i < cSrcElements; i++ )
        {
            fOk = Add( src[ i ], NULL );

            if( !fOk )
            {
                break;
            }
        }

        return( fOk );
    }


    //
    // For compatibility with the old implementation of tptrarr.h
    // We only implement the case where nNewSize is zero.
    //
    BOOL SetSize( DWORD nNewSize, DWORD nGrowBy = 0xffffffff )
    {
        if( 0 != nNewSize )
        {
            return( S_OK );
        }

        Type* val;

        if( SUCCEEDED( GetDefaultValue( &val ) ) )
        {
            FreeList();
            SetDefaultValue( val );
        }

        else
        {
            FreeList();
        }

        return( S_OK );
    }

protected:
    DWORD   m_cElements;
};


#endif  // TPTRARR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\TSparseBlock.h ===
#ifndef TSPARSEBLOCK_H_INCLUDED
#define TSPARSEBLOCK_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <assert.h>

//////////////////////////////////////////////////////////////////////////////
//
// CTSparseBlock - a template class that facilitates building efficient sparse
//                 arrays of arbitrary values that are indexed by an integer
//                 (which can also be 1-8 bytes).
//
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero = TRUE>
class CTSparseBlock
{
public:
    typedef CTSparseBlock<IType, VType, ValsPerBlock, InitToZero> BlockType;

    CTSparseBlock()
    {
        m_FirstIndex = 0;
        m_dwFlags = 0;
        ZeroMemory( m_bSetValues, sizeof( m_bSetValues ) );
        if( InitToZero )
        {
            ZeroMemory( m_Values, sizeof( m_Values ) );
        }
        m_pNext = NULL; 
    }

    ~CTSparseBlock()
    {
        if( 0 == m_FirstIndex )
        {
            //
            // If this is the root block clean up all allocated pages
            //
            FreeList( FALSE );
        }
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // Methods to manipulate a linked list of sparse blocks.
    // You call them on the root block of the linked list (which may be
    // a class member or a stack value).
    //

    //
    // Gets a copy of the current default value, if set
    //
    HRESULT GetDefaultValue( VType *pValue ) const;

    //
    // Sets the default value
    //
    HRESULT SetDefaultValue( VType value );

    //
    // Gets a pointer to a value given its index - fails if value
    // hasn't been explicitly set
    //
    HRESULT GetPointer( IType index, VType **ppValue );

    //
    // Gets a copy of a value given its index - works with default values
    //
    HRESULT GetValue( IType index, VType *pValue ) const;

    //
    // Sets an explicit value for a given index - overrides default value
    //
    HRESULT SetValue( IType index, VType value );

    //
    // Inserts an explicit value at a given index - overrides default value.
    // This operation can be very expensive
    //
    HRESULT InsertValue( IType index, VType value );

    //
    // Removes a value at the given index.  This operation can be very expensive
    //
    HRESULT RemoveValue( IType index );

    //
    // Cleans up all allocated blocks, resets all values to their unset state,
    // and clears the default value
    //
    HRESULT FreeList( BOOL fFreeRoot = FALSE );

protected:
    //////////////////////////////////////////////////////////////////////////
    //
    // Virtual methods to allocate and release sparse blocks - derived classes
    // can override these to allocate more efficiently (e.g. from a pool)
    //
    virtual HRESULT CreateBlock( BlockType **ppNewBlock );

    virtual HRESULT FreeBlock( BlockType *pBlock );

private:
    //////////////////////////////////////////////////////////////////////////
    //
    // Static arrays and helper methods
    //
    static BYTE s_bLeftBitMasks[ 9 ];
    static BYTE s_bRightBitMasks[ 9 ];
    static BYTE s_bSingleBitMasks[ 8 ];

    BOOL IsSet( DWORD valIndex ) const
    {
        return( 0 != ( m_bSetValues[ valIndex / 8 ] &
                       s_bSingleBitMasks[ valIndex % 8 ] ) );
    }

protected:
    IType       m_FirstIndex;

    enum SparseBlockFlags
    {
        DEFAULT_VALUE_SET = 0x01
    };

    DWORD       m_dwFlags;
    VType       m_DefValue;
    BYTE        m_bSetValues[ ( ValsPerBlock + 7 ) / 8 ];
    VType       m_Values[ ValsPerBlock ];
    BlockType  *m_pNext;    
};


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
BYTE CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::s_bLeftBitMasks[ 9 ] =
{
    0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF
};


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
BYTE CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::s_bRightBitMasks[ 9 ] =
{
    0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF
};


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
BYTE CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::s_bSingleBitMasks[ 8 ] =
{
    0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
};


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
HRESULT CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::CreateBlock( BlockType **ppNewBlock )
{
    *ppNewBlock = ::new BlockType;

    return( ( NULL != *ppNewBlock ) ? S_OK : E_OUTOFMEMORY );
}


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
HRESULT CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::FreeBlock( BlockType *pBlock )
{
    //
    // Validate arguments
    //
    if( NULL == pBlock )
    {
        return( E_INVALIDARG );
    }

    ::delete pBlock;
    pBlock = NULL;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
HRESULT CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::GetDefaultValue( VType *pValue ) const
{
    //
    // Validate arguments
    //
    if( NULL == pValue )
    {
        return( E_INVALIDARG );
    }

    if( !( m_dwFlags & DEFAULT_VALUE_SET ) )
    {
        return( E_FAIL );
    }

    *pValue = m_DefValue;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
HRESULT CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::SetDefaultValue( VType value )
{
    m_DefValue = value;
    m_dwFlags |= DEFAULT_VALUE_SET;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
HRESULT CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::GetPointer(
                                                        IType index,
                                                        VType **ppValue )
{
    //
    // Validate arguments
    //
    if( NULL == ppValue )
    {
        return( E_INVALIDARG );
    }
    *ppValue = NULL;

    //
    // Be somewhat sure that this is the root block
    //
    assert( 0 == m_FirstIndex );

    BlockType *pBlock = this;

    HRESULT hr = E_FAIL;

    while( NULL != pBlock )
    {
        if( ( index >= pBlock->m_FirstIndex ) &&
            ( index < pBlock->m_FirstIndex + ValsPerBlock ) )
        {
            //
            // This is the block we want - see if the value has been explicitly set
            //
            DWORD valIndex = index - pBlock->m_FirstIndex;

            if( pBlock->IsSet( valIndex ) )
            {
                //
                // It's OK to give out a pointer to explicitly set values
                //
                *ppValue = &pBlock->m_Values[ valIndex ];

                hr = S_OK;            
            }

            break;
        }

        //
        // Move on to the next block in the linked list
        //
        pBlock = pBlock->m_pNext;
    }

    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
HRESULT CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::GetValue(
                                                        IType index,
                                                        VType *pValue ) const
{
    //
    // Validate arguments
    //
    if( NULL == pValue )
    {
        return( E_INVALIDARG );
    }

    //
    // Be somewhat sure that this is the root block
    //
    assert( 0 == m_FirstIndex );

    const BlockType *pBlock = this;

    HRESULT hr = E_FAIL;

    while( NULL != pBlock )
    {
        if( ( index >= pBlock->m_FirstIndex ) &&
            ( index < pBlock->m_FirstIndex + ValsPerBlock ) )
        {
            //
            // This is the block we want - see if the value has been explicitly set
            //
            DWORD valIndex = index - pBlock->m_FirstIndex;

            if( pBlock->IsSet( valIndex ) )
            {
                *pValue = pBlock->m_Values[ valIndex ];

                hr = S_OK;
            }
            break;
        }

        //
        // Move on to the next block in the linked list
        //
        pBlock = pBlock->m_pNext;
    }

    //
    // We return the default value on all failures (if one has been set)
    //
    if( FAILED( hr ) && ( m_dwFlags & DEFAULT_VALUE_SET ) )
    {
        *pValue = m_DefValue;

        hr = S_OK;
    }

    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
HRESULT CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::SetValue(
                                                        IType index,
                                                        VType value )
{
    //
    // Be somewhat sure that this is the root block
    //
    assert( 0 == m_FirstIndex );

    BlockType *pPrevBlock = NULL;
    BlockType *pBlock = this;

    BOOL fNeedToMakeBlock = TRUE;

    while( NULL != pBlock )
    {
        if( index < pBlock->m_FirstIndex )
        {
            //
            // We need a new sparse block between the previous one and
            // this one
            //
            break;
        }

        if( index < pBlock->m_FirstIndex + ValsPerBlock )
        {
            //
            // We found the right block
            //
            fNeedToMakeBlock = FALSE;
            break;
        }

        //
        // Try the next block in the linked list
        //
        pPrevBlock = pBlock;
        pBlock = pBlock->m_pNext;
    }

    if( fNeedToMakeBlock )
    {
        //
        // Add a new sparse block if necessary
        //
        assert( pBlock != this );
        assert( NULL != pPrevBlock );

        HRESULT hr;
        BlockType *pNewBlock = NULL;

        hr = CreateBlock( &pNewBlock );

        if( FAILED( hr ) )
        {
            return( hr );
        }

        //
        // Set the base index of the new block
        //
        pNewBlock->m_FirstIndex = ValsPerBlock * ( index / ValsPerBlock );

        //
        // Insert the new block in our linked list
        //
        assert( pPrevBlock->m_pNext == pBlock );

        if ( NULL != pPrevBlock )
        {
            pPrevBlock->m_pNext = pNewBlock;
        }
        pNewBlock->m_pNext = pBlock;

        pBlock = pNewBlock;
    }

    //
    // This is the block we want - simply set the value
    //
    assert( index >= pBlock->m_FirstIndex );
    assert( index < pBlock->m_FirstIndex + ValsPerBlock );
    DWORD valIndex = index - pBlock->m_FirstIndex;

    pBlock->m_bSetValues[ valIndex / 8 ] |= s_bSingleBitMasks[ valIndex % 8 ];
    pBlock->m_Values[ valIndex ] = value;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
HRESULT CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::InsertValue(
                                                        IType index,
                                                        VType value )
{
    //
    // Be somewhat sure that this is the root block
    //
    assert( 0 == m_FirstIndex );

    //
    // Look for the containing (or next) block
    //
    BlockType *pBlock = this;

    while( NULL != pBlock )
    {
        if( index < pBlock->m_FirstIndex + ValsPerBlock )
        {
            break;
        }

        pBlock = pBlock->m_pNext;
    }

    //
    // Process all remaining blocks in the list
    //
    HRESULT hr = S_OK;
    BOOL fBumpedValue = FALSE;
    DWORD iBumpedValue = 0;
    VType valBumped = m_DefValue;

    while( NULL != pBlock )
    {
        BOOL fContainingBlock = FALSE;
        DWORD iInsert = 0;

        if( index >= pBlock->m_FirstIndex )
        {
            fContainingBlock = TRUE;
            iInsert = index - pBlock->m_FirstIndex;
        }

        //
        // Save the last value in this block as the "next bumped" value
        // if it is set
        //
        BOOL fNextBumpedValue = FALSE;
        DWORD iNextBumpedValue = 0;
        VType valNextBumped = m_DefValue;

        if( pBlock->IsSet( ValsPerBlock - 1 ) )
        {
            fNextBumpedValue = TRUE;
            iNextBumpedValue = pBlock->m_FirstIndex + ValsPerBlock;
            valNextBumped = pBlock->m_Values[ ValsPerBlock - 1 ];
        }

        //
        // Move all of the items past the insert point up by one slot
        //
        MoveMemory( 
                &pBlock->m_Values[ iInsert + 1 ],
                &pBlock->m_Values[ iInsert ],
                ( ValsPerBlock - 1 - iInsert ) * sizeof( VType ) );

        //
        // Save the first few value bits (to restore later)
        //
        int iValueByte = iInsert / 8;
        BYTE bSave = pBlock->m_bSetValues[ iValueByte ];

        //
        // Shift all of the affected value set bits left by one
        //
        for( int i = sizeof( pBlock->m_bSetValues ) - 1; i >= iValueByte; i-- )
        {
            pBlock->m_bSetValues[ i ] >>= 1;

            //
            // Zero any bits that get shifted beyond the logical end of this block
            //
            if( i == sizeof( pBlock->m_bSetValues ) - 1 )
            {
                BYTE cBits = 8 - (BYTE)( ValsPerBlock % 8 );

                pBlock->m_bSetValues[ i ] &= s_bLeftBitMasks[ cBits ];
            }

            //
            // Carry in the rightmost bit of the previous byte
            //
            if( ( i > iValueByte ) &&
                ( 0 != ( pBlock->m_bSetValues[ i - 1 ] & 1 ) ) )
            {
                pBlock->m_bSetValues[ i ] |= 0x80;
            }
        }

        //
        // Restore all of the bits before the removed index in a containing block
        //
        BYTE cRestoreBits = (BYTE)( iInsert % 8 );

        if( fContainingBlock && ( cRestoreBits > 0 ) )
        {
            pBlock->m_bSetValues[ iValueByte ] &= s_bRightBitMasks[ 8 - cRestoreBits ];

            pBlock->m_bSetValues[ iValueByte ] |= ( bSave & s_bLeftBitMasks[ cRestoreBits ] );
        }

        //
        // Set the last bumped value (if any) into its new location.
        // This may create a new block if this block is not contiguous with the
        // previous one.
        //
        if( fBumpedValue )
        {
            hr = SetValue( iBumpedValue, valBumped );

            if( FAILED( hr ) )
            {
                break;
            }

            fBumpedValue = FALSE;
        }

        //
        // Shift the "next bumped" value into the bumped value
        //
        if( fNextBumpedValue )
        {
            fBumpedValue = TRUE;
            iBumpedValue = iNextBumpedValue;
            valBumped = valNextBumped;
        }

        pBlock = pBlock->m_pNext;
    }

    //
    // Set the value being inserted into its proper location
    //
    if( SUCCEEDED( hr ) )
    {
        hr = SetValue( index, value );
    }

    //
    // Set the final bumped value (if any) into its new location
    //
    if( SUCCEEDED( hr ) && fBumpedValue )
    {
        hr = SetValue( iBumpedValue, valBumped );
    }

    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
HRESULT CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::RemoveValue( IType index )
{
    //
    // Be somewhat sure that this is the root block
    //
    assert( 0 == m_FirstIndex );

    //
    // Look for the containing (or next) block
    //
    BlockType *pBlock = this;

    while( NULL != pBlock )
    {
        if( index < pBlock->m_FirstIndex + ValsPerBlock )
        {
            break;
        }

        pBlock = pBlock->m_pNext;
    }

    //
    // Process all remaining blocks in the list
    //
    HRESULT hr = S_OK;

    while( NULL != pBlock )
    {
        BOOL fContainingBlock = FALSE;
        DWORD iRemove = 0;

        if( index >= pBlock->m_FirstIndex )
        {
            fContainingBlock = TRUE;
            iRemove = index - pBlock->m_FirstIndex;
        }

        //
        // Shift the first value in a non-containing block backwards if set
        //
        if( !fContainingBlock && pBlock->IsSet( 0 ) )
        {
            hr = SetValue( pBlock->m_FirstIndex - 1, pBlock->m_Values[ 0 ] );

            if( FAILED( hr ) )
            {
                break;
            }
        }

        //
        // Move all of the values past the item to remove down by one slot
        //
        MoveMemory(
                &pBlock->m_Values[ iRemove ],
                &pBlock->m_Values[ iRemove + 1 ],
                ( ValsPerBlock - 1 - iRemove ) * sizeof( VType ) );

        //
        // Save the first few value bits (to restore later)
        //
        DWORD iValueByte = iRemove / 8;
        BYTE bSave = pBlock->m_bSetValues[ iValueByte ];

        //
        // Shift all of the affected value set bits left by one
        //
        for( DWORD i = iValueByte; i < sizeof( pBlock->m_bSetValues ); i++ )
        {
            pBlock->m_bSetValues[ i ] <<= 1;

            //
            // Carry in the leftmost bit of the next byte
            //
            if( ( i < ( sizeof( pBlock->m_bSetValues ) - 1 ) ) &&
                ( 0 != ( pBlock->m_bSetValues[ i + 1 ] & 0x80 ) ) )
            {
                pBlock->m_bSetValues[ i ] |= 1;
            }
        }

        //
        // Restore all of the bits before the removed index in a containing block
        //
        BYTE cRestoreBits = (BYTE)( iRemove % 8 );

        if( fContainingBlock && ( cRestoreBits > 0 ) )
        {
            pBlock->m_bSetValues[ iValueByte ] &= s_bRightBitMasks[ 8 - cRestoreBits ];

            pBlock->m_bSetValues[ iValueByte ] |= ( bSave & s_bLeftBitMasks[ cRestoreBits ] );
        }

        pBlock = pBlock->m_pNext;
    }

    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
template <class IType, class VType, int ValsPerBlock, BOOL InitToZero>
HRESULT CTSparseBlock<IType, VType, ValsPerBlock, InitToZero>::FreeList( BOOL fFreeRoot /* = FALSE */ )
{
    //
    // Be somewhat sure that this is the root block
    //
    assert( 0 == m_FirstIndex );

    //
    // Point at the first block to be freed
    //
    BlockType *pBlock = this;

    if( !fFreeRoot )
    {
        m_FirstIndex = 0;
        m_dwFlags &= ~DEFAULT_VALUE_SET;
        ZeroMemory( m_bSetValues, sizeof( m_bSetValues ) );
        if( InitToZero )
        {
            ZeroMemory( m_Values, sizeof( m_Values ) );
        }

        pBlock = m_pNext;
        m_pNext = NULL; 
    }

    HRESULT hr = S_OK;

    while( NULL != pBlock )
    {
        //
        // Move on to the next block in the linked list
        //
        BlockType *pFreeBlock = pBlock;

        pBlock = pBlock->m_pNext;

        //
        // Free a block
        //
        hr = FreeBlock( pFreeBlock );

        if( FAILED( hr ) )
        {
            break;
        }
    }

    return( hr );
}

#endif  // TSPARSEBLOCK_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vbckhash.cpp ===
#include "dstructp.h"


#if DBG
extern BOOL g_fUseNewDelete;
#endif

//////////////////////////////////////////////////////////////////////////////
CVBucketHash::CVBucketHash()
{
    m_pTable = NULL;
    m_dwTableSize = 0;
    m_dwEntries = 0;
    m_pNodePool = NULL;
    m_pfnHash = NULL;
}

//////////////////////////////////////////////////////////////////////////////
CVBucketHash::~CVBucketHash()
{
#if DBG 
    if( ( g_fUseNewDelete ) && ( 0 != m_dwEntries ) )
    {
        DWORD dwKeyDummy = 0;
        void * pValueDummy = NULL;
        
        while( SUCCEEDED(Remove( dwKeyDummy, &pValueDummy )) )
        {
            ;
        }
    }
#endif

    delete [] m_pTable;
    delete m_pNodePool;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CVBucketHash::Initialize( DWORD dwTableSize, PFNHASHINGFUNCTION pfnHashingFunction, DWORD dwParam )
{
    if( m_pTable )
    {
        return( E_UNEXPECTED );   
    }
    if( !dwTableSize )
    {
        return( E_INVALIDARG );
    }

    m_pTable = new NODE *[ dwTableSize ];
    if( !m_pTable )
    {
        return( E_OUTOFMEMORY );
    }

    ZeroMemory( m_pTable, ( sizeof(NODE *) * dwTableSize ) );

    m_pNodePool = new CVCellPool;
    if( !m_pNodePool ||
        FAILED( m_pNodePool->Initialize( sizeof(NODE), dwTableSize, 1, FALSE ) ) )
    {
        delete m_pNodePool;
        m_pNodePool = NULL;
        return( E_OUTOFMEMORY );
    }

    m_pfnHash = pfnHashingFunction;
    m_dwTableSize = dwTableSize;
    m_dwEntries = 0;
    m_dwHashParam = dwParam;
    m_pCursor = NULL;

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CVBucketHash::Insert( const DWORD& Key, const void *pValue )
{
    //
    // Find a node to use in the bucket
    //
    NODE *pNew;

    if( FAILED( m_pNodePool->AcquireCell( (void**)&pNew ) ) )
    {
        return( E_OUTOFMEMORY );
    }

    pNew->Key = Key;
    pNew->pValue = (void*)pValue;

    //
    // Find the right bucket to use
    //
    DWORD dwHash = Hash( Key );

    pNew->pNext = m_pTable[dwHash];
    m_pTable[dwHash] = pNew;

    m_dwEntries++;

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
DWORD CVBucketHash::RemoveAll()
{
    if( !m_pTable )
    {
        return( 0 );
    }

    m_pCursor = NULL;
    
    if( FAILED( m_pNodePool->Initialize( sizeof(NODE), m_dwTableSize, 1, FALSE ) ) )
    {
        delete m_pNodePool;
        m_pNodePool = NULL;
        return( 0 );
    }

    ZeroMemory( m_pTable, ( sizeof(NODE *) * m_dwTableSize ) );

    DWORD dwRemoved = m_dwEntries;
    m_dwEntries = 0;

    return( dwRemoved );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CVBucketHash::Find( const DWORD& Key, void **ppValue )
{
    if( !m_pTable )
    {
        return( E_UNEXPECTED );
    }

    DWORD dwHash = Hash( Key );

    NODE *pNode = m_pTable[dwHash];

    while( pNode )
    {
        if( pNode->Key == Key )
        {
            *ppValue = pNode->pValue;
            break;
        }
        pNode = pNode->pNext;
    }

    return( pNode ? S_OK : E_FAIL );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CVBucketHash::Remove( const DWORD& Key, void **ppValue )
{
    if( !m_pTable )
    {
        return( E_UNEXPECTED );
    }

    DWORD dwHash = Hash( Key );

    NODE *pPrev = NULL;
    NODE *pNode = m_pTable[dwHash];

    while( pNode )
    {
        if( pNode->Key == Key )
        {
            m_pCursor = NULL;
            *ppValue = pNode->pValue;
            m_dwEntries--;

            if( pPrev )
            {
                pPrev->pNext = pNode->pNext;
            }
            else
            {
                m_pTable[dwHash] = pNode->pNext;
            }

            m_pNodePool->ReleaseCell( (void*)pNode );
            break;
        }

        pPrev = pNode;
        pNode = pNode->pNext;
    }

    return( pNode ? S_OK : E_FAIL );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVBucketHash::GetFirst( DWORD& Key, void **ppValue )
{  
    if( !m_pTable )
    {
        return( FALSE );
    }

    BOOL fLookingForNext = FALSE;

    for( DWORD i = 0; i < m_dwTableSize; i++ )
    {
        if( NULL == m_pTable[i] )
        {
            continue;
        }
        if( fLookingForNext )
        {
            m_pCursor = m_pTable[i];
            return( TRUE );
        }
        
        Key = m_pTable[i]->Key;
        *ppValue = m_pTable[i]->pValue;

        m_pCursor = m_pTable[i]->pNext;

        if( !m_pCursor )
        {
            fLookingForNext = TRUE;
            continue;
        }

        return( TRUE );
    }

    return( fLookingForNext );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVBucketHash::GetNext( DWORD& Key, void **ppValue )
{
    if( !m_pTable || !m_pCursor )
    {
        return( FALSE );
    }

    Key = m_pCursor->Key;
    *ppValue = m_pCursor->pValue;

    m_pCursor = m_pCursor->pNext;

    if( !m_pCursor )
    {
        for( DWORD i = Hash( Key ) + 1; i < m_dwTableSize; i++ )
        {
            if( m_pTable[i] )
            {
                m_pCursor = m_pTable[i];
                break;
            }
        }
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vavltable.cpp ===
//
// This module is adapted from ntos\rtl\avltable.c
//
#include "dstructp.h"


#ifdef _DEBUG

//
// Build a table of the best case efficiency of a balanced binary tree, holding the
// most possible nodes that can possibly be held in a binary tree with a given number
// of levels.  The answer is always (2**n) - 1.
//
DWORD BestCaseFill[33] =
{
    0,          1,          3,          7,          0xf,        0x1f,       0x3f,       0x7f,
    0xff,       0x1ff,      0x3ff,      0x7ff,      0xfff,      0x1fff,     0x3fff,     0x7fff,
    0xffff,     0x1ffff,    0x3ffff,    0x7ffff,    0xfffff,    0x1fffff,   0x3fffff,   0x7fffff,
    0xffffff,   0x1ffffff,  0x3ffffff,  0x7ffffff,  0xfffffff,  0x1fffffff, 0x3fffffff, 0x7fffffff,
    0xffffffff
};

//
// Build a table of the worst case efficiency of a balanced binary tree, holding the
// fewest possible nodes that can possibly be contained in a balanced binary tree with
// the given number of levels.  After the first two levels, each level n is obviously
// occupied by a root node, plus one subtree the size of level n-1, and another subtree
// which is the size of n-2, i.e.:
//
//     WorstCaseFill[n] = 1 + WorstCaseFill[n-1] + WorstCaseFill[n-2]
//
// The efficiency of a typical balanced binary tree will normally fall between the two
// extremes, typically closer to the best case.  Note however that even with the worst
// case, it only takes 32 compares to find an element in a worst case tree populated with
// ~3.5M nodes.  Unbalanced trees and splay trees, on the other hand, can and will sometimes
// degenerate to a straight line, requiring on average n/2 compares to find a node.
//
DWORD WorstCaseFill[33] =
{
    0,          1,          2,          4,          7,          12,         20,         33,
    54,         88,         143,        232,        376,        609,        986,        1596,
    2583,       4180,       6764,       10945,      17710,      28656,      46367,      75024,
    121392,     196417,     317810,     514228,     832039,     1346268,    2178308,    3524577,
    5702886
};

#endif


//////////////////////////////////////////////////////////////////////////////
//
// This structure is the header for a generic table entry.
// Align this structure on a 8 byte boundary so the user data is correctly aligned.
//
#pragma pack(push,8)

typedef struct _TABLE_ENTRY_HEADER
{
    AVL_TREE_NODE Node;
    LONGLONG UserData;

}   TABLE_ENTRY_HEADER, *PTABLE_ENTRY_HEADER;

#pragma pack(pop)

#define GetDataPtr( pNodeToExamine ) \
            &((PTABLE_ENTRY_HEADER) pNodeToExamine)->UserData


//////////////////////////////////////////////////////////////////////////////
//
// The default matching function which matches everything.
//
AVL_MATCH_RESULT AVLAPI MatchAll( struct _AVL_TABLE *, void *, void * )
{
    return( AvlMatched );
}


//////////////////////////////////////////////////////////////////////////////
BOOL IsLeftChild( AVL_TREE_NODE *pNode )
{
    return( pNode == ( pNode->pParent->pLeftChild ) );
}


//////////////////////////////////////////////////////////////////////////////
BOOL IsRightChild( AVL_TREE_NODE *pNode )
{
    return( pNode == ( pNode->pParent->pRightChild ) );
}


//////////////////////////////////////////////////////////////////////////////
//
// FindNodeOrParent is used by all routines to locate a node in the tree.
// It will find and return the node with the given key, or if that node
// is not found it will return a pointer to the parent node.
//
// AVL_SEARCH_RESULT return value notes:
//
//      AvlEmptyTree    -> the tree was empty, *ppNodeOrParent is not altered.
//
//      AvlFoundNode    -> a node matching the given key was found, and
//                         *ppNodeOrParent points to that node.
//
//      AvlInsertAsLeft -> a matching node was not found, *ppNodeOrParent points
//                         to the node that would be the parent, and this key
//                         value would be the parent's left child.
//
//      AvlInsertAsRight-> a matching node was not found, *ppNodeOrParent points
//                         to the node that would be the parent, and this key
//                         value would be the parent's right child.
//
AVL_SEARCH_RESULT FindNodeOrParent(
                        AVL_TABLE *pTable,
                        void *pvBuffer,
                        AVL_TREE_NODE **ppNodeOrParent )
{
    if( AvlIsTableEmpty( pTable ) )
    {
        return( AvlEmptyTree );
    }

    AVL_TREE_NODE *pNodeToExamine = pTable->BalancedRoot.pRightChild;
    AVL_COMPARE_RESULT Result;

#ifdef _DEBUG
    DWORD dwNumCompares = 0;
#endif

    while( TRUE )
    {
        //
        // Compare the buffer with the key in the current tree element.
        //
        Result = pTable->pfnCompareRoutine(
                                    pTable,
                                    pvBuffer,
                                    GetDataPtr( pNodeToExamine ) );

        //
        // Make sure the depth of tree is correct.
        //
        assert( ++dwNumCompares <= pTable->dwTreeDepth );

        //
        // Navigate through the tree appropriately
        //
        if( AvlLessThan == Result )
        {
            if( NULL != pNodeToExamine->pLeftChild )
            {
                pNodeToExamine = pNodeToExamine->pLeftChild;
            }
            else
            {
                *ppNodeOrParent = pNodeToExamine;

                return( AvlInsertAsLeft );
            }
        }
        else if( AvlGreaterThan == Result )
        {
            if( NULL != pNodeToExamine->pRightChild )
            {
                pNodeToExamine = pNodeToExamine->pRightChild;
            }
            else
            {
                *ppNodeOrParent = pNodeToExamine;

                return( AvlInsertAsRight );
            }
        }
        else
        {
            assert( AvlEqual == Result );

            *ppNodeOrParent = pNodeToExamine;

            return( AvlFoundNode );
        }
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// This routine performs the fundamental adjustment required for balancing
// the binary tree during insert and delete operations.  Simply put, the designated
// node is promoted in such a way that it rises one level in the tree and its parent
// drops one level in the tree, becoming now the child of the designated node.
// Generally the path length to the subtree "opposite" the original parent.  Balancing
// occurs as the caller chooses which nodes to promote according to the balanced tree
// algorithms from Knuth.
//
// Note that the pointer to the root node of the tree is assumed to be contained in a
// AVL_TREE_NODE structure itself, to allow the algorithms below to change the root
// of the tree without checking for special cases.  Note also that this is an internal
// routine, and the caller guarantees that it never requests to promote the root itself.
//
// This routine only updates the tree links; the caller must update the balance factors
// as appropriate.
//
void PromoteNode( AVL_TREE_NODE *pChild )
{
    AVL_TREE_NODE *pParent = pChild->pParent;
    AVL_TREE_NODE *pGrandParent = pParent->pParent;

    //
    // Handle promotion based on whether this is a left or right child
    //
    if( pParent->pLeftChild == pChild )
    {
        //
        // This promotion looks like this:
        //
        //          G           G
        //          |           |
        //          P           C
        //         / \   =>    / \
        //        C   z       x   P
        //       / \             / \
        //      x   y           y   z
        //

        pParent->pLeftChild = pChild->pRightChild;

        if( NULL != pParent->pLeftChild )
        {
            pParent->pLeftChild->pParent = pParent;
        }

        pChild->pRightChild = pParent;

        //
        // Fall through to update parent and G <-> C relationship in common code.
        //
    }
    else
    {
        assert( pParent->pRightChild == pChild );

        //
        // This promotion looks like this:
        //
        //        G               G
        //        |               |
        //        P               C
        //       / \     =>      / \
        //      x   C           P   z
        //         / \         / \
        //        y   z       x   y
        //

        pParent->pRightChild = pChild->pLeftChild;

        if( NULL != pParent->pRightChild )
        {
            pParent->pRightChild->pParent = pParent;
        }

        pChild->pLeftChild = pParent;
    }

    //
    // Update parent of P, for either case above.
    //
    pParent->pParent = pChild;

    //
    // Finally update G <-> C links for either case above.
    //
    if( pGrandParent->pLeftChild == pParent )
    {
        pGrandParent->pLeftChild = pChild;
    }
    else
    {
        assert( pGrandParent->pRightChild == pParent );

        pGrandParent->pRightChild = pChild;
    }

    pChild->pParent = pGrandParent;
}


//////////////////////////////////////////////////////////////////////////////
//
// This routine performs a rebalance around the input node S, for which the
// Balance factor has just effectively become +2 or -2.  When called, the
// Balance factor still has a value of +1 or -1, but the respective longer
// side has just become one longer as the result of an insert or delete operation.
//
// This routine effectively implements steps A7.iii (test for Case 1 or Case 2) and
// steps A8 and A9 of Knuths balanced insertion algorithm, plus it handles Case 3
// identified in the delete section, which can only happen on deletes.
//
// The trick is, to convince yourself that while travling from the insertion point
// at the bottom of the tree up, that there are only these two cases, and that when
// traveling up from the deletion point, that there are just these three cases.
// Knuth says it is obvious!
//
// Note: returns TRUE if Case 3 was detected (causes delete algorithm to terminate).
//
BOOL RebalanceNode( AVL_TREE_NODE *pSNode )
{
    AVL_TREE_NODE *pRNode;
    AVL_TREE_NODE *pPNode;
    CHAR a;

    //
    // Capture which side is unbalanced.
    //
    a = pSNode->Balance;

    if( +1 == a )
    {
        pRNode = pSNode->pRightChild;
    }
    else
    {
        pRNode = pSNode->pLeftChild;
    }

    //
    // If the balance of R and S are the same (Case 1 in Knuth) then a single
    // promotion of R will do the single rotation.  (Step A8, A10)
    //
    // Here is a diagram of the Case 1 transformation, for a == +1 (a mirror
    // image transformation occurs when a == -1), and where the subtree
    // heights are h and h+1 as shown (++ indicates the node out of balance):
    //
    //                  |                   |
    //                  S++                 R
    //                 / \                 / \
    //               (h)  R+     ==>      S  (h+1)
    //                   / \             / \
    //                 (h) (h+1)       (h) (h)
    //
    // Note that on an insert we can hit this case by inserting an item in the
    // right subtree of R.  The original height of the subtree before the insert
    // was h+2, and it is still h+2 after the rebalance, so insert rebalancing may
    // terminate.
    //
    // On a delete we can hit this case by deleting a node from the left subtree
    // of S.  The height of the subtree before the delete was h+3, and after the
    // rebalance it is h+2, so rebalancing must continue up the tree.
    //
    if( pRNode->Balance == a )
    {
        PromoteNode( pRNode );

        pRNode->Balance = 0;
        pSNode->Balance = 0;

        return( FALSE );
    //
    // Otherwise, we have to promote the appropriate child of R twice (Case 2
    // in Knuth).  (Step A9, A10)
    //
    // Here is a diagram of the Case 2 transformation, for a == +1 (a mirror
    // image transformation occurs when a == -1), and where the subtree
    // heights are h and h-1 as shown.  There are actually two minor subcases,
    // differing only in the original balance of P (++ indicates the node out
    // of balance).
    //
    //                  |                   |
    //                  S++                 P
    //                 / \                 / \
    //                /   \               /   \
    //               /     \             /     \
    //             (h)      R-   ==>    S-      R
    //                     / \         / \     / \
    //                    P+ (h)     (h)(h-1)(h) (h)
    //                   / \
    //               (h-1) (h)
    //
    //
    //                  |                   |
    //                  S++                 P
    //                 / \                 / \
    //                /   \               /   \
    //               /     \             /     \
    //             (h)      R-   ==>    S       R+
    //                     / \         / \     / \
    //                    P- (h)     (h) (h)(h-1)(h)
    //                   / \
    //                 (h) (h-1)
    //
    // Note that on an insert we can hit this case by inserting an item in the
    // left subtree of R.  The original height of the subtree before the insert
    // was h+2, and it is still h+2 after the rebalance, so insert rebalancing may
    // terminate.
    //
    // On a delete we can hit this case by deleting a node from the left subtree
    // of S.  The height of the subtree before the delete was h+3, and after the
    // rebalance it is h+2, so rebalancing must continue up the tree.
    //
    }
    else if( pRNode->Balance == -a )
    {
        //
        // Pick up the appropriate child P for the double rotation (Link(-a,R)).
        //
        if( +1 == a )
        {
            pPNode = pRNode->pLeftChild;
        }
        else
        {
            pPNode = pRNode->pRightChild;
        }

        //
        // Promote him twice to implement the double rotation.
        //
        PromoteNode( pPNode );
        PromoteNode( pPNode );

        //
        // Now adjust the balance factors.
        //
        pRNode->Balance = 0;
        pSNode->Balance = 0;

        if( pPNode->Balance == a )
        {
            pSNode->Balance = -a;
        }
        else if( pPNode->Balance == -a )
        {
            pRNode->Balance = a;
        }

        pPNode->Balance = 0;

        return( FALSE );
    //
    // Otherwise this is Case 3 which can only happen on Delete (identical to Case 1 except
    // R->Balance == 0).  We do a single rotation, adjust the balance factors appropriately,
    // and return TRUE.  Note that the balance of S stays the same.
    //
    // Here is a diagram of the Case 3 transformation, for a == +1 (a mirror
    // image transformation occurs when a == -1), and where the subtree
    // heights are h and h+1 as shown (++ indicates the node out of balance):
    //
    //                  |                   |
    //                  S++                 R-
    //                 / \                 / \
    //               (h)  R      ==>      S+ (h+1)
    //                   / \             / \
    //                (h+1)(h+1)       (h) (h+1)
    //
    // This case can not occur on an insert, because it is impossible for a single insert to
    // balance R, yet somehow grow the right subtree of S at the same time.  As we move up
    // the tree adjusting balance factors after an insert, we terminate the algorithm if a
    // node becomes balanced, because that means the subtree length did not change!
    //
    // On a delete we can hit this case by deleting a node from the left subtree
    // of S.  The height of the subtree before the delete was h+3, and after the
    // rebalance it is still h+3, so rebalancing may terminate in the delete path.
    //
    }
    else
    {
        PromoteNode( pRNode );

        pRNode->Balance = -a;

        return( TRUE );
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// This routine deletes the specified node from the balanced tree, rebalancing
// as necessary.  If the NodeToDelete has at least one NULL child pointers, then
// it is chosen as the EasyDelete, otherwise a subtree predecessor or successor
// is found as the EasyDelete.  In either case the EasyDelete is deleted
// and the tree is rebalanced.  Finally if the NodeToDelete was different
// than the EasyDelete, then the EasyDelete is linked back into the tree in
// place of the NodeToDelete.
//
void DeleteNodeFromTree( AVL_TABLE *pTable, AVL_TREE_NODE *pNodeToDelete )
{
    AVL_TREE_NODE *pEasyDelete;
    AVL_TREE_NODE *pNode;
    CHAR a;

    if( ( NULL == pNodeToDelete->pLeftChild ) || ( NULL == pNodeToDelete->pRightChild ) )
    {
        //
        // If NodeToDelete has at least one NULL child pointer, then we can
        // delete it directly.
        //
        pEasyDelete = pNodeToDelete;
    }
    else if( pNodeToDelete->Balance >= 0 )
    {
        //
        // Otherwise, we may as well pick the longest side to delete from (if one is
        // is longer), as that reduces the probability that we will have to rebalance.
        // Pick up the subtree successor.
        //
        pEasyDelete = pNodeToDelete->pRightChild;

        while( NULL != pEasyDelete->pLeftChild )
        {
            pEasyDelete = pEasyDelete->pLeftChild;
        }
    }
    else
    {
        //
        // Pick up the subtree predecessor.
        //
        pEasyDelete = pNodeToDelete->pLeftChild;

        while( NULL != pEasyDelete->pRightChild )
        {
            pEasyDelete = pEasyDelete->pRightChild;
        }
    }

    //
    // Rebalancing must know which side of the first parent the delete occurred
    // on.  Assume it is the left side and otherwise correct below.
    //
    a = -1;

    if( NULL == pEasyDelete->pLeftChild )
    {
        //
        // Now we can do the simple deletion for the no left child case.
        //
        if( IsLeftChild( pEasyDelete ) )
        {
            pEasyDelete->pParent->pLeftChild = pEasyDelete->pRightChild;
        }
        else
        {
            pEasyDelete->pParent->pRightChild = pEasyDelete->pRightChild;
            a = 1;
        }

        if( NULL != pEasyDelete->pRightChild )
        {
            pEasyDelete->pRightChild->pParent = pEasyDelete->pParent;
        }
    }
    else
    {
        //
        // Now we can do the simple deletion for the no right child case,
        // plus we know there is a left child.
        //
        if( IsLeftChild( pEasyDelete ) )
        {
            pEasyDelete->pParent->pLeftChild = pEasyDelete->pLeftChild;
        }
        else
        {
            pEasyDelete->pParent->pRightChild = pEasyDelete->pLeftChild;
            a = 1;
        }

        if( NULL != pEasyDelete->pLeftChild )
        {
            pEasyDelete->pLeftChild->pParent = pEasyDelete->pParent;
        }
    }

    //
    // For delete rebalancing, set the balance at the root to 0 to properly
    // terminate the rebalance without special tests, and to be able to detect
    // if the depth of the tree actually decreased.
    //
    pTable->BalancedRoot.Balance = 0;
    pNode = pEasyDelete->pParent;

    //
    // Loop until the tree is balanced.
    //
    while( TRUE )
    {
        if( pNode->Balance == a )
        {
            //
            // First handle the case where the tree became more balanced.  Zero
            // the balance factor, calculate a for the next loop and move on to
            // the parent.
            //
            pNode->Balance = 0;
        }
        else if( pNode->Balance == 0 )
        {
            //
            // If this node is curently balanced, we can show it is now unbalanced
            // and terminate the scan since the subtree length has not changed.
            // (This may be the root, since we set Balance to 0 above!)
            //
            pNode->Balance = -a;

            //
            // If we shortened the depth all the way back to the root, then the tree
            // really has one less level.
            //
            if( pTable->BalancedRoot.Balance != 0 )
            {
                pTable->dwTreeDepth--;
            }

            break;
        }
        else
        {
            //
            // Otherwise we made the short side 2 levels less than the long side,
            // and rebalancing is required.  On return, some node has been promoted
            // to above node P.  If Case 3 from Knuth was not encountered, then we
            // want to effectively resume rebalancing from P's original parent which
            // is effectively its grandparent now.
            //
            // We are done if Case 3 was hit, i.e., the depth of this subtree is
            // now the same as before the delete.
            //
            if( RebalanceNode( pNode ) )
            {
                break;
            }

            pNode = pNode->pParent;
        }

        a = IsRightChild( pNode ) ? 1 : -1;

        pNode = pNode->pParent;
    }

    //
    // Finally, if we actually deleted a predecessor/successor of the NodeToDelete,
    // we will link him back into the tree to replace NodeToDelete before returning.
    // Note that NodeToDelete did have both child links filled in, but that may no
    // longer be the case at this point.
    //
    if( pNodeToDelete != pEasyDelete )
    {
        *pEasyDelete = *pNodeToDelete;

        if( IsLeftChild( pNodeToDelete ) )
        {
            pEasyDelete->pParent->pLeftChild = pEasyDelete;
        }
        else
        {
            assert( IsRightChild( pNodeToDelete ) );
            pEasyDelete->pParent->pRightChild = pEasyDelete;
        }

        if( NULL != pEasyDelete->pLeftChild )
        {
            pEasyDelete->pLeftChild->pParent = pEasyDelete;
        }

        if( NULL != pEasyDelete->pRightChild )
        {
            pEasyDelete->pRightChild->pParent = pEasyDelete;
        }
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to the successor of the input node within the entire
// balanced tree, or NULL if there is not a successor.
//
AVL_TREE_NODE *RealSuccessor( AVL_TREE_NODE *pNode )
{
    AVL_TREE_NODE *pNext;

    pNext = pNode->pRightChild;

    if( NULL != pNext )
    {
        //
        // First, check to see if there is a right subtree to the input node.
        // If there is then the real successor is the left most node in
        // the right subtree.  That is, find and return S in the following diagram:
        //
        //            pNode
        //               \
        //                .
        //               .
        //              .
        //             /
        //            S
        //             \
        //
        while( NULL != pNext->pLeftChild )
        {
            pNext = pNext->pLeftChild;
        }

        return( pNext );
    }

    //
    // We do not have a right child so check to see if we have a parent and if
    // so find the first ancestor that we are a left decendent of. That is,
    // find and return S in the following diagram:
    //
    //                 S
    //                /
    //               .
    //                .
    //                 .
    //                pNode
    //
    // Note that this code depends on how the BalancedRoot is initialized, which is
    // Parent points to self, and the RightChild points to an actual node which is
    // the root of the tree, and LeftChild does not point to self.
    //
    pNext = pNode;

    while( IsRightChild( pNext ) )
    {
        pNext = pNext->pParent;
    }

    if( IsLeftChild( pNext ) )
    {
        return( pNext->pParent );
    }

    //
    // Otherwise we do not have a real successor so we simply return NULL.
    //
    // This can only occur when we get back to the root, and we can tell
    // that since the Root is its own parent.
    //
    assert( pNext->pParent == pNext );

    return( NULL );
}


//////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to the predecessor of the input node within the entire
// balanced tree, or NULL if there is not a predecessor.
//
AVL_TREE_NODE *RealPredecessor( AVL_TREE_NODE *pNode )
{
    AVL_TREE_NODE *pPrev;

    pPrev = pNode->pLeftChild;

    if( NULL != pPrev )
    {
        //
        // First, check to see if there is a left subtree to the input node.
        // If there is then the real successor is the right most node in
        // the left subtree.  That is, find and return P in the following diagram:
        //
        //          pNode
        //           /
        //          .
        //           .
        //            .
        //             P
        //            /
        //
        while( NULL != pPrev->pRightChild )
        {
            pPrev = pPrev->pRightChild;
        }

        return( pPrev );
    }

    //
    // We do not have a left child so check to see if we have a parent and if
    // so find the first ancestor that we are a right decendent of. That is,
    // find and return P in the following diagram:
    //
    //                 P
    //                  \
    //                   .
    //                  .
    //                 .
    //               pNode
    //
    // Note that this code depends on how the BalancedRoot is initialized, which is
    // Parent points to self, and the RightChild points to an actual node which is
    // the root of the tree, and LeftChild does not point to self.
    //
    pPrev = pNode;

    while( IsLeftChild( pPrev ) )
    {
        pPrev = pPrev->pParent;
    }

    if( IsRightChild( pPrev ) && ( pPrev->pParent->pParent != pPrev->pParent ) )
    {
        return( pPrev->pParent );
    }

    //
    // Otherwise we do not have a real predecessor so we simply return NULL.
    //
    return( NULL );
}


//////////////////////////////////////////////////////////////////////////////
void AVLAPI AvlInitializeTable(
                    IN AVL_TABLE *pTable,
                    IN PAVL_COMPARE_ROUTINE pfnCompare,
                    IN PAVL_ALLOCATE_ROUTINE pfnAllocate,
                    IN PAVL_FREE_ROUTINE pfnFree,
                    IN void *pvTableContext )
{
#ifdef _DEBUG
    DWORD i;

    for( i = 2; i < 33; i++ )
    {
        assert( WorstCaseFill[ i ] ==
                ( 1 + WorstCaseFill[ i - 1 ] + WorstCaseFill[ i - 2 ] ) );
    }
#endif

    //
    // Initialize the passed in AVL table
    //
    memset( pTable, 0, sizeof(AVL_TABLE) );

    pTable->BalancedRoot.pParent = &pTable->BalancedRoot;

    pTable->pfnCompareRoutine = pfnCompare;
    pTable->pfnAllocateRoutine = pfnAllocate;
    pTable->pfnFreeRoutine = pfnFree;
    pTable->pvTableContext = pvTableContext;
}


//////////////////////////////////////////////////////////////////////////////
//
// AvlInsertElement inserts a new element in a table.  It does this by allocating
// space for the new element (including the base AVL tree node structure),
// inserting the element in the table, and then returning to the user a pointer
// to the new element.  If an element with the same key already exists in the
// table the return value is a pointer to the old element.  The optional output
// param pfDuplicateFound is used to indicate if there was already an element
// that shared the same key.
//
// Note: the user supplied buffer is copied into the allocated tree node.
//
void * AVLAPI AvlInsertElement(
                    IN AVL_TABLE *pTable,
                    IN void *pvBuffer,
                    IN DWORD cbBuffer,
                    OUT BOOL *pfDuplicateFound OPTIONAL )
{
    AVL_TREE_NODE *pNodeOrParent;
    AVL_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent( pTable, pvBuffer, &pNodeOrParent );

    return( AvlInsertElementEx(
                        pTable,
                        pvBuffer,
                        cbBuffer,
                        pfDuplicateFound,
                        pNodeOrParent,
                        Lookup ) );
}


//////////////////////////////////////////////////////////////////////////////
//
// AvlInsertElementEx does the same thing as AvlInsertElement, except that it
// is made faster by passing the pNodeOrParent and SearchResult from a previous
// call to AvlFindElementEx (or FindNodeOrParent for internal callers).
//
void * AVLAPI AvlInsertElementEx(
                    IN AVL_TABLE *pTable,
                    IN void *pvBuffer,
                    IN DWORD cbBuffer,
                    OUT BOOL *pfDuplicateFound OPTIONAL,
                    IN AVL_TREE_NODE *pNodeOrParent,
                    IN AVL_SEARCH_RESULT SearchResult )
{
    TABLE_ENTRY_HEADER *pNewNode = NULL;

    if( AvlFoundNode != SearchResult )
    {
        //
        // Allocate space for a new tree node
        //
        assert( pTable->dwNumElements != 0xFFFFFFFE );

        //
        // 48835 - Check for overflow
        //
        if(cbBuffer > (cbBuffer + FIELD_OFFSET( TABLE_ENTRY_HEADER, UserData ) ) )
        {
            return( NULL );
        }

        pNewNode = (TABLE_ENTRY_HEADER *) pTable->pfnAllocateRoutine( pTable,
                                cbBuffer + FIELD_OFFSET( TABLE_ENTRY_HEADER, UserData ) );

        if( NULL == pNewNode )
        {
            return( NULL );
        }

        memset( pNewNode, 0, sizeof(pNewNode->Node) );

        pTable->dwNumElements++;

        //
        // Insert the new node in the tree.
        //
        if( AvlEmptyTree == SearchResult )
        {
            pTable->BalancedRoot.pRightChild = &pNewNode->Node;
            pNewNode->Node.pParent = &pTable->BalancedRoot;

            assert( 0 == pTable->dwTreeDepth );
            pTable->dwTreeDepth = 1;
        }
        else
        {
            AVL_TREE_NODE *pRNode = &pNewNode->Node;
            AVL_TREE_NODE *pSNode = pNodeOrParent;

            if( AvlInsertAsLeft == SearchResult )
            {
                assert( NULL == pSNode->pLeftChild );
                pSNode->pLeftChild = pRNode;
            }
            else
            {
                assert( NULL == pSNode->pRightChild );
                pSNode->pRightChild = pRNode;
            }

            pRNode->pParent = pSNode;

            //
            // The above completes the standard binary tree insertion, which
            // happens to correspond to steps A1-A5 of Knuth's "balanced tree
            // search and insertion" algorithm.  Now comes the time to adjust
            // balance factors and possibly do a single or double rotation as
            // in steps A6-A10.

            //
            // Set the Balance factor in the root to a convenient value
            // to simplify loop control, and loop adjusting balance factors
            // while checking to see if any balance operations need to happen.
            //
            pTable->BalancedRoot.Balance = -1;

            while( TRUE )
            {
                CHAR a;

                //
                // Calculate the next adjustment.
                //
                a = IsLeftChild( pRNode ) ? -1 : 1;

                if( 0 == pSNode->Balance )
                {
                    //
                    // If this node was balanced, show that it is no longer and keep looping.
                    // This is essentially A6 of Knuth's algorithm, where he updates all of
                    // the intermediate nodes on the insertion path which previously had
                    // balance factors of 0.  We are looping up the tree via Parent pointers
                    // rather than down the tree as in Knuth.
                    //
                    pSNode->Balance = a;

                    pRNode = pSNode;
                    pSNode = pSNode->pParent;
                }
                else if( pSNode->Balance != a )
                {
                    //
                    // If this node has the opposite balance, then the tree got more
                    // balanced (or we hit the root) and we are done.
                    //

                    //
                    //  Step A7.ii
                    //
                    pSNode->Balance = 0;

                    //
                    // If S is actually the root, then this means the depth of the tree
                    // just increased by 1!  (This is essentially A7.i, but we just
                    // initialized the root balance to force it through here.)
                    //
                    if( 0 == pTable->BalancedRoot.Balance )
                    {
                        pTable->dwTreeDepth++;
                    }

                    break;
                }
                else
                {
                    //
                    // Otherwise the tree became unbalanced (path length differs
                    // by 2 below us) and we need to do one of the balancing operations,
                    // and then we are done. 
                    // The RebalanceNode routine does steps A7.iii, A8 and A9.
                    //
                    RebalanceNode( pSNode );
                    break;
                }
            }
        }

        //
        // Copy the users buffer into the user data area of the table entry
        //
        memcpy( GetDataPtr( pNewNode ), pvBuffer, cbBuffer );
    }
    else
    {
        //
        // Return a pointer to the existing tree node with a duplicate key value
        //
        pNewNode = (TABLE_ENTRY_HEADER *) pNodeOrParent;
    }

    if( NULL != pfDuplicateFound )
    {
        *pfDuplicateFound = ( SearchResult != AvlFoundNode );
    }

    //
    // Sanity check tree size and depth.
    //
    assert( ( pTable->dwNumElements >= WorstCaseFill[ pTable->dwTreeDepth] ) &&
            ( pTable->dwNumElements <= BestCaseFill[ pTable->dwTreeDepth ] ) );

    return( GetDataPtr( pNewNode ) );
}


//////////////////////////////////////////////////////////////////////////////
//
// AvlDeleteElement finds and deletes an element from the given AVL table.
// It returns TRUE if the element was found, and FALSE otherwise.  The supplied
// input buffer is only used as a key for search purposes.
//
BOOL AVLAPI AvlDeleteElement(
                    IN AVL_TABLE *pTable,
                    IN void *pvBuffer )
{
    AVL_TREE_NODE *pNodeOrParent;
    AVL_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent( pTable, pvBuffer, &pNodeOrParent );

    if( AvlFoundNode != Lookup )
    {
        return( FALSE );
    }
    
    //
    // Make AvlEnumerate safe by replacing the RestartKey with its predecessor
    // if it gets deleted.  A NULL means return the first node in the tree. 
    //
    if( pNodeOrParent == pTable->pRestartKey )
    {
        pTable->pRestartKey = RealPredecessor( pNodeOrParent );
    }

    //
    // Make AvlEnumerateMatches safe by incrementing the DeleteCount.
    //
    pTable->dwDeleteCount++;

    //
    // Remove the node from the tree
    //
    DeleteNodeFromTree( pTable, pNodeOrParent );
    pTable->dwNumElements--;

    //
    // Sanity check tree size and depth.
    //
    assert( ( pTable->dwNumElements >= WorstCaseFill[ pTable->dwTreeDepth] ) &&
            ( pTable->dwNumElements <= BestCaseFill[ pTable->dwTreeDepth ] ) );

    //
    // Have the deletion routine clean up the node's memory
    //
    pTable->pfnFreeRoutine( pTable, pNodeOrParent );

    return( TRUE );
}


//////////////////////////////////////////////////////////////////////////////
//
// AvlFindElement finds an element in the given AVL table.  It returns a
// pointer to the user data associated with the element if found, and
// otherwise returns NULL.  The supplied input buffer is only used as a key
// for search purposes.
//
void * AVLAPI AvlFindElement(
                    IN AVL_TABLE *pTable,
                    IN void *pvBuffer )
{
    AVL_TREE_NODE *pNodeOrParent;
    AVL_SEARCH_RESULT Lookup;

    return( AvlFindElementEx( pTable, pvBuffer, &pNodeOrParent, &Lookup ) );
}


//////////////////////////////////////////////////////////////////////////////
//
// AvlFindElementEx finds an element in the given AVL table.  If found, it
// returns a pointer to the user data associated with the element.  If not
// found, it returns a pointer to the parent of the insert location.  The
// user must examine the SearchResult value to determine which is being
// returned.  The user can use the SearchResult and parent pointer to
// make an optimized insert call via AvlInsertElementEx.
//
void * AVLAPI AvlFindElementEx(
                    IN AVL_TABLE *pTable,
                    IN void *pvBuffer,
                    OUT AVL_TREE_NODE **ppNodeOrParent,
                    OUT AVL_SEARCH_RESULT *pSearchResult )
{
    //
    //  Lookup the element and save the result.
    //
    *pSearchResult = FindNodeOrParent( pTable, pvBuffer, ppNodeOrParent );

    if( AvlFoundNode != *pSearchResult )
    {
        return( NULL );
    }
    else
    {
        //
        // Return a pointer to the user data.
        //
        return( GetDataPtr( *ppNodeOrParent ) );
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// AvlEnumerate will return to the caller one-by-one the elements of a table.
// The return value is a pointer to the user data associated with the element.
// The input parameter fRestart indicates if the enumeration should start from
// the beginning or should return the next element.  If there are no more new
// elements to return then the return value is NULL.
//
// NOTE: This routine does not modify the structure of the tree, but saves
//       the last restart key returned in the table itself, and for this
//       reason requires exclusive access to the table for the duration of
//       the enumeration.  It simply calls AvlEnumerateEx underneath.
//
void * AVLAPI AvlEnumerate(
                    IN AVL_TABLE *pTable,
                    IN BOOL fRestart )
{
    if( fRestart )
    {
        pTable->pRestartKey = NULL;
    }

    return( AvlEnumerateEx( pTable, (void **) &pTable->pRestartKey ) );
}


//////////////////////////////////////////////////////////////////////////////
//
// AvlEnumerateEx will return to the caller one-by-one the elements of a table.
// The return value is a pointer to the user data associated with the element.
// The input parameter ppvRestartKey indicates if the enumeration should start
// from the beginning or should return the next element.  If there are no more
// new elements to return then the return value is NULL.
//
// If ppvRestartKey is NULL, enumeration will start from the least entry in
// the table, otherwise it will start from the last entry returned.
//
// NOTE:   This routine does not modify either the structure of the tree
//         or the generic table itself, but must insure that no deletes
//         occur for the duration of the enumeration, typically by having
//         at least shared access to the table for the duration.
//
void * AVLAPI AvlEnumerateEx(
                    IN AVL_TABLE *pTable,
                    IN OUT void **ppvRestartKey )
{
    AVL_TREE_NODE *pNodeToReturn;

    if( AvlIsTableEmpty( pTable ) )
    {
        return( NULL );
    }

    if( NULL == *ppvRestartKey )
    {
        //
        // Find the leftmost child of the root
        //
        pNodeToReturn = pTable->BalancedRoot.pRightChild;

        while( NULL != pNodeToReturn->pLeftChild )
        {
            pNodeToReturn = pNodeToReturn->pLeftChild;
        }

        *ppvRestartKey = pNodeToReturn;
    }
    else
    {
        //
        // The caller has passed in the previous entry found in order to
        // continue the previous search.  Use RealSuccessor to find the next
        // tree node.
        //
        pNodeToReturn = RealSuccessor( (AVL_TREE_NODE *) *ppvRestartKey );

        if( NULL != pNodeToReturn )
        {
            *ppvRestartKey = pNodeToReturn;
        }
    }

    //
    // If there actually is a next element in the enumeration
    // then the pointer to return is right after the list links.
    //
    return( ( NULL != pNodeToReturn ) ? GetDataPtr( pNodeToReturn ) : NULL );
}


//////////////////////////////////////////////////////////////////////////////
//
// AvlEnumerateMatches will return to the caller one-by-one the matching elements
// of a table.  The return value is a pointer to the user data associated with
// the element.  The input parameter ppvRestartKey indicates if the enumeration
// should start from the beginning or should return the next matching element.
// If there are no more matching elements to return the return value is NULL.
//
// If *ppvRestartKey is NULL, enumeration will start/resume from the position
// described by pvBuffer.  Otherwise, the enumeration will resume from the most
// recent location, as long as there were no intervening deletes.  If a delete
// happened, enumeration will resume from the position described in pvBuffer.
//
// To enumerate the table from the beginning, initialize the contents of pvBuffer
// to contain <min possible key> before making the first call with *ppvRestartKey
// = NULL.  To start from an arbitrary point, initialize the contents of pvBuffer
// to contain the desired starting key.
//
// Enumerations via this routine across intermixed insert and delete operations
// are safe.  All names not involved in inserts and deletes will be returned
// exactly once (unless explicitly resumed from an earlier point), and
// all intermixed inserts and deletes will be seen or not seen based on their
// state at the time the enumeration processes the respective range.
//
// NOTE:   This routine does not modify either the structure of the tree
//         or the generic table itself.  The table must only be acquired
//         shared for the duration of this call, and all synchronization
//         may optionally be dropped between calls.  Enumeration is always
//         correctly resumed in the most efficient manner possible via the
//         IN OUT parameters provided.
//
void * AVLAPI AvlEnumerateMatches(
                    IN AVL_TABLE *pTable,
                    IN PAVL_MATCH_ROUTINE pfnMatch OPTIONAL,
                    IN void *pvMatchData,
                    IN BOOL fContinueLastMatch, // aka NextFlag
                    IN OUT void **ppvRestartKey,
                    IN OUT DWORD *pdwDeleteCount,
                    IN void *pvBuffer )
{
    AVL_MATCH_RESULT MatchResult;
    AVL_SEARCH_RESULT Lookup;
    TABLE_ENTRY_HEADER *pNodeOrParent = (TABLE_ENTRY_HEADER *) *ppvRestartKey;

    //
    // Get out if the table is empty.
    //
    if( AvlIsTableEmpty( pTable ) )
    {
        *ppvRestartKey = NULL;
        return( NULL );
    }

    //
    // If no match function was specified, then match all elements.
    //
    if( NULL == pfnMatch )
    {
        pfnMatch = MatchAll;
    }

    //
    // If there was a delete since the last time DeleteCount was captured, then we
    // cannot trust the RestartKey.
    //
    if( *pdwDeleteCount != pTable->dwDeleteCount )
    {
        pNodeOrParent = NULL;
    }

    assert( FIELD_OFFSET( TABLE_ENTRY_HEADER, Node ) == 0 );

    if( NULL == pNodeOrParent )
    {
        //
        // No saved location, so position using the supplied key value
        //
        Lookup = FindNodeOrParent(
                            pTable,
                            pvBuffer,
                            (AVL_TREE_NODE **) &pNodeOrParent );

        if( AvlFoundNode != Lookup )
        {
            fContinueLastMatch = FALSE;

            //
            // pNodeOrParent points to a parent node where our key buffer could be
            // inserted.  If the key would be the left child, then pNodeOrParent just
            // so happens to be the correct successor node.  Otherwise, the successor
            // of the specified key is the successor of pNodeOrParent.
            //
            if( AvlInsertAsRight == Lookup )
            {
                pNodeOrParent = (TABLE_ENTRY_HEADER *) RealSuccessor(
                                        (AVL_TREE_NODE *) pNodeOrParent );
            }
        }
    }

    //
    // Now see if we are supposed to skip one.
    //
    if( fContinueLastMatch )
    {
        assert( NULL != pNodeOrParent );
        pNodeOrParent = (TABLE_ENTRY_HEADER *) RealSuccessor(
                                (AVL_TREE_NODE *) pNodeOrParent );
    }

    //
    // Continue to enumerate until we hit the end of the matches or get a match.
    //
    while( NULL != pNodeOrParent )
    {
        MatchResult = pfnMatch( pTable, GetDataPtr( pNodeOrParent ), pvMatchData );

        if( AvlNoMatch != MatchResult )
        {
            break;
        }

        pNodeOrParent = (TABLE_ENTRY_HEADER *) RealSuccessor(
                                (AVL_TREE_NODE *) pNodeOrParent );
    }

    //
    // If we terminated the above loop with a pointer, it is either because we got a
    // match, or because the match function knows that there will be no more matches.
    // Fill in the OUT parameters the same in either case, but only return the UserData
    // pointer if we really got a match.
    //
    if( NULL != pNodeOrParent )
    {
        assert( ( AvlMatched == MatchResult ) || ( AvlNoMoreMatches == MatchResult ) );

        *ppvRestartKey = pNodeOrParent;
        *pdwDeleteCount = pTable->dwDeleteCount;

        if( AvlMatched == MatchResult )
        {
            return( GetDataPtr( pNodeOrParent ) );
        }
    }

    return( NULL );
}


//////////////////////////////////////////////////////////////////////////////
//
// AvlGetNumElements returns a DWORD count of elements currently held in
// the given table.
//
DWORD AVLAPI AvlGetNumElements( IN AVL_TABLE *pTable )
{
    return( pTable->dwNumElements );
}


//////////////////////////////////////////////////////////////////////////////
//
// AvlIsTableEmpty returns TRUE if the table is empty and FALSE otherwise.
//
BOOL AVLAPI AvlIsTableEmpty( IN AVL_TABLE *pTable )
{
    return( 0 == pTable->dwNumElements );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vavltable.h ===
#ifndef VAVLTABLE_H_INCLUDED
#define VAVLTABLE_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windef.h>

//
// Adapted from portion of nt\public\sdk\inc\ntrtl.h concerning AVL-based
// generic table package.
//

//
// This enumerated type is used as the function return value of the function
// that is used to search the tree for a key. FoundNode indicates that the
// function found the key. Insert as left indicates that the key was not found
// and the node should be inserted as the left child of the parent. Insert as
// right indicates that the key was not found and the node should be inserted
// as the right child of the parent.
//
typedef enum _AVL_SEARCH_RESULT
{
    AvlEmptyTree,
    AvlFoundNode,
    AvlInsertAsLeft,
    AvlInsertAsRight

}   AVL_SEARCH_RESULT;

//
// The results of a compare can be less than, equal, or greater than.
//
typedef enum _AVL_COMPARE_RESULT
{
    AvlLessThan,
    AvlGreaterThan,
    AvlEqual

}   AVL_COMPARE_RESULT;

//
// The results of a match can be success, no match (but continue enumerating),
// or no match (and stop enumerating).
//
typedef enum _AVL_MATCH_RESULT
{
    AvlMatched,
    AvlNoMatch,
    AvlNoMoreMatches

}   AVL_MATCH_RESULT;

struct _AVL_TABLE;

#define AVLAPI  __stdcall

//
// The comparison function takes as input pointers to elements containing
// user defined structures and returns the results of comparing the two
// elements.
//
typedef AVL_COMPARE_RESULT (AVLAPI *PAVL_COMPARE_ROUTINE)(
                                    struct _AVL_TABLE *pTable,
                                    void *pvFirst,
                                    void *pvSecond );

//
// The allocation and deallocations are called to allocate and free nodes
// of the AVL tree (which can vary in size based on the supplied data).
//
typedef void * (AVLAPI *PAVL_ALLOCATE_ROUTINE)(
                                    struct _AVL_TABLE *pTable,
                                    DWORD cbTreeNode );

typedef void (AVLAPI *PAVL_FREE_ROUTINE)(
                                    struct _AVL_TABLE *pTable,
                                    void *pvTreeNode );

//
// The match function takes as input the user data to be matched and a pointer
// to some match data, which was passed along with the function pointer.  It
// returns TRUE for a match and FALSE for no match.
//
typedef AVL_MATCH_RESULT (AVLAPI *PAVL_MATCH_ROUTINE)(
                                        struct _AVL_TABLE *pTable,
                                        void *pvUserData,
                                        void *pvMatchData );

//
// Define the base structure of all AVL tree nodes.  This structure should
// be treated as opaque by callers!
//
// The root of a balanced binary tree is not a real node in the tree
// but rather points to a real node which is the root.  It is always
// in the table below, and its fields are used as follows:
//
//      pParent     Pointer to self, to allow for detection of the root.
//      pLeftChild  NULL
//      pRightChild Pointer to real root
//      Balance     Undefined, however it is set to a convenient value
//                  (depending on the algorithm) prior to rebalancing
//                  in insert and delete routines.
//
typedef struct _AVL_TREE_NODE
{
    struct _AVL_TREE_NODE *pParent;
    struct _AVL_TREE_NODE *pLeftChild;
    struct _AVL_TREE_NODE *pRightChild;
    CHAR Balance;
    UCHAR Reserved[3];

}   AVL_TREE_NODE;

//
// To use this AVL tree package the user declares a variable of type
// AVL_TABLE and then uses the routines described below to initialize
// and manipulate the tree.  This structure should be treated as opaque
// by callers!
//
typedef struct _AVL_TABLE
{
    AVL_TREE_NODE BalancedRoot;

    DWORD dwNumElements;
    DWORD dwTreeDepth;
    DWORD dwDeleteCount;

    DWORD dwRestartDeleteCount;
    AVL_TREE_NODE *pRestartKey;

    void *pvTableContext;

    PAVL_COMPARE_ROUTINE pfnCompareRoutine;
    PAVL_ALLOCATE_ROUTINE pfnAllocateRoutine;
    PAVL_FREE_ROUTINE pfnFreeRoutine;

}   AVL_TABLE;

//
// AvlInitializeTable must be called for each instance of an AVL_TABLE before
// it can be used.
//
void AVLAPI AvlInitializeTable(
                    IN AVL_TABLE *pTable,
                    IN PAVL_COMPARE_ROUTINE pfnCompare,
                    IN PAVL_ALLOCATE_ROUTINE pfnAllocate,
                    IN PAVL_FREE_ROUTINE pfnFree,
                    IN void *pvTableContext );

//
// AvlInsertElement inserts a new element in a table.  It does this by allocating
// space for the new element (including the base AVL tree node structure),
// inserting the element in the table, and then returning to the user a pointer
// to the new element.  If an element with the same key already exists in the
// table the return value is a pointer to the old element.  The optional output
// param pfDuplicateFound is used to indicate if there was already an element
// that shared the same key.
//
// Note: the user supplied buffer is copied into the allocated tree node.
//
void * AVLAPI AvlInsertElement(
                    IN AVL_TABLE *pTable,
                    IN void *pvBuffer,
                    IN DWORD cbBuffer,
                    OUT BOOL *pfDuplicateFound OPTIONAL );

//
// AvlInsertElementEx does the same thing as AvlInsertElement, except that it
// is made faster by passing the pNodeOrParent and SearchResult from a previous
// call to AvlFindElementEx.
//
void * AVLAPI AvlInsertElementEx(
                    IN AVL_TABLE *pTable,
                    IN void *pvBuffer,
                    IN DWORD cbBuffer,
                    OUT BOOL *pfDuplicateFound OPTIONAL,
                    IN AVL_TREE_NODE *pNodeOrParent,
                    IN AVL_SEARCH_RESULT SearchResult );

//
// AvlDeleteElement finds and deletes an element from the given AVL table.
// It returns TRUE if the element was found, and FALSE otherwise.  The supplied
// input buffer is only used as a key for search purposes.
//
BOOL AVLAPI AvlDeleteElement(
                    IN AVL_TABLE *pTable,
                    IN void *pvBuffer );

//
// AvlFindElement finds an element in the given AVL table.  It returns a
// pointer to the user data associated with the element if found, and
// otherwise returns NULL.  The supplied input buffer is only used as a key
// for search purposes.
//
void * AVLAPI AvlFindElement(
                    IN AVL_TABLE *pTable,
                    IN void *pvBuffer );

//
// AvlFindElementEx finds an element in the given AVL table.  If found, it
// returns a pointer to the user data associated with the element.  If not
// found, it returns a pointer to the parent of the insert location.  The
// user must examine the SearchResult value to determine which is being
// returned.  The user can use the SearchResult and parent pointer to
// make an optimized insert call via AvlInsertElementEx.
//
void * AVLAPI AvlFindElementEx(
                    IN AVL_TABLE *pTable,
                    IN void *pvBuffer,
                    OUT AVL_TREE_NODE **ppNodeOrParent,
                    OUT AVL_SEARCH_RESULT *pSearchResult );

//
// AvlEnumerate will return to the caller one-by-one the elements of a table.
// The return value is a pointer to the user data associated with the element.
// The input parameter fRestart indicates if the enumeration should start from
// the beginning or should return the next element.  If there are no more new
// elements to return then the return value is NULL.
//
// NOTE: This routine does not modify the structure of the tree, but saves
//       the last restart key returned in the table itself, and for this
//       reason requires exclusive access to the table for the duration of
//       the enumeration.  It simply calls AvlEnumerateEx underneath.
//
void * AVLAPI AvlEnumerate(
                    IN AVL_TABLE *pTable,
                    IN BOOL fRestart );

//
// AvlEnumerateEx will return to the caller one-by-one the elements of a table.
// The return value is a pointer to the user data associated with the element.
// The input parameter ppvRestartKey indicates if the enumeration should start
// from the beginning or should return the next element.  If there are no more
// new elements to return then the return value is NULL.
//
// If ppvRestartKey is NULL, enumeration will start from the least entry in
// the table, otherwise it will start from the last entry returned.
//
// NOTE:   This routine does not modify either the structure of the tree
//         or the generic table itself, but must insure that no deletes
//         occur for the duration of the enumeration, typically by having
//         at least shared access to the table for the duration.
//
void * AVLAPI AvlEnumerateEx(
                    IN AVL_TABLE *pTable,
                    IN OUT void **ppvRestartKey );

//
// AvlEnumerateMatches will return to the caller one-by-one the matching elements
// of a table.  The return value is a pointer to the user data associated with
// the element.  The input parameter ppvRestartKey indicates if the enumeration
// should start from the beginning or should return the next matching element.
// If there are no more matching elements to return the return value is NULL.
//
// If ppvRestartKey is NULL, enumeration will start from the least entry in
// the table, otherwise it will start from the last entry returned.
//
// NOTE:   This routine does not modify either the structure of the tree
//         or the generic table itself.  The table must only be acquired
//         shared for the duration of this call, and all synchronization
//         may optionally be dropped between calls.  Enumeration is always
//         correctly resumed in the most efficient manner possible via the
//         IN OUT parameters provided.
//
void * AVLAPI AvlEnumerateMatches(
                    IN AVL_TABLE *pTable,
                    IN PAVL_MATCH_ROUTINE pfnMatch OPTIONAL,
                    IN void *pvMatchData,
                    IN BOOL fContinueLastMatch,
                    IN OUT void **ppvRestartKey,
                    IN OUT DWORD *pdwDeleteCount,
                    IN void *pvBuffer );

//
// AvlGetNumElements returns a DWORD count of elements currently held in
// the given table.
//
DWORD AVLAPI AvlGetNumElements(
                    IN AVL_TABLE *pTable );

//
// AvlIsTableEmpty returns TRUE if the table is empty and FALSE otherwise.
//
BOOL AVLAPI AvlIsTableEmpty(
                    IN AVL_TABLE *pTable );


#endif  // VAVLTREE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vbckhash.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File: 		vbckhash.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef VBCKHASH_H
#define VBCKHASH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "vcelpool.h"

typedef DWORD (WINAPI *PFNHASHINGFUNCTION)( DWORD dwKey, DWORD dwTableSize, DWORD dwParam );

//////////////////////////////////////////////////////////////////////////////
class CVBucketHash
{
public:
    CVBucketHash();
   ~CVBucketHash();

   HRESULT Initialize( DWORD dwTableSize, 
                       PFNHASHINGFUNCTION pfnHash = NULL, 
                       DWORD dwParam = 0 );

   HRESULT Insert( const DWORD& Key, const void *pValue );
   HRESULT Find( const DWORD& Key, void **ppValue );
   HRESULT Remove( const DWORD& Key, void **ppValue );

   DWORD GetEntryCount() { return m_dwEntries; }
   DWORD RemoveAll();

   BOOL GetFirst( DWORD& Key, void **ppValue );
   BOOL GetNext( DWORD& Key, void **ppValue );

private:
    struct NODE
    {
        DWORD Key;
        void *pValue;
        NODE *pNext;
    };
  
    NODE **m_pTable;
    DWORD m_dwTableSize;
    DWORD m_dwEntries;
    DWORD m_dwHashParam;
    NODE *m_pCursor;

    PFNHASHINGFUNCTION m_pfnHash;

    CVCellPool *m_pNodePool;

    DWORD Hash( const DWORD& Key );
};


//////////////////////////////////////////////////////////////////////////////
inline DWORD CVBucketHash::Hash( const DWORD& Key )
{
    if( NULL == m_pfnHash )
    {
        return( Key % m_dwTableSize );
    }
    else
    {
        return( m_pfnHash( Key, m_dwTableSize, m_dwHashParam ) );
    }
}

#endif // VBCKHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vcelpool.cpp ===
#include "dstructp.h"


#ifndef MAKESIG
#define MAKESIG( ch0, ch1, ch2, ch3 )                           \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#define SIG_FREE_CELL               g_sigFreeCell
#define SIG_USED_CELL               g_sigUsedCell
#define SIG_FREE_PAGE               g_sigFreePage
#define SIG_PARTIALLY_FILLED_PAGE   g_sigPFPage
#define SIG_COMPLETELY_FILLED_PAGE  g_sigCFPage

DWORD g_sigFreeCell = MAKESIG( 'F','R','E','E' );
DWORD g_sigUsedCell = MAKESIG( 'U','S','E','D' );
DWORD g_sigFreePage = MAKESIG( 'F','R','P','G' );
DWORD g_sigPFPage   = MAKESIG( 'P','F','P','G' );
DWORD g_sigCFPage   = MAKESIG( 'C','F','P','G' );

// setting this to 1 will place cells at end of free list which degrades performance
#define PUT_CELLS_AT_TAIL_OF_LIST       0   // only in DBG builds

// setting this to 1 will generate random alloc pattern
#define GENERATE_RANDOM_ALLOC_PATTERN   0   // only in DBG builds

#if DBG
static LONG g_NextAllocPattern = 1;         // only in DBG builds
#endif

#define CELLPOOL_PARANOIA               1   // only in DBG builds
#define FILL_CELL_WITH_DEBUG_PATTERN    1   // only in DBG builds
#define PATTERN_PAGES                   1   // only in DBG builds

#define ALWAYS_FREE_UNUSED_PAGES        0   // for debug only


#define ALLOC_PATTERN                   0xCC    // only in DBG builds
#define DELETE_PATTERN                  0xDD    // only in DBG builds
#define ALLOC_BUFFER_PATTERN            0xCD    // only in DBG builds
#define DELETE_BUFFER_PATTERN           0xEF    // only in DBG builds


#define m_pFreePages                    m_rgPages[0]
#define m_pPartiallyFilledPages         m_rgPages[1]
#define m_pCompletelyFilledPages        m_rgPages[2]

#if DBG
#define VCELLPOOLASSERT( exp )   if( !( exp ) ) { DebugBreak(); }
#else
#define VCELLPOOLASSERT( exp )
#endif

#if DBG
BOOL g_fUseNewDelete = FALSE;
#endif

class GlobalFlagInitializer
{
public:
    GlobalFlagInitializer()
    {
#if DBG
        LONG lResult;
        HKEY hRegKey;
        DWORD dwType;
        DWORD dwLength;
        DWORD dwRegistryValue = 0;

        // Read this from the registry so we can tune it.
        lResult = RegOpenKeyExW( 
                        HKEY_LOCAL_MACHINE,
                        L"Software\\Microsoft\\Windows Media\\Platform\\Memory",
                        0,
                        KEY_READ,
                        &hRegKey
                        );
                        
        if ( ERROR_SUCCESS == lResult )
        {
            dwLength = sizeof( DWORD );
            lResult = RegQueryValueExW( 
                            hRegKey, 
                            L"Use New and Delete",
                            NULL,
                            &dwType, 
                            (LPBYTE) &dwRegistryValue, 
                            &dwLength 
                            );
            if ( ( ERROR_SUCCESS == lResult ) && ( REG_DWORD == dwType ) && dwRegistryValue )
            {
                g_fUseNewDelete = TRUE;
            }

            RegCloseKey( hRegKey );
        } // End of reading registry values.
#endif
    }
};

GlobalFlagInitializer g_GlobalFlagInitializer;


//////////////////////////////////////////////////////////////////////
// Public Methods

//////////////////////////////////////////////////////////////////////////////
CVCellPool::CVCellPool()
{
    ZeroMemory( this, sizeof(*this) );
    m_fInitialized = FALSE;
    m_cbTotalMemoryUsed = 0;
#if DBG
    m_AllocPattern = ALLOC_PATTERN;
#endif // DBG
}

//////////////////////////////////////////////////////////////////////////////
CVCellPool::~CVCellPool()
{
    _Cleanup();
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CVCellPool::Initialize( DWORD cbCellSize, 
                                DWORD nCellsPerPage, 
                                DWORD nInitialPages, 
                                BOOL  fFreeUnusedPages ) 
{
    if( ( cbCellSize < 1 ) 
    ||  ( nCellsPerPage < 1 ) 
    ||  ( nInitialPages < 1 )
#ifndef WIN32
    ||  ( ( cbCellSize + sizeof(CELLHEADER) + sizeof(PAGEHEADER) + CELL_ALIGNMENT ) > 65535 ) 
#endif  //!WIN32
      )
    {
        // brain-dead request
        VCELLPOOLASSERT( 0 );
        return( E_INVALIDARG );
    }

    if( m_fInitialized )
    {
        // VCELLPOOLASSERT( 0 );, this should not be allowed, or we should make sure it
        // is only rarely used.  throw the assert in sometime to debug where it is done and why
        
        // the client had better know what they're doing here...
        _Cleanup();
    }
    
#if DBG && GENERATE_RANDOM_ALLOC_PATTERN
    LONG lTemp = InterlockedIncrement( &g_NextAllocPattern );
    // Make sure it is odd so we can fail when we use it as a pointer.
    m_AllocPattern = ( ( lTemp * 2 ) + 1 ) & 0x000000FF;
#endif

#if ALWAYS_FREE_UNUSED_PAGES
    m_fFreeUnusedPages = TRUE;
#else
    m_fFreeUnusedPages = fFreeUnusedPages;
#endif // ALWAYS_FREE_UNUSED_PAGES

    if( fFreeUnusedPages && ( nInitialPages > 1 ) )
    {
        // the additional pages would just be freed
        nInitialPages = 1;
    }

    m_cbPageHeader = PROCESSOR_ALIGNMENT * ( ( sizeof(PAGEHEADER) + PROCESSOR_ALIGNMENT - 1 ) / PROCESSOR_ALIGNMENT );
    m_cbCellHeader = PROCESSOR_ALIGNMENT * ( ( sizeof(CELLHEADER) + PROCESSOR_ALIGNMENT - 1 ) / PROCESSOR_ALIGNMENT );
    m_cbCellSize = PROCESSOR_ALIGNMENT * ( ( cbCellSize + PROCESSOR_ALIGNMENT - 1 ) / PROCESSOR_ALIGNMENT );

    m_cbActualCellSize = CELL_ALIGNMENT * ( ( cbCellSize + m_cbCellHeader + CELL_ALIGNMENT - 1 ) / CELL_ALIGNMENT );
    VCELLPOOLASSERT( ( m_cbActualCellSize % CELL_ALIGNMENT ) == 0 );

#ifdef  WIN32
    m_nCellsPerPage = nCellsPerPage;
#else
    m_nCellsPerPage = min( nCellsPerPage, ( 65535 - m_cbPageHeader - CELL_ALIGNMENT ) / m_cbActualCellSize );
#endif  //WIN32

    m_nPageCount = 0;
    m_cbActualPageSize = CELL_ALIGNMENT - PROCESSOR_ALIGNMENT + m_cbPageHeader + m_nCellsPerPage * m_cbActualCellSize; // - PROCESSOR_ALIGNMENT;
    m_fInitialized = 1;

#if DBG
    if ( g_fUseNewDelete )
    {
        return( S_OK );
    }
#endif

#if DBG
    VCELLPOOLASSERT( m_cFreePages == 0 );
#endif    
    PPAGEHEADER pNewPage;

    while( nInitialPages-- )
    {
        pNewPage = _AcquireCleanPage();
        if( NULL == pNewPage )
        {
            // this will set m_fInitialized to 0
            _Cleanup();
            break;
        }
        
        _AddToNewList( m_pFreePages, pNewPage );
#if DBG        
        m_cFreePages++;
#endif        
    }
#if DBG
    VCELLPOOLASSERT( m_nPageCount == ( m_cFreePages + m_cPartiallyFilledPages + m_cCompletelyFilledPages ) );
#endif    

    return( m_fInitialized ? S_OK : E_OUTOFMEMORY );
}




//////////////////////////////////////////////////////////////////////////////
HRESULT CVCellPool::AcquireCell( void **ppCell )
{
    PCELLHEADER pNewCell;
    PPAGEHEADER pPage;

    if( NULL == ppCell )
    {
        return( E_INVALIDARG );
    }
    *ppCell = NULL;             // initialize var to NULL
    
#if DBG
    if ( g_fUseNewDelete )
    {
        VCELLPOOLASSERT( m_cbCellSize > 0 );
        *ppCell = ::new BYTE[ m_cbCellSize ];
        return( ( *ppCell != NULL ) ? S_OK : E_OUTOFMEMORY );        
    }
#endif

#if DBG
    if( !m_fInitialized )
    {
        VCELLPOOLASSERT(0);
        goto abort;
    }
#endif

#if DBG
    VCELLPOOLASSERT( m_nPageCount == ( m_cFreePages + m_cPartiallyFilledPages + m_cCompletelyFilledPages ) );
#endif    
    
    //
    // Keep track of where we got the page to allocate the cell from
    //
    if( NULL != m_pPartiallyFilledPages )
    {
        pPage = m_pPartiallyFilledPages;
        pPage->nCellsInUse++;
        
        //
        // we are going to use a partially filled page. Allocating one cell
        // might put this past the limit & into the completely filled page list.
        //
#if VCELLPOOL_USE_SIGNATURE
        VCELLPOOLASSERT( SIG_PARTIALLY_FILLED_PAGE == pPage->fccSignature );
#endif        

        if( pPage->nCellsInUse == m_nCellsPerPage )
        {
#if VCELLPOOL_USE_SIGNATURE        
            pPage->fccSignature = SIG_COMPLETELY_FILLED_PAGE;
#endif            
            _RemoveFromOldList( m_pPartiallyFilledPages, pPage );
#if DBG            
            m_cPartiallyFilledPages--;
#endif            
            _AddToNewList( m_pCompletelyFilledPages, pPage );
#if DBG            
            m_cCompletelyFilledPages++;
#endif            
        }    
    }
    else if( m_pFreePages != NULL )
    { 
        pPage = m_pFreePages;
        //
        // we are going to use a free page and allocate atleast
        // one cell. So set this page to be a partially filled page
        // or completely filled page depending on the CellsPerPage limit.
        //
#if VCELLPOOL_USE_SIGNATURE
        VCELLPOOLASSERT( SIG_FREE_PAGE == pPage->fccSignature );
#endif        
        VCELLPOOLASSERT( pPage->nCellsInUse == 0 );

        pPage->nCellsInUse++;
        
        _RemoveFromOldList( m_pFreePages, pPage );
#if DBG        
        m_cFreePages--;
#endif        
        
        if( pPage->nCellsInUse != m_nCellsPerPage )
        {            
#if VCELLPOOL_USE_SIGNATURE        
            pPage->fccSignature = SIG_PARTIALLY_FILLED_PAGE;
#endif            
            _AddToNewList( m_pPartiallyFilledPages, pPage );
#if DBG            
            m_cPartiallyFilledPages++;
#endif
        }
        else
        { 
#if VCELLPOOL_USE_SIGNATURE        
            pPage->fccSignature = SIG_COMPLETELY_FILLED_PAGE;
#endif            
            _AddToNewList( m_pCompletelyFilledPages, pPage );
#if DBG            
            m_cCompletelyFilledPages++;
#endif
        }    
    }
    else // need to allocate a page
    {
        pPage = _AcquireCleanPage();
        if( NULL == pPage )
        {
            VCELLPOOLASSERT(0);
            goto abort;
        }

#if VCELLPOOL_USE_SIGNATURE        
        VCELLPOOLASSERT( SIG_FREE_PAGE == pPage->fccSignature );
#endif        
        VCELLPOOLASSERT( pPage->nCellsInUse == 0 );

        pPage->nCellsInUse++;
        
        if( pPage->nCellsInUse != m_nCellsPerPage )
        {  
#if VCELLPOOL_USE_SIGNATURE        
            pPage->fccSignature = SIG_PARTIALLY_FILLED_PAGE;
#endif            
            _AddToNewList( m_pPartiallyFilledPages, pPage );
#if DBG            
            m_cPartiallyFilledPages++;
#endif            
        }
        else
        {
#if VCELLPOOL_USE_SIGNATURE        
            pPage->fccSignature = SIG_COMPLETELY_FILLED_PAGE;
#endif            
            _AddToNewList( m_pCompletelyFilledPages, pPage );
#if DBG            
            m_cCompletelyFilledPages++;
#endif            
        }
    }    

    pNewCell = pPage->pFreeChain;
    pPage->pFreeChain = pNewCell->pFreeLink;
#if DBG    
    if ( pPage->pEndFreeChain == pNewCell )
    {
        pPage->pEndFreeChain = NULL;
    }
#endif
    
    pNewCell->pFreeLink = NULL;
    
#if VCELLPOOL_USE_SIGNATURE   
    VCELLPOOLASSERT( SIG_FREE_CELL == pNewCell->fccSignature )
    pNewCell->fccSignature = SIG_USED_CELL;
#endif    

    *ppCell = (void *) ( (char *) pNewCell - m_cbCellSize );  
    VCELLPOOLASSERT( ( (QWORD) *ppCell % CELL_ALIGNMENT ) == 0 );

#if DBG && FILL_CELL_WITH_DEBUG_PATTERN
    VCELLPOOLASSERT( m_cbCellSize > 2 );

    FillMemory( *ppCell, m_cbCellSize, (BYTE)( m_AllocPattern & 0x000000FF ) );
#endif // DBG && FILL_CELL_WITH_DEBUG_PATTERN

#if DBG
    VCELLPOOLASSERT( m_nPageCount == ( m_cFreePages + m_cPartiallyFilledPages + m_cCompletelyFilledPages ) );
#endif    

abort:
    return( ( *ppCell != NULL ) ? S_OK : E_OUTOFMEMORY );        
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CVCellPool::ReleaseCell( void *pClientCell )
{
#if DBG
    if ( g_fUseNewDelete )
    {
        ::delete [] pClientCell;
        return( S_OK );
    }
#endif

    HRESULT hr = S_OK;
    PCELLHEADER pCell;
    PPAGEHEADER pPage;

#if DBG
    if( !m_fInitialized )
    {
        VCELLPOOLASSERT(0);
        hr = E_UNEXPECTED;
        goto abort;
    }
#endif // DBG

    VCELLPOOLASSERT( ( (QWORD) pClientCell % CELL_ALIGNMENT ) == 0 );
    pCell = (PCELLHEADER) ( (char*) pClientCell + m_cbCellSize );  
    pPage = pCell->pPageHeader;    
    
#if DBG    
    if( !_IsValidCell( pCell ) )
    {
        VCELLPOOLASSERT(0);
        hr = E_INVALIDARG;
        goto abort;
    }

    if( !_IsValidPage( pPage )
    ||  !_CellIsOnPage( pCell, pPage ) 
#if VCELLPOOL_USE_SIGNATURE    
    ||  ( SIG_USED_CELL != pCell->fccSignature ) 
#endif  // VCELLPOOL_USE_SIGNATURE  
    )
    {
        VCELLPOOLASSERT(0);
        hr = E_FAIL;
        goto abort;
    }

    if( this != pPage->pOwnerPool )
    {
        VCELLPOOLASSERT(0);
        hr = E_FAIL;
        goto abort;
    }
#endif

#if DBG
    VCELLPOOLASSERT( m_nPageCount == ( m_cFreePages + m_cPartiallyFilledPages + m_cCompletelyFilledPages ) );
#endif

#if DBG && FILL_CELL_WITH_DEBUG_PATTERN
    FillMemory( pClientCell, m_cbCellSize, DELETE_PATTERN );
#endif // DBG && FILL_CELL_WITH_DEBUG_PATTERN

#if VCELLPOOL_USE_SIGNATURE
    pCell->fccSignature = SIG_FREE_CELL;
#endif    


#if DBG && PUT_CELLS_AT_TAIL_OF_LIST
    // Put it at the tail of the free list.
    pCell->pFreeLink = NULL;
    if ( pPage->pEndFreeChain )
    {
        pPage->pEndFreeChain->pFreeLink = pCell;
    }
    pPage->pEndFreeChain = pCell;
    if ( NULL == pPage->pFreeChain )
    {
        pPage->pFreeChain = pCell;
    }
#else
    // Put it at the head of the free list.
    pCell->pFreeLink = pPage->pFreeChain;
    pPage->pFreeChain = pCell;   
#endif

    
#if VCELLPOOL_USE_SIGNATURE
    VCELLPOOLASSERT( pPage->fccSignature != SIG_FREE_PAGE );
#endif    

    if( pPage->nCellsInUse < m_nCellsPerPage )
    {
#if VCELLPOOL_USE_SIGNATURE
        VCELLPOOLASSERT( pPage->fccSignature == SIG_PARTIALLY_FILLED_PAGE );
#endif        
        pPage->nCellsInUse--;
        
        if( pPage->nCellsInUse == 0 )
        {
#if VCELLPOOL_USE_SIGNATURE        
            pPage->fccSignature = SIG_FREE_PAGE;
#endif            
            _RemoveFromOldList( m_pPartiallyFilledPages, pPage );
#if DBG            
            m_cPartiallyFilledPages--;
#endif            
            _AddToNewList( m_pFreePages, pPage );
#if DBG            
            m_cFreePages++;
#endif            

            if( m_fFreeUnusedPages )
            {
                _FreeAnUnusedPage();
            }            
        }       
    }
    else // pPage->nCellsInUse == m_nCellsPerPage
    {
#if VCELLPOOL_USE_SIGNATURE        
        VCELLPOOLASSERT( pPage->fccSignature == SIG_COMPLETELY_FILLED_PAGE );
#endif        
        pPage->nCellsInUse--;
        _RemoveFromOldList( m_pCompletelyFilledPages, pPage );
        
#if DBG        
        m_cCompletelyFilledPages--;
#endif        
        
        if( pPage->nCellsInUse == 0 )
        {
#if VCELLPOOL_USE_SIGNATURE        
            pPage->fccSignature = SIG_FREE_PAGE;
#endif            
            _AddToNewList( m_pFreePages, pPage );
#if DBG            
            m_cFreePages++;
#endif            
            
            if( m_fFreeUnusedPages )
            {
                _FreeAnUnusedPage();
            }            
        } 
        else
        {
#if VCELLPOOL_USE_SIGNATURE        
            pPage->fccSignature = SIG_PARTIALLY_FILLED_PAGE;
#endif            
            _AddToNewList( m_pPartiallyFilledPages, pPage );
#if DBG            
            m_cPartiallyFilledPages++;
#endif            
        }                
    }    
        
#if DBG
    VCELLPOOLASSERT( m_nPageCount == ( m_cFreePages + m_cPartiallyFilledPages + m_cCompletelyFilledPages ) );
#endif    

#if DBG
abort:
#endif
    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CVCellPool::FindCellContaining( void *pvLocation, void **ppCell )
{
    HRESULT hr = S_OK;
    BOOL fFound = FALSE;
    DWORD nOffset;
    PPAGEHEADER pPage;

    //
    // we look for only in Partially filled & completely filled pages
    //
    
    for( int i = 1; ( i < VCELLPOOL_NUM_PAGE_LIST ) && ( !fFound ) ; i++ )
    {
        pPage = m_rgPages[i];
        while( NULL != pPage )
        {
            if( 0 < pPage->nCellsInUse )
            {
                if( ( pvLocation >= pPage->pCells )
                &&  ( pvLocation < ( (char *) pPage + m_cbActualPageSize ) ) )
                {
                    fFound = TRUE;
                    break;
                }            
            }
            pPage = pPage->pNextPage;
        }
    }

    if( !pPage )
    {
        VCELLPOOLASSERT(0);
        hr = E_INVALIDARG;
        goto abort;
    }
    
    nOffset = (DWORD) ( (char *) pvLocation - (char *) pPage->pCells );
    
    nOffset -= nOffset % m_cbActualCellSize;
        
    if( ppCell )
    {
        *ppCell = (void *) ( (char *) pPage->pCells + nOffset );
        VCELLPOOLASSERT( ( (QWORD) *ppCell % CELL_ALIGNMENT ) == 0 );
    }

abort:
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CVCellPool::GetInfo( DWORD *pTotalPages, DWORD *pPagesOccupied, DWORD *pCellsOccupied )
{
#if DBG
    HRESULT hr = S_OK;
    DWORD nCellsInUse = 0;
    DWORD nPagesInUse = 0;
    PPAGEHEADER pPage;
    int i;

    if( !m_fInitialized )
    {
        VCELLPOOLASSERT(0);
        hr = E_UNEXPECTED;
        goto abort;
    }

    //
    // Calculate cells and pages in use
    //

    for( i = 0; i < VCELLPOOL_NUM_PAGE_LIST; i++ )
    {
        pPage = m_rgPages[i];
        while( NULL != pPage )
        {
            if( 0 < pPage->nCellsInUse )
            {
                nPagesInUse++;
                nCellsInUse += pPage->nCellsInUse;
            }
            pPage = pPage->pNextPage;
        }    
    }

    //
    // Return the requested values
    //
    if( pTotalPages )
    {
        *pTotalPages = m_nPageCount;
    }
    if( pPagesOccupied )
    {
        *pPagesOccupied = nPagesInUse;
    }
    if( pCellsOccupied )
    {
        *pCellsOccupied = nCellsInUse;        
    }

abort:
    return( S_OK );
#else
    return( E_NOTIMPL );
#endif    
}


//////////////////////////////////////////////////////////////////////
// Private Methods

//////////////////////////////////////////////////////////////////////////////
CVCellPool::PPAGEHEADER CVCellPool::_AcquireCleanPage()
{
#ifdef  WIN32
    PPAGEHEADER pNewPage = (PPAGEHEADER) new char[ m_cbActualPageSize ];
#else
    PPAGEHEADER pNewPage = (PPAGEHEADER) GlobalAllocPtr( GMEM_MOVEABLE, m_cbActualPageSize );
#endif  // WIN32

    if( NULL == pNewPage )
    {
#if DBG
        DWORD err = GetLastError();
        HRESULT hr = HRESULT_FROM_WIN32( err );
        VCELLPOOLASSERT( 0 );
#endif
        return( NULL );
    }

    VCELLPOOLASSERT( !g_fUseNewDelete );

#if DBG && PATTERN_PAGES
    FillMemory( ( char * ) pNewPage, m_cbActualPageSize, ALLOC_BUFFER_PATTERN );
#endif

    m_cbTotalMemoryUsed += m_cbActualPageSize;

    // Assign the location of pNewPage->pCells, which will point to the first aligned entry 
    // in the allocated page 

    pNewPage->pCells = (void *) ( CELL_ALIGNMENT * ( ( (QWORD) pNewPage + m_cbPageHeader + CELL_ALIGNMENT - 1 ) / CELL_ALIGNMENT ) );
    VCELLPOOLASSERT( (QWORD) pNewPage->pCells >= (QWORD) pNewPage );

    PCELLHEADER pNewCell;
    PCELLHEADER pFreeLink = NULL;
#if DBG
    pNewPage->pEndFreeChain = NULL;
#endif    
    for( DWORD ix = 0; ix < m_nCellsPerPage; ix++ )
    {
        char *pCell = (char *) ( (char *) pNewPage->pCells + ix * m_cbActualCellSize );
        VCELLPOOLASSERT( ( (QWORD) pCell % CELL_ALIGNMENT ) == 0 );
        pNewCell  = (PCELLHEADER) ( (char *) pCell + m_cbCellSize );
        VCELLPOOLASSERT( ( (QWORD) pNewCell % PROCESSOR_ALIGNMENT ) == 0 );
#if VCELLPOOL_USE_SIGNATURE
        pNewCell->fccSignature = SIG_FREE_CELL;
#endif        
        pNewCell->pPageHeader = pNewPage;
        pNewCell->pFreeLink = pFreeLink;
        pFreeLink = pNewCell;
#if DBG
        // If this is the end of the free chain, then put it at the tail of 
        // the free list.
        if ( NULL == pNewPage->pEndFreeChain )
        {
            pNewPage->pEndFreeChain = pNewCell;        
        }
#endif        
    }
#if VCELLPOOL_USE_SIGNATURE    
    pNewPage->fccSignature = SIG_FREE_PAGE;
#endif    
    pNewPage->pNextPage = NULL;
    pNewPage->pPrevPage = NULL;
    pNewPage->nCellsInUse = 0;
    pNewPage->pFreeChain = pFreeLink;
#if DBG    
    pNewPage->pOwnerPool = this;
#endif    

    m_nPageCount++;

    //WCHAR str[256];
    //swprintf(str, L"%s allocated 1 page of %d bytes & %d cells, %d/%d bytes per cell, ptr = %x\n", 
    //         m_szPoolName, m_cbActualPageSize, m_nCellsPerPage, m_cbCellSize, m_cbActualCellSize,
    //         pNewPage->pCells );
    //OutputDebugStringW(str);

    return( pNewPage );
}

//////////////////////////////////////////////////////////////////////////////
void CVCellPool::_ReleasePage( PPAGEHEADER pPage )
{
#if DBG && PATTERN_PAGES
    if ( NULL != pPage )
    {
        FillMemory( ( char * ) pPage, m_cbActualPageSize, DELETE_BUFFER_PATTERN );
    }
#endif

#ifdef  WIN32
    delete [] (char*)pPage;
#else
    GlobalFreePtr( (char*)pPage );
#endif

    m_nPageCount--;

    //WCHAR str[256];
    //swprintf(str, L"%s released 1 page of %d bytes & %d cells, %d/%d bytes per cell\n", 
    //         m_szPoolName, m_cbActualPageSize, m_nCellsPerPage, m_cbCellSize, m_cbActualCellSize );
    //OutputDebugStringW(str);
}


//////////////////////////////////////////////////////////////////////////////
void CVCellPool::_RemoveFromOldList( PPAGEHEADER & pOldList, PPAGEHEADER & pPage )
{
    if( pPage == pOldList )
    {
        pOldList = pPage->pNextPage;
    }    
        
    if( pPage->pPrevPage )
    {
        VCELLPOOLASSERT( pPage != pOldList );
        pPage->pPrevPage->pNextPage = pPage->pNextPage;
    }

    if( pPage->pNextPage )
    {
        pPage->pNextPage->pPrevPage = pPage->pPrevPage;
    }
}


//////////////////////////////////////////////////////////////////////////////
BOOL CVCellPool::_FreeAnUnusedPage()
{
    PPAGEHEADER pCandidatePage = m_pFreePages;
    DWORD cFreePages = 0;

    //
    // This while loop is not very expensive as we atmost loop it twice.
    // Also most of the server code does not free unused pages,
    // so this code does not get called often.
    //
    while( pCandidatePage )
    {
        cFreePages++;
        if( cFreePages > 1 )
        {
            break;
        }

        pCandidatePage = pCandidatePage->pNextPage;
    }    
    
    pCandidatePage = m_pFreePages;
    
    if( cFreePages > 1 )
    {
        _RemoveFromOldList( m_pFreePages, pCandidatePage );
#if DBG        
        m_cFreePages--;
#endif        
        _ReleasePage( pCandidatePage );
        return( TRUE );
    }   

    return( FALSE );            
}


//////////////////////////////////////////////////////////////////////////////
void CVCellPool::_AddToNewList( PPAGEHEADER & pNewList, PPAGEHEADER & pPage )
{
    if( pNewList )
    {
        VCELLPOOLASSERT( NULL == pNewList->pPrevPage );
        pNewList->pPrevPage = pPage;
        pPage->pNextPage = pNewList;
        pPage->pPrevPage = NULL;
        pNewList = pPage;
    }
    else
    {
        pNewList = pPage;
        pPage->pPrevPage = NULL;
        pPage->pNextPage = NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////
void CVCellPool::_Cleanup()
{
    PPAGEHEADER pNextPage;
    BOOL fQuit = FALSE;

    for( int i = 0; ( i < VCELLPOOL_NUM_PAGE_LIST ) && ( !fQuit ) ; i++ )
    {
        PPAGEHEADER pPage = m_rgPages[i];
        while( NULL != pPage )
        {
            pNextPage = pPage->pNextPage;
#if DBG
            if( pPage->nCellsInUse == 0 )
            {
#if VCELLPOOL_USE_SIGNATURE
                VCELLPOOLASSERT( pPage->fccSignature == SIG_FREE_PAGE );
#endif                
                m_cFreePages--;
            }
            else if( pPage->nCellsInUse < m_nCellsPerPage )
            {
#if VCELLPOOL_USE_SIGNATURE
                VCELLPOOLASSERT( pPage->fccSignature == SIG_PARTIALLY_FILLED_PAGE );
#endif            
                m_cPartiallyFilledPages--;
            }
            else
            {
#if VCELLPOOL_USE_SIGNATURE
                VCELLPOOLASSERT( pPage->fccSignature == SIG_COMPLETELY_FILLED_PAGE );
#endif            
                m_cCompletelyFilledPages--;
            } 
#endif   //DBG         

            _ReleasePage( pPage );

            pPage = pNextPage;
        }
    }    

    ZeroMemory( this, sizeof(*this) );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVCellPool::_IsValidPage( PPAGEHEADER pPage )
{
    BOOL fValid = FALSE;

    for(;;)
    {
#if VCELLPOOL_USE_SIGNATURE    
        if( ( SIG_PARTIALLY_FILLED_PAGE != pPage->fccSignature ) && ( SIG_COMPLETELY_FILLED_PAGE != pPage->fccSignature ) )
        {
            // this isn't a page header (or its corrupted)
            VCELLPOOLASSERT( !"How did this happen?" );
            break;
        }
#endif        

#if DBG && CELLPOOL_PARANOIA
        PPAGEHEADER pTestPage;
        BOOL fFound = FALSE;
        
        for( int i = 0; ( i < VCELLPOOL_NUM_PAGE_LIST ) && ( !fFound ) ; i++ )
        {
            pTestPage = m_rgPages[i];

            while( pTestPage )
            {
                if( pTestPage == pPage )
                {
                    fFound = TRUE;
                    break;
                }
                pTestPage = pTestPage->pNextPage;
            }
        }    
        if( pTestPage != pPage )
        {
            // this isn't one of our pages
            VCELLPOOLASSERT( !"this isn't one of our pages" );
            break;
        }
        // TODO: maybe traverse the page's free chain to look for corruption
#endif // CELLPOOL_PARANOIA

        fValid = TRUE;
        break;
    }

    return( fValid );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVCellPool::_IsValidCell( PCELLHEADER pCell )
{
    BOOL fValid = FALSE;

    for(;;)
    {
#if VCELLPOOL_USE_SIGNATURE    
        if( ( SIG_FREE_CELL != pCell->fccSignature ) && ( SIG_USED_CELL != pCell->fccSignature ) )
        {
            // this isn't a cell header (or its corrupted)
            VCELLPOOLASSERT( !"this isn't a cell header (or its corrupted)" );
            break;
        }
#endif        

        fValid = TRUE;
        break;
    }

    return( fValid );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVCellPool::_CellIsOnPage( PCELLHEADER pCell, PPAGEHEADER pPage )
{
    if( ( (char *) pCell >= (char *) pPage->pCells ) &&
        ( (char *) pCell <= (char *) ( (char *) pPage + m_cbActualPageSize ) ) )
    {
        return( TRUE );
    }
    VCELLPOOLASSERT(0);
    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\tptrlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File: 		tptrlist.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef TPTRLIST_H
#define TPTRLIST_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "vptrlist.h"

typedef void * LISTPOS;

//////////////////////////////////////////////////////////////////////////////
template<class Type>
class CTPtrList : public CVPtrList
{ 
public: 
    // Type casting wrapper class for CVPtrList

    // peek at head or tail
    BOOL GetHead( Type **ppHead ) const;
    BOOL GetTail( Type **ppTail ) const;

    // get head or tail (and remove it)
    BOOL RemoveHead( Type **ppOldHead );
    BOOL RemoveTail( Type **ppOldTail );

    // add before head or after tail
    LISTPOS AddHead( Type *pNewHead );
    LISTPOS AddTail( Type *pNewTail );

    // add another list of elements before head or after tail
    void AddHead( CTPtrList<Type> *pNewList );
    void AddTail( CTPtrList<Type> *pNewList );

    // iteration
    BOOL GetNext( LISTPOS& rLISTPOS, Type **ppNext ) const;
    BOOL GetPrev( LISTPOS& rLISTPOS, Type **ppPrev ) const;

    // getting/modifying an element at a given LISTPOS
    BOOL GetAt( LISTPOS pos, Type **ppElement ) const;
    void SetAt( LISTPOS pos, Type *pNewElement );

    // inserting before or after a given LISTPOS
    LISTPOS InsertBefore( LISTPOS pos, Type *pNewElement );
    LISTPOS InsertAfter( LISTPOS pos, Type *pNewElement );

    // helper functions (note: O(n) speed)
    LISTPOS Find( Type *pSearchValue, LISTPOS startAfter = NULL ) const;
    
    class CTComparator
    {
    public:
        virtual BOOL IsLessThan( Type* p1, Type* p2 ) = 0;
    };

    BOOL Sort( CTComparator* pComparator );
private:
    // Hide void * implementation methods

    // peek at head or tail
    BOOL GetHead( void **ppHead ) const { return( FALSE ); }
    BOOL GetTail( void **ppTail ) const { return( FALSE ); }

    // get head or tail (and remove it)
    BOOL RemoveHead( void **ppOldHead ) { return( FALSE ); }
    BOOL RemoveTail( void **ppOldTail ) { return( FALSE ); }

    // add before head or after tail
    LISTPOS AddHead( void *pNewHead ) { return( (LISTPOS)NULL ); }
    LISTPOS AddTail( void *pNewTail ) { return( (LISTPOS)NULL ); }

    // add another list of elements before head or after tail
    void AddHead( CVPtrList *pNewList ) {}
    void AddTail( CVPtrList *pNewList ) {}

    // iteration
    BOOL GetNext( LISTPOS& rLISTPOS, void **ppNext ) const { return( FALSE ); }
    BOOL GetPrev( LISTPOS& rLISTPOS, void **ppPrev ) const { return( FALSE ); }

    // getting/modifying an element at a given LISTPOS
    BOOL GetAt( LISTPOS pos, void **ppElement ) const { return( FALSE ); }
    void SetAt( LISTPOS pos, void *pNewElement ) {}

    // inserting before or after a given LISTPOS
    LISTPOS InsertBefore( LISTPOS pos, void *pNewElement ) { return( (LISTPOS)NULL ); }
    LISTPOS InsertAfter( LISTPOS pos, void *pNewElement ) { return( (LISTPOS)NULL ); }

    // helper functions (note: O(n) speed)
    LISTPOS Find( void *pSearchValue, LISTPOS startAfter = NULL ) const { return( (LISTPOS)NULL ); }
};


//////////////////////////////////////////////////////////////////////////////
template<class Type>
inline BOOL CTPtrList<Type>::GetHead( Type **ppHead ) const
{
    return( CVPtrList::GetHead( (void **)ppHead ) );
}

template<class Type>
inline BOOL CTPtrList<Type>::GetTail( Type **ppTail ) const
{
    return( CVPtrList::GetTail( (void **)ppTail ) );
}

template<class Type>
inline BOOL CTPtrList<Type>::RemoveHead( Type **ppOldHead )
{
    return( CVPtrList::RemoveHead( (void **)ppOldHead ) );
}

template<class Type>
inline BOOL CTPtrList<Type>::RemoveTail( Type **ppOldTail )
{
    return( CVPtrList::RemoveTail( (void **)ppOldTail ) );
}

template<class Type>
inline LISTPOS CTPtrList<Type>::AddHead( Type *pNewHead )
{
    return( CVPtrList::AddHead( (void *)pNewHead ) );
}

template<class Type>
inline LISTPOS CTPtrList<Type>::AddTail( Type *pNewTail )
{
    return( CVPtrList::AddTail( (void *)pNewTail ) );
}

template<class Type>
inline void CTPtrList<Type>::AddHead( CTPtrList<Type> *pNewList )
{
    CVPtrList::AddHead( (CVPtrList *)pNewList );
}

template<class Type>
inline void CTPtrList<Type>::AddTail( CTPtrList<Type> *pNewList )
{
    CVPtrList::AddTail( (CVPtrList *)pNewList );
}

template<class Type>
inline BOOL CTPtrList<Type>::GetNext( LISTPOS& rLISTPOS, Type **ppNext ) const
{ 
    return( CVPtrList::GetNext( rLISTPOS, (void **)ppNext ) );
}

template<class Type>
inline BOOL CTPtrList<Type>::GetPrev( LISTPOS& rLISTPOS, Type **ppPrev ) const
{ 
    return( CVPtrList::GetPrev( rLISTPOS, (void **)ppPrev ) );
}

template<class Type>
inline BOOL CTPtrList<Type>::GetAt( LISTPOS pos, Type **ppElement ) const
{ 
    return( CVPtrList::GetAt( pos, (void **)ppElement ) );
}

template<class Type>
inline void CTPtrList<Type>::SetAt( LISTPOS pos, Type *pNewElement )
{ 
    CVPtrList::SetAt( pos, (void *)pNewElement );
}

template<class Type>
inline LISTPOS CTPtrList<Type>::InsertBefore( LISTPOS pos, Type *pNewElement )
{
    return( CVPtrList::InsertBefore( pos, (void *)pNewElement ) );
}

template<class Type>
inline LISTPOS CTPtrList<Type>::InsertAfter( LISTPOS pos, Type *pNewElement )
{
    return( CVPtrList::InsertAfter( pos, (void *)pNewElement ) );
}

template<class Type>
inline LISTPOS CTPtrList<Type>::Find( Type *pSearchValue, LISTPOS startAfter ) const
{
    return( CVPtrList::Find( (void *)pSearchValue, startAfter ) );
}

template<class Type>
inline BOOL CTPtrList<Type>::Sort( CTComparator* pComparator )
{
    return( CVPtrList::Sort( (CComparator*) pComparator ) );
}

#endif  // TPTRLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vcelpool.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File: 		vcelpool.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef _VCELPOOL_H
#define _VCELPOOL_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Turn this on for retail/free when you need to 
// debug bugs in free builds. On shipping version
// this should be off. It's always on for DBG builds.
#if DBG
#define VCELLPOOL_USE_SIGNATURE          1
#else
#define VCELLPOOL_USE_SIGNATURE          0  
#endif

#define VCELLPOOL_NUM_PAGE_LIST			 3

#define CACHE_LINE_SIZE                  32
#define CACHE_ALIGN_CELLS                1

#if defined(_X86_)
#define PROCESSOR_ALIGNMENT              4
#else
#define PROCESSOR_ALIGNMENT              8
#endif

#if CACHE_ALIGN_CELLS
#define CELL_ALIGNMENT                   CACHE_LINE_SIZE
#else
#define CELL_ALIGNMENT                   PROCESSOR_ALIGNMENT
#endif


//////////////////////////////////////////////////////////////////////////////
// CVCellPool
//////////////////////////////////////////////////////////////////////////////
class CVCellPool
{
public:
    //////////////////////////////////////////////////////////////////////
    // Public Methods
    CVCellPool();
   ~CVCellPool();

    HRESULT Initialize( DWORD cbCellSize, 
    					DWORD nCellsPerPage, 
                        DWORD nInitialPages, 
                        BOOL fFreeUnusedPages
			);


    HRESULT AcquireCell( void **ppCell );
    HRESULT ReleaseCell( void *pCell );
    HRESULT FindCellContaining( void *pvLocation, void **ppCell );
    HRESULT GetInfo( DWORD *pnTotalPages, DWORD *pnPagesOccupied, DWORD *pnCellsOccupied );
    DWORD   GetTotalMemoryUsed() { return( m_cbTotalMemoryUsed ); }

private:
    struct CELLHEADER;

    //////////////////////////////////////////////////////////////////////
    struct PAGEHEADER
    {
#if VCELLPOOL_USE_SIGNATURE    
        DWORD           fccSignature;   // signature
#endif        
        void           *pCells;         // Where the cells are located
        DWORD           nCellsInUse;    // cells currently allocated 
        CELLHEADER     *pFreeChain;     // list of free cells
        PAGEHEADER     *pNextPage;      // next page of cells
        PAGEHEADER     *pPrevPage;      // prev page of cells
#if DBG        
        CELLHEADER     *pEndFreeChain;  // list of free cells
        CVCellPool     *pOwnerPool;
#endif        
    };  // size == 16 bytes for free && 28 bytes for checked
    typedef PAGEHEADER *PPAGEHEADER;

    //////////////////////////////////////////////////////////////////////
    struct CELLHEADER
    {
#if VCELLPOOL_USE_SIGNATURE    
        DWORD           fccSignature;   // signature
#endif        
        PPAGEHEADER     pPageHeader;    // pointer to this cell's page
        CELLHEADER *    pFreeLink;      // used to link cell in free chain
    };  // size == 8 bytes for free && 12 bytes for checked
    typedef CELLHEADER *PCELLHEADER;

    //////////////////////////////////////////////////////////////////////
    // Private Methods
    PPAGEHEADER _AcquireCleanPage();
    void _ReleasePage( PPAGEHEADER pPage );
    void _Cleanup();
    BOOL _IsValidPage( PPAGEHEADER pPage );
    BOOL _IsValidCell( PCELLHEADER pCell );
    BOOL _FreeAnUnusedPage();
    BOOL _CellIsOnPage( PCELLHEADER pCell, PPAGEHEADER pPage );
    void _RemoveFromOldList( PPAGEHEADER & pOldList, PPAGEHEADER & pItem );
    void _AddToNewList( PPAGEHEADER & pNewList, PPAGEHEADER & pItem );

    //////////////////////////////////////////////////////////////////////
    PPAGEHEADER   m_rgPages[VCELLPOOL_NUM_PAGE_LIST];
    //PPAGEHEADER   m_pFreePages = m_rgPages[0];
#if DBG    
    DWORD         m_cFreePages;    
    //PPAGEHEADER   m_pPartiallyFilledPages = m_rgPages[1];
    DWORD         m_cPartiallyFilledPages;
    //PPAGEHEADER   m_pCompletelyFilledPages = m_rgPages[2];
    DWORD         m_cCompletelyFilledPages;
#endif    
    DWORD  m_cbActualPageSize;
    DWORD  m_nCellsPerPage;
    DWORD  m_cbCellSize;
    DWORD  m_cbActualCellSize;
    DWORD  m_nPageCount;
    DWORD  m_fFreeUnusedPages;
    DWORD  m_fInitialized;
    DWORD  m_cbPageHeader;
    DWORD  m_cbCellHeader;
    DWORD  m_cbTotalMemoryUsed;
    
#if DBG
    DWORD  m_AllocPattern;
#endif // DBG
};

#endif // _VCELPOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vleftist.cpp ===
#include "dstructp.h"


#if DBG
extern BOOL g_fUseNewDelete;
#endif

//////////////////////////////////////////////////////////////////////////////
CVLeftistTree::CVLeftistTree()
{
    m_pRoot = NULL;
    m_dwEntries = 0;
}

///////////////////////////////////////////////////////////////////////////////
#if DBG
CVLeftistTree::~CVLeftistTree()
{
    if( ( g_fUseNewDelete ) && ( 0 != m_dwEntries ) )
    {
        DWORD dwKeyDummy = 0;
        void * pValueDummy = NULL;
        
        // empty the tree
        while( GetNextItem( dwKeyDummy, &pValueDummy ) )
        {
            ;
        }
    }
}
#endif

//////////////////////////////////////////////////////////////////////////////
HRESULT CVLeftistTree::Initialize( DWORD nCellsPerPage, DWORD nInitialPages, BOOL bFreeUnusedPages )
{
    return( m_NodePool.Initialize( sizeof(TreeNode), nCellsPerPage, nInitialPages, bFreeUnusedPages ) );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVLeftistTree::AddItem( DWORD Key, void *pValue )
{
    //
    // Get a new tree node from our pool and initialize it
    //
    TreeNode *pNewNode = NULL;

    if( FAILED( m_NodePool.AcquireCell( (void**)&pNewNode ) ) )
    {
        return( FALSE );
    }

    pNewNode->key = Key;
    pNewNode->value = pValue;
    pNewNode->pLeft = NULL;
    pNewNode->pRight = NULL;
    pNewNode->dist = 1;

    //
    // Merge this new node into our tree
    //
    m_pRoot = LeftistUnion( m_pRoot, pNewNode );

    m_dwEntries++;

    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVLeftistTree::GetNextItem( DWORD &Key, void **ppValue )
{
    if( !m_pRoot )
    {
        return( FALSE );
    }

    //
    // Pull the root node (containing the smallest key) off the tree, and rebalance
    //
    TreeNode *pNextNode = m_pRoot;

    m_pRoot = LeftistUnion( pNextNode->pLeft, pNextNode->pRight );

    //
    // Give the key and value from the root node back to the caller, and recycle the node
    //
    Key = pNextNode->key;
    *ppValue = pNextNode->value;

    m_NodePool.ReleaseCell( (void*)pNextNode );

    m_dwEntries--;

    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVLeftistTree::PeekNextItem( DWORD &Key, void **ppValue )
{
    if( !m_pRoot )
    {
        return( FALSE );
    }

    Key = m_pRoot->key;
    *ppValue = m_pRoot->value;

    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
CVLeftistTree::TreeNode *CVLeftistTree::LeftistUnion( TreeNode *pTreeA, TreeNode *pTreeB )
{
    if( !pTreeA )
    {
        return( pTreeB );
    }
    else if( !pTreeB )
    {
        return( pTreeA );
    }
    else if( pTreeA->key < pTreeB->key )
    {
        return( MergeRight( pTreeA, pTreeB ) );
    }
    else
    {
        return( MergeRight( pTreeB, pTreeA ) );
    }
}

//////////////////////////////////////////////////////////////////////////////
CVLeftistTree::TreeNode *CVLeftistTree::MergeRight( TreeNode *pTreeA, TreeNode *pTreeB )
{
    pTreeA->pRight = LeftistUnion( pTreeA->pRight, pTreeB );

    if( !pTreeA->pLeft || ( pTreeA->pLeft->dist < pTreeA->pRight->dist ) )
    {
        //
        // Swap pTreeA->pLeft and pTreeA->pRight to preserve leftist property
        //
        TreeNode *pTemp = pTreeA->pLeft;
        pTreeA->pLeft = pTreeA->pRight;
        pTreeA->pRight = pTemp;
    }

    //
    //  Fix the distance field of node pTreeA
    //
    if( !pTreeA->pRight )
    {
        pTreeA->dist = 1;
    }
    else
    {
        pTreeA->dist = 1 + min( pTreeA->pLeft->dist, pTreeA->pRight->dist );
    }

    return( pTreeA );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vleftist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File: 		vleftist.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef VLEFTIST_H
#define VLEFTIST_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "vcelpool.h"

//////////////////////////////////////////////////////////////////////////////
class CVLeftistTree
{
public:
    CVLeftistTree();

#if DBG
    ~CVLeftistTree();
#endif

    HRESULT Initialize( DWORD nCellsPerPage = 10, 
                        DWORD nInitialPages = 1, 
                        BOOL bFreeUnusedPages = FALSE );

    BOOL AddItem( DWORD Key, void *pValue );
    BOOL GetNextItem( DWORD& Key, void **ppValue );
    BOOL PeekNextItem( DWORD& Key, void **pValue );

    DWORD GetEntryCount() { return m_dwEntries; }

private:
    struct TreeNode
    {
        DWORD      key;
        void*      value;
        TreeNode  *pLeft;
        TreeNode  *pRight;
        UINT       dist;
    };

    CVCellPool m_NodePool;
    TreeNode *m_pRoot;
    DWORD m_dwEntries;

    TreeNode *LeftistUnion( TreeNode *pTreeA, TreeNode *pTreeB );
    TreeNode *MergeRight( TreeNode *pTreeA, TreeNode *pTreeB );
};


#endif  // LEFTIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vmallocpool.h ===
#pragma once
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       FanOut.h
//
//  Contents: 
//
//--------------------------------------------------------------------------

#ifndef _VMAllocPool_h_
#define _VMAllocPool_h_

#include "tcelpool.h"
#include "tbckhash.h"
#include "leakdetector.h"


//////////////////////////////////////////////////////////////////////////////
class CWMSVMAllocPool
{
public:
    CWMSVMAllocPool();
    virtual ~CWMSVMAllocPool();
    HRESULT Initialize();
    
    BYTE *AllocPages( DWORD dwNumPages );
    void FreePages( BYTE *pData );

protected:
    enum CWMSVMAllocPoolInternalConstants
    {
        // TODO, reeval param
        MAX_PAGES_PER_BUFFER            = 256,      // for 4K pages, allocate 1 meg at a time

        NUM_ACTIVE_BUFFER_HASH_SLOTS    = 251,      // Prime number
    };

    ///////////////////////////////////////
    class CVMBufferInfo
    {
    public:
        BYTE            *m_pBuffer;
        DWORD           m_dwNumPages;
        BOOL            m_fFree;

        // These link together either active buffers or free buffers.
        // A buffer may only be in one list, active or free, depending
        // on whether that buffer is active or free.
        CVMBufferInfo   *m_pPrev;
        CVMBufferInfo   *m_pNext;

        // This links buffers that point to adjacent pieces of virtual
        // memory. It allows us to combine adjacent free buffers.
        CVMBufferInfo   *m_pPrevInMemory;
        CVMBufferInfo   *m_pNextInMemory;
    }; // CVMBufferInfo


    CVMBufferInfo *FindFreeBuffer( DWORD dwNumPages );
    CVMBufferInfo *AllocNewBuffer();
    HRESULT TrimBuffer( CVMBufferInfo *pVMInfo, DWORD dwNumPages );

    void CombineFreeBuffers( CVMBufferInfo *pLowerBuffer, CVMBufferInfo *pUpperBuffer );

    void AddBufferToFreeList( CVMBufferInfo *pVMInfo );
    void RemoveBufferFromFreeList( CVMBufferInfo *pVMInfo );

    void AddBufferToActiveList( CVMBufferInfo *pVMInfo );
    void RemoveBufferFromActiveList( CVMBufferInfo *pVMInfo );
    CVMBufferInfo *FindBufferInActiveList( BYTE *ptr );

    CRITICAL_SECTION                m_CriticalSection;

    DWORD                           m_dwBytesPerPage;
    DWORD                           m_dwNumPagesPerVirtualAlloc;
    DWORD                           m_dwBytesPerVirtualAlloc;
    DWORD                           m_dwNumIdlePages;
    // DWORD                        m_dwMaxIdlePages;

    CVMBufferInfo                   *m_pIdleBuffers;
    CVMBufferInfo *                 m_FreeBuffers[MAX_PAGES_PER_BUFFER];
    CVMBufferInfo *                 m_ActiveBuffers[NUM_ACTIVE_BUFFER_HASH_SLOTS];

    CTCellPool<CVMBufferInfo>       m_BufferPool;

#if DBG_MEM_LEAK
private:
    void *m_pLeakDetector;
#endif
}; // End of CWMSVMAllocPool.


#endif // _VMAllocPool_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vmallocpool.cpp ===
#include "dstructp.h"


#if DBG
extern BOOL g_fUseNewDelete;
#endif


// have this use a shift 
// #define HASH_PTR_TO_BUCKET( ptr ) ( ( ( DWORD ) ( ptr ) >> m_dwBytesPerPageLog2 ) % NUM_ACTIVE_BUFFER_HASH_SLOTS )
//note - Hashing a pointer value -> (0..NUM_ACTIVE_BUFFER_HASH_SLOTS -1). Since NUM_ACTIVE_BUFFER_HASH_SLOTS 251, a DWORD is plenty
#define HASH_PTR_TO_BUCKET( ptr ) ((DWORD)( ( ( SIZE_T ) ( ptr ) / m_dwBytesPerPage ) % NUM_ACTIVE_BUFFER_HASH_SLOTS ))



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CWMSVMAllocPool::CWMSVMAllocPool()
{
    HRESULT hr = S_OK;
    SYSTEM_INFO sysInfo;
    DWORD i;

    InitializeCriticalSection( &m_CriticalSection );

    GetSystemInfo( &sysInfo );
    m_dwBytesPerPage = sysInfo.dwPageSize;
    m_dwNumPagesPerVirtualAlloc = MAX_PAGES_PER_BUFFER;
    m_dwBytesPerVirtualAlloc = m_dwBytesPerPage * m_dwNumPagesPerVirtualAlloc;

    // Initially, there are no empty buffers.
    for ( i = 0; i < m_dwNumPagesPerVirtualAlloc; i++ )
    {
        m_FreeBuffers[i] = NULL;
    }

    // Initially, there are no active buffers.
    for ( i = 0; i < NUM_ACTIVE_BUFFER_HASH_SLOTS; i++ )
    {
        m_ActiveBuffers[i] = NULL;
    }

    m_pIdleBuffers = NULL;
    m_dwNumIdlePages = 0;
    // m_dwMaxIdlePages = m_dwNumPagesPerVirtualAlloc * 3;

#if DBG_MEM_LEAK
    m_pLeakDetector = malloc( 1 );
#endif
} // End of CWMSVMAllocPool.




/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CWMSVMAllocPool::~CWMSVMAllocPool()
{
    DeleteCriticalSection( &m_CriticalSection );

#if DBG_MEM_LEAK
    if( NULL != m_pLeakDetector )
    {
        free( m_pLeakDetector );
    }
#endif
} // End of ~CWMSVMAllocPool




/////////////////////////////////////////////////////////////////////////////
//
// [Initialize] -- ReEntrant method
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWMSVMAllocPool::Initialize()
{
    HRESULT hr = S_OK;

    hr = m_BufferPool.Initialize();
    if ( FAILED( hr ) )
    {
        goto abort;
    }

abort:
    return( hr );
} // End of Initialize.





/////////////////////////////////////////////////////////////////////////////
//
// [AllocPages]
//
/////////////////////////////////////////////////////////////////////////////
BYTE *
CWMSVMAllocPool::AllocPages( DWORD dwNumPages )
{
#if DBG
    if ( g_fUseNewDelete )
    {
        return( ::new BYTE[ m_dwBytesPerPage * dwNumPages ] );
    }
#endif

    HRESULT hr = S_OK;
    CVMBufferInfo *pVMInfo = NULL;

    EnterCriticalSection( &m_CriticalSection );

    if( 0 == dwNumPages ) 
    {
        goto abort;
    }

    if( dwNumPages > m_dwNumPagesPerVirtualAlloc )
    {
        // Need to do a special allocation to satisfy this requestion

        pVMInfo = m_BufferPool.AcquireElement();
        if ( NULL == pVMInfo )
        {
            goto abort;
        }

        // 48836 - Check for overflow
        if(dwNumPages > (0xFFFFFFFF / m_dwBytesPerPage))
        {
            goto abort;
        }

        pVMInfo->m_pBuffer = ( BYTE * ) VirtualAlloc(
                                    NULL,                     // region to reserve or commit
                                    dwNumPages * m_dwBytesPerPage, // size of region
                                    MEM_COMMIT, // type of allocation
                                    PAGE_READWRITE // type of access protection
                                    );
        if ( NULL == pVMInfo->m_pBuffer )
        {
            goto abort;
        }

        pVMInfo->m_dwNumPages = dwNumPages;
        pVMInfo->m_fFree = FALSE;
        pVMInfo->m_pPrev = NULL;
        pVMInfo->m_pNext = NULL;
        pVMInfo->m_pPrevInMemory = NULL;
        pVMInfo->m_pNextInMemory = NULL;

        goto done;
    }


    pVMInfo = FindFreeBuffer( dwNumPages );
    if ( NULL == pVMInfo )
    {
        pVMInfo = AllocNewBuffer();
        if ( NULL == pVMInfo )
        {
            goto abort;
        }
    }

    RemoveBufferFromFreeList( pVMInfo );

    hr = TrimBuffer( pVMInfo, dwNumPages );
    if ( FAILED( hr ) )
    {
        AddBufferToFreeList( pVMInfo );
        goto abort;
    }

done:
    AddBufferToActiveList( pVMInfo );

    LeaveCriticalSection( &m_CriticalSection );
    return( pVMInfo->m_pBuffer );

abort:
    LeaveCriticalSection( &m_CriticalSection );
    return( NULL );
} // AllocPages.





/////////////////////////////////////////////////////////////////////////////
//
// [FreePages]
//
/////////////////////////////////////////////////////////////////////////////
void
CWMSVMAllocPool::FreePages( BYTE *pData )
{
#if DBG
    if ( g_fUseNewDelete )
    {
        ::delete [] pData;
        return;
    }
#endif

    HRESULT hr = S_OK;
    CVMBufferInfo *pLowerBuffer = NULL;
    CVMBufferInfo *pUpperBuffer = NULL;
    CVMBufferInfo *pVMInfo = NULL;
    EnterCriticalSection( &m_CriticalSection );

    pVMInfo = FindBufferInActiveList( pData );
    if ( ( NULL == pVMInfo ) 
        || ( pVMInfo->m_fFree ) )
    {
        goto abort;
    }

    RemoveBufferFromActiveList( pVMInfo );

    if( pVMInfo->m_dwNumPages > m_dwNumPagesPerVirtualAlloc )
    {
        // Need to do a special free to satisfy this request
        // NOTE: Calling VirtualFree with MEM_DECOMMIT only decommits the memory
        // and does not free the VADs.  MEM_RELEASE both decommits and frees
        // the VADs.  MEM_RELEASE also requires that dwSize be zero.
        VirtualFree( pVMInfo->m_pBuffer, 
                     0,
                     MEM_RELEASE );

        m_BufferPool.ReleaseElement( pVMInfo );
        
        goto abort;
    }
    
    AddBufferToFreeList( pVMInfo );

    // Neel says to avoid fast re-merge; since we will immediately 
    // have to free data again.
    pLowerBuffer = pVMInfo->m_pPrevInMemory;
    pUpperBuffer = pVMInfo->m_pNextInMemory;

#if 1
    if ( NULL != pLowerBuffer )
    {
        if ( pLowerBuffer->m_fFree )
        {
            CombineFreeBuffers( pLowerBuffer, pVMInfo );
            // This keeps the lower buffer and discards the upper buffer.
            pVMInfo = pLowerBuffer;
        }
    }

    if ( NULL != pUpperBuffer )
    {
        if ( pUpperBuffer->m_fFree )
        {
            CombineFreeBuffers( pVMInfo, pUpperBuffer );
        }
    }

    // If this entire buffer is free, then place it on an idle
    // list. Buffers on this idle list are candidates to be returned
    // to the operating system if we are using too much memory.
    if ( pVMInfo->m_dwNumPages == m_dwNumPagesPerVirtualAlloc )
    {
        RemoveBufferFromFreeList( pVMInfo );

        pVMInfo->m_pNext = m_pIdleBuffers;
        m_pIdleBuffers = pVMInfo;

        m_dwNumIdlePages = m_dwNumIdlePages + pVMInfo->m_dwNumPages;
    }

#endif

abort:
    LeaveCriticalSection( &m_CriticalSection );
    return;
} // FreePages.






/////////////////////////////////////////////////////////////////////////////
//
// [FindFreeBuffer]
//
/////////////////////////////////////////////////////////////////////////////
CWMSVMAllocPool::CVMBufferInfo *
CWMSVMAllocPool::FindFreeBuffer( DWORD dwNumPages )
{
    HRESULT hr = S_OK;
    DWORD i;

    // Initially, there are no empty buffers.
    for ( i = dwNumPages - 1; i < m_dwNumPagesPerVirtualAlloc; i++ )
    {
        if ( NULL != m_FreeBuffers[i] )
        {
            return( m_FreeBuffers[i] );
        }
    }

    return( NULL );
} // End of FindFreeBuffer.





/////////////////////////////////////////////////////////////////////////////
//
// [AllocNewBuffer]
//
/////////////////////////////////////////////////////////////////////////////
CWMSVMAllocPool::CVMBufferInfo *
CWMSVMAllocPool::AllocNewBuffer()
{
    HRESULT hr = S_OK;
    CVMBufferInfo *pVMInfo = NULL;

    // If there is an idle buffer waiting to be returned
    // to the operating system, then use it.
    if ( NULL != m_pIdleBuffers )
    {
        pVMInfo = m_pIdleBuffers;
        m_pIdleBuffers = m_pIdleBuffers->m_pNext;
        m_dwNumIdlePages = m_dwNumIdlePages - pVMInfo->m_dwNumPages;

        AddBufferToFreeList( pVMInfo );

        return( pVMInfo );
    }

    pVMInfo = m_BufferPool.AcquireElement();
    if ( NULL == pVMInfo )
    {
        goto abort;
    }

    pVMInfo->m_pBuffer = ( BYTE * ) VirtualAlloc(
                                NULL, // region to reserve or commit
                                m_dwBytesPerVirtualAlloc, // size of region
                                MEM_COMMIT, // type of allocation
                                PAGE_READWRITE // type of access protection
                                );
    if ( NULL == pVMInfo->m_pBuffer )
    {
        goto abort;
    }

    pVMInfo->m_dwNumPages = m_dwNumPagesPerVirtualAlloc;
    pVMInfo->m_fFree = TRUE;
    pVMInfo->m_pPrev = NULL;
    pVMInfo->m_pNext = NULL;
    pVMInfo->m_pPrevInMemory = NULL;
    pVMInfo->m_pNextInMemory = NULL;

    AddBufferToFreeList( pVMInfo );

    return( pVMInfo );

abort:
    if ( NULL != pVMInfo )
    {
        m_BufferPool.ReleaseElement( pVMInfo );
    }

    return( NULL );
} // End of AllocNewBuffer.





/////////////////////////////////////////////////////////////////////////////
//
// [TrimBuffer]
//
// This assumes: 
//   1. The lock is held.
//   2. The buffer is not in the free list.
/////////////////////////////////////////////////////////////////////////////
HRESULT
CWMSVMAllocPool::TrimBuffer( CVMBufferInfo *pVMInfo, DWORD dwNumPages )
{
    HRESULT hr = S_OK;
    CVMBufferInfo *pUpperBuffer = NULL;
    DWORD numBytesInTrimmedBuffer;
    DWORD numPagesInTrimmedBuffer;
    DWORD numBytesInUpperBuffer;
    DWORD numPagesInUpperBuffer;

    if ( NULL == pVMInfo )
    {
        hr = E_INVALIDARG;
        goto abort;
    }

    // If the buffer is the correct size, then there is nothing to do.
    if ( dwNumPages == pVMInfo->m_dwNumPages )
    {
        hr = S_OK;
        goto abort;
    }
    if ( pVMInfo->m_dwNumPages < dwNumPages )
    {
        hr = E_UNEXPECTED;
        goto abort;
    }

    // Figure where we will split the buffers.
    numPagesInTrimmedBuffer = dwNumPages;
    numBytesInTrimmedBuffer = numPagesInTrimmedBuffer * m_dwBytesPerPage;
    numPagesInUpperBuffer = pVMInfo->m_dwNumPages - dwNumPages;
    numBytesInUpperBuffer = numPagesInUpperBuffer * m_dwBytesPerPage;


    // Allocate a buffer descriptor for the extra pages.
    pUpperBuffer = m_BufferPool.AcquireElement();
    if ( NULL == pUpperBuffer )
    {
        goto abort;
    }
    pUpperBuffer->m_pBuffer = pVMInfo->m_pBuffer + numBytesInTrimmedBuffer;
    pUpperBuffer->m_dwNumPages = numPagesInUpperBuffer;

    // Add the new buffer descriptor to the list of physically adjacent buffers.
    pUpperBuffer->m_pPrevInMemory = pVMInfo;
    pUpperBuffer->m_pNextInMemory = pVMInfo->m_pNextInMemory;
    pVMInfo->m_pNextInMemory = pUpperBuffer;
    if ( NULL != pUpperBuffer->m_pNextInMemory )
    {
        pUpperBuffer->m_pNextInMemory->m_pPrevInMemory = pUpperBuffer;
    }

    AddBufferToFreeList( pUpperBuffer );

    pVMInfo->m_dwNumPages = dwNumPages;

    return( S_OK );

abort:
    if ( NULL != pUpperBuffer )
    {
        m_BufferPool.ReleaseElement( pUpperBuffer );
    }

    return( hr );
} // End of TrimBuffer.






/////////////////////////////////////////////////////////////////////////////
//
// [AddBufferToFreeList]
//
// This ASSUMES that the lock is held.
/////////////////////////////////////////////////////////////////////////////
void
CWMSVMAllocPool::AddBufferToFreeList( CVMBufferInfo *pVMInfo )
{
    if ( NULL != pVMInfo )
    {
        DWORD dx = pVMInfo->m_dwNumPages - 1;

        pVMInfo->m_fFree = TRUE;
        pVMInfo->m_pPrev = NULL;
        pVMInfo->m_pNext = m_FreeBuffers[dx];

        if ( NULL != m_FreeBuffers[dx] )
        {
            m_FreeBuffers[dx]->m_pPrev = pVMInfo;
        }
        m_FreeBuffers[dx] = pVMInfo;
    }
} // End of AddBufferToFreeList.





/////////////////////////////////////////////////////////////////////////////
//
// [RemoveBufferFromFreeList]
//
// This ASSUMES that the lock is held.
/////////////////////////////////////////////////////////////////////////////
void
CWMSVMAllocPool::RemoveBufferFromFreeList( CVMBufferInfo *pVMInfo )
{
    if ( NULL != pVMInfo )
    {
        pVMInfo->m_fFree = FALSE;

        if ( NULL != pVMInfo->m_pPrev )
        {
            pVMInfo->m_pPrev->m_pNext = pVMInfo->m_pNext;
        }
        else
        {
            m_FreeBuffers[pVMInfo->m_dwNumPages - 1] = pVMInfo->m_pNext;
        }

        if ( NULL != pVMInfo->m_pNext )
        {
            pVMInfo->m_pNext->m_pPrev = pVMInfo->m_pPrev;
        }
    }
} // End of RemoveBufferFromFreeList.






/////////////////////////////////////////////////////////////////////////////
//
// [CombineFreeBuffers]
//
// This ASSUMES that the lock is held.
//
// This discards the upper buffer.
/////////////////////////////////////////////////////////////////////////////
void
CWMSVMAllocPool::CombineFreeBuffers( 
                        CVMBufferInfo *pLowerBuffer, 
                        CVMBufferInfo *pUpperBuffer 
                        )
{
    if ( ( NULL == pLowerBuffer ) 
        || ( NULL == pUpperBuffer )
        || ( pLowerBuffer == pUpperBuffer ) )
    {
        return;
    }

    RemoveBufferFromFreeList( pLowerBuffer );
    RemoveBufferFromFreeList( pUpperBuffer );


    pLowerBuffer->m_dwNumPages = pLowerBuffer->m_dwNumPages + pUpperBuffer->m_dwNumPages;

    pLowerBuffer->m_pNextInMemory = pUpperBuffer->m_pNextInMemory;
    if ( NULL != pUpperBuffer->m_pNextInMemory )
    {
        pUpperBuffer->m_pNextInMemory->m_pPrevInMemory = pLowerBuffer;
    }

    AddBufferToFreeList( pLowerBuffer );

    m_BufferPool.ReleaseElement( pUpperBuffer );
} // End of CombineFreeBuffers.






/////////////////////////////////////////////////////////////////////////////
//
// [AddBufferToActiveList]
//
// This ASSUMES that the lock is held.
/////////////////////////////////////////////////////////////////////////////
void
CWMSVMAllocPool::AddBufferToActiveList( CVMBufferInfo *pVMInfo )
{
    DWORD dwIndex;

    if ( NULL != pVMInfo )
    {
        dwIndex = HASH_PTR_TO_BUCKET( pVMInfo->m_pBuffer );

        pVMInfo->m_fFree = FALSE;
        pVMInfo->m_pPrev = NULL;
        pVMInfo->m_pNext = m_ActiveBuffers[dwIndex];

        if ( NULL != m_ActiveBuffers[dwIndex] )
        {
            m_ActiveBuffers[dwIndex]->m_pPrev = pVMInfo;
        }
        m_ActiveBuffers[dwIndex] = pVMInfo;
    }
} // End of AddBufferToActiveList.





/////////////////////////////////////////////////////////////////////////////
//
// [RemoveBufferFromActiveList]
//
// This ASSUMES that the lock is held.
/////////////////////////////////////////////////////////////////////////////
void
CWMSVMAllocPool::RemoveBufferFromActiveList( CVMBufferInfo *pVMInfo )
{
    DWORD dwIndex;

    if ( NULL != pVMInfo )
    {
        dwIndex = HASH_PTR_TO_BUCKET( pVMInfo->m_pBuffer );

        pVMInfo->m_fFree = TRUE;

        if ( NULL != pVMInfo->m_pPrev )
        {
            pVMInfo->m_pPrev->m_pNext = pVMInfo->m_pNext;
        }
        else
        {
            m_ActiveBuffers[dwIndex] = pVMInfo->m_pNext;
        }

        if ( NULL != pVMInfo->m_pNext )
        {
            pVMInfo->m_pNext->m_pPrev = pVMInfo->m_pPrev;
        }
    }
} // End of RemoveBufferFromActiveList.




/////////////////////////////////////////////////////////////////////////////
//
// [FindBufferInActiveList]
//
// This ASSUMES that the lock is held.
/////////////////////////////////////////////////////////////////////////////
CWMSVMAllocPool::CVMBufferInfo *
CWMSVMAllocPool::FindBufferInActiveList( BYTE *ptr )
{
    DWORD dwIndex;
    CVMBufferInfo *pVMInfo;

    dwIndex = HASH_PTR_TO_BUCKET( ptr );

    pVMInfo = m_ActiveBuffers[dwIndex];
    while ( NULL != pVMInfo )
    {
        if ( ptr == pVMInfo->m_pBuffer )
        {
            return( pVMInfo );
        }

        pVMInfo = pVMInfo->m_pNext;
    }

    return( NULL );
} // End of FindBufferInActiveList.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vfifolif.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File: 		vfifolif.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef VFIFOLIF_H
#define VFIFOLIF_H

#include "vcelpool.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////
class CVLifo
{
public:
    CVLifo() { m_fInitialized = FALSE; m_dwCount = 0; }

#if DBG
    ~CVLifo();
#endif
    
    HRESULT Initialize( DWORD dwElementsPerPage = 10 );
    
    HRESULT Push( void *pElement );
    BOOL Pop( void **pElement );
    BOOL Peek( void **pElement );
    
    DWORD Count() { return( m_dwCount ); }

private:
    struct NODE
    {
        void *pData;
        NODE *pNext;    
    };
    
    CVCellPool m_NodePool;
    NODE *m_pHead;
    DWORD m_dwCount;
    BOOL m_fInitialized;
};

//////////////////////////////////////////////////////////////////////////////
class CVFifo
{
public:
    CVFifo() { m_fInitialized = FALSE; m_dwCount = 0; }

#if DBG
    ~CVFifo();
#endif

    HRESULT Initialize( DWORD dwElementsPerPage = 10 );
    
    HRESULT Push( void *pElement );
    BOOL Pop( void **pElement );
    BOOL Peek( void **pElement );
    
    DWORD Count() { return( m_dwCount ); }

private:
    struct NODE
    {
        void *pData;
        NODE *pNext;    
    };
    
    CVCellPool m_NodePool;
    NODE *m_pHead;
    NODE *m_pTail;
    DWORD m_dwCount;
    BOOL m_fInitialized;
};

#endif // FIFOLIFO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vfifolif.cpp ===
#include "dstructp.h"


#if DBG
extern BOOL g_fUseNewDelete;
#endif

//////////////////////////////////////////////////////////////////////////////
// CVLifo public methods

//////////////////////////////////////////////////////////////////////////////
#if DBG
CVLifo::~CVLifo()
{
    if( ( g_fUseNewDelete ) && ( 0 != m_dwCount ) )
    {
        void * pElementDummy = NULL;
        
        while( Pop( &pElementDummy ) )
        {
            ;
        }
    }
}
#endif

//////////////////////////////////////////////////////////////////////////////
HRESULT CVLifo::Initialize( DWORD dwElementsPerPage )
{
    if( m_fInitialized )
    {
        return( E_UNEXPECTED );
    }

    if( FAILED( m_NodePool.Initialize( sizeof(NODE), dwElementsPerPage, 1, FALSE ) ) )
    {
        return( E_OUTOFMEMORY );
    }

    m_pHead = NULL;
    m_dwCount = 0;
    
    m_fInitialized = TRUE;
    
    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CVLifo::Push( void *pElement )
{
    NODE *pNext = m_pHead;

    if( FAILED( m_NodePool.AcquireCell( (void**)&m_pHead ) ) )
    {
        m_pHead = pNext;
        return( E_OUTOFMEMORY );
    }
    m_pHead->pNext = pNext;
    m_pHead->pData = pElement;
    m_dwCount++;

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVLifo::Pop( void **ppElement )
{
    if( !m_pHead )
    {
        return( FALSE );
    }

    *ppElement = m_pHead->pData;

    NODE *pNext = m_pHead->pNext;
    m_NodePool.ReleaseCell( (void*)m_pHead );
    m_pHead = pNext;

    m_dwCount--;
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVLifo::Peek( void **ppElement )
{
    if( !m_pHead )
    {
        return( FALSE );
    }

    *ppElement = m_pHead->pData;
    
    return( TRUE );
}


//////////////////////////////////////////////////////////////////////////////
// CVFifo public methods

//////////////////////////////////////////////////////////////////////////////

#if DBG
CVFifo::~CVFifo()
{
    if( ( g_fUseNewDelete ) && ( 0 != m_dwCount ) )
    {
        void * pElementDummy = NULL;
        
        while( Pop( &pElementDummy ) )
        {
            ;
        }
    }

}
#endif

//////////////////////////////////////////////////////////////////////////////
HRESULT CVFifo::Initialize( DWORD dwElementsPerPage )
{
    if( m_fInitialized )
    {
        return( E_UNEXPECTED );
    }

    if( FAILED( m_NodePool.Initialize( sizeof(NODE), dwElementsPerPage, 1, FALSE ) ) )
    {
        return( E_OUTOFMEMORY );
    }

    m_pHead = NULL;
    m_pTail = NULL;
    m_dwCount = 0;
    
    m_fInitialized = TRUE;
    
    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CVFifo::Push( void *pElement )
{
    NODE *pNew = NULL;
    if( FAILED( m_NodePool.AcquireCell( (void**)&pNew ) ) )
    {
        return( E_OUTOFMEMORY );
    }

    pNew->pNext = NULL;
    pNew->pData = pElement;

    if( m_pTail )
    {
        m_pTail->pNext = pNew;
    }
    else
    {
        m_pHead = pNew;
    }

    m_pTail = pNew;
    m_dwCount++;

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVFifo::Pop( void **ppElement )
{
    if( !m_pHead )
    {
        return( FALSE );
    }

    *ppElement = m_pHead->pData;

    NODE *pNext = m_pHead->pNext;
    m_NodePool.ReleaseCell( (void*)m_pHead );
    m_pHead = pNext;

    if( !m_pHead )
    {
        m_pTail = NULL;
    }

    m_dwCount--;
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVFifo::Peek( void **ppElement )
{
    if( !m_pHead )
    {
        return( FALSE );
    }

    *ppElement = m_pHead->pData;
    
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vordlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File: 		vordlist.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef VORDLIST_H
#define VORDLIST_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "vcelpool.h"

//////////////////////////////////////////////////////////////////////////////
class CVOrderedList
{ 
public: 
    CVOrderedList();

#if DBG
    ~CVOrderedList();
#endif

    HRESULT Initialize( DWORD cInitialEntryAllocation );

    void Clear();
    
    BOOL AddEntry( DWORD dwKey, void *pValue );
    BOOL GetEntry( int index, DWORD& dwKey, void **ppValue );
    BOOL RemoveEntry( int index, DWORD& dwKey, void **ppValue );

    DWORD GetCount() { return( m_cEntries ); }
    
private:
    struct NODE
    {
        DWORD dwKey;
        void *pValue;
        NODE *pNext;
        NODE *pPrev;
    };
    
    NODE *m_pHead;
    NODE *m_pTail; 
    DWORD m_cEntries;
    CVCellPool m_NodePool;
};

#endif // VORDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vordlist.cpp ===
#include "dstructp.h"


#if DBG
extern BOOL g_fUseNewDelete;
#endif

//////////////////////////////////////////////////////////////////////////////
CVOrderedList::CVOrderedList()
{
    m_pHead = m_pTail = NULL;
    m_cEntries = 0;
}

//////////////////////////////////////////////////////////////////////////////
#if DBG
CVOrderedList::~CVOrderedList()
    {
        if( ( g_fUseNewDelete ) && ( 0 != m_cEntries ) )
        {
            Clear();
        }
    }
#endif

//////////////////////////////////////////////////////////////////////////////
HRESULT CVOrderedList::Initialize( DWORD cInitialEntryAllocation )
{
    return( m_NodePool.Initialize( sizeof(NODE), cInitialEntryAllocation, 1, FALSE ) );
}

//////////////////////////////////////////////////////////////////////////////
void CVOrderedList::Clear()
{
    NODE *pNext;

    while( m_pHead )
    {
        pNext = m_pHead->pNext;
        m_NodePool.ReleaseCell( (void*)m_pHead );
        m_pHead = pNext;
    }

    m_cEntries = 0;
    m_pTail = NULL;
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVOrderedList::AddEntry( DWORD dwKey, void *pValue )
{
    NODE *pNew;
    if( FAILED( m_NodePool.AcquireCell( (void**)&pNew ) ) )
    {
        return( FALSE );
    }

    pNew->dwKey = dwKey;
    pNew->pValue = pValue;
    pNew->pNext = NULL;
    pNew->pPrev = NULL;

    if( !m_pHead )
    {
        m_pHead = m_pTail = pNew;
    }
    else
    {               
        NODE *pNext = m_pHead;
        while( pNext )
        {
            if( pNext->dwKey > dwKey )
            {
                pNew->pNext = pNext;
                pNew->pPrev = pNext->pPrev;
                pNext->pPrev = pNew;
                if( pNext->pPrev )
                {
                    pNext->pPrev->pNext = pNew;
                }
                if( pNext == m_pHead )
                {
                    m_pHead = pNew;
                }                
                break;
            }
            pNext = pNext->pNext;
        }
        if( !pNext )
        {   
            pNew->pPrev = m_pTail;
            m_pTail->pNext = pNew;
            m_pTail = pNew;
        }
    }
    
    m_cEntries++;
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVOrderedList::GetEntry( int index, DWORD& dwKey, void **ppValue )
{
    NODE *pNext = m_pHead;

    for( int i = 0; ( i < index ) && pNext; i++ )
    {
        pNext = pNext->pNext;
    }

    if( !pNext )
    {
        return( FALSE );
    }

    dwKey = pNext->dwKey;

    if( ppValue )
    {
        *ppValue = pNext->pValue;
    }
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CVOrderedList::RemoveEntry( int index, DWORD& dwKey, void **ppValue )
{
    NODE *pNext = m_pHead;

    for( int i = 0; ( i < index ) && pNext; i++ )
    {
        pNext = pNext->pNext;
    }

    if( !pNext )
    {
        return( FALSE );
    }

    dwKey = pNext->dwKey;  

    if( ppValue )
    {
        *ppValue = pNext->pValue;
    }
    
    if( pNext == m_pTail )
    {
        m_pTail = pNext->pPrev;
    }
    if( pNext == m_pHead )
    {
        m_pHead = pNext->pNext;
    }
    if( pNext->pNext )
    {
        pNext->pNext->pPrev = pNext->pPrev;
    }
    if( pNext->pPrev )
    {
        pNext->pPrev->pNext = pNext->pNext;
    }

    m_NodePool.ReleaseCell( (void*)pNext );
    m_cEntries--;
    
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vptrarr.cpp ===
#include "dstructp.h"


/////////////////////////////////////////////////////////////////////////////
CVPtrArray::CVPtrArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
#if DBG_MEM_LEAK
    m_pLeakDetector = malloc( 1 );
#endif
}

/////////////////////////////////////////////////////////////////////////////
CVPtrArray::~CVPtrArray()
{
    delete[] (BYTE*)m_pData;
#if DBG_MEM_LEAK
    if( NULL != m_pLeakDetector )
    {
        free( m_pLeakDetector );
    }
#endif
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVPtrArray::SetSize( DWORD nNewSize, DWORD nGrowByParam )
{
    if( nGrowByParam != 0xffffffff )
    {
        m_nGrowBy = nGrowByParam;  // set new size
    }

    if( nNewSize == 0 )
    {
        // shrink to nothing
        delete[] (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if( NULL == m_pData )
    {
        // create one with exact size

        // 48837 - Check for overflow
        if(nNewSize > (0xFFFFFFFF / sizeof(void *)))
        {
            return( FALSE );
        }

        m_pData = (void **) new BYTE[nNewSize * sizeof(void *)];

        if( NULL == m_pData )
        {
            return( FALSE );
        }

        memset( m_pData, 0, nNewSize * sizeof(void *) );  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if( nNewSize <= m_nMaxSize )
    {
        // it fits
        if( nNewSize > m_nSize )
        {
            // initialize the new elements
            memset( &m_pData[m_nSize], 0, (nNewSize - m_nSize) * sizeof(void *));
        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;

        if( 0 == nGrowBy )
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min( 1024, max( 4, m_nSize / 8 ) );
        }

        int nNewMax;
        if ( nNewSize < m_nMaxSize + nGrowBy )
        {
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        }
        else
        {
            nNewMax = nNewSize;  // no slush
        }

        // ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        // ASSERT( nNewMax <= SIZE_T_MAX / sizeof(void *)); // no overflow
#endif
        void **pNewData = (void **) new BYTE[nNewMax * sizeof(void *)];

        if( NULL == pNewData )
        {
            return( FALSE );
        }

        // copy new data from old
        memcpy( pNewData, m_pData, m_nSize * sizeof(void *) );

        // construct remaining elements
        // ASSERT( nNewSize > m_nSize );

        memset( &pNewData[m_nSize], 0, (nNewSize - m_nSize) * sizeof(void *));

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }

    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVPtrArray::Append( const CVPtrArray& src, DWORD *pdwOldSize )
{
    // ASSERT( this != &src );   // cannot append to itself

    DWORD nOldSize = m_nSize;

    if( !SetSize( m_nSize + src.m_nSize ) )
    {
        return( FALSE );
    }

    memcpy( m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(void *) );

    if( NULL != pdwOldSize )
    {
        *pdwOldSize = nOldSize;
    }

    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVPtrArray::Copy( const CVPtrArray& src )
{
    // ASSERT( this != &src );   // cannot append to itself

    if( !SetSize( src.m_nSize ) )
    {
        return( FALSE );
    }

    memcpy( m_pData, src.m_pData, src.m_nSize * sizeof(void *) );

    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
void CVPtrArray::FreeExtra()
{
    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        // ASSERT( m_nSize <= SIZE_T_MAX / sizeof(void *)); // no overflow
#endif
        void** pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (void**) new BYTE[m_nSize * sizeof(void* )];
            if (pNewData == NULL)
            {
                // Don't have enough memory to resize, stick with current state
                return;
            }
            // copy new data from old
            memcpy( pNewData, m_pData, m_nSize * sizeof(void *) );
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVPtrArray::SetAtGrow( DWORD nIndex, void *pNewElement )
{
    if (nIndex >= m_nSize)
    {
        if( !SetSize( nIndex + 1 ) )
        {
            return( FALSE );
        }
    }

    m_pData[nIndex] = pNewElement;

    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVPtrArray::InsertAt( DWORD nIndex, void *pNewElement )
{
    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        if( !SetSize( nIndex + 1 ) )  // grow so nIndex is valid
        {
            return( FALSE );
        }
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;

        if( !SetSize( m_nSize + 1 ) )  // grow it to new size
        {
            return( FALSE );
        }

        // shift old data up to fill gap
        memmove( &m_pData[nIndex + 1], &m_pData[nIndex],
                 (nOldSize - nIndex) * sizeof(void *) );
    }

    // insert new value in the gap
    m_pData[nIndex] = pNewElement;

    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVPtrArray::RemoveAt( DWORD nIndex, DWORD nCount )
{
    // ASSERT( nCount >= 0 );

    if( nIndex + nCount > m_nSize )
    {
        return( FALSE );
    }

    // just remove a range
    DWORD nMoveCount = m_nSize - (nIndex + nCount);

    if( nMoveCount > 0 )
    {
        memmove( &m_pData[nIndex], &m_pData[nIndex + nCount],
                 nMoveCount * sizeof(void *) );
    }

    m_nSize -= nCount;

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vptrarr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft NetShow
//  Copyright (C) Microsoft Corporation 1998.
//
//  File: 		vptrarr.h
//
//  Contents:   
//
//  History:    10/5/98            Created
//  
//--------------------------------------------------------------------------

#ifndef VPTRARR_H
#define VPTRARR_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "leakdetector.h"

////////////////////////////////////////////////////////////////////////////
class CVPtrArray
{
public:
    CVPtrArray();
    ~CVPtrArray();

    // Attributes
    DWORD GetSize() const;
    BOOL SetSize( DWORD nNewSize, DWORD nGrowBy = 0xffffffff );

    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    BOOL GetAt( DWORD nIndex, void **ppElement ) const;
    BOOL SetAt( DWORD nIndex, void *pNewElement );

    // Potentially growing the array
    BOOL SetAtGrow( DWORD nIndex, void *pNewElement );
    BOOL Add( void *pNewElement, DWORD *pdwIndex );
    BOOL Append( const CVPtrArray& src, DWORD *pdwOldSize );
    BOOL Copy( const CVPtrArray& src );

    // Operations that move elements around
    BOOL InsertAt( DWORD nIndex, void *pNewElement );
    BOOL RemoveAt( DWORD nIndex, DWORD nCount = 1 );

protected:
    void** m_pData;   // the actual array of data
    DWORD m_nSize;     // # of elements (upperBound - 1)
    DWORD m_nMaxSize;  // max allocated
    DWORD m_nGrowBy;   // grow amount

private:
#if DBG_MEM_LEAK
	void *m_pLeakDetector;
#endif
};

////////////////////////////////////////////////////////////////////////////
inline DWORD CVPtrArray::GetSize() const
{
    return( m_nSize );
}

inline void CVPtrArray::RemoveAll()
{
    SetSize( 0 );
}

inline BOOL CVPtrArray::GetAt( DWORD nIndex, void **ppElement ) const
{
    // ASSERT( nIndex < m_nSize );

    if( nIndex >= m_nSize )
    {
        return( FALSE );
    }

    *ppElement = m_pData[nIndex];

    return( TRUE );
}

inline BOOL CVPtrArray::SetAt( DWORD nIndex, void *pNewElement )
{
    if( nIndex >= m_nSize )
    {
        return( FALSE );
    }

    m_pData[nIndex] = pNewElement;

    return( TRUE );
}

inline BOOL CVPtrArray::Add( void *pNewElement, DWORD *pdwIndex )
{
    if( NULL != pdwIndex )
    {
        *pdwIndex = m_nSize;
    }

    return( SetAtGrow( m_nSize, pNewElement ) );
}

#endif  // VPTRARR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\vptrlist.cpp ===
#include "dstructp.h"


/////////////////////////////////////////////////////////////////////////////
CVPtrList::CVPtrList()
{
    m_cEntries = 0;
    m_pHead = m_pTail = NULL;
    m_pfnCompare = NULL;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CVPtrList::Initialize( DWORD cInitialEntryAllocation, PFNTYPEDCOMPAREFUNCTION pfnCompare )
{
    m_pfnCompare = pfnCompare;
    return( m_NodePool.Initialize( sizeof(NODE), cInitialEntryAllocation, 1, FALSE ) );
}

//////////////////////////////////////////////////////////////////////////////
void CVPtrList::RemoveAll()
{
    NODE *pNext;

    while( NULL != m_pHead )
    {
        pNext = m_pHead->pNext;
        m_NodePool.ReleaseCell( (void*)m_pHead );
        m_pHead = pNext;
    }

    m_cEntries = 0;
    m_pTail = NULL;
}

/////////////////////////////////////////////////////////////////////////////
LISTPOS CVPtrList::AddHead( void *pNewHead )
{
    NODE *pNewNode;
    if( FAILED( m_NodePool.AcquireCell( (void**)&pNewNode ) ) )
    {
        return( (LISTPOS) NULL );
    }

    pNewNode->pValue = pNewHead;
    pNewNode->pNext = m_pHead;
    pNewNode->pPrev = NULL;

    if( NULL != m_pHead )
    {
        m_pHead->pPrev = pNewNode;
    }
    else
    {
        m_pTail = pNewNode;
    }

    m_pHead = pNewNode;
    m_cEntries++;

    return( (LISTPOS) pNewNode );
}

/////////////////////////////////////////////////////////////////////////////
LISTPOS CVPtrList::AddTail( void *pNewTail )
{
    NODE *pNewNode;
    if( FAILED( m_NodePool.AcquireCell( (void**)&pNewNode ) ) )
    {
        return( (LISTPOS) NULL );
    }

    pNewNode->pValue = pNewTail;
    pNewNode->pNext = NULL;
    pNewNode->pPrev = m_pTail;

    if( NULL != m_pTail )
    {
        m_pTail->pNext = pNewNode;
    }
    else
    {
        m_pHead = pNewNode;
    }

    m_pTail = pNewNode;
    m_cEntries++;

    return( (LISTPOS) pNewNode );
}

/////////////////////////////////////////////////////////////////////////////
void CVPtrList::AddHead( CVPtrList *pNewList )
{
    // ASSERT( pNewList )

    // add a list of same elements to head (maintain order)
    void *pElement;
    LISTPOS pos = pNewList->GetTailPosition();

    while ( ( NULL != pos ) && ( pNewList->GetPrev( pos, &pElement ) ) )
    {
        AddHead( pElement );
    }
}

/////////////////////////////////////////////////////////////////////////////
void CVPtrList::AddTail( CVPtrList *pNewList )
{
    // ASSERT( pNewList )

    // add a list of same elements
    void *pElement;
    LISTPOS pos = pNewList->GetHeadPosition();

    while ( ( NULL != pos ) && ( pNewList->GetNext( pos, &pElement ) ) )
    {
        AddTail( pElement );
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVPtrList::RemoveHead( void **ppOldHead )
{
    if( !ppOldHead || !m_pHead )
    {
        return( FALSE );
    }

    NODE *pOldNode = m_pHead;
    *ppOldHead = pOldNode->pValue;

    m_pHead = pOldNode->pNext;

    if( NULL != m_pHead )
    {
        m_pHead->pPrev = NULL;
    }
    else
    {
        m_pTail = NULL;
    }

    m_NodePool.ReleaseCell( (void*)pOldNode );
    m_cEntries--;
    
    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVPtrList::RemoveTail( void **ppOldTail )
{
    if( !ppOldTail || !m_pTail )
    {
        return( FALSE );
    }

    NODE *pOldNode = m_pTail;
    *ppOldTail = pOldNode->pValue;

    m_pTail = pOldNode->pPrev;

    if( NULL != m_pTail )
    {
        m_pTail->pNext = NULL;
    }
    else
    {
        m_pHead = NULL;
    }

    m_NodePool.ReleaseCell( (void*)pOldNode );
    m_cEntries--;
    
    return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
LISTPOS CVPtrList::InsertBefore( LISTPOS pos, void *pNewElement )
{
    if( ( NULL == pos ) || ( ((NODE*)pos)->pPrev == NULL ) )
    {
        return( AddHead( pNewElement ) ); // insert before nothing -> head of the list
    }

    // Insert it before pos
    NODE *pOldNode = (NODE*) pos;

    NODE *pNewNode;
    if( FAILED( m_NodePool.AcquireCell( (void**)&pNewNode ) ) )
    {
        return( (LISTPOS) NULL );
    }

    pNewNode->pValue = pNewElement;
    pNewNode->pPrev = pOldNode->pPrev;
    pNewNode->pNext = pOldNode;

    pOldNode->pPrev->pNext = pNewNode;
    pOldNode->pPrev = pNewNode;

    m_cEntries++;

    return( (LISTPOS) pNewNode );
}

/////////////////////////////////////////////////////////////////////////////
LISTPOS CVPtrList::InsertAfter( LISTPOS pos, void *pNewElement )
{
    if( ( NULL == pos ) || ( ((NODE*)pos)->pNext == NULL ) )
    {
        return( AddTail( pNewElement ) ); // insert after nothing -> tail of the list
    }

    // Insert it after pos
    NODE *pOldNode = (NODE*) pos;

    NODE *pNewNode;
    if( FAILED( m_NodePool.AcquireCell( (void**)&pNewNode ) ) )
    {
        return( (LISTPOS) NULL );
    }

    pNewNode->pValue = pNewElement;
    pNewNode->pPrev = pOldNode;
    pNewNode->pNext = pOldNode->pNext;

    pOldNode->pNext->pPrev = pNewNode;
    pOldNode->pNext = pNewNode;

    m_cEntries++;

    return( (LISTPOS) pNewNode );
}

/////////////////////////////////////////////////////////////////////////////
void CVPtrList::RemoveAt( LISTPOS pos )
{
    // ASSERT( NULL != pos )
    NODE *pOldNode = (NODE*) pos;

    // remove pOldNode from list
    if( pOldNode == m_pHead )
    {
        m_pHead = pOldNode->pNext;
    }
    else
    {
        // ASSERT( pOldNode->pPrev );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }

    if (pOldNode == m_pTail)
    {
        m_pTail = pOldNode->pPrev;
    }
    else
    {
        // ASSERT( pOldNode->pNext )
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }

    m_NodePool.ReleaseCell( (void*)pOldNode );
    m_cEntries--;
}

/////////////////////////////////////////////////////////////////////////////
LISTPOS CVPtrList::FindIndex( DWORD nIndex ) const
{
    if( nIndex >= m_cEntries )
    {
        return( (LISTPOS) NULL );  // went too far
    }

    NODE *pNode = m_pHead;

    while (nIndex--)
    {
        pNode = pNode->pNext;
    }

    return( (LISTPOS) pNode );
}

/////////////////////////////////////////////////////////////////////////////
LISTPOS CVPtrList::Find( void *pSearchValue, LISTPOS startAfter ) const
{
    NODE *pNode = (NODE *) startAfter;

    if( NULL == pNode )
    {
        pNode = m_pHead;  // start at head
    }
    else
    {
        pNode = pNode->pNext;  // start after the one specified
    }

    for ( ; NULL != pNode; pNode = pNode->pNext )
    {
        if ( 0 == Compare( pNode->pValue, pSearchValue) )
        {
            return( (LISTPOS) pNode );
        }
    }

    return( (LISTPOS) NULL );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVPtrList::Sort( CVPtrList::CComparator* pComparator )
{
    if( NULL == pComparator )
    {
        return( FALSE );
    }

    if( m_cEntries >= 2 )
    {
        NODE* pList     = m_pHead->pNext;
        NODE* pStart    = m_pHead;
        NODE* pNewList  = m_pHead;
        pNewList->pNext = NULL;
        pNewList->pPrev = NULL;

        NODE* pNode = pList;

        while( NULL != pNode )
        {
            NODE* pCurrent = pNewList;
            NODE* pLast = NULL;

            while( ( NULL != pCurrent ) && ( pComparator->IsLessThan( pNode->pValue, pCurrent->pValue ) ) )
            {
                pLast = pCurrent;
                pCurrent = pCurrent->pPrev;
            }

            NODE* pNextNode = pNode->pNext;
            pNode->pNext = pLast;

            if( NULL != pLast )
            {
                pLast->pPrev = pNode;
            }
            else
            {
                pNewList = pNode;
            }

            pNode->pPrev = pCurrent;

            if( NULL != pCurrent )
            {
                pCurrent->pNext = pNode;
            }
            else
            {
                pStart = pNode;
            }

            pNode = pNextNode;
        }

        m_pHead = pStart;
        m_pTail = pNewList;
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\dvt\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <atlbase.h>

#include <..\vavltable.h>
#include <..\vmallocpool.h>
#include <..\vptrarr.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\servhlp\dstruct\xlocks.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       locks.h

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

       10/16/01 - Tampered by DCaiafa to work in the XOnline environment

--*/

#ifndef __XLOCKS_H__
#define __XLOCKS_H__

//--------------------------------------------------------------------
// File: locks.h
//
// A collection of different implementations of read/write locks that all
// share the same interface.  This allows different locks to be plugged
// into C++ templates as parameters.
//
// The implementations are:
//      CSmallSpinLock      lightweight critical section
//      CSpinLock           variant of CSmallSpinLock
//      CFakeLock           do-nothing class; useful as a template parameter
//      CCritSec            Win32 CRITICAL_SECTION
//   Multi-Reader/Single-Writer locks:
//      CReaderWriterLock   MRSW lock from Neel Jain
//      CReaderWriterLock2  smaller implementation of CReaderWriterLock
//      CReaderWriterLock3  CReaderWriterLock2 with recursive WriteLock
//
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> can used as
// exception-safe wrappers.
//
// TODO:
// * Add per-class lock-contention statistics
// * Add a timeout feature to Try{Read,Write}Lock
// * Add some way of tracking all the owners of a multi-reader lock
//--------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <assert.h>

namespace xlocks 
{

//--------------------------------------------------------------------
// Miscellaneous functions

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// how many CPUs on this machine?
inline int NumProcessors()
{
    static int s_nCPUs = 0;
    
    if (s_nCPUs == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nCPUs = si.dwNumberOfProcessors;
    }
    return s_nCPUs;
}


// Type of processor, 386, 486, etc
inline int ProcessorType()
{
    static int s_nProcessorType = 0;
    
    if (s_nProcessorType == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nProcessorType = si.dwProcessorType;
    }
    return s_nProcessorType;
}

BOOL
Locks_Initialize();

BOOL
Locks_Cleanup();

#ifdef __cplusplus
}
#endif // __cplusplus

enum LOCK_LOCKTYPE {
    LOCK_SMALLSPINLOCK = 1,
    LOCK_SPINLOCK,
    LOCK_FAKELOCK,
    LOCK_CRITSEC,
    LOCK_READERWRITERLOCK,
    LOCK_READERWRITERLOCK2,
    LOCK_READERWRITERLOCK3,
};


// Forward declarations
class CSmallSpinLock;
class CSpinLock;
class CFakeLock;
class CCritSec;
class CReaderWriterLock;
class CReaderWriterLock2;
class CReaderWriterLock3;


#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// __forceinline keyword new to VC6
# define LOCK_FORCEINLINE __forceinline
#else
# define LOCK_FORCEINLINE inline
#endif

#ifdef _M_IX86
// The compiler will warn that the assembly language versions of the
// Lock_Atomic* functions don't return a value. Actually, they do: in EAX.
# pragma warning(disable: 4035)
#endif

// Workarounds for certain useful interlocked operations that are not
// available on Windows 95. Note: the CMPXCHG and XADD instructions were
// introduced in the 80486. If you still need to run on a 386 (unlikely in
// 2000), you'll need to use something else.

LOCK_FORCEINLINE
LONG
Lock_AtomicIncrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    1
        lock xadd       [ecx],  eax
             inc        eax                 // correct result
    }
#else
    return InterlockedIncrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicDecrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    -1
        lock xadd       [ecx],  eax
             dec        eax                 // correct result
    }
#else
    return InterlockedDecrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    [ecx]
    LAEloop:
        lock cmpxchg    [ecx],  edx
             jnz        LAEloop
    }
#else
    return InterlockedExchange(plAddr, lNew);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicCompareExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew,
    IN LONG      lCurrent)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    lCurrent
        lock cmpxchg    [ecx],  edx
    }
#else
    return InterlockedCompareExchange(plAddr, lNew, lCurrent);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchangeAdd(
    IN OUT LPLONG plAddr,
    IN LONG       lValue)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        eax,    lValue
        lock xadd       [ecx],  eax
    }
#else
    return InterlockedExchangeAdd(plAddr, lValue);
#endif
}



#ifdef _M_IX86
# pragma warning(default: 4035)
// Makes tight loops a little more cache friendly and reduces power
// consumption. Needed on Willamette processors.
# define Lock_Yield()    _asm { rep nop }
#else
# define Lock_Yield()    ((void) 0)
#endif



//--------------------------------------------------------------------
// Spin count values.
enum LOCK_SPINS {
    LOCK_MAXIMUM_SPINS =      10000,    // maximum allowable spin count
    LOCK_DEFAULT_SPINS =       4000,    // default spin count
    LOCK_MINIMUM_SPINS =        100,    // minimum allowable spin count
    LOCK_USE_DEFAULT_SPINS = 0xFFFF,    // use class default spin count
    LOCK_DONT_SPIN =              0,    // don't spin at all
};

#ifndef LOCK_DEFAULT_SPIN_IMPLEMENTATION

// Boilerplate code for the per-class default spincount and spinfactor

#define LOCK_DEFAULT_SPIN_IMPLEMENTATION()                                  \
protected:                                                                  \
    /* per-class variables */                                               \
    static   WORD   sm_wDefaultSpinCount;   /* global default spin count */   \
    static   double sm_dblDfltSpinAdjFctr;  /* global spin adjustment factor*/\
                                                                            \
public:                                                                     \
    /* Set the default spin count for all locks */                          \
    static void SetDefaultSpinCount(WORD wSpins)                            \
    {                                                                       \
        assert((wSpins == LOCK_DONT_SPIN)                               \
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)                    \
                   || (LOCK_MINIMUM_SPINS <= wSpins                         \
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));                  \
                                                                            \
        if ((LOCK_MINIMUM_SPINS <= wSpins  &&  wSpins <= LOCK_MAXIMUM_SPINS)\
                || (wSpins == LOCK_DONT_SPIN))                              \
            sm_wDefaultSpinCount = wSpins;                                  \
        else if (wSpins == LOCK_USE_DEFAULT_SPINS)                          \
            sm_wDefaultSpinCount = LOCK_DEFAULT_SPINS;                      \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static WORD GetDefaultSpinCount()                                       \
    {                                                                       \
        return sm_wDefaultSpinCount;                                        \
    }                                                                       \
                                                                            \
    /* Set the adjustment factor for the spincount, used in each iteration */\
    /* of countdown-and-sleep by the backoff algorithm. */                  \
    static void SetDefaultSpinAdjustmentFactor(double dblAdjFactor)         \
    {                                                                       \
        assert(0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0);          \
        if (0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0)                  \
            sm_dblDfltSpinAdjFctr = dblAdjFactor;                           \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static double GetDefaultSpinAdjustmentFactor()                          \
    {                                                                       \
        return sm_dblDfltSpinAdjFctr;                                       \
    }                                                                       \

#endif


//--------------------------------------------------------------------
// Various Lock Traits

// Is the lock a simple mutex or a multi-reader/single-writer lock?
enum LOCK_RW_MUTEX {
    LOCK_MUTEX = 1,         // mutexes allow only one thread to hold the lock
    LOCK_MRSW,              // multi-reader, single-writer
};


// Can the lock be recursively acquired?
enum LOCK_RECURSION {
    LOCK_RECURSIVE = 1,     // Write and Read locks can be recursively acquired
    LOCK_READ_RECURSIVE,    // Read locks can be reacquired, but not Write
    LOCK_NON_RECURSIVE,     // Will deadlock if attempt to acquire recursively
};


// Does the lock Sleep in a loop or block on a kernel synch object handle?
// May (or may not) spin first before sleeping/blocking.
enum LOCK_WAIT_TYPE {
    LOCK_WAIT_SLEEP = 1,    // Calls Sleep() in a loop
    LOCK_WAIT_HANDLE,       // Blocks on a kernel mutex, semaphore, or event
};


// When the lock is taken, how are the waiters dequeued?
enum LOCK_QUEUE_TYPE {
    LOCK_QUEUE_FIFO = 1,    // First in, first out.  Fair.
    LOCK_QUEUE_LIFO,        // Unfair but CPU cache friendly
    LOCK_QUEUE_KERNEL,      // Determined by vagaries of scheduler
};


// Can the lock's spincount be set on a per-lock basis, or is it only
// possible to modify the default spincount for all the locks in this class?
enum LOCK_PERLOCK_SPIN {
    LOCK_NO_SPIN = 1,       // The locks do not spin at all
    LOCK_CLASS_SPIN,        // Can set class-wide spincount, not individual
    LOCK_INDIVIDUAL_SPIN,   // Can set a spincount on an individual lock
};


//--------------------------------------------------------------------
// CLockBase: bundle the above attributes

template < LOCK_LOCKTYPE     locktype,
           LOCK_RW_MUTEX     mutextype,
           LOCK_RECURSION    recursiontype,
           LOCK_WAIT_TYPE    waittype,
           LOCK_QUEUE_TYPE   queuetype,
           LOCK_PERLOCK_SPIN spintype
         >
class CLockBase
{
public:
    static LOCK_LOCKTYPE     LockType()     {return locktype;}
    static LOCK_RW_MUTEX     MutexType()    {return mutextype;}
    static LOCK_RECURSION    Recursion()    {return recursiontype;}
    static LOCK_WAIT_TYPE    WaitType()     {return waittype;}
    static LOCK_QUEUE_TYPE   QueueType()    {return queuetype;}
    static LOCK_PERLOCK_SPIN PerLockSpin()  {return spintype;}
};



// Lock instrumentation causes all sorts of interesting statistics about
// lock contention, etc., to be gathered, but makes locks considerably fatter
// and somewhat slower.  Turned off by default.

// #define LOCK_INSTRUMENTATION 1

#ifdef LOCK_INSTRUMENTATION

// We generally don't want to instrument CSmallSpinLock in addition
// to CSpinLock1, as it makes a CSpinLock1 huge.

// #define LOCK_SMALL_SPIN_INSTRUMENTATION 1

//--------------------------------------------------------------------
// CLockStatistics: statistics for an individual lock

class CLockStatistics
{
public:
    enum {
        L_NAMELEN = 8,
    };
    
    double   m_nContentions;     // #times this lock was already locked
    double   m_nSleeps;          // Total #Sleep()s needed
    double   m_nContentionSpins; // Total iterations this lock spun
    double   m_nAverageSpins;    // Average spins each contention needed
    double   m_nReadLocks;       // Number of times lock acquired for reading
    double   m_nWriteLocks;      // Number of times lock acquired for writing
    TCHAR    m_tszName[L_NAMELEN];// Name of this lock

    CLockStatistics()
        : m_nContentions(0),
          m_nSleeps(0),
          m_nContentionSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {
        m_tszName[0] = _TEXT('\0');
    }
};



//--------------------------------------------------------------------
// CGlobalLockStatistics: statistics for all the known locks

class CGlobalLockStatistics
{
public:
    LONG     m_cTotalLocks;     // Total number of locks created
    LONG     m_cContendedLocks; // Total number of contended locks
    LONG     m_nSleeps;         // Total #Sleep()s needed by all locks
    LONGLONG m_cTotalSpins;     // Total iterations all locks spun
    double   m_nAverageSpins;   // Average spins needed for each contended lock
    LONG     m_nReadLocks;      // Total ReadLocks
    LONG     m_nWriteLocks;     // Total WriteLocks

    CGlobalLockStatistics()
        : m_cTotalLocks(0),
          m_cContendedLocks(0),
          m_nSleeps(0),
          m_cTotalSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {}
};

# define LOCK_INSTRUMENTATION_DECL() \
private:                                                                    \
    volatile LONG   m_nContentionSpins; /* #iterations this lock spun */    \
    volatile WORD   m_nContentions;     /* #times lock was already locked */\
    volatile WORD   m_nSleeps;          /* #Sleep()s needed */              \
    volatile WORD   m_nReadLocks;       /* #ReadLocks */                    \
    volatile WORD   m_nWriteLocks;      /* #WriteLocks */                   \
    TCHAR           m_tszName[CLockStatistics::L_NAMELEN]; /* Name of lock */\
                                                                            \
    static   LONG   sm_cTotalLocks;     /* Total number of locks created */ \
    static   LONG   sm_cContendedLocks; /* Total number of contended locks */\
    static   LONG   sm_nSleeps;         /* Total #Sleep()s by all locks */  \
    static LONGLONG sm_cTotalSpins;     /* Total iterations all locks spun */\
    static   LONG   sm_nReadLocks;      /* Total ReadLocks */               \
    static   LONG   sm_nWriteLocks;     /* Total WriteLocks */              \
                                                                            \
public:                                                                     \
    const TCHAR* Name() const       {return m_tszName;}                     \
                                                                            \
    CLockStatistics                 Statistics() const;                     \
    static CGlobalLockStatistics    GlobalStatistics();                     \
    static void __stdcall           ResetGlobalStatistics();                \
private:                                                                    \


// Add this to constructors

# define LOCK_INSTRUMENTATION_INIT(ptszName)        \
    m_nContentionSpins = 0;                         \
    m_nContentions = 0;                             \
    m_nSleeps = 0;                                  \
    m_nReadLocks = 0;                               \
    m_nWriteLocks = 0;                              \
    ++sm_cTotalLocks;                               \
    if (ptszName == NULL)                           \
        m_tszName[0] = _TEXT('\0');                 \
    else                                            \
        _tcsncpy(m_tszName, ptszName, sizeof(m_tszName)/sizeof(TCHAR))

// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.

# define LOCK_READLOCK_INSTRUMENTATION()    \
      { ++m_nReadLocks;                     \
        ++sm_nReadLocks; }

# define LOCK_WRITELOCK_INSTRUMENTATION()   \
      { ++m_nWriteLocks;                    \
        ++sm_nWriteLocks; }

#else // !LOCK_INSTRUMENTATION

# define LOCK_INSTRUMENTATION_DECL()
# define LOCK_READLOCK_INSTRUMENTATION()    ((void) 0)
# define LOCK_WRITELOCK_INSTRUMENTATION()   ((void) 0)

#endif // !LOCK_INSTRUMENTATION



//--------------------------------------------------------------------
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> provide exception-safe
// acquisition and release of the other locks defined below

template <class _Lock>
class CAutoReadLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoReadLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }
    ~CAutoReadLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.ReadLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_Lock.ReadUnlock();
            m_fLocked = false;
        }
    }
};



template <class _Lock>
class CAutoWriteLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoWriteLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }

    ~CAutoWriteLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.WriteLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_fLocked = false;
            m_Lock.WriteUnlock();
        }
    }
};




//--------------------------------------------------------------------
// A spinlock is a sort of lightweight critical section.  Its main
// advantage over a true Win32 CRITICAL_SECTION is that it occupies 4 bytes
// instead of 24 (+ another 32 bytes for the RTL_CRITICAL_SECTION_DEBUG data),
// which is important when we have many thousands of locks
// and we're trying to be L1 cache-conscious.  A CRITICAL_SECTION also
// contains a HANDLE to a semaphore, although this is not initialized until
// the first time that the CRITICAL_SECTION blocks.
//
// On a multiprocessor machine, a spinlock tries to acquire the lock.  If
// it fails, it sits in a tight loop, testing the lock and decrementing a
// counter.  If the counter reaches zero, it does a Sleep(0), yielding the
// processor to another thread.  When control returns to the thread, the
// lock is probably free.  If not, the loop starts again and it is
// terminated only when the lock is acquired.  The theory is that it is
// less costly to spin in a busy loop for a short time rather than
// immediately yielding the processor, forcing an expensive context switch
// that requires the old thread's state (registers, etc) be saved, the new
// thread's state be reloaded, and the L1 and L2 caches be left full of
// stale data.
//
// You can tune the spin count (global only: per-lock spin counts are 
// disabled) and the backoff algorithm (the factor by which the spin
// count is multiplied after each Sleep).
//
// On a 1P machine, the loop is pointless---this thread has control,
// hence no other thread can possibly release the lock while this thread
// is looping---so the processor is yielded immediately.
//
// The kernel uses spinlocks internally and spinlocks were also added to
// CRITICAL_SECTIONs in NT 4.0 sp3.  In the CRITICAL_SECTION implementation,
// however, the counter counts down only once and waits on a semaphore
// thereafter (i.e., the same blocking behavior that it exhibits without
// the spinlock).
//
// A disadvantage of a user-level spinlock such as this is that if the
// thread that owns the spinlock blocks for any reason (or is preempted by
// the scheduler), all the other threads will continue to spin on the
// spinlock, wasting CPU, until the owning thread completes its wait and
// releases the lock.  (The kernel spinlocks, however, are smart enough to
// switch to another runnable thread instead of wasting time spinning.)
// The backoff algorithm decreases the spin count on each iteration in an
// attempt to minimize this effect.  The best policy---and this is true for
// all locks---is to hold the lock for as short as time as possible.
//
// Note: unlike a CRITICAL_SECTION, a CSmallSpinLock cannot be recursively
// acquired; i.e., if you acquire a spinlock and then attempt to acquire it
// again *on the same thread* (perhaps from a different function), the
// thread will hang forever.  Use CSpinLock instead, which is safe though a
// little slower than a CSmallSpinLock.  If you own all the code
// that is bracketed by Lock() and Unlock() (e.g., no callbacks or passing
// back of locked data structures to callers) and know for certain that it
// will not attempt to reacquire the lock, you can use CSmallSpinLock.
//
// See also http://muralik/work/performance/spinlocks.htm and John Vert's
// MSDN article, "Writing Scalable Applications for Windows NT".
//
// The original implementation is due to PALarson.

class CSmallSpinLock :
    public CLockBase<LOCK_SMALLSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lTid;              // The lock state variable

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_DECL();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        return (LONG) (dwTid);
    }

private:
    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId();

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }

public:

#ifndef LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock(
        const TCHAR* ptszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

#ifdef _DEBUG
    ~CSmallSpinLock()
    {
        assert(m_lTid == 0);
    }
#endif // _DEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        // Optimize for the common case by helping the processor's branch
        // prediction algorithm.
        if (_TryLock())
            return;

        _LockSpin();
    }

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        if (_TryLock())
            return;

        _LockSpin();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    inline void ReadUnlock()
    {
        WriteUnlock();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return (m_lTid == _CurrentThreadId());
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return (m_lTid == 0);
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        assert((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CSmallSpinLock");}
}; // CSmallSpinLock




//--------------------------------------------------------------------
// CSpinLock is a spinlock that doesn't deadlock if recursively acquired.
// This version occupies only 4 bytes.  Uses 28 bits for the thread id.

class CSpinLock :
    public CLockBase<LOCK_SPINLOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // a union for convenience
    volatile LONG m_lTid;

    enum {
        THREAD_SHIFT = 0,
        THREAD_BITS  = 28,
        OWNER_SHIFT  = THREAD_BITS,
        OWNER_BITS   = 4,
        THREAD_MASK  = ((1 << THREAD_BITS) - 1) << THREAD_SHIFT,
        OWNER_INCR   = 1 << THREAD_BITS,
        OWNER_MASK   = ((1 << OWNER_BITS) - 1) << OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Idle Process (Process ID 0).
        // We use a thread-id of zero to indicate that the lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        assert(dwTid != 0
                   && ((dwTid <= THREAD_MASK) || (dwTid > ~THREAD_MASK)));
        return (LONG) (dwTid & THREAD_MASK);
    }

    // Attempt to acquire the lock without blocking
    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId() | OWNER_INCR;

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }


    // Acquire the lock, recursively if need be
    void _Lock()
    {
        // Do we own the lock already?  Just bump the count.
        if ((m_lTid & THREAD_MASK) == _CurrentThreadId())
        {
            // owner count isn't maxed out?
            assert((m_lTid & OWNER_MASK) != OWNER_MASK);

            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid),
                                m_lTid + OWNER_INCR);
        }

        // Some other thread owns the lock.  We'll have to spin :-(.
        else
            _LockSpin();

        assert((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());
    }


    // Release the lock
    LOCK_FORCEINLINE void _Unlock()
    {
        assert((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

        LONG l = m_lTid - OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((l & OWNER_MASK) == 0)
            l = 0;

        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), l);
    }


    // Return true if the lock is owned by this thread
    bool _IsLocked() const
    {
        bool fLocked = ((m_lTid & THREAD_MASK) == _CurrentThreadId());

        assert(!fLocked || ((m_lTid & OWNER_MASK) > 0
                               && (m_lTid & THREAD_MASK)==_CurrentThreadId()));

        return fLocked;
    }


    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

public:

#ifndef LOCK_INSTRUMENTATION

    CSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_INSTRUMENTATION

    CSpinLock(
        const TCHAR* ptszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef _DEBUG
    ~CSpinLock()
    {
        assert(m_lTid == 0);
    }
#endif // _DEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }
    

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }

    // See the description under CReaderWriterLock3::ReadOrWriteLock
    inline bool ReadOrWriteLock()
    {
        ReadLock();
        return true;
    } 

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    inline void WriteUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    inline void ReadUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a call to ReadOrWriteLock().
    inline void ReadOrWriteUnlock(bool)
    {
        ReadUnlock();
    } 

    // Is the lock already locked for writing?
    bool IsWriteLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return !IsReadLocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Set the spin count for this lock.
    bool SetSpinCount(WORD dwSpins)     {return false;}

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CSpinLock");}
}; // CSpinLock




//--------------------------------------------------------------------
// A dummy class, primarily useful as a template parameter

class CFakeLock :
    public CLockBase<LOCK_FAKELOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_FIFO,
                       LOCK_NO_SPIN
                      >
{
private:
    LOCK_INSTRUMENTATION_DECL();

public:
    CFakeLock()                     {} 
#ifdef LOCK_INSTRUMENTATION
    CFakeLock(const char*)          {}
#endif // LOCK_INSTRUMENTATION
    ~CFakeLock()                    {} 
    void WriteLock()                {} 
    void ReadLock()                 {} 
    bool ReadOrWriteLock()          {return true;} 
    bool TryWriteLock()             {return true;} 
    bool TryReadLock()              {return true;} 
    void WriteUnlock()              {}
    void ReadUnlock()               {}
    void ReadOrWriteUnlock(bool)    {}
    bool IsWriteLocked() const      {return true;} 
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}
    bool IsReadUnlocked() const     {return true;}
    void ConvertSharedToExclusive() {}
    void ConvertExclusiveToShared() {}
    bool SetSpinCount(WORD dwSpins) {return false;}
    WORD GetSpinCount() const       {return LOCK_DONT_SPIN;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CFakeLock");}
}; // CFakeLock




//--------------------------------------------------------------------
// A Win32 CRITICAL_SECTION

class CCritSec :
    public CLockBase<LOCK_CRITSEC, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CRITICAL_SECTION m_cs;

    LOCK_INSTRUMENTATION_DECL();

public:
    CCritSec()
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#ifdef LOCK_INSTRUMENTATION
    CCritSec(const char*)
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION
    ~CCritSec()         { DeleteCriticalSection(&m_cs); }

    void WriteLock()    { EnterCriticalSection(&m_cs); }
    void ReadLock()     { WriteLock(); }
    bool ReadOrWriteLock() { ReadLock(); return true; } 
    bool TryWriteLock();
    bool TryReadLock()  { return TryWriteLock(); }
    void WriteUnlock()  { LeaveCriticalSection(&m_cs); }
    void ReadUnlock()   { WriteUnlock(); }
    void ReadOrWriteUnlock(bool) { ReadUnlock(); } 

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock