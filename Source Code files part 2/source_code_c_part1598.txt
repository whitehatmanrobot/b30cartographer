 {       
        //
        // There is a domain, see if pre-pending is explicitly set in the
        // DUN setting for this connection.
        //
        LPTSTR pszDunEntry = NULL;
        LPTSTR pszPreviousSection = NULL;

        if (pszDunName && *pszDunName)
        {
            pszDunEntry = CmStrCpyAlloc(pszDunName);
        }
        else
        {
            pszDunEntry = GetDefaultDunSettingName(piniService, FALSE); // FALSE == fTunnelEntry, never called from DoTunnelDial
        }
        
        MYDBGASSERT(pszDunEntry);

        if (pszDunEntry)
        {
            //
            //  Since we are going to call SetSection on piniService to set it up
            //  to retrieve the DUN setting name, we should save the existing value
            //  before we overwrite it.
            //
            pszPreviousSection = CmStrCpyAlloc(piniService->GetSection());
            MYDBGASSERT(pszPreviousSection);

            if (pszPreviousSection) // this will either be "" or the previous section name
            {
                LPTSTR pszSection = CmStrCpyAlloc(TEXT("&"));

                pszSection = CmStrCatAlloc(&pszSection, pszDunEntry);
                MYDBGASSERT(pszSection);

                piniService->SetSection(pszSection);

                CmFree(pszSection);
            }
        }

        int nTmp = piniService->GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunPrependDialupDomain, -1);    

        if (-1 == nTmp)
        {
            //
            // There is no prepend flag, so on W9X infer from the VPN scenario.
            // The inference is that if we're dialing a number that is part of
            // a VPN scenario AND its a same-name logon, then we need to prepend
            // the Domain to the user name (eg. REDMOND\username).
            //

            if (OS_W9X && pArgs->fUseTunneling && pArgs->fUseSameUserName) 
            {
                bPrependDomain = TRUE;    
            }    
        }
        else
        {           
            bPrependDomain = (BOOL) nTmp;
        }

        //
        //  Restore the previous section to piniService to as not to have a function side effect.
        //
        if (pszPreviousSection)
        {
            piniService->SetSection(pszPreviousSection);
            CmFree(pszPreviousSection);        
        }

        CmFree(pszDunEntry);
    }

    //
    // Build username as required
    //

    LPTSTR pszName = NULL;

    if (bPrependDomain)
    {
        pszName = CmStrCpyAlloc(pArgs->szDomain);        
        CmStrCatAlloc(&pszName, TEXT("\\"));
        CmStrCatAlloc(&pszName, pszBuffer);
    }   
    else
    {
        pszName = CmStrCpyAlloc(pszBuffer);
    }

    return pszName;
}


//+----------------------------------------------------------------------------
//
// Function:  GetPrefixAndSuffix
//
// Synopsis:  Handles the messy details of determining the username prefix and 
//            suffix to be used. This data varies according to whether the 
//            referencING profile has either a prefix and suffix in which case 
//            they are used against all phone #s. However, if they do not exist
//            in the referencING profile, then the prefix and suffix in the 
//            referecED profile (if any) are used.
//
// Arguments: ArgsStruct *pArgs          - Ptr to global Args struct
//            CIni *piniService          - Ptr to the Cini object to be used
//            LPTSTR *ppszUsernamePrefix - Address of pointer to be allocated
//                                         filled w/ prefix.
//            LPTSTR *ppszUsernamePrefix - Address of pointer to be allocated
//                                         filled w/ suffix.
//
// Returns:   Nothing, caller should validate output
//
// History:   nickball    Created          05/31/00
//
//+----------------------------------------------------------------------------
void GetPrefixSuffix(ArgsStruct *pArgs, CIni* piniService, LPTSTR *ppszUsernamePrefix, LPTSTR *ppszUsernameSuffix)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(piniService);
    MYDBGASSERT(ppszUsernameSuffix);
    MYDBGASSERT(ppszUsernamePrefix);

    if (NULL == pArgs || NULL == piniService || NULL == ppszUsernamePrefix || NULL == ppszUsernameSuffix)
    {
        return;
    }   
    
    //
    // If the referencING (top-level) service file includes a prefix or suffix,
    // then we'll use it. Otherwise, we'll use the realm from the service file 
    // associated with the phone book from which the user selected the POP.
    //

    LPTSTR pszTmpPrefix = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryUserPrefix);
    LPTSTR pszTmpSuffix = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryUserSuffix);   

    //
    // Thus, if both prefix and suffix are empty and this is a referencED profile 
    // and the user has selected a phone # from a referenced pbk, we'll retrieve 
    // the data from the referencED service file.
    //
    
    if (pszTmpPrefix && pszTmpSuffix)
    {
        if (!*pszTmpPrefix && !*pszTmpSuffix)
        {
            if (pArgs->fHasRefs && 
                lstrcmpiU(pArgs->aDialInfo[pArgs->nDialIdx].szPhoneBookFile, pArgs->piniService->GetFile()) != 0) 
            {
                if (pszTmpPrefix)
                {
                    CmFree(pszTmpPrefix);
                }

                if (pszTmpSuffix)
                {
                    CmFree(pszTmpSuffix);
                }
                pszTmpPrefix = piniService->GPPS(c_pszCmSection, c_pszCmEntryUserPrefix);
                pszTmpSuffix = piniService->GPPS(c_pszCmSection, c_pszCmEntryUserSuffix);
            }
        }
    }

    *ppszUsernamePrefix = pszTmpPrefix;
    *ppszUsernameSuffix = pszTmpSuffix;
}

//+----------------------------------------------------------------------------
//
// Function:  ApplyPrefixSuffixToBufferAlloc
//
// Synopsis:  Handles the messy details of Domain management relative to username
//            Updates the the RasDialParams as appropriate.
//
// Arguments: ArgsStruct *pArgs     - Ptr to global Args struct
//            CIni *piniService     - Ptr to the Cini object to be used
//            LPTSTR pszBuffer      - Ptr to current buffer to which we'll apply
//                                    suffix and prefix data.
//
// Returns:   A new buffer allocation containing the original buffer
//            with applied suffix and prefix data. 
//
// Note:      The CIni object is expected to be that associated with the current
//            number. In other words, that returned by GetApporpriateIniService
//
// History:   nickball    Created          03/04/00
//            nickball    GetPrefixSuffix  05/31/00
//
//+----------------------------------------------------------------------------

LPTSTR ApplyPrefixSuffixToBufferAlloc(ArgsStruct *pArgs, 
                                      CIni *piniService, 
                                      LPTSTR pszBuffer)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(piniService);
    MYDBGASSERT(pszBuffer);

    if (NULL == pArgs || NULL == piniService || NULL == pszBuffer)
    {
        return NULL;
    }
   
    LPTSTR pszUsernamePrefix = NULL;
    LPTSTR pszUsernameSuffix = NULL;

    GetPrefixSuffix(pArgs, piniService, &pszUsernamePrefix, &pszUsernameSuffix);

    //
    // Don't double prepend the prefix if there is one. User may have
    // provided a fully qualified name including realm prefix. 
    // (eg. MSN/user)
    //

    if (*pszUsernamePrefix)
    {
        if (CmStrStr(pszBuffer, pszUsernamePrefix) == pszBuffer)
        {
            *pszUsernamePrefix = 0;
        }
    }

    CmStrCatAlloc(&pszUsernamePrefix, pszBuffer);

    //
    // Don't double append the suffix if there is one. User may have
    // provided a fully qualified name including domain suffix. 
    // (eg. user@ipass.com)
    //

    if (*pszUsernameSuffix)
    {
        LPTSTR pszTmp = CmStrStr(pszUsernamePrefix, pszUsernameSuffix);
    
        //
        // If the suffix exists in the combined string and the length of the 
        // suffix sub-string therein matches that of the suffix, then we
        // know its at the end of the combined string, so we don't append. 
        //

        if (!(pszTmp && lstrlenU(pszTmp) == lstrlenU(pszUsernameSuffix)))
        {            
            CmStrCatAlloc(&pszUsernamePrefix, pszUsernameSuffix);                   
        }
    }
    
    CmFree(pszUsernameSuffix);

    //
    // pszUsernamePrefix now contains the final product
    //

    return pszUsernamePrefix;    
}

//+----------------------------------------------------------------------------
//
// Function:  InBetween
//
// Synopsis:  Simple function which returns TRUE if the passed in number is
//            in between the given lower and upper bounds.  Note that the
//            boundaries themselves are considered in bounds.
//
// Arguments: int iLowerBound - lower bound
//            int iNumber - number to test
//            int iUpperBound - upper bound
//
// Returns:   TRUE if the number is equal to either of the boundaries or in between
//            the two numbers.  Note that if the lower and upper boundary numbers
//            are backwards it will always return FALSE.
//
//
// History:   quintinb    Created          07/24/00
//
//+----------------------------------------------------------------------------
BOOL InBetween(int iLowerBound, int iNumber, int iUpperBound)
{
    return ((iLowerBound <= iNumber) && (iUpperBound >= iNumber));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdl\cmfdi.h ===
//+----------------------------------------------------------------------------
//
// File:	 cmfdi.h
//
// Module:	 CMDL32.EXE
//
// Synopsis: CFdi class declarations
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 nickball    Created    04/08/98
//
//+----------------------------------------------------------------------------
#ifndef _CMDL_FDI_INC
#define _CMDL_FDI_INC

#include <windows.h>

extern "C" 
{
	#include <diamondd.h>
}

//
// CFDIFile declaration
//

class CFDIFile 
{
	public:
		virtual ~CFDIFile();
		virtual DWORD Read(LPVOID pv, DWORD cb);
		virtual DWORD Write(LPVOID pv, DWORD cb);
		virtual long Seek(long dist, int seektype);
		virtual int Close();
		virtual HANDLE GetHandle();
};

//
// CFDIFileFile declaration
//

class CFDIFileFile : public CFDIFile 
{
	public:
		CFDIFileFile();
		~CFDIFileFile();
		BOOL CreateFile(LPCTSTR pszFile,
						DWORD dwDesiredAccess,
						DWORD dwShareMode,
						DWORD dwCreationDistribution,
						DWORD dwFlagsAndAttributes,
						DWORD dwFileSize);
		BOOL CreateUniqueFile(LPTSTR pszFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes);
		virtual DWORD Read(LPVOID pv, DWORD cb);
		virtual DWORD Write(LPVOID pv, DWORD cb);
		virtual long Seek(long dist, int seektype);
		virtual int Close();
		virtual HANDLE GetHandle();
	private:
		HANDLE m_hFile;
};

//
// FDI wrapper routines
//

void HUGE * FAR DIAMONDAPI fdi_alloc(ULONG cb);

void FAR DIAMONDAPI fdi_free(void HUGE *pv);

INT_PTR FAR DIAMONDAPI fdi_open(char FAR *pszFile, int oflag, int pmode);

UINT FAR DIAMONDAPI fdi_read(INT_PTR hf, void FAR *pv, UINT cb);

UINT FAR DIAMONDAPI fdi_write(INT_PTR hf, void FAR *pv, UINT cb);

long FAR DIAMONDAPI fdi_seek(INT_PTR hf, long dist, int seektype);

int FAR DIAMONDAPI fdi_close(INT_PTR hf);

INT_PTR FAR DIAMONDAPI fdi_notify(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin);

#endif // _CMDL_FDI_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdl\cmfdi.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 cmfdi.cpp
//
// Module:	 CMDL32.EXE
//
// Synopsis: CFdi class implementations
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:	 nickball    Created    04/08/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#include <fcntl.h>
#include <sys\stat.h>

const TCHAR* const c_pszExeFile  =  TEXT("PBUPDATE.EXE");    // for detecting itExeInCab
const TCHAR* const c_pszInfFile  =  TEXT("PBUPDATE.INF");    // for detecting itInfInCab
const TCHAR* const c_pszVerFile  =  TEXT("PBUPDATE.VER");    // version string in .CAB
const TCHAR* const c_pszPbr      =  TEXT("PBR");            // regions file extension

//
// CFDIFile Implementation
//

CFDIFile::~CFDIFile() 
{
	// nothing
}

DWORD CFDIFile::Read(LPVOID pv, DWORD cb) 
{
	return 0;
}

DWORD CFDIFile::Write(LPVOID pv, DWORD cb) 
{
	return 0;
}

long CFDIFile::Seek(long dist, int seektype)
{
    return 0;
}

int CFDIFile::Close()
{
    return 0;
}

HANDLE CFDIFile::GetHandle() 
{
	return (INVALID_HANDLE_VALUE);
}

//
// CFDIFileFile Implementation
//

CFDIFileFile::CFDIFileFile() 
{

	m_hFile = INVALID_HANDLE_VALUE;
}


CFDIFileFile::~CFDIFileFile() 
{

	if (m_hFile != INVALID_HANDLE_VALUE) {
		MYDBG(("CFDIFileFile::~CFDIFileFile() destructor called while file still open."));
		Close();
	}
}


BOOL CFDIFileFile::CreateFile(LPCTSTR pszFile,
							  DWORD dwDesiredAccess,
							  DWORD dwShareMode,
							  DWORD dwCreationDistribution,
							  DWORD dwFlagsAndAttributes,
							  DWORD dwFileSize) 
{
	// Make sure the files isn't in use
	
	if (m_hFile != INVALID_HANDLE_VALUE) 
	{
		MYDBG(("CFDIFileFile::CreateFile() file is already open."));
		SetLastError(ERROR_OUT_OF_STRUCTURES);
		return (FALSE);
	}
	
	// Open Create/Open the file
	
	m_hFile = ::CreateFile(pszFile,dwDesiredAccess,dwShareMode,NULL,dwCreationDistribution,dwFlagsAndAttributes,NULL);
	if (m_hFile == INVALID_HANDLE_VALUE) 
	{
		MYDBG(("CFDIFileFile::CreateFile() CreateFile(pszFile=%s,dwDesiredAccess=%u,dwShareMode=%u,dwCreationDistribution=%u,dwFlagsAndAttributes=%u) failed, GLE=%u.",
			   pszFile,dwDesiredAccess,dwShareMode,dwCreationDistribution,dwFlagsAndAttributes,GetLastError()));
		return (FALSE);
	}
	
	// If dwFileSize is specified, move the pointer by dwFileSize bytes 
	
	if (dwFileSize) 
	{
		BOOL bRes;
		DWORD dwRes;
		dwRes = SetFilePointer(m_hFile,dwFileSize,NULL,FILE_BEGIN);
		MYDBGTST(dwRes==INVALID_SET_FILE_POINTER ,("CFDIFileFile::CreateFile() SetFilePointer() failed, GLE=%u.",GetLastError()));
		
		// If that worked, set the end of file at the file pointer position
		
		if (dwRes != INVALID_SET_FILE_POINTER) 
		{
			bRes = SetEndOfFile(m_hFile);
			MYDBGTST(!bRes,("CFDIFileFile::CreateFile() SetEndOfFile() failed, GLE=%u.",GetLastError()));
		}
		
		// Reset the file pointer to the beginning
		
		if ((dwRes != INVALID_SET_FILE_POINTER ) && bRes) 
		{
			dwRes = SetFilePointer(m_hFile,0,NULL,FILE_BEGIN);
			MYDBGTST(dwRes==INVALID_SET_FILE_POINTER ,("CFDIFileFile::CreateFile() SetFilePointer() failed, GLE=%u.",GetLastError()));
		}
		
		// Close the file and bail if we failed the above 
		
		if ((dwRes == INVALID_SET_FILE_POINTER ) || !bRes) 
		{
			bRes = CloseHandle(m_hFile);
			MYDBGTST(!bRes,("CFDIFileFile::CreateFile() CloseHandle() failed, GLE=%u.",GetLastError()));
			m_hFile = INVALID_HANDLE_VALUE;
			return (-1);
		} 		
	}
	
	return (TRUE);
}


BOOL CFDIFileFile::CreateUniqueFile(LPTSTR pszFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes) 
{
	DWORD dwIdx;
	TCHAR szFile[MAX_PATH+1];

	if (m_hFile != INVALID_HANDLE_VALUE) {
		MYDBG(("CFDIFileFile::CreateUniqueFile() file is already open."));
		SetLastError(ERROR_OUT_OF_STRUCTURES);
		return (FALSE);
	}
	dwIdx = 0;
	while (1) {
		wsprintf(szFile,"%08u.tmp",dwIdx);
		m_hFile = ::CreateFile(szFile,dwDesiredAccess,dwShareMode,NULL,CREATE_NEW,dwFlagsAndAttributes,NULL);
		if (m_hFile != INVALID_HANDLE_VALUE) {
			break;
		}
		if (IsErrorForUnique(GetLastError(), szFile)) {
			MYDBG(("CFDIFileFile::CreateUniqueFile() CreateFile() failed, GLE=%u.",GetLastError()));
			return (FALSE);
		}
		dwIdx++;
	}
	lstrcpy(pszFile,szFile);
	return (TRUE);
}


DWORD CFDIFileFile::Read(LPVOID pv, DWORD cb) 
{
	BOOL bRes;
	DWORD dwRes;

	bRes = ReadFile(m_hFile,pv,cb,&dwRes,NULL);
	if (!bRes) {
		MYDBG(("CFDIFileFile::Read() ReadFile() failed, GLE=%u.",GetLastError()));
		return ((UINT) -1);
	}
	return (dwRes);
}


DWORD CFDIFileFile::Write(LPVOID pv, DWORD cb) 
{
	BOOL bRes;
	DWORD dwRes;

	bRes = WriteFile(m_hFile,pv,cb,&dwRes,NULL);
	if (!bRes) {
		MYDBG(("CFDIFileFile::Write() WriteFile() failed, GLE=%u.",GetLastError()));
		return ((UINT) -1);
	}
	return (dwRes);
}


long CFDIFileFile::Seek(long dist, int seektype) 
{
	DWORD dwRes;

	dwRes = SetFilePointer(m_hFile,dist,NULL,seektype);
	if (dwRes == INVALID_SET_FILE_POINTER) {
		MYDBG(("CFDIFileFile::Seek() SetFilePointer() failed, GLE=%u.",GetLastError()));
		return (-1);
	}
	return ((long) dwRes);
}


int CFDIFileFile::Close() 
{
	BOOL bRes;

	bRes = CloseHandle(m_hFile);
	if (!bRes) {
		MYDBG(("CFDIFileFile::Close() CloseHandle() failed, GLE=%u.",GetLastError()));
		return (-1);
	}
	m_hFile = INVALID_HANDLE_VALUE;
	return (0);
}


HANDLE CFDIFileFile::GetHandle() 
{
	return (m_hFile);
}

//
// FDI wrapper routines
//

void HUGE * FAR DIAMONDAPI fdi_alloc(ULONG cb) 
{
	return (CmMalloc(cb));
}

void FAR DIAMONDAPI fdi_free(void HUGE *pv) 
{
	CmFree(pv);
}

INT_PTR FAR DIAMONDAPI fdi_open(char FAR *pszFile, int oflag, int pmode) 
{
	TCHAR szTempFileName[MAX_PATH+1];
	DWORD dwDesiredAccess;
	DWORD dwShareMode = FILE_SHARE_READ;
	DWORD dwCreationDistribution;
	DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
	DWORD dwFileSize = 0;
	DWORD dwRes;
	BOOL bRes;

	CFDIFileFile *pfff = NULL;

	pfff = new CFDIFileFile;
	if (!pfff) {
		MYDBG(("fdi_open() new CFDIFileFile failed."));
		return (-1);
	}

	switch (oflag & (_O_RDONLY|_O_WRONLY|_O_RDWR)) {

		case _O_RDONLY:
			dwDesiredAccess = GENERIC_READ;
			break;

		case _O_WRONLY:
			dwDesiredAccess = GENERIC_WRITE;
			break;

		case _O_RDWR:
			dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
			break;

		default:
			MYDBG(("fdi_open() invalid read/write flags, oflag=%u.",oflag));
			return (-1);
	}
	if (oflag & _O_CREAT) {
		if (!(pmode & _S_IWRITE)) {
			dwFlagsAndAttributes |= FILE_ATTRIBUTE_READONLY;
		}
	}
	if (oflag & (_O_CREAT | _O_EXCL)) {
		dwCreationDistribution = CREATE_NEW;
	} else if (oflag & (_O_CREAT | _O_TRUNC)) {
		dwCreationDistribution = CREATE_ALWAYS;
	} else if (oflag & _O_CREAT) {
		dwCreationDistribution = OPEN_ALWAYS;
	} else if (oflag & _O_TRUNC) {
		dwCreationDistribution = TRUNCATE_EXISTING;
	} else {
		dwCreationDistribution = OPEN_EXISTING;
	}
	if (*pszFile == '*') {
		PFDISPILLFILE pfsf = (PFDISPILLFILE) pszFile;
		TCHAR szTempPath[MAX_PATH+1];                                      

		ZeroMemory(szTempPath,sizeof(szTempPath));
		ZeroMemory(szTempFileName,sizeof(szTempFileName));
		dwRes = GetTempPath(sizeof(szTempPath)/sizeof(TCHAR)-1,szTempPath);
		MYDBGTST(!dwRes,("fdi_open() GetTempPath() failed, GLE=%u.",GetLastError()));
		
		dwRes = GetTempFileName(szTempPath,TEXT("ctf"),0,szTempFileName);
		MYDBGTST(!dwRes,("fdi_open() GetTempFileName() failed, GLE=%u.",GetLastError()));
		MYDBGTST(!dwRes,("fdi_open() GetTempFileName() failed, GLE=%u.",GetLastError()));
		pszFile = szTempFileName;
		dwFileSize = pfsf->cbFile;
		dwFlagsAndAttributes |= FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE;
	}
	bRes = pfff->CreateFile(pszFile,dwDesiredAccess,dwShareMode,dwCreationDistribution,dwFlagsAndAttributes,dwFileSize);

	if (!bRes) {
		delete pfff;
		return (-1);
	}                 
	
	return ((INT_PTR)pfff);    
}

UINT FAR DIAMONDAPI fdi_read(INT_PTR hf, void FAR *pv, UINT cb) 
{
		return (((CFDIFile *) hf)->Read(pv,cb));
}

UINT FAR DIAMONDAPI fdi_write(INT_PTR hf, void FAR *pv, UINT cb) 
{
	return (((CFDIFile *) hf)->Write(pv,cb));
}

long FAR DIAMONDAPI fdi_seek(INT_PTR hf, long dist, int seektype) 
{
	return (((CFDIFile *) hf)->Seek(dist,seektype));
}

int FAR DIAMONDAPI fdi_close(INT_PTR hf) 
{
	int nRes;

	CFDIFile *pff = (CFDIFile *) hf;
	nRes = pff->Close();
	delete pff;
	return (nRes);
}

INT_PTR FAR DIAMONDAPI fdi_notify(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin) 
{
	NotifyArgs *pnaArgs = (NotifyArgs *) pfdin->pv;
	BOOL bRes;

	switch (fdint) 
	{
		case fdintCOPY_FILE: 
		{
			InstallType itType;
			TCHAR szTmp[MAX_PATH+1];
	        LPTSTR  pszExt;         // file extension
	        PFILEPROCESSINFO pFPI;

			MYDBG(("fdi_notify() fdint=fdintCOPY_FILE, psz1=%s, cb=%u.",pfdin->psz1,pfdin->cb));
			if (lstrlen(pnaArgs->pdaArgs->szCabDir)+lstrlen(pfdin->psz1)+1>sizeof(szTmp)/sizeof(TCHAR)-1) 
			{
				MYDBG(("fdi_notify() szCabDir=%s+pszFile=%s exceeds MAX_PATH.",pnaArgs->pdaArgs->szCabDir,pfdin->psz1));
				return (-1);
			}
			lstrcpy(szTmp,pnaArgs->pdaArgs->szCabDir);
		
            if (szTmp[0] && (GetLastChar(szTmp) != '\\')) 
			{
				lstrcat(szTmp,TEXT("\\"));
			}
			lstrcat(szTmp,pfdin->psz1);
			
            if (!(pnaArgs->dwAppFlags & AF_NO_EXEINCAB) && (lstrcmpi(pfdin->psz1,c_pszExeFile) == 0)) 
			{
                //
                // Its a .EXE, note the fact for later processing
                //

#ifdef EXTENDED_CAB_CONTENTS

                itType = itExeInCab;

#else
                itType = itInvalid;  // currently an invalid type

#endif // EXTENDED_CAB_CONTENTS

                pnaArgs->pdaArgs->fContainsExeOrInf = TRUE;
			} 
            else if (!(pnaArgs->dwAppFlags & AF_NO_INFINCAB) && (lstrcmpi(pfdin->psz1,c_pszInfFile) == 0)) 
			{
                //
                // Its a .INF, note the fact for later processing
                //

#ifdef EXTENDED_CAB_CONTENTS

                itType = itInfInCab;

#else
                itType = itInvalid;  // currently an invalid type

#endif // EXTENDED_CAB_CONTENTS

        		pnaArgs->pdaArgs->fContainsExeOrInf = TRUE;
			} 
            else if (!(pnaArgs->dwAppFlags & AF_NO_PBDINCAB) && (lstrcmpi(pfdin->psz1,c_pszPbdFile) == 0)) 
			{
                //
                // Its a .PBD, note the fact for later processing
                //
				itType = itPbdInCab;
			} 
			else if ((pszExt = CmStrchr(pfdin->psz1, TEXT('.'))) && (lstrcmpi(pszExt+1, c_pszPbk) == 0)) 
			{
                *pszExt = TEXT('\0');
		        // if the PBK is not for this service, we don't use it.
		        if (lstrcmpi(pfdin->psz1, pnaArgs->pdaArgs->pszPhoneBookName) != 0)
                {
                    itType = itInvalid;
                }
		        else 
                {
                    itType = itPbkInCab;
                }
		        // restore the filename
		        *pszExt = TEXT('.');
            } 
    	    else if ((pszExt = CmStrchr(pfdin->psz1, TEXT('.'))) && (lstrcmpi(pszExt+1, c_pszPbr) == 0)) 
			{
		        *pszExt = TEXT('\0');
		        // if the PBR is not for this service, we don't use it.
		        if (lstrcmpi(pfdin->psz1, pnaArgs->pdaArgs->pszPhoneBookName) != 0)
                {
                    itType = itInvalid;
                }
		        else 
                {
                    itType = itPbrInCab;
                }
		        // restore the filename
		        *pszExt = TEXT('.');
		        
                // save the name in pdaArgs

                // if (!(pnaArgs->pdaArgs->pszNewPbrFile = CmStrCpyAlloc(pfdin->psz1))) 
                // {
                //     MYDBG((TEXT("fdi_notify(): CmStrCpyAlloc for pszNewPbrFile failed.")));
                //     return -1;
                // }
	        } 
	        else if (lstrcmpi(pfdin->psz1, c_pszVerFile) == 0)
            {
		        // a version file - we don't process it.  We'll read the version in fdintCLOSE_FILE_INFO
		        itType = itInvalid;
	        }
#ifdef EXTENDED_CAB_CONTENTS
            else if (!(pnaArgs->dwAppFlags & AF_NO_SHLINCAB)) 
	        {
			    itType = itShlInCab;
    		    pnaArgs->pdaArgs->fContainsShl = TRUE;
			} 
#endif // EXTENDED_CAB_CONTENTS
            else 
			{
			    itType = itInvalid;
			}
            
	        // create a file process info.  add one to the existing list.
	        if (itType != itInvalid) 
            {
		        if (!pnaArgs->pdaArgs->rgfpiFileProcessInfo) 
		            pFPI = (PFILEPROCESSINFO)CmMalloc(sizeof(FILEPROCESSINFO));
		        else
		            pFPI = (PFILEPROCESSINFO)CmRealloc(pnaArgs->pdaArgs->rgfpiFileProcessInfo,
			                    (pnaArgs->pdaArgs->dwNumFilesToProcess+1)*sizeof(FILEPROCESSINFO));
		        
                if (!pFPI) 
                {
		            MYDBG((TEXT("fdi_notify(): Malloc(FILEPROCESSINFO) failed.")));
		            return -1;
		        }

                pnaArgs->pdaArgs->rgfpiFileProcessInfo = pFPI;
		        pnaArgs->pdaArgs->dwNumFilesToProcess++;
		        pFPI[pnaArgs->pdaArgs->dwNumFilesToProcess-1].itType = itType;
		        pFPI[pnaArgs->pdaArgs->dwNumFilesToProcess-1].pszFile = CmStrCpyAlloc(pfdin->psz1);
	        }

		    // Do standard fdintCOPY_FILE processing, create the file and return the handle
		
			CFDIFileFile *pfff;
			BOOL bRes;
	
			pfff = new CFDIFileFile;
			if (!pfff) 
			{
				MYDBG(("fdi_notify() new CFDIFileFile failed."));
				return (-1);
			}
			bRes = pfff->CreateFile(szTmp,GENERIC_WRITE,FILE_SHARE_READ,CREATE_NEW,FILE_ATTRIBUTE_NORMAL,0);
			if (!bRes) 
			{
				delete pfff;
				return (-1);
			}
	
			return ((INT_PTR)pfff);    
		}

		case fdintCLOSE_FILE_INFO: 
		{
			int iRes;
			TCHAR szTmp[MAX_PATH+1];

			// Append file name to cab dir
			
			lstrcpy(szTmp,pnaArgs->pdaArgs->szCabDir);
			if (szTmp[0] && (GetLastChar(szTmp) != '\\')) 
			{
				lstrcat(szTmp,TEXT("\\"));
			}
			lstrcat(szTmp,pfdin->psz1);

			// Set the date and time to the original file time not the current time
			
			FILETIME ftTmp;
			FILETIME ftTime;

			bRes = DosDateTimeToFileTime(pfdin->date,pfdin->time,&ftTmp);
			MYDBGTST(!bRes,("fdi_notify() DosDateTimeToFileTime(%u,%u) failed, GLE=%u.",pfdin->date,pfdin->time,GetLastError()));
			
			bRes = LocalFileTimeToFileTime(&ftTmp,&ftTime);
			MYDBGTST(!bRes,("fdi_notify() LocalFileTimeToFileTime() failed, GLE=%u.",GetLastError()));
			
			bRes = SetFileTime(((CFDIFile *) (pfdin->hf))->GetHandle(),&ftTime,&ftTime,&ftTime);
			MYDBGTST(!bRes,("fdi_notify() SetFileTime() failed, GLE=%u.",GetLastError()));

			iRes = fdi_close(pfdin->hf);   

			// If this is the version file, get the version number

			if (lstrcmpi(pfdin->psz1,c_pszVerFile) == 0) 
			{
				pnaArgs->pdaArgs->pszVerNew = GetVersionFromFile(szTmp);
			}                               

			// Set file attributes according to original file attribs

			bRes = SetFileAttributes(szTmp,pfdin->attribs);
			MYDBGTST(!bRes,("fdi_notify() SetFileAttributes(%s,%u) failed, GLE=%u.",szTmp,pfdin->attribs,GetLastError()));
						
			return ((iRes==0)?TRUE:FALSE);
		}

		case fdintNEXT_CABINET:
			MYDBG(("fdi_notify_scan() spanning cabinets is not supported."));
			return (-1);

		default:
			MYDBG(("fdi_notify_scan() fdint=%u.",fdint));
			break;
	}
	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdl\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//      
// Module:   CMDL32.EXE 
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:	 nickball   Created   04/08/98
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include "cmdl.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdl\cmdl.h ===
//+----------------------------------------------------------------------------
//
// File:         cmdl.h
//
// Module:       CMDL32.EXE
//
// Synopsis: Header file for common definitions
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:       nickball    Created    04/08/98
//
//+----------------------------------------------------------------------------

#ifndef _CMDL_INC
#define _CMDL_INC

#include <windows.h>
#include <ras.h>
#include <raserror.h>
#include <windowsx.h>

#ifdef  WIN32_LEAN_AND_MEAN
#include <shellapi.h>
#endif

#include <stdlib.h>                                                                          
#include <ctype.h>
#include <tchar.h>

//#define ISBU_VERSION                          "6.0.1313.0\0"          /* VERSIONINFO string */

#include <commctrl.h>
#include <wininet.h>

// Define EXTENDED_CAB_CONTENTS only if we support download of other items 
// besides PBKs, PBDs, PBRs, and VERs inside or in lieu of CAB files. You 
// will need to link statically to wintrust.lib to compile.

#ifdef EXTENDED_CAB_CONTENTS
#include <wintrust.h>
#endif

#include <stdio.h>
#include <io.h>

#include "base_str.h"
#include "dl_str.h"
#include "mgr_str.h"
#include "pbk_str.h"
#include "log_str.h"
#include "cm_def.h"
#include "resource.h"
#include "cm_phbk.h"
#include "cmdebug.h"
#include "cmutil.h"
#include "cmlog.h"
#include "mutex.h"
#include "cmfdi.h"
#include "util.h"
#include "pnpuverp.h"

#define BUFFER_LENGTH           (8*1024)                                                                                // buffer length for i/o
#define DEFAULT_DELAY           (2*60)                                                                                  // default delay before downloading, in seconds
#define DEFAULT_HIDE            (-1)                   // default number of milliseconds to keep window hidden

const TCHAR* const c_pszPbdFile =  TEXT("PBUPDATE.PBD");    // for detecting itPbdInCab

#define IDX_INETTHREAD_HANDLE   0               // must be *first*
#define IDX_EVENT_HANDLE        1

#define HANDLE_COUNT            2

extern "C" __declspec(dllimport) HRESULT WINAPI PhoneBookLoad(LPCSTR pszISP, DWORD_PTR *pdwPB);
extern "C" __declspec(dllimport) HRESULT WINAPI PhoneBookUnload(DWORD_PTR dwPB);
extern "C" __declspec(dllimport) HRESULT WINAPI PhoneBookMergeChanges(DWORD_PTR dwPB, LPCSTR pszChangeFile);

typedef enum _EventType {
        etDataBegin,
        etDataReceived,
        etDataEnd,
#ifdef EXTENDED_CAB_CONTENTS
        etVerifyTrust,
#endif
        etInstall,
        etDone,
        etICMTerm
} EventType;


// Values for dwAppFlags
#define AF_NO_DELETE            0x0001                  // does not delete file(s) on exit
#define AF_NO_INSTALL           0x0002                  // downloads and verifies, but does not install
#ifdef DEBUG
#define AF_NO_VERIFY            0x0004                  // bypasses WinVerifyTrust() - only available in DEBUG builds
#endif
#define AF_NO_PROFILE           0x0008                  // no profile on command line (and hence must use AF_URL, and no phone book delta support)
#define AF_URL                  0x0010                  // URL on command line (in next token) instead of in profile->service
#define AF_NO_EXE               0x0020                  // disable running of .EXEs
#define AF_NO_EXEINCAB          0x0040                  // disable running of PBUPDATE.EXE from .CAB
#define AF_NO_INFINCAB          0x0080                  // disable running of PBUPDATE.INF from .CAB
#define AF_NO_PBDINCAB          0x0100                  // disable running of PBUPDATE.PBD from .CAB
#define AF_NO_SHLINCAB          0x0200                  // disable running of first file in .CAB
#define AF_NO_VER               0x0400                  // disable updating of phone book version
//#define AF_NO_UPDATE          0x0800                  // don't do any work
#define AF_LAN                  0x1000                  // update request is over a LAN, don't look for the RAS connection before download
#define AF_VPN                  0x2000                  // this is a VPN file update request instead of a PBK update request


typedef void (*EVENTFUNC)(DWORD,DWORD,LPVOID);


// NOTE - the values in enum _InstallType are in sorted order!  Higher values have
// higher precendence.

typedef enum _InstallType {

#ifdef EXTENDED_CAB_CONTENTS
        itInvalid = 0,  // Must be 0.
        itShlInCab,
        itPbdInCab,
        itPbkInCab,
        itPbrInCab,
        itInfInCab,
        itExeInCab,
        itExe
#else
        itInvalid = 0,  // Must be 0.
        itPbdInCab,
        itPbkInCab,
        itPbrInCab,
#endif

} InstallType;


// the info on how we process each file we find in the cab
typedef struct _FILEPROCESSINFO {
    LPTSTR      pszFile;
    InstallType itType;
} FILEPROCESSINFO, *PFILEPROCESSINFO;

// download args, one per URL(or .cms)
typedef struct _DownloadArgs {
    LPTSTR pszCMSFile;
    LPTSTR pszPbkFile;
    LPTSTR pszPbrFile;
    LPTSTR pszUrl;
    LPTSTR pszVerCurr;
    LPTSTR pszVerNew;
    LPTSTR pszPhoneBookName;
    LPURL_COMPONENTS psUrl;
    HINTERNET hInet;
    HINTERNET hConn;
    HINTERNET hReq;
    TCHAR szFile[MAX_PATH+1];
    EVENTFUNC pfnEvent;
    LPVOID pvEventParam;
    DWORD dwTransferred;
    DWORD dwTotalSize;
    BOOL bTransferOk;
    BOOL * volatile pbAbort;
    TCHAR szCabDir[MAX_PATH+1];
    BOOL fContainsExeOrInf;
    TCHAR szHostName[MAX_PATH+1];
    DWORD dwBubbledUpError;
#ifdef EXTENDED_CAB_CONTENTS
    BOOL fContainsShl;
#endif // EXTENDED_CAB_CONTENTS
    DWORD   dwNumFilesToProcess;
    PFILEPROCESSINFO   rgfpiFileProcessInfo;
} DownloadArgs;

typedef struct _ArgsStruct {
    HINSTANCE hInst;
    DWORD dwDownloadDelay;
    LPTSTR pszProfile;
    DWORD dwAppFlags;
    UINT nMsgId;
    HWND hwndDlg;
    DWORD dwHandles;
    HANDLE ahHandles[HANDLE_COUNT];
    DWORD dwArgsCnt;
    DownloadArgs *pdaArgs;
    BOOL bAbort;
    DWORD dwDataCompleted;
    DWORD dwDataTotal;
    DWORD dwDataStepSize;
    LPTSTR pszServiceName;
    HICON hIcon;
    HICON hSmallIcon;
    BOOL bShow;
    DWORD dwFirstEventTime;
    DWORD dwHideDelay;
    DWORD dwComplete;
    CmLogFile Log;
#ifdef EXTENDED_CAB_CONTENTS
    TCHAR szInstallTitle[MAX_PATH+1];
    DWORD dwRebootCookie;
    HINSTANCE hAdvPack;
        BOOL bVerified;
#endif // EXTENDED_CAB_CONTENTS
} ArgsStruct;

typedef struct _NotifyArgs 
{
        DWORD dwAppFlags;
        DownloadArgs *pdaArgs;
} NotifyArgs;

//
//  Function Prototypes
//
BOOL UpdateVpnFileForProfile(LPCTSTR pszCmpPath);


#endif // _CMDL_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdl\mutexclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mutexclass.cpp     
//
// Module:   CMDL32.EXE
//
// Synopsis: Mutex class implementation.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

#ifndef UNICODE
#define CreateMutexU CreateMutexA
#else
#define CreateMutexU CreateMutexW
#endif

//
//	Please see pnpu\common\source for the actual source here.
//
#include "mutex.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdl\util.h ===
//+----------------------------------------------------------------------------
//
// File:	 util.h
//
// Module:	 CMDL32.EXE
//
// Synopsis: Header file for utility routines specific to CMDL
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 nickball    Created    04/08/98
//
//+----------------------------------------------------------------------------

#ifndef _CMDL_UTIL_INC
#define _CMDL_UTIL_INC

//
// Function Protoypes
//

BOOL IsErrorForUnique(DWORD dwErrCode, LPSTR lpszFile);
LPTSTR GetVersionFromFile(LPSTR lpszFile);
BOOL CreateTempDir(LPTSTR pszDir);
TCHAR GetLastChar(LPTSTR pszStr);
LPTSTR *GetCmArgV(LPTSTR pszCmdLine);

#endif // _CMDL_UTIL_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdl\vpndownload.cpp ===
//+----------------------------------------------------------------------------
//
// File:     vpndownload.cpp
//
// Module:   CMDL32.EXE
//
// Synopsis: This file contains the code to handle the updating of VPN phonebooks.
//
// Copyright (c) 2000-2001 Microsoft Corporation
//
// Author:   quintinb   Created     11/03/00
//
//+----------------------------------------------------------------------------
#include "cmdl.h"
#include "gppswithalloc.cpp"
#include "tunl_str.h"

//+----------------------------------------------------------------------------
//
// Function:  DownloadVpnFileFromUrl
//
// Synopsis:  This function is responsible for downloading a VPN file update
//            from the given URL and storing the retreived data in a temp file.
//            The full path to the temp file is passed back to the caller via
//            the ppszVpnUpdateFile variable.  The var must be freed by the caller.
//
// Arguments: LPCTSTR pszVpnUpdateUrl - URL to update the vpn file from
//            LPTSTR* ppszVpnUpdateFile - pointer to hold the file name of the
//                                        updated VPN file downloaded from the server.
//                                        Used by the caller to copy the temp file
//                                        over the existing file.  The memory allocated
//                                        for this string must be freed by the caller.
//
// Returns:   BOOL - TRUE if the download was successful
//
// History:   quintinb Created     11/05/00
//
//+----------------------------------------------------------------------------
BOOL DownloadVpnFileFromUrl(LPCTSTR pszVpnUpdateUrl, LPTSTR* ppszVpnUpdateFile)
// REVIEW: shouldn't this support the /LAN flag and not do the download if it cannot find the CM connection active?  What
//         about setting the socket option code?
{
    BOOL bReturn = FALSE;
    BOOL bDeleteFileOnFailure = FALSE;
    HANDLE hFile = NULL;
    HINTERNET hInternet = NULL;
    HINTERNET hPage = NULL;
    DWORD dwSize = MAX_PATH;
    LPTSTR pszBuffer = NULL;
    BOOL bExitLoop = FALSE;

    if ((NULL == pszVpnUpdateUrl) || (TEXT('\0') == pszVpnUpdateUrl[0]))
    {
        goto Cleanup;
    }

    CMTRACE1("DownloadVpnFileFromUrl: URL is %s", pszVpnUpdateUrl);

    //
    //  First, let's create the file that we are going to download the updated file
    //  too.  This requires us to figure out what the temporary directory path is
    //  and then create a uniquely named file in it.
    //

    do
    {
        CmFree(pszBuffer);
        pszBuffer = (LPTSTR)CmMalloc((dwSize + 1)*sizeof(TCHAR));

        if (pszBuffer)
        {
            DWORD dwReturnedSize = GetTempPath (dwSize, pszBuffer);

            if (0 == dwReturnedSize)
            {
                //
                //  An error occurred, lets report it and bail.
                //
                DWORD dwError = GetLastError();
                CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- GetTempPath returned an error."));
                CMTRACE1(TEXT("DownloadVpnFileFromUrl -- GetTempPath failed, GLE = %d"), dwError);
                goto Cleanup;
            }
            else if (dwReturnedSize > dwSize)
            {
                //
                //  Not big enough we will have to loop again.
                //
                dwSize = dwReturnedSize;
                if (1024*1024 < dwReturnedSize)
                {
                    CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- GetTempPath asked for more than 1MB of memory.  Something is wrong, bailing."));
                    goto Cleanup;                
                }
            }
            else
            {
                //
                //  We got what we wanted, it's time to leave the loop
                //
                bExitLoop = TRUE;
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- CmMalloc failed for pszBuffer."));
            goto Cleanup;
        }
    
    } while(!bExitLoop);

    //
    //  Okay, now we have the temp file path.  Next let's get a temp file name in that directory.
    //
    *ppszVpnUpdateFile = (LPTSTR)CmMalloc((dwSize + 24)*sizeof(TCHAR)); // GetTempFileName doesn't provide sizing info, lame
    
    if (*ppszVpnUpdateFile)
    {
        dwSize = GetTempFileName(pszBuffer, TEXT("VPN"), 0, *ppszVpnUpdateFile);

        if ((0 == dwSize) || (TEXT('\0') == (*ppszVpnUpdateFile)[0]))
        {
            CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- GetTempFileName failed."));
            goto Cleanup;
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- CmMalloc failed for *ppszVpnUpdateFile"));
        goto Cleanup;    
    }

    //
    //  Free pszBuffer so we can use it to read in file data below
    //
    CmFree (pszBuffer);
    pszBuffer = NULL;

    //
    //  Okay, we have a file name let's get a file handle to it that we can write too
    //

    hFile = CreateFile(*ppszVpnUpdateFile, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        //
        //  We have created the file, let's make sure to delete it if we fail from here on out.
        //
        bDeleteFileOnFailure = TRUE;

        //
        //  Initialize WININET
        //
        hInternet = InternetOpen(TEXT("Microsoft(R) Connection Manager Vpn File Update"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);

        if (hInternet)
        {
            //
            //  Open the URL
            //
            hPage = InternetOpenUrl(hInternet, pszVpnUpdateUrl, NULL, 0, 0, 0);

            if (hPage)
            {
                const DWORD c_dwBufferSize = 1024; // REVIEW: why did the original use 4096 on the stack, seems awfully large to me?
                pszBuffer = (LPTSTR)CmMalloc(c_dwBufferSize);

                if (pszBuffer)
                {
                    bExitLoop = FALSE;

                    do
                    {
                        if (InternetReadFile(hPage, pszBuffer, c_dwBufferSize, &dwSize))
                        {
                            //
                            //  We got data, write it to the temp file
                            //

                            if (0 == dwSize)
                            {
                                //
                                //  We succeeded with a zero read size.  That means we hit
                                //  end of file and are done.
                                //
                                bReturn = TRUE;
                                bExitLoop = TRUE;
                            }

                            if (FALSE == WriteFile(hFile, pszBuffer, dwSize, &dwSize, NULL))
                            {
                                bReturn = FALSE;
                                CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- WriteFile failed."));
                                goto Cleanup;   
                            }
                        }
                        else
                        {
                            goto Cleanup;
                        }

                    } while (!bExitLoop);
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("DownloadVpnFileFromUrl -- unable to allocate the file buffer"));
                    goto Cleanup;                
                }
            }
            else
            {
                DWORD dwError = GetLastError();
                CMTRACE1(TEXT("DownloadVpnFileFromUrl -- InternetOpenUrl failed, GLE %s"), dwError);
            }
        }
        else
        {
            DWORD dwError = GetLastError();
            CMTRACE1(TEXT("DownloadVpnFileFromUrl -- InternetOpen failed, GLE %s"), dwError);
        }
    }

Cleanup:

    //
    //  Close our handles
    //
    if (hPage)
    {
        InternetCloseHandle(hPage);
    }

    if (hInternet)
    {
        InternetCloseHandle(hInternet);
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

    //
    //  Free up the buffer we alloc-ed
    //
    CmFree(pszBuffer);

    //
    //  Finally cleanup the temp file and temp file name if we failed
    //
    if (FALSE == bReturn)
    {
        if (bDeleteFileOnFailure && *ppszVpnUpdateFile)
        {
            DeleteFile(*ppszVpnUpdateFile);
        }

        CmFree(*ppszVpnUpdateFile);
        *ppszVpnUpdateFile = NULL;

        CMTRACE(TEXT("DownloadVpnFileFromUrl -- VPN file download failed!"));
    }
    else
    {
        CMTRACE(TEXT("DownloadVpnFileFromUrl -- VPN file download succeeded!"));
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  OverwriteVpnFileWithUpdate
//
// Synopsis:  This function is responsible for copying the given new vpn file
//            over the given existing vpn file.  The code first makes a backup
//            copy of the existing file just in case something goes wrong with the
//            data overwrite.  If a problem exists then it copies the original back
//            over to ensure nothing got corrupted in the failed copy.
//
// Arguments: LPCTSTR pszExistingVpnFile - full path to the existing VPN file
//            LPCTSTR pszNewVpnFile - full path to the temp VPN file to overwrite
//                                    the existing file with.
//
// Returns:   BOOL - TRUE if the update was successful
//
// History:   quintinb Created     11/03/00
//
//+----------------------------------------------------------------------------
BOOL OverwriteVpnFileWithUpdate(LPCTSTR pszExistingVpnFile, LPCTSTR pszNewVpnFile)
{
    if ((NULL == pszExistingVpnFile) || (NULL == pszNewVpnFile) ||
        (TEXT('\0') == pszExistingVpnFile[0]) || (TEXT('\0') == pszNewVpnFile[0]))
    {
        CMASSERTMSG(FALSE, TEXT("OverwriteVpnFileWithUpdate -- invalid parameter passed."));
        return FALSE;
    }

    BOOL bReturn = FALSE;

    //
    //  We first want to make a backup copy of the original file
    //
    const TCHAR* const c_pszDotBak = TEXT(".bak");
    DWORD dwSize = (lstrlen(pszExistingVpnFile) + lstrlen(c_pszDotBak) + 1)*sizeof(TCHAR);

    LPTSTR pszBackupFile = (LPTSTR)CmMalloc(dwSize);

    if (pszBackupFile)
    {
        wsprintf(pszBackupFile, TEXT("%s%s"), pszExistingVpnFile, c_pszDotBak);

        if (pszBackupFile[0])
        {
            if (CopyFile(pszExistingVpnFile, pszBackupFile, FALSE)) // FALSE == bFailIfExists
            {
                //
                //  Now copy over the new file
                //
                if (CopyFile(pszNewVpnFile, pszExistingVpnFile, FALSE)) // FALSE == bFailIfExists
                {
                    bReturn = TRUE;
                }
                else
                {
                    DWORD dwError = GetLastError();
                    CMTRACE1(TEXT("OverwriteVpnFileWithUpdate -- CopyFile of the new file over the original file failed, GLE %s"), dwError);
                    CMASSERTMSG(FALSE, TEXT("OverwriteVpnFileWithUpdate -- update of the original file failed, attempting to restore the original from backup."));

                    //
                    //  We need to restore the backup file
                    //
                    if (!CopyFile(pszBackupFile, pszExistingVpnFile, FALSE)) // FALSE == bFailIfExists
                    {
                        dwError = GetLastError();
                        CMTRACE1(TEXT("OverwriteVpnFileWithUpdate -- CopyFile to restore the saved backup file failed, GLE %s"), dwError);

                        CMASSERTMSG(FALSE, TEXT("OverwriteVpnFileWithUpdate -- restoration of backup failed!"));
                    }
                }

                //
                //  Delete the backup file
                //
                DeleteFile(pszBackupFile);
            }
            else
            {
                DWORD dwError = GetLastError();
                CMTRACE1(TEXT("OverwriteVpnFileWithUpdate -- CopyFile of the original file to the backup file failed, GLE %s"), dwError);
            }
        }
    }

    CmFree(pszBackupFile);

    if (bReturn)
    {
        CMTRACE(TEXT("OverwriteVpnFileWithUpdate -- VPN file update succeeded!"));
    }
    else
    {
        CMTRACE(TEXT("OverwriteVpnFileWithUpdate -- VPN file update failed."));    
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  UpdateVpnFileForProfile
//
// Synopsis:  This function is called to download and update a VPN file with a
//            newly downloaded VPN update file.
//
// Arguments: LPCTSTR pszCmpPath - full path to the cmp file
//
// Returns:   BOOL - TRUE if the download and update were successful.
//
// History:   quintinb Created     11/03/00
//
//+----------------------------------------------------------------------------
BOOL UpdateVpnFileForProfile(LPCTSTR pszCmpPath)
{

    if ((NULL == pszCmpPath) || (TEXT('\0') == pszCmpPath[0]))
    {
        CMASSERTMSG(FALSE, TEXT("UpdateVpnFileForProfile in cmdl32.exe -- invalid pszCmpPath parameter."));
        return FALSE;
    }

    BOOL bReturn = FALSE;

    //
    //  Convert the .cmp path into the .cms path
    //

    LPTSTR pszService = GetPrivateProfileStringWithAlloc(c_pszCmSection, c_pszCmEntryCmsFile, TEXT(""), pszCmpPath);

    if (pszService && *pszService)
    {
        //
        // We have the relative path to the cms, build the full path to the file
        //

        LPTSTR pszCmsPath = CmBuildFullPathFromRelative(pszCmpPath, pszService);

        if (pszCmsPath && *pszCmsPath)
        {
            //
            //  Next get the VPN phonebook file name from the profile.
            //
            LPTSTR pszVpnFileName = GetPrivateProfileStringWithAlloc(c_pszCmSection, c_pszCmEntryTunnelFile, TEXT(""), pszCmsPath);

            if (pszVpnFileName && *pszVpnFileName)
            {
                LPTSTR pszVpnFile = CmBuildFullPathFromRelative(pszCmpPath, pszVpnFileName);

                if (pszVpnFile && *pszVpnFile)
                {
                    //
                    //  Now get the URL to update the vpn file from
                    //
                    LPTSTR pszVpnUpdateUrl = GetPrivateProfileStringWithAlloc(c_pszCmSectionSettings, c_pszCmEntryVpnUpdateUrl, TEXT(""), pszVpnFile);

                    if (pszVpnUpdateUrl && *pszVpnUpdateUrl)
                    {
                        //
                        //  Finally, we have a URL so let's download the updated VPN server list.
                        //
                        LPTSTR pszUpdatedVpnFile = NULL;
                        bReturn = DownloadVpnFileFromUrl(pszVpnUpdateUrl, &pszUpdatedVpnFile);

                        if (bReturn && pszUpdatedVpnFile && *pszUpdatedVpnFile)
                        {
                            bReturn = OverwriteVpnFileWithUpdate(pszVpnFile, pszUpdatedVpnFile);
                        }

                        CmFree (pszUpdatedVpnFile);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("UpdateVpnFileForProfile in cmdl32.exe -- unable to get the URL to update the vpn file from..."));    
                    }

                    CmFree(pszVpnUpdateUrl);
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("UpdateVpnFileForProfile in cmdl32.exe -- unable to expand the path to the vpn file."));    
                }

                CmFree(pszVpnFile);
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("UpdateVpnFileForProfile in cmdl32.exe -- unable to retrieve the vpn file name."));    
            }

            CmFree(pszVpnFileName);
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("UpdateVpnFileForProfile in cmdl32.exe -- unable to build the cms path from the cmp path."));    
        }
        
        CmFree(pszCmsPath);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("UpdateVpnFileForProfile in cmdl32.exe -- unable to get the relative path to the CMS."));    
    }

    CmFree(pszService);

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdl\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 util.cpp
//
// Module:	 CMDL32.EXE
//
// Synopsis: Utility routines specific to CMDL
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 nickball    Created    4/8/98
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
// Definitions
//

#define MAX_CMD_ARGS            15

typedef enum _CMDLN_STATE
{
    CS_END_SPACE,   // done handling a space
    CS_BEGIN_QUOTE, // we've encountered a begin quote
    CS_END_QUOTE,   // we've encountered a end quote
    CS_CHAR,        // we're scanning chars
    CS_DONE
} CMDLN_STATE;

//
// Helper function to determine if a file open error 
// is due to the fact that a file doesn't exist
//

BOOL IsErrorForUnique(DWORD dwErrCode, LPSTR lpszFile) 
{
	if (!lpszFile)
	{
		MYDBGASSERT(lpszFile);
		return TRUE;
	}

	// If the file exists, return false, its not a unique file error
	
	switch (dwErrCode) 
	{
		case ERROR_FILE_EXISTS:
		case ERROR_ACCESS_DENIED:
		case ERROR_ALREADY_EXISTS:
			return (FALSE);

		default:
			break;
	}

    return (TRUE);
}

//
// Helper function to retrieve the version number from the version file
//

LPTSTR GetVersionFromFile(LPSTR lpszFile)
{
    MYDBGASSERT(lpszFile);

    LPTSTR pszVerNew = NULL;

    if (NULL == lpszFile)
    {
        return NULL;
    }

    //
    // We simply read the version file contents to get the version number
	//
    				
	HANDLE hFileSrc = CreateFile(lpszFile,
		                           GENERIC_READ,
		                           FILE_SHARE_READ,
		                           NULL,
		                           OPEN_EXISTING, 
		                           FILE_ATTRIBUTE_NORMAL,
		                           NULL);

	MYDBGTST(hFileSrc == INVALID_HANDLE_VALUE,("GetVersionFromFile() CreateFile() failed - %s.", lpszFile));

	if (hFileSrc != INVALID_HANDLE_VALUE)
	{
        DWORD dwSize = GetFileSize(hFileSrc, NULL);

        MYDBGTST(dwSize >= 0x7FFF,("GetVersionFromFile() Version file is too large - %s.", lpszFile));
    
        if (dwSize < 0x7FFF)
        {
            // Read in contennts

	        DWORD dwBytesIn;
	 
			pszVerNew = (LPTSTR) CmMalloc(dwSize);
						
			if (pszVerNew) 
			{
		        // Read entire file contents into buffer
		        
		        int nRead = ReadFile(hFileSrc, pszVerNew, dwSize, &dwBytesIn, NULL);
		        MYDBGTST(!nRead,("GetVersionFromFile() ReadFile() failed - %s.",lpszFile));

				if (nRead)
        		{
				    // Make sure that the ver string is properly truncated
						
					LPTSTR pszTmp = pszVerNew;
			
					while (*pszTmp) 
					{
						// Truncate the version string to the first tab, newline, or carriage return.
			
						if (*pszTmp == '\t' || *pszTmp == '\n' || *pszTmp == '\r') 
						{
							*pszTmp = 0;
							break;
						}
			
						pszTmp++;
					}
		        }
	        }

			MYDBGTST(!pszVerNew,("GetVersionFromFile() CmMalloc(%u) failed.",dwSize));
	    }
					
		CloseHandle(hFileSrc);
	} 

    return pszVerNew;
}

//
// Helper function to create a temp directory.  Note that we
// expect pszDir to be at least MAX_PATH + 1.
//

BOOL CreateTempDir(LPTSTR pszDir) 
{
    TCHAR szTmp[MAX_PATH+1];
    BOOL bRes = FALSE;

    if (pszDir)
    {
        UINT uReturn = GetTempFileName(TEXT("."), TEXT("000"), 0, szTmp);

        if (0 == uReturn)
        {
            DWORD dwError = GetLastError();
            MYDBG(("CreateTempDir() GetTempFileName failed, GLE=%u.", dwError));
        }
        else
        {
            MYVERIFY(DeleteFile(szTmp));

            bRes = CreateDirectory(szTmp, NULL);

            if (!bRes) 
            {
                MYDBG(("CreateTempDir() CreateDirectory() failed, GLE=%u.",GetLastError()));
            }
            else
            {
                lstrcpy(pszDir, szTmp);
            }
        }
    }

    return bRes;
}

//
// Get the last character(DBCS-enabled)
//

TCHAR GetLastChar(LPTSTR pszStr)
{
    LPTSTR  pszPrev;
     
    if (!pszStr)
    {
    	return 0;
    }

    pszPrev = pszStr;

    while (*pszStr)
    {
	    pszPrev = pszStr;
	    pszStr = CharNext(pszStr);
    }

    return *pszPrev;
}


//+----------------------------------------------------------------------------
//
// Function:  GetCmArgV
//
// Synopsis:  Simulates ArgV using GetCommandLine
//
// Arguments: LPTSTR pszCmdLine - Ptr to a copy of the command line to be processed
//
// Returns:   LPTSTR * - Ptr to a ptr array containing the arguments. Caller is
//                       responsible for releasing memory.
//
// History:   nickball    Created     4/9/98
//
//+----------------------------------------------------------------------------
LPTSTR *GetCmArgV(LPTSTR pszCmdLine)
{   
    MYDBGASSERT(pszCmdLine);

    if (NULL == pszCmdLine || NULL == pszCmdLine[0])
    {
        return NULL;
    }

    //
    // Allocate Ptr array, up to MAX_CMD_ARGS ptrs
    //
    
    LPTSTR *ppCmArgV = (LPTSTR *) CmMalloc(sizeof(LPTSTR) * MAX_CMD_ARGS);

    if (NULL == ppCmArgV)
    {
        return NULL;
    }

    //
    // Declare locals
    //

    LPTSTR pszCurr;
    LPTSTR pszNext;
    LPTSTR pszToken;
    CMDLN_STATE state;
    state = CS_CHAR;
    int ndx = 0;  

    //
    // Parse out pszCmdLine and store pointers in ppCmArgV
    //

    pszCurr = pszToken = pszCmdLine;

    do
    {
        switch (*pszCurr)
        {
            case TEXT(' '):
                if (state == CS_CHAR)
                {
                    //
                    // We found a token                
                    //

                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    ppCmArgV[ndx] = pszToken;
                    ndx++;

                    pszCurr = pszToken = pszNext;
                    state = CS_END_SPACE;
                    continue;
                }
				else 
                {
                    if (state == CS_END_SPACE || state == CS_END_QUOTE)
				    {
					    pszToken = CharNext(pszToken);
				    }
                }
                
                break;

            case TEXT('\"'):
                if (state == CS_BEGIN_QUOTE)
                {
                    //
                    // We found a token
                    //
                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    //
                    // skip the opening quote
                    //
                    pszToken = CharNext(pszToken);
                    
                    ppCmArgV[ndx] = pszToken;
                    ndx++;
                    
                    pszCurr = pszToken = pszNext;
                    
                    state = CS_END_QUOTE;
                    continue;
                }
                else
                {
                    state = CS_BEGIN_QUOTE;
                }
                break;

            case TEXT('\0'):
                if (state != CS_END_QUOTE)
                {
                    //
                    // End of the line, set last token
                    //

                    ppCmArgV[ndx] = pszToken;
                }
                state = CS_DONE;
                break;

            default:
                if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    state = CS_CHAR;
                }
                break;
        }

        pszCurr = CharNext(pszCurr);
    } while (state != CS_DONE);

    return ppCmArgV;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdl\resource.h ===
//+----------------------------------------------------------------------------
//
// File:     resource.h
//
// Module:   CMDL32.EXE
//
// Synopsis: Resource IDs
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   created Header  08/16/99
//
//+----------------------------------------------------------------------------

#define IDD_MAIN            101
#define IDI_APP             102
//#define IDC_MAIN_HELP     1001
#define IDC_MAIN_PROGRESS   1002
#define IDC_MAIN_MESSAGE    1003

#define IDMSG_PERCENT_COMPLETE  1010
#define IDMSG_PBTITLE           1011

#ifdef EXTENDED_CAB_CONTENTS

#define IDMSG_REBOOT_TEXT       1012
#define IDMSG_REBOOT_CAPTION    1013    
#define IDMSG_PBTITLEMSG        1014

#endif // EXTENDED_CAB_CONTENTS

#define IDMSG_LOG_NO_UPDATE_REQUIRED    1015
#define IDMSG_LOG_FULL_UPDATE           1016
#define IDMSG_LOG_DELTA_UPDATE          1017


#define ICONNDWN_CLASS "IConnDwn Class"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdl\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//
// Module:   CMDL32.EXE
//
// Synopsis: Main source for PhoneBook download connect action
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   nickball    Created Header   04/08/98
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"
#include "shlobj.h"

const TCHAR* const c_pszIConnDwnMsg             =  TEXT("IConnDwn Message");                // for RegisterWindowMessage() for event messages
const TCHAR* const c_pszIConnDwnAgent           =  TEXT("Microsoft Connection Manager");    // agent for InternetOpen()
const TCHAR* const c_pszIConnDwnContent         =  TEXT("application/octet-stream");        // content type for HttpOpenRequest()

const TCHAR* const c_pszCmEntryHideDelay        = TEXT("HideDelay");
const TCHAR* const c_pszCmEntryDownloadDelay    = TEXT("DownLoadDelay");
const TCHAR* const c_pszCmEntryPbUpdateMessage  = TEXT("PBUpdateMessage");

#ifdef EXTENDED_CAB_CONTENTS

//
// SPECIAL NOTE:
//
// Be careful here. If you re-enable EXTENDED_CAB_CONTENTS, then you must 
// address the possibility that different instances might be doing updates 
// simultaneously in which case a common name such as "PBUPDATE.DIR" is not 
// appropriate. Because we do not implement this feature, we do not concern
// ourselves with it for the simple PBK case. Thus we copy the .PBK, .PBR, 
// etc. directly from the original tmp dir to the profile directory when 
// updating.
//

const TCHAR* const c_pszDirName     = TEXT("PBUPDATE.DIR");    // directory to expand .CAB into
const TCHAR* const c_pszInfInDir    = TEXT("PBUPDATE.DIR\\PBUPDATE.INF");
const TCHAR* const c_pszPbdInDir    = TEXT("PBUPDATE.DIR\\PBUPDATE.PBD");

static LPVOID MyAdvPackLoadAndLink(ArgsStruct *pArgs, LPCTSTR pszFunc) 
{
    LPVOID pvFunc;

    if (!pArgs->hAdvPack)
    {
        pArgs->hAdvPack = LoadLibrary(TEXT("advpack.dll"));
        if (!pArgs->hAdvPack)
        {
            MYDBG(("MyAdvPackLoadAndLink() LoadLibrary() failed, GLE=%u.",GetLastError()));
            return (NULL);
        }
    }
    pvFunc = GetProcAddress(pArgs->hAdvPack,pszFunc);
    MYDBGTST(!pvFunc,("MyAdvPackLoadAndLink() GetProcAddress(%s) failed, GLE=%u.",pszFunc,GetLastError()));
    return (pvFunc);
}

#define RSC_FLAG_INF    1

static HRESULT MyRunSetupCommand(ArgsStruct *pArgs,
                                 HWND hwndParent,
                                 LPCSTR pszCmdName,
                                 LPCSTR pszInfSection,
                                 LPCSTR pszDir,
                                 LPCSTR pszTitle,
                                 HANDLE *phExe,
                                 DWORD dwFlags,
                                 LPVOID pvRsvd) 
{

    HRESULT (WINAPI *pfn)(HWND,LPCSTR,LPCSTR,LPCSTR,LPCSTR,HANDLE,DWORD,LPVOID);

    pfn = (HRESULT (WINAPI *)(HWND,LPCSTR,LPCSTR,LPCSTR,LPCSTR,HANDLE,DWORD,LPVOID)) MyAdvPackLoadAndLink(pArgs,TEXT("RunSetupCommand"));
    if (!pfn) 
    {
        return (HRESULT_FROM_WIN32(GetLastError()));
    }
    return (pfn(hwndParent,pszCmdName,pszInfSection,pszDir,pszTitle,phExe,dwFlags,pvRsvd));
}

static DWORD MyNeedRebootInit(ArgsStruct *pArgs) 
{

    DWORD (WINAPI *pfn)(VOID);

    pfn = (DWORD (WINAPI *)(VOID)) MyAdvPackLoadAndLink(pArgs,TEXT("NeedRebootInit"));
    if (!pfn)
    {
        return (0);
    }
    return (pfn());
}

static BOOL MyNeedReboot(ArgsStruct *pArgs, DWORD dwCookie) 
{
    BOOL (WINAPI *pfn)(DWORD);

    pfn = (BOOL (WINAPI *)(DWORD)) MyAdvPackLoadAndLink(pArgs,TEXT("NeedReboot"));
    if (!pfn)
    {
        return (FALSE);
    }
    return (pfn(dwCookie));
}

#endif // EXTENDED_CAB_CONTENTS

//+----------------------------------------------------------------------------
//
// Function:  SuppressInetAutoDial
//
// Synopsis:  Sets Inet Option to turn off auto-dial for requests made by this
//            process. This prevents multiple instances of CM popping up to 
//            service CMDL initiated requests if the user disconnects CM 
//            immediately after getting connected.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball    Created Header    6/3/99
//
//+----------------------------------------------------------------------------
static void SuppressInetAutoDial(HINTERNET hInternet)
{
    DWORD dwTurnOff = 1;
        
    //
    // The flag only exists for IE5, this call 
    // will have no effect if IE5 is not present.
    //
    
    BOOL bTmp = InternetSetOption(hInternet, INTERNET_OPTION_DISABLE_AUTODIAL, &dwTurnOff, sizeof(DWORD));

    MYDBGTST(FALSE == bTmp, ("InternetSetOption() returned %d, GLE=%u.", bTmp, GetLastError()));
}


static BOOL CmFreeIndirect(LPVOID *ppvBuffer) 
{
    CmFree(*ppvBuffer);
    *ppvBuffer = NULL;
    return TRUE;
}

static BOOL CmFreeIndirect(LPTSTR *ppszBuffer) 
{
    return (CmFreeIndirect((LPVOID *) ppszBuffer));
}

static LPURL_COMPONENTS MyInternetCrackUrl(LPTSTR pszUrl, DWORD dwOptions) 
{
    struct _sRes 
    {
        URL_COMPONENTS sUrl;
        TCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
        TCHAR szHostName[INTERNET_MAX_HOST_NAME_LENGTH+1];
        TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH+1];
        TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH+1];
        TCHAR szUrlPath[INTERNET_MAX_PATH_LENGTH+1];
        TCHAR szExtraInfo[INTERNET_MAX_PATH_LENGTH+1];
    } *psRes;
    BOOL bRes;
    UINT nIdx;
    UINT nSpaces;

    if (!pszUrl) 
    {
        MYDBG(("MyInternetCrackUrl() invalid parameter."));
        SetLastError(ERROR_INVALID_PARAMETER);
        return (NULL);
    }
    psRes = (struct _sRes *) CmMalloc(sizeof(*psRes));
    if (!psRes) 
    {
        return (NULL);
    }
    psRes->sUrl.dwStructSize = sizeof(psRes->sUrl);
    psRes->sUrl.lpszScheme = psRes->szScheme;
    psRes->sUrl.dwSchemeLength = sizeof(psRes->szScheme);
    psRes->sUrl.lpszHostName = psRes->szHostName;
    psRes->sUrl.dwHostNameLength = sizeof(psRes->szHostName);
    psRes->sUrl.lpszUserName = psRes->szUserName;
    psRes->sUrl.dwUserNameLength = sizeof(psRes->szUserName);
    psRes->sUrl.lpszPassword = psRes->szPassword;
    psRes->sUrl.dwPasswordLength = sizeof(psRes->szPassword);
    psRes->sUrl.lpszUrlPath = psRes->szUrlPath;
    psRes->sUrl.dwUrlPathLength = sizeof(psRes->szUrlPath);
    psRes->sUrl.lpszExtraInfo = psRes->szExtraInfo;
    psRes->sUrl.dwExtraInfoLength = sizeof(psRes->szExtraInfo);
    bRes = InternetCrackUrl(pszUrl,0,dwOptions,&psRes->sUrl);
    if (!bRes) 
    {
        MYDBG(("MyInternetCrackUrl() InternetCrackUrl(pszUrl=%s) failed, GLE=%u.",pszUrl,GetLastError()));
        CmFree(psRes);
        return (NULL);
    }
    
    nSpaces = 0;
    
    for (nIdx=0;psRes->szExtraInfo[nIdx];nIdx++) 
    {
        if (psRes->szExtraInfo[nIdx] == ' ') 
        {
            nSpaces++;
        }
    }
    
    if (nSpaces) 
    {
        TCHAR szQuoted[sizeof(psRes->szExtraInfo)/sizeof(TCHAR)];

        if (lstrlen(psRes->szExtraInfo)+nSpaces*2 > sizeof(psRes->szExtraInfo)/sizeof(TCHAR)-1) 
        {
            MYDBG(("MyInternetCrackUrl() quoting spaces will exceed buffer size."));
            CmFree(psRes);
            return (NULL);
        }
        
        ZeroMemory(szQuoted,sizeof(szQuoted));
        nSpaces = 0;
        
        for (nIdx=0,nSpaces=0;psRes->szExtraInfo[nIdx];nIdx++,nSpaces++) 
        {
            if (psRes->szExtraInfo[nIdx] == ' ') 
            {
                szQuoted[nSpaces++] = '%';
                szQuoted[nSpaces++] = '2';
                szQuoted[nSpaces] = '0';
            } 
            else 
            {
                szQuoted[nSpaces] = psRes->szExtraInfo[nIdx];
            }
        }
        lstrcpy(psRes->szExtraInfo,szQuoted);
    }
    return (&psRes->sUrl);
}

static BOOL DownloadFileFtp(DownloadArgs *pdaArgs, HANDLE hFile) 
{
    BOOL bRes = FALSE;

    WIN32_FIND_DATA wfdData;
    LPBYTE pbData = NULL;

    LPTSTR pszObject = (LPTSTR) CmMalloc((INTERNET_MAX_PATH_LENGTH*2) + 1);

    if (NULL == pszObject)
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;   
    }

    pdaArgs->hInet = InternetOpen(c_pszIConnDwnAgent,INTERNET_OPEN_TYPE_PRECONFIG,NULL,NULL,0);
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hInet) 
    {
        MYDBG(("DownloadFileFtp() InternetOpen() failed, GLE=%u.",GetLastError()));
        goto done;
    }
    pdaArgs->hConn = InternetConnect(pdaArgs->hInet,
                                     pdaArgs->psUrl->lpszHostName,
                                     pdaArgs->psUrl->nPort,
                                     pdaArgs->psUrl->lpszUserName&&*pdaArgs->psUrl->lpszUserName?pdaArgs->psUrl->lpszUserName:NULL,
                                     pdaArgs->psUrl->lpszPassword&&*pdaArgs->psUrl->lpszPassword?pdaArgs->psUrl->lpszPassword:NULL,
                                     INTERNET_SERVICE_FTP,
                                     0,
                                     0);
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hConn) 
    {
        MYDBG(("DownloadFileFtp() InternetConnect(pszHostName=%s) failed, GLE=%u.",pdaArgs->psUrl->lpszHostName,GetLastError()));
        goto done;
    }
    
    lstrcpy(pszObject,pdaArgs->psUrl->lpszUrlPath);
//      lstrcat(pszObject,pdaArgs->psUrl->lpszExtraInfo);
    ZeroMemory(&wfdData,sizeof(wfdData));
    pdaArgs->hReq = FtpFindFirstFile(pdaArgs->hConn,pszObject,&wfdData,INTERNET_FLAG_RELOAD|INTERNET_FLAG_DONT_CACHE,0);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hReq) 
    {
        MYDBG(("DownloadFileFtp() FtpFindFirstFile() failed, GLE=%u.",GetLastError()));
        goto done;
    }
    
    bRes = InternetFindNextFile(pdaArgs->hReq,&wfdData);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    if (bRes || (GetLastError() != ERROR_NO_MORE_FILES)) 
    {
        MYDBG(("DownloadFileFtp() InternetFindNextFile() returned unexpected result, bRes=%u, GetLastError()=%u.",bRes,bRes?0:GetLastError()));
        bRes = FALSE;
        goto done;
    }
    
    InternetCloseHandle(pdaArgs->hReq);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    pdaArgs->dwTotalSize = wfdData.nFileSizeLow;
    pdaArgs->hReq = FtpOpenFile(pdaArgs->hConn,pszObject,GENERIC_READ,FTP_TRANSFER_TYPE_BINARY,0);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFtp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hReq) 
    {
        MYDBG(("DownloadFileFtp() FtpOpenFile() failed, GLE=%u.",GetLastError()));
        goto done;
    }
    
    pbData = (LPBYTE) CmMalloc(BUFFER_LENGTH);
    
    if (!pbData) 
    {
        goto done;
    }
    
    while (1) 
    {
        DWORD dwBytesRead;
        DWORD dwBytesWritten;

        bRes = InternetReadFile(pdaArgs->hReq,pbData,BUFFER_LENGTH,&dwBytesRead);
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFtp() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            MYDBG(("DownloadFileFtp() InternetReadFile() failed, GLE=%u.",GetLastError()));
            goto done;
        }
        
        if (!dwBytesRead) 
        {
            break;
        }
        
        bRes = WriteFile(hFile,pbData,dwBytesRead,&dwBytesWritten,NULL);
    
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFtp() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            MYDBG(("DownloadFileFtp() WriteFile() failed, GLE=%u.",GetLastError()));
            goto done;
        }
        
        if (dwBytesRead != dwBytesWritten) 
        {
            MYDBG(("DownloadFileFtp() dwBytesRead=%u, dwBytesWritten=%u.",dwBytesRead,dwBytesWritten));
            SetLastError(ERROR_DISK_FULL);
            goto done;
        }
        
        pdaArgs->dwTransferred += dwBytesRead;
        
        if (pdaArgs->pfnEvent) 
        {
            pdaArgs->pfnEvent(pdaArgs->dwTransferred,pdaArgs->dwTotalSize,pdaArgs->pvEventParam);
        }
        
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFtp() aborted."));
            goto done;
        }
    }
    
    bRes = TRUE;

done:
    
    if (pbData) 
    {
        CmFree(pbData);
    }
    
    if (pdaArgs->hReq) 
    {
        InternetCloseHandle(pdaArgs->hReq);
        pdaArgs->hReq = NULL;
    }
    
    if (pdaArgs->hConn) 
    {
        InternetCloseHandle(pdaArgs->hConn);
        pdaArgs->hConn = NULL;
    }
    
    if (pdaArgs->hInet) 
    {
        InternetCloseHandle(pdaArgs->hInet);
        pdaArgs->hInet = NULL;
    }

    if (pszObject)
    {
        CmFree(pszObject);
    }

    return (bRes);
}

static BOOL DownloadFileFile(DownloadArgs *pdaArgs, HANDLE hFile) 
{
    BOOL bRes = FALSE;

    HANDLE hInFile = INVALID_HANDLE_VALUE;
    LPBYTE pbData = NULL;

    hInFile = CreateFile(pdaArgs->psUrl->lpszUrlPath,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFile() aborted."));
        goto done;
    }
    
    if (hInFile == INVALID_HANDLE_VALUE) 
    {
        MYDBG(("DownloadFileFile() CreateFile(pszFile=%s) failed, GLE=%u.",pdaArgs->psUrl->lpszUrlPath,GetLastError()));
        goto done;
    }
    
    pdaArgs->dwTotalSize = GetFileSize(hInFile,NULL);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileFile() aborted."));
        goto done;
    }
    
    if (pdaArgs->dwTotalSize == -1) 
    {
        MYDBG(("DownloadFileFile() GetFileSize() failed, GLE=%u.",GetLastError()));
        goto done;
    }
    
    pbData = (LPBYTE) CmMalloc(BUFFER_LENGTH);
    
    if (!pbData) 
    {
        goto done;
    }
    
    while (1) 
    {
        DWORD dwBytesRead;
        DWORD dwBytesWritten;

        bRes = ReadFile(hInFile,pbData,BUFFER_LENGTH,&dwBytesRead,NULL);
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFile() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            MYDBG(("DownloadFileFile() ReadFile() failed, GLE=%u.",GetLastError()));
            goto done;
        }
        
        if (!dwBytesRead) 
        {
            break;
        }
        
        bRes = WriteFile(hFile,pbData,dwBytesRead,&dwBytesWritten,NULL);
        
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFile() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            MYDBG(("DownloadFileFile() WriteFile() failed, GLE=%u.",GetLastError()));
            goto done;
        }
        
        if (dwBytesRead != dwBytesWritten) 
        {
            MYDBG(("DownloadFileFile() dwBytesRead=%u, dwBytesWritten=%u.",dwBytesRead,dwBytesWritten));
            SetLastError(ERROR_DISK_FULL);
            goto done;
        }
        
        pdaArgs->dwTransferred += dwBytesWritten;
        
        if (pdaArgs->pfnEvent) 
        {
            pdaArgs->pfnEvent(pdaArgs->dwTransferred,pdaArgs->dwTotalSize,pdaArgs->pvEventParam);
        }
        
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileFile() aborted."));
            goto done;
        }
    }
    bRes = TRUE;

done:

    if (pbData) 
    {
        CmFree(pbData);
    }
    
    if (hInFile != INVALID_HANDLE_VALUE) 
    {
        CloseHandle(hInFile);
    }

    return (bRes);
}

static BOOL DownloadFileHttp(DownloadArgs *pdaArgs, HANDLE hFile) 
{
    BOOL bRes = FALSE;
    LPBYTE pbData = NULL;
    DWORD dwTmpLen;
    DWORD dwTmpIdx;
    DWORD dwStatus;
    LPCTSTR apszContent[] = {c_pszIConnDwnContent,NULL};

    LPTSTR pszObject = (LPTSTR) CmMalloc(INTERNET_MAX_PATH_LENGTH + 1);

    if (NULL == pszObject)
    {
        MYDBG(("DownloadFileHttp() aborted."));
        goto done;   
    }

    pdaArgs->dwBubbledUpError = 0;

    pdaArgs->hInet = InternetOpen(c_pszIConnDwnAgent,INTERNET_OPEN_TYPE_PRECONFIG,NULL,NULL,0);

    //
    // Supress auto-dial calls to CM from WININET now that we have a handle
    //

    SuppressInetAutoDial(pdaArgs->hInet);

    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileHttp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hInet) 
    {
        pdaArgs->dwBubbledUpError = GetLastError();
        MYDBG(("DownloadFileHttp() InternetOpen() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
        goto done;
    }
    
    pdaArgs->hConn = InternetConnect(pdaArgs->hInet,
                                     pdaArgs->psUrl->lpszHostName,
                                     pdaArgs->psUrl->nPort,
                                     pdaArgs->psUrl->lpszUserName&&*pdaArgs->psUrl->lpszUserName?pdaArgs->psUrl->lpszUserName:NULL,
                                     pdaArgs->psUrl->lpszPassword&&*pdaArgs->psUrl->lpszPassword?pdaArgs->psUrl->lpszPassword:NULL,
                                     INTERNET_SERVICE_HTTP,
                                     0,
                                     0);
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileHttp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hConn) 
    {
        pdaArgs->dwBubbledUpError = GetLastError();
        MYDBG(("DownloadFileHttp() InternetConnect(pszHostName=%s) failed, GLE=%u.", pdaArgs->psUrl->lpszHostName, pdaArgs->dwBubbledUpError));
        goto done;
    }
    
    lstrcpy(pszObject,pdaArgs->psUrl->lpszUrlPath);
    lstrcat(pszObject,pdaArgs->psUrl->lpszExtraInfo);
    
    MYDBG(("DownloadFileHttp() - HttpOpenRequest - %s", pszObject));

    pdaArgs->hReq = HttpOpenRequest(pdaArgs->hConn,
                                    NULL,
                                    pszObject,
                                    NULL,
                                    NULL,
                                    apszContent,
                                    INTERNET_FLAG_RELOAD|INTERNET_FLAG_DONT_CACHE|(pdaArgs->psUrl->nScheme==INTERNET_SCHEME_HTTPS?INTERNET_FLAG_SECURE:0),
                                    0);
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileHttp() aborted."));
        goto done;
    }
    
    if (!pdaArgs->hReq) 
    {
        pdaArgs->dwBubbledUpError = GetLastError();
        MYDBG(("DownloadFileHttp() HttpOpenRequest() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
        goto done;
    }
    
    bRes = HttpSendRequest(pdaArgs->hReq,NULL,0,NULL,0);
    
    if (*(pdaArgs->pbAbort)) 
    {
        MYDBG(("DownloadFileHttp() aborted."));
        goto done;
    }
    
    if (!bRes) 
    {
        pdaArgs->dwBubbledUpError = GetLastError();
        MYDBG(("DownloadFileHttp() HttpSendRequest() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
        goto done;
    }

    pbData = (LPBYTE) CmMalloc(BUFFER_LENGTH);
    
    if (!pbData) 
    {
        goto done;
    }
    
    while (1) 
    {
        DWORD dwBytesRead;
        DWORD dwBytesWritten;

        bRes = InternetReadFile(pdaArgs->hReq,pbData,BUFFER_LENGTH,&dwBytesRead);
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileHttp() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            pdaArgs->dwBubbledUpError = GetLastError();
            MYDBG(("DownloadFileHttp() InternetReadFile() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
            goto done;
        }
        
        if (!dwBytesRead) 
        {
            break;
        }
        
        bRes = WriteFile(hFile,pbData,dwBytesRead,&dwBytesWritten,NULL);
        
        if (*(pdaArgs->pbAbort)) 
        {
            MYDBG(("DownloadFileHttp() aborted."));
            goto done;
        }
        
        if (!bRes) 
        {
            pdaArgs->dwBubbledUpError = GetLastError();
            MYDBG(("DownloadFileHttp() WriteFile() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
            goto done;
        }
        
        if (dwBytesRead != dwBytesWritten) 
        {
            MYDBG(("DownloadFileHttp() dwBytesRead=%u, dwBytesWritten=%u.",dwBytesRead,dwBytesWritten));
            SetLastError(ERROR_DISK_FULL);
            goto done;
        }
        
        if (!pdaArgs->dwTransferred) 
        {
            dwTmpLen = sizeof(pdaArgs->dwTotalSize);
            dwTmpIdx = 0;
            bRes = HttpQueryInfo(pdaArgs->hReq,HTTP_QUERY_FLAG_NUMBER|HTTP_QUERY_CONTENT_LENGTH,&pdaArgs->dwTotalSize,&dwTmpLen,&dwTmpIdx);
            if (*(pdaArgs->pbAbort)) 
            {
                MYDBG(("DownloadFileHttp() aborted."));
                goto done;
            }
            MYDBGTST(!bRes,("DownloadFileHttp() HttpQueryInfo() failed, GLE=%u.",GetLastError()));
            if (!bRes)
            {
                pdaArgs->dwBubbledUpError = GetLastError();
            }
        }
        
        pdaArgs->dwTransferred += dwBytesRead;
        
        if (pdaArgs->pfnEvent) 
        {
            pdaArgs->pfnEvent(pdaArgs->dwTransferred,pdaArgs->dwTotalSize,pdaArgs->pvEventParam);
        }
        if (*(pdaArgs->pbAbort))
        {
            MYDBG(("DownloadFileHttp() aborted."));
            goto done;
        }
    }
    
    dwTmpLen = sizeof(dwStatus);
    dwTmpIdx = 0;
    
    bRes = HttpQueryInfo(pdaArgs->hReq,HTTP_QUERY_FLAG_NUMBER|HTTP_QUERY_STATUS_CODE,&dwStatus,&dwTmpLen,&dwTmpIdx);

    if (!bRes) 
    {
        pdaArgs->dwBubbledUpError = GetLastError();
        MYDBG(("DownloadFileHttp() HttpQueryInfo() failed, GLE=%u.", pdaArgs->dwBubbledUpError));
        goto done;
    }

    switch (dwStatus) 
    {
        case HTTP_STATUS_OK:
            break;

        case HTTP_STATUS_NO_CONTENT:
        case HTTP_STATUS_BAD_REQUEST:
        case HTTP_STATUS_NOT_FOUND:
        case HTTP_STATUS_SERVER_ERROR:
        default:
            pdaArgs->dwBubbledUpError = dwStatus;
            MYDBG(("DownloadFileHttp() HTTP status code = %u.",dwStatus));
            bRes = FALSE;
            SetLastError(ERROR_FILE_NOT_FOUND);
            goto done;
    }
    bRes = TRUE;

done:

    if ((0 == pdaArgs->dwBubbledUpError) && !*(pdaArgs->pbAbort))
    {
        //
        //  If the error value hasn't been set yet, and isn't the Abort case (which
        //  is logged separately) try to get it from GetLastError().
        //
        pdaArgs->dwBubbledUpError = GetLastError();
    }

    if (pbData) 
    {
        CmFree(pbData);
    }
    
    if (pdaArgs->hReq) 
    {
        InternetCloseHandle(pdaArgs->hReq);
        pdaArgs->hReq = NULL;
    }
    
    if (pdaArgs->hConn) 
    {
        InternetCloseHandle(pdaArgs->hConn);
        pdaArgs->hConn = NULL;
    }
    
    if (pdaArgs->hInet) 
    {
        InternetCloseHandle(pdaArgs->hInet);
        pdaArgs->hInet = NULL;
    }
    
    if (bRes && (pdaArgs->dwTransferred > pdaArgs->dwTotalSize)) 
    {
        pdaArgs->dwTotalSize = pdaArgs->dwTransferred;
    }

    if (pszObject)
    {
        CmFree(pszObject);
    }
    
    return (bRes);
}

static BOOL DownloadFile(DownloadArgs *pdaArgs, HANDLE hFile) 
{
    BOOL bRes = FALSE;

    pdaArgs->psUrl = MyInternetCrackUrl((LPTSTR) pdaArgs->pszUrl,ICU_ESCAPE);
    if (!pdaArgs->psUrl) 
    {
        return (NULL);
    }
    
    switch (pdaArgs->psUrl->nScheme) 
    {
        case INTERNET_SCHEME_FTP:
            bRes = DownloadFileFtp(pdaArgs,hFile);
            break;

        case INTERNET_SCHEME_HTTP:
        case INTERNET_SCHEME_HTTPS:
            bRes = DownloadFileHttp(pdaArgs,hFile);
            break;

        case INTERNET_SCHEME_FILE:
            bRes = DownloadFileFile(pdaArgs,hFile);
            break;

        default:
            MYDBG(("DownloadFile() unhandled scheme (%u).",pdaArgs->psUrl->nScheme));
            SetLastError(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
            break;
    }

    // useful for logging
    lstrcpyn(pdaArgs->szHostName, pdaArgs->psUrl->lpszHostName, MAX_PATH);

    CmFree(pdaArgs->psUrl);
    pdaArgs->psUrl = NULL;
    return (bRes);
}

typedef struct _EventParam 
{
    ArgsStruct *pArgs;
    DWORD dwIdx;
} EventParam;

static void EventFunc(DWORD dwCompleted, DWORD dwTotal, LPVOID pvParam) 
{
    EventParam *pepParam = (EventParam *) pvParam;

    MYDBG(("EventFunc() dwCompleted=%u, dwTotal=%u.",dwCompleted,dwTotal));
    pepParam->pArgs->dwDataCompleted = dwCompleted;
    pepParam->pArgs->dwDataTotal = dwTotal;
    PostMessage(pepParam->pArgs->hwndDlg,pepParam->pArgs->nMsgId,etDataReceived,0);
}

static BOOL ProcessCabinet(DownloadArgs *pdaArgs, DWORD dwAppFlags) 
{
    BOOL    fRet = TRUE;

    if (!pdaArgs->bTransferOk) 
        return (TRUE); // If the transfer failed, just leave the install type as itInvalid.
    
    {
        HFDI hfdi;
        ERF erf;
        FDICABINETINFO info;
        BOOL bRes;
        NotifyArgs naArgs = {dwAppFlags,pdaArgs};
        
        bRes = CreateTempDir(pdaArgs->szCabDir);
    
        if (bRes) 
        {
            hfdi = FDICreate(fdi_alloc,fdi_free,fdi_open,fdi_read,fdi_write,fdi_close,fdi_seek,cpu80386,&erf);
            MYDBGTST(!hfdi,("ProcessCabinet() FDICreate() failed, fError=%u, erfOper=%u, erfType=%u.",erf.fError,erf.fError?erf.erfOper:0,erf.fError?erf.erfType:0));
            if (hfdi) 
            {
                // Open the suspected cab file 
                
                CFDIFileFile fff;
                
                bRes = fff.CreateFile(pdaArgs->szFile,GENERIC_READ,FILE_SHARE_READ,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
                if (bRes) 
                {
                    // Verify that this is in fact a cabinet file
                    bRes = FDIIsCabinet(hfdi,(INT_PTR) &fff, &info);
                    MYDBGTST(!bRes,("ProcessCabinet() FDIIsCabinet() failed, fError=%u, erfOper=%u, erfType=%u.",erf.fError,erf.fError?erf.erfOper:0,erf.fError?erf.erfType:0));
                    fff.Close();
                    if (bRes) 
                    {
                        // Do the FDI copy

                        bRes = FDICopy(hfdi,pdaArgs->szFile,TEXT(""),0,(PFNFDINOTIFY)fdi_notify,NULL,&naArgs);
                        if (!bRes) 
                        {
                            MYDBG(("ProcessCabinet() FDICopy() failed, fError=%u, erfOper=%u, erfType=%u.",erf.fError,erf.fError?erf.erfOper:0,erf.fError?erf.erfType:0));
                            //pdaArgs->itType = itInvalid;
                        }
                    }
#ifdef EXTENDED_CAB_CONTENTS
                    else
                    {                                                                       
                        // Not a Cab file, assume exe
                        if (OS_NT) 
                        {
                            BOOL bExe = FALSE;
                            DWORD dwExe = 0;

                            // GetBinaryType() is not supported under Win95.
                            bExe = GetBinaryType(pdaArgs->szFile,&dwExe);       
                            MYDBG(("ProcessCabinet() GetBinaryType() return %u, dwExe=%u.",bExe,dwExe));
                        
                            if (!(bExe && ((dwExe & SCS_32BIT_BINARY) || (dwExe & SCS_DOS_BINARY)))) 
                            {
                                fRet = FALSE;
                                // if it's not either a win32 or dos exe, then just cleanup and abort
                                goto destroy_fdi;
                            }
                        }

                        MYDBGASSERT(!pdaArgs->rgfpiFileProcessInfo && !pdaArgs->dwNumFilesToProcess);
                    
                        pdaArgs->rgfpiFileProcessInfo = (PFILEPROCESSINFO)CmMalloc(sizeof(FILEPROCESSINFO));
                        if (!pdaArgs->rgfpiFileProcessInfo) 
                        {
                            MYDBG((TEXT("ProcessCabinet: Malloc() failed.")));
                            fRet = FALSE;
                            goto destroy_fdi;
                        }
                        pdaArgs->dwNumFilesToProcess++;
                        pdaArgs->rgfpiFileProcessInfo[0].itType = itExe;
                        pdaArgs->rgfpiFileProcessInfo[0].pszFile = CmStrCpyAlloc(pdaArgs->szFile);

                        pdaArgs->szCabDir[0] = TEXT('\0');
                        // pdaArgs->itType = itExe; 
                    }
destroy_fdi:            

#endif // EXTENDED_CAB_CONTENTS
                }

                // Destroy the FDI context
                
                bRes = FDIDestroy(hfdi);
                MYDBGTST(!bRes,("ProcessCabinet() FDIDestroy() failed."));
            }
        }
    }
    
    return fRet;
}

//
// Recursively deletes the contents of a directory(pszDir).  Changes the file 
// attributes from RO to RW if necessary.
//
static BOOL ZapDir(LPCTSTR pszDir) 
{
    HANDLE hFind = NULL;
    TCHAR szTmp[MAX_PATH+1];
    BOOL bRes;

    // If pszDir format is not appropriate, bail out

    if (!pszDir || !*pszDir || (lstrlen(pszDir)+2 > sizeof(szTmp)/sizeof(TCHAR)-1)) 
    {
        SetLastError(ERROR_BAD_PATHNAME);
        return (FALSE);
    }
    
    lstrcpy(szTmp,pszDir);

    if (GetLastChar(szTmp) != '\\') 
    {
        lstrcat(szTmp,TEXT("\\"));
    }
    
    lstrcat(szTmp,TEXT("*"));

    // Traverse directory

    WIN32_FIND_DATA wfdData;
    hFind = FindFirstFile(szTmp,&wfdData);
    MYDBGTST((hFind==INVALID_HANDLE_VALUE)&&(GetLastError()!=ERROR_FILE_NOT_FOUND)&&(GetLastError()!=ERROR_NO_MORE_FILES)&&(GetLastError()!=ERROR_PATH_NOT_FOUND),("ZapDir() FindFirstFile() failed, GLE=%u.",GetLastError()));

    if (hFind != INVALID_HANDLE_VALUE) 
    {
        while (1) 
        {
            MYDBGTST(lstrlen(pszDir)+lstrlen(wfdData.cFileName)+1 > sizeof(szTmp)/sizeof(TCHAR)-1,("ZapDir() pszDir=%s+cFileName=%s exceeds %u.",pszDir,wfdData.cFileName,sizeof(szTmp)/sizeof(TCHAR)-1));
            if (lstrlen(pszDir)+lstrlen(wfdData.cFileName)+1 <= sizeof(szTmp)/sizeof(TCHAR)-1) 
            {
                if ((lstrcmp(wfdData.cFileName,TEXT(".")) != 0) && (lstrcmp(wfdData.cFileName,TEXT("..")) != 0)) 
                {
                    lstrcpy(szTmp,pszDir);
                    if (GetLastChar(szTmp) != '\\') 
                    {
                        lstrcat(szTmp,TEXT("\\"));
                    }
                
                    lstrcat(szTmp,wfdData.cFileName);
    
                    // If the file is read-only, attrib writeable so we can delete it

                    if (wfdData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) 
                    {
                        bRes = SetFileAttributes(szTmp,wfdData.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY);
                        MYDBGTST(!bRes,("ZapDir() SetFileAttributes(szTmp=%s) failed, GLE=%u.",szTmp,GetLastError()));
                    }

                    // Found a dir entry, recurse down a level

                    if (wfdData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        ZapDir(szTmp);
                    } 
                    else 
                    {
                        bRes = DeleteFile(szTmp);
                        MYDBGTST(!bRes,("ZapDir() DeleteFile(szTmp=%s) failed, GLE=%u.",szTmp,GetLastError()));
                    }
                }
            }
            
            // Go to next file

            bRes = FindNextFile(hFind,&wfdData);
            if (!bRes) 
            {
                MYDBGTST((GetLastError()!=ERROR_FILE_NOT_FOUND)&&(GetLastError()!=ERROR_NO_MORE_FILES),("ZapDir() FindNextFile() failed, GLE=%u.",GetLastError()));
                break;
            }
        }
        
        bRes = FindClose(hFind);
        MYDBGTST(!bRes,("ZapDir() FindClose() failed, GLE=%u.",GetLastError()));
    }

    // Now that the files have been removed, delete the directory
    
    bRes = RemoveDirectory(pszDir);
    MYDBGTST(!bRes&&(GetLastError()!=ERROR_PATH_NOT_FOUND),("ZapDir() RemoveDirectory(pszDir=%s) failed, GLE=%u.",pszDir,GetLastError()));
    return (bRes);
}

#ifdef EXTENDED_CAB_CONTENTS

static long MyMsgWaitDlg(HWND hwndMsg, DWORD dwHandles, HANDLE *phHandles, DWORD dwTimeout) 
{
    long lRes;

    if (hwndMsg) 
    {
        HCURSOR hPrev;
        MSG msg;

        hPrev = SetCursor(LoadCursor(NULL,IDC_WAIT));
        ShowCursor(TRUE);
        while (1) 
        {
            lRes = MsgWaitForMultipleObjects(dwHandles,phHandles,FALSE,dwTimeout,QS_ALLINPUT);
            if (lRes == WAIT_TIMEOUT) 
            {
                break;
            }
            if (lRes != (long) (WAIT_OBJECT_0+dwHandles)) 
            {
                MYDBGTST(-1 == lRes,("MyMsgWaitDlg() MsgWaitForMultipleObjects() failed, GLE=%u.",GetLastError()));
                break;
            }
            PeekMessage(&msg,hwndMsg,0,0,PM_NOREMOVE);
        }
        ShowCursor(FALSE);
        SetCursor(hPrev);
    } 
    else 
    {
        lRes = WaitForMultipleObjects(dwHandles,phHandles,FALSE,dwTimeout);
    }
    return (lRes);
}

#endif // EXTENDED_CAB_CONTENTS

//
// Executes installation of phone book update based upon download file
//

static BOOL DoInstall(ArgsStruct *pArgs, HWND hwndParent, DWORD dwAppFlags) 
{
    DWORD dwIdx;

    // If no install, we are done

    if (dwAppFlags & AF_NO_INSTALL) 
    {
        return (TRUE);
    }
    
    // For each arg, handle installation

    for (dwIdx=0;dwIdx<pArgs->dwArgsCnt;dwIdx++) 
    {
        DownloadArgs *pdaArgs;
        UINT    i;
        BOOL bInstallOk = FALSE;
        BOOL bRes = TRUE;

        pdaArgs = pArgs->pdaArgs + dwIdx;

        pdaArgs->dwBubbledUpError = 0;

#ifdef EXTENDED_CAB_CONTENTS

        BOOL fCabDirRenamed = FALSE;

        // rename the dir the downloaded file is not an EXE
        if (pdaArgs->szCabDir[0]) 
        {
            ZapDir(c_pszDirName);
            bRes = MoveFile(pdaArgs->szCabDir,c_pszDirName);
            MYDBGTST(!bRes,("DoInstall() MoveFile(szCabDir=%s,c_pszDirName) failed, GLE=%u.",pdaArgs->szCabDir,GetLastError()));
            if (bRes)
            {
                fCabDirRenamed = TRUE;
            }
        }

#endif // EXTENDED_CAB_CONTENTS
        
        // Only perform if the rename worked.

        if (bRes) 
        {       
            for (i=0; i<pdaArgs->dwNumFilesToProcess; i++) 
            {
                //
                // Reset install flag for each file that is processed, 
                // otherwise a single success will cause us to interpret
                // the entire install as successful. #5887
                //
                
                bInstallOk = FALSE; 

                switch (pdaArgs->rgfpiFileProcessInfo[i].itType) 
                {

#ifdef EXTENDED_CAB_CONTENTS

                    case itExeInCab:
                    case itExe:
                    {
                        STARTUPINFO siInfo;
                        PROCESS_INFORMATION piInfo;
        
                        ZeroMemory(&siInfo,sizeof(siInfo));
                        ZeroMemory(&piInfo,sizeof(piInfo));
                        siInfo.cb = sizeof(siInfo);
                        
                        bRes = CreateProcess(pdaArgs->rgfpiFileProcessInfo[i].pszFile,
                             NULL,NULL,NULL,FALSE,0,NULL,NULL,&siInfo,&piInfo);
                        MYDBGTST(!bRes,("DoInstall() CreateProcess(pszExe=%s) failed, GLE=%u.",pdaArgs->rgfpiFileProcessInfo[i].pszFile,GetLastError()));
                        
                        // If CreateProcess worked, wait for process to terminate before continuing
                        
                        if (bRes) 
                        {
                            CloseHandle(piInfo.hThread);
                            MyMsgWaitDlg(hwndParent,1,&piInfo.hProcess,INFINITE);
                            CloseHandle(piInfo.hProcess);
                            bInstallOk = TRUE;
                        }
                        break;
                    }
                    
                    case itInfInCab: // .INF file
                    {
                        TCHAR szCabDir[MAX_PATH+1];
                        DWORD dwRes;
                        HRESULT hRes;

                        ZeroMemory(szCabDir,sizeof(szCabDir));
                        dwRes = GetCurrentDirectory(sizeof(szCabDir)/sizeof(TCHAR)-1,szCabDir);
                        MYDBGTST(!dwRes,("DoInstall() GetCurrentDirectory() failed, GLE=%u.",GetLastError()));
            
                        if (GetLastChar(szCabDir) != '\\') 
                        {
                            lstrcat(szCabDir,TEXT("\\"));
                        }
                        lstrcat(szCabDir,c_pszDirName); 
                        
                        // Since RunSetupCommand() has problems with long file names, we'll
                        // convert the path just to be sure.
                        
                        dwRes = GetShortPathName(szCabDir,szCabDir,sizeof(szCabDir)/sizeof(TCHAR)-1);
                        MYDBGTST(!dwRes,("DoInstall() GetShortPathName() failed, GLE=%u.",GetLastError()));

                        // TBD: Initialize pArgs->szInstallTitle from service file instead of from resource.

                        LPTSTR pszTmp = CmFmtMsg(pArgs->hInst,IDMSG_PBTITLE);
                        lstrcpy(pArgs->szInstallTitle,pszTmp);
                        CmFree(pszTmp);

                        hRes = MyRunSetupCommand(pArgs,
                                                 hwndParent,
                                                 c_pszInfInDir,
                                                 NULL,
                                                 szCabDir,
                                                 pArgs->szInstallTitle,
                                                 NULL,
                                                 RSC_FLAG_INF,
                                                 NULL);

                        if (!HRESULT_SEVERITY(hRes)) 
                        {
                            bInstallOk = TRUE;
                        }

                        break;

                    }

#endif // EXTENDED_CAB_CONTENTS

                    case itPbdInCab: // Delta phonebook file

                        // if the CAB contains an EXE or an INF, then we don't do PBD
                        if (pdaArgs->fContainsExeOrInf)
                        {
                            continue;
                        }

                        if (pdaArgs->pszCMSFile) 
                        {
                            HRESULT hRes;
                            DWORD_PTR dwPb;
                    
                            // Update the Phonebook using API calls

                            hRes = PhoneBookLoad(pdaArgs->pszCMSFile, &dwPb);

                            MYDBGTST(hRes!=ERROR_SUCCESS,("DoInstall() PhoneBookLoad(pszCMSFile=%s) failed, GLE=%u.", pdaArgs->pszCMSFile, hRes));
                            
                            if (hRes == ERROR_SUCCESS) 
                            {

#ifdef EXTENDED_CAB_CONTENTS
                                hRes = PhoneBookMergeChanges(dwPb, c_pszPbdInDir);
#else
                                // 
                                // Build path to delta file, to be passed to phonebook merge
                                //

                                TCHAR szPbd[MAX_PATH+1];
                                lstrcpy(szPbd, pdaArgs->szCabDir);
                                lstrcat(szPbd, TEXT("\\"));
                                lstrcat(szPbd, c_pszPbdFile);

                                hRes = PhoneBookMergeChanges(dwPb, szPbd);
#endif // EXTENDED_CAB_CONTENTS
                                MYDBGTST(hRes!=ERROR_SUCCESS,("DoInstall() PhoneBookMergeChanges() failed, GLE=%u.",hRes));
                                if (hRes == ERROR_SUCCESS) 
                                {
                                    bInstallOk = TRUE;
                                }
                                else
                                {
                                    pdaArgs->dwBubbledUpError = hRes;
                                }
                                
                                hRes = PhoneBookUnload(dwPb);
                                MYDBGTST(hRes!=ERROR_SUCCESS,("DoInstall() PhoneBookUnload() failed, GLE=%u.",hRes));
                            }
                            
                            if (!bInstallOk && !(dwAppFlags & AF_NO_VER)) 
                            {
                                // We currently zap the version string on any failure.  This should cause
                                // the phone book to get completely update the next time around.
                            
                                WritePrivateProfileString(c_pszCmSection,
                                                          c_pszVersion,
                                                          TEXT(""),
                                                          pdaArgs->pszCMSFile);
                            }
                        }
                        break;

                    case itPbkInCab: // Phone book file
                    {
                        TCHAR szPbk[MAX_PATH+1];
                        
                        // if the CAB contains an EXE or an INF, then we don't do PBK
                        if (pdaArgs->fContainsExeOrInf)
                        {
                            continue;
                        }

#ifdef EXTENDED_CAB_CONTENTS

                        lstrcpy(szPbk, c_pszDirName);

#else // EXTENDED_CAB_CONTENTS                       

                        lstrcpy(szPbk, pdaArgs->szCabDir);

#endif
                        lstrcat(szPbk, TEXT("\\"));
                        lstrcat(szPbk, pdaArgs->rgfpiFileProcessInfo[i].pszFile);
            
                        // Try to copy the phonebook file directly

                        if (!CopyFile(szPbk, pdaArgs->pszPbkFile, FALSE))
                        {
                            pdaArgs->dwBubbledUpError = GetLastError();
                            MYDBG((TEXT("DoInstall() itPbkInCab, CopyFile() failed, GLE=%u."), pdaArgs->dwBubbledUpError));
                        }
                        else
                        {
                            bInstallOk = TRUE;
                        }
                        break;
                    }
                    
                    case itPbrInCab: // Region file
                    {
                        TCHAR szPbr[MAX_PATH+1];
                    
                        // if the CAB contains an EXE or an INF, then we don't do PBD
                        if (pdaArgs->fContainsExeOrInf)
                        {
                            continue;
                        }
                                    
#ifdef EXTENDED_CAB_CONTENTS 

                        lstrcpy(szPbr, c_pszDirName);

#else // EXTENDED_CAB_CONTENTS

                        lstrcpy(szPbr, pdaArgs->szCabDir);
#endif

                        lstrcat(szPbr, TEXT("\\"));
                        lstrcat(szPbr, pdaArgs->rgfpiFileProcessInfo[i].pszFile);
                        
                        // Try to copy the region file directly

                        if (!CopyFile(szPbr, pdaArgs->pszPbrFile, FALSE))
                        {
                            MYDBG((TEXT("DoInstall() itPbrInCab, CopyFile() failed, GLE=%u."), GetLastError()));
                        }
                        else
                        {
                            bInstallOk = TRUE;
                        }

                        break;
                    }

#ifdef EXTENDED_CAB_CONTENTS

                    case itShlInCab: // Shell execute target
                    {
                        TCHAR szShl[MAX_PATH+1];

                        lstrcpy(szShl,c_pszDirName);
                        lstrcat(szShl,TEXT("\\"));
                        lstrcat(szShl,pdaArgs->rgfpiFileProcessInfo[i].pszFile);

                        SHELLEXECUTEINFO seiInfo;
                        ZeroMemory(&seiInfo,sizeof(seiInfo));
                        seiInfo.cbSize = sizeof(seiInfo);
                        seiInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
                        seiInfo.hwnd = hwndParent;
                        seiInfo.lpFile = szShl;
                        seiInfo.nShow = SW_SHOWNORMAL;
                        bRes = ShellExecuteEx(&seiInfo);
                        MYDBGTST(!bRes,("DoInstall() ShellExecuteEx(szShl=%s) failed, GLE=%u.",szShl,GetLastError()));
                        
                        // If it worked, wait for termination

                        if (bRes) 
                        {
                            MyMsgWaitDlg(hwndParent,1,&seiInfo.hProcess,INFINITE);
                            CloseHandle(seiInfo.hProcess);
                            bInstallOk = TRUE;
                        }
                        
                        break;
                    } // case itShlInCab

#endif // EXTENDED_CAB_CONTENTS

                } // switch (pdaArgs->rgfpiFileProcessInfo[i].itType)
            } // for (i=0; i<pdaArgs->dwNumFilesToProcess; i++)
        } // if (bRes)

#ifdef EXTENDED_CAB_CONTENTS
        
        if (fCabDirRenamed) 
        {
            // Copy the Cab directory back to tmp name

            bRes = MoveFile(c_pszDirName,pdaArgs->szCabDir);
            MYDBGTST(!bRes,("DoInstall() MoveFile(c_pszDirName,szCabDir=%s) failed, GLE=%u.",pdaArgs->szCabDir,GetLastError()));
        }

#endif // EXTENDED_CAB_CONTENTS
        
        // Update version info in CMS

        if (bInstallOk && !(dwAppFlags & AF_NO_VER) && pdaArgs->pszVerNew && pdaArgs->pszCMSFile) 
        {
            WritePrivateProfileString(c_pszCmSection,
                                      c_pszVersion,
                                      pdaArgs->pszVerNew,
                                      pdaArgs->pszCMSFile);
        }
    }
    
    return (TRUE);
}


//+----------------------------------------------------------------------------
//
// Func:    CheckFileForPBSErrors
//
// Desc:    Scan the downloaded file for PBS errors
//
// Args:    [hFile] - handle to the already opened tempfile
//
// Return:  LONG (0 = no download needed, +ve = PBS error code, -1 = other error)
//
// Notes:
//
// History: 14-Apr-2001   SumitC      Created
//
//-----------------------------------------------------------------------------
static LONG CheckFileForPBSErrors(HANDLE hFile)
{
    LONG lRet = -1;
    
    MYDBGASSERT(hFile);

    if (hFile && (INVALID_HANDLE_VALUE != hFile))
    {
        TCHAR szFirstThree[4] = {0};
        DWORD dwBytesRead;

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

        if (ReadFile(hFile, szFirstThree, 3, &dwBytesRead, NULL) &&
            (dwBytesRead >= 3))
        {
            if (0 == lstrcmpi(szFirstThree, TEXT("204")))
            {
                //
                //  "204" => no download necessary
                //
                lRet = 0;
            }
            else if (0 != lstrcmpi(szFirstThree, TEXT("MSC")))
            {
                //
                //  "MSC" => we have a phonebook.  If *not* MSC, get the error number
                //
                LONG lVal = 0;
                for (int i = 0 ; i < 3; ++i)
                {
                    if ((szFirstThree[i] >= TEXT('0')) && (szFirstThree[i] <= TEXT('9')))
                    {
                        lVal = (lVal *10) + (szFirstThree[i] - TEXT('0'));
                    }
                    else
                    {
                        break;
                    }
                }

                if (lVal)
                {
                    lRet = lVal;
                }
            }
        }
    }

    return lRet;
}

//static unsigned __stdcall InetThreadFunc(void *pvParam) 
DWORD WINAPI InetThreadFunc(void *pvParam) 
{
    EventParam epParam = {(ArgsStruct *) pvParam,0};
    BOOL bRes = FALSE;
    BOOL bSuccess = FALSE;
    DWORD dwFileIdx;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    RASCONN RasConn, *prgRasConn;
    DWORD   cb, cConnections;
    PVOID   pRasEnumMem = NULL;

    // Wait for delay period to expire
    
    DWORD dwRes = WaitForSingleObject(epParam.pArgs->ahHandles[1], epParam.pArgs->dwDownloadDelay);

    MYDBGTST(dwRes==WAIT_FAILED,("InetThreadFunc() WaitForMultipleObjects() failed, GLE=%u.",GetLastError()));

    //
    // Check if connection is still valid before starting the download
    // on NT5 we depend on setting the don't autodial flag for InternetSetOptions()
    // Unless, of course, the /LAN flag was specified in which case we don't want
    // this connection check to happen because the caller is telling us this is happening
    // over a LAN connection.
    //
    if (!(epParam.pArgs->dwAppFlags & AF_LAN))
    {
        cb = sizeof(RasConn);
        prgRasConn = &RasConn;
        prgRasConn->dwSize = cb;
        dwRes = RasEnumConnections(prgRasConn, &cb, &cConnections);
        if (dwRes == ERROR_BUFFER_TOO_SMALL)
        {
            pRasEnumMem = CmMalloc(cb);
            if (pRasEnumMem == NULL)
            {
                MYDBG(("InetThreadFunc() aborted. Out of memory"));
                epParam.pArgs->bAbort = TRUE;
                goto done;
            }
            prgRasConn = (RASCONN *) pRasEnumMem;
            prgRasConn[0].dwSize = sizeof(RASCONN);
            dwRes = RasEnumConnections(prgRasConn, &cb, &cConnections);
        }

        //
        // Iterate through connections to check if our's is active
        // if there is a problem getting this list we don't abort?
        //
        if (dwRes == ERROR_SUCCESS)
        {
            DWORD       iConn;
            BOOL        fConnected = FALSE;
        
            for (iConn = 0; iConn < cConnections; iConn++)
            {
                if (lstrcmpi(epParam.pArgs->pszServiceName, prgRasConn[iConn].szEntryName) == 0)
                {
                    fConnected = TRUE;
                    break;
                }
            }

            if (fConnected == FALSE)
            {
                MYDBG(("InetThreadFunc() aborted. No connection"));
                epParam.pArgs->bAbort = TRUE;
                goto done;
            }
        }
    }

    if (epParam.pArgs->bAbort) 
    {
        MYDBG(("InetThreadFunc() aborted."));
    }

    for (epParam.dwIdx=0;epParam.dwIdx<epParam.pArgs->dwArgsCnt;epParam.dwIdx++) 
    {
        int i = 0;
        UINT uReturn = 0;
        DownloadArgs * pDA = &(epParam.pArgs->pdaArgs[epParam.dwIdx]);

        while (i++ < 3)
        {
            //
            //  On Win9x and/or slow machines, GetTempFileName sometimes fails,
            //  and cmdl32 errors all the way out.  In the debugger, if the call
            //  is retried, it will invariably succeed.  This sounds like a timing
            //  issue with the OS.  We do 3 tries, separated by a 1-second sleep.
            //
            uReturn = GetTempFileName(TEXT("."), TEXT("000"), 0, epParam.pArgs->pdaArgs[epParam.dwIdx].szFile);
            if (uReturn)
            {
                break;
            }
            Sleep(1000);
        }

        if (0 == uReturn)
        {
            DWORD dwError = GetLastError();
            MYDBG(("InetThreadFunc() GetTempFileName failed, GLE=%u.", dwError));
            epParam.pArgs->Log.Log(PB_DOWNLOAD_FAILURE, dwError, pDA->pszPhoneBookName, pDA->szHostName);
            goto done;
        }
        else
        {
            hFile = CreateFile(epParam.pArgs->pdaArgs[epParam.dwIdx].szFile,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (INVALID_HANDLE_VALUE == hFile)
            {
                DWORD dwError = GetLastError();
                MYDBG(("InetThreadFunc() CreateFile(szFile=%s) failed, GLE=%u.", epParam.pArgs->pdaArgs[epParam.dwIdx].szFile, dwError));
                epParam.pArgs->Log.Log(PB_DOWNLOAD_FAILURE, dwError, pDA->pszPhoneBookName, pDA->szHostName);
                goto done;            
            }
        }

        //
        //  Check to make sure we haven't been aborted
        //
        if (epParam.pArgs->bAbort) 
        {
            MYDBG(("InetThreadFunc() aborted."));
            goto done;
        }

        // We have a valid tmp file name, download phonebook update into it.
    
        epParam.pArgs->pdaArgs[epParam.dwIdx].pfnEvent = EventFunc;
        epParam.pArgs->pdaArgs[epParam.dwIdx].pvEventParam = &epParam;
        epParam.pArgs->pdaArgs[epParam.dwIdx].pbAbort = &epParam.pArgs->bAbort;
        
        PostMessage(epParam.pArgs->hwndDlg,epParam.pArgs->nMsgId,etDataBegin,0);

        bRes = DownloadFile(&epParam.pArgs->pdaArgs[epParam.dwIdx],hFile);
        FlushFileBuffers(hFile);

        LONG lResult = CheckFileForPBSErrors(hFile);

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        
        if (epParam.pArgs->bAbort) 
        {
            MYDBG(("InetThreadFunc() aborted."));
            goto done;
        }

        PostMessage(epParam.pArgs->hwndDlg,epParam.pArgs->nMsgId,etDataEnd,0);
        
#if 0 
/*
        if (!bRes && !epParam.dwIdx)
        {
            // TBD: Currently, a failure to update the primary phonebook prevents any
            // secondary phonebooks from being updated.  But a failure to update one
            // secondary does not prevent other secondaries from being updated.
            
            goto done;   
        }
*/      
#endif
        //
        // If download failed (either cpserver thinks that we don't need to update
        // the phone book or the phone book doesn't exist on the server), just keep 
        // on downloading the phone books for other profiles.
        //
    
        if (!bRes) 
        {
            if (lResult < 0)
            {
                //
                //  we parsed the downloaded file and got some error other than
                //  the 2 cases handled below
                //
                epParam.pArgs->Log.Log(PB_DOWNLOAD_FAILURE, pDA->dwBubbledUpError, pDA->pszPhoneBookName, pDA->szHostName);
            }
            else
            {
                //
                //  we contacted the web server successfully, and...
                //
                epParam.pArgs->Log.Log(PB_DOWNLOAD_SUCCESS, pDA->pszPhoneBookName, pDA->pszVerCurr, pDA->szHostName);

                if (lResult > 0)
                {
                    //
                    //  ... (case 1) the web server or PBS reported an error
                    //
                    epParam.pArgs->Log.Log(PB_UPDATE_FAILURE_PBS, lResult, pDA->pszPhoneBookName);
                }
                else
                {
                    //
                    //  ... (case 2) PBS said no download necessary
                    //
                    MYDBGASSERT(0 == lResult);

                    LPTSTR pszText = CmFmtMsg(epParam.pArgs->hInst, IDMSG_LOG_NO_UPDATE_REQUIRED);

                    epParam.pArgs->Log.Log(PB_UPDATE_SUCCESS,
                                           SAFE_LOG_ARG(pszText),
                                           pDA->pszPhoneBookName,
                                           pDA->pszVerCurr,
                                           pDA->pszVerCurr,     // for no-download case, these are the same
                                           pDA->szHostName);
                    CmFree(pszText);
                }
            }

            continue;
        }

        if (bRes && epParam.pArgs->pdaArgs[epParam.dwIdx].dwTotalSize) 
        {
            epParam.pArgs->pdaArgs[epParam.dwIdx].bTransferOk = TRUE;
        }
        
        if (epParam.pArgs->bAbort) 
        {
            MYDBG(("InetThreadFunc() aborted."));
            goto done;
        }
        
        //
        //  Phonebook download was successful, log this and proceed to unpack/update
        //
        epParam.pArgs->Log.Log(PB_DOWNLOAD_SUCCESS, pDA->pszPhoneBookName, pDA->pszVerCurr, pDA->szHostName);

        bRes = ProcessCabinet(&epParam.pArgs->pdaArgs[epParam.dwIdx],epParam.pArgs->dwAppFlags);

        if (bRes && (NULL == pDA->rgfpiFileProcessInfo))
        {
            MYDBGASSERT(FALSE);

            // strange case.  set error here so that we log something sensible later
            pDA->dwBubbledUpError = ERROR_INVALID_DATA;     // yes. we know this is lame.
        }

        if (bRes && pDA->rgfpiFileProcessInfo)
        {
            //
            //  figure out if this was a full or delta download
            //
            BOOL fFoundFullCab = FALSE;
            BOOL fFoundDeltaCab = FALSE;
            
            for (DWORD dwFileIndex = 0; dwFileIndex < pDA->dwNumFilesToProcess; ++dwFileIndex)
            {
                switch (pDA->rgfpiFileProcessInfo[dwFileIndex].itType)
                {
                    case itPbkInCab:
                        fFoundFullCab = TRUE;
                        break;
                        
                    case itPbdInCab:
                        fFoundDeltaCab = TRUE;
                        break;
                }
            }

            if (fFoundFullCab ^ fFoundDeltaCab)
            {
                // the cab should contain one or the other, but not both

                LPTSTR pszTemp = NULL;

                if (fFoundFullCab)
                {
                    pszTemp = CmFmtMsg(epParam.pArgs->hInst, IDMSG_LOG_FULL_UPDATE);
                }
                else if (fFoundDeltaCab)
                {
                    pszTemp = CmFmtMsg(epParam.pArgs->hInst, IDMSG_LOG_DELTA_UPDATE);
                }

                MYDBGASSERT(pszTemp);
                if (pszTemp)
                {
                    epParam.pArgs->Log.Log(PB_UPDATE_SUCCESS,
                                           SAFE_LOG_ARG(pszTemp),
                                           pDA->pszPhoneBookName,
                                           pDA->pszVerCurr,
                                           pDA->pszVerNew,
                                           pDA->szHostName);

                    CmFree(pszTemp);
                }
            }
            else
            {
                // strange cab (or at least, doesn't contain what we expected)

                // both full and delta
                CMASSERTMSG(!(fFoundFullCab && fFoundDeltaCab), TEXT("This cab has both full and delta phonebooks!!"));
                // neither full nor delta
                CMASSERTMSG(! (!fFoundFullCab && !fFoundDeltaCab), TEXT("This cab has neither a full nor a delta phonebook!!"));
                
                pDA->dwBubbledUpError = ERROR_BAD_FORMAT;
                epParam.pArgs->Log.Log(PB_UPDATE_FAILURE_CMPBK, pDA->dwBubbledUpError, pDA->pszPhoneBookName);
            }
        }
        else
        {
            epParam.pArgs->Log.Log(PB_UPDATE_FAILURE_CMPBK, pDA->dwBubbledUpError, pDA->pszPhoneBookName);
        }

        if (!bRes)
        {
            goto done;
        }

        bSuccess = TRUE; // We have at least one successful download #5635

#if 0 
/*
        if (!epParam.dwIdx &&
            epParam.pArgs->pdaArgs[epParam.dwIdx].dwTotalSize &&
            (epParam.pArgs->pdaArgs[epParam.dwIdx].itType != itInvalid) &&
            (epParam.pArgs->pdaArgs[epParam.dwIdx].itType != itPbdInCab)) 
        {
            // TBD: Currently, if the primary service is being updated in any way other than
            // a simple phone number delta, we do *not* update any of the secondary phonebooks
            // this time around.
            break;
        }
*/
#endif

    }

    //
    // If no download attempts succeeded, bail completely
    //
    
    if (!bSuccess)
    {
        MYDBG(("InetThreadFunc() no download success."));
        goto done;
    }

    if (epParam.pArgs->bAbort) 
    {
        MYDBG(("InetThreadFunc() aborted."));
        goto done;
    }

#ifdef EXTENDED_CAB_CONTENTS
    
    // At this point, all of the downloads are complete.  We post a message to the main
    // window, asking it to call WinVerifyTrust() as appropriate for all of the downloaded
    // blobs.  The main window will post the event back to us when it is done.
    
    PostMessage(epParam.pArgs->hwndDlg,epParam.pArgs->nMsgId,etVerifyTrust,0);
    
    dwRes = WaitForSingleObject(epParam.pArgs->ahHandles[IDX_EVENT_HANDLE],INFINITE);
    
    if (epParam.pArgs->bAbort) 
    {
        MYDBG(("InetThreadFunc() aborted."));
        goto done;
    }

#endif // EXTENDED_CAB_CONTENTS
       
    // At this point, everything is all set - we're ready to perform the actual installs.  So
    // send a message to the main window telling it to do the installs, and wait until it
    // signals success back.
    
    PostMessage(epParam.pArgs->hwndDlg,epParam.pArgs->nMsgId,etInstall,0);
    dwRes = WaitForSingleObject(epParam.pArgs->ahHandles[IDX_EVENT_HANDLE],INFINITE);
    
    if (epParam.pArgs->bAbort)
    {
        MYDBG(("InetThreadFunc() aborted."));
        goto done;
    }
    
    SetLastError(ERROR_SUCCESS);

done:

    if (epParam.pArgs->bAbort)
    {
        epParam.pArgs->Log.Log(PB_ABORTED);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    if (pRasEnumMem != NULL)
    {
        CmFree(pRasEnumMem);
    }
    
    PostMessage(epParam.pArgs->hwndDlg,epParam.pArgs->nMsgId,etDone,0);
    return (GetLastError());
}

//
// The main dlg
//

BOOL CALLBACK MainDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{ 
    ArgsStruct *pArgs = (ArgsStruct *) GetWindowLongPtr(hwndDlg,DWLP_USER);
    static UINT uTimerID = 0;

    switch (uMsg) 
    {             
        case WM_INITDIALOG: 
        {
            RECT rDlg;
            RECT rWorkArea;
            DWORD dwThreadId = 0;
            SetWindowLongPtr(hwndDlg,DWLP_USER,(LONG_PTR)lParam);
            pArgs = (ArgsStruct *) lParam;
            pArgs->hwndDlg = hwndDlg;
            
            MYDBG(("MainDlgProc() - WM_INITDIALOG."));

            // Get the dialog rect and the available work area.
            
            GetWindowRect(hwndDlg,&rDlg);

            if (SystemParametersInfoA(SPI_GETWORKAREA,0,&rWorkArea,0))
            {
                // Move the dialog to the bottom right of the screen
                
                MoveWindow(hwndDlg,
                    rWorkArea.left + ((rWorkArea.right-rWorkArea.left) - (rDlg.right-rDlg.left) - GetSystemMetrics(SM_CXBORDER)),
                    rWorkArea.top + ((rWorkArea.bottom-rWorkArea.top) - (rDlg.bottom-rDlg.top) - GetSystemMetrics(SM_CYBORDER)),
                    rDlg.right-rDlg.left,
                    rDlg.bottom-rDlg.top,
                    FALSE);         
            }

            // Get update message from ini

            if (pArgs->pszProfile) 
            {
                TCHAR szTmp1[MAX_PATH+1];
                TCHAR szTmp2[MAX_PATH+1];

                GetDlgItemText(hwndDlg,IDC_MAIN_MESSAGE,szTmp2,sizeof(szTmp2)/sizeof(TCHAR)-1);
                GetPrivateProfileString(c_pszCmSection,
                                        c_pszCmEntryPbUpdateMessage, 
                                        szTmp2,
                                        szTmp1,
                                        sizeof(szTmp1)/sizeof(TCHAR)-1,
                                        pArgs->pdaArgs->pszCMSFile);
                SetDlgItemText(hwndDlg,IDC_MAIN_MESSAGE,szTmp1);
            }

            // Spin download thread (InetThreadFunc)

            pArgs->dwHandles = sizeof(pArgs->ahHandles) / sizeof(pArgs->ahHandles[0]);

            pArgs->ahHandles[IDX_EVENT_HANDLE] = CreateEvent(NULL,FALSE,FALSE,NULL);
            if (!pArgs->ahHandles[IDX_EVENT_HANDLE]) 
            {
                MYDBG(("MainDlgProc() CreateEvent() failed, GLE=%u.",GetLastError()));
                EndDialog(hwndDlg,FALSE);
            }

            //pArgs->ahHandles[IDX_INETTHREAD_HANDLE] = (HANDLE) _beginthreadex(NULL,0,InetThreadFunc,pArgs,0,&nThreadId);
            pArgs->ahHandles[IDX_INETTHREAD_HANDLE] = (HANDLE) CreateThread(0,0,InetThreadFunc,pArgs,0,&dwThreadId);
            if (!pArgs->ahHandles[IDX_INETTHREAD_HANDLE]) 
            {
                MYDBG(("MainDlgProc() CreateThread() failed, GLE=%u.",GetLastError()));
                EndDialog(hwndDlg,FALSE);
            }

            SetFocus((HWND) wParam);
            return (FALSE);
        }

        case WM_WINDOWPOSCHANGING:

            // Until we set pArgs->bShow to TRUE, we prevent the window from
            // ever being shown.
            if (!pArgs->bShow && (((LPWINDOWPOS) lParam)->flags & SWP_SHOWWINDOW)) 
            {
                ((LPWINDOWPOS) lParam)->flags &= ~SWP_SHOWWINDOW;
                ((LPWINDOWPOS) lParam)->flags |= SWP_HIDEWINDOW;
            }
            break;

        case WM_INITMENUPOPUP: 
        {
            HMENU hMenu = (HMENU) wParam;
//          UINT nPos = (UINT) LOWORD(lParam);
            BOOL fSysMenu = (BOOL) HIWORD(lParam);

            if (fSysMenu) 
            {
                EnableMenuItem(hMenu,SC_MAXIMIZE,MF_BYCOMMAND|MF_GRAYED);
            }
            break;
        }

        case WM_DESTROY:
        {                       
            // Kill timer if we have one
            
            if (uTimerID)
            {
                KillTimer(hwndDlg, uTimerID);
            }
            
            // If we have args, set bAbort true
            
            if (pArgs)
            {
                pArgs->bAbort = TRUE;
            }
            else
            {
                MYDBGASSERT(FALSE); // should not happen if dailog loads
            }                   
            
            break;
    }
        default:
            break;
    }
    
    // Check for custom messages
    
    if (pArgs && (uMsg == pArgs->nMsgId)) 
    {
        LPTSTR pszMsg;
        MYDBG(("Custom arg - %u received.", (DWORD) wParam));
       
        //
        // Setup FirstEvent time for tracking delays
        //                                            
        
        if (!pArgs->dwFirstEventTime) 
        {
            pArgs->dwFirstEventTime = GetTickCount();
            MYDBG(("Setting FirstEventTime to %u.", pArgs->dwFirstEventTime));
        }
        if (!pArgs->bShow && (GetTickCount() - pArgs->dwFirstEventTime > pArgs->dwHideDelay)) 
        {
            MYDBG(("HideDelay of %u expired, displaying dlg now.", pArgs->dwHideDelay));
            pArgs->bShow = TRUE;
            ShowWindow(hwndDlg,SW_SHOWNA);
        }

        // Handle specific message
        
        switch (wParam) 
        {
            case etDataBegin:
                pArgs->dwDataStepSize = 0;
                SendDlgItemMessage(hwndDlg,IDC_MAIN_PROGRESS,PBM_SETRANGE,0,MAKELPARAM(0,100));
                SendDlgItemMessage(hwndDlg,IDC_MAIN_PROGRESS,PBM_SETPOS,0,0);
                pszMsg = CmFmtMsg(pArgs->hInst,IDMSG_PERCENT_COMPLETE,0);
                SetWindowText(hwndDlg,pszMsg);
                CmFree(pszMsg);
                break;

            case etDataReceived:
                if (pArgs->dwDataTotal) // PREVENT DIVIDE BY ZERO
                { 
                    if (!pArgs->dwDataStepSize ) 
                    {
                        //
                        // Progress controls have a limit to there maximum 
                        // integral value so calculate an aproximate step size.
                        // 
                        //

                        pArgs->dwDataStepSize = (pArgs->dwDataTotal / 65535) + 1;

                        SendDlgItemMessage(hwndDlg,
                                           IDC_MAIN_PROGRESS,
                                           PBM_SETRANGE,
                                           0,
                                           MAKELPARAM(0,pArgs->dwDataTotal/pArgs->dwDataStepSize));
                    }
                    if (pArgs->dwDataStepSize) 
                    {
                        SendDlgItemMessage(hwndDlg,IDC_MAIN_PROGRESS,PBM_SETPOS,(WORD) (pArgs->dwDataCompleted / pArgs->dwDataStepSize),0);
                        pszMsg = CmFmtMsg(pArgs->hInst,IDMSG_PERCENT_COMPLETE,(pArgs->dwDataCompleted*100)/pArgs->dwDataTotal);
                        SetWindowText(hwndDlg,pszMsg);
                        CmFree(pszMsg);
                    }
                }
                break;

            case etDataEnd:
                pszMsg = CmFmtMsg(pArgs->hInst,IDMSG_PERCENT_COMPLETE,100);
                SetWindowText(hwndDlg,pszMsg);
                CmFree(pszMsg);
                break;

#ifdef EXTENDED_CAB_CONTENTS
                
            case etVerifyTrust: 
            {
                DWORD dwIdx;
                UINT    i;

                for (dwIdx=0;dwIdx<pArgs->dwArgsCnt;dwIdx++) 
                {
                    DownloadArgs *pdaArgs;
                    LONG lRes = ERROR_INVALID_PARAMETER;
                    WCHAR szPath[MAX_PATH+1];
                    GUID gCabSubjectType = WIN_TRUST_SUBJTYPE_CABINET;
                    GUID gExeSubjectType = WIN_TRUST_SUBJTYPE_PE_IMAGE;
                    WIN_TRUST_SUBJECT_FILE sSubject = {INVALID_HANDLE_VALUE,szPath};
                    GUID gActionID = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
                    WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT sActionData = {NULL,&gCabSubjectType,&sSubject};
                    int iRes;
                    BOOL fStandaloneExe;

                    pdaArgs = pArgs->pdaArgs + dwIdx;
                    ZeroMemory(szPath,sizeof(szPath));
                    pszMsg = CmFmtMsg(pArgs->hInst,IDMSG_PBTITLEMSG);
                    iRes = MultiByteToWideChar(CP_OEMCP,0,pszMsg,-1,szPath,sizeof(szPath)/sizeof(WCHAR)-1);
                    MYDBGTST(!iRes,("MainDlgProc() MultiByteToWideChar() failed, GLE=%u.",GetLastError()));
                    CmFree(pszMsg);

                    fStandaloneExe = (pdaArgs->dwNumFilesToProcess == 1 &&
                    pdaArgs->rgfpiFileProcessInfo[0].itType == itExe);

                    if (fStandaloneExe || pdaArgs->fContainsExeOrInf || pdaArgs->fContainsShl) 
                    {
                        HRESULT hRes;
        
                        if (fStandaloneExe) 
                            sActionData.SubjectType = &gExeSubjectType;
#ifdef DEBUG
                        if (!(pArgs->dwAppFlags & AF_NO_VERIFY)) 
                        {
#endif
                            sSubject.hFile = CreateFile(pdaArgs->szFile,
                                                        GENERIC_READ,
                                                        FILE_SHARE_READ,
                                                        NULL,
                                                        OPEN_EXISTING,
                                                        0,
                                                        NULL);
                            
                            MYDBGTST(sSubject.hFile==INVALID_HANDLE_VALUE,("MainDlgProc() CreateFile(szFile=%s) failed, GLE=%u.",pdaArgs->szFile,GetLastError()));

                            if (sSubject.hFile != INVALID_HANDLE_VALUE) 
                            {
                
                                //
                                // Now that we know we're going to do something, show the window #6335
                                //

                                pArgs->bShow = TRUE;
                                ShowWindow(hwndDlg,SW_SHOWNA);

                                //
                                // Perform verification
                                // 
                                
                                hRes = WinVerifyTrust(hwndDlg,&gActionID,&sActionData);
                
                                if (!HRESULT_SEVERITY(hRes)) 
                                {
                                    lRes = ERROR_SUCCESS;
                                } 
                                else 
                                {
                                    MYDBG(("MainDlgProc() WinVerifyTrust(pszFile=%s) failed, GLE=%u.",pdaArgs->szFile,hRes));
                                    lRes = HRESULT_CODE(hRes);
                                }
                                
                                CloseHandle(sSubject.hFile);
                            }
#ifdef DEBUG
                        } 
                        else 
                        {
                            lRes = ERROR_SUCCESS;
                        }
#endif
                    }
                    else // we don't do signing of other files
                        lRes = ERROR_SUCCESS;

                    if (lRes != ERROR_SUCCESS) 
                    {
                        // pdaArgs->itType = itInvalid;
                        pArgs->bAbort = TRUE;
                    }
                }

#ifdef EXTENDED_CAB_CONTENTS
                pArgs->bVerified = TRUE;
#endif // EXTENDED_CAB_CONTENTS
                ShowWindow(hwndDlg,SW_HIDE);
                SetEvent(pArgs->ahHandles[IDX_EVENT_HANDLE]);
                break;
            }

#endif // EXTENDED_CAB_CONTENTS

            case etInstall:
            {
                CNamedMutex PbMutex;
                               
                //
                // Hide the window, we're ready to install
                //

                pArgs->bShow = TRUE;            
                ShowWindow(hwndDlg,SW_HIDE);
                
                //
                // Grab the mutex before we begin PB updates. If it fails then 
                // abort the install, we'll try again next time the user connects.

                if (PbMutex.Lock(c_pszCMPhoneBookMutex))
                {
                    DoInstall(pArgs,hwndDlg,pArgs->dwAppFlags);
                    PbMutex.Unlock();
                }

                SetEvent(pArgs->ahHandles[IDX_EVENT_HANDLE]);
                ShowWindow(hwndDlg,SW_HIDE);
                break;
            }

            case etDone:
                EndDialog(hwndDlg,TRUE);
                break;

            case etICMTerm:

#ifdef EXTENDED_CAB_CONTENTS
                if (!pArgs->bVerified) 
                {
                    pArgs->bAbort = TRUE;
                    EndDialog(hwndDlg,FALSE);
                }
#endif // EXTENDED_CAB_CONTENTS

                SetEvent(pArgs->ahHandles[IDX_EVENT_HANDLE]);
                break;
        }
    }
    return (FALSE);
}


static void AddToUrl(LPTSTR pszUrl, LPTSTR pszVersion, LPTSTR pszService) 
{
    TCHAR szHttpstr[MAX_PATH];
    TCHAR szChar[16];
    int i,len;

    if (!CmStrchr(pszUrl,'?')) 
    {
        lstrcat(pszUrl,TEXT("?"));
    } 
    else
    {
        if (pszUrl[lstrlen(pszUrl)-1] != '&') 
        {
            lstrcat(pszUrl,TEXT("&"));
        }
    }

    
    // TBD Maybe get more info to send to the server.  We currently send
    // OSArch, OSType, LCID, OSVer, CMVer, PBVer, and ServiceName.
    
    SYSTEM_INFO siInfo;
    OSVERSIONINFO oviInfo;

    GetSystemInfo(&siInfo);
    ZeroMemory(&oviInfo,sizeof(oviInfo));
    oviInfo.dwOSVersionInfoSize = sizeof(oviInfo);
    GetVersionEx(&oviInfo);

    // #pragma message("ALERT - Resolution required - need to remove ISBU_VERSION." __FILE__)

    wsprintf(pszUrl+lstrlen(pszUrl),
             TEXT("OSArch=%u&OSType=%u&LCID=%u&OSVer=%u.%u.%u&CMVer=%s"),
             siInfo.wProcessorArchitecture,
             oviInfo.dwPlatformId,
             ConvertDefaultLocale(LOCALE_SYSTEM_DEFAULT),
             oviInfo.dwMajorVersion,
             oviInfo.dwMinorVersion,
             (oviInfo.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)?LOWORD(oviInfo.dwBuildNumber):oviInfo.dwBuildNumber,
             VER_PRODUCTVERSION_STR);

    if (pszVersion && *pszVersion) 
    {
        wsprintf(pszUrl+lstrlen(pszUrl),TEXT("&PBVer=%s"),pszVersion);
    }
    
    if (pszService && *pszService) 
    {
        // replace spaces with %20 for HTTP - 10216
        len = strlen(pszService);
        szHttpstr[0] = 0;
        szChar[1] = 0;
        for (i=0; i<len; ++i)
        {
            if (pszService[i] == ' ')
            {
                lstrcat(szHttpstr,"%20");
            }
            else
            {
                szChar[0] = pszService[i];
                lstrcat(szHttpstr,szChar);
            }
        }
        wsprintf(pszUrl+lstrlen(pszUrl),TEXT("&PB=%s"),szHttpstr);
    }
}

static BOOL WINAPI RefFunc(LPCTSTR pszFile,
                           LPCTSTR pszURL,
                           PPBFS , // pFilterA,
                           PPBFS , // pFilterB,
                           DWORD_PTR dwParam) 
{
    ArgsStruct *pArgs = (ArgsStruct *) dwParam;
    DownloadArgs *pdaArgsTmp;
    TCHAR szTmp[MAX_PATH+1];
    BOOL bOk = FALSE;
    LPTSTR  pszSlash;
    LPTSTR  pszDot;

    pdaArgsTmp = (DownloadArgs *) CmRealloc(pArgs->pdaArgs,(pArgs->dwArgsCnt+1)*sizeof(DownloadArgs));
    if (pdaArgsTmp) 
    {
        pArgs->pdaArgs = pdaArgsTmp;
        pdaArgsTmp += pArgs->dwArgsCnt;
        pdaArgsTmp->pszCMSFile = CmStrCpyAlloc(pszFile);
    
        if (pdaArgsTmp->pszCMSFile) 
        {
            // If get the version number from the CMS file

            GetPrivateProfileString(c_pszCmSection,
                                    c_pszVersion,
                                    TEXT(""),
                                    szTmp,
                                    (sizeof(szTmp)/sizeof(TCHAR))-1,
                                    pdaArgsTmp->pszCMSFile);
            pdaArgsTmp->pszVerCurr = CmStrCpyAlloc(szTmp);
        
            // get the PBK filename from the CMS file
            GetPrivateProfileString(c_pszCmSectionIsp,
                        c_pszCmEntryIspPbFile,
                        TEXT(""),
                        szTmp,
                        sizeof(szTmp)/sizeof(TCHAR)-1,
                        pdaArgsTmp->pszCMSFile);
            pdaArgsTmp->pszPbkFile = CmStrCpyAlloc(szTmp);
        
            // get the PDR filename from the CMS file
            GetPrivateProfileString(c_pszCmSectionIsp,
                        c_pszCmEntryIspRegionFile,
                        TEXT(""),
                        szTmp,
                        sizeof(szTmp)/sizeof(TCHAR)-1,
                        pdaArgsTmp->pszCMSFile);
            pdaArgsTmp->pszPbrFile = CmStrCpyAlloc(szTmp);

            // get the phone book name
            if (!(pszSlash = CmStrrchr(pdaArgsTmp->pszPbkFile, TEXT('\\')))) 
            {
                MYDBG((TEXT("RefFunc() bad PBK FILE - no backslash.")));
                goto parse_err;
            }

            if (!(pszDot = CmStrchr(pszSlash, TEXT('.')))) 
            {
                MYDBG((TEXT("Reffunc() bad PBK FILE - no dot.")));
                goto parse_err;
            }
            
            *pszDot = TEXT('\0');
            
            if (!(pdaArgsTmp->pszPhoneBookName = CmStrCpyAlloc(pszSlash+1)))
            {
                MYDBG((TEXT("Reffunc() out of memory.")));
            }
            // restore the slash
            *pszDot = TEXT('.');
            goto next_param;

parse_err:  
            pdaArgsTmp->pszPhoneBookName = CmStrCpyAlloc(TEXT(""));
        
next_param:
            if (pdaArgsTmp->pszVerCurr) 
            {
                // Build URL with version number and service name
                
                pdaArgsTmp->pszUrl = (LPTSTR) CmMalloc((INTERNET_MAX_URL_LENGTH+1)*sizeof(TCHAR));
                if (pdaArgsTmp->pszUrl) 
                {
                    lstrcpy(pdaArgsTmp->pszUrl,pszURL);
                    AddToUrl(pdaArgsTmp->pszUrl,pdaArgsTmp->pszVerCurr,pdaArgsTmp->pszPhoneBookName);
                    pArgs->dwArgsCnt++;
                    bOk = TRUE;
                }
            }
        }
    }

    // Cleanup

    if (!bOk && pdaArgsTmp) 
    {
        CmFreeIndirect(&pdaArgsTmp->pszCMSFile);
        CmFreeIndirect(&pdaArgsTmp->pszVerCurr);
        CmFreeIndirect(&pdaArgsTmp->pszUrl);
    }
    return (TRUE);
}

//
// cmmgr32.exe passes cmdl32.exe the cmp filename in full path.
//
static BOOL InitArgs(ArgsStruct *pArgs) 
{
    static struct 
    {
        LPTSTR pszFlag;
        DWORD dwFlag;
    } asFlags[] = {{TEXT("/no_delete"),AF_NO_DELETE},
                   {TEXT("/no_install"),AF_NO_INSTALL},
#ifdef DEBUG
                   {TEXT("/no_verify"),AF_NO_VERIFY},
#endif
                   {TEXT("/url"),AF_URL},
                   {TEXT("/no_profile"),AF_NO_PROFILE},
                   {TEXT("/no_exe"),AF_NO_EXE},
                   {TEXT("/no_exeincab"),AF_NO_EXEINCAB},
                   {TEXT("/no_infincab"),AF_NO_INFINCAB},
                   {TEXT("/no_pbdincab"),AF_NO_PBDINCAB},
                   {TEXT("/no_shlincab"),AF_NO_SHLINCAB},
                   {TEXT("/no_ver"),AF_NO_VER},
                   {TEXT("/LAN"),AF_LAN},
                   {TEXT("/VPN"),AF_VPN},
                   {NULL,0}};
    DWORD dwIdx;
    BOOL bInUrl;
    LPTSTR pszUrl = NULL;
    BOOL bRes = FALSE;
    TCHAR szPath[MAX_PATH+1];
    DWORD dwRes;
//  LPTSTR pszFileInPath;

    //
    // Get simulated ArgV
    //

    LPTSTR pszCmdLine = CmStrCpyAlloc(GetCommandLine());
   
    LPTSTR *ppszArgv = GetCmArgV(pszCmdLine);

    if (!ppszArgv || !ppszArgv[0]) 
    {
        MYDBG(("InitArgs() invalid parameter."));
        goto done;
    }
    
    //
    // Proces arguments
    //

    bInUrl = FALSE;
    
    for (dwIdx=1;ppszArgv[dwIdx];dwIdx++) 
    {
        DWORD dwFlagIdx;

        for (dwFlagIdx=0;asFlags[dwFlagIdx].pszFlag;dwFlagIdx++) 
        {
            if (lstrcmpi(asFlags[dwFlagIdx].pszFlag,ppszArgv[dwIdx]) == 0) 
            {
                if (bInUrl) 
                {
                    MYDBG(("InitArgs() URL expected after AF_URL flag."));
                    goto done;
                }
                switch (asFlags[dwFlagIdx].dwFlag) 
                {
                    case AF_URL:
                        bInUrl = TRUE;
                        break;

                    case AF_NO_PROFILE:
                        if (pArgs->pszProfile) 
                        {
                            MYDBG(("InitArgs() argument number %u (%s) is invalid.",dwIdx,ppszArgv[dwIdx]));
                            goto done;
                        }
                        // fall through
                    default:
                        pArgs->dwAppFlags |= asFlags[dwFlagIdx].dwFlag;
                        break;
                }
                break;
            }
        }
        if (!asFlags[dwFlagIdx].pszFlag) 
        {
            if (bInUrl) 
            {
                if (pszUrl) 
                {
                    MYDBG(("InitArgs() argument number %u (%s) is invalid.",dwIdx,ppszArgv[dwIdx]));
                    goto done;
                }
                bInUrl = FALSE;
                pszUrl = (LPTSTR) CmMalloc((INTERNET_MAX_URL_LENGTH+1)*sizeof(TCHAR));
                if (!pszUrl) 
                {
                    goto done;
                }
                lstrcpy(pszUrl,ppszArgv[dwIdx]);

            } 
            else 
            {
                if (pArgs->pszProfile || (pArgs->dwAppFlags & AF_NO_PROFILE)) 
                {
                    MYDBG(("InitArgs() argument number %u (%s) is invalid.",dwIdx,ppszArgv[dwIdx]));
                    goto done;
                }
                /*
                ZeroMemory(szPath,sizeof(szPath));
                dwRes = GetFullPathName(ppszArgv[dwIdx],sizeof(szPath)/sizeof(TCHAR)-1,szPath,&pszFileInPath);
                MYDBGTST(!dwRes,("InitArgs() GetFullPathName() failed, GLE=%u.",GetLastError()));
                */
                //
                // the cmp filename is always in full path.
                //
                lstrcpy(szPath, ppszArgv[dwIdx]);
                pArgs->pszProfile = CmStrCpyAlloc(szPath);
                if (!pArgs->pszProfile) 
                {
                    goto done;
                }
                else
                {
                    //
                    // Set the current dir to the profile dir
                    // If the szPath contains only the file name, then
                    // assume that the current dir is the profile dir
                    //
                    char *pszTemp = NULL;
                    
                    pszTemp = CmStrrchr(szPath, TEXT('\\'));
                    if (NULL != pszTemp)
                    {
                        *pszTemp = TEXT('\0');
                        MYVERIFY(SetCurrentDirectory(szPath));
                    }
                }
            }
        }
    }
////////////////////////////////////////////////////////////////////////////////////////////
    if (pArgs->dwAppFlags & AF_VPN)
    {
        //
        //  They have asked for a VPN download.  Let's make sure that the only other flags
        //  they have specified are /LAN or /NO_DELETE
        //
        DWORD dwAllowedFlags = AF_VPN | AF_LAN | AF_NO_DELETE;
        if ((dwAllowedFlags | pArgs->dwAppFlags) != dwAllowedFlags)
        {
            CMASSERTMSG(FALSE, TEXT("InitArgs in cmdl32.exe -- VPN flag specified with other non supported flags, exiting."));
            goto done;
        }

        bRes = TRUE;
        CMTRACE(TEXT("InitArgs - /VPN flag detected going into VPN file download mode."));
        goto done;
    }
////////////////////////////////////////////////////////////////////////////////////////////
    if (bInUrl) 
    {
        MYDBG(("InitArgs() URL expected after AF_URL flag."));
        goto done;
    }
    
    if (!pArgs->pszProfile && !(pArgs->dwAppFlags & AF_NO_PROFILE)) 
    {
        MYDBG(("InitArgs() must use AF_NO_PROFILE if no profile given on command line."));
        goto done;
    }
    
    if (pArgs->pszProfile && pszUrl) 
    {
        MYDBG(("InitArgs() can't give both a profile and a URL on the command line."));
        goto done;
    }
    
    pArgs->pdaArgs = (DownloadArgs *) CmMalloc(sizeof(DownloadArgs));
    
    if (!pArgs->pdaArgs) 
    {
        goto done;
    }
    pArgs->dwArgsCnt++;
    
    if (!pszUrl) 
    {
        TCHAR szTmp[MAX_PATH+1];
        PhoneBookParseInfoStruct pbpisInfo;
        LPTSTR  pszSlash;
        LPTSTR  pszDot;
        int nVal = 0;

        if (!pArgs->pszProfile) 
        {
            MYDBG(("InitArgs() must give AF_URL on command line when AF_NO_PROFILE is given."));
            goto done;
        }

        // Get CMS file name

        GetPrivateProfileString(c_pszCmSection,
                                c_pszCmEntryCmsFile,
                                TEXT(""),
                                szTmp,
                                sizeof(szTmp)/sizeof(TCHAR)-1,
                                pArgs->pszProfile);
        if (!szTmp[0]) 
        {
            MYDBG(("InitArgs() [Connection Manager] CMSFile= entry not found in %s.",pArgs->pszProfile));
            goto done;
        }

        /*
        ZeroMemory(szPath,sizeof(szPath));
        dwRes = GetFullPathName(szTmp,sizeof(szPath)/sizeof(TCHAR)-1,szPath,&pszFileInPath);
        MYDBGTST(!dwRes,("InitArgs() GetFullPathName() failed, GLE=%u.",GetLastError()));
        */
        //
        // we simply append the relative path of the cms file to the profile dir to
        // construct the cms path.
        //
        lstrcat(szPath, TEXT("\\"));
        lstrcat(szPath, szTmp);

        pArgs->pdaArgs->pszCMSFile = CmStrCpyAlloc(szPath);
        if (!pArgs->pdaArgs->pszCMSFile) 
        {
            goto done;
        }
        
        // get the PBK filename from the CMS file
        GetPrivateProfileString(c_pszCmSectionIsp,
                                c_pszCmEntryIspPbFile,
                                TEXT(""),
                                szTmp,
                                sizeof(szTmp)/sizeof(TCHAR)-1,
                                pArgs->pdaArgs->pszCMSFile);
        if (!*szTmp) 
        {
            MYDBG(("InitArgs() [ISP Info] RegionFile= entry not found in %s.",pArgs->pdaArgs->pszCMSFile));
            pArgs->pdaArgs->pszPhoneBookName = CmStrCpyAlloc(TEXT(""));
        }
        else 
        {
            if (!(pArgs->pdaArgs->pszPbkFile = CmStrCpyAlloc(szTmp)))
                goto done;
    
            // get the phone book name
            if (!(pszSlash = CmStrrchr(pArgs->pdaArgs->pszPbkFile, TEXT('\\')))) 
            {
                MYDBG((TEXT("InitArgs() bad PBKFILE - no backslash.")));
                goto done;
            }

            if (!(pszDot = CmStrchr(pszSlash, TEXT('.')))) 
            {
                MYDBG((TEXT("InitArgs() bad PBKFILE - no dot.")));
                goto done;
            }

            *pszDot = TEXT('\0');
            
            if (!(pArgs->pdaArgs->pszPhoneBookName = CmStrCpyAlloc(pszSlash+1)))
                goto done;
            // restore the slash
            *pszDot = TEXT('.');
        }

    

        // get the PBR filename from the CMS file
        GetPrivateProfileString(c_pszCmSectionIsp,
                                c_pszCmEntryIspRegionFile,
                                TEXT(""),
                                szTmp,
                                sizeof(szTmp)/sizeof(TCHAR)-1,
                                pArgs->pdaArgs->pszCMSFile);
        MYDBGTST(!*szTmp, ("InitArgs() [ISP Info] RegionFile= entry not found in %s.",pArgs->pdaArgs->pszCMSFile));

        if (!(pArgs->pdaArgs->pszPbrFile = CmStrCpyAlloc(szTmp)))
            goto done;
    
        GetPrivateProfileString(c_pszCmSection,
                                c_pszVersion,
                                TEXT(""),
                                szTmp,
                                sizeof(szTmp)/sizeof(TCHAR)-1,
                                pArgs->pdaArgs->pszCMSFile);  
                                                                                    
        pArgs->pdaArgs->pszVerCurr = CmStrCpyAlloc(szTmp);
        
        if (!pArgs->pdaArgs->pszVerCurr) 
        {
            goto done;
        }
        
        pArgs->pdaArgs->pszUrl = (LPTSTR) CmMalloc((INTERNET_MAX_URL_LENGTH+1)*sizeof(TCHAR));
        
        if (!pArgs->pdaArgs->pszUrl) 
        {
            goto done;
        }
        
        ZeroMemory(&pbpisInfo,sizeof(pbpisInfo));
        pbpisInfo.dwSize = sizeof(pbpisInfo);
        pbpisInfo.pszURL = pArgs->pdaArgs->pszUrl;
        pbpisInfo.dwURL = INTERNET_MAX_URL_LENGTH;
        pbpisInfo.pfnRef = RefFunc;
        pbpisInfo.dwRefParam = (DWORD_PTR) pArgs;
        bRes = PhoneBookParseInfo(pArgs->pdaArgs->pszCMSFile,&pbpisInfo);
        
        if (!bRes) 
        {
            MYDBG(("InitArgs() PhoneBookParseInfo() failed, GLE=%u.",GetLastError()));
            goto done;
        }
        
        PhoneBookFreeFilter(pbpisInfo.pFilterA);
        PhoneBookFreeFilter(pbpisInfo.pFilterB);
        
        //
        // Bug fix #3064, a-nichb - HideDelay & DownloadDelay
        // Use nVal while retrieving entries, then assign to global
        //
                
        // Get Download delay

        nVal = GetPrivateProfileInt(c_pszCmSection,
                                    c_pszCmEntryDownloadDelay,
                                    DEFAULT_DELAY,
                                    pArgs->pdaArgs->pszCMSFile);
        
        // Convert to milliseconds

        pArgs->dwDownloadDelay = ((DWORD) nVal * (DWORD) 1000);
        MYDBG(("Download delay is %u millisseconds.", pArgs->dwDownloadDelay));

        // Get Hide delay 
        
        nVal = GetPrivateProfileInt(c_pszCmSection,
                                    c_pszCmEntryHideDelay,
                                    -1,
                                    pArgs->pdaArgs->pszCMSFile);
        //
        // Convert to milliseconds
        //
        if (nVal < 0)
        {
            pArgs->dwHideDelay = DEFAULT_HIDE;
        }
        else
        {
            pArgs->dwHideDelay = ((DWORD) nVal * (DWORD) 1000);
        }
        
        MYDBG(("Hide delay is %u milliseconds.", pArgs->dwHideDelay));

#if 0
/*
        // we don't support SuppressUpdates anymore

        if (GetPrivateProfileInt(c_pszCmSection, //13226
                                 TEXT("SuppressUpdates"),
                                 0,
                                 pArgs->pszProfile)) 
        {
            pArgs->dwAppFlags |= AF_NO_UPDATE;
        }
*/
#endif

    } 
    else 
    {
        pArgs->pdaArgs[0].pszUrl = pszUrl;
        pszUrl = NULL;
    }
    
    if (pArgs->pszProfile) 
    {
        TCHAR szTmp1[MAX_PATH+1];
        TCHAR szTmp2[MAX_PATH+1];

        pArgs->pszServiceName = (LPTSTR) CmMalloc((MAX_PATH+1)*sizeof(TCHAR));
        if (!pArgs->pszServiceName) 
        {
            goto done;
        }
        
        lstrcpy(szTmp1,pArgs->pdaArgs->pszCMSFile);
        
        if (CmStrrchr(szTmp1,'.')) 
        {
            *CmStrrchr(szTmp1,'.') = 0;
        }
        
        if (CmStrrchr(szTmp1,'\\')) 
        {
            lstrcpy(szTmp1,CmStrrchr(szTmp1,'\\')+1);
        }
        
        GetPrivateProfileString(c_pszCmSection,
                                c_pszCmEntryServiceName,
                                szTmp1,
                                pArgs->pszServiceName,
                                MAX_PATH,
                                pArgs->pdaArgs->pszCMSFile);
        
        // Get the name of the large icon
        
        GetPrivateProfileString(c_pszCmSection,
                                c_pszCmEntryBigIcon,
                                TEXT(""),
                                szTmp2,
                                sizeof(szTmp2)/sizeof(TCHAR)-1,
                                pArgs->pdaArgs->pszCMSFile);
        
        // If we have a name, load the large icon

        if (szTmp2[0]) 
        {
            pArgs->hIcon = CmLoadIcon(pArgs->hInst,szTmp2); 
        }

        // Get the name of the small icon

        GetPrivateProfileString(c_pszCmSection,
                                c_pszCmEntrySmallIcon,
                                TEXT(""),
                                szTmp2,
                                sizeof(szTmp2)/sizeof(TCHAR)-1,
                                pArgs->pdaArgs->pszCMSFile);
        
        // If we have a name, load the small icon

        if (szTmp2[0]) 
        {
            pArgs->hSmallIcon = CmLoadSmallIcon(pArgs->hInst,szTmp2); 
        }
    }
    
    //
    // If the name based icon loads were not successful, load defaults from EXE
    //

    if (!pArgs->hIcon) 
    {
        pArgs->hIcon = CmLoadIcon(pArgs->hInst, MAKEINTRESOURCE(IDI_APP));
    }
    
    if (!pArgs->hSmallIcon) 
    {
        pArgs->hSmallIcon = CmLoadSmallIcon(pArgs->hInst,MAKEINTRESOURCE(IDI_APP));
    }
    
    AddToUrl(pArgs->pdaArgs->pszUrl,pArgs->pdaArgs->pszVerCurr,pArgs->pdaArgs->pszPhoneBookName);

    bRes = TRUE;

done:
    
    // 
    // Cleanup
    // 
    
    if (pszUrl) 
    {
        CmFree(pszUrl);
    }

    if (pszCmdLine)
    {
        CmFree(pszCmdLine);
    }
    
    if (ppszArgv)
    {
        CmFree(ppszArgv);
    }
   
    return (bRes);
}

static BOOL InitApplication(ArgsStruct *pArgs) 
{
    WNDCLASSEX wcDlg;

    wcDlg.cbSize = sizeof(wcDlg);
    
    if (FALSE == GetClassInfoEx(NULL, WC_DIALOG, &wcDlg)) 
    {      
        MYDBG(("InitApplication() GetClassInfoEx() failed, GLE=%u.",GetLastError()));
        return (FALSE);                             
    }                                               

    wcDlg.lpszClassName = ICONNDWN_CLASS;
    wcDlg.hIcon = pArgs->hIcon;
    wcDlg.hIconSm = pArgs->hSmallIcon;
    wcDlg.hInstance = pArgs->hInst; 

    pArgs->hIcon = NULL;
    pArgs->hSmallIcon = NULL;     
    
    //
    // We have our class data setup, register the class
    //

    ATOM aRes = RegisterClassEx(&wcDlg);
    if (!aRes) 
    {  
        //
        // We may have more than one instance, so check the error case
        // 

        DWORD dwError = GetLastError();
        
        if (ERROR_ALREADY_EXISTS != dwError)
        {
            MYDBG(("InitApplication() RegisterClassEx() failed, GLE=%u.",GetLastError()));
            return (FALSE);
        }
    }

    MYDBG(("InitApplication() Class %s is registered.", wcDlg.lpszClassName));

    return TRUE;    
}

static BOOL InitInstance(ArgsStruct *pArgs) 
{
    pArgs->nMsgId = RegisterWindowMessage(c_pszIConnDwnMsg);
    if (!pArgs->nMsgId) 
    {
        MYDBG(("InitInstance() RegisterWindowMessage() failed."));
        return (FALSE);
    }
    
    return (TRUE);
}

//+----------------------------------------------------------------------------
//
// Func:    InitLogging
//
// Desc:    Initializes logging functionality for the CMDL32 module
//
// Args:    [pArgs] - args struct to pick up stuff from
//
// Return:  BOOL (TRUE for success)
//
// Notes:   IMPORTANT: note that CMDL32 is compiled Ansi whereas CMUTIL, which
//          contains the logging functionality, is Unicode.  CmLogFile exposes both
//          Ansi and Unicode variants for member functions that take strings.
//          However, the arguments passed to the Log calls are Ansi - they are
//          handled correctly by using %S (note, capital S) in the corresponding
//          format strings in cmlog.rc.
//
// History: 11-Apr-2001   SumitC      Created
//
//-----------------------------------------------------------------------------
static BOOL InitLogging(ArgsStruct * pArgs)
{
    BOOL    fAllUser   = TRUE;
    BOOL    fEnabled   = FALSE;
    DWORD   dwMaxSize  = 0;
    CHAR    szFileDir[MAX_PATH + 1] = {0};

    //
    //  First figure out if this profile is AllUsers or Single User
    //

    if (!OS_W9X)
    {
        HMODULE hShell32 = LoadLibraryExA("Shell32.dll", NULL, 0);
        
        if (hShell32)
        {
            typedef DWORD (WINAPI *pfnSHGetSpecialFolderPathASpec)(HWND, CHAR*, int, BOOL);

            pfnSHGetSpecialFolderPathASpec pfnSHGetSpecialFolderPathA;

            pfnSHGetSpecialFolderPathA = (pfnSHGetSpecialFolderPathASpec)
                                            GetProcAddress(hShell32,
                                                           "SHGetSpecialFolderPathA");

            if (pfnSHGetSpecialFolderPathA)
            {
                CHAR szPath[MAX_PATH+1];

                if (TRUE == pfnSHGetSpecialFolderPathA(NULL, szPath, CSIDL_APPDATA, FALSE))
                {
                    CHAR szProfile[MAX_PATH + 1];

                    lstrcpyn(szProfile, pArgs->pszProfile, MAX_PATH);
                    szProfile[ lstrlen(szPath) ] = '\0';
                    
                    if (0 == lstrcmpi(szProfile, szPath))
                    {
                        fAllUser = FALSE;
                    }
                }
            }

            FreeLibrary(hShell32);
        }
    }
    //
    //  To get Enabled, we have the code equivalent of IniBoth
    //
    
    fEnabled = c_fEnableLogging;

    BOOL bGotValueFromReg = FALSE;
    HKEY hkey;
    CHAR szRegPath[2 * MAX_PATH];

    lstrcpy(szRegPath, fAllUser ? "SOFTWARE\\Microsoft\\Connection Manager\\UserInfo\\" :
                                  "SOFTWARE\\Microsoft\\Connection Manager\\SingleUserInfo\\");

    if ( (lstrlen(szRegPath) + 1 + lstrlen(pArgs->pszServiceName) + 1) > (2 * MAX_PATH))
    {
        return FALSE;
    }
    
    lstrcat(szRegPath, "\\");
    lstrcat(szRegPath, pArgs->pszServiceName);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      szRegPath,
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hkey))
    {
        DWORD dwType;
        DWORD bEnabled;
        DWORD dwSize = sizeof(DWORD);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                             c_pszCmEntryEnableLogging,
                                             NULL,
                                             &dwType,
                                             (PBYTE) &bEnabled,
                                             &dwSize))
        {
            fEnabled = bEnabled ? TRUE : FALSE;
            bGotValueFromReg = TRUE;
        }
        
        RegCloseKey(hkey);        
    }

    //
    //  To *exactly* mimic pIniBoth we should check the .CMP here too.  However,
    //  the moment the user brings up the UI we will write this value to the
    //  registry if it was in the .CMP.  So, skip the CMP step.
    //
    if (FALSE == bGotValueFromReg)
    {
        fEnabled = (BOOL ) GetPrivateProfileInt(c_pszCmSection,
                                                c_pszCmEntryEnableLogging,
                                                c_fEnableLogging,
                                                pArgs->pdaArgs->pszCMSFile);
    }

    //
    //  To get MaxSize, we have the code equivalent of IniService
    //
    dwMaxSize = GetPrivateProfileInt(c_pszCmSectionLogging,
                                     c_pszCmEntryMaxLogFileSize,
                                     c_dwMaxFileSize,
                                     pArgs->pdaArgs->pszCMSFile);

    //
    //  LogFileDirectory is also obtained via IniService
    //
    GetPrivateProfileString(c_pszCmSectionLogging,
                            c_pszCmEntryLogFileDirectory,
                            c_szLogFileDirectory,
                            szFileDir,
                            sizeof(szFileDir) / sizeof(TCHAR) - 1,
                            pArgs->pdaArgs->pszCMSFile);

    //
    //  Use these values to initialize logging
    //
    pArgs->Log.Init(pArgs->hInst, fAllUser, pArgs->pszServiceName);
    
    pArgs->Log.SetParams(fEnabled, dwMaxSize, szFileDir);
    if (pArgs->Log.IsEnabled())
    {
        pArgs->Log.Start(FALSE);        // FALSE => no banner
    }
    else
    {
        pArgs->Log.Stop();
    }

    return TRUE;
}

int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR , int ) 
{
    MYDBG(("====================================================="));
    MYDBG((" CMDL32.EXE - LOADING - Process ID is 0x%x ", GetCurrentProcessId()));
    MYDBG(("====================================================="));

    INT_PTR iRes = 1;    
    ArgsStruct asArgs;
    DWORD dwIdx = 0;
    BOOL bRes = FALSE;
   
    //
    // Initialize app-wide arguments
    //

    ZeroMemory(&asArgs,sizeof(asArgs));
    
    //
    // We can't use hInst param if we're not linked with libc.
    // libc uses GetModuleHandle(NULL), so we will too.
    //
    
    asArgs.hInst = GetModuleHandleA(NULL); //  hInst;
    MYDBGTST(NULL == asArgs.hInst, ("WinMain - GetModuleHandle(NULL) returned 0x%x, GLE=%u.", asArgs.hInst, GetLastError()));

#ifdef EXTENDED_CAB_CONTENTS

    asArgs.dwRebootCookie = MyNeedRebootInit(&asArgs); //must init flag or else will ask for reboot with no args or other errors

#endif // EXTENDED_CAB_CONTENTS

    if (!InitArgs(&asArgs)) 
    {
        goto done;
    }

///////////////////////////////////////////////////////////////////////////////////
    if (asArgs.dwAppFlags & AF_VPN)
    {
        iRes = UpdateVpnFileForProfile(asArgs.pszProfile);
        goto done;
    }
///////////////////////////////////////////////////////////////////////////////////
    // Set UPDATE flag

//      if (asArgs.dwAppFlags & AF_NO_UPDATE) 
//      {
//              MYDBG(("WinMain() user has disabled updates."));
//              goto done;
//      }

    // Initialize the app.

    if (!InitApplication(&asArgs)) 
    {
        goto done;
    }

    // Setup this instance

    if (!InitInstance(&asArgs)) 
    {
        goto done;
    }

    InitCommonControls();

#ifdef EXTENDED_CAB_CONTENTS    

    asArgs.dwRebootCookie = MyNeedRebootInit(&asArgs);

#endif // EXTENDED_CAB_CONTENTS 

    //
    //  Initialize Logging
    //
    if (!InitLogging(&asArgs)) 
    {
        goto done;
    }
    
    iRes = DialogBoxParam(asArgs.hInst,MAKEINTRESOURCE(IDD_MAIN),NULL, (DLGPROC)MainDlgProc,(LPARAM) &asArgs);

    MYDBGTST(iRes == -1, ("WinMain() - DialogBoxParam(0x%x, 0x%x, NULL, MainDlgProc, 0x%x) - failed",asArgs.hInst, MAKEINTRESOURCE(IDD_MAIN), &asArgs));

done:

    // Close any handles created during WININET session

    for (dwIdx=0;dwIdx<asArgs.dwArgsCnt;dwIdx++) 
    {
        DownloadArgs *pdaArgs;

        pdaArgs = asArgs.pdaArgs + dwIdx;
        
        if (pdaArgs->hReq) 
        {
            bRes = InternetCloseHandle(pdaArgs->hReq);
            MYDBGTST(!bRes,("WinMain() InternetCloseHandle(asArgs.pdaArgs[%u].hReq) failed, GLE=%u.",dwIdx,GetLastError()));
            pdaArgs->hReq = NULL;
        }

        if (pdaArgs->hConn) 
        {
            bRes = InternetCloseHandle(pdaArgs->hConn);
            MYDBGTST(!bRes,("WinMain() InternetCloseHandle(asArgs.pdaArgs[%u].hConn) failed, GLE=%u.",dwIdx,GetLastError()));
            pdaArgs->hConn = NULL;
        }
        
        if (pdaArgs->hInet) 
        {
            bRes = InternetCloseHandle(pdaArgs->hInet);
            MYDBGTST(!bRes,("WinMain() InternetCloseHandle(asArgs.pdaArgs[%u].hInet) failed, GLE=%u.",dwIdx,GetLastError()));
            pdaArgs->hInet = NULL;
        }
    }
    
    // Wait for thread to terminate

    if (asArgs.ahHandles[IDX_INETTHREAD_HANDLE]) 
    {
        long lRes;

        lRes = WaitForSingleObject(asArgs.ahHandles[IDX_INETTHREAD_HANDLE],45*1000);
        MYDBGTST(lRes!=WAIT_OBJECT_0,("WinMain() WaitForSingleObject() failed, GLE=%u.",lRes));
    }

    // Free profile and service data

    if (asArgs.pszProfile) 
    {
        CmFree(asArgs.pszProfile);
        asArgs.pszProfile = NULL;
    }
    
    if (asArgs.pszServiceName) 
    {
    CmFree(asArgs.pszServiceName);
    asArgs.pszServiceName = NULL;
    }
    
    // Cleanup for each argument
    
    for (dwIdx=0;dwIdx<asArgs.dwArgsCnt;dwIdx++) 
    {
        DownloadArgs *pdaArgs;
        UINT i;

        pdaArgs = asArgs.pdaArgs + dwIdx;
        CmFreeIndirect(&pdaArgs->pszCMSFile);
        CmFreeIndirect(&pdaArgs->pszPbkFile);
        CmFreeIndirect(&pdaArgs->pszPbrFile);
        CmFreeIndirect(&pdaArgs->pszUrl);
        CmFreeIndirect(&pdaArgs->pszVerCurr);
        CmFreeIndirect(&pdaArgs->pszVerNew);
        //CmFreeIndirect(&pdaArgs->pszNewPbrFile);
        CmFreeIndirect(&pdaArgs->pszPhoneBookName);

        if (pdaArgs->psUrl) 
        {
            CmFree(pdaArgs->psUrl);
            pdaArgs->psUrl = NULL;
        }

        for (i=0; i<pdaArgs->dwNumFilesToProcess; i++)
            CmFree(pdaArgs->rgfpiFileProcessInfo[i].pszFile);
        
        CmFree(pdaArgs->rgfpiFileProcessInfo);
    
        // As long as AF_NO_DELETE is NOT set, clean up temp files and dirs

        if (!(asArgs.dwAppFlags & AF_NO_DELETE)) 
        {
            if (pdaArgs->szFile[0]) 
            {
                bRes = DeleteFile(pdaArgs->szFile);
                MYDBGTST(!bRes,("WinMain() DeleteFile(asArgs[pdaArgs[%lu].szFile=%s) failed, GLE=%u.",dwIdx,pdaArgs->szFile,GetLastError()));
            }
            
            if (pdaArgs->szCabDir[0]) 
            {
                ZapDir(pdaArgs->szCabDir);
            }
        }
    }
    
    // Release download args

    if (asArgs.pdaArgs) 
    {
        CmFree(asArgs.pdaArgs);
        asArgs.pdaArgs = NULL;
    }
    
    for (dwIdx=0;dwIdx<sizeof(asArgs.ahHandles)/sizeof(asArgs.ahHandles[0]);dwIdx++) 
    {
        if (asArgs.ahHandles[dwIdx]) 
        {
            bRes = CloseHandle(asArgs.ahHandles[dwIdx]);
            MYDBGTST(!bRes,("WinMain() CloseHandle(asArgs.ahHandles[%u]) failed, GLE=%u.",dwIdx,GetLastError()));
            asArgs.ahHandles[dwIdx] = NULL;
        }
    }

#ifdef EXTENDED_CAB_CONTENTS    

    // If we need a re-boot, prompt the user

    if (MyNeedReboot(&asArgs,asArgs.dwRebootCookie)) 
    {
        LPTSTR pszCaption;
        LPTSTR pszText;
        int iMBRes;

        pszText = CmFmtMsg(asArgs.hInst,IDMSG_REBOOT_TEXT);
        pszCaption = CmFmtMsg(asArgs.hInst,IDMSG_REBOOT_CAPTION);
        iMBRes = MessageBoxEx(NULL,pszText,pszCaption,MB_YESNO|MB_ICONEXCLAMATION|MB_DEFBUTTON2,LANG_USER_DEFAULT);
        MYDBGTST(!iMBRes,("WinMain() MessageBoxEx() failed, GLE=%u.",GetLastError()));
        CmFree(pszText);
        CmFree(pszCaption);
    
        if (iMBRes == IDYES) 
        {
            bRes = ExitWindowsEx(EWX_REBOOT,0);
            MYDBGTST(!bRes,("WinMain() ExitWindowsEx() failed, GLE=%u.",GetLastError()));
        }
    }

    // If advpack was used, release it

    if (asArgs.hAdvPack) 
    {
        bRes = FreeLibrary(asArgs.hAdvPack);
        MYDBGTST(!bRes,("WinMain() FreeLibrary() failed, GLE=%u.",GetLastError()));
        asArgs.hAdvPack = NULL;
    }

#endif // EXTENDED_CAB_CONTENTS   

    //
    //  Uninitialize logging
    //
    asArgs.Log.DeInit();

    //
    // the C runtine uses ExitProcess() to exit.
    //

    MYDBG(("====================================================="));
    MYDBG((" CMDL32.EXE - UNLOADING - Process ID is 0x%x ", GetCurrentProcessId()));
    MYDBG(("====================================================="));

    ExitProcess((UINT)iRes);
  
    return ((int)iRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmgr\cmfmtstr.h ===
//+----------------------------------------------------------------------------
//
// File:     cmfmtstr.h
//
// Module:   CMMGR32.EXE
//
// Synopsis: String IDs for cmfmtstr.rc
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#define IDMSG_NOCMDLINE_MSG             11000
#define IDMSG_NOCMS_MSG					11101
#define IDMSG_APP_TITLE                 11102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmgr\icm.h ===
//+----------------------------------------------------------------------------
//
// File:     icm.h
//
// Module:   CMMGR32.EXE
//
// Synopsis: Main header for cmmgr32.exe
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#ifndef _ICM_INC
#define _ICM_INC

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <ctype.h>
#include <wchar.h>
#include <raserror.h>
#include <rasdlg.h>
#include <shlobj.h>

#include "cmras.h"
#include "cm_def.h"
#include "cmdebug.h"
#include "cmutil.h"
#include "cmdial.h"

#include "base_str.h"
#include "mgr_str.h"
#include "reg_str.h"

#include "uapi.h"

#include "cmfmtstr.h"

#ifdef __cplusplus
extern "C" {
#endif

extern HINSTANCE g_hInst;

#ifdef __cplusplus
}
#endif

typedef enum _CMDLN_STATE
{
    CS_END_SPACE,   // done handling a space
    CS_BEGIN_QUOTE, // we've encountered a begin quote
    CS_END_QUOTE,   // we've encountered a end quote
    CS_CHAR,        // we're scanning chars
    CS_DONE
} CMDLN_STATE;

//
// External prototypes from util.cpp
//

BOOL GetProfileInfo(
    LPTSTR pszCmpName,
    LPTSTR pszServiceName
);

BOOL IsCmpPathAllUser(
    LPCTSTR pszCmp
);


#endif // _ICM_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmgr\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:	 cmmaster.h
//
// Module:	 CMMGR32.EXE
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 quintinb    Created header    08/17/99
//
//+----------------------------------------------------------------------------
#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include "icm.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmgr\cmmgr.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmmgr.cpp
//
// Module:   CMMGR32.EXE
//
// Synopsis: Main file for the CM downlevel executable.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb    Created header    08/17/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

// 
// Common CM includes
//

#include "cmtiming.h"

BOOL InitArgs(
    LPTSTR    pszCmdln,
    LPTSTR    pszCmp,
    PDWORD    pdwFlags
);

void CheckCmdArg(
    LPTSTR  pszToken, 
    LPTSTR  pszCmp, 
    PDWORD  pdwFlags
);
                    


HINSTANCE   g_hInst;


//+---------------------------------------------------------------------------
//
//  Function:   InitArgs
//
//  Synopsis:   Parses the command line arguments, return the connectoid name if 
//              "dialing with connectoid"
//
//  Arguments:  pArgs           - Pointer to global args struct
//              nArgC           - number of command line arguments
//              ppszArgv        - command arguments
//              pszConnectoid   - Connectoid name as found on command line
//
//  Returns:    TRUE        if succeed
//              FALSE       otherwise
//
//  History:    byao        Modified  5/8/97
//                          Added handler for 'dialing with connectoid'
//----------------------------------------------------------------------------
BOOL InitArgs(
    LPTSTR    pszCmdln,
    LPTSTR    pszCmp,
    PDWORD    pdwFlags
) 
{
    LPTSTR  pszCurr;
    LPTSTR  pszToken;

    CMDLN_STATE state;
    
    // Parse the command line.

    state = CS_CHAR;
    pszCurr = pszToken = pszCmdln;

    do
    {
        switch (*pszCurr)
        {
            case TEXT(' '):
                if (state == CS_CHAR)
                {
                    //
                    // we found a token
                    //
                    *pszCurr = TEXT('\0');
                    CheckCmdArg(pszToken, pszCmp, pdwFlags);
                    *pszCurr = TEXT(' ');
                    pszCurr = pszToken = CharNextU(pszCurr);
                    state = CS_END_SPACE;
                    continue;
                }
                else if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    pszToken = CharNextU(pszToken);
                }
                break;

            case TEXT('\"'):
                if (state == CS_BEGIN_QUOTE)
                {
                    //
                    // we found a token
                    //
                    *pszCurr = TEXT('\0');

                    //
                    // skip the opening quote
                    //
                    pszToken = CharNextU(pszToken);
                    CheckCmdArg(pszToken, pszCmp, pdwFlags);
                    *pszCurr = TEXT('\"');
                    pszCurr = pszToken = CharNextU(pszCurr);
                    state = CS_END_QUOTE;
                    continue;
                }
                else
                {
                    state = CS_BEGIN_QUOTE;
                }
                break;

            case TEXT('\0'):
                if (state != CS_END_QUOTE)
                {
                    CheckCmdArg(pszToken, pszCmp, pdwFlags);
                }
                state = CS_DONE;
                break;

            default:
                if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    state = CS_CHAR;
                }
                break;
        }

        pszCurr = CharNextU(pszCurr);
    } while (state != CS_DONE);

    return TRUE;
}



//
// determines the cmdline parameter.
//
void CheckCmdArg(
    LPTSTR  pszToken, 
    LPTSTR  pszCmp, 
    PDWORD  pdwFlags
)
{
    struct 
    {
        LPCTSTR pszArg;
        DWORD dwFlag;
    } ArgTbl[] = {
                  {TEXT("/settings"),FL_PROPERTIES},
                  {TEXT("/autodial"),FL_AUTODIAL},
                  {TEXT("/unattended"), FL_UNATTENDED},  // unattended dial
                  {NULL,0}};
    
    CMTRACE1(TEXT("Command line argument %s"), pszToken);

    //
    // Look through our table for a match and set flags accordingly.
    //
    
    for (size_t nIdx=0;ArgTbl[nIdx].pszArg;nIdx++) 
    {
        if (lstrcmpiU(pszToken, ArgTbl[nIdx].pszArg) == 0) 
        {
            MYDBGASSERT(!(*pdwFlags & ArgTbl[nIdx].dwFlag)); // only one of each please
            CMTRACE2(TEXT("InitArgs() parsed option %s, flag=0x%x."), pszToken, ArgTbl[nIdx].dwFlag);

            *pdwFlags |= ArgTbl[nIdx].dwFlag;

            break;
        }
    }

    // 
    // If table is exhausted, then its a data argument.
    //

    if (!ArgTbl[nIdx].pszArg) 
    {
        // 
        // If this is the first data argument then it must be a profile 
        // source, either a .CMP file, a "connectoid" (.CON file).
        //
        lstrcpyU(pszCmp, pszToken);
    }

    return;
}

//+----------------------------------------------------------------------------
//
// Function:  WinMain
//
// Synopsis:  Main entry point of the exe
//
// History:   byao      Modified        05/06/97    
//                          handle 'dialing with connectoid' and 'unattended dialing'
//
//            quintinb  Modified        05/12/99
//                          bAllUsers for MSN to use cmmgr32.exe on both NT5 and win98SR1
//
//+----------------------------------------------------------------------------

int WINAPI WinMain(HINSTANCE hInst, 
                   HINSTANCE hPrevInst, 
                   LPSTR /*pszCmdLine*/, 
                   int /*iCmdShow*/) 
{

    //
    //  First Things First, lets initialize the U Api's
    //
    if (!InitUnicodeAPI())
    {
        //
        //  Without our U api's we are going no where.  Bail.
        //
        MessageBox(NULL, TEXT("Cmmgr32.exe Initialization Error:  Unable to initialize Unicode to ANSI conversion layer, exiting."),
                   TEXT("Connection Manager"), MB_OK | MB_ICONERROR);
        return FALSE;
    }

    LPTSTR pszCmdLine;

    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMMGR32.EXE - LOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE(TEXT("====================================================="));

    CM_SET_TIMING_INTERVAL("WinMain");

    //
    // Declare local vars
    //

    TCHAR   szServiceName[RAS_MaxEntryName];    // service name
    TCHAR   szCmp[MAX_PATH];                    // cmp filename
    LPTSTR  pszCL;
    DWORD   dwExitCode = ERROR_SUCCESS;
    DWORD   dwFlags = 0;
    DWORD   dwSize;   
    BOOL    bAllUsers; 
    LPCMDIALINFO lpCmInfo = NULL;

#ifndef UNICODE
    LPWSTR pszwServiceName;
#endif

    //
    // we can't use hInst if we're linked with libc.  libc uses GetModuleHandle(NULL).
    //
    g_hInst = GetModuleHandleA(NULL);

    //
    //  Expand any environment strings in the command line
    //


    dwSize = lstrlenU(GetCommandLine()) + 1;

    do
    {
        pszCmdLine = (LPTSTR)CmMalloc(sizeof(WCHAR)*dwSize);

        if (pszCmdLine)
        {
            DWORD dwRequiredSize = ExpandEnvironmentStringsU(GetCommandLine(), pszCmdLine, dwSize);
            if (0 == dwRequiredSize)
            {
                CMASSERTMSG(FALSE, TEXT("ExpandEnvironmentStrings Failed, exiting."));
                goto done;
            }
            else if (dwRequiredSize > dwSize)
            {
                //
                //  Buffer not large enough.  Try again.
                //
                dwSize = dwRequiredSize;
                CmFree(pszCmdLine);
            }
            else
            {
                //
                //  It worked and was the correct size
                //
                break;
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("Unable to CmMalloc Memory for the command line string, exiting."));
            goto done;            
        }

    } while(1);
    
    //
    //  Now process the command line
    //
    CmStrTrim(pszCmdLine);

    pszCL = pszCmdLine;

    //
    // Scan, and skip over, subsequent characters until
    // another double-quote or a null is encountered.
    //
    if (*pszCL == TEXT('\"')) 
    {
        while (*(++pszCL) != TEXT('\"')
            && *pszCL) 
            ;

        //
        // If we stopped on a double-quote (usual case), skip
        // over it.
        //
        if ( *pszCL == TEXT('\"') )
            pszCL++;
    }

    //
    // skip the spaces
    //
    while (*pszCL && *pszCL == TEXT(' '))
        pszCL++;

    //
    // Return here if command line is empty - ALL PLATFORMS !!!!!!!
    //

    if (pszCL[0] == TEXT('\0'))
    {
        LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_NOCMDLINE_MSG);
        LPTSTR pszTitle = CmFmtMsg(g_hInst, IDMSG_APP_TITLE);
        MessageBoxEx(NULL,pszMsg, pszTitle, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);//13309
        CmFree(pszTitle);
        CmFree(pszMsg);
        
        dwExitCode = ERROR_WRONG_INFO_SPECIFIED;
        goto done;
    }

    //
    // Parse the command line options: Basically, this is to set 
    // commandline option flags, as well as the profile filename
    //
    //
    // without libc, pszCmdLine in WinMain is empty.
    //
    if (!InitArgs(pszCL, szCmp, &dwFlags))
    {
        dwExitCode = GetLastError();
        goto done;
    }

    //
    // Get the service name from the CMP
    // 

    if (!GetProfileInfo(szCmp, szServiceName))
    {
        CMTRACE(TEXT("WinMain() can't run without a profile on the command line."));
        LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_NOCMS_MSG);
        LPTSTR pszTitle = CmFmtMsg(g_hInst, IDMSG_APP_TITLE);
        MessageBoxEx(NULL, pszMsg, pszTitle, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);//13309       
        CmFree(pszMsg);
        CmFree(pszTitle);
        
        dwExitCode = ERROR_WRONG_INFO_SPECIFIED;           
        goto done;
    }

    //
    // Always set the FL_DESKTOP flag when CMMGR is calling, it is more 
    // efficient than checking the module filename inside CmCustomDialDlg
    //

    if (!(dwFlags & FL_DESKTOP))
    {
        dwFlags |= FL_DESKTOP;
    }

    //
    // Call CMDIAL as appropriate
    // 
    
    lpCmInfo = (LPCMDIALINFO) CmMalloc(sizeof(CMDIALINFO));
   
    if (NULL == lpCmInfo)
    {
        dwExitCode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    lpCmInfo->dwCmFlags = dwFlags;

    //
    // Determine if this is an all user call based upon the path. 
    // Thus we can support single-user profiles on NT5.
    //

    bAllUsers = IsCmpPathAllUser(szCmp);

    CmCustomDialDlg(NULL, 
                bAllUsers ? RCD_AllUsers : RCD_SingleUser, 
                NULL,           
                szServiceName, 
                NULL, 
                NULL, 
                NULL,
                lpCmInfo);

done:   

    UnInitUnicodeAPI();
    
    CmFree(pszCmdLine);
    CmFree(lpCmInfo);

    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMMGR32.EXE - UNLOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE(TEXT("====================================================="));

    //
    // the C runtine uses ExitProcess() to exit.
    //

    ExitProcess((UINT)dwExitCode);
   
    return ((int)dwExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmgr\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:     util.cpp
//
// Module:   CMMGR32.EXE
//
// Synopsis: Utility functions for cmmgr32.exe
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   created Header  08/16/99
//
//+----------------------------------------------------------------------------


#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
//  Function    GetProfileInfo
//
//  Synopsis    get the service name from cms
//              
//
//  Arguments   pszCmpName      the cmp file name.  Can be in one of the following
//                              3 formats:
//
//                              1. relative paths without the extension(e.g. msn, cm\msn)
//                              2. relative path with the extension(e.g. msn.cmp, cm\msn.cmp)
//                              3. full path(e.g. c:\cm\msn.cmp)
//
//              pszServiceName  the output buffer for the service name(ServiceName).
//                              must be at least RAS_MaxEntryName.
//
//  Returns     BOOL    TRUE=success, FALSE=failure
//
//-----------------------------------------------------------------------------

BOOL GetProfileInfo(
    LPTSTR pszCmpName,
    LPTSTR pszServiceName
) 
{
    LPTSTR pszTmp;
    LPTSTR pszDot;
    LPTSTR pszSlash;
    LPTSTR pszColon;
    
    TCHAR szFileName[MAX_PATH + 1];
    TCHAR szCmsFile[MAX_PATH + 1];
    TCHAR szPath[MAX_PATH + 1];

    lstrcpynU(szFileName, pszCmpName, sizeof(szFileName)/sizeof(TCHAR)-1);

    pszDot = CmStrrchr(szFileName, TEXT('.'));
    pszSlash = CmStrrchr(szFileName, TEXT('\\'));
    pszColon = CmStrrchr(szFileName, TEXT(':'));
    
    if ((pszSlash >= pszDot) && (pszColon >= pszDot)) 
    {
        //
        // The argument doesn't have an extension, so we'll include one.
        //
        lstrcatU(szFileName, TEXT(".cmp"));
    }

    //
    // We need to change our current dir to read the profiles.
    // If we found a slash, it's either a UNC path, relative path, or
    // a full path. Use it to set the current dir. Otherwise use we 
    // assume that the profile is local and use the application path.
    //

    if (pszSlash)
    {
        *pszSlash = TEXT('\0');
        MYVERIFY(SetCurrentDirectoryU(szFileName));
        //
        // restore the slash
        //
        *pszSlash = TEXT('\\');
    }
    else
    {
        //
        // Assumes its local, use app path for current dir
        //
               
        TCHAR szCurrent[MAX_PATH];
    
        if (GetModuleFileNameU(NULL, szCurrent, MAX_PATH - 1))
        {            
            pszSlash = CmStrrchr(szCurrent, TEXT('\\'));
            
            MYDBGASSERT(pszSlash);

            if (pszSlash)
            {
                *pszSlash = TEXT('\0');  

                MYVERIFY(SetCurrentDirectoryU(szCurrent));
            }
        }
    }

    //
    // test whether this is a valid cmp
    //
    if (SearchPathU(NULL, szFileName, NULL, MAX_PATH, szPath, &pszTmp))
    {
        BOOL bReturn = FALSE;
        
        //
        // szPath should now be a full path.
        //

        //
        // first get the CMS file path from the cmp file.
        //

        GetPrivateProfileStringU(c_pszCmSection, c_pszCmEntryCmsFile, TEXT(""), szCmsFile, MAX_PATH, szPath);

        //
        // construct the cms file path.  the cms file path obtained from the cmp file 
        // is a relative path.
        //
        pszTmp = CmStrrchr(szPath, TEXT('\\'));
        if (NULL != pszTmp)
        {
            //
            // Move past the '\\'
            //
            pszTmp = CharNextU(pszTmp);
            
            if (NULL != pszTmp)
            {
                lstrcpyU(pszTmp, szCmsFile); 
                GetPrivateProfileStringU(c_pszCmSection, c_pszCmEntryServiceName, TEXT(""), 
                                        pszServiceName, MAX_PATH, szPath);              
                //
                // If the .cms file doesn't exist or is corrupt
                // the value of pszService will be ""
                //
                if (TEXT('\0') != *pszServiceName)
                {
                    bReturn = TRUE;
                }
            }
        }

        return bReturn;
    }
    else
    {
        //
        // there isn't much we can do here
        //
        *pszServiceName = TEXT('\0');

        return FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Function    IsCmpPathAllUser
//
//  Synopsis    If this function is executed on NT5, then it checks to see if
//              the passed in CMP file path has the users APP_DATA directory as
//              part of the path.  If so, then it considers the profile to be
//              single user.  Otherwise it returns that the profile is all user.
//              If the function encounters an error it returns that the profile
//              is all user (that is considered the default case).
//              
//
//  Arguments   pszCmp          the cmp file name
//
//  Returns     BOOL    TRUE == All User Profile, FALSE == Single User profile
//
//  History     quintinb    Created     05/12/99
//
//-----------------------------------------------------------------------------
BOOL IsCmpPathAllUser(LPCTSTR pszCmp)
{
    BOOL bReturn = TRUE;

    //
    //  If we get an invalid input parameter then just assume that it is
    //  All User.  On the other hand, if the OS isn't NT5, then we are
    //  All User so there is no need to check the path.  If we are on
    //  NT5 and the beginning of the cmp path matches the users
    //  Application data dir, then we have a single user profile and
    //  should return false.
    //

    if ((NULL != pszCmp) && (TEXT('\0') != pszCmp[0]) && OS_NT5)
    {

        //
        //  Load shell32 here so that we can call the shell to find out
        //  the path to the Application Data directory.
        //

        typedef HRESULT (WINAPI *pfnSHGetSpecialFolderLocationSpec)(HWND, int, LPITEMIDLIST*);
        typedef BOOL (WINAPI *pfnSHGetPathFromIDListSpec)(LPCITEMIDLIST, LPTSTR);
        typedef HRESULT (WINAPI *pfnSHGetMallocSpec)(LPMALLOC *);

        pfnSHGetSpecialFolderLocationSpec pfnSHGetSpecialFolderLocation;
        pfnSHGetMallocSpec pfnSHGetMalloc;
        pfnSHGetPathFromIDListSpec pfnSHGetPathFromIDList;

        HMODULE hShell32 = LoadLibraryExA("Shell32.dll", NULL, 0);

        if (hShell32)
        {
            pfnSHGetSpecialFolderLocation = (pfnSHGetSpecialFolderLocationSpec)GetProcAddress(hShell32, 
                "SHGetSpecialFolderLocation");

            pfnSHGetMalloc = (pfnSHGetMallocSpec)GetProcAddress(hShell32, "SHGetMalloc");

#ifdef UNICODE
            pfnSHGetPathFromIDList = (pfnSHGetPathFromIDListSpec)GetProcAddress(hShell32,
                "SHGetPathFromIDListW");
#else
            pfnSHGetPathFromIDList = (pfnSHGetPathFromIDListSpec)GetProcAddress(hShell32,
                "SHGetPathFromIDListA");
#endif

            if (pfnSHGetSpecialFolderLocation && pfnSHGetPathFromIDList && pfnSHGetMalloc)
            {
                LPITEMIDLIST pidl;
                TCHAR szAppDataDir[MAX_PATH+1];
                TCHAR szTemp[MAX_PATH+1];

                HRESULT hr = pfnSHGetSpecialFolderLocation(NULL,
                                                           CSIDL_APPDATA,
                                                           &pidl);    
                if (SUCCEEDED(hr))
                {
                    if (pfnSHGetPathFromIDList(pidl, szAppDataDir))
                    {
                        UINT uiLen = lstrlenU(szAppDataDir) + 1;
                        lstrcpynU(szTemp, pszCmp, uiLen);

                        if (0 == lstrcmpiU(szAppDataDir, szTemp))
                        {
                            bReturn = FALSE;
                        }
                    }

                    LPMALLOC pMalloc;
                    if (SUCCEEDED(pfnSHGetMalloc(&pMalloc)))
                    {
                        pMalloc->Free(pidl);
                        MYVERIFY(SUCCEEDED(pMalloc->Release()));
                    }
                }            
            }

            FreeLibrary(hShell32);
        }
    }

    //
    //  Figure out what the user directory of the current user is.  We can compare this
    //  against the directory of the phonebook and see if we have a private user
    //  profile or an all user profile.

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Precompiled header for cmmon
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------
#include <windows.h>
#include "CmDebug.h"
#include "CmUtil.h"
#include "shelldll.h"
#include "Base_Str.h"
#include "Dl_Str.h"
#include "Mgr_Str.h"
#include "Mon_Str.h"

#include "uapi.h"
#include "pwutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\arrayptr.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ArrayPtr.h	 
//
// Module:   CMMON32.EXE
//
// Synopsis: Implement class CPtrArray, a array of void*, which grows dynamicly
//           This class is exactly the same as the one defined by MFC.
//           Help on the class also comes with vc help
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fengsun Created    2/17/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ArrayPtr.h"

CPtrArray::CPtrArray()
{
   m_pData = NULL;
   m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CPtrArray::~CPtrArray()
{
   ASSERT_VALID(this);

   delete [] (BYTE*)m_pData;
}

void CPtrArray::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
   ASSERT_VALID(this);
   MYDBGASSERT(nNewSize >= 0);

   if (nGrowBy != -1)
      m_nGrowBy = nGrowBy;  // set new size

   if (nNewSize == 0)
   {
      // shrink to nothing 
      delete [] (BYTE*)m_pData;
      m_pData = NULL;
      m_nSize = m_nMaxSize = 0;
   }
   else if (m_pData == NULL)
   {
      // create one with exact size
      m_pData = (void**) new BYTE[nNewSize * sizeof(void*)];

      if (m_pData)
	  {
	     memset(m_pData, 0, nNewSize * sizeof(void*));  // zero fill

		 m_nSize = m_nMaxSize = nNewSize;
	  }
   }
   else if (nNewSize <= m_nMaxSize)
   {
      // it fits
      if (nNewSize > m_nSize)
      {
         // initialize the new elements

         memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

      }

      m_nSize = nNewSize;
   }
   else
   {
      // Otherwise grow array
      int nNewMax;
      if (nNewSize < m_nMaxSize + m_nGrowBy)
         nNewMax = m_nMaxSize + m_nGrowBy;  // granularity
      else
         nNewMax = nNewSize;  // no slush

      void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)];

      // copy new data from old
      memcpy(pNewData, m_pData, m_nSize * sizeof(void*));

      // construct remaining elements
      MYDBGASSERT(nNewSize > m_nSize);

      memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));


      // get rid of old stuff (note: no destructors called)
      delete [] (BYTE*)m_pData;
      m_pData = pNewData;
      m_nSize = nNewSize;
      m_nMaxSize = nNewMax;
   }
}

void CPtrArray::FreeExtra()
{
   ASSERT_VALID(this);

   if (m_nSize != m_nMaxSize)
   {
      // shrink to desired size
      void** pNewData = NULL;
      if (m_nSize != 0)
      {
         pNewData = (void**) new BYTE[m_nSize * sizeof(void*)];
         // copy new data from old
         memcpy(pNewData, m_pData, m_nSize * sizeof(void*));
      }

      // get rid of old stuff (note: no destructors called)
      delete [] (BYTE*)m_pData;
      m_pData = pNewData;
      m_nMaxSize = m_nSize;
   }
}

/////////////////////////////////////////////////////////////////////////////

void CPtrArray::SetAtGrow(int nIndex, void* newElement)
{
   ASSERT_VALID(this);
   MYDBGASSERT(nIndex >= 0);

   if (nIndex >= m_nSize)
      SetSize(nIndex+1);
   m_pData[nIndex] = newElement;
}

void CPtrArray::InsertAt(int nIndex, void* newElement, int nCount /*=1*/)
{
   ASSERT_VALID(this);
   MYDBGASSERT(nIndex >= 0);    // will expand to meet need
   MYDBGASSERT(nCount > 0);     // zero or negative size not allowed

   if (nIndex >= m_nSize)
   {
      // adding after the end of the array
      SetSize(nIndex + nCount);  // grow so nIndex is valid
   }
   else
   {
      // inserting in the middle of the array
      int nOldSize = m_nSize;
      SetSize(m_nSize + nCount);  // grow it to new size
      // shift old data up to fill gap
      CmMoveMemory(&m_pData[nIndex+nCount], &m_pData[nIndex],
         (nOldSize-nIndex) * sizeof(void*));

      // re-init slots we copied from

      memset(&m_pData[nIndex], 0, nCount * sizeof(void*));

   }

   // insert new value in the gap
   MYDBGASSERT(nIndex + nCount <= m_nSize);
   while (nCount--)
      m_pData[nIndex++] = newElement;
}

void CPtrArray::RemoveAt(int nIndex, int nCount /* = 1 */)
{
   ASSERT_VALID(this);
   MYDBGASSERT(nIndex >= 0);
   MYDBGASSERT(nCount >= 0);
   MYDBGASSERT(nIndex + nCount <= m_nSize);

   // just remove a range
   int nMoveCount = m_nSize - (nIndex + nCount);

   if (nMoveCount)
      memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
         nMoveCount * sizeof(void*));
   m_nSize -= nCount;
}

void CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
   ASSERT_VALID(this);
   MYDBGASSERT(pNewArray != NULL);
   ASSERT_VALID(pNewArray);
   MYDBGASSERT(nStartIndex >= 0);

   if (pNewArray->GetSize() > 0)
   {
      InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
      for (int i = 0; i < pNewArray->GetSize(); i++)
         SetAt(nStartIndex + i, pNewArray->GetAt(i));
   }
}


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef DEBUG

void CPtrArray::AssertValid() const
{
   if (m_pData == NULL)
   {
      MYDBGASSERT(m_nSize == 0 && m_nMaxSize == 0);
   }
   else
   {
      MYDBGASSERT(m_nSize >= 0);
      MYDBGASSERT(m_nMaxSize >= 0);
      MYDBGASSERT(m_nSize <= m_nMaxSize);
      MYDBGASSERT(!IsBadReadPtr(m_pData, m_nMaxSize * sizeof(void*)));
   }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\arrayptr.h ===
//+----------------------------------------------------------------------------
//
// File:     ArrayPtr.h	 
//
// Module:   CMMON32.EXE
//
// Synopsis: Implement class CPtrArray, a array of void*, which grows dynamicly
//           This class is exactly the same as the one defined by MFC.
//           Help on the class also comes with vc help
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fengsun Created    2/17/98
//
//+----------------------------------------------------------------------------

#ifndef ARRAYPTR_H
#define ARRAYPTR_H

#include "windows.h"
#include "CmDebug.h"


class CPtrArray 
{

public:

// Construction
   CPtrArray();
   ~CPtrArray();

// Attributes
   int GetSize() const;
   int GetUpperBound() const;
   void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
   // Clean up
   void FreeExtra();
   void RemoveAll();

   // Accessing elements
   void* GetAt(int nIndex) const;
   void SetAt(int nIndex, void* newElement);
   void*& ElementAt(int nIndex);

   // Direct Access to the element data (may return NULL)
   const void** GetData() const;
   void** GetData();

   // Potentially growing the array
   void SetAtGrow(int nIndex, void* newElement);
   int Add(void* newElement);
   int Append(const CPtrArray& src);
   void Copy(const CPtrArray& src);

   // overloaded operator helpers
   void* operator[](int nIndex) const;
   void*& operator[](int nIndex);

   // Operations that move elements around
   void InsertAt(int nIndex, void* newElement, int nCount = 1);
   void RemoveAt(int nIndex, int nCount = 1);
   void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
   void** m_pData;   // the actual array of data
   int m_nSize;     // # of elements (upperBound - 1)
   int m_nMaxSize;  // max allocated
   int m_nGrowBy;   // grow amount

public:
#ifdef DEBUG
   void AssertValid() const;  //assert this is valid, for debugging
#endif
};



inline int CPtrArray::GetSize() const
   { return m_nSize; }
inline int CPtrArray::GetUpperBound() const
   { return m_nSize-1; }
inline void CPtrArray::RemoveAll()
   { SetSize(0); }
inline void* CPtrArray::GetAt(int nIndex) const
   { MYDBGASSERT(nIndex >= 0 && nIndex < m_nSize);
      return m_pData[nIndex]; }
inline void CPtrArray::SetAt(int nIndex, void* newElement)
   { MYDBGASSERT(nIndex >= 0 && nIndex < m_nSize);
      m_pData[nIndex] = newElement; }
inline void*& CPtrArray::ElementAt(int nIndex)
   { MYDBGASSERT(nIndex >= 0 && nIndex < m_nSize);
      return m_pData[nIndex]; }
inline int CPtrArray::Add(void* newElement)
   { int nIndex = m_nSize;
      SetAtGrow(nIndex, newElement);
      return nIndex; }
inline void* CPtrArray::operator[](int nIndex) const
   { return GetAt(nIndex); }
inline void*& CPtrArray::operator[](int nIndex)
   { return ElementAt(nIndex); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\connection.h ===
//+----------------------------------------------------------------------------
//
// File:     connection.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Header for the CCmConnection class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------
#ifndef CONNECTION_H
#define CONNECTION_H

#include "cm_misc.h"
#include "ras.h"
#include "ConnStat.h"
#include "Idlestat.h"
#include "WatchProcess.h"
#include "StatusDlg.h"
#include "ReconnectDlg.h"
#include "cm_def.h"
#include "resource.h"
#include "TrayIcon.h"
#include <rasdlg.h>
#include "cmdial.h"
#include "RasApiDll.h"
#include "cmlog.h"


struct tagCmConnectedInfo;  // CM_CONNECTED_INFO
struct Cm_Connection;       // CM_CONNECTION

class CCmConnection
{
public:
    // Called by main thread
    // Post a hangup message to itself
    // The connection is already hangup,
    void PostHangupMsg() const;

    CCmConnection(const tagCmConnectedInfo * pConnectedInfo, 
        const Cm_Connection* pConnectionEntry);
    ~CCmConnection();

    const TCHAR* GetServiceName() const {return m_szServiceName;}

    enum { 
        // Tray icon message send to status window
        WM_TRAYICON = WM_USER + 1, 
        WM_CONN_EVENT,  // Internal message posted to the thread, wParam in below
    };

    // Connection events, wParam for WM_CONN_EVENT
    enum CONN_EVENT
    {
        EVENT_LOST_CONNECTION, // The connection is losted
        EVENT_IDLE,            // No-traffic/No watching-process
        EVENT_COUNTDOWN_ZERO,  // Disconnect Countdown down to 0
        EVENT_USER_DISCONNECT, // user choose to disconnect 
        EVENT_CMDIAL_HANGUP,   // cmdial send cmmon a hangup request
        EVENT_RECONNECT,       // User clicked OK for the reconnect dialog
        EVENT_NONE,            // No event happened
    };

    // wParam for WM_COMMAND
    enum {IDM_TRAYMENU = IDC_DISCONNECT + 1000};  // addition tray icon menu id start from here

    void ReInstateTrayIcon();                       // re-add the trayicon to the tray
    DWORD OnTrayIcon(WPARAM wParam, LPARAM lParam); // WM_TRAYICON
    void OnStatusDetails();                         // "Detail" button clicked
    void OnStayOnLine();                            // "Stay Online" clicked
    void OnAdditionalTrayMenu(WORD nCmd);           // Additinal command from tray menu selected
    BOOL OnEndSession(BOOL fEndSession, BOOL fLogOff); // WM_ENDSESSION

    // Logging class
    CmLogFile m_Log;

    // Is this a "global" user (i.e. an all-user connectoid) with global creds?
    // That's the only type of connectoid that will survive a Fast User Switch
    BOOL m_fGlobalGlobal;
    
protected:
    enum CONN_STATE
    {  
        STATE_CONNECTED, // the connection is connected, this is the initial state
        STATE_COUNTDOWN, // displaying disconnect count down dialog box
        STATE_PROMPT_RECONNECT, // Displaying prompt reconnect dialog
        STATE_RECONNECTING,  // Calling cmdial to reconnect
        STATE_TERMINATED,    // connection no longer exist
    };  

    // Internal state
    CONN_STATE m_dwState;

    // The connection thread ID
    DWORD m_dwThreadId;

    // Dial-up RAS connection handle
    HRASCONN m_hRasDial;

    // Tunnel RAS connection handle
    HRASCONN m_hRasTunnel;

    // Connection statistics for Win9x
    CConnStatistics m_ConnStatistics;

    // Disconnect count down timer is 30 seconds
    enum{IDLE_DLG_WAIT_TIMEOUT = 30 * 1000}; 

    // Manage idle disconnect for Win9x
    CIdleStatistics m_IdleStatistics;

    // The tray icon on the task bar
    CTrayIcon   m_TrayIcon;

    // The big and small CM icon, 
    // the icon for status dialog and reconnect dialog
    HICON m_hBigIcon;
    HICON m_hSmallIcon;

    // Manage watch process list
    CWatchProcessList m_WatchProcess;

    // the start time when connected
    DWORD m_dwConnectStartTime;

    // The start time of disconnect count down
    DWORD m_dwCountDownStartTime;

    // Status and disconnect count down dialog
    CStatusDlg m_StatusDlg;

    // the prompt reconnect dialog
    CReconnectDlg m_ReconnectDlg;

    //
    // Information for reconnect only, except dwCmFlags
    //
        
    CMDIALINFO m_ReconnectInfo;

    // the long service name
    TCHAR m_szServiceName[RAS_MaxEntryName + 1];

    TCHAR m_szRasPhoneBook[MAX_PATH];

    CIni m_IniProfile;  // .cmp file
    CIni m_IniService;  // .cms file
    CIni m_IniBoth;     // Both .cmp and .cms file
                        // Write to .cmp file
                        // Read from .cmp file, if not found try .cms file

    // The help file name
    TCHAR m_szHelpFile[128];

    // An event for RAS to be signaled whe connection is lost
    // If NULL, we have to check the connection by RasGetConnectionStatus in our timer
    HANDLE m_hEventRasNotify;

    // The link to rasapi32
    CRasApiDll m_RasApiDll;

    // Whether to minimize the working set before MsgWaitForMultipleObject
    BOOL m_fToMinimizeWorkingSet;

    // hide the trayicon?
    BOOL m_fHideTrayIcon;

    // Used to cascade the window, increased by 1 for each connection
    static DWORD m_dwCurPositionId;
    // The position id of this connection, use this id to position the window
    DWORD m_dwPositionId;
public:    
    BOOL StartConnectionThread(); // Create a thread for this connection
    CONN_EVENT StateConnectedOnTimer(); 
    BOOL IsTrayIconHidden() const;

protected:
    static DWORD WINAPI ConnectionThread(LPVOID pConnection);  // Thread entry point
    DWORD ConnectionThread();   // Non static function of the entry point

    void InitIniFiles(const TCHAR* pszProfileName);
    void StateConnectedInit();
    void StateConnectedCleanup(BOOL fEndSession = FALSE);

    void StateConnected();  // The life time of state STATE_CONNECTED/COUNTDOWN
    CONN_EVENT StateConnectedGetEvent();

    CONN_STATE StateConnectedProcessEvent(CONN_EVENT wEvent);

    BOOL CmCustomHangup(BOOL fPromptReconnect, BOOL fEndSession = FALSE);

    BOOL CheckRasConnection(OUT BOOL& fLostConnection);

    LPTSTR LoadHelpFileName() ;
    void LoadConnectionIcons();
    BOOL IsPromptReconnectEnabled() const;
    BOOL IsAutoReconnectEnabled() const;

    HANDLE CallRasConnectionNotification(HRASCONN hRasDial, HRASCONN hRasTunnel);
    static DWORD WINAPI RasMonitorDlgThread(LPVOID lParam);


    CONN_STATE StatePrompt();
    BOOL Reconnect();

    //
    // Utility functions
    //
    BOOL ExecCmdLine(const TCHAR* pszCmdLine, const TCHAR* pszCmsFile);
    HANDLE RunAsUser(WCHAR *pszProgram, WCHAR *pszParams, WCHAR *pszDesktop);
    DWORD GetProcessId(WCHAR *pszModule);

    static void PositionWindow(HWND hWnd, DWORD dwPositionId);
public:
#ifdef DEBUG
   void AssertValid() const;  //assert this is valid, for debugging
#endif
};

//
// Inline functions
//


inline BOOL CCmConnection::IsTrayIconHidden() const
{
    return m_fHideTrayIcon;
}

inline void CCmConnection::ReInstateTrayIcon()
{
    //
    // we need to re-add the trayicon
    //
    m_TrayIcon.SetIcon(NULL, m_StatusDlg.GetHwnd(), WM_TRAYICON, 0, m_szServiceName);
}
     
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\cm_misc.h ===
//+----------------------------------------------------------------------------
//
// File:     cm_misc.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Miscellaneous function headers for cmmon32.exe
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------
#ifndef _CM_MISC_INC
#define _CM_MISC_INC

//
// Utility.cpp
//
void FmtNum(DWORD dwNum, LPSTR pszNum, DWORD dwNumSize); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\modaldlgclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     modaldlgclass.cpp
//
// Module:   CMMON32.EXE
//
// Synopsis: Modal dlg implementation
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
//	Please see pnpu\common\source for the actual source here.
//

#include "modaldlg.h"
#include "modaldlg.cpp"

#include "modelessdlg.h"
#include "modelessdlg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\connstat.h ===
//+----------------------------------------------------------------------------
//
// File:     connstat.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Header for the CConnStatistics class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------
#ifndef CONNSTAT_H
#define CONNSTAT_H

#include <windows.h>
#include <ras.h>
#include <tapi.h>

#include "RasApiDll.h"
#include "SmplRing.h"

//+---------------------------------------------------------------------------
//
//	class CConnStatistics
//
//	Description: A class to collect connection statistics
//               OpenByPerformanceKey() will start gathering data from registry
//               OpenByDevice   will gathering data from TAPI device handle
//
//	History:	fengsun	    10/01/97    Created
//              nickball    03/04/00    Heavily revised for NT5 usage   
//
//----------------------------------------------------------------------------
class CConnStatistics
{
public:
    CConnStatistics();
    ~CConnStatistics();

    void  Update();             // Update the statistics
    DWORD GetBytesPerSecRead() const;
    DWORD GetBytesPerSecWrite() const;
    DWORD GetBytesRead() const;
    DWORD GetBytesWrite() const;
    DWORD GetBaudRate() const;
    DWORD GetDuration() const;

    void Open(HINSTANCE hInst, 
              DWORD dwInitBytesRecv,
              DWORD dwInitBytesSend, 
              HRASCONN hRasDial, 
              HRASCONN hRAsTunnel);

    void Close();        // No more statistic information

    void  SetDialupTwo(BOOL fAdapter2);
    DWORD GetInitBytesRead() const;
    DWORD GetInitBytesWrite() const;

    BOOL IsAvailable() const;  // whether statistic information is available

protected:
    
    void OpenByStatisticsApi(DWORD dwInitBytesRecv,
                             DWORD dwInitBytesSend,
                             HRASCONN hDial, 
                             HRASCONN hTunnel);
                             
    void OpenByPerformanceKey(HINSTANCE hInst, 
                              DWORD dwInitBytesRecv,
                              DWORD dwInitBytesSend); 

    BOOL OpenByDevice(HRASCONN hrcRasConn);

    BOOL GetDeviceHandle(HRASCONN hrcRasConn);

    BOOL GetPerfData(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const;
    BOOL GetTapiDeviceStats(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const;
    void GetStatRegValues(HINSTANCE hInst);

protected:
    struct CTraffic
    {
        DWORD dwRead;
        DWORD dwWrite;
        DWORD dwTime;  // time in minisecond
    };

    enum {STAT_COUNT = 3};

    CSimpleRing<CTraffic, STAT_COUNT> m_TrafficRing;
    
    DWORD m_dwReadPerSecond;
    DWORD m_dwWritePerSecond;
    DWORD m_dwBaudRate;
    DWORD m_dwDuration;


    HANDLE m_hStatDevice;   // the TAPI device handle

    HRASCONN m_hRasConn;    // the RAS connection handle

	// For DUN 1.2, ICM uses perfmon counters for connection status data
	// however, these perfmon counters such as TotalBytesReceived are from last reboot
	// so we need to record the initial data in order to get correct value for this
	// particular connection

    HKEY   m_hKey;          // Performance registry handle
    DWORD  m_dwInitBytesRead;
    DWORD  m_dwInitBytesWrite;

    //
    // Registry names are different for PPP and PPTP
    //
    BOOL m_fAdapter2;
    BOOL m_fAdapterSet;

    //
    // Localized version of 
    // "Dial-up Adapter"\TotalBytesRecvd"
    // "Dial-up Adapter"\TotalBytesXmit"
    // "Dial-up Adapter"\ConnectSpeed"
    //
    LPTSTR m_pszTotalBytesRecvd;
    LPTSTR m_pszTotalBytesXmit;
    LPTSTR m_pszConnectSpeed;

    // The link to rasapi32
    CRasApiDll m_RasApiDll;

public:
#ifdef DEBUG
    void AssertValid() const;
#endif
};

//
// Inline functions
//

inline DWORD CConnStatistics::GetInitBytesRead() const
{
    return m_dwInitBytesRead;
}

inline DWORD CConnStatistics::GetInitBytesWrite() const
{
    return m_dwInitBytesWrite;
}

inline void CConnStatistics::SetDialupTwo(BOOL fAdapter2) 
{
    m_fAdapterSet = TRUE;
    m_fAdapter2 = fAdapter2;
}

inline DWORD CConnStatistics::GetBytesPerSecRead() const
{
    return m_dwReadPerSecond;
}

inline DWORD CConnStatistics::GetBytesPerSecWrite() const
{
    return m_dwWritePerSecond;
}

inline DWORD CConnStatistics::GetDuration() const
{
    return OS_NT5 ? (m_dwDuration) : 0; 
}

inline DWORD CConnStatistics::GetBytesRead() const
{
    return m_TrafficRing.GetLatest().dwRead;
}

inline DWORD CConnStatistics::GetBytesWrite() const
{
    return m_TrafficRing.GetLatest().dwWrite;
}

inline BOOL CConnStatistics::IsAvailable() const
{
    return OS_NT5 ? (m_hRasConn && m_RasApiDll.IsLoaded()) : (m_hKey || m_hStatDevice);
}

inline DWORD CConnStatistics::GetBaudRate() const
{
    return m_dwBaudRate;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\connstat.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ConnStat.cpp	 
//
// Module:   CMMON32.EXE
//
// Synopsis: Implementation of class CConnStatistics
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 Fengsun Created    10/15/97
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ConnStat.h"
#include "cm_misc.h" // for MYDBGASSERT
#include "DynamicLib.h"
#include "resource.h"
#include "perf_str.h"

//
// DeviceIoControl code
//

#define UNIMODEM_IOCTL_GET_STATISTICS	0x0000a007

//
// Constructor and destructor
//

CConnStatistics::CConnStatistics()
{
    m_TrafficRing.Reset();
    m_dwReadPerSecond = m_dwWritePerSecond = m_dwBaudRate = m_dwDuration = 0;
    m_dwInitBytesRead = m_dwInitBytesWrite = (DWORD)-1;
    m_hStatDevice = NULL;
    m_hKey = NULL;
    m_fAdapter2 = FALSE;
    m_fAdapterSet = FALSE;
    m_pszTotalBytesRecvd = m_pszTotalBytesXmit = m_pszConnectSpeed = NULL;
}

CConnStatistics::~CConnStatistics()
{
    Close();
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::OpenByDevice
//
// Synopsis:  
//
// Arguments: HRASCONN hrcRasConn - the ras connection handle, needed for 
//                     non-tunnle connection, when registry is not available
//
// Returns:   BOOL - Whether open succeeded.  
//              Because the TAPI device handle maybe available later from cmstat dll
//              Use IsAvailable() to see whether statistics is available
//
// History:   fengsun Created Header    10/29/97
//
//+----------------------------------------------------------------------------
BOOL CConnStatistics::OpenByDevice(HRASCONN hrcRasConn)
{
    MYDBGASSERT(OS_W95);
    MYDBGASSERT(!IsAvailable());
    MYDBGASSERT(hrcRasConn);

    if (GetDeviceHandle(hrcRasConn))
    {
        return TRUE;
    }

    //
    // NOTE: For win95 gold, GetDeviceHandle will fail if TAPI 2.1 is installed.  
    // We used to have a hack there to hook the lights.exe.  We decided to take
    // it out and to let the setup program ask user to upgrade TAPI or DUN. We 
    // dropped HookLight(), because it does not work for multiple connections.
    //

    MYDBGASSERT(FALSE);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//	Function:	Open()
//
//	Synopsis:	Encapsulates the opening of the statistics data store
//
// Arguments:   HINSTANCE hInst         - The instance to LoadString "Dial-up Adapter"
//              DWORD dwInitBytesRecv   - Initial value of TotalBytesRecvd
//              DWORD dwInitBytesSend   - Initial value of TotalBytesXmit
//              HRASCONN hDial          - Handle to dial-up connection, if any
//              HRASCONN hTunnel        - Handle to tunnel connection, if any
//
//	Returns:    TRUE  if succeed
//			    FALSE otherwise
//
//	History:    nickball    03/04/00     Created. Wrapped existing code.
//              
//  Note:       This function initialize the connection statistics from one
//              of three places. 
//
//                  1) W98 registry 
//                  2) NT5 RAS API
//                  3) W95 Tapi device handle. 
//
//----------------------------------------------------------------------------
void CConnStatistics::Open(HINSTANCE hInst, 
                           DWORD dwInitBytesRecv,
                           DWORD dwInitBytesSend, 
                           HRASCONN hDial, 
                           HRASCONN hTunnel)
{
    //
    // Start statistics 
    //
   
    if (OS_NT5)
    {
        OpenByStatisticsApi(dwInitBytesRecv, dwInitBytesSend, hDial, hTunnel);
    }
    else
    {
        OpenByPerformanceKey(hInst,
                             dwInitBytesRecv,
                             dwInitBytesSend);
    }

    //
    // See if we have stats, go with plan B if not.
    //

    if (!IsAvailable())
    {
        //
        // On W95, we have a fallback position of hooking the TAPI handle 
        // via RAS, so use it. Note: We will retry initializing stats on every 
        // timer tick if we don't get them here, so all is not lost for W98.
        // Note that we only check hDial here because if you are on win95 without
        // MSDUN 1.2, you aren't able to tunnel.
        //

        if (OS_W95 && hDial)
        {
            OpenByDevice(hDial);
        }
    }
}

//+---------------------------------------------------------------------------
//
//	Function:	OpenByStatisticsApi()
//
//	Synopsis:	Sets initial values and makes sure the RasApis are loaded.
//
// Arguments:   DWORD dwInitBytesRecv   - Initial value of TotalBytesRecvd
//              DWORD dwInitBytesSend   - Initial value of TotalBytesXmit
//              HRASCONN hDial          - Handle to dial-up connection, if any
//              HRASCONN hTunnel        - Handle to tunnel connection, if any
//
//	Returns:    Nothing
//
//	History:    nickball    03/04/00   Created from OpenByPerformanceKey
//
//----------------------------------------------------------------------------
void CConnStatistics::OpenByStatisticsApi(DWORD dwInitBytesRecv, 
                                          DWORD dwInitBytesSend,
                                          HRASCONN hDial, 
                                          HRASCONN hTunnel)
{
    //
    // Initialize our APIs
    //

    m_RasApiDll.Load();
    
    //
    // Get the handle that we'll use to look up stats.
    // Try tunnel first, then drop back to dial-up
    //

    CMTRACE2(TEXT("CConnStatistics::OpenByStatisticsApi() hTunnel is 0x%x and hDial is 0x%x"), hTunnel, hDial);

    m_hRasConn = hTunnel ? hTunnel : hDial;

    //
    // Init the bytes sent and received with whatever was pushed down to us.
    //

    m_dwInitBytesRead = dwInitBytesRecv;
    m_dwInitBytesWrite = dwInitBytesSend;
}

//+---------------------------------------------------------------------------
//
//	Function:	OpenByPerformanceKey()
//
//	Synopsis:	Open the registry key for Dial-Up Adapter Performance Data
//
// Arguments:   HINSTANCE hInst - The instance to LoadString "Dial-up Adapter"
//              DWORD dwInitBytesRecv - Initial value of TotalBytesRecvd
//              DWORD dwInitBytesSend - Initial value of TotalBytesXmit
//
//	Returns:    TRUE  if succeed
//			    FALSE otherwise
//
//	History:    byao	    07/16/97     Created		                
//              fengsun     10/01/97     Make it a member fuction     
//              nickball    11/14/98     If key exists, use it
//              
//  Note:       This function initialize the connection statistics from the 
//              registry. It is used when the initial bytes sent/recvd are 
//              known as is the case when CMDIAL hands off to CMMON.
//
//----------------------------------------------------------------------------

void CConnStatistics::OpenByPerformanceKey(HINSTANCE hInst, 
                                           DWORD dwInitBytesRecv,
                                           DWORD dwInitBytesSend)
{
    //
    // If available, there's nothing to do here
    //

    if (IsAvailable() || !m_fAdapterSet)
    {
        MYDBGASSERT(FALSE);
        return;

    }   
 
    //
    // We haven't opened the key yet, try to do so
    //

    MYDBGASSERT(!m_hKey);

    if (m_hKey)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    DWORD dwErrCode = RegOpenKeyExU( HKEY_DYN_DATA, 
							  c_pszDialupPerfKey,
							  0, 
							  KEY_ALL_ACCESS, 
							  &m_hKey );

    if (dwErrCode != ERROR_SUCCESS)
    {
    	CMTRACE1(TEXT("OpenDAPPerfKey() RegOpenKeyEx() returned GLE=%u."), dwErrCode);
        m_hKey = NULL;
        return;
    }

    m_dwInitBytesRead = dwInitBytesRecv;
    m_dwInitBytesWrite = dwInitBytesSend;

    GetStatRegValues(hInst);

    //
    // If intial values are -1, reget the initial values.
    //

    if (((DWORD)-1 == dwInitBytesRecv) || ((DWORD)-1 == dwInitBytesSend))
    {  
        //
        // Get the initial statistics info
        //

        if (!GetPerfData(m_dwInitBytesRead, m_dwInitBytesWrite, m_dwBaudRate))
        {
            //
            // No dial-up statistic info
            //
            
            RegCloseKey(m_hKey);
            m_hKey = NULL;

            CMTRACE(TEXT("CConnStatistics::OpenByPerformanceKey() - failed to find stats"));
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::GetStatRegValues
//
// Synopsis:  Helper method, builds the reg value names using the localized 
//            form of the word "Dial-up Adapter".
//
// Arguments: HINSTANCE hInst
//
// Returns:   Nothing
//
// History:   nickball      Created     11/14/98
//
//+----------------------------------------------------------------------------
void CConnStatistics::GetStatRegValues(HINSTANCE hInst)
{
    CMTRACE1(TEXT("CConnStatistics::GetStatRegValues - m_pszTotalBytesRecvd is %s"), m_pszTotalBytesRecvd);

    //
    // bug 149367 The word "Dial-up Adapter" need to be localized.  
    // Load it from resource if no loaded yet
    //

    if (m_pszTotalBytesRecvd == NULL)
    {
        m_pszTotalBytesRecvd = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszTotalBytesRecvd, m_fAdapter2 ? c_pszDialup_2_TotalBytesRcvd : c_pszDialupTotalBytesRcvd);

        m_pszTotalBytesXmit = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszTotalBytesXmit, m_fAdapter2 ? c_pszDialup_2_TotalBytesXmit : c_pszDialupTotalBytesXmit);

        m_pszConnectSpeed = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszConnectSpeed, m_fAdapter2 ? c_pszDialup_2_ConnectSpeed : c_pszDialupConnectSpeed);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::Close
//
// Synopsis:  Stop gathering statistic and close the handle
//
// Arguments: 
//
// Returns:   
//
// History:   Created Header    10/15/97
//
//+----------------------------------------------------------------------------
void CConnStatistics::Close()
{
	if (m_hStatDevice) 
	{
		BOOL bRes = CloseHandle(m_hStatDevice);
        m_hStatDevice = NULL;

#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("CConnStatistics::Close() CloseHandle() failed, GLE=%u."), GetLastError());
        }
#endif
	}

	if (m_hKey)
	{
		DWORD dwErrCode = RegCloseKey(m_hKey);
		CMTRACE1(TEXT("Close() RegCloseKey() returned GLE=%u."), dwErrCode);
        m_hKey = NULL;
	}

    CmFree( m_pszTotalBytesRecvd );
    CmFree( m_pszTotalBytesXmit );
    CmFree( m_pszConnectSpeed );

    m_pszTotalBytesRecvd = m_pszTotalBytesXmit = m_pszConnectSpeed = NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::Update
//
// Synopsis:  Gather new statistic information
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Fengsun Created     10/15/97
//
//+----------------------------------------------------------------------------
void CConnStatistics::Update()
{
    if (!IsAvailable())
    {
        MYDBGASSERT(FALSE);
        return;
    }
    
    CTraffic curTraffic;
    curTraffic.dwTime = GetTickCount();

    MYDBGASSERT(curTraffic.dwTime > m_TrafficRing.GetOldest().dwTime);

    if (curTraffic.dwTime == m_TrafficRing.GetOldest().dwTime)
    {
        return;
    }

    //
    // Prefer performace registry data 
    //

    if (OS_NT5)
    {
        RAS_STATS RasStats;
 
        ZeroMemory(&RasStats, sizeof(RasStats));
        RasStats.dwSize = sizeof(RAS_STATS);
        
        DWORD dwRet = m_RasApiDll.RasGetConnectionStatistics(m_hRasConn, &RasStats);

        if (ERROR_SUCCESS == dwRet)
        {
            curTraffic.dwRead   = RasStats.dwBytesRcved;
            curTraffic.dwWrite  = RasStats.dwBytesXmited;
            m_dwBaudRate        = RasStats.dwBps;
            m_dwDuration        = RasStats.dwConnectDuration;
        }
    }
    else
    {
        //
        // Not NT5, try the registry
        //
        
        if (m_hKey)
        {    
            if (!GetPerfData(curTraffic.dwRead, curTraffic.dwWrite, m_dwBaudRate))
            {
                return;
            }
            curTraffic.dwRead -= m_dwInitBytesRead;
            curTraffic.dwWrite -= m_dwInitBytesWrite;
        }
        else
        {
            //
            // Last resort for 9x, try to use stat device 
            //
            
            if (m_hStatDevice)
            {
                if (!GetTapiDeviceStats(curTraffic.dwRead, curTraffic.dwWrite, m_dwBaudRate))
                {
	    	        BOOL bRes = CloseHandle(m_hStatDevice);
                    m_hStatDevice = NULL;

                    if (!bRes)
                    {
                        CMTRACE1(TEXT("CConnStatistics::Update() CloseHandle() failed, GLE=%u."), GetLastError());
                    }
                    return;
                }
            }   
            else
            {
                MYDBGASSERT(m_hStatDevice);
                return;
            }
        }
    }

    //
    // Calculate the avarage between two interval
    //
    const CTraffic& lastTraffic = m_TrafficRing.GetOldest();

    DWORD dwDeltaTime = curTraffic.dwTime - lastTraffic.dwTime;
    m_dwReadPerSecond = ((curTraffic.dwRead - lastTraffic.dwRead)*1000) /dwDeltaTime;
    m_dwWritePerSecond = ((curTraffic.dwWrite - lastTraffic.dwWrite)*1000) /dwDeltaTime;

    m_TrafficRing.Add(curTraffic);
}


//+---------------------------------------------------------------------------
//
//	Function:	GetPerfData
//
//	Synopsis:	Get Performance Data from DUN1.2 performance registry
//
//	Arguments:	
//
//	Returns:	TRUE: succeed
//				FALSE otherwise
//
//	History:	byao	created		7/16/97
//              fengsun change it into a member function 10/14/97
//					
//----------------------------------------------------------------------------
BOOL CConnStatistics::GetPerfData(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const
{
    if (OS_W9X)
    {
        MYDBGASSERT(m_hKey != NULL);   
        MYDBGASSERT(m_pszTotalBytesRecvd && *m_pszTotalBytesRecvd);

        LONG dwErrCode;

        DWORD dwValueSize, dwValueType;
	    DWORD dwValue;

        //
        // "Dial-up Adapter\TotalBytesRecvd"
        //
        dwValueSize = sizeof(DWORD);
	    dwErrCode = RegQueryValueExU(
				    m_hKey,
                    m_pszTotalBytesRecvd,
				    NULL,
				    &dwValueType,
				    (PBYTE)&dwValue,
				    &dwValueSize);

	    if (dwErrCode == ERROR_SUCCESS) 
	    {
		    dwRead = dwValue;
        }
	    else 
	    {
      	    CMTRACE2(TEXT("GetPerfData() RegQueryValueEx() %s failed and returned GLE=%u."),
                m_pszTotalBytesRecvd, dwErrCode);

		    return FALSE;
	    }

        //
        // "Dial-up Adapter\TotalBytesXmit"
        //
	    
	    dwValueSize = sizeof(DWORD);
	    dwErrCode = RegQueryValueExU(
				    m_hKey,
                    m_pszTotalBytesXmit,
				    NULL,
				    &dwValueType,
				    (PBYTE)&dwValue,
				    &dwValueSize);

	    if (dwErrCode == ERROR_SUCCESS) 
	    {
		    dwWrite = dwValue;
        }
	    else 
	    {
      	    CMTRACE2(TEXT("GetPerfData() RegQueryValueEx() %s failed and returned GLE=%u."),
                m_pszTotalBytesXmit, dwErrCode);

		    return FALSE;
	    }

        //
        // "Dial-up Adapter\ConnectSpeed"
        //
	    dwValueSize = sizeof(DWORD);
	    dwErrCode = RegQueryValueExU(
				    m_hKey,
                    m_pszConnectSpeed,
				    NULL,
				    &dwValueType,
				    (PBYTE)&dwValue,
				    &dwValueSize);

	    if (dwErrCode == ERROR_SUCCESS) 
	    {
		    dwBaudRate = dwValue;
        }
	    else 
	    {
            CMTRACE2(TEXT("GetPerfData() RegQueryValueEx() %s failed and returned GLE=%u."), m_pszConnectSpeed, dwErrCode);
		    return FALSE;
	    }
    }

	return TRUE;
}


//+---------------------------------------------------------------------------
//
//	Function:	GetTapiDeviceStats
//
//	Synopsis:	Get Modem Performance Data by DeviceIoControl
//
//	Arguments:	
//
//	Returns:	TRUE: succeed
//				FALSE otherwise
//
//	History:	byao	created		7/16/97
//              fengsun change it into a member function 10/14/97
//					
//----------------------------------------------------------------------------
BOOL CConnStatistics::GetTapiDeviceStats(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const
{
	BOOL bRes;
	DWORD dwRet;

    typedef struct tagAPISTATS {
	    LPVOID hPort;
	    DWORD fConnected;
	    DWORD DCERate;
	    DWORD dwPerfRead;
	    DWORD dwPerfWrite;
    } APISTATS;

	APISTATS ApiStats;

	if (m_hStatDevice) 
	{
		bRes = DeviceIoControl(m_hStatDevice,
							   UNIMODEM_IOCTL_GET_STATISTICS,
							   &ApiStats,
							   sizeof(ApiStats),
							   &ApiStats,
							   sizeof(ApiStats),
							   &dwRet,
							   NULL);
		if (bRes && ApiStats.fConnected) 
		{
            dwRead = ApiStats.dwPerfRead;
            dwWrite = ApiStats.dwPerfWrite;
            dwBaudRate = ApiStats.DCERate;
			return (TRUE);
		}
        
		CMTRACE(TEXT("GetTapiDeviceStats() DeviceIoControl() failed - disabling hStatDevice."));
	}

	return (FALSE);
}




//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::GetDeviceHandle
//
// Synopsis:  Get the TAPI device handle
//
// Arguments: HRASCONN hrcRasConn - the ras connection handle
//
// Returns:   BOOL - TRUE if succeed
//
// History:   fengsun Created Header    10/29/97
//
//+----------------------------------------------------------------------------
BOOL CConnStatistics::GetDeviceHandle(HRASCONN hrcRasConn) 
{
    MYDBGASSERT(hrcRasConn);
    MYDBGASSERT(!m_hStatDevice);

    typedef struct tagDEVICE_PORT_INFO 
    {
	    DWORD dwSize;
	    HANDLE hDevicePort;
	    HLINE hLine;
	    HCALL hCall;
	    DWORD dwAddressID;
	    DWORD dwLinkSpeed;
	    char szDeviceClass[RAS_MaxDeviceType+1];
    } DEVICE_PORT_INFO, *LPDEVICE_PORT_INFO;

    typedef struct tagMacInfo 
    {
	    VARSTRING varstring;
	    HANDLE hCommDevice;
	    char szDeviceClass[1];
    } MacInfo;

    typedef DWORD (WINAPI *RnaGetDevicePortFUNC)(HANDLE,LPDEVICE_PORT_INFO);
	RnaGetDevicePortFUNC pfnRnaGetDevicePort;

    //
    // Load rasapi32.dll and call RnaGetDevicePort
    //
    
    //
    // The destructor of CDynamicLibrary automaticly call FreeLibrary
    //
    CDynamicLibrary RasLib;

    if (!RasLib.Load(TEXT("rasapi32.dll")))
	{
        CMTRACE1(TEXT("GetDeviceHandle() LoadLibrary() failed, GLE=%u."), GetLastError());
		return FALSE;
	}
    
	pfnRnaGetDevicePort = (RnaGetDevicePortFUNC) RasLib.GetProcAddress("RnaGetDevicePort");
	if (!pfnRnaGetDevicePort) 
	{
        CMTRACE1(TEXT("GetDeviceHandle() GetProcAddress() failed, GLE=%u."), GetLastError());
        return FALSE;
	}

	DWORD dwRes;
	DEVICE_PORT_INFO dpi;

	ZeroMemory(&dpi,sizeof(dpi));
	dpi.dwSize = sizeof(dpi);

    dwRes = pfnRnaGetDevicePort(hrcRasConn,&dpi);
	if (dwRes) 
	{
        CMTRACE1(TEXT("GetDeviceHandle() RnaGetDevicePort() failed, GLE=%u."), dwRes);
        return FALSE;
	}

    //
    // Load TAPI32.dll
    // CDynamicLibrary Free the lib on destructor
    //
    CDynamicLibrary LibTapi;

    if (!LibTapi.Load(TEXT("TAPI32.DLL")))
    {
        return FALSE;
    }

    typedef LONG (WINAPI *TapiLineGetIDFUNC)
        (HLINE, DWORD, HCALL, DWORD, LPVARSTRING, LPCSTR);

    //
    //  Always call the Ansi version since this is a Win9x only function
    //
    TapiLineGetIDFUNC pfnTapiLineGetID; 
	pfnTapiLineGetID = (TapiLineGetIDFUNC) LibTapi.GetProcAddress("lineGetID");

    if (pfnTapiLineGetID == NULL)
    {
        MYDBGASSERT(pfnTapiLineGetID != NULL);
        return FALSE;
    }

    LONG lRes;

    CMTRACE3(TEXT("GetDeviceHandle() hDevicePort=0x%x, hLine=0x%x, hCall=0x%x,"), dpi.hDevicePort, dpi.hLine, dpi.hCall);
    CMTRACE3(TEXT("\tdwAddressID=0x%x, dwLinkSpeed=%u, szDeviceClass=%s."), dpi.dwAddressID, dpi.dwLinkSpeed, dpi.szDeviceClass);

    m_dwBaudRate = dpi.dwLinkSpeed;
	
    MacInfo* pmi = NULL;
    DWORD dwSize = sizeof(*pmi);
	
    do
    {
	    CmFree(pmi);
	    pmi = (MacInfo *) CmMalloc(dwSize);
        if (pmi == NULL)
        {
            lRes = ERROR_OUTOFMEMORY;
            break;
        }

	    pmi->varstring.dwTotalSize = dwSize;


	    lRes = pfnTapiLineGetID(dpi.hLine,
					        dpi.dwAddressID,
					        NULL,
					        LINECALLSELECT_ADDRESS,
					        &pmi->varstring,
                            "comm/datamodem");

        dwSize = pmi->varstring.dwNeededSize;
    } while(pmi->varstring.dwNeededSize > pmi->varstring.dwTotalSize);

#ifdef DEBUG
    if (lRes)
    {
        CMTRACE1(TEXT("CConnStatistics::GetDeviceHandle() lineGetID() failed, GLE=%u."), lRes);
    }
#endif

	if (!lRes && pmi != NULL ) 
	{
		m_hStatDevice = pmi->hCommDevice;
	}

	CmFree(pmi);

    return m_hStatDevice != NULL; 
}

#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::AssertValid
//
// Synopsis:  For debug purpose only, assert the object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CConnStatistics::AssertValid() const
{
    MYDBGASSERT(m_hKey == NULL || m_hStatDevice == NULL);
    MYDBGASSERT(m_fAdapter2 == TRUE || m_fAdapter2 == FALSE);
    ASSERT_VALID(&m_TrafficRing);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\connection.cpp ===
//+----------------------------------------------------------------------------
//
// File:     connection.cpp  
//
// Module:   CMMON32.EXE
//
// Synopsis: 
//      Implement class CCmConnection
//      CCmConnection manages a single connection.  
//           
//      The m_StatusDlg lives through out the CONNECTED/DISCONNECT_COUNTDOWN
//      state.  The appearance changes when it comes to COUNTDOWN state.
//
//      The m_ReconnectDlg is the reconnect prompt dialog.  It exist during
//      STATE_PROMPT_RECONNECT state.
//
//      Both dialogs are modeless.  (We need a initially invisible status dialog 
//      to receive timer and trayicon message.  I did not find any way to create
//      a invisible modal dialog without flashing.)
//
//      CreateDialog will simply return, unlike DialogBox, which returns only after
//      Dialog is ended.  To simplify the implementation, we handle end-dialog event
//      in the thread routine instead of in the dialog procedure.
//
//      When we need to end the status or reconnect dialog, we simply post a thread 
//      message to end the dialog and continue to the next state.  The connection 
//      thread runs a message loop and processes thread message.
//
//      The RasMonitorDlg on NT is running in another thread.  Otherwise the connection
//      thread message can not be processed
//
//      The connection is event driven module.  ConnectionThread() is the entry 
//      point of the connection thread.
//
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created    2/11/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "connection.h"
#include "Monitor.h"
#include "TrayIcon.h"
#include "ShellDll.h"
#include <tchar.h>
#include <rasdlg.h>
#include "cmdial.h"
#include <wininet.h> // for INTERNET_DIALSTATE_DISCONNECTED
#include "DynamicLib.h"

#include "log_str.h"
#include "userinfo_str.h"

HINSTANCE g_hInst = NULL;

//
// Functions in cmdial32.dll, the prototype is in cmdial.h
//
static const CHAR* const c_pszCmReconnect = "CmReConnect";
static const CHAR* const c_pszCmHangup = "CmCustomHangUp";

//
// CMS flags used exclusively by connection.cpp
//
static const TCHAR* const c_pszCmEntryIdleThreshold     = TEXT("IdleThreshold");
static const TCHAR* const c_pszCmEntryNoPromptReconnect = TEXT("NoPromptReconnect");
static const TCHAR* const c_pszCmEntryHideTrayIcon      = TEXT("HideTrayIcon");

typedef BOOL (WINAPI * CmReConnectFUNC)(LPTSTR lpszPhonebook, 
    LPTSTR lpszEntry, 
    LPCMDIALINFO lpCmInfo);

typedef DWORD (WINAPI * CmCustomHangUpFUNC)(HRASCONN hRasConn, 
    LPCTSTR pszEntry,
    BOOL fIgnoreRefCount,
    BOOL fPersist);

//
// The timer interval for StateConnectedOnTimer();
//
const DWORD TIMER_INTERVAL = 1000;

DWORD CCmConnection::m_dwCurPositionId = 0;
//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::CCmConnection
//
// Synopsis:  Constructor, called in the monitor thread
//
// Arguments: const CONNECTED_INFO* pConnectedInfo - Information passed from 
//                cmdial upon conected
//            const CM_CONNECTION* pConnectionEntry - Information in the
//                Connection table
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/3/98
//
//+----------------------------------------------------------------------------
CCmConnection::CCmConnection(const CM_CONNECTED_INFO* pConnectedInfo, 
                             const CM_CONNECTION* pConnectionEntry) : 
#pragma warning(disable:4355) //'this' : used in base member initializer list
    m_StatusDlg(this),
#pragma warning(default:4355) 
    m_TrayIcon()
{
    MYDBGASSERT(pConnectedInfo);
    MYDBGASSERT(pConnectionEntry);

    m_dwState = STATE_CONNECTED;
    m_hBigIcon = m_hSmallIcon = NULL;

    m_dwConnectStartTime = GetTickCount() - 500; // .5 second for round off

    m_dwCountDownStartTime = 0;
    m_dwThreadId = 0;

    //
    // set this to TRUE, so the WorkingSet will be minimized before MsgWait
    // while there is no more message
    //
    m_fToMinimizeWorkingSet = TRUE;  

    m_fHideTrayIcon = FALSE;

    //
    // Save the data from pConnectedInfo
    //

    lstrcpynU(m_ReconnectInfo.szPassword, pConnectedInfo->szPassword, 
        sizeof(m_ReconnectInfo.szPassword)/sizeof(m_ReconnectInfo.szPassword[0]));
    lstrcpynU(m_ReconnectInfo.szInetPassword, pConnectedInfo->szInetPassword, 
        sizeof(m_ReconnectInfo.szPassword)/sizeof(m_ReconnectInfo.szPassword[0]));

    m_ReconnectInfo.dwCmFlags = pConnectedInfo->dwCmFlags | FL_RECONNECT; // Cm specific flags

    lstrcpynU(m_szServiceName, pConnectedInfo->szEntryName, sizeof(m_szServiceName)/sizeof(m_szServiceName[0]));

    //
    // NOTE: Fast User Switching is only available on WinXP and beyond, and this
    //       member variable should only be accessed/used for WinXP and beyond.
    //
    m_fGlobalGlobal = (pConnectionEntry->fAllUser && (pConnectedInfo->dwCmFlags & FL_GLOBALCREDS));
    CMTRACE1(TEXT("CCmConnection::CCmConnection set m_fGlobalGlobal to %d"), m_fGlobalGlobal);

    //
    // Get the RAS phonebook
    //

    lstrcpynU(m_szRasPhoneBook, pConnectedInfo->szRasPhoneBook, sizeof(m_szRasPhoneBook)/sizeof(m_szRasPhoneBook[0]));   

    //
    // Init m_IniProfile, m_IniService and m_IniBoth
    //
    InitIniFiles(pConnectedInfo->szProfilePath);

    //
    //  Because the IdleTimeout and EnableLogging values are not saved
    //  per access point as all the other profile settings are, we must change the PrimaryRegPath
    //  value of m_IniBoth so that it points to the non-access point registry location.
    //
    LPCTSTR c_pszUserInfoRegPath = (pConnectionEntry->fAllUser) ? c_pszRegCmUserInfo : c_pszRegCmSingleUserInfo;

    LPTSTR pszSavedPrimaryRegPath = CmStrCpyAlloc(m_IniBoth.GetPrimaryRegPath());
    LPTSTR pszPrimaryRegPath = (LPTSTR)CmMalloc(sizeof(TCHAR)*(lstrlenU(c_pszUserInfoRegPath) + lstrlenU(m_szServiceName) + 1));

    if (pszPrimaryRegPath && pszSavedPrimaryRegPath)
    {
        wsprintfU(pszPrimaryRegPath, TEXT("%s%s"), c_pszUserInfoRegPath, m_szServiceName);
        
        m_IniBoth.SetPrimaryRegPath(pszPrimaryRegPath);

        CmFree(pszPrimaryRegPath);
    }

    //
    //  Initialize Logging
    //
    m_Log.Init(g_hInst, pConnectionEntry->fAllUser, GetServiceName());
    
    BOOL fEnabled       = FALSE;
    DWORD dwMaxSize     = 0;
    LPTSTR pszFileDir   = NULL;

    fEnabled    = m_IniBoth.GPPB(c_pszCmSection, c_pszCmEntryEnableLogging, c_fEnableLogging);
    dwMaxSize   = m_IniService.GPPI(c_pszCmSectionLogging, c_pszCmEntryMaxLogFileSize, c_dwMaxFileSize);
    pszFileDir  = m_IniService.GPPS(c_pszCmSectionLogging, c_pszCmEntryLogFileDirectory, c_szLogFileDirectory);
    
    m_Log.SetParams(fEnabled, dwMaxSize, pszFileDir);
    if (m_Log.IsEnabled())
    {
        m_Log.Start(FALSE);     // FALSE => no banner
    }
    else
    {
        m_Log.Stop();
    }
    CmFree(pszFileDir);

    //
    // Whether to enable auto disconnect for no-traffic and no-watch-process
    // 0 of dwIdleTime means never timeout
    //

    const DWORD DEFAULT_IDLETIMEOUT = 10;  // default idle time out is 10 minute
    DWORD dwIdleTime = (DWORD) m_IniBoth.GPPI(c_pszCmSection, 
                                              c_pszCmEntryIdleTimeout, 
                                              DEFAULT_IDLETIMEOUT);

    //
    //  Set the m_IniBoth object back to its previous Primary Reg path
    //
    if (pszSavedPrimaryRegPath)
    {
        m_IniBoth.SetPrimaryRegPath(pszSavedPrimaryRegPath);
        CmFree(pszSavedPrimaryRegPath);
    }

    //
    // No watch-process time-out if IdleTime is "never"
    //
    if (dwIdleTime)
    {
        for (int i=0; pConnectedInfo->ahWatchHandles[i] != 0; i++)
        {

            m_WatchProcess.Add(pConnectedInfo->ahWatchHandles[i]);
        }
    }

    if (!OS_NT4)
    {        
        m_ConnStatistics.SetDialupTwo(pConnectedInfo->fDialup2);

        m_ConnStatistics.Open(CMonitor::GetInstance(),
                           pConnectedInfo->dwInitBytesRecv,
                           pConnectedInfo->dwInitBytesSend,
                           pConnectionEntry->hDial,
                           pConnectionEntry->hTunnel);
        if (dwIdleTime)
        {
            //
            // Adjust minutes value to milliseconds
            //

            dwIdleTime = dwIdleTime * 1000 * 60;

            DWORD dwIdleThreshold = m_IniService.GPPI(c_pszCmSection,
                                                      c_pszCmEntryIdleThreshold,
                                                      0L); // default threshold is always 0 bytes

            //
            // Start idle statistic counter anyway
            // IsIdle will return FALSE, if it is never updated
            //
            m_IdleStatistics.Start(dwIdleThreshold, dwIdleTime);
        }
    }

    //
    // Save data from pConnectionEntry
    //
    MYDBGASSERT(pConnectionEntry->hDial || pConnectionEntry->hTunnel);
    MYDBGASSERT(pConnectionEntry->CmState == CM_CONNECTED);

    m_hRasDial = pConnectionEntry->hDial;
    m_hRasTunnel = pConnectionEntry->hTunnel;

    m_szHelpFile[0] = 0;
    
    //
    // the position id increased by 1 for each connection
    //
    m_dwPositionId = m_dwCurPositionId;
    m_dwCurPositionId++;
}



//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::~CCmConnection
//
// Synopsis:  
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/18/98
//
//+----------------------------------------------------------------------------
CCmConnection::~CCmConnection()
{
    ASSERT_VALID(this);

    if (m_hBigIcon)
    {
        DeleteObject(m_hBigIcon);
    }

    if (m_hSmallIcon)
    {
        DeleteObject(m_hSmallIcon);
    }

    if (m_hEventRasNotify)
    {
        CloseHandle(m_hEventRasNotify);
    }

    //
    //  UnInitialize Logging
    //
    m_Log.DeInit();

}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::InitIniFiles
//
// Synopsis:  Initialize data member m_IniProfile, m_IniService and m_IniBoth
//
// Arguments: const TCHAR* pszProfileName - the full path of the .cmp file
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/10/98
//
//+----------------------------------------------------------------------------

void CCmConnection::InitIniFiles(const TCHAR* pszProfileName)
{
    if (NULL == pszProfileName)
    {
        return;
    }

    g_hInst = CMonitor::GetInstance(); 

    //
    // .cmp file
    //
    m_IniProfile.Clear();
    m_IniProfile.SetHInst(CMonitor::GetInstance());
    m_IniProfile.SetFile(pszProfileName);

    //
    // .cms file
    //
    m_IniService.Clear();
    m_IniService.SetHInst(CMonitor::GetInstance());

    LPTSTR pszService = m_IniProfile.GPPS(c_pszCmSection,c_pszCmEntryCmsFile);
    MYDBGASSERT(pszService);

    //
    // the .cms file is relative to .cmp path, convert it to absolute path
    //

    LPTSTR pszFullPath = CmBuildFullPathFromRelative(m_IniProfile.GetFile(), pszService);

    MYDBGASSERT(pszFullPath);

    if (pszFullPath)
    {
        m_IniService.SetFile(pszFullPath);
    }

    CmFree(pszFullPath);
    CmFree(pszService);

    // both: .CMP file takes precedence over .CMS file
    //       use .CMP file as primary file
    //
    m_IniBoth.Clear();
    m_IniBoth.SetHInst(CMonitor::GetInstance());
    m_IniBoth.SetFile(m_IniService.GetFile());
    m_IniBoth.SetPrimaryFile(m_IniProfile.GetFile());
}


//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StartConnectionThread
//
// Synopsis:  Start the connection thread.  Called by monitor on CONNECTED 
//            message from cmdial
//
// Arguments: None
//
// Returns:   BOOL - Whether the thread is created successfully
//
// History:   fengsun Created Header    2/3/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::StartConnectionThread()
{
    DWORD dwThreadId;
    HANDLE hThread;
    
    if ((hThread = CreateThread(NULL, 0, ConnectionThread ,this,0,&dwThreadId)) == NULL)
    {
        MYDBGASSERT(FALSE);
        CMTRACE(TEXT("CCmConnection::StartConnectionThread CreateThread failed"));
        return FALSE;
    }

    CloseHandle(hThread);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  static CCmConnection::ConnectionThread
//
// Synopsis:  The connection thread. Call back function for CreateThread
//
// Arguments: LPVOID lParam - pConnection
//
// Returns:   DWORD WINAPI - thread exit code
//
// History:   fengsun Created Header    2/12/98
//
//+----------------------------------------------------------------------------
DWORD WINAPI CCmConnection::ConnectionThread(LPVOID lParam)
{
    MYDBGASSERT(lParam);

    //
    // Call the non-static function
    //
    return ((CCmConnection*)lParam)->ConnectionThread();
}



//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::ConnectionThread
//
// Synopsis:  The non-static connection thread, so we can referrence 
//            data/fuction directly
//
// Arguments: None
//
// Returns:   DWORD - thread exit code
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
DWORD CCmConnection::ConnectionThread()
{
    m_dwThreadId = GetCurrentThreadId();

    m_dwState = STATE_CONNECTED;

    //
    // Run the connected/disconnect-count-down state
    // StateConnected() will change m_dwState to the new state
    //
    StateConnected();

    //
    // Whether to remove the connection from the shared connection table
    // This is TRUE, only if user clicks No for the prompt reconnect dialog
    //
    BOOL fRemoveFromSharedTable = FALSE;

    if (m_dwState != STATE_TERMINATED)
    {
        //
        // if auto reconnect is not enabled, then show the reconnect prompt
        //
        if (m_dwState != STATE_RECONNECTING)
        {
            //
            // Run the prompt reconnect state
            //
            m_dwState = StatePrompt();
        }

        if (m_dwState != STATE_RECONNECTING)
        {
            //
            // User clicks No for the reconnect-prompt dialog
            // Clear the entry from connection table
            //
            fRemoveFromSharedTable = TRUE;
        }
        else
        {
            //
            // User clicks Yes for the reconnect-prompt dialog
            // Move from Connected array to reconnecting array
            //

            CMonitor::MoveToReconnectingConn(this);

            //
            // Run the reconnect state
            //
            Reconnect();
        }
    }

    CMTRACE(TEXT("The connection thread is terminated"));

    //
    // The connection is terminated without need to ask for reconnect
    // Remove the connection from monitor conntected connection array
    // If fRemoveFromSharedTable is FALSE, do not clear the entry from shared table. 
    // CmCustomHangup clears the table
    // Monitor will delete the connection object.  Must exit the thread after this. 
    //
    CMonitor::RemoveConnection(this, fRemoveFromSharedTable);

    CMonitor::MinimizeWorkingSet();

    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnectedInit
//
// Synopsis:  Initialization for the connected state, unlike the connstructor
//            This is called with in the connection thread
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CCmConnection::StateConnectedInit()
{
    m_dwConnectStartTime = GetTickCount();

    //
    // Load big and small connection icon: m_hBigIcon and m_hSmallIcon
    //
    LoadConnectionIcons();

    m_StatusDlg.Create(CMonitor::GetInstance(), CMonitor::GetMonitorWindow(), m_szServiceName, m_hBigIcon);
    m_StatusDlg.ChangeToStatus();

    //
    // Change the window position, so multiple status window will not be at 
    // the same position
    //
    PositionWindow(m_StatusDlg.GetHwnd(), m_dwPositionId);

    //
    // Change the dialog titlebar icon 
    //
    SendMessageU(m_StatusDlg.GetHwnd(),WM_SETICON,ICON_BIG,(LPARAM) m_hBigIcon);
    SendMessageU(m_StatusDlg.GetHwnd(),WM_SETICON,ICON_SMALL,(LPARAM) m_hSmallIcon);

    //
    // Set the help file name
    //

    LPTSTR lpHelpFile = LoadHelpFileName();
    
    if (lpHelpFile)
    {
        m_StatusDlg.SetHelpFileName(lpHelpFile);
    }
    else
    {
        m_StatusDlg.SetHelpFileName(c_pszDefaultHelpFile);
    }

    CmFree(lpHelpFile);
   
    //
    // Determine whether or not, we're hiding the icon. The default is TRUE 
    // for NT5 because we already have full support from the folder.
    //

    m_fHideTrayIcon= m_IniService.GPPI(c_pszCmSection, c_pszCmEntryHideTrayIcon, OS_NT5);

    if (!m_fHideTrayIcon && !(OS_NT5 && IsLogonAsSystem()))
    {
        HICON hIcon = NULL;

        LPTSTR pszTmp = m_IniService.GPPS(c_pszCmSection, c_pszCmEntryTrayIcon);
        if (*pszTmp) 
        {
            //
            // The icon name is relative to the .cmp file, convert it into full name
            //

            LPTSTR pszFullPath = CmBuildFullPathFromRelative(m_IniProfile.GetFile(), pszTmp);

            hIcon = CmLoadSmallIcon(CMonitor::GetInstance(), pszFullPath);
            
            CmFree(pszFullPath);
        }
        CmFree(pszTmp);

        //
        // Use the default tray icon
        //
        if (!hIcon) 
        {
            hIcon = CmLoadSmallIcon(CMonitor::GetInstance(), MAKEINTRESOURCE(IDI_APP));
        }

        //
        // m_TrayIcon is responsible to delete the hIcon object
        //
        m_TrayIcon.SetIcon(hIcon, m_StatusDlg.GetHwnd(), WM_TRAYICON, 0,m_szServiceName);

        // Question: , shall we also load the tray icon cmd from iniProfile?
        m_TrayIcon.CreateMenu(&m_IniService, IDM_TRAYMENU);
   }

    //
    // Try to call RasConnectionNotification.  When connection is losted
    //  a event will be signaled 
    //
    m_RasApiDll.Load();
    m_hEventRasNotify = CallRasConnectionNotification(m_hRasDial, m_hRasTunnel);

    if (m_hEventRasNotify)
    {
        //
        // If we got the event, unload RAS, otherwise, need to check connection on timer
        //
        m_RasApiDll.Unload();
    }
}




//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnected
//
// Synopsis:  The connection is in the connected or disconnect-count-down state
//            Run the message loop until state is changed
//
// Arguments: None
//
// Returns:   CONN_STATE - The new state, either STATE_TERMINATED or 
//                                STATE_PROMPT_RECONNECT
//
// History:   fengsun Created Header    2/4/98
//
//+----------------------------------------------------------------------------

//
// The reconnect dialog only shows up on Win95 Gold
// And we need to use service name to find the dialog.
//
void ZapRNAReconnectStop(HANDLE hThread);
HANDLE ZapRNAReconnectStart(BOOL *pbConnLost);

void CCmConnection::StateConnected()
{
    ASSERT_VALID(this);
    MYDBGASSERT(m_dwState == STATE_CONNECTED);

    CMTRACE(TEXT("Enter StateConnected"));

    StateConnectedInit();

    HANDLE hThreadRnaReconnect = NULL;

    if (OS_W95)
    {
        hThreadRnaReconnect = ZapRNAReconnectStart(NULL);
    }

    while (m_dwState == STATE_CONNECTED || m_dwState == STATE_COUNTDOWN)
    {
        CONN_EVENT dwEvent = StateConnectedGetEvent();
        MYDBGASSERT(dwEvent <= EVENT_NONE);

        if (dwEvent < EVENT_NONE )
        {
            //
            // Call the event handler to process the event
            //
            m_dwState = StateConnectedProcessEvent(dwEvent);
        }
    }

    if (hThreadRnaReconnect)
    {
        ZapRNAReconnectStop(hThreadRnaReconnect);
    }

}


//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnectedGetEvent
//
// Synopsis:  In the state of CONNECTED/COUNTDOWN. Wait until some event happens. 
//              Also runs the message loop
//
// Arguments: None
//
// Returns:   CCmConnection::CONN_EVENT - The event that can cause the 
//            connection change the state other than CONNECTED/COUNTDOWN
//
// History:   Created Header    2/18/98
//
//+----------------------------------------------------------------------------
CCmConnection::CONN_EVENT CCmConnection::StateConnectedGetEvent()
{
    ASSERT_VALID(this);
    //
    // The last time SateConnectedOnTimer got called
    //

    DWORD dwLastTimerCalled = 0;
    //
    // Loop until we got some event
    //
    while (TRUE)
    {
        MYDBGASSERT(m_dwState == STATE_CONNECTED || m_dwState == STATE_COUNTDOWN);

        //
        // Process all the messages in the message queue
        //
        MSG msg;
        while(PeekMessageU(&msg, NULL,0,0,PM_REMOVE))
        {
            if (msg.hwnd == NULL)
            {
                //
                // it is a thread message
                //
                
                MYDBGASSERT((msg.message >= WM_APP) || (msg.message == WM_CONN_EVENT));
                if (msg.message == WM_CONN_EVENT)
                {
                    MYDBGASSERT(msg.wParam < EVENT_NONE);
                    return (CONN_EVENT)msg.wParam;
                }
            }
            else
            {   
                //
                // Also dispatch message for Modeless dialog box
                //
                if (!IsDialogMessageU(m_StatusDlg.GetHwnd(), &msg))
                {
                    TranslateMessage(&msg);
                    DispatchMessageU(&msg);
                }
            }
        }

        //
        // whether cmmon needs timer.
        // The timer is needed, if we have check the ras connection on timer,
        // or we have to check idle disconnect on timer,
        // or the state is disconnect-count-down,
        // or status dialog is visible
        //
        BOOL fNeedTimer = !m_hEventRasNotify 
            || m_IdleStatistics.IsStarted() 
            || m_dwState == STATE_COUNTDOWN
            || IsWindowVisible(m_StatusDlg.GetHwnd());

        //
        // If more than 1 seconds elapsed, call the timer
        //
        if (fNeedTimer && GetTickCount() - dwLastTimerCalled >= TIMER_INTERVAL)
        {
            dwLastTimerCalled = GetTickCount();
            CONN_EVENT dwEvent = StateConnectedOnTimer();

            if (dwEvent != EVENT_NONE)
            {
                return dwEvent;
            }
        }

        //
        // Setup the opbject array for MsgWaitForMultipleObjects
        //

        HANDLE ahObjectsToWait[3];
        int nObjects = 0;

        if (m_hEventRasNotify)
        {
            ahObjectsToWait[nObjects] = m_hEventRasNotify;
            nObjects++;
        }

        if (m_WatchProcess.GetSize())
        {
            //
            // If we have any process to watch, just add the first hProcess
            // Since we want to know whether all processes exit
            //
            ahObjectsToWait[nObjects] = m_WatchProcess.GetProcess(0);
            MYDBGASSERT(ahObjectsToWait[nObjects]);
            nObjects++;
        }

        //
        // From MSDN:
        // The documentation for MsgWaitForMultipleObjects() says that the API returns 
        // successfully when either the objects are signalled or the input is available. 
        // However, the API behaves as if it requires that the objects are signalled 
        // and the input is available. 
        //
        // Put an extra event seems to fix it for NT
        //
        if (OS_NT && nObjects)
        {
            ahObjectsToWait[nObjects] = ahObjectsToWait[nObjects-1];
            nObjects++;
        }

        if (m_fToMinimizeWorkingSet)
        {
            //
            // If we do not need a timer here, minimize the working set.
            // before calling  MsgWaitForMultipleObjects.
            //
            CMonitor::MinimizeWorkingSet();
            m_fToMinimizeWorkingSet = FALSE;
        }

        DWORD dwRes = MsgWaitForMultipleObjects(nObjects, ahObjectsToWait, FALSE, 
            fNeedTimer ? 1000 : INFINITE, 
            QS_ALLINPUT);

        //
        // Timeout
        //
        if (dwRes == WAIT_TIMEOUT)
        {
            //
            // We always checks timer on the beginning of the loop
            //
            continue;
        }

        //
        // An event
        //
#pragma warning(push)
#pragma warning(disable:4296)
        if (dwRes >= WAIT_OBJECT_0 && dwRes < WAIT_OBJECT_0 + nObjects)
#pragma warning(pop)
        {
            BOOL        fLostConnection;
            
            //
            // Ras Event
            //
            if (m_hEventRasNotify && ahObjectsToWait[dwRes - WAIT_OBJECT_0] == m_hEventRasNotify &&
                    !CheckRasConnection(fLostConnection))
            {
                //
                // Got a notification that the RAS connection is losted
                //
                
                CMTRACE(TEXT("CCmConnection::StateConnectedGetEvent() - m_hEventRasNotify && ahObjectsToWait[dwRes - WAIT_OBJECT_0] == m_hEventRasNotify"));
                return EVENT_LOST_CONNECTION;
            }
            else
            {
                //
                // A watch process exits
                // IsIdle() remove the process from the list
                //
                if (m_WatchProcess.IsIdle())
                {
                    //
                    // If all the watch process are terminated, change to disconnect countdown
                    //
                    CMTRACE(TEXT("CCmConnection::StateConnectedGetEvent() - m_WatchProcess.IsIdle()"));
                    return EVENT_IDLE;
                }

                continue;
            }
        }

        //
        // A message
        //
        if (dwRes == WAIT_OBJECT_0 + nObjects)
        {
            continue;
        }

        if (-1 == dwRes)
        {
            CMTRACE1(TEXT("MsgWaitForMultipleObjects failed, LastError:%d"), GetLastError());
            //
            // Something does wrong
            //
            continue;
        }

        //
        // what is this return value
        //
        CMTRACE1(TEXT("MsgWaitForMultipleObjects returns %d"), dwRes);
        continue;
    }

    //
    // should never get here
    //
    MYDBGASSERT(FALSE);
    return EVENT_USER_DISCONNECT;
}



//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnectedOnTimer
//
// Synopsis:  Process the timer in the state of CONNECTED/COUNTDOWN
//
// Arguments: None
//
// Returns:   CCmConnection::CONN_EVENT - The event that can cause the 
//            connection change the state other than CONNECTED/COUNTDOWN or EVENT_NONE
//
// History:   fengsun Created Header    2/18/98
//
//+----------------------------------------------------------------------------
CCmConnection::CONN_EVENT CCmConnection::StateConnectedOnTimer()
{
    ASSERT_VALID(this);
    MYDBGASSERT(m_dwState == STATE_CONNECTED || m_dwState == STATE_COUNTDOWN);

    if (m_dwState != STATE_CONNECTED && m_dwState != STATE_COUNTDOWN)
    {
        return EVENT_NONE;
    }

    //
    // Check whether CM is still connected, only if the Ras notify event is not available
    //
    if (m_hEventRasNotify == NULL)
    {
        BOOL fLostConnection;
        
        BOOL fConnect = CheckRasConnection(fLostConnection);

        CMTRACE2(TEXT("CCmConnection::StateConnectedOnTimer - CheckRasConnection returns %d - fLostConnection is %d"), fConnect, fLostConnection);

        if (!fConnect)
        {
            return (fLostConnection ? EVENT_LOST_CONNECTION : EVENT_USER_DISCONNECT);
        }
    }

    //
    // If we don't have stats, something went wrong accessing the 
    // registry stats earlier, so try to initialize again here.
    //

    if (OS_W98 && !m_ConnStatistics.IsAvailable())
    {
        //
        // Try to initialize the perf stats from the registry again
        //

        CMASSERTMSG(FALSE, TEXT("StateConnectedOnTimer() - Statistics unavailable, re-initializing stats now."));

        m_ConnStatistics.Open(CMonitor::GetInstance(),
                              (DWORD)-1,
                              (DWORD)-1,
                              m_hRasDial,
                              m_hRasTunnel);      
    }

    //
    // Get statistics for Win9x
    //
    
    if (m_ConnStatistics.IsAvailable())
    {
        m_ConnStatistics.Update();

        // 
        // collecting data points for monitoring idle-disconnect
        // check whether ICM has received more data points than the IdleThreshold value
        // during the past IDLE_SPREAD time
        // Start() is not called for NT
        //

        if (m_IdleStatistics.IsStarted())
        {
            m_IdleStatistics.UpdateEveryInterval(m_ConnStatistics.GetBytesRead());
        }
    }

    if (m_dwState == STATE_CONNECTED)
    {
        //
        // Check idle time out
        //

        if (m_IdleStatistics.IsIdleTimeout())
        {
            //
            // Disconnect count down 
            //
            
            CMTRACE(TEXT("CCmConnection::StateConnectedOnTimer() - m_IdleStatistics.IsIdleTimeout()"));
            return EVENT_IDLE;
        }

        //
        // Check process watch list
        //

        if (m_WatchProcess.IsIdle())
        {
            //
            // Disconnect count down 
            //
            
            CMTRACE(TEXT("CCmConnection::StateConnectedOnTimer() - m_WatchProcess.IsIdle())"));
            return EVENT_IDLE;
        }

        //
        // Update the status window, only if the window is visible
        //
        if (IsWindowVisible(m_StatusDlg.GetHwnd()))
        {
            if (m_ConnStatistics.IsAvailable())
            {
                m_StatusDlg.UpdateStats(m_ConnStatistics.GetBaudRate(), 
                                        m_ConnStatistics.GetBytesRead(), 
                                        m_ConnStatistics.GetBytesWrite(), 
                                        m_ConnStatistics.GetBytesPerSecRead(), 
                                        m_ConnStatistics.GetBytesPerSecWrite());
            }

            //
            // We have exact duration numbers from RAS on NT5, so use them.
            //

            if (m_ConnStatistics.GetDuration())
            {
                m_StatusDlg.UpdateDuration(m_ConnStatistics.GetDuration() / 1000);
            }
            else
            {
                m_StatusDlg.UpdateDuration((GetTickCount() - m_dwConnectStartTime) / 1000);
            }
        }

        return EVENT_NONE;
    }
    else    // m_dwState == STATE_COUNTDOWN
    {

        //
        // Note: NetBEUI seems to insist on sending unsolicited 
        // stuff over the dial-up adapter. So we will define 
        // "idle" as "not having received anything".
        //

        //
        //  check whether we have new traffic that exceeds the threshold.
        //  But we don't care about network traffic if the countdown is caused
        //  by 0 watched process
        //
        if (!m_WatchProcess.IsIdle() && !m_IdleStatistics.IsIdle() )
        {

            // 
            // We were in our idle wait, but we just picked up some
            // activity. Stay on line.
            // If this is NT5 we don't use our own status dialog so just hide
            // it again.  If this is downlevel then just change the dialog to
            // a status dialog
            //
            if (OS_NT5)
            {
                m_StatusDlg.DismissStatusDlg();
            }
            else
            {
                m_StatusDlg.ChangeToStatus();
            }

            m_dwState = STATE_CONNECTED;

            return EVENT_NONE; 
        } 

        //
        // If the time elapsed is more than 30 second, timeout
        //

        DWORD dwElapsed = GetTickCount() - m_dwCountDownStartTime;

        if (dwElapsed > IDLE_DLG_WAIT_TIMEOUT) 
        {
            //
            // Connection has been idle for timeout period and the
            // grace period is up with no user intervention, so we
            // quit/disconnect, and ask for reconnect
            //

            CMTRACE(TEXT("CCmConnection::StateConnectedOnTimer() - dwElapsed > IDLE_DLG_WAIT_TIMEOUT"));
            return EVENT_COUNTDOWN_ZERO;
        } 
        else 
        {
            //
            // Connection has been idle for timeout period but we 
            // are still in the grace period, show countdown.
            //

            int nTimeLeft = (int) ((IDLE_DLG_WAIT_TIMEOUT - dwElapsed) / 1000);
            
            //
            // Update duration and countdown seconds left.
            //
            
            if (m_ConnStatistics.GetDuration()) // NT5 only
            {
                m_StatusDlg.UpdateCountDown(m_ConnStatistics.GetDuration() / 1000,
                                            nTimeLeft);
            }
            else
            {
                m_StatusDlg.UpdateCountDown((GetTickCount() - m_dwConnectStartTime) / 1000, 
                                            nTimeLeft);
            }
        }

        return EVENT_NONE;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnectedProcessEvent
//
// Synopsis:  Process the connection event while in CONNECTED/COUNTDOWN state
//
// Arguments: CONN_EVENT dwEvent - the event to process
//
// Returns:   CCmConnection::CONN_STATE - The new state of the connection
//
// History:   fengsun Created Header    2/19/98
//
//+----------------------------------------------------------------------------
CCmConnection::CONN_STATE CCmConnection::StateConnectedProcessEvent(CONN_EVENT dwEvent)
{
    ASSERT_VALID(this);
    switch (dwEvent)
    {
    case EVENT_IDLE:
        CMTRACE(TEXT("StateConnectedProcessEvent EVENT_IDLE"));

        if (m_dwState != STATE_COUNTDOWN)
        {
            //
            // No-traffic/ No-watch-process idle event
            // change to Disconnect count down 
            //
            m_dwCountDownStartTime = GetTickCount();
            m_StatusDlg.ChangeToCountDown();
            //
            // Update duration and countdown seconds left
            //
            
            int nTimeLeft = IDLE_DLG_WAIT_TIMEOUT / 1000;

            if (m_ConnStatistics.GetDuration()) // NT5 only
            {
                m_StatusDlg.UpdateCountDown(m_ConnStatistics.GetDuration() / 1000,
                                            nTimeLeft);
            }
            else
            {
                m_StatusDlg.UpdateCountDown((GetTickCount() - m_dwConnectStartTime) / 1000, 
                                            nTimeLeft);
            }

            //
            //  Don't show the UI if we are at Winlogon unless we are on NT4
            //
            if (!IsLogonAsSystem() || OS_NT4)
            {
                m_StatusDlg.BringToTop();
            }
        }

        return STATE_COUNTDOWN;

    case EVENT_CMDIAL_HANGUP:
        CMTRACE(TEXT("StateConnectedProcessEvent EVENT_CMDIAL_HANGUP"));

        m_Log.Log(DISCONNECT_EXT);

        //
        // Cmdial posted cmmon a message to clean up the connection.
        // Do not need to call hangup here
        //
        StateConnectedCleanup();

        return STATE_TERMINATED;

    case EVENT_LOST_CONNECTION:
    case EVENT_COUNTDOWN_ZERO:
        CMTRACE(TEXT("StateConnectedProcessEvent EVENT_LOST_CONNECTION/EVENT_COUNTDOWN_ZERO"));
        
        //
        // lost-ras-connection event or the count down counter is down to 0
        //        
        if (IsPromptReconnectEnabled() && !m_WatchProcess.IsIdle() ||
            ( dwEvent == EVENT_LOST_CONNECTION && IsAutoReconnectEnabled() ) )
        {
            CmCustomHangup(TRUE); // fPromptReconnect = TRUE, do not remove from Conn Table

            //
            // It is possible
            // Someone else called cmdial to disconnect, while we are disconnecting.
            // If the ref count is down to  0, cmdial will remove the entry
            //

            CM_CONNECTION CmEntry;
            if (CMonitor::ConnTableGetEntry(m_szServiceName, &CmEntry))
            {
                //
                // Cmdial should change the state to CM_RECONNECTPROMPT
                //
                CMTRACE2(TEXT("CmEntry.CmState is %d, event is %d"), CmEntry.CmState, dwEvent);
                
                MYDBGASSERT(CmEntry.CmState == CM_RECONNECTPROMPT);

                if (EVENT_LOST_CONNECTION == dwEvent)
                {
                    m_Log.Log(DISCONNECT_EXT_LOST_CONN);
                }
                else if (EVENT_COUNTDOWN_ZERO == dwEvent)
                {
                    m_Log.Log(DISCONNECT_INT_AUTO);
                }

                //
                // is auto reconnect enabled(don't show reconnect prompt)?
                //
                if (dwEvent == EVENT_LOST_CONNECTION && IsAutoReconnectEnabled())
                {
                    //
                    //  On win98 Gold, we have a timing issue with Auto Reconnect because
                    //  notification that the line was dropped is sent before cleanup for
                    //  the connection takes place.  Thus, we need to poll the connection
                    //  status using RasGetConnectionStatus until the line is available
                    //  before trying to reconnect.  NTRAID 273033.
                    //
                    if (OS_W98 && (NULL != m_hRasDial))
                    {
                        BOOL bConnectionActive;
                        BOOL bLostConnection;   //ignored
                        int iCount = 0;

                        do
                        {
                            bConnectionActive = CheckRasConnection(bLostConnection);
                            if (bConnectionActive)
                            {
                                Sleep(50);
                            }

                            iCount++;
                            
                            // 50 Milliseconds * 200 = 10 seconds
                            // If waiting 10 seconds hasn't fixed it, not sure that it will
                            // get fixed by this method.
                            

                        } while ((200 >= iCount) && (bConnectionActive));
                    }

                    return STATE_RECONNECTING;
                }

                return STATE_PROMPT_RECONNECT;
            }
            else
            {
                return STATE_TERMINATED;
            }
        }

        //
        // Else fall through
        //
    
    case EVENT_USER_DISCONNECT:
        CMTRACE(TEXT("StateConnectedProcessEvent EVENT_USER_DISCONNECT"));

        m_Log.Log(DISCONNECT_INT_MANUAL);

        //
        // For EVENT_USER_DISCONNECT
        // User can disconnect from tray icon, status dialog, or countdown dialog.
        // Or prompt reconnect is not enabled             
        //
        CmCustomHangup(FALSE); // fPromptReconnect = FALSE
        return STATE_TERMINATED;

    default:
        //
        // Unexpected event, do the same thing as EVENT_USER_DISCONNECT
        //
        MYDBGASSERT(FALSE);
        CmCustomHangup(FALSE); // fPromptReconnect = FALSE
        return STATE_TERMINATED;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::IsAutoReconnectEnabled
//
// Synopsis:  See if auto-reconnect is enabled, but only if we aren't logged-in
//            as system.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/18/98
//            tomkel  moved from connection.h  06/06/2001
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::IsAutoReconnectEnabled() const
{
    //
    // Load the AutoReconnect flag from profile
    // Default is FALSE
    //
    BOOL fReturn = FALSE;

    if (!IsLogonAsSystem())
    {
        fReturn = m_IniService.GPPB(c_pszCmSection, c_pszCmEntryAutoReconnect, FALSE);
    }

    return fReturn; 
}


//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StateConnectedCleanup
//
// Synopsis:  Cleanup before exiting the connected state
//
// Arguments: BOOL fEndSession, whether windows is going to logoff/shutdown
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/18/98
//
//+----------------------------------------------------------------------------
void CCmConnection::StateConnectedCleanup(BOOL fEndSession)
{
    ASSERT_VALID(this);
    //
    // Remove the trayicon, destroy the status dialog
    //
    m_TrayIcon.RemoveIcon();
    m_ConnStatistics.Close();

    //
    // Do not close window on WM_ENDSESSION.  Otherwise, cmmon would be terminated right here
    //
    if (!fEndSession)
    {
        m_StatusDlg.KillRasMonitorWindow();
        DestroyWindow(m_StatusDlg.GetHwnd());
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::IsPromptReconnectEnabled
//
// Synopsis:  When prompt-reconnect is enabled by the profile
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/18/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::IsPromptReconnectEnabled() const
{
    //
    // Load the NoPromptReconnect flag from profile.  Also check the Unattended flag and
    // if we are running in the system account on win2k or Whistler.  If any of the above
    // are true then we don't prompt, otherwise we do.
    //

    BOOL fPromptReconnect = !(m_IniService.GPPB(c_pszCmSection,
        c_pszCmEntryNoPromptReconnect, FALSE)); 

    if (!fPromptReconnect || (m_ReconnectInfo.dwCmFlags & FL_UNATTENDED) || (IsLogonAsSystem() && OS_NT5))
    {
        //
        // Do not prompt reconnect
        //
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::CmCustomHangup
//
// Synopsis:  Call cmdial to hangup the connection
//
// Arguments: BOOL fPromptReconnect, whether cmmon are going to prompt the 
//                  reconnect dialog
//            BOOL fEndSession, whther windows is going to logoff/shutdown
//                  Default value is FALSE
//
// Returns:   Nothing
//
// History:   fegnsun Created Header    2/11/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::CmCustomHangup(BOOL fPromptReconnect, BOOL fEndSession)
{
    ASSERT_VALID(this);

    CMTRACE2(TEXT("CCmConnection::CmCustomHangup - fPromptReconnect is %d and fEndSession is %d"), fPromptReconnect, fEndSession);

    //
    // Remove the trayicon close status dlg, before hangup
    //
    StateConnectedCleanup(fEndSession);

    //
    // It is possible the connection is disconnected or disconnecting
    //

    CM_CONNECTION CmEntry;

    if (!CMonitor::ConnTableGetEntry(m_szServiceName, &CmEntry) ||
        CmEntry.CmState != CM_CONNECTED)
    {
        //
        // The connection is disconnected by someone else, do not hangup.
        //

        CMTRACE(TEXT("CCmConnection::CmCustomHangup - Entry is not connected, canceling hangup"));       
        return TRUE; 
    }

    //
    // Call cmdial32.dll CmCustomHangup
    //

    //
    // The destructor of CDynamicLibrary calls FreeLibrary
    //
    CDynamicLibrary LibCmdial;
    
    if (!LibCmdial.Load(TEXT("cmdial32.dll")))
    {
        MYDBGASSERT(FALSE);
        return FALSE;
    }

    CmCustomHangUpFUNC pfnCmCustomHangUp;

    pfnCmCustomHangUp = (CmCustomHangUpFUNC)LibCmdial.GetProcAddress(c_pszCmHangup);
    MYDBGASSERT(pfnCmCustomHangUp);

    if (pfnCmCustomHangUp)
    {
        //
        // hRasConn = NULL, 
        // fIgnoreRefCount = TRUE, always except for InetDialHandler
        // fPersist = fPromptReconnect, do not remove the entry if 
        // we are going to prompt for reconnect
        //
        DWORD dwRet;
        dwRet = pfnCmCustomHangUp(NULL, m_szServiceName, TRUE, fPromptReconnect);
        CMTRACE1(TEXT("CCmConnection::CmCustomHangup -- Return Value from CmCustomHangup is %u"), dwRet);
        return (ERROR_SUCCESS == dwRet);
    }

    return FALSE;

}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::CallRasConnectionNotification
//
// Synopsis:  call RasConnectionNotify.  Ras will set the event when connection
//             is lost
//
// Arguments: HRASCONN hRasDial - The dial ras handle
//            HRASCONN hRasTunnel - The tunnel ras handle
//
// Returns:   HANDLE - the event handle, or NULL if failed
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
HANDLE CCmConnection::CallRasConnectionNotification(HRASCONN hRasDial, HRASCONN hRasTunnel)
{
    DWORD       dwRes;
    
    MYDBGASSERT(hRasDial || hRasTunnel);

    //
    // Call RasConnectionNotification.  Ras will call us back when connection is losted.
    // However, this fuction is not avaliable for Win95 with DUN 1.0
    //

    if (!m_RasApiDll.HasRasConnectionNotification())
    {
        return NULL;
    }

    HANDLE hEvent = NULL;

    if (OS_W9X)
    {
        //
        // Create an manual-reset non-signaled event on Win95, Win98 & WinME
        //
        hEvent = CreateEventU(NULL, TRUE, FALSE, NULL);
    }
    else
    {
        //
        // Create an auto-reset non-signaled event
        //
        hEvent = CreateEventU(NULL, FALSE, FALSE, NULL);

    }

    //
    // v-vijayb: Changed to use INVALID_HANDLE_VALUE(notify for all disconnects), as we where
    // not getting notified after a reconnect or after connecting thru winlogon.
    // StateConnectedGetEvent() will check if this connection is lost to determine if it was 
    // a disconnection of this connection or some other.
    //
    if (hRasDial)
    {
        //
        // Copied from RAS.h
        // #if (WINVER >= 0x401)
        //
        #define RASCN_Disconnection     0x00000002
        if (OS_NT)
        {
            dwRes = m_RasApiDll.RasConnectionNotification((HRASCONN) INVALID_HANDLE_VALUE, hEvent, RASCN_Disconnection);
        }
        else
        {
            dwRes = m_RasApiDll.RasConnectionNotification(hRasDial, hEvent, RASCN_Disconnection);
        }
        
        if (dwRes != ERROR_SUCCESS)
        {
            CMASSERTMSG(FALSE, TEXT("RasConnectionNotification Failed"));
            CloseHandle(hEvent);
            return NULL;
        }
    }

    if (hRasTunnel)
    {
        if (OS_NT)
        {
            dwRes = m_RasApiDll.RasConnectionNotification((HRASCONN) INVALID_HANDLE_VALUE, hEvent, RASCN_Disconnection);
        }
        else
        {
            dwRes = m_RasApiDll.RasConnectionNotification(hRasTunnel, hEvent, RASCN_Disconnection);
        }
        
        if (dwRes != ERROR_SUCCESS)
        {
            CMASSERTMSG(FALSE, TEXT("RasConnectionNotification Failed"));
            CloseHandle(hEvent);
            return NULL;
        }
    }

    return hEvent;
}

//+---------------------------------------------------------------------------
//
//  struct RASMON_THREAD_INFO
//
//  Description: Information passed to RasMonitorDlgThread by OnStatusDetails
//
//  History:    fengsun Created     2/11/98
//
//----------------------------------------------------------------------------
struct RASMON_THREAD_INFO
{
    HRASCONN hRasConn; // the ras handle to display status
    HWND hwndParent;   // the parent window for the RasMonitorDlg
};

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::OnStatusDetails
//
// Synopsis:  Called upon pressing detailed button on NT status dlg
//            Call RasMonitorDlg to display the dial-up monitor 
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/98
//
//+----------------------------------------------------------------------------

void CCmConnection::OnStatusDetails()
{
    ASSERT_VALID(this);
    //
    // RasDlg.dll is not available for Win9X
    //
    MYDBGASSERT(OS_NT4);

    if (!OS_NT4)
    {
        return;
    }

    //
    // RasMonitorDlg pops up a modal dialog box, which will block the thread message loop.
    // No thread message or event can be processed
    // Create another thread to call RasMonitorDlg
    //

    //
    // Alloc the parametor from heap. It is not safe to use stack here.
    // CreateThread can return before the thread routine is called
    // The thread is responsible to free the pointer
    //
    RASMON_THREAD_INFO* pInfo = (RASMON_THREAD_INFO*)CmMalloc(sizeof(RASMON_THREAD_INFO));
    if (NULL == pInfo)
    {
        CMTRACE(TEXT("CCmConnection::OnStatusDetails alloc for pInfo failed"));
        return;
    }
    
    pInfo->hRasConn = m_hRasTunnel?m_hRasTunnel : m_hRasDial;
    pInfo->hwndParent = m_StatusDlg.GetHwnd();

    DWORD dwThreadId;
    HANDLE hThread;
    if ((hThread = CreateThread(NULL, 0, RasMonitorDlgThread ,pInfo,0,&dwThreadId)) == NULL)
    {
        MYDBGASSERT(FALSE);
        CMTRACE(TEXT("CCmConnection::OnStatusDetails CreateThread failed"));
        CmFree(pInfo);
        return ;
    }

    CloseHandle(hThread);
}


//+----------------------------------------------------------------------------
//
// Function:  static CCmConnection::RasMonitorDlgThread
//
// Synopsis:  The thread to call RasMonitorDlg to avoid blocking the thread 
//            message loop.  RasMonitorDlg is a modal dialogbox.  The thead exits
//            when the dialog is closed.  That happens when user close the dialog box, 
//            or m_StatusDlg.KillRasMonitorWindow() is called
//
// Arguments: LPVOID lParam - RASMON_THREAD_INFO* the information passed to the thread
//
// Returns:   DWORD WINAPI - The thread return value
//
// History:   fengsun Created Header    2/19/98
//
//+----------------------------------------------------------------------------
DWORD WINAPI CCmConnection::RasMonitorDlgThread(LPVOID lParam)
{
    MYDBGASSERT(lParam);

    RASMON_THREAD_INFO* pInfo = (RASMON_THREAD_INFO*)lParam;

    MYDBGASSERT(pInfo->hRasConn);
    
    //
    // Get the device name first, if tunnel is available, use tunnel device
    //
    RASCONNSTATUS rcsStatus;
    memset(&rcsStatus,0,sizeof(rcsStatus));
    rcsStatus.dwSize = sizeof(rcsStatus);

    //
    // Load Rasapi32.dll here.  This dll is not loaded on NT
    // Destructor will unload the DLL
    //
    CRasApiDll rasApiDll;
    if (!rasApiDll.Load())
    {
        MYDBGASSERT(FALSE);
        CmFree(pInfo);
        return 1;
    }

    DWORD dwRes = rasApiDll.RasGetConnectStatus(pInfo->hRasConn, &rcsStatus);
    CMASSERTMSG(dwRes == ERROR_SUCCESS, TEXT("RasGetConnectStatus failed"));

    //
    // The connection is lost.  Still call RasMonitorDlg with empty name
    //

    RASMONITORDLG RasInfo;
    WORD (WINAPI *pfnFunc)(LPTSTR,LPRASMONITORDLG) = NULL;

    ZeroMemory(&RasInfo,sizeof(RasInfo));
    RasInfo.dwSize = sizeof(RasInfo);
    RasInfo.hwndOwner = pInfo->hwndParent;
    RasInfo.dwStartPage = RASMDPAGE_Status;

    CmFree(pInfo);

    //
    // Call rasdlg.dll -> RasMonitorDlg
    //
    
    //
    // The destructor of CDynamicLibrary calls FreeLibrary
    //
    CDynamicLibrary LibRasdlg;

    if (!LibRasdlg.Load(TEXT("RASDLG.DLL")))
    {
        CMTRACE1(TEXT("Rasdlg.dll LoadLibrary() failed, GLE=%u."), GetLastError());
        return 1;
    }

    pfnFunc = (WORD (WINAPI *)(LPTSTR,LPRASMONITORDLG))LibRasdlg.GetProcAddress("RasMonitorDlg"A_W);
    if (pfnFunc)
    {
        pfnFunc(rcsStatus.szDeviceName, &RasInfo);
    }

    LibRasdlg.Unload();
    rasApiDll.Unload();

    //
    // Minimize the working set before exit the thread.
    //
    CMonitor::MinimizeWorkingSet();
    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::StatePrompt
//
// Synopsis:  The connection is in the prompt-reconnect stste
//            Run the message loop until state is changed
//
// Arguments: None
//
// Returns:   CONN_STATE - The new state, either STATE_TERMINATED or 
//                                STATE_RECONNECTING
//
// History:   fengsun Created Header    2/4/98
//
//+----------------------------------------------------------------------------
CCmConnection::CONN_STATE CCmConnection::StatePrompt()
{
    ASSERT_VALID(this);
    MYDBGASSERT(m_dwState == STATE_PROMPT_RECONNECT);
//    MYDBGASSERT(!IsWindow(m_StatusDlg.GetHwnd()));

    CMTRACE(TEXT("Enter StatePrompt"));

    LPTSTR pszReconnectMsg = CmFmtMsg(CMonitor::GetInstance(),IDMSG_RECONNECT,m_szServiceName);

    m_ReconnectDlg.Create(CMonitor::GetInstance(), NULL,
        pszReconnectMsg,m_hBigIcon);

    CmFree(pszReconnectMsg);

    //
    // Change the window position, so multiple status window will not be at 
    // the same position
    //
    PositionWindow(m_ReconnectDlg.GetHwnd(), m_dwPositionId);

    //
    // Change the dialog titlebar icon. This does not work,
    // Reconnect dialog does not have system menu icon
    //
    SendMessageU(m_ReconnectDlg.GetHwnd(),WM_SETICON,ICON_BIG,(LPARAM) m_hBigIcon);
    SendMessageU(m_ReconnectDlg.GetHwnd(),WM_SETICON,ICON_SMALL,(LPARAM) m_hSmallIcon);

    //
    // Minimize the working set
    //
    CMonitor::MinimizeWorkingSet();

    MSG msg;
    while(GetMessageU(&msg, NULL,0,0))
    {
        if (msg.hwnd == NULL)
        {
            //
            // it is a thread message
            //

            MYDBGASSERT((msg.message >= WM_APP) || (msg.message == WM_CONN_EVENT));
            if (msg.message == WM_CONN_EVENT)
            {
                MYDBGASSERT(msg.wParam == EVENT_USER_DISCONNECT 
                        || msg.wParam == EVENT_RECONNECT
                        || msg.wParam == EVENT_CMDIAL_HANGUP);
                break;
            }
        }
        else
        {
            //
            // Also dispatch message for Modeless dialog box
            //
            if (!IsDialogMessageU(m_ReconnectDlg.GetHwnd(), &msg))
            {
                TranslateMessage(&msg);
                DispatchMessageU(&msg);
            }
        }

    }

    //
    // If the status window is not destroyed yet, destroy it now
    //
    if (IsWindow(m_ReconnectDlg.GetHwnd()))
    {
        DestroyWindow(m_ReconnectDlg.GetHwnd());
    }

    if (msg.wParam == EVENT_RECONNECT)
    {
        return STATE_RECONNECTING;
    }
    else
    {
        return STATE_TERMINATED;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::OnTrayIcon
//
// Synopsis:  called Upon tray icon message
//
// Arguments: WPARAM wParam - wParam of the message
//            LPARAM lParam - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/4/98
//
//+----------------------------------------------------------------------------
DWORD CCmConnection::OnTrayIcon(WPARAM, LPARAM lParam)
{
    ASSERT_VALID(this);
    MYDBGASSERT(m_dwState == STATE_CONNECTED || m_dwState == STATE_COUNTDOWN);

    switch (lParam) 
    {
        case WM_LBUTTONDBLCLK:
            //
            //  Don't show the UI if we are at Winlogon unless we are on NT4
            //
            if (!IsLogonAsSystem() || OS_NT4)
            {
                m_StatusDlg.BringToTop();
            }
            break;

        case WM_RBUTTONUP: 
            {
                //
                // Popup the tray icon menu at the mouse location
                //
                POINT PosMouse;
                if (!GetCursorPos(&PosMouse))
                {
                    MYDBGASSERT(FALSE);
                    break;
                }
                //
                // From Microsoft Knowledge Base
                // PRB: Menus for Notification Icons Don't Work Correctly
                // To correct the first behavior, you need to make the current window 
                // the foreground window before calling TrackPopupMenu
                //
                //  see also fixes for Whistler bugs 41696 and 90576
                //

                if (FALSE == SetForegroundWindow(m_StatusDlg.GetHwnd()))
                {
                    CMTRACE(TEXT("SetForegroundWindow before TrackPopupMenu failed"));
                }

                m_TrayIcon.PopupMenu(PosMouse.x, PosMouse.y, m_StatusDlg.GetHwnd());
                PostMessageU(m_StatusDlg.GetHwnd(), WM_NULL, 0, 0);
            }
            break;

        default:
            break;
    }

    return TRUE;
}




//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::OnStayOnLine
//
// Synopsis:  Called when "Stay Online" button is pressed in the disconnect
//            count down dialog box
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/98
//
//+----------------------------------------------------------------------------
void CCmConnection::OnStayOnLine()
{
    ASSERT_VALID(this);
    //
    // Change the dialog to display status
    //
    m_StatusDlg.ChangeToStatus();
    m_dwState = STATE_CONNECTED;

    if (m_WatchProcess.IsIdle())
    {
        //
        // If idle bacause of no watching process
        // User clickes stay online, 0 watch process is not idle any more
        //
        m_WatchProcess.SetNotIdle();
    }

    if (m_IdleStatistics.IsIdleTimeout())
    {
        //
        // If idle bacause of no traffic
        // User clickes stay online, restart the idle counter
        //
        m_IdleStatistics.Reset();
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::PostHangupMsg
//
// Synopsis:  Called by monitor to clean up the connection.  The request was 
//            come from cmdial to remove tray icon  and status dialog
//            cmdial is responsible to actually hangup the connection
// 
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/98
//
//+----------------------------------------------------------------------------
void CCmConnection::PostHangupMsg() const
{
    //
    // NOTE: This function is called within the Monitor thread
    // Do not referrence any volatile data
    // The CMMON_HANGUP_INFO request can come in at any state
    //

    //
    // Post a message, so this will be handled in the connection thread
    //
    BOOL fRet = PostThreadMessageU(m_dwThreadId,WM_CONN_EVENT, EVENT_CMDIAL_HANGUP, 0);
    
#if DBG
    if (FALSE == fRet)
    {
        CMTRACE1(TEXT("CCmConnection::PostHangupMsg -- PostThreadMessage failed (GLE = %d)"), GetLastError());
    }
#endif
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::Reconnect
//
// Synopsis:  The connection is in reconnecting state
//            Simply load cmdial32.dll and call CmCustomDialDlg
//
// Arguments: None
//
// Returns:   BOOL whether reconnect successfully
//
// History:   fengsun Created Header    2/11/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::Reconnect()
{
    ASSERT_VALID(this);
    MYDBGASSERT(m_dwState == STATE_RECONNECTING);

    CMTRACE(TEXT("Enter Reconnect"));

    //
    // Load cmdial32.dll and call CmReConnect();
    //

    //
    // The destructor of CDynamicLibrary calls FreeLibrary
    //
    CDynamicLibrary LibCmdial;
    
    if (!LibCmdial.Load(TEXT("cmdial32.dll")))
    {
        MYDBGASSERT(FALSE);
        return FALSE;
    }

    CmReConnectFUNC pfnCmReConnect;

    pfnCmReConnect = (CmReConnectFUNC)LibCmdial.GetProcAddress(c_pszCmReconnect);
    MYDBGASSERT(pfnCmReConnect);

    if (!pfnCmReConnect)
    {
        return FALSE;
    }

    //
    //  Log that we're reconnecting
    //
    m_Log.Log(RECONNECT_EVENT);

    //
    // If we have a RAS phonebook name pass it to reconnect, else NULL for system
    //

    if (m_szRasPhoneBook[0])
    {
        return (pfnCmReConnect(m_szRasPhoneBook, m_szServiceName, &m_ReconnectInfo));
    }
    else
    {
        return (pfnCmReConnect(NULL, m_szServiceName, &m_ReconnectInfo));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::CheckRasConnection
//
// Synopsis:  Check whether the RAS connection is still connected
//
// Arguments: OUT BOOL& fLostConnection - 
//                If the no longer connected, TRUE means lost connection
//                                            FALSE means user disconnect
//
// Returns:   BOOL - Whether still connected
//
// History:   fengsun Created Header    2/8/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::CheckRasConnection(OUT BOOL& fLostConnection)
{
    ASSERT_VALID(this);

    MYDBGASSERT(m_hRasDial != NULL || m_hRasTunnel != NULL);

    // Whether we are still connected   
    BOOL fConnected = TRUE;
    RASCONNSTATUS rcsStatus;
    DWORD dwRes = ERROR_SUCCESS;

    if (NULL == m_hRasDial && NULL == m_hRasTunnel)
    {
        //
        //  If both m_hRasTunnel and m_hRasDial are NULL, we're definitely not
        //  connected.  Yes, we have lost the connection, and return value is FALSE.
        //
        fLostConnection = TRUE;
        return FALSE;
    }

    // check tunnel status first
    if (m_hRasTunnel != NULL) 
    {
        memset(&rcsStatus,0,sizeof(rcsStatus));
        rcsStatus.dwSize = sizeof(rcsStatus);

        //
        // This function will load RASAPI32.dll, if not loaded yet
        // Will not unload RASAPI32.dll, since this function is called on timer
        //
        dwRes = m_RasApiDll.RasGetConnectStatus(m_hRasTunnel, &rcsStatus);
        if (dwRes != ERROR_SUCCESS  || rcsStatus.rasconnstate == RASCS_Disconnected) 
        {
            //
            // The connection is lost
            //
            fConnected = FALSE;
        }
    }

    // check dialup connection status
    if (fConnected && m_hRasDial != NULL)
    {
        memset(&rcsStatus,0,sizeof(rcsStatus));
        rcsStatus.dwSize = sizeof(rcsStatus);
        dwRes = m_RasApiDll.RasGetConnectStatus(m_hRasDial, &rcsStatus);
    }

    if ((dwRes == ERROR_SUCCESS) 
         && ((rcsStatus.rasconnstate != RASCS_Disconnected) 
            || (rcsStatus.dwError == PENDING))) 
    {
        // CMTRACE(TEXT("CCmConnection::CheckRasConnection - rcsStatus.rasconnstate != RASCS_Disconnected || rcsStatus.dwError == PENDING"));
        return TRUE;
    }

    //
    // CM is no longer connected
    //

    CMTRACE3(TEXT("OnTimer() RasGetConnectStatus() returns %u, rasconnstate=%u, dwError=%u."), dwRes, 
        rcsStatus.rasconnstate, rcsStatus.dwError);

    if (rcsStatus.dwError == ERROR_USER_DISCONNECTION && OS_W9X)
    {
        fLostConnection = FALSE;

        //
        // On NT, ERROR_USER_DISCONNECTION is received in
        // the event of idle disconnect which we consider 
        // a lost connection
        // 
    }
    else
    {
        fLostConnection = TRUE;
    }

    return FALSE;
}



//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::OnEndSession
//
// Synopsis:  Called upon WM_ENDSESSION message
//
// Arguments: BOOL fEndSession - whether the session is being ended, wParam
//            BOOL fLogOff - whether the user is logging off or shutting down, 
//                           lParam
//
// Returns:   Nothing
//
// History:   fengsun Created Header    5/4/98
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::OnEndSession(BOOL fEndSession, BOOL)
{
    CMTRACE(TEXT("CCmConnection::OnEndSession"));
    if (fEndSession)
    {
        //
        // The session can end any time after this function returns
        // If we are connected, hangup the connection
        //
        if(m_dwState == STATE_CONNECTED || m_dwState == STATE_COUNTDOWN)
        {
            return CmCustomHangup(FALSE, TRUE); // fPromptReconnect = FALSE, fEndSession = TRUE
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::OnAdditionalTrayMenu
//
// Synopsis:  Called upon additional menuitem is selected from tray icon menu
//
// Arguments: WORD nCmd - LOWORD(wParam) of WM_COMMAND, the menu id
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CCmConnection::OnAdditionalTrayMenu(WORD nCmd)
{
    ASSERT_VALID(this);
    MYDBGASSERT( (nCmd >= IDM_TRAYMENU) 
        && nCmd <(IDM_TRAYMENU + m_TrayIcon.GetAdditionalMenuNum()));

    nCmd -= IDM_TRAYMENU; // get the index for the command

    if (nCmd >= m_TrayIcon.GetAdditionalMenuNum())
    {
        return;
    }

    //
    // Run the command line
    //
    ExecCmdLine(m_TrayIcon.GetMenuCommand(nCmd), m_IniService.GetFile());
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::GetProcessId
//
// Synopsis:  Find the process specified by pszModule & returns its PID
//
// Arguments: WCHAR *pszModule
//
// Returns:   PID of process or 0 if not found
//
// History:   v-vijayb    Created     7/20/99
//
//+----------------------------------------------------------------------------
DWORD CCmConnection::GetProcessId(WCHAR *pszModule)
{
    DWORD       dwPID = 0;
    HINSTANCE   hInstLib;
    DWORD       cbPIDs, cbNeeded, iPID, cPIDs;
    DWORD       *pdwPIDs = NULL;
    HANDLE      hProcess;
    HMODULE     hMod;
    WCHAR       szFileName[MAX_PATH + 1];
    
    //
    // PSAPI Function Pointers.
    //

    BOOL (WINAPI *lpfEnumProcesses)(DWORD *, DWORD cb, DWORD *);
    BOOL (WINAPI *lpfEnumProcessModules)(HANDLE, HMODULE *, DWORD, LPDWORD);
    DWORD (WINAPI *lpfGetModuleBaseName)(HANDLE, HMODULE, WCHAR *, DWORD);

    hInstLib = LoadLibrary(TEXT("PSAPI.DLL"));
    if (hInstLib == NULL)
    {
        return (0);
    }

    //
    // Get procedure addresses.
    //
    lpfEnumProcesses = (BOOL(WINAPI *)(DWORD *,DWORD,DWORD*)) GetProcAddress(hInstLib, "EnumProcesses") ;
    lpfEnumProcessModules = (BOOL(WINAPI *)(HANDLE, HMODULE *, DWORD, LPDWORD)) GetProcAddress(hInstLib, "EnumProcessModules") ;
    lpfGetModuleBaseName =(DWORD (WINAPI *)(HANDLE, HMODULE, WCHAR *, DWORD)) GetProcAddress(hInstLib, "GetModuleBaseNameW") ;
    if (lpfEnumProcesses == NULL || lpfEnumProcessModules == NULL || lpfGetModuleBaseName == NULL)
    {
        goto OnError;
    }

    cbPIDs = 256 * sizeof(DWORD);
    cbNeeded = 0;
    do
    {
        if (pdwPIDs != NULL)
        {
            HeapFree(GetProcessHeap(), 0, pdwPIDs);
            cbPIDs = cbNeeded;
        }
        pdwPIDs = (DWORD *) CmMalloc(cbPIDs);
        if (pdwPIDs == NULL)
        {
            goto OnError;
        }
        if (!lpfEnumProcesses(pdwPIDs, cbPIDs, &cbNeeded))
        {
            goto OnError;
        }

    } while (cbNeeded > cbPIDs);

    cPIDs = cbNeeded / sizeof(DWORD);
    for (iPID = 0; iPID < cPIDs; iPID ++)
    {
        szFileName[0] = 0;
        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pdwPIDs[iPID]);
        if (hProcess != NULL)
        {
            if (lpfEnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded))
            {
                if (lpfGetModuleBaseName(hProcess, hMod, szFileName, sizeof(szFileName)))
                {
                    if (lstrcmpiW(pszModule, szFileName) == 0)
                    {
                        dwPID = pdwPIDs[iPID];
                    }
                }
            }

            CloseHandle(hProcess);
            if (dwPID != 0)
            {
                break;
            }
        }

    }

OnError:

    if (pdwPIDs != NULL)
    {
        CmFree(pdwPIDs);
    }
    FreeLibrary(hInstLib);

    return (dwPID);
}

typedef BOOL (WINAPI *lpfDuplicateTokenEx)(
    HANDLE, 
    DWORD, 
    LPSECURITY_ATTRIBUTES, 
    SECURITY_IMPERSONATION_LEVEL, 
    TOKEN_TYPE, 
    PHANDLE
);

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::RunAsUser
//
// Synopsis:  Run the action as an exe or other shell object on the choosen desktop
//
// Arguments: WCHAR *pszProgram - name of module to be launched
//            WCHAR *pszParams  - parameters to be passed to module
//            WCHAR *pszDesktop - desktop on which to launch module
//
// Returns:   HANDLE - The action Process handle, for Win32 only
//
// History:   07/19/99  v-vijayb      Created                        
//            07/27/99  nickball      Return codes and explicit path. 
//
//+----------------------------------------------------------------------------
HANDLE CCmConnection::RunAsUser(WCHAR *pszProgram, WCHAR *pszParams, WCHAR *pszDesktop)
{
    STARTUPINFOW        StartupInfo = {0};
    PROCESS_INFORMATION ProcessInfo = {0};

    WCHAR szShell[MAX_PATH + 1];
    DWORD dwPID;
    HANDLE hProcess = NULL;
    HANDLE hUserToken = NULL;
    HANDLE hProcessToken = NULL;

    MYDBGASSERT(pszProgram);
    CMTRACE(TEXT("RunAsUser"));

    //
    //  NOTE: Normally we only have one icon in the systray, being run by Explorer,
    //        thus any menuitem execution is done in the user's account.  On NT4,
    //        we can't rely on the Connections Folder to handle this for us, so we
    //        create and manage the systray icon ourselves, but we have to make
    //        sure than any items executed, are executed using the User's account.
    //        Or, on NT5 and later, we can have the strange case where HideTrayIcon
    //        is set to 0, thus requiring us to create/manage a systray icon (so
    //        there are 2 connectoids in the systray), hence the code below checks
    //        for all flavors of NT (rather than just NT4).
    //
    if (!OS_NT)
    {
        MYDBGASSERT(FALSE); 
        return NULL;
    }

    //
    // Get the PID for the shell. We expect explorer.exe, but could be others
    //

    GetProfileString(TEXT("windows"), TEXT("shell"), TEXT("explorer.exe"), szShell, MAX_PATH);
    dwPID = GetProcessId(szShell);

    //
    // Now extract the token from the shell process
    //

    if (dwPID)
    {
        //
        // Get the Process handle from the PID
        //

        hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, dwPID);
        CMTRACE1(TEXT("RunAsUser/OpenProcess(PROCESS_ALL_ACCESS, TRUE, dwPID) returns 0x%x"), hProcess);
    
        if (hProcess)
        {
            //
            // Get the token
            //

            if (OpenProcessToken(hProcess, TOKEN_ASSIGN_PRIMARY | TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE, &hProcessToken))
            {
                HINSTANCE hInstLibrary = LoadLibrary(TEXT("ADVAPI32.DLL"));
                CMTRACE1(TEXT("RunAsUser/LoadLibrary(ADVAPI32.DLL) returns 0x%x"), hInstLibrary);

                //
                // Get user token via DuplicateTokenEx and impersonate the user
                //
                
                if (hInstLibrary)
                {
                    lpfDuplicateTokenEx lpfuncDuplicateTokenEx = (lpfDuplicateTokenEx) GetProcAddress(hInstLibrary, "DuplicateTokenEx");
                    
                    CMTRACE1(TEXT("RunAsUser/GetProcAddress(hInstLibrary, DuplicateTokenEx) returns 0x%x"), lpfuncDuplicateTokenEx);

                    if (lpfuncDuplicateTokenEx)
                    {
                        if (lpfuncDuplicateTokenEx(hProcessToken, 
                                                   TOKEN_ASSIGN_PRIMARY | TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE, 
                                                   NULL, 
                                                   SecurityImpersonation, 
                                                   TokenPrimary, 
                                                   &hUserToken))
                        {            
                            BOOL bRes = ImpersonateLoggedOnUser(hUserToken);                   

                            if (FALSE == bRes)
                            {
                                hUserToken = NULL;
                                CMTRACE1(TEXT("RunAsUser/ImpersonateLoggedOnUser failed, GLE=&u"), GetLastError());    
                            }
                        }
                    }

                    FreeLibrary(hInstLibrary);
                }

                CloseHandle(hProcessToken);
            }

            CloseHandle(hProcess);
        }
    }

    CMTRACE1(TEXT("RunAsUser - hUserToken is 0x%x"), hUserToken);

    //
    // Can't impersonate user, don't run because we're in the system account
    //

    if (NULL == hUserToken)
    {
        MYDBGASSERT(FALSE);
        return NULL;   
    }

    //
    // Now prep CreateProcess
    //

    StartupInfo.cb = sizeof(StartupInfo);
    if (pszDesktop)
    {
        StartupInfo.lpDesktop = pszDesktop;
        StartupInfo.wShowWindow = SW_SHOW;
    }

    //
    // Build the path and params
    //

    LPWSTR pszwCommandLine = (LPWSTR) CmMalloc((2 + lstrlen(pszProgram) + 1 + lstrlen(pszParams) + 1) * sizeof(TCHAR));

    if (NULL == pszwCommandLine)
    {
        MYDBGASSERT(FALSE);
        return NULL;
    }

    //
    //  Copy path, but surround with double quotes for security
    //
    lstrcpyU(pszwCommandLine, TEXT("\""));
    lstrcatU(pszwCommandLine, pszProgram);
    lstrcatU(pszwCommandLine, TEXT("\""));

    if (pszParams[0] != L'\0')
    {
        lstrcatU(pszwCommandLine, TEXT(" "));
        lstrcatU(pszwCommandLine, pszParams);
    }
   
    CMTRACE1(TEXT("RunAsUser/CreateProcessAsUser() - Launching %s"), pszwCommandLine);
    
    if (NULL == CreateProcessAsUser(hUserToken, NULL, pszwCommandLine, 
                               NULL, NULL, FALSE, CREATE_SEPARATE_WOW_VDM, 
                               NULL, NULL,
                               &StartupInfo, &ProcessInfo))
    {
        CMTRACE1(TEXT("RunAsUser/CreateProcessAsUser() failed, GLE=%u."), GetLastError());
        ProcessInfo.hProcess = NULL;
    }
    
    CloseHandle(hUserToken);        
    RevertToSelf();
   
    CmFree(pszwCommandLine);
    return (ProcessInfo.hProcess);
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::ExecCmdLine
//
// Synopsis:  ShellExecute the command line
//            The code is copied from CActionList::RunAsExe
//
// Arguments: const TCHAR* pszCmdLine - the command line to run, including
//                  arguments
//            const TCHAR* pszCmsFile - Full path of CMS file
//
// Returns:   BOOL - Whether ShellExecute succeed
//
// Notes:     Menu actions consists of a command string and an optional argument string.
//            The first delimited string is considered the command portion and anything
//            thereafter is treated as the argument portion, which formatless and passed
//            indiscriminately to ShellExecuteEx. Long filename command paths are 
//            enclosed in "+" signs by CMAK. Thus the following permutations are allowed:
//
//            "C:\\Progra~1\\Custom.Exe" 
//            "C:\\Progra~1\\Custom.Exe Args" 
//            "+C:\\Program Files\\Custom.Exe+"
//            "+C:\\Program Files\\Custom.Exe+ Args"
//
// History:   02/10/98  fengsun     Created Header
//            02/09/99  nickball    Fixed long filename bug one year later.
//
//+----------------------------------------------------------------------------
BOOL CCmConnection::ExecCmdLine(const TCHAR* pszCmdLine, const TCHAR* pszCmsFile) 
{
    LPTSTR pszArgs = NULL;
    LPTSTR pszCmd = NULL;

    BOOL bRes = FALSE;

    MYDBGASSERT(pszCmdLine);
    MYDBGASSERT(pszCmsFile);

    if (NULL == pszCmdLine || NULL == pszCmsFile)
    {       
        return FALSE;    
    }
    
    CMTRACE1(TEXT("ExecCmdLine() pszCmdLine is %s"), pszCmdLine);

    if (CmParsePath(pszCmdLine, pszCmsFile, &pszCmd, &pszArgs))
    {    
        CMTRACE1(TEXT("ExecCmdLine() pszCmd is %s"), pszCmd);
        CMTRACE1(TEXT("ExecCmdLine() pszArgs is %s"), pszArgs);
         
        //
        // Now we have the exe name and args separated, execute it
        //

        if (IsLogonAsSystem())
        {
            HANDLE hProcess = RunAsUser(pszCmd, pszArgs, TEXT("Winsta0\\default"));

            if (hProcess)
            {
                CloseHandle(hProcess);
                bRes = TRUE;
            }
            else
            {
                bRes = FALSE;
            }
        }
        else
        {
            SHELLEXECUTEINFO seiInfo;

            ZeroMemory(&seiInfo,sizeof(seiInfo));
            seiInfo.cbSize = sizeof(seiInfo);
            seiInfo.fMask |= SEE_MASK_FLAG_NO_UI;
            seiInfo.lpFile = pszCmd;
            seiInfo.lpParameters = pszArgs;
            seiInfo.nShow = SW_SHOW;

            //
            // Load Shell32.dll and call Shell_ExecuteEx
            //

            CShellDll ShellDll(TRUE); // TRUE == don't unload shell32.dll because of bug 289463
            bRes = ShellDll.ExecuteEx(&seiInfo);

            CMTRACE2(TEXT("ExecCmdLine/ShellExecuteEx() returns %u - GLE=%u"), bRes, GetLastError());
        }           
    }

    CmFree(pszCmd);
    CmFree(pszArgs);
   
    CMTRACE1(TEXT("ExecCmdLine() - Returns %d"), bRes);
   
    return bRes;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::LoadHelpFileName
//
// Synopsis:  Get the connection help file name
//
// Arguments: None
//
// Returns:   LPTSTR - The help file name, can be a empty string
//            caller is responsible to free the pointer
//
// History:   Created Header    2/13/98
//
//+----------------------------------------------------------------------------
LPTSTR CCmConnection::LoadHelpFileName() 
{
    //
    // Read the filename from profile first
    //
    
    LPTSTR pszFullPath = NULL;
    
    LPTSTR pszFileName = m_IniService.GPPS(c_pszCmSection,c_pszCmEntryHelpFile);

    if (pszFileName != NULL && pszFileName[0])
    {
        //
        // The help file name is relative to the .cmp file, convert it into full name
        //
        pszFullPath = CmBuildFullPathFromRelative(m_IniProfile.GetFile(), pszFileName);
    }

    CmFree(pszFileName);
    
    return pszFullPath;
}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::LoadConnectionIcons
//
// Synopsis:  Load big and small icon of the connection
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/13/98
//
//+----------------------------------------------------------------------------
void CCmConnection::LoadConnectionIcons()
{
    // Load large icon name

    LPTSTR pszTmp = m_IniService.GPPS(c_pszCmSection, c_pszCmEntryBigIcon);

    if (*pszTmp) 
    {
        //
        // The icon name is relative to the .cmp file, convert it into full name
        //
        LPTSTR pszFullPath = CmBuildFullPathFromRelative(m_IniProfile.GetFile(), pszTmp);

        m_hBigIcon = CmLoadIcon(CMonitor::GetInstance(), pszFullPath);

        CmFree(pszFullPath);
    }

    CmFree(pszTmp);

    // Use default (EXE) large icon if no user icon found

    if (!m_hBigIcon) 
    {
        m_hBigIcon = CmLoadIcon(CMonitor::GetInstance(), MAKEINTRESOURCE(IDI_APP));
    }

    // Load the small Icon
    // Load small icon name

    pszTmp = m_IniService.GPPS(c_pszCmSection, c_pszCmEntrySmallIcon);
    if (*pszTmp) 
    {
        //
        // The icon name is relative to the .cmp file, convert it into full name
        //
        LPTSTR pszFullPath = CmBuildFullPathFromRelative(m_IniProfile.GetFile(), pszTmp);
        
        m_hSmallIcon = CmLoadSmallIcon(CMonitor::GetInstance(), pszFullPath);

        CmFree(pszFullPath);
    }
    CmFree(pszTmp);

    // Use default (EXE) small icon if no user icon found

    if (!m_hSmallIcon)
    {
        m_hSmallIcon = CmLoadSmallIcon(CMonitor::GetInstance(), MAKEINTRESOURCE(IDI_APP));
    }

}

//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::PositionWindow
//
// Synopsis:  Position the window according to dwPositionId, so multiple 
//            connection window would be positioned differently
//
// Arguments: HWND hWnd - The window to position
//            dwPositionId - the id of the window
//
// Returns:   Nothing
//
// History:   fengsun Created Header    3/25/98
//
//+----------------------------------------------------------------------------
void CCmConnection::PositionWindow(HWND hWnd, DWORD dwPositionId) 
{
    MYDBGASSERT(IsWindow(hWnd));

    //
    // Get the rect of this window
    //
    RECT rcDlg;
    GetWindowRect(hWnd, &rcDlg);

    //
    // center within work area
    //
    RECT rcArea;
    SystemParametersInfoA(SPI_GETWORKAREA, NULL, &rcArea, NULL);


    //
    // Position the window on the desktop work area according to the PositionId
    //      x = Desktop.midX - width/2
    //      y = Desktop.midY - hight/2 + hight * (PostitionId%3 -1)
    // X position is always the same
    // Y position repeat for every three time
    //
    int xLeft = (rcArea.left + rcArea.right) / 2 - (rcDlg.right - rcDlg.left) / 2;
    int yTop = (rcArea.top + rcArea.bottom) / 2 - (rcDlg.bottom - rcDlg.top) / 2
                + (rcDlg.bottom - rcDlg.top) * ((int)dwPositionId%3 -1);

    //
    // if the dialog is outside the screen, move it inside
    //
    if (xLeft < rcArea.left)
    {
        xLeft = rcArea.left;
    }
    else if (xLeft + (rcDlg.right - rcDlg.left) > rcArea.right)
    {
        xLeft = rcArea.right - (rcDlg.right - rcDlg.left);
    }

    if (yTop < rcArea.top)
    {
        yTop = rcArea.top;
    }
    else if (yTop + (rcDlg.bottom - rcDlg.top) > rcArea.bottom)
    {
        yTop = rcArea.bottom - (rcDlg.bottom - rcDlg.top);
    }

    
    SetWindowPos(hWnd, NULL, xLeft, yTop, -1, -1,
        SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

}


#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CCmConnection::AssertValid
//
// Synopsis:  For debug purpose only, assert the connection object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CCmConnection::AssertValid() const
{
    MYDBGASSERT(m_dwState >= 0 && m_dwState <= STATE_TERMINATED);
    MYDBGASSERT(m_hRasDial != NULL || m_hRasTunnel != NULL);
    ASSERT_VALID(&m_ConnStatistics);
    ASSERT_VALID(&m_IdleStatistics);
    ASSERT_VALID(&m_StatusDlg);

    //    ASSERT_VALID(m_TrayIcon);
    //    ASSERT_VALID(m_WatchProcess);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\idlestat.cpp ===
//+----------------------------------------------------------------------------
//
// File:     IdleStat.cpp
//
// Module:   CMMON32.EXE
//
// Synopsis: Implementation of class CIdleStatistics
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 Fengsun Created    10/01/97
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "IdleStat.h"

//+---------------------------------------------------------------------------
//
//	CIdleStatistics::Start()
//
//	Synopsis:	Start the idle statistics
//
//	Arguments:	dwThreshold: The idle threshold.  Traffic in a minute Less than 
//                          the threshold is considered idle
//              dwTimeOut: Idle time out in minisecond
//
//	History:	fengsun	created on 10/1/97
//
//----------------------------------------------------------------------------

void CIdleStatistics::Start(DWORD dwThreshold, DWORD dwTimeOut)
{
    MYDBGASSERT(dwTimeOut != 0);

    m_dwThreshold = dwThreshold;
    m_dwTimeOut = dwTimeOut;
    m_dwStartIdleTime = 0;

    m_DataPointsRing.Reset();
}

//+---------------------------------------------------------------------------
//
//	CIdleStatistics::UpdateEveryInterval()
//
//	Synopsis:	This function should be call every Interval with a updated statistic 
//
//	Arguments:	dwTraffic: the updated statistics
//
//
//	History:	fengsun	created on 10/1/97
//
//----------------------------------------------------------------------------
void CIdleStatistics::UpdateEveryInterval(DWORD dwTraffic)
{
    DWORD dwLast = m_DataPointsRing.GetOldest();

    m_DataPointsRing.Add(dwTraffic);

    if (dwLast == 0) // Started less than a minute
    {
        return;
    }

    if (dwTraffic - dwLast > m_dwThreshold)
    {
        //
        // Not idle
        //
        m_dwStartIdleTime = 0;
    }
    else
    {
        if (m_dwStartIdleTime == 0)
		{
			//
			// We are already idle for 1 minute
			//
            m_dwStartIdleTime = GetTickCount() - IDLE_INTERVAL;
		}
    }
}


#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CIdleStatistics::AssertValid
//
// Synopsis:  For debug purpose only, assert the object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CIdleStatistics::AssertValid() const
{
    MYDBGASSERT(m_dwTimeOut <10000*60*1000); // less than 10000 minutes
    MYDBGASSERT(m_dwThreshold <= 64*1024);
    ASSERT_VALID(&m_DataPointsRing);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\idlestat.h ===
//+----------------------------------------------------------------------------
//
// File:     IdleStat.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Definition for the CIdleStatistics class to handle Idle Disconnect
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

#ifndef IDLESTAT_H
#define IDLESTAT_H

#include "SmplRing.h"

//+---------------------------------------------------------------------------
//
//	class CIdleStatistics
//
//	Description: A class to handle idle disconnect
//               After Start(), call UpdateEveryInterval(dwTraffic) for every 
//               interval, every second.  Then use IsIdle() and IsIdleTimeout()
//               to tell whether it is currently idle and whether the idle 
//               timeout is reached.
//               Note, this class will only handle one direction traffic 
//                     (read or write)
//
//	History:	fengsun	Created		10/1/97
//
//----------------------------------------------------------------------------

class CIdleStatistics
{
public:
    CIdleStatistics();

    void Start(DWORD dwThreshold, DWORD dwTimeOut); // start the idle statistics
    void Stop();                                    // Stop the idle statistics
    BOOL IsStarted() const;                     // Whether the idle statistics is started
                                                //   return FALSE if Start() is not called
                                                //   or Stop() is called
    void Reset();                               // reset idle start time to 0

    BOOL IsIdle() const;                        // Whether the connection is currently idle
    BOOL IsIdleTimeout() const;                 // Whether the idle timeout is reached
    void UpdateEveryInterval(DWORD dwTraffic);  // This function is called every second


protected:
    enum {IDLE_INTERVAL = 60L*1000L };		// 1 minute for idle disconnect time period
    enum {IDLE_MONITOR_DATA_POINTS = IDLE_INTERVAL/1000};  // every second

    DWORD m_dwTimeOut;               // Timeout time in miniseconds
    DWORD m_dwThreshold;             // The threshold, if the traffic in last minute
                                     //     is below threshold, it is considered idle
    DWORD m_dwStartIdleTime;         // The start time when the connection is idle, 
                                     //     or 0 if not currently idle

    CSimpleRing<DWORD, IDLE_MONITOR_DATA_POINTS> m_DataPointsRing;  // A 60 point DWORD data array

public:
#ifdef DEBUG
    void AssertValid() const;
#endif
};


//
// Inline functions
//

inline CIdleStatistics::CIdleStatistics()
{
    m_dwTimeOut = m_dwThreshold = m_dwStartIdleTime = 0; 
}

inline void CIdleStatistics::Reset()
{
    m_dwStartIdleTime = 0;
    m_DataPointsRing.Reset();
}

inline void CIdleStatistics::Stop()
{
    m_dwTimeOut = 0;
}

inline BOOL CIdleStatistics::IsStarted() const
{
    return m_dwTimeOut != 0;
}

inline BOOL CIdleStatistics::IsIdle() const
{
    return IsStarted() && (m_dwStartIdleTime != 0);
}

inline BOOL CIdleStatistics::IsIdleTimeout() const
{
    return IsIdle() && 
		 ( (GetTickCount() - m_dwStartIdleTime) > m_dwTimeOut);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\monitor.cpp ===
//+----------------------------------------------------------------------------
//
// File:     Monitor.cpp
//
// Module:   CMMON32.EXE
//
// Synopsis: Implement class CMonitor
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created    01/22/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "Monitor.h"
#include "Connection.h"

// The following blocks are copied from winuser.h and wtsapi32.h (we compile with
// _WIN32_WINNT set to less than 5.01, so we can't get these values via a #include)
//
#include "winuser.h"
#define WM_WTSSESSION_CHANGE            0x02B1
//
#include "WtsApi32.h"
#define WTS_CONSOLE_CONNECT                0x1
#define WTS_CONSOLE_DISCONNECT             0x2
#define WTS_REMOTE_CONNECT                 0x3
#define WTS_REMOTE_DISCONNECT              0x4
#define WTS_SESSION_LOGON                  0x5
#define WTS_SESSION_LOGOFF                 0x6
#define WTS_SESSION_LOCK                   0x7
#define WTS_SESSION_UNLOCK                 0x8

#include "shelldll.cpp"  // for common source

//
// The monitor invisible window class name
//
static const TCHAR* const c_pszCmMonWndClass = TEXT("CM Monitor Window");

//
// static class data members
//
HINSTANCE CMonitor::m_hInst = NULL;
CMonitor* CMonitor::m_pThis = NULL;

inline CMonitor::CMonitor()
{
    MYDBGASSERT(m_pThis == NULL);
    m_pThis = this;
    m_hProcess = NULL;
}

inline CMonitor::~CMonitor()
{
    MYDBGASSERT(m_InternalConnArray.GetSize() == 0);
    MYDBGASSERT(m_ReconnectConnArray.GetSize() == 0);
    MYDBGASSERT(m_hProcess == NULL);
};

//+----------------------------------------------------------------------------
//
// Function:  WinMain
//
// Synopsis:  WinMain of the exe
//
//
// History:   Created Header    1/22/98
//
//+----------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE , HINSTANCE hPrevInst, LPSTR pszCmdLine, int iCmdShow) 
{

    //
    //  First Things First, lets initialize the U Api's
    //
    if (!InitUnicodeAPI())
    {
        //
        //  Without our U api's we are going no where.  Bail.  Don't show the message if
        //  we are running in the system account since we might be running without a user
        //  present.
        //

        if (!IsLogonAsSystem())
        {
            MessageBox(NULL, TEXT("Cmmon32.exe Initialization Error:  Unable to initialize Unicode to ANSI conversion layer, exiting."),
                       TEXT("Connection Manager"), MB_OK | MB_ICONERROR);
        }

        return FALSE;
    }

    DWORD cb = 0;
    HWINSTA hWSta = GetProcessWindowStation();
    HDESK   hDesk = GetThreadDesktop(GetCurrentThreadId());
    TCHAR szWinStation[MAX_PATH] = {0};
    TCHAR szDesktopName[MAX_PATH] = {0};

    GetUserObjectInformation(hDesk, UOI_NAME, szDesktopName, sizeof(szDesktopName), &cb);
    GetUserObjectInformation(hWSta, UOI_NAME, szWinStation, sizeof(szWinStation), &cb);
    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMMON32.EXE - LOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE1(TEXT(" WindowStation Name = %s"), szWinStation);
    CMTRACE1(TEXT(" Desktop Name = %s"), szDesktopName);
    CMTRACE(TEXT("====================================================="));

    int iRet = CMonitor::WinMain(GetModuleHandleA(NULL), hPrevInst, pszCmdLine, iCmdShow);

    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMMON32.EXE - UNLOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE(TEXT("====================================================="));

    if (!UnInitUnicodeAPI())
    {
        CMASSERTMSG(FALSE, TEXT("cmmon32.exe WinMain, UnInitUnicodeAPI failed - we are probably leaking a handle"));
    }

    //
    // that's what C runtime does to exit.
    //
    ExitProcess(iRet);
    return iRet;
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::WinMain
//
// Synopsis:  Called by ::WinMain
//
// Arguments: Same as WinMain
//            
//
// Returns:   int - return value of the process
//
// History:   Created Header    1/22/98
//
//+----------------------------------------------------------------------------
int CMonitor::WinMain(HINSTANCE hInst, HINSTANCE /*hPrevInst*/, LPSTR /*pszCmdLine*/, int /*iCmdShow*/)
{
    m_hInst = hInst;

    //
    // The only Monitor object exist during the life time of WinMain
    //
    CMonitor theMonitor;

    if (!theMonitor.Initialize())
    {
        CMTRACE(TEXT("theMonitor.Initialize failed"));
        return 0;
    }


    MSG msg;

    //
    // Loop until PostQuitMessage is called,
    // This happens when both connected and reconnecting array are down to 0
    //
    while(GetMessageU(&msg, NULL,0,0))
    {
        TranslateMessage(&msg);
        DispatchMessageU(&msg);
    }

    theMonitor.Terminate();

    CMTRACE(TEXT("The Monitor is terminated"));

    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CMonitor::Initialize
//
// Synopsis:  Initialize before the monitor start the message loop
//
// Arguments: None
//
// Returns:   BOOL - Whether successfully initialized
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
BOOL CMonitor::Initialize()
{
    DWORD dwProcessId = GetCurrentProcessId();
    m_hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
    MYDBGASSERT(m_hProcess);

#ifdef DEBUG
    BOOL fStandAlone = FALSE;  // whether cmmon is lauched directly instead of through cmdial
#endif

    if (FAILED(m_SharedTable.Open()))
    {
#ifdef DEBUG
        if ( MessageBox(NULL, TEXT("CMMON32.exe has to be launched by CMDIAL. \nContinue testing?"), 
            TEXT("CmMon32 ERROR"), MB_YESNO|MB_ICONQUESTION|MB_SYSTEMMODAL)
             == IDNO)
        {
            return FALSE;
        }

        fStandAlone = TRUE;

        if (FAILED(m_SharedTable.Create()))
#endif
        return FALSE;
    }

#ifdef DEBUG
    //
    // No other CMMON running
    //
    HWND hwndMonitor;
    m_SharedTable.GetMonitorWnd(&hwndMonitor);

    MYDBGASSERT(hwndMonitor == NULL);

#endif

    if ((m_hwndMonitor = CreateMonitorWindow()) == NULL)
    {
        CMTRACE(TEXT("CreateMonitorWindow failed"));
        return FALSE;
    }

    MYVERIFY(SUCCEEDED(m_SharedTable.SetMonitorWnd(m_hwndMonitor)));

    //
    // Register for user changes (XP onwards only)
    //
    if (OS_NT51)
    {
        HINSTANCE hInstLib = LoadLibrary(TEXT("WTSAPI32.DLL"));
        if (hInstLib)
        {
            BOOL (WINAPI *pfnWTSRegisterSessionNotification)(HWND, DWORD);
            
            pfnWTSRegisterSessionNotification = (BOOL(WINAPI *)(HWND, DWORD)) GetProcAddress(hInstLib, "WTSRegisterSessionNotification") ;
            if (pfnWTSRegisterSessionNotification)
            {
                pfnWTSRegisterSessionNotification(m_hwndMonitor, NOTIFY_FOR_THIS_SESSION);
            }
            FreeLibrary(hInstLib);
        }
        else
        {
            MYDBGASSERT(0);
        }
    }

    //
    // Tell CmDial32.dll, CmMon is ready to receive message
    //
    HANDLE hEvent = OpenEventU(EVENT_ALL_ACCESS, FALSE, c_pszCmMonReadyEvent);

#ifdef DEBUG
    if (!fStandAlone && !hEvent)
    {
        DWORD dw = GetLastError();
        CMTRACE1(TEXT("CreateMonitorWindow -- OpenEvent failed %d"), dw);

        //
        // CmDial have the event opened
        //
        MYDBGASSERT(hEvent);

    }
#endif

    SetEvent(hEvent);
    CloseHandle(hEvent);

    return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::Terminate
//
// Synopsis:  Cleanup, before exit
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CMonitor::Terminate()
{
    //
    // All the thread should exited at this point
    //

    if (m_ReconnectConnArray.GetSize() != 0)
    {
        MYDBGASSERT(FALSE);
    }

    if (m_InternalConnArray.GetSize() != 0)
    {
        MYDBGASSERT(FALSE);
    }

    //
    // Unregister for user changes (XP onwards only)
    //
    if (OS_NT51)
    {
        HINSTANCE hInstLib = LoadLibrary(TEXT("WTSAPI32.DLL"));
        if (hInstLib)
        {
            BOOL (WINAPI *pfnWTSUnRegisterSessionNotification)(HWND);
            
            pfnWTSUnRegisterSessionNotification = (BOOL(WINAPI *)(HWND)) GetProcAddress(hInstLib, "WTSUnRegisterSessionNotification") ;
            if (pfnWTSUnRegisterSessionNotification)
            {
                pfnWTSUnRegisterSessionNotification(m_hwndMonitor);
            }
            FreeLibrary(hInstLib);
        }
        else
        {
            MYDBGASSERT(0);
        }
    }

#ifdef DEBUG
    HWND hwndMonitor;
    m_SharedTable.GetMonitorWnd(&hwndMonitor);
    MYDBGASSERT(hwndMonitor == m_hwndMonitor);
#endif

    MYVERIFY(SUCCEEDED(m_SharedTable.SetMonitorWnd(NULL)));
    m_SharedTable.Close();

    CloseHandle(m_hProcess);
    m_hProcess = NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::CreateMonitorWindow
//
// Synopsis:  Register and create the invisible monitor window
//
// Arguments: None
//
// Returns:   HWND - The monitor window handle
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
HWND CMonitor::CreateMonitorWindow()
{
    //
    // Register a window class and create the window
    //
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(wc));

    wc.lpszClassName = c_pszCmMonWndClass;
    wc.lpfnWndProc = MonitorWindowProc;
    wc.cbSize = sizeof(wc);

    if (!RegisterClassExU( &wc ))
    {
        CMTRACE(TEXT("RegisterClassEx failed"));
        return NULL;
    }

     return CreateWindowExU(0, c_pszCmMonWndClass, TEXT(""), 0, 0, 
                            0, 0, 0, 0, 0, m_hInst, 0);
}


//+----------------------------------------------------------------------------
//
// Function:  CMonitor::HandleFastUserSwitch
//
// Synopsis:  Does any disconnects required when XP does a fast user switch
//
// Arguments: dwAction - a WTS_ value indicating how the user's state has changed
//
// Returns:   BOOL - success or failure
//
// History:   10-Jul-2001   SumitC      Created
//
//+----------------------------------------------------------------------------
BOOL
CMonitor::HandleFastUserSwitch(IN DWORD dwAction)
{
    BOOL    bRet = TRUE;
    BOOL    fDisconnecting = FALSE;

    MYDBGASSERT(OS_NT51);
    if (!OS_NT51)
    {
        goto Cleanup;
    }

    if ((WTS_SESSION_LOCK == dwAction) || (WTS_SESSION_UNLOCK == dwAction))
    {
        // don't do anything for lock and unlock
        goto Cleanup;
    }

    //
    //  See if we are disconnecting
    //

    if ((WTS_CONSOLE_DISCONNECT == dwAction) ||
        (WTS_REMOTE_DISCONNECT == dwAction) ||
        (WTS_SESSION_LOGOFF == dwAction))
    {
        fDisconnecting = TRUE;
    }
    
    //
    //  If a session is being disconnected, find out if any of the connected
    //  connectoids are single-user, and disconnect them if so.
    //
    if (fDisconnecting)
    {
        CMTRACE(TEXT("CMonitor::HandleFastUserSwitch -- see if theres anything to disconnect"));

        for (INT i = 0; i < m_InternalConnArray.GetSize(); ++i)
        {
            CCmConnection* pConnection = (CCmConnection*)m_InternalConnArray[i];
            ASSERT_VALID(pConnection);
            
            if (pConnection && (FALSE == pConnection->m_fGlobalGlobal))
            {
                CMTRACE1(TEXT("CMonitor::HandleFastUserSwitch -- found one, disconnecting %s"), pConnection->GetServiceName());
                MYVERIFY(TRUE == pConnection->OnEndSession(TRUE, FALSE));
            }
        }
    }

Cleanup:
    return bRet;
}


//+----------------------------------------------------------------------------
//
// Function:  CMonitor::MonitorWindowProc
//
// Synopsis:  The window procedure of the invisible monitor window
//
// Arguments: HWND hWnd - Window Proc parameters
//            UINT uMsg - 
//            WPARAM wParam - 
//            LPARAM lParam - 
//
// Returns:   LRESULT - 
//
// History:   Created Header    2/3/98
//
//+----------------------------------------------------------------------------
LRESULT CALLBACK CMonitor::MonitorWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    switch (uMsg)
    {
    case WM_COPYDATA:
        {
            ASSERT_VALID(m_pThis);
            COPYDATASTRUCT* pCopyData = (COPYDATASTRUCT*) lParam;
            MYDBGASSERT(pCopyData);

            switch(pCopyData->dwData) 
            {
            case CMMON_CONNECTED_INFO:
                MYDBGASSERT(pCopyData->cbData >= sizeof(CM_CONNECTED_INFO));
                m_pThis->OnConnected((CM_CONNECTED_INFO*)pCopyData->lpData);
                return TRUE;

            case CMMON_HANGUP_INFO:
                MYDBGASSERT(pCopyData->cbData == sizeof(CM_HANGUP_INFO));
                m_pThis->OnHangup((CM_HANGUP_INFO*)pCopyData->lpData);
                return TRUE;

            default:
                MYDBGASSERT(FALSE);
                return FALSE;
            }
        }

        break;

    case WM_REMOVE_CONNECTION:
        ASSERT_VALID(m_pThis);
        m_pThis->OnRemoveConnection((DWORD)wParam, (CCmConnection*)lParam);
        return TRUE;
        break;

    case WM_QUERYENDSESSION:
        CMTRACE(TEXT("CMonitor::MonitorWindowProc -- Got WM_QUERYENDSESSION message"));
        return m_pThis->OnQueryEndSession((BOOL)lParam);
        break;

    case WM_ENDSESSION:
        CMTRACE(TEXT("CMonitor::MonitorWindowProc -- Got WM_ENDSESSION message"));
        break;

    case WM_WTSSESSION_CHANGE:
        CMTRACE1(TEXT("CMonitor::MonitorWindowProc -- Got WM_WTSSESSION_CHANGE message with %d"), wParam);
        if (OS_NT51)
        {
            MYVERIFY(m_pThis->HandleFastUserSwitch((DWORD)wParam));
        }
        break;

    default:
        break;
    }

    return DefWindowProcU(hWnd, uMsg, wParam, lParam);
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::OnConnected
//
// Synopsis:  Called upon CMMON_CONNECTED_INFO received from cmdial
//
// Arguments: const CONNECTED_INFO* pConnectedInfo - Info from CmDial
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/3/98
//
//+----------------------------------------------------------------------------
void CMonitor::OnConnected(const CM_CONNECTED_INFO* pConnectedInfo)
{
    ASSERT_VALID(this);

    CMTRACE(TEXT("CMonitor::OnConnected"));

    RestoreWorkingSet();

    MYDBGASSERT(pConnectedInfo);

    //
    // Not in the connected table
    //
    MYDBGASSERT(!LookupConnection(m_InternalConnArray, pConnectedInfo->szEntryName));

    // ASSERT in the shared table
    CM_CONNECTION ConnectionEntry;

    if (FAILED(m_SharedTable.GetEntry(pConnectedInfo->szEntryName, &ConnectionEntry)))
    {
        MYDBGASSERT(!"CMonitor::OnConnected: Can not find the connection");
        return;
    }

    CCmConnection* pConnection = new CCmConnection(pConnectedInfo, &ConnectionEntry);
    MYDBGASSERT(pConnection);

    if (pConnection)
    {
        m_InternalConnArray.Add(pConnection);

        pConnection->StartConnectionThread();
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::OnHangup
//
// Synopsis:  Upon CMMON_HANGUP_INFO request from CMDIAL
//            Post the request to the thread
//
// Arguments: const CM_HANGUP_INFO* pHangupInfo - Info from CmDial
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CMonitor::OnHangup(const CM_HANGUP_INFO* pHangupInfo)
{
    ASSERT_VALID(this);
    RestoreWorkingSet();

    MYDBGASSERT(pHangupInfo);
    MYDBGASSERT(pHangupInfo->szEntryName[0]);

    //
    // Upon hangup request from CMDIAL.DLL
    // Look up the InternalConnArray for the connection
    //

    CCmConnection* pConnection = LookupConnection(m_InternalConnArray,pHangupInfo->szEntryName);

    //
    // CMDIAL post this message regardless whether there is a connection 
    //

    if (!pConnection)
    {
        return;
    }

    pConnection->PostHangupMsg();
    //
    // The connection thread will post a REMOVE_CONNECTION message back when finished
    //
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::LookupConnection
//
// Synopsis:  Look up a connection from connection array by service name
//
// Arguments: const CPtrArray& ConnArray - The array to lookup
//            const TCHAR* pServiceName - The servicename of the connection
//
// Returns:   CCmConnection* - the connection found or NULL
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
CCmConnection* CMonitor::LookupConnection(const CPtrArray& ConnArray, const TCHAR* pServiceName) const
{
    for (int i =0; i<ConnArray.GetSize(); i++)
    {
        CCmConnection* pConnection = (CCmConnection*)ConnArray[i];

        ASSERT_VALID(pConnection);

        if (lstrcmpiU(pServiceName, pConnection->GetServiceName()) == 0)
        {
            return pConnection;
        }
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CMonitor::LookupConnection
//
// Synopsis:  Look up a connection from connection array by connection pointer
//
// Arguments: const CPtrArray& ConnArray - The array to lookup
//            const CCmConnection* pConnection - The connection pointer
//
// Returns:   int - the index to the array, or -1 if not found
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
int CMonitor::LookupConnection(const CPtrArray& ConnArray, const CCmConnection* pConnection) const
{
    ASSERT_VALID(pConnection);

    for (int i =0; i<ConnArray.GetSize(); i++)
    {
        if ((CCmConnection*)ConnArray[i] == pConnection )
        {
            return i;
        }
    }

    return -1;
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::RemoveConnection
//
// Synopsis:  Called by connection thread to remove a connection from 
//            connected/reconnecting array
//
// Arguments: CCmConnection* pConnection - The connection to remove
//            BOOL fClearTable - Whter to remove the connection from shared table
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/23/98
//
//+----------------------------------------------------------------------------
void CMonitor::RemoveConnection(CCmConnection* pConnection, BOOL fClearTable)
{
    if (fClearTable)
    {
        //
        // Called in Connection thread.  Operation on m_SharedTable is multi-thread safe
        //
        m_pThis->m_SharedTable.ClearEntry(pConnection->GetServiceName());
    }

    //
    // The internal connection list is not safe to be accessed by multiple thread
    // Message will be processed in monitor thread OnRemoveConnection
    //
    PostMessageU(GetMonitorWindow(), WM_REMOVE_CONNECTION, 
                REMOVE_CONNECTION, (LPARAM)pConnection);
}



//+----------------------------------------------------------------------------
//
// Function:  CMonitor::MoveToReconnectingConn
//
// Synopsis:  Called by connection thread.  Move a connection from connected 
//            array to reconnecting array
//
// Arguments: CCmConnection* pConnection - The connectio to move
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/23/98
//
//+----------------------------------------------------------------------------
void CMonitor::MoveToReconnectingConn(CCmConnection* pConnection)
{
    //
    // Message will be processed in OnRemoveConnection
    // Note: SendMessage to another thread can cause deadlock, if the reveiving 
    // thread also SendMessage back to this thread. 
    // Use SendMessageTimeout if that is the case
    //
    PostMessageU(GetMonitorWindow(), WM_REMOVE_CONNECTION, 
                 MOVE_TO_RECONNECTING, (LPARAM)pConnection);
}

//+----------------------------------------------------------------------------
//
// Function:  CMonitor::OnRemoveConnection
//
// Synopsis:  Called whether a remove connection request is received from 
//            connection thread.  
//            Remove the connection from connected array or reconnecting array
//            Delete it from the shared connectio table
//            If both array are down to 0, exit cmmon
//
// Arguments: DWORD dwRequestType - 
//                  REMOVE_CONNECTION remove the connection from either array
//                  MOVE_TO_RECONNECTING move the connection from connected array 
//                          to reconnecting array
//
//            CCmConnection* pConnection - The connetion to remove or move
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/3/98
//
//+----------------------------------------------------------------------------
void CMonitor::OnRemoveConnection(DWORD dwRequestType, CCmConnection* pConnection)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pConnection);

    switch(dwRequestType)
    {
    case REMOVE_CONNECTION:
        {
            int nIndex = LookupConnection(m_InternalConnArray, pConnection);

            if (nIndex != -1)
            {
                //
                // Remove the entry from connected array
                //
                m_InternalConnArray.RemoveAt(nIndex);

            }
            else
            {
                //
                // Remove the entry from reconnecting array
                //
                nIndex = LookupConnection(m_ReconnectConnArray, pConnection);
                MYDBGASSERT(nIndex != -1);

                if (nIndex == -1)
                {
                    break;
                }

                m_ReconnectConnArray.RemoveAt(nIndex);
            }

            delete pConnection;
        }

        break;

    case MOVE_TO_RECONNECTING:
        {
            //
            // Move from connected array to reconnecting array
            //
            int nIndex = LookupConnection(m_InternalConnArray, pConnection);
            MYDBGASSERT(nIndex != -1);

            if (nIndex == -1)
            {
                break;
            }

            m_InternalConnArray.RemoveAt(nIndex);
            m_ReconnectConnArray.Add(pConnection);
        }

        break;

    default:
        MYDBGASSERT(FALSE);
        break;
    }

    //
    // If there are no connections, quit CmMon
    //
    if (m_ReconnectConnArray.GetSize() == 0 && m_InternalConnArray.GetSize() == 0)
    {
        PostQuitMessage(0);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CMonitor::OnQueryEndSession
//
// Synopsis:  This message processes the WM_QUERYENDSESSION message by passing
//            it to all the connection threads.
//
// Arguments: Nothing
//
// Returns:   TRUE if successful, FALSE otherwise
//
// History:   quintinb Created      3/18/99
//
//+----------------------------------------------------------------------------
BOOL CMonitor::OnQueryEndSession(BOOL fLogOff) const
{

    BOOL bOkayToEndSession = TRUE;
    BOOL bReturn;

    for (int i = 0; i < m_InternalConnArray.GetSize(); i++)
    {
        ASSERT_VALID((CCmConnection*)m_InternalConnArray[i]);
        
        bReturn = ((CCmConnection*)m_InternalConnArray[i])->OnEndSession(TRUE, fLogOff); // fEndSession == TRUE
        
        bOkayToEndSession = bOkayToEndSession && bReturn;
    }

    return bOkayToEndSession;
}


#ifdef DEBUG


//+----------------------------------------------------------------------------
//
// Function:  CMonitor::AssertValid
//
// Synopsis:  Helper function for debug. Assert the object is in a valid state
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CMonitor::AssertValid() const
{
    MYDBGASSERT(IsWindow(m_hwndMonitor));
    MYDBGASSERT(m_pThis == this);

    ASSERT_VALID(&m_InternalConnArray);
    ASSERT_VALID(&m_ReconnectConnArray);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\pwfuncs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pwfuncs.cpp     
//
// Module:   CMMON32.EXE
//
// Synopsis: This source file pound includes the password utility functions, 
//           see common\source\pwutil.cpp for specifics.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   nickball   created         08/04/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
//	Please see pnpu\cm\common\source for the actual source here.
//

#include "pwutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\monitor.h ===
//+----------------------------------------------------------------------------
//
// File:     Monitor.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Definition of the class CMonitor
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun    Created    02/05/98
//
//+----------------------------------------------------------------------------


#include "ArrayPtr.h"
#include <ras.h>
#include "ConTable.h"

class CCmConnection;
struct tagCmConnectedInfo;  // CM_CONNECTED_INFO
struct tagCmHangupInfo;     // CM_HANGUP_INFO

//+---------------------------------------------------------------------------
//
//  class CMonitor
//
//  Description: Class CMonitor manage all connected CM conaction.  It has 
//              data/functions not specific to a particular connection.  
//              It also manage the communication with 
//              other CM components like CMDIAL.DLL.  
//
//  History:  fengsun Created 1/22/98
//
//----------------------------------------------------------------------------

class CMonitor
{
public:
    CMonitor();
    ~CMonitor();

public:
    //
    // Static public functions, can be called without CMonitor instance
    //

    // Called by ::WinMain
    static int WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR pszCmdLine, int iCmdShow);

    static HINSTANCE GetInstance() {return m_hInst;};
    static HWND GetMonitorWindow() {MYDBGASSERT(m_pThis); return m_pThis->m_hwndMonitor;}
    static void MinimizeWorkingSet();
    static void RestoreWorkingSet();
    static BOOL ConnTableGetEntry(IN LPCTSTR pszEntry, OUT CM_CONNECTION* pCmEntry);
    static void RemoveConnection(CCmConnection* pConnection, BOOL fClearTable);
    static void MoveToReconnectingConn(CCmConnection* pConnection);

protected:

    enum {
        //
        // this message is posted from connection thread to remove a connection
        // from shared table and internal array.
        // We use PostMessage, because all the operation on this array is handled 
        // by monitor thread.  Other wise we need CriticalSection to protect the array.
        // When both array are empty, cmmon exit
        // wParam is one of the value below, lParam is pointer to the connection
        //
        WM_REMOVE_CONNECTION = WM_USER + 1, 
    };

    //
    // wParam for WM_REMOVE_CONNECTION message
    //
    enum {
        REMOVE_CONNECTION,  // Remove from Connected/Reconnecting Array
        MOVE_TO_RECONNECTING    // Move from connected array to reconnecting array
        };    


    HANDLE m_hProcess; // the process handle for the monitor, used to changed working set

    // The Connection Table file mapping
    CConnectionTable m_SharedTable;

    // the invisible monitor window handle message from cmdial32.dll and connection thread
    HWND m_hwndMonitor;

    // Internal array for connected connection
    // Can only be accessed from the monitor thread
    CPtrArray m_InternalConnArray;

    // Array of reconnecting connections
    // Can only be accessed from the monitor thread
    // If both array are down to 0, cmmon exits
    CPtrArray m_ReconnectConnArray;

    //  Called on start up
    //  Open Connection Table
    //  CreateMonitorWindow, SharedTable.SetHwndMonotor()
    BOOL Initialize();
    
    // Called upon exit
    // Close all the connections, terminate all thread
    // Release connection table
    void Terminate();

    // Register a window class and create the invisible monitorwindow
    HWND CreateMonitorWindow();

    // The Monitor window procedure, process all the message
    static LRESULT CALLBACK MonitorWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

protected:
    //
    // Message handler
    //

    // upon receiving connected message from cmdial32.dll
    // Create the CcmConnection object, add to internal table
    void OnConnected(const tagCmConnectedInfo* pConnectedInfo);


    // Upon hangup request from CMDIAL32.DLL
    // Look up the InternalConnArray for the connection
    // Call pConnection->PostHangupMsg();
    // Hangup is done in connection thread
    void OnHangup(const tagCmHangupInfo* pHangupInfo);

    //
    //  Upon WM_QUERYENDSESSION message, we walk the table of connections
    //  and call pConnection->OnEndSession on them so they will hangup and
    //  clean themselves up.
    //
    BOOL OnQueryEndSession(BOOL fLogOff) const;

    // Upon WM_REMOVE_CONNECTION message posted by connection thread
    void OnRemoveConnection(DWORD dwRequestType, CCmConnection* pConnection);

    // Look up the connection array for a connection by name
    CCmConnection* LookupConnection(const CPtrArray& PtrArray, const TCHAR* pServiceName) const;

    // Look up the connection array for a connection by connection pointer
    int LookupConnection(const CPtrArray& ConnArray, const CCmConnection* pConnection) const;

    // Maintain or drop connections across a Fast User Switch
    BOOL HandleFastUserSwitch(DWORD dwAction);

protected:
    // The exe instance handle
    static HINSTANCE m_hInst;

    // Used by static function MonitorWindowProc
    static CMonitor* m_pThis;

#ifdef DEBUG
    void AssertValid() const; // protected: not safe to call in other thread
#endif
};

inline void CMonitor::MinimizeWorkingSet()
{
    MYDBGASSERT(m_pThis->m_hProcess);
    SetProcessWorkingSetSize(m_pThis->m_hProcess, 128*1024, 384*1024);
}

inline void CMonitor::RestoreWorkingSet()
{
    MYDBGASSERT(m_pThis->m_hProcess);
    SetProcessWorkingSetSize(m_pThis->m_hProcess, 0, 0);
}

inline BOOL CMonitor::ConnTableGetEntry(IN LPCTSTR pszEntry, OUT CM_CONNECTION* pCmEntry)
{
    MYDBGASSERT(pCmEntry);
    MYDBGASSERT(m_pThis);

    return (SUCCEEDED(m_pThis->m_SharedTable.GetEntry(pszEntry, pCmEntry)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\reconnectdlg.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ReconnectDlg.h
//
// Module:	 CMMON32.EXE
//
// Synopsis: implement the reconnect dialog class CReconnectDlg
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fegnsun Created    02/17/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ReconnectDlg.h"
#include "Connection.h"
#include "resource.h"

// Question: Do we need help for reconnect dialog
const DWORD CReconnectDlg::m_dwHelp[] = {0,0};




//+----------------------------------------------------------------------------
//
// Function:  CReconnectDlg::Create
//
// Synopsis:  Create the reconnect modeless dialog
//
// Arguments: HINSTANCE hInstance - the instance for the dialog resource
//            HWND hWndParent - The parant window
//            LPCTSTR lpszReconnectMsg - The reconnect message on the dialog
//            HICON hIcon - The icon on the dialog
//
// Returns:   HWND - The reconnect dialog window handle
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
HWND CReconnectDlg::Create(HINSTANCE hInstance, HWND hWndParent,
    LPCTSTR lpszReconnectMsg, HICON hIcon)
{
    MYDBGASSERT(lpszReconnectMsg);
    MYDBGASSERT(hIcon);

    if (!CModelessDlg::Create(hInstance, IDD_RECONNECT, hWndParent)) 
    {
        MYDBGASSERT(FALSE);
        return NULL;
    }

	UpdateFont(m_hWnd);
	SetDlgItemTextU(m_hWnd,IDC_RECONNECT_MSG, lpszReconnectMsg);
	SendDlgItemMessageU(m_hWnd,IDC_CONNSTAT_ICON,STM_SETIMAGE,
						IMAGE_ICON,(LPARAM) hIcon);

    SetWindowPos(m_hWnd, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);

    return m_hWnd;
}

//+----------------------------------------------------------------------------
//
// Function:  CReconnectDlg::OnOK
//
// Synopsis:  called when OK button is clicked
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CReconnectDlg::OnOK()
{
    //
    // The connection thread will kill the reconnect dialog and call cmdial to reconnect
    //
    PostThreadMessageU(GetCurrentThreadId(), CCmConnection::WM_CONN_EVENT, 
        CCmConnection::EVENT_RECONNECT, 0);
}

//+----------------------------------------------------------------------------
//
// Function:  CReconnectDlg::OnInitDialog
//
// Synopsis:  Called when dialog is intialized and WM_INITDIALOG is received.
//
// Arguments: None
//
// Returns:   BOOL - FALSE is focus was assigned to a control.
//
// History:   nickball      03/22/00    Created 
//
//+----------------------------------------------------------------------------
BOOL CReconnectDlg::OnInitDialog()
{
    SetForegroundWindow(m_hWnd);        
    Flash();
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CReconnectDlg::OnCancel
//
// Synopsis:  Called when cancel button is clicked
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CReconnectDlg::OnCancel()
{
    //
    // The connection thread will kill the reconnect dialog and quit
    //
    PostThreadMessageU(GetCurrentThreadId(), CCmConnection::WM_CONN_EVENT,
        CCmConnection::EVENT_USER_DISCONNECT, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\resource.h ===
//+----------------------------------------------------------------------------
//
// File:     resource.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Resource IDs
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CmMon.rc
//
#define IDI_APP                         101
#define IDD_CONNSTAT                    104
#define IDD_CONNSTATNT4                 105
#define IDM_TRAY                        120
#define IDMC_TRAY_STATUS                121
#define IDD_RECONNECT                   123
#define IDC_CONNSTAT_ICON               1038
#define IDC_CONNSTAT_DURATION_DISPLAY   1039
#define IDC_CONNSTAT_SPEED_DISPLAY      1040
#define IDC_CONNSTAT_RECEIVED_DISPLAY   1041
#define IDC_CONNSTAT_SENT_DISPLAY       1042
#define IDC_DISCONNECT                  1043
#define IDC_CONNSTAT_DISCONNECT_DISPLAY 1044
#define IDC_AUTODISC                    1045
#define IDC_DETAILS                     1049
#define IDC_DETAILINFO                  1050
#define IDC_RECONNECT_MSG               1058
#define IDC_CONNSTAT_STATIC_CALL_DURATION 1069
#define IDC_CONNSTAT_STATIC_CONNECT_SPEED 1070
#define IDC_CONNSTAT_STATIC_BYTES_RECEIVED 1071
#define IDC_CONNSTAT_STATIC_BYTES_SENT  1072

//#define IDS_YES                         10010
//#define IDS_NO                          10011
//#define IDS_TRUE                        10012
//#define IDS_FALSE                       10013

#define IDMSG_CONNSPEED                 11054
#define IDMSG_CONNDUR                   11055
#define	IDMSG_CONNCNT					11056
#define IDMSG_CONNCNTRATE               11057
#define	IDMSG_CONNDISCONNECT			11060
#define IDMSG_CONNDISC_STAYONLINE       11061
#define IDMSG_CONNDISC_DISCNOW          11062
#define IDMSG_CONNDISC_OK               11063
#define IDMSG_CONNDISC_DISCONNECT       11064
#define IDMSG_DUR_START                 11065
#define IDMSG_DUR_START2                11066
#define IDMSG_DUR_START3                11067
#define IDMSG_DUR_START4                11068
#define IDMSG_DUR_START5                11069
#define IDMSG_DUR_START6                11070
#define IDMSG_DUR_START7                11071
#define IDMSG_DUR_START8                11072
#define IDMSG_DUR_START9                11073
#define IDMSG_DUR_START10               11074
#define IDMSG_DUR_START11               11075
#define IDMSG_DUR_START12               11076
#define IDMSG_DUR_START13               11077
#define IDMSG_DUR_START14               11078
#define IDMSG_DUR_START15               11079
#define IDMSG_DUR_START16               11080
#define IDMSG_DUR_START17               11081
#define IDMSG_DUR_START18               11082
#define IDMSG_DUR_START19               11083
#define IDMSG_DUR_START20               11084
#define IDMSG_DUR_START21               11085
#define IDMSG_DUR_START22               11086
#define IDMSG_DUR_START23               11087
#define IDMSG_DUR_START24               11088
#define IDMSG_DUR_START25               11089
#define IDMSG_DUR_START26               11090
#define IDMSG_DUR_START27               11091
#define IDMSG_RECONNECT                 11094
#define IDS_REG_DIALUP_ADAPTER          11208

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        125
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\reconnectdlg.h ===
//+----------------------------------------------------------------------------
//
// File:     ReconnectDlg.h
//
// Module:	 CMMON32.EXE
//
// Synopsis: Define the reconnect dialog class CReconnectDlg
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fegnsun Created    02/17/98
//
//+----------------------------------------------------------------------------

#ifndef RECONNECTDLG_H
#define RECONNECTDLG_H

#include <windows.h>
//#include "ModalDlg.h"
#include "ModelessDlg.h"

class CCmConnection;
 
//+---------------------------------------------------------------------------
//
//	class CReconnectDlg
//
//	Description: The class for reconnect prompt dialog
//
//	History:	fengsun	Created		2/17/98
//
//----------------------------------------------------------------------------
class CReconnectDlg : public CModelessDlg
{
public:
    HWND Create(HINSTANCE hInstance, HWND hWndParent,
        LPCTSTR lpszReconnectMsg, HICON hIcon);

protected:
    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();    // WM_INITDIALOG

    static const DWORD m_dwHelp[]; // help id pairs
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\rasapidll.h ===
//+----------------------------------------------------------------------------
//
// File:     RasApiDll.h	 
//
// Module:   CMMON32.EXE
//
// Synopsis: Dynamicly link to RASAPI32.dll
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fengsun Created    03/12/98
//
//+----------------------------------------------------------------------------

#ifndef RASAPIALL_H
#define RASAPIALL_H

#include <ras.h>
#include "DynamicLib.h"

//
// The statistics structure used with RasGetConnectionStatistics API
//   

typedef struct _RAS_STATS
{
    DWORD   dwSize;
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwCompressionRatioIn;
    DWORD   dwCompressionRatioOut;
    DWORD   dwBps;
    DWORD   dwConnectDuration;

} RAS_STATS, *PRAS_STATS;

//+---------------------------------------------------------------------------
//
//	class :	CRasApiDll
//
//	Synopsis:	A class to dynamic link to RASAPI32.DLL, derived from CDynamicLibrary
//              Calling any of the RAS function will load the DLL
//
//	History:	fengsun created		3/12/98
//
//----------------------------------------------------------------------------

class CRasApiDll : public CDynamicLibrary
{
public: 
    CRasApiDll();
    DWORD RasGetConnectStatus(HRASCONN hrasconn, LPRASCONNSTATUS lprasconnstatus);
    
    DWORD RasConnectionNotification(HRASCONN hrasconn,  
                                    HANDLE hEvent,
                                    DWORD dwFlags);
    
    DWORD RasGetConnectionStatistics(HRASCONN hrasconn, PRAS_STATS pRasStats);

    BOOL Load();

    BOOL HasRasConnectionNotification() const;

protected:
    typedef DWORD (WINAPI* RasGetConnectStatusFUNC)(HRASCONN, LPRASCONNSTATUS);
    typedef DWORD (WINAPI* RasConnectionNotificationFUNC)(HRASCONN hrasconn,  
                                                          HANDLE hEvent,
                                                          DWORD dwFlags);
    typedef DWORD (WINAPI* RasGetConnectionStatisticsFUNC) (HRASCONN, PRAS_STATS);


    RasGetConnectStatusFUNC         m_pfnRasGetConnectStatus;
    RasConnectionNotificationFUNC   m_pfnRasConnectionNotification;
    RasGetConnectionStatisticsFUNC  m_pfnRasGetConnectionStatistics;
};


//
// Constructor
//
inline CRasApiDll::CRasApiDll() : CDynamicLibrary()
{
    m_pfnRasGetConnectStatus = NULL;
    m_pfnRasConnectionNotification = NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  CRasApiDll::Load
//
// Synopsis:  Load RASAPI32.dll
//
// Arguments: None
//
// Returns:   BOOL - TRUE if load successfully
//
// History:   fengsun Created Header    3/12/98
//
//+----------------------------------------------------------------------------
inline 
BOOL CRasApiDll::Load()
{
    if(IsLoaded())
    {
        return TRUE;
    }

    if (!CDynamicLibrary::Load(TEXT("RASAPI32.DLL")))
    {
        return FALSE;
    }

    LPSTR pszGetConnectStatusFuncName;
    LPSTR pszConnectionNotificationFuncName;
    LPSTR pszGetConnectionStatisticsFuncName;

    if (OS_NT)
    {
        pszGetConnectStatusFuncName = "RasGetConnectStatusW";
        pszConnectionNotificationFuncName = "RasConnectionNotificationW";
    }
    else
    {
        pszGetConnectStatusFuncName = "RasGetConnectStatusA";
        pszConnectionNotificationFuncName = "RasConnectionNotificationA";
    }

    m_pfnRasGetConnectStatus = (RasGetConnectStatusFUNC)CDynamicLibrary::GetProcAddress
                    (pszGetConnectStatusFuncName);
    
    m_pfnRasConnectionNotification = (RasConnectionNotificationFUNC)CDynamicLibrary::GetProcAddress
                    (pszConnectionNotificationFuncName);

    //
    // Only on NT5, we load the statistics retrieval API
    //

    if (OS_NT5)
    {
        pszGetConnectionStatisticsFuncName = "RasGetConnectionStatistics";

        m_pfnRasGetConnectionStatistics = (RasGetConnectionStatisticsFUNC)CDynamicLibrary::GetProcAddress
                    (pszGetConnectionStatisticsFuncName);
    }
    
    MYDBGASSERT(m_pfnRasGetConnectStatus);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CRasApiDll::RasGetConnectionStatistics
//
// Synopsis:  Call the ras function RasGetConnectionStatistics.
//            Load the Dll, if not loaded yet
//
// Arguments: HRASCONN hrasconn     - Same as ::RasGetConnectStatus
//            RAS_STATS RasStats    - The Ras statistics
//
// Returns:   DWORD - Same as ::RasGetConnectStatus
//
// History:   nickball  03/04/00    Created. Cloned from RasGetConnectStatus
//
//+----------------------------------------------------------------------------
inline 
DWORD CRasApiDll::RasGetConnectionStatistics(HRASCONN hRasConn, PRAS_STATS pRasStats)
{
    DWORD dwReturn = ERROR_INVALID_FUNCTION;
    MYDBGASSERT(hRasConn);
    MYDBGASSERT(pRasStats);

    MYVERIFY(Load());

    if (IsLoaded() && m_pfnRasGetConnectionStatistics)
    {
        return (m_pfnRasGetConnectionStatistics(hRasConn, pRasStats));
    }

    return ERROR_INVALID_FUNCTION;
}

//+----------------------------------------------------------------------------
//
// Function:  CRasApiDll::RasGetConnectStatus
//
// Synopsis:  Call the ras function RasGetConnectStatus.
//            Load the Dll, if not loaded yet
//
// Arguments: HRASCONN hrasconn - Same as ::RasGetConnectStatus
//            LPRASCONNSTATUSA lprasconnstatus - Same as ::RasGetConnectStatus
//
// Returns:   DWORD - Same as ::RasGetConnectStatus
//
// History:   fengsun Created Header    3/12/98
//
//+----------------------------------------------------------------------------
inline 
DWORD CRasApiDll::RasGetConnectStatus(HRASCONN hrasconn, LPRASCONNSTATUS lprasconnstatus)
{
    DWORD dwReturn = ERROR_INVALID_FUNCTION;
    MYDBGASSERT(hrasconn);
    MYDBGASSERT(lprasconnstatus);

    MYVERIFY(Load());

    if (IsLoaded() && m_pfnRasGetConnectStatus != NULL)
    {
        if (OS_NT)
        {
            dwReturn = m_pfnRasGetConnectStatus(hrasconn, lprasconnstatus);
        }
        else
        {
            RASCONNSTATUSA RasConnStatusA;
            ZeroMemory(&RasConnStatusA, sizeof(RASCONNSTATUSA));
            RasConnStatusA.dwSize = sizeof(RASCONNSTATUSA);

            //
            // We cast this here because we only have one function declaration. We should
            // probably have one for Unicode and one for ANSI but for now the cast works 
            // fine.
            //
            
            dwReturn = m_pfnRasGetConnectStatus(hrasconn, (LPRASCONNSTATUS)&RasConnStatusA); 

            if (ERROR_SUCCESS == dwReturn)
            {
                lprasconnstatus->rasconnstate = RasConnStatusA.rasconnstate;
                lprasconnstatus->dwError = RasConnStatusA.dwError;
                SzToWz(RasConnStatusA.szDeviceType, lprasconnstatus->szDeviceType, RAS_MaxDeviceType);
                SzToWz(RasConnStatusA.szDeviceName, lprasconnstatus->szDeviceName, RAS_MaxDeviceName);
            }
        }    
    }

    return dwReturn;
}



//+----------------------------------------------------------------------------
//
// Function:  CRasApiDll::RasConnectionNotification
//
// Synopsis:  Call the ras function RasConnectionNotification.
//            Load the Dll, if not loaded yet
//
// Arguments: HRASCONN hrasconn - Same as ::RasConnectionNotification
//            HANDLE hEvent - Same as ::RasConnectionNotification
//            DWORD dwFlags - Same as ::RasConnectionNotification
//
// Returns:   DWORD - Same as ::RasConnectionNotification
//
// History:   fengsun Created Header    3/12/98
//
//+----------------------------------------------------------------------------
inline
DWORD CRasApiDll::RasConnectionNotification(HRASCONN hrasconn,  
                                            HANDLE hEvent,
                                            DWORD dwFlags)
{
    MYDBGASSERT(hrasconn);
    MYDBGASSERT(hEvent);
    MYDBGASSERT(dwFlags);

    MYVERIFY(Load());

    if(!IsLoaded() || m_pfnRasConnectionNotification == NULL)
    {
        return ERROR_INVALID_FUNCTION;
    }

    return m_pfnRasConnectionNotification(hrasconn, hEvent, dwFlags);
}


//+----------------------------------------------------------------------------
//
// Function:  CRasApiDll::HasRasConnectionNotification
//
// Synopsis:  Whether the dll has the function RasConnectionNotification()
//            which is not available for WIN9x w/ DUN1.0
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the function is avalaible
//
// History:   fengsun Created Header    3/13/98
//
//+----------------------------------------------------------------------------
inline
BOOL CRasApiDll::HasRasConnectionNotification() const
{
    MYDBGASSERT(m_hInst);

    return m_pfnRasConnectionNotification != NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\rnawnd.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 rnawnd.cpp 
//
// Module:	 CMMON32.EXE
//
// Synopsis: Kill the DUN Reconnect dialog for Win95 Gold
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 quintinb       Created header      08/17/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include <process.h>

struct RECONNECT_PARAM 
{
	HANDLE hEvent;
	BOOL *pbConnLost;
};

static unsigned long __stdcall ZapRNAReconnectThread(void *pvParam) 
{
	RECONNECT_PARAM* pParam = (RECONNECT_PARAM*) pvParam;
	HANDLE hEvent = pParam->hEvent;
	BOOL *pbConnLost = pParam->pbConnLost;
	long lRes;
	BOOL bRes;
	HMODULE hLibrary;
	HRSRC hrsrcDlg;
	HGLOBAL hgDlg;
	LPDLGTEMPLATE pDlg;
	WCHAR szTmp[MAX_PATH];
	unsigned uRes = 1;
	HWND hwndRNA;
	HLOCAL hRes;

    CMTRACE(TEXT("ZapRNAReconnectThread()"));

	hRes = LocalFree(pvParam);
#ifdef DEBUG
    if (hRes)
    {
        CMTRACE1(TEXT("ZapRNAReconnectThread() LocalFree() failed, GLE=%u."), GetLastError());
    }
#endif

	szTmp[0] = 0;
	
    hLibrary = LoadLibraryExA("rnaapp.exe", NULL, LOAD_LIBRARY_AS_DATAFILE);
		
    if (hLibrary) 
    {
	hrsrcDlg = FindResourceExU(hLibrary, TEXT("#1010"), RT_DIALOG, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

		if (hrsrcDlg)
        {
			hgDlg = LoadResource(hLibrary, hrsrcDlg);
			if (hgDlg) 
            {
				pDlg = (LPDLGTEMPLATE) LockResource(hgDlg);
				
				if (pDlg) 
                {
					LPWSTR pszTmp = (LPWSTR) (pDlg + 1);

					switch (*pszTmp) 
                    {

						case 0x0000:
							pszTmp++;
							break;

						case 0xffff:
							pszTmp += 2;
							break;

						default:
							pszTmp += lstrlenU(pszTmp) + 1;
							break;
					}
					switch (*pszTmp) 
                    {

						case 0x0000:
							pszTmp++;
							break;

						case 0xffff:
							pszTmp += 2;
							break;

						default:
							pszTmp += lstrlenU(pszTmp) + 1;
					}

                    lstrcpyU(szTmp, pszTmp);
				}
                else
                {
                    CMTRACE(TEXT("ZapRNAReconnectThread() LockResource() failed."));
                }
			}
            else
            {
    			CMTRACE1(TEXT("ZapRNAReconnectThread() LoadResource() failed, GLE=%u."), GetLastError());        
            }
		}
        else
        {
            CMTRACE1(TEXT("ZapRNAReconnectThread() FindResource() failed, GLE=%u."), GetLastError());
        }

		bRes = FreeLibrary(hLibrary);

#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("ZapRNAReconnectThread() FreeLibrary() failed, GLE=%u."), GetLastError());        
        }
#endif

	}
    else
    {
        CMTRACE1(TEXT("ZapRNAReconnectThread() LoadLibraryEx() failed, GLE=%u."), GetLastError());
    }

	if (szTmp[0]) 
    {
		CMTRACE1(TEXT("ZapRNAReconnectThread() is watching for a window named %s."), szTmp);

		while (1) 
        {
			lRes = WaitForSingleObject(hEvent,750);
			
            if (lRes != WAIT_TIMEOUT) 
            {
#ifdef DEBUG
                if (WAIT_FAILED == lRes)
                {
                    CMTRACE1(TEXT("ZapRNAReconnectThread() WaitForSingleObject() failed, GLE=%u."), 
                        GetLastError());
                }
                else if (WAIT_OBJECT_0 == lRes)
                {
                    CMTRACE(TEXT("ZapRNAReconnectThread() was told to die."));                
                }
#endif
				break;
			}

			hwndRNA = FindWindowExU(NULL, NULL, WC_DIALOG, szTmp);

			if (hwndRNA) 
            {
				CMTRACE(TEXT("ZapRNAReconnectThread() is canceling the reconnect dialog."));

				PostMessageA(hwndRNA,WM_COMMAND,IDCANCEL,0);
				
                if (pbConnLost) 
                {
					*pbConnLost = TRUE;
				}
			}
		}
	}

	bRes = CloseHandle(hEvent);

#ifdef DEBUG

	if (!bRes)
    {
        CMTRACE1(TEXT("ZapRNAReconnectThread() CloseHandle() failed, GLE=%u."), GetLastError());
    }
    
    CMTRACE1(TEXT("ZapRNAReconnectThread() is exiting with uRes=%u."), uRes);
#endif

    return (uRes);
}


HANDLE ZapRNAReconnectStart(BOOL *pbConnLost) 
{
	HANDLE hEvent;
	BOOL bRes;
	HANDLE hThread = NULL;
	unsigned long tidThread;
	RECONNECT_PARAM* pParam = NULL;
	HLOCAL hRes;

    CMTRACE(TEXT("ZapRNAReconnectStart()"));

    //
    // Not quite right for multiple connections.  This is unlike to happen for Win95 Gold w DUN1.0
    //
    hEvent = CreateEventA(NULL, FALSE, FALSE, "IConnMgr ZRRS Event");

#ifdef DEBUG
    if (!hEvent)
    {
        CMTRACE1(TEXT("ZapRNAReconnectStart() CreateEvent() failed, GLE=%u."), GetLastError());
    }
    else if (hEvent && (ERROR_ALREADY_EXISTS == GetLastError()))
    {
        CMTRACE(TEXT("ZapRNAReconnectStart() ZapRNAReconnectThread() is already running."));
    }
#endif
    
    if (hEvent && (GetLastError() != ERROR_ALREADY_EXISTS)) 
    {
		pParam = (RECONNECT_PARAM*) LocalAlloc(LPTR,sizeof(*pParam));

		if (pParam) 
        {
			pParam->hEvent = hEvent;
			pParam->pbConnLost = pbConnLost;
			hThread = (HANDLE) CreateThread(NULL,0,ZapRNAReconnectThread,pParam,0,&tidThread);

#ifdef DEBUG
            if (!hThread)
            {
                CMTRACE1(TEXT("ZapRNAReconnectStart() CreateThread() failed, GLE=%u."), GetLastError());
            }
#endif
		}
	}

	if (!hThread) 
    {
		bRes = CloseHandle(hEvent);

#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("ZapRNAReconnectStart() CloseHandle() failed, GLE=%u."), GetLastError());
        }
#endif

		if (pParam) 
        {
			hRes = LocalFree(pParam);

#ifdef DEBUG
            if (hRes)
            {
                CMTRACE1(TEXT("ZapRNAReconnectStart() LocalFree() failed, GLE=%u."), GetLastError());
            }
#endif
		}
	}

    CMTRACE1(TEXT("ZapRNAReconnectStart() is exiting with hThread=%u."), hThread);

	return hThread;
}


void ZapRNAReconnectStop(HANDLE hThread) 
{
	HANDLE hEvent;
	BOOL bRes;
	long lRes;

    CMTRACE(TEXT("ZapRNAReconnectStop()"));
    MYDBGASSERT(hThread);

	hEvent = OpenEventA(EVENT_MODIFY_STATE, FALSE, "IConnMgr ZRRS Event");

	if (hEvent) 
    {
		bRes = SetEvent(hEvent);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("ZapRNAReconnectStop() SetEvent() failed, GLE=%u."), GetLastError());
        }
#endif

		bRes = CloseHandle(hEvent);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("ZapRNAReconnectStop() CloseHandle(hEvent) failed, GLE=%u."), GetLastError());
        }
#endif

		lRes = WaitForSingleObject(hThread,2000);
#ifdef DEBUG
        if (WAIT_OBJECT_0 != lRes)
        {
            CMTRACE2(TEXT("ZapRNAReconnectStop() WaitForSingleObject() returns %u, GLE=%u."), 
                lRes, (WAIT_FAILED == lRes) ? GetLastError() : 0);
        }
#endif

		bRes = CloseHandle(hThread);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("ZapRNAReconnectStop() CloseHandle(hThread) failed, GLE=%u."), GetLastError());
        }
#endif
	}
    else
    {
        CMTRACE1(TEXT("ZapRNAReconnectStop() OpenEvent() failed, GLE=%u."), GetLastError());
    }

    CloseHandle(hThread);

    CMTRACE1(TEXT("ZapRNAReconnectStop() is exiting."), hThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\smplring.h ===
//+----------------------------------------------------------------------------
//
// File:	 SimpRing.h
//
// Module:	 CMMON32.EXE
//
// Synopsis: Define a template for a round ring class
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 ?????  Created    10/27/97
//
//+----------------------------------------------------------------------------

#ifndef SMPLRING_H
#define SMPLRING_H

//+---------------------------------------------------------------------------
//
//	class :	CSimpleRing template
//
//	Synopsis:	A simple round ring class.  It does not check the full
//              or empty situation.  That is the new item will overwrite the 
//              old one, when the ring is full
//
//	Template Arguments:	class TYPE, the type of element in the ring
//                      DWORD dwSize, the size of the ring
//
//	History:	fengsun created		10/97
//
//----------------------------------------------------------------------------

template <class TYTE, DWORD dwSize> class CSimpleRing
{
public:
    CSimpleRing() {m_dwIndex = 0;}
    void Reset();                     // Reset all data to 0, will not call destructor
    void Add(const TYTE& dwElement);  // Add one elements, it will over write the last one in the ring
    const TYTE& GetLatest() const;     // Get the one just put in
    const TYTE& GetOldest() const;      // Get the last element in the ring,

protected:
    DWORD m_dwIndex;              // The index of next item to be added
    TYTE  m_Elements[dwSize];     // The elements array

public:
#ifdef DEBUG
    void AssertValid() const;
#endif
};

template <class TYPE, DWORD dwSize> 
inline void CSimpleRing<TYPE, dwSize>::Reset()
{
    ZeroMemory(m_Elements, sizeof(m_Elements));
    m_dwIndex = 0;
}

template <class TYPE, DWORD dwSize> 
inline void CSimpleRing<TYPE, dwSize>::Add(const TYPE& dwElement)
{
    m_Elements[m_dwIndex] = dwElement;
    m_dwIndex = (m_dwIndex + 1) % dwSize;
}

template <class TYPE, DWORD dwSize> 
inline const TYPE& CSimpleRing<TYPE, dwSize>::GetLatest() const
{
    return m_Elements[(m_dwIndex-1)%dwSize];
}

//+----------------------------------------------------------------------------
//
// Function:  DWORD CIdleStatistics::CDwordRing<dwSize>::GetOldest
//
// Synopsis:  Get the oldest element in the ring,
//
// Arguments: None
//
// Returns:   DWORD
//
// History:   Created Header    10/15/97
//
//+----------------------------------------------------------------------------

template <class TYPE, DWORD dwSize> 
inline const TYPE& CSimpleRing<TYPE, dwSize>::GetOldest() const
{
    return m_Elements[m_dwIndex];
}

#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CSimpleRing::AssertValid
//
// Synopsis:  For debug purpose only, assert the object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
template <class TYPE, DWORD dwSize> 
inline void CSimpleRing<TYPE, dwSize>::AssertValid() const
{
    MYDBGASSERT(m_dwIndex < dwSize); 
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\statusdlg.h ===
//+----------------------------------------------------------------------------
//
// File:     statusdlg.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Header for the CStatusDlg Class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

#ifndef STATUSDLG_H
#define STATUSDLG_H

#include <windows.h>
#include "ModelessDlg.h"

class CCmConnection;

//+---------------------------------------------------------------------------
//
//	class CStatusDlg
//
//	Description: The class for both Status dialog and count down dialog
//
//	History:	fengsun	Created		2/17/98
//
//----------------------------------------------------------------------------
class CStatusDlg : public CModelessDlg
{
public:
    CStatusDlg(CCmConnection* pConnection);
    HWND Create(HINSTANCE hInstance, HWND hWndParent,
        LPCTSTR lpszTitle, HICON hIcon);


    // Call RasMonitorDlg
    // Shall CM display the new NT5 status dialog
    void ChangeToCountDown(); // change to count down dialog box
    void ChangeToStatus();    // Change to Status dialog box
    void UpdateStatistics();  // Update statistics for Win95
    void UpdateCountDown(DWORD dwDuration, DWORD dwSeconds);
    void UpdateStats(DWORD dwBaudRate, DWORD dwBytesRead, DWORD dwBytesWrite,
                 DWORD dwByteReadPerSec, DWORD dwByteWritePerSec);
    void UpdateDuration(DWORD dwSeconds);
    void KillRasMonitorWindow(); 
    void BringToTop();
    void DismissStatusDlg();
    
    virtual BOOL OnInitDialog();    // WM_INITDIALOG

protected:
    // Status or count down dialog box. TRUE means currently it is displaying status
    BOOL m_fDisplayStatus;  

    // Pointer to the connection to notify event
    CCmConnection* m_pConnection;

    // Whether window is visible when it is changed into count down
    // Need to restore the previous visible state when "StayOnLine"
    BOOL m_fStatusWindowVisible;

    //
    // registered hwnd msg for IE4 explorer.  This msg is broadcasted 
    // when the taskbar comes up.
    //
    UINT m_uiHwndMsgTaskBar;

    void OnDisconnect();
    virtual void OnOK();
    virtual void OnCancel();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );
    virtual DWORD OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam );
    HWND GetRasMonitorWindow();
    static BOOL CALLBACK KillRasMonitorWndProc(HWND hwnd,  LPARAM lParam);


	static const DWORD m_dwHelp[]; // help id pairs

public:
#ifdef DEBUG
    void AssertValid() const;
#endif
};

inline void CStatusDlg::BringToTop()
{
    //
    // On NT, we should bring the RAS monitor window to top, if exist
    //
    ShowWindow(m_hWnd, SW_SHOW);
	EnableWindow(m_hWnd, TRUE);

    HWND hwndTop = GetLastActivePopup(m_hWnd);
    MYDBGASSERT(hwndTop);

    SetForegroundWindow(hwndTop);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\statusdlg.cpp ===
//+----------------------------------------------------------------------------
//
// File:    StatusDlg.cpp
//
// Module:	 CMMON32.EXE
//
// Synopsis: Implement status/count-down dialog class CStatusDlg
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 ?????      Created    02/20/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "StatusDlg.h"
#include "Connection.h"
#include "resource.h"
#include "Monitor.h"
#include "cmmgr32.h" // help IDs
#include "cm_misc.h"
#include "resource.h"

//
// Map of control id to help id
//
const DWORD CStatusDlg::m_dwHelp[] = {IDOK,           IDH_OK_CONNECTED,
                                      IDC_DISCONNECT, IDH_STATUS_DISCONNECT,
                                      IDC_DETAILS,    IDH_DETAILS,
				                      0,0};

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::CStatusDlg
//
// Synopsis:  Constructor
//
// Arguments: CCmConnection* pConnection - The connection to notify event
//
// Returns:   Nothing
//
// History:   Created Header    2/20/98
//
//+----------------------------------------------------------------------------
CStatusDlg::CStatusDlg(CCmConnection* pConnection):CModelessDlg(m_dwHelp)
{
    m_pConnection = pConnection;
    m_fDisplayStatus = FALSE;
    m_fStatusWindowVisible = FALSE;
}



//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::Create
//
// Synopsis:  Create a modeless status dialog
//
// Arguments: HINSTANCE hInstance - Instance of the resource
//            HWND hWndParent - Parent window
//            LPCTSTR lpszTitle - Dialog window title
//            HICON hIcon - Dialog icon
//
// Returns:   HWND - The dialog window handle
//
// History:   Created Header    2/20/98
//
//+----------------------------------------------------------------------------
HWND CStatusDlg::Create(HINSTANCE hInstance, HWND hWndParent,
    LPCTSTR lpszTitle, HICON hIcon)
{
    MYDBGASSERT(lpszTitle);
    MYDBGASSERT(hIcon);

    DWORD dwStatusDlgId = OS_NT4 ? IDD_CONNSTATNT4 : IDD_CONNSTAT;

    if (!CModelessDlg::Create(hInstance, dwStatusDlgId, hWndParent)) 
    {
        MYDBGASSERT(FALSE);
        return NULL;
    }

	EnableWindow(m_hWnd, FALSE);
	UpdateFont(m_hWnd);
	SetWindowTextU(m_hWnd,lpszTitle);
	SendDlgItemMessageA(m_hWnd,IDC_CONNSTAT_ICON,STM_SETIMAGE,
						IMAGE_ICON,(LPARAM) hIcon);

	MakeBold(GetDlgItem(m_hWnd,IDC_CONNSTAT_DISCONNECT_DISPLAY), FALSE);

    m_uiHwndMsgTaskBar = RegisterWindowMessageA("TaskbarCreated");

    return m_hWnd;
}
//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::OnInitDialog
//
// Synopsis:  Called when dialog is intialized and WM_INITDIALOG is received.
//
// Arguments: None
//
// Returns:   BOOL - FALSE is focus was assigned to a control.
//
// History:   nickball      03/22/00    Created 
//
//+----------------------------------------------------------------------------
BOOL CStatusDlg::OnInitDialog()
{
    SetForegroundWindow(m_hWnd);                        
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::OnOtherCommand
//
// Synopsis:  Process WM_COMMAND other than IDOK and IDCANCEL
//
// Arguments: WPARAM wParam - wParam of the message
//            LPARAM - 
//
// Returns:   DWORD - Return value of the message
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
DWORD CStatusDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{
	switch (LOWORD(wParam)) 
    {
        case IDC_DISCONNECT:
            KillRasMonitorWindow();
            //
            // The thread message loop will handle thread message
	        //
            PostThreadMessageU(GetCurrentThreadId(), CCmConnection::WM_CONN_EVENT,
                CCmConnection::EVENT_USER_DISCONNECT, 0);
			break;

        case IDC_DETAILS:
            m_pConnection->OnStatusDetails();
            break;

        case IDMC_TRAY_STATUS:
            //
            //  Don't show the UI if we are at Winlogon unless we are on NT4
            //
            if (!IsLogonAsSystem() || OS_NT4)
            {
                BringToTop();
            }
            break;

        case WM_DESTROY:
            ReleaseBold(GetDlgItem(m_hWnd, IDC_CONNSTAT_DISCONNECT_DISPLAY));
            break;

        default:
            //
            // Should be message comes from additional tray icon menu item
            //
            if (LOWORD(wParam) >= CCmConnection::IDM_TRAYMENU && 
                LOWORD(wParam) <= (CCmConnection::IDM_TRAYMENU + 100))
            {
                m_pConnection->OnAdditionalTrayMenu(LOWORD(wParam));
            }
            break;
    }

    return FALSE;
}



//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::OnOtherMessage
//
// Synopsis:  Process  message other than WM_COMMAND and WM_INITDIALOG
//
// Arguments: UINT uMsg - the message
//            WPARAM wParam - wParam of the message
//            LPARAM lParam - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   Created Header    2/20/98
//
//+----------------------------------------------------------------------------
DWORD CStatusDlg::OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg)
    {
    case CCmConnection::WM_TRAYICON:
        return m_pConnection->OnTrayIcon(wParam, lParam);

    case WM_TIMER:
        // CMMON does not use WM_TIMER
        MYDBGASSERT(0);
        return 0;

    case WM_SHOWWINDOW:
        if (wParam)  //fShow == TRUE
        {
            //
            // Statistics is not updated if window is invisible.
            // Force a update of statistics now.
            // 
            m_pConnection->StateConnectedOnTimer();
        }
        break;

    default:
        if (uMsg == m_uiHwndMsgTaskBar && !m_pConnection->IsTrayIconHidden())
        {
            //
            // we need to re-add the trayicon
            //
            m_pConnection->ReInstateTrayIcon();
        }
    break;
    }

    return FALSE;
}


//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::OnCancel
//
// Synopsis:  Virtual function. Process WM_COMMAND IDCANCEL
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::OnCancel()
{
    //
    // Even through, the status dialog does not have a cancel button, this message 
    // is send when user click Esc, or close from system menu
    //

    //
    // As if OK/StayOnLine is clicked
    //
    OnOK();
}


//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::OnOK
//
// Synopsis:  Virtual function. Process WM_COMMAND IDOK
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::OnOK()
{
    if (m_fDisplayStatus)  
    {
        ShowWindow(m_hWnd, SW_HIDE);
        EnableWindow(m_hWnd, FALSE);
    }
    else  // in count-down state
    {
        m_pConnection->OnStayOnLine();
   		// 
		// If window is was up previously and a countdown is being
		// terminated leave the window active. Otherwise restore
		// window to previous hidden state.
		//

        if (!m_fStatusWindowVisible)
        {
            ShowWindow(m_hWnd,SW_HIDE);
			EnableWindow(m_hWnd, FALSE);
        }
    }

    if (!IsWindowVisible(m_hWnd))
    {
        //
        // Minimize the working set after hide the window.
        //
        CMonitor::MinimizeWorkingSet();
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::ChangeToCountDown
//
// Synopsis:  Change the status dialog to count-down dialog
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::ChangeToCountDown()
{
    MYDBGASSERT(m_fDisplayStatus); // is status;

    m_fDisplayStatus = FALSE;
    //
    // After user clicked "Stay Online", we need to restore the visible state
    // Convert is to real boolean
    //
    m_fStatusWindowVisible = IsWindowVisible(m_hWnd) != FALSE;

    KillRasMonitorWindow();

	//
    // Change OK to Stay Online
    //
    LPTSTR pszTmp = CmLoadString(CMonitor::GetInstance(),IDMSG_CONNDISC_STAYONLINE);
	SetDlgItemTextU(m_hWnd,IDOK,pszTmp);
	CmFree(pszTmp);
	
    //
    // Change Disconnect to Disconnect Now
    //
    pszTmp = CmLoadString(CMonitor::GetInstance(),IDMSG_CONNDISC_DISCNOW);
	SetDlgItemTextU(m_hWnd,IDC_DISCONNECT,pszTmp);
	CmFree(pszTmp); 
	
	// Hide/Show the windows for countdown mode
	
    if (!OS_NT4)
    {
        //
        // Hide 9X statistics control
        //
        ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_SPEED_DISPLAY),SW_HIDE);
	    ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_RECEIVED_DISPLAY),SW_HIDE);
	    ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_SENT_DISPLAY),SW_HIDE);
    }

	ShowWindow(GetDlgItem(m_hWnd,IDC_AUTODISC),SW_SHOW);
    SetForegroundWindow(m_hWnd);

    //
    // Make sure we're flashing and topmost for countdown
    //

    SetWindowPos(m_hWnd, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);

    Flash();
}
 
//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::ChangeToStatus
//
// Synopsis:  Change the count-down dialog to status dialog
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::ChangeToStatus()
{
    MYDBGASSERT(!m_fDisplayStatus); // is count down

    m_fDisplayStatus = TRUE;

	// Set text for buttons and static to standard mode
    SetDlgItemTextU(m_hWnd,IDC_CONNSTAT_DISCONNECT_DISPLAY,TEXT(""));

    //
    // Change back to OK
    //
    LPTSTR pszTmp = CmLoadString(CMonitor::GetInstance(),IDMSG_CONNDISC_OK);
	SetDlgItemTextU(m_hWnd,IDOK,pszTmp);
	CmFree(pszTmp);

    //
    // Change back to Disconnect
    //
	pszTmp = CmLoadString(CMonitor::GetInstance(),IDMSG_CONNDISC_DISCONNECT);
	SetDlgItemTextU(m_hWnd,IDC_DISCONNECT,pszTmp);
	CmFree(pszTmp);

	// Hide/Show the windows for standard mode

	ShowWindow(GetDlgItem(m_hWnd,IDC_AUTODISC),SW_HIDE);
    if (!OS_NT4)
    {
	    ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_SPEED_DISPLAY),SW_SHOW);
	    ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_RECEIVED_DISPLAY),SW_SHOW);
	    ShowWindow(GetDlgItem(m_hWnd,IDC_CONNSTAT_SENT_DISPLAY),SW_SHOW);
    }

    //
    // Make sure we're not top-most, just on top, when we switch to status
    //

    SetWindowPos(m_hWnd, HWND_TOP, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::UpdateCountDown
//
// Synopsis:  Update the "xx seconds until disconnect" of the count-down dialog
//
// Arguments: DWORD dwDuration: connection duration
//            DWORD dwSeconds - seconds remain to disconnect
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::UpdateCountDown(DWORD dwDuration, DWORD dwSeconds)
{
    MYDBGASSERT(!m_fDisplayStatus);
    MYDBGASSERT(dwSeconds < 0xFFFF);

    UpdateDuration(dwDuration);

    LPTSTR pszTmp = CmFmtMsg(CMonitor::GetInstance(), IDMSG_CONNDISCONNECT, dwSeconds);
	SetDlgItemTextU(m_hWnd,IDC_CONNSTAT_DISCONNECT_DISPLAY,pszTmp);
	CmFree(pszTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::UpdateDuration
//
// Synopsis:  Update the connection duration
//
// Arguments: DWORD dwSeconds - connected duration
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::UpdateDuration(DWORD dwSeconds)
{
    if (!IsWindowVisible(m_hWnd))
    {
        return;
    }

	LPTSTR pszMsg;

	// Connect Duration

	pszMsg = CmFmtMsg(CMonitor::GetInstance(),
					  IDMSG_CONNDUR,
					  (WORD)((dwSeconds/60)/60),
					  (WORD)((dwSeconds/60)%60),
					  (WORD)(dwSeconds%60));
	SetDlgItemTextU(m_hWnd,IDC_CONNSTAT_DURATION_DISPLAY,pszMsg);
	CmFree(pszMsg);
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::UpdateStats
//
// Synopsis:  Update the status dialog for Win9X
//
// Arguments: DWORD dwBaudRate - Baud rate
//            DWORD dwBytesRead - Total Bytes read
//            DWORD dwBytesWrite - Total bytes written
//            DWORD dwBytesReadPerSec - Byte read last second
//            DWORD dwBytesWritePerSec - Byte written last second
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::UpdateStats(DWORD dwBaudRate, DWORD dwBytesRead, DWORD dwBytesWrite,
                 DWORD dwBytesReadPerSec, DWORD dwBytesWritePerSec)
{
	//
	// Received
	//

	CHAR szFmtNum1[MAX_PATH];
	CHAR szFmtNum2[MAX_PATH];
    LPSTR pszMsg;

    FmtNum(dwBytesRead, szFmtNum1, sizeof(szFmtNum1));


	if (dwBytesReadPerSec) 
	{
		FmtNum(dwBytesReadPerSec, szFmtNum2, sizeof(szFmtNum2));
		pszMsg = CmFmtMsgA(CMonitor::GetInstance(), IDMSG_CONNCNTRATE, szFmtNum1, szFmtNum2);
	} 
	else 
	{
		pszMsg = CmFmtMsgA(CMonitor::GetInstance(), IDMSG_CONNCNT, szFmtNum1);
	}

	SetDlgItemTextA(m_hWnd, IDC_CONNSTAT_RECEIVED_DISPLAY, pszMsg);
	CmFree(pszMsg);

	//
	// Sent 
	//

	FmtNum(dwBytesWrite, szFmtNum1, sizeof(szFmtNum1));

	if (dwBytesWritePerSec) 
	{
		FmtNum(dwBytesWritePerSec, szFmtNum2, sizeof(szFmtNum2));
		pszMsg = CmFmtMsgA(CMonitor::GetInstance(), IDMSG_CONNCNTRATE, szFmtNum1, szFmtNum2);
	} 
	else 
	{
		pszMsg = CmFmtMsgA(CMonitor::GetInstance(), IDMSG_CONNCNT, szFmtNum1);
	}

	SetDlgItemTextA(m_hWnd, IDC_CONNSTAT_SENT_DISPLAY, pszMsg);

	CmFree(pszMsg);

	if (dwBaudRate) 
	{
		FmtNum(dwBaudRate, szFmtNum1, sizeof(szFmtNum1));
		pszMsg = CmFmtMsgA(CMonitor::GetInstance(), IDMSG_CONNSPEED, szFmtNum1);
		SetDlgItemTextA(m_hWnd, IDC_CONNSTAT_SPEED_DISPLAY, pszMsg);
		CmFree(pszMsg);
	}
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::GetRasMonitorWindow
//
// Synopsis:  Find the RasMonitor window on NT, if present
//            The Status window is the owner of the RasMonitor
//
// Arguments: none
//
// Returns:   HWND - The RasMonitor window handle or NULL
//
// History:   fengsun Created Header    2/12/98
//
//+----------------------------------------------------------------------------
HWND CStatusDlg::GetRasMonitorWindow()
{
    //
    // RasMonitor window only exists on NT
    //
    if (!OS_NT4)
    {
        return NULL;
    }

    //
    // The RasMonitor window is the child window of desktop
    // however, the owner window is the status window
    //
    HWND hwnd = NULL;
    
    while (hwnd = FindWindowExU(NULL, hwnd, WC_DIALOG, NULL))
    {
        if (GetParent(hwnd) == m_hWnd)
        {
            return hwnd;
        }
    }

    return NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::KillRasMonitorWindow
//
// Synopsis:  Close the RasMonitorDlg and any child dialog it might have
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/28/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::KillRasMonitorWindow()
{

    HWND hwndRasMonitor = GetRasMonitorWindow();

    if (hwndRasMonitor)
    {
        //
        // The current thread is the connection thread
        //
        MYDBGASSERT(GetWindowThreadProcessId(m_hWnd, NULL) == GetCurrentThreadId());

        //
        // The RasMonitorDlg can pop up aother dialog, such as details.
        // Kill all the dialog in the RasMonitor thread
        //

        DWORD dwRasMonitorThread = GetWindowThreadProcessId(hwndRasMonitor, NULL);
        MYDBGASSERT(dwRasMonitorThread);
        MYDBGASSERT(dwRasMonitorThread != GetCurrentThreadId());

        EnumThreadWindows(dwRasMonitorThread, KillRasMonitorWndProc, (LPARAM)this);
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::KillRasMonitorWndProc
//
// Synopsis:  Kill all the window in the RasMonitorThread
//
// Arguments: HWND hwnd - Window handle belong to the RasMonitorThread
//            LPARAM lParam - pointer to CStatusDlg
//
// Returns:   BOOL - TRUE to continue enumeration
//
// History:   fengsun Created Header    4/28/98
//
//+----------------------------------------------------------------------------
BOOL CALLBACK CStatusDlg::KillRasMonitorWndProc(HWND hwnd,  LPARAM lParam)
{
    //
    // SendMessage will block until the message returns, because we do not
    // want to exit the connection thread before RasMinotor thread ended.
    // CM sends a message from Connection thread to RasMonitor thread.
    // Be careful about possible deadlock situation
    // Cause Bug 166787
    //

    SendMessageA(hwnd, WM_CLOSE, (WPARAM)0, (LPARAM)0);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::DismissStatusDlg
//
// Synopsis:  Dismisses the status dialog.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    4/28/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::DismissStatusDlg()
{
    //
    //  Since OnOK is protected and virtual we will just add a member function
    //  to call it.  We really just want to dismiss the dialog so it will be
    //  hidden again.
    //
    OnOK();
}

#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CStatusDlg::AssertValid
//
// Synopsis:  For debug purpose only, assert the object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CStatusDlg::AssertValid() const
{
    MYDBGASSERT(m_fDisplayStatus == TRUE || m_fDisplayStatus == FALSE);
    MYDBGASSERT(m_fStatusWindowVisible == TRUE || m_fStatusWindowVisible == FALSE);
    MYDBGASSERT(m_pConnection != NULL);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\ccsv.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ccsv.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Implementation of the class CCSVFile.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// INCLUDES
#include "cmmaster.h"

// ############################################################################
// DEFINES
#define chComma ','
#define chNewline '\n'
#define chReturn '\r'
#define chSpace ' '

// ############################################################################
//
// CCSVFile - simple file i/o for CSV files
//
CCSVFile::CCSVFile()
{
	m_hFile = INVALID_HANDLE_VALUE;
	m_chLastRead = 0;
	m_pchLast = m_pchBuf = NULL;
	m_fReadFail = FALSE;
	m_fUseLastRead = FALSE;
}

// ############################################################################
CCSVFile::~CCSVFile()
{
	CMASSERTMSG(m_hFile==INVALID_HANDLE_VALUE,"CCSV file is still open");
}

// ############################################################################
BOOLEAN CCSVFile::Open(LPCSTR pszFileName)
{
	CMASSERTMSG(m_hFile==INVALID_HANDLE_VALUE, "a file is already open.");
	
	m_hFile = CreateFile((LPCTSTR) pszFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
	if (INVALID_HANDLE_VALUE == m_hFile)
	{
		return FALSE;
	}
	m_pchLast = m_pchBuf = NULL;
	return TRUE;
}

// ############################################################################
BOOL CCSVFile::ClearNewLines(void)
{
	//
	// This routine is designed to eat characters until a non-newline char or 
	// the end-of-file is encountered. If a non-newline char is encountered, 
	// the fUseLast flag is set to ensure that the next call to ChNext will 
	// return the correct current character.
	//

	char ch = chNewline;
    WORD wRet;
    BYTE bErr;

	//
	// eat leading newlines
	//

	while (chNewline == ch)
	{
        //
        // eat the leading space first
        //
        do 
        {
            wRet = ChNext();
        } while ((wRet == chSpace) || (wRet == TEXT('\t')));

        bErr = HIBYTE(wRet);
        ch = LOBYTE(wRet);

		// if EOF return false
		
		if (0xff == bErr)
		{
	    	return FALSE;
		}
	}

	//
	// we hit a character other than newline, use current char as next.
	//

	m_fUseLastRead = TRUE;

	return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::ReadToken(char *psz, DWORD cbMax)
{
	char 	*pszOrig = psz;
	DWORD 	dwLen = 0;
	char	ch;
    BYTE    bErr = 0xff;
    WORD    wRet;

	wRet = ChNext();
    bErr = HIBYTE(wRet);
    ch = LOBYTE(wRet);

	if (0xff == bErr)
	{
		return FALSE;
	}

	// read chars until we hit a comma, newline, or run out of file

	while (dwLen < cbMax - 1 && chComma != ch && chNewline != ch && 0xff != bErr)
	{
		*psz++ = ch;

		wRet = ChNext(); //Read in the next character
        bErr = HIBYTE(wRet);
        ch = LOBYTE(wRet);

		dwLen++;
	}

	*psz++ = '\0';
	
	// eat leading spaces

	while (*pszOrig == chSpace) 
	{
		lstrcpy(pszOrig,pszOrig+1);
	}

	psz = pszOrig + lstrlen(pszOrig);

	// eat trailing spaces

	while ((psz != pszOrig) && (*(psz-1) == chSpace)) 
	{
		psz--;
		*psz = 0;
	}

	return TRUE;
}

// ############################################################################
void CCSVFile::Close(void)
{
	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hFile);
	}

#ifdef DEBUG
	
	if (m_hFile==INVALID_HANDLE_VALUE) 
	{
		CMTRACE("CCSVFile::Close was called, but m_hFile was already INVALID_HANDLE_VALUE\n");
	}

#endif

	m_hFile = INVALID_HANDLE_VALUE;
}

// ############################################################################
BOOL CCSVFile::ReadError(void)
{
	return (m_fReadFail);
}

// ############################################################################
BOOL CCSVFile::FReadInBuffer(void)
{
	//Read another buffer
	if (!ReadFile(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE, &m_cchAvail, NULL) || !m_cchAvail)
	{
		m_fReadFail = TRUE;
		return FALSE;	 //nothing more to read
	}

	m_pchBuf = m_rgchBuf;
	m_pchLast = m_pchBuf + m_cchAvail;
	
	return TRUE; //success
}

// ############################################################################
inline WORD CCSVFile::ChNext(void)
{
	//
	// If the fUseLastRead flag is set, clear the 
	// flag and use the existing m_chLastRead 
	//
	
	if (m_fUseLastRead)
	{
		m_fUseLastRead = FALSE;	
	}
	else
	{
		//
		// Get the next char in the buffer. Load new buffer if necessary.
		//

LNextChar:

		if (m_pchBuf >= m_pchLast && !FReadInBuffer())  //implies that we finished reading the buffer. Read in some more.
		{
			return MAKEWORD(0, 0xff);	 //nothing more to read
		}

		m_chLastRead = *m_pchBuf++;
		
		//
		// If its a carriage return, read another char
		//

		if (chReturn == m_chLastRead)
		{
			goto LNextChar;		//faster to NOT make extra function call
		}
	}

	return MAKEWORD(m_chLastRead, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include <windows.h>
#include <windowsx.h>
#include <tapi.h>
#include <ras.h>
#include <raserror.h>
#include <tchar.h>

#include "cmutil.h"
#include "cm_phbk.h"
#include "ccsv.h"
#include "phbk.h"
#include "misc.h"
#include "cm_misc.h"
#include "pbk_str.h"
#include "cmdebug.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\watchprocess.h ===
//+----------------------------------------------------------------------------
//
// File:     watchprocess.h
//
// Module:   CMMON32.EXE
//
// Synopsis: Header and Implementation for the CWatchProcessList class.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

#include "ArrayPtr.h"

//+---------------------------------------------------------------------------
//
//	class CWatchProcessList
//
//	Description: Manage to list of process handle. 
//               Tell whether all the processes are terminated
//
//	History:	fengsun	Created		10/30/97
//
//----------------------------------------------------------------------------

class CWatchProcessList
{
public:
    CWatchProcessList();
    ~CWatchProcessList();

    BOOL IsIdle();
    void Add(HANDLE hProcess);
    void SetNotIdle() {m_fProcessAdded = FALSE;};
    DWORD GetSize() const {return m_ProcessArray.GetSize();} 
    HANDLE GetProcess(int i) {return m_ProcessArray[i];}

protected:

    // an array of process handle
    CPtrArray m_ProcessArray;
    BOOL m_fProcessAdded;
};

inline CWatchProcessList::CWatchProcessList()
{
    m_fProcessAdded = FALSE;
}

inline CWatchProcessList::~CWatchProcessList()
{
    for (int i=m_ProcessArray.GetSize()-1; i>=0; i--)
    {
	    CloseHandle((HANDLE)m_ProcessArray[i]);
    }
}

inline BOOL CWatchProcessList::IsIdle()
{
    if (!m_fProcessAdded)
    {
        return FALSE;
    }
    
    for (int i=m_ProcessArray.GetSize()-1; i>=0; i--)
    {
        DWORD dwExitCode;

		BOOL bRes = GetExitCodeProcess((HANDLE)m_ProcessArray[i],&dwExitCode);

		if (!bRes || (dwExitCode != STILL_ACTIVE)) 
		{
			CloseHandle((HANDLE)m_ProcessArray[i]);
            m_ProcessArray.RemoveAt(i);
		}
    }

    return m_ProcessArray.GetSize() == 0;
}
    
inline void CWatchProcessList::Add(HANDLE hProcess)
{
    //
    // CMDIAL calls DuplicateHandle to get the hProcess
    // CmMon is responsible to close the handle
    //

    MYDBGASSERT(hProcess);

    //
    // It is possible the auto application exited before this function is called
    //
    m_fProcessAdded = TRUE;
    
	if (hProcess) 
    {
		m_ProcessArray.Add(hProcess);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\trayicon.h ===
//+----------------------------------------------------------------------------
//
// File:     TrayIcon.h  
//
// Module:   CMMON32.EXE
//
// Synopsis: CTrayIcon class definition, which manages the connection tray icon 
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created    02/17/98
//
//+----------------------------------------------------------------------------

#ifndef TRAYICON_H
#define TRAYICON_H

#include "ArrayPtr.h"


class CIni;

//+---------------------------------------------------------------------------
//
//  class CTrayIcon
//
//  Description: A class to manage tray icon
//
//  History:    fengsun Created     2/17/98
//
//----------------------------------------------------------------------------
class CTrayIcon
{
public:
    CTrayIcon();
    ~CTrayIcon();

    void SetIcon(HICON hIcon, HWND hwnd, UINT uMsg, UINT uID, const TCHAR* lpMsg = NULL);
//    void SetTip(const TCHAR* lpMsg);
    void RemoveIcon();
    void CreateMenu(const CIni* pIniFile, DWORD dwMsgBase);

    void PopupMenu(int x, int y, HWND hWnd);
    const TCHAR* GetMenuCommand(int i) const;
    int GetAdditionalMenuNum() const;

protected:

    HMENU m_hMenu;  // the IDM_TARY menu in the resource
    HMENU m_hSubMenu;   // the first sub menu of IDM_TRAY
    HWND  m_hwnd;       // the window handle for the tray icon
    UINT  m_uID;        // the ID of the tray icon
    HICON m_hIcon;      // the tray icon handle
    CPtrArray m_CommandArray;  // array of LPTSTR menu item command line
};

inline void CTrayIcon::PopupMenu(int x, int y, HWND hWnd)
{
    SetMenuDefaultItem(m_hSubMenu, IDMC_TRAY_STATUS, FALSE); 
    MYVERIFY(TrackPopupMenu(m_hSubMenu,TPM_LEFTALIGN|TPM_RIGHTBUTTON,x,y,0,hWnd,NULL));
}

inline const TCHAR* CTrayIcon::GetMenuCommand(int i) const
{
    return (const TCHAR*) m_CommandArray[i];
}
    
inline int CTrayIcon::GetAdditionalMenuNum() const
{
    return m_CommandArray.GetSize();

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\bsearch.cpp ===
//+----------------------------------------------------------------------------
//
// File:     bsearch.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Binary search implementation
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

/***
*char *bsearch() - do a binary search on an array
*
*Purpose:
*       Does a binary search of a sorted array for a key.
*
*Entry:
*       const char *key    - key to search for
*       const char *base   - base of sorted array to search
*       unsigned int num   - number of elements in array
*       unsigned int width - number of bytes per element
*       int (*compare)()   - pointer to function that compares two array
*               elements, returning neg when #1 < #2, pos when #1 > #2, and
*               0 when they are equal. Function is passed pointers to two
*               array elements.
*
*Exit:
*       if key is found:
*               returns pointer to occurrence of key in array
*       if key is not found:
*               returns NULL
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl CmBSearch (
        REG4 const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        )
{
        REG1 char *lo = (char *)base;
        REG2 char *hi = (char *)base + (num - 1) * width;
        REG3 char *mid;
        unsigned int half;
        int result;

        while (lo <= hi)
                if (half = num / 2)
                {
                        mid = lo + (num & 1 ? half : (half - 1)) * width;
                        if (!(result = (*compare)(key,mid)))
                                return(mid);
                        else if (result < 0)
                        {
                                hi = mid - width;
                                num = num & 1 ? half : half-1;
                        }
                        else    {
                                lo = mid + width;
                                num = half;
                        }
                }
                else if (num)
                        return((*compare)(key,lo) ? NULL : lo);
                else
                        break;

        return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\utility.cpp ===
//+----------------------------------------------------------------------------
//
// File:     utility.cpp
//
// Module:   CMMON32.EXE
//
// Synopsis: Utility functions for cmmon32.exe.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "cm_misc.h"
#include <stdio.h>
#include "resource.h" 
#include <stdlib.h>

//+----------------------------------------------------------------------------
//
// Function:  FmtNum
//
// Synopsis:  Formats a number according to current locale
//
// Arguments: DWORD dwNum - Number to be formatted
//            LPTSTR pszNum - Buffer to receive formatted output
//            DWORD dwNumSize - Size of buffer
//
// Returns:   Nothing
//
// History:   nickball    Created Header    3/30/98
//
//+----------------------------------------------------------------------------
void FmtNum(DWORD dwNum, LPSTR pszNum, DWORD dwNumSize) 
{
	static BOOL bLocaleInit = FALSE;
	static UINT nDecimalDigits;
	DWORD dwNumLen;
	CHAR szRawNum[MAX_PATH];

	if (!bLocaleInit) 
	{
		int iRes;

		bLocaleInit = TRUE;
		iRes = GetLocaleInfoA(LOCALE_USER_DEFAULT,
							  LOCALE_IDIGITS,
							  szRawNum,
							  (sizeof(szRawNum) / sizeof(CHAR)) - 1);
#ifdef DEBUG
        if (!iRes)
        {
            CMTRACE1(TEXT("FmtNum() GetLocaleInfo() failed, GLE=%u."), GetLastError());
        }
#endif

		nDecimalDigits = (UINT)CmAtolA(szRawNum);
	}
    
    wsprintfA(szRawNum, "%u", dwNum);
	
	GetNumberFormatA(LOCALE_USER_DEFAULT,
					 0,
					 szRawNum,
					 NULL,
					 pszNum,
					 (dwNumSize / sizeof(CHAR)) - 1);

	dwNumLen = lstrlenA(pszNum);
	
    if (nDecimalDigits && (dwNumLen > nDecimalDigits) && !CmIsDigitA(pszNum+dwNumLen - nDecimalDigits - 1)) 
	{
		pszNum[dwNumLen - nDecimalDigits - 1] = 0;
	} 
	else 
	{
        CMTRACE(TEXT("FmtNum() unexpected decimal output."));
		bLocaleInit = FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\ccsv.h ===
//+----------------------------------------------------------------------------
//
// File:     ccsv.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Definition of the CCSVFile class.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------
#ifndef _CCSV_INC_
#define _CCSV_INC_

#define CCSVFILE_BUFFER_SIZE 2*512

// simple file i/o for phone books
class CCSVFile 
{
	
	public:

		CCSVFile();
		~CCSVFile();
		BOOLEAN Open(LPCSTR pszFileName);
		BOOLEAN ReadToken(char *pszDest, DWORD cbMax);	// reads up to comma or newline, returns fFalse on EOF
		BOOL ClearNewLines(void); // reads through newlines, returns FALSE on EOF
		BOOL ReadError(void);	  // true if last read failed
		void Close(void);

	private:
		BOOL	m_fReadFail;
		BOOL    m_fUseLastRead;
		BOOL 	FReadInBuffer(void);
		inline WORD	ChNext(void);
		char 	m_rgchBuf[CCSVFILE_BUFFER_SIZE]; //buffer
		char 	*m_pchBuf;			//pointer to the next item in the buffer to read
		char	*m_pchLast;			//pointer to the last item in the buffer
		char  	m_chLastRead;		//the character last read.  HIBYTE=err code, LOBYTE=char
		DWORD 	m_cchAvail;
		HANDLE 	m_hFile;

}; // ccsv
#endif //_CCSV_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\trayicon.cpp ===
//+----------------------------------------------------------------------------
//
// File:     trayicon.cpp
//
// Module:   CMMON32.EXE
//
// Synopsis: Implementation for the CTrayIcon class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created Header    08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "resource.h"
#include "TrayIcon.h"
#include "Monitor.h"
#include "cm_misc.h"
#include "ShellDll.h"

//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::CTrayIcon
//
// Synopsis:  Constructor
//
// Arguments: Nothing
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
CTrayIcon::CTrayIcon()
{
    m_hwnd = NULL;
    m_hMenu = m_hSubMenu = NULL;
    m_uID = 0;
    m_hIcon = NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::~CTrayIcon
//
// Synopsis:  Destructor
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    4/7/98
//
//+----------------------------------------------------------------------------
CTrayIcon::~CTrayIcon()
{
    if (m_hMenu)
    {
        DestroyMenu(m_hMenu);
    }

    if (m_hIcon)
    {
        DeleteObject(m_hIcon);
    }

    for (int i=0; i< m_CommandArray.GetSize();i++)
    {
        CmFree((TCHAR*) m_CommandArray[i]);
    }

}



#if 0 // this function is not used

/*
//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::SetTip
//
// Synopsis:  Change the tip of the tray icon
//
// Arguments: const TCHAR* lpMsg - message to set
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CTrayIcon::SetTip(const TCHAR* lpMsg)
{
    MYDBGASSERT(IsWindow(m_hwnd));
    MYDBGASSERT(lpMsg);

    NOTIFYICONDATA nidData;
    ZeroMemory(&nidData,sizeof(nidData));
    nidData.cbSize = sizeof(nidData);
    nidData.hWnd = m_hwnd;
    nidData.uID = m_uID;
    nidData.uFlags = NIF_TIP;

    lstrcpyn(nidData.szTip,lpMsg,sizeof(nidData.szTip)/sizeof(TCHAR));

    //
    // Load Shell32.dll and call Shell_NotifyIcon
    //
    CShellDll ShellDll;
    BOOL bRes = ShellDll.NotifyIcon(NIM_MODIFY,&nidData);
    MYDBGASSERT(bRes);
}
*/
#endif

//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::SetIcon
//
// Synopsis:  Set the icon for the tray icon
//
// Arguments: HICON hIcon - icon to set.  Use NULL to use existing icon.
//            HWND hwnd - window to receive tray icon message
//            UINT uMsg - tray icon message
//            UINT uID - The id for the tray icon
//            const TCHAR* lpMsg - The initial tip for the icon
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CTrayIcon::SetIcon(HICON hIcon, HWND hwnd, UINT uMsg, UINT uID, const TCHAR* lpMsg)
{
    MYDBGASSERT(IsWindow(hwnd));
    //MYDBGASSERT(m_hIcon == NULL);
    //MYDBGASSERT(hIcon);
    MYDBGASSERT(m_hIcon == NULL && hIcon ||
                m_hIcon && hIcon == NULL);

    m_hwnd = hwnd;
    m_uID = uID;

    NOTIFYICONDATA nidData;

    ZeroMemory(&nidData,sizeof(nidData));
    nidData.cbSize = sizeof(nidData);
    nidData.hWnd = m_hwnd;
    nidData.uID = uID;
    nidData.uFlags = NIF_ICON | NIF_MESSAGE;
    //
    // we'll reuse the icon if we already have one.
    //
    if (!m_hIcon)
    {
        m_hIcon = hIcon;
    }
    nidData.hIcon = m_hIcon;

    nidData.uCallbackMessage = uMsg;

    if (lpMsg)
    {
        nidData.uFlags |= NIF_TIP;
        lstrcpynU(nidData.szTip,lpMsg,sizeof(nidData.szTip)/sizeof(TCHAR));
    }

    //
    // Load Shell32.dll and call Shell_NotifyIcon
    //
    CShellDll ShellDll;
    DWORD   cRetries = 0;
    
    BOOL bRes = ShellDll.NotifyIcon(NIM_ADD,&nidData);
    //
    // Check if Icon is already added
    //
    if (bRes == FALSE)
    {
        bRes = ShellDll.NotifyIcon(NIM_MODIFY,&nidData);
    }
    //
    // If this fails its very likely that the tray is not started yet. Retry few times
    // with a max wait time of 5 mins & then abort
    //
    while (bRes == FALSE && cRetries < 300)
    {
        Sleep(1000);
        cRetries ++;
//        CMTRACE1(TEXT("Shell_NotifyIcon = %d"), bRes);
        bRes = ShellDll.NotifyIcon(NIM_ADD,&nidData);
        //
        // Check if Icon is already added
        //
        if (bRes == FALSE)
        {
            bRes = ShellDll.NotifyIcon(NIM_MODIFY,&nidData);
        }
    }
    MYDBGASSERT(bRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::RemoveIcon
//
// Synopsis:  remove icon from the tray
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CTrayIcon::RemoveIcon() 
{
    if (m_hIcon)
    {
        NOTIFYICONDATA nidData;

        ZeroMemory(&nidData,sizeof(nidData));
        nidData.cbSize = sizeof(nidData);
        nidData.hWnd = m_hwnd;
        nidData.uID = m_uID;

        //
        // Load Shell32.dll and call Shell_NotifyIcon
        //
        CShellDll ShellDll;
        BOOL bRes = ShellDll.NotifyIcon(NIM_DELETE,&nidData);
        MYDBGASSERT(bRes);

        DeleteObject(m_hIcon);
        m_hIcon = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  class CMultipleString
//
//  Description: A string taht have multiple sub strings.
//      The format is "stringA\0stringB\0...\0\0"
//
//  History:    fengsun Created     2/17/98
//
//----------------------------------------------------------------------------

class CMultipleString
{
public:
    CMultipleString(const TCHAR* lpStrings) {m_lpStrings = lpStrings;}
    const TCHAR* GetNextString();

protected:
    const TCHAR * m_lpStrings; // pointer to the string to be distracted
};

//+----------------------------------------------------------------------------
//
// Function:  CMultipleString::GetNextString
//
// Synopsis:  Get the next substring 
//
// Arguments: None
//
// Returns:   const TCHAR* - The next sub string or NULL
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
const TCHAR* CMultipleString::GetNextString()
{
    MYDBGASSERT(m_lpStrings);

    if (m_lpStrings[0] == TEXT('\0'))
    {
        //
        // Reach the end og the string
        //
        return NULL;
    }

    const TCHAR* lpReturn = m_lpStrings;

    //
    // Advance the pointer to the next string
    //
    m_lpStrings += lstrlenU(lpReturn)+1;

    return (lpReturn);
}

//+----------------------------------------------------------------------------
//
// Function:  CTrayIcon::CreateMenu
//
// Synopsis:  Create the menu for the tray icon
//
// Arguments: const CIni* pIniFile - The ini file which have a tray menu section
//            DWORD dwMsgBase - The starting message id for the additional 
//                          command in the tray menu
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CTrayIcon::CreateMenu(const CIni* pIniFile, DWORD dwMsgBase)
{
    MYDBGASSERT(pIniFile);

    //
    // The default tray menu is the sub-menu of IDM_TRAY in the resource
    //
    m_hMenu = LoadMenuU(CMonitor::GetInstance(), MAKEINTRESOURCE(IDM_TRAY));
    MYDBGASSERT(m_hMenu != NULL);

    m_hSubMenu = GetSubMenu(m_hMenu, 0);
    MYDBGASSERT(m_hSubMenu != NULL);

    //
    // lpMenuNames contains all the entry names under c_pszCmSectionMenuOptions
    //
    LPTSTR lpMenuNames = pIniFile->GPPS(c_pszCmSectionMenuOptions, (LPTSTR)NULL);

    if (lpMenuNames[0] == 0)
    {
        //
        // No additional menu item
        //
        CmFree(lpMenuNames);
        return;
    }

    int nMenuPos; // the position to insert menu;

    nMenuPos = GetMenuItemCount(m_hSubMenu);
    MYDBGASSERT(nMenuPos >= 0);

    //
    // Add seperator
    //
    MYVERIFY(FALSE != InsertMenuU(m_hSubMenu, nMenuPos, MF_BYPOSITION|MF_SEPARATOR, 0, 0));
    nMenuPos++;


    //
    // append menus
    //

    CMultipleString MultipleStr(lpMenuNames);

    while(TRUE)
    {
        const TCHAR* lpMenuName = MultipleStr.GetNextString();

        if (lpMenuName == NULL)
        {
            //
            // No more string
            //
            break;
        }

        LPTSTR lpCmdLine = pIniFile->GPPS(c_pszCmSectionMenuOptions,lpMenuName);

        MYDBGASSERT(lpCmdLine && lpCmdLine[0]);

        if (lpCmdLine[0] == 0)
        {
            //
            // Ignore menu without command line
            //
            CmFree(lpCmdLine);
            continue;
        }

        //
        // Add the command to the menu
        //
        MYVERIFY(FALSE != InsertMenuU(m_hSubMenu, nMenuPos, MF_BYPOSITION|MF_STRING, 
            dwMsgBase + m_CommandArray.GetSize(), lpMenuName));

        nMenuPos++;

        //
        // Add the command to the command array
        //
        m_CommandArray.Add(lpCmdLine);
    }

    CmFree(lpMenuNames);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\pch.hpp ===
extern "C" {
#include "pch.h"
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Implementation of DllMain for cmpbk32.dll.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

extern HINSTANCE g_hInst;

extern "C" BOOL WINAPI DllMain(
    HINSTANCE  hinstDLL,	// handle to DLL module 
    DWORD  fdwReason,		// reason for calling function 
    LPVOID  lpvReserved 	// reserved 
   )
{
	if (fdwReason == DLL_PROCESS_ATTACH)
    {
        MYDBGASSERT(hinstDLL);
		g_hInst = hinstDLL;
        MYVERIFY(DisableThreadLibraryCalls(hinstDLL));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\cm_misc.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cm_misc.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Miscellaneous functions.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// INCLUDES

#include "cmmaster.h"

HINSTANCE g_hInst;

#if 0
/*
int MyStrICmpWithRes(HINSTANCE hInst, LPCTSTR psz1, UINT n2) {
	LPTSTR psz2;
	int iRes;

	if (!psz1) {
		return (-1);
	}
	if (!2) {
		return (1);
	}
	psz2 = CmLoadString(hInst,n2);
	iRes = lstrcmpi(psz1,psz2);
	CmFree(psz2);
	return (iRes);
}
*/
#endif

//+----------------------------------------------------------------------------
//
// Function:  GetBaseDirFromCms
//
// Synopsis:  Strips the filename part and sub-directiory from the specified 
//            src path which is expected to be a fully qualified path to a .CMS
//
// Arguments: LPCSTR pszSrc - The src path and filename
//
// Returns:   LPTSTR - Ptr to allocated Base Directory name including trailing "\"
//
// History:   nickball    Created    3/8/98
//
//+----------------------------------------------------------------------------
LPTSTR GetBaseDirFromCms(LPCSTR pszSrc)
{
    LPTSTR pszBase = NULL;

    MYDBGASSERT(pszSrc);

    if (NULL == pszSrc || 0 == pszSrc[0])
    {
        return NULL;
    }

    //
    // The source filename should exist 
    //

    HANDLE hFile = CreateFile(pszSrc, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
	                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    

    if (INVALID_HANDLE_VALUE == hFile)
    {
        MYDBGASSERT(FALSE); 
        return NULL;    
    }

    CloseHandle(hFile);

    //
    // File name is good allocate a buffer to work with
    //
    LPTSTR pszSlash = NULL;
    pszBase = (LPTSTR) CmMalloc((_tcslen(pszSrc) +1)*sizeof(TCHAR));

    if (pszBase)
    {
        _tcscpy(pszBase, pszSrc);

        pszSlash = CmStrrchr(pszBase,TEXT('\\'));

        if (!pszSlash)
        {
            MYDBGASSERT(FALSE); // should be a full path
            CmFree(pszBase);
            return NULL;
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("GetBaseDirFromCms -- Unable to allocate pszBase."));
        return NULL;	
    }

    //
    // Null terminate at slash and find next
    //

    *pszSlash = TEXT('\0');                                    
    pszSlash = CmStrrchr(pszBase,TEXT('\\'));

    if (!pszSlash)
    {
        MYDBGASSERT(FALSE); // should be a full path
        CmFree(pszBase);
        return NULL;
    }

    //
    // Null terminate at slash again and we're done
    //

//    pszSlash = _tcsinc(pszSlash);
    *pszSlash = TEXT('\0');                         

    return pszBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\cm_misc.h ===
//+----------------------------------------------------------------------------
//
// File:     cm_misc.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Miscellaneous function definitions.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------
#ifndef _CM_MISC_INC
#define _CM_MISC_INC


//+----------------------------------------------------------------------------
// defines
//+----------------------------------------------------------------------------

//
// the register stuff is from libc(cruntime.h)
//
#ifdef _M_IX86
/*
 * x86
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4

#else
/*
 * ALPHA
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4    register
#endif

int MyStrCmp(LPCTSTR psz1, LPCTSTR psz2);

//int MyStrICmpWithRes(HINSTANCE hInst, LPCTSTR psz1, UINT n2);

LPTSTR GetBaseDirFromCms(LPCSTR pszSrc);

void * __cdecl CmBSearch (
    REG4 const void *key,
    const void *base,
    size_t num,
    size_t width,
    int (__cdecl *compare)(const void *, const void *)
);

void __cdecl CmQSort (
    void *base,
    unsigned num,
    unsigned width,
    int (__cdecl *comp)(const void *, const void *)
);

//+----------------------------------------------------------------------------
// externs
//+----------------------------------------------------------------------------
extern HINSTANCE g_hInst;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\cm_phbk.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cm_phbk.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Implementation of the Private CM Phone book API.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// INCLUDES

#include "cmmaster.h"

#include <stddef.h>
#include <limits.h>

//#define DllImport extern "C" __declspec(dllimport)

#define MIN_TAPI_VERSION        0x10004
#define MAX_TAPI_VERSION        0x10004

const TCHAR* const c_pszCmEntryIspFilterMask    = TEXT("Mask&");
const TCHAR* const c_pszCmEntryIspFilterMatch   = TEXT("Match&");
const TCHAR* const c_pszCmSectionServiceTypes   = TEXT("Service Types");
const TCHAR* const c_pszBps                     = TEXT("bps");

#ifndef UNICODE
    
CM_PHBK_DllExportP PhoneBookCopyFilter(PPBFS pFilterIn)
{
    PPBFS pRes;
    DWORD dwSize;

    if (!pFilterIn)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }
    // Undocumented feature (used internally):  always allocates room for one additional pair.
    dwSize = offsetof(PhoneBookFilterStruct,aData) + sizeof(pRes->aData) * (pFilterIn->dwCnt + 1);
    pRes = (PPBFS) CmMalloc((size_t) dwSize);

    if (pRes)
    {
        CopyMemory(pRes,pFilterIn,(size_t) dwSize - sizeof(pRes->aData));
    }

    return pRes;
}


CM_PHBK_DllExportV PhoneBookFreeFilter(PPBFS pFilter)
{
    CmFree(pFilter);
}


CM_PHBK_DllExportB PhoneBookMatchFilter(PPBFS pFilter, DWORD dwValue)
{
    DWORD dwIdx;

    if (!pFilter)
    {
        return FALSE;
    }
    for (dwIdx = 0; dwIdx < pFilter->dwCnt; dwIdx++)
    {
        if ((dwValue & pFilter->aData[dwIdx].dwMask) == pFilter->aData[dwIdx].dwMatch)
        {
            return TRUE;
        }
    }
    return FALSE;
}

static PPBFS GetFilterFromFile(LPCTSTR pszFile, LPCTSTR pszFilter)
{
    LPTSTR pszFilterTmp;
    LPTSTR pszTmp;
    static PhoneBookFilterStruct sInit = {0,{{0,0}}};
    PPBFS pRes;
    CIni iniTmp(g_hInst,pszFile);

    pRes = PhoneBookCopyFilter(&sInit);
    if (!pRes)
    {
        return NULL;
    }
    pszFilterTmp = CmStrCpyAlloc(pszFilter);
    pszTmp = CmStrtok(pszFilterTmp,TEXT(" \t,"));
    while (pszTmp)
    {
        iniTmp.SetEntry(pszTmp);
        pRes->aData[pRes->dwCnt].dwMask = iniTmp.GPPI(c_pszCmSectionIsp,c_pszCmEntryIspFilterMask,0x00000000);
        pRes->aData[pRes->dwCnt].dwMatch = iniTmp.GPPI(c_pszCmSectionIsp,c_pszCmEntryIspFilterMatch,0xffffffff);
        pRes->dwCnt++;
        pszTmp = CmStrtok(NULL,TEXT(" \t,"));
        if (pszTmp)
        {
            PPBFS pResTmp;

            pResTmp = PhoneBookCopyFilter(pRes);
            PhoneBookFreeFilter(pRes);
            pRes = pResTmp;
            if (!pRes)
            {
                CmFree(pszFilterTmp);
                return NULL;
            }
        }
    }

    CmFree(pszFilterTmp);
    return pRes;
}


CM_PHBK_DllExportB PhoneBookParseInfoA(LPCSTR pszFile, PhoneBookParseInfoStructA *pInfo)
{
    CIni iniFile(g_hInst,(LPCTSTR) pszFile);
    LPTSTR pszTmp;

    if (!pszFile || !pInfo || pInfo->dwSize != sizeof(*pInfo)) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    pszTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspUrl);
    if (pInfo->pszURL && ((DWORD) lstrlen(pszTmp) >= pInfo->dwURL)) 
    {
        pInfo->dwURL = lstrlen(pszTmp) + 1;
        CmFree(pszTmp);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    
    pInfo->dwURL = lstrlen(pszTmp) + 1;
    if (pInfo->pszURL) 
    {
        lstrcpy(pInfo->pszURL,pszTmp);
    }
    CmFree(pszTmp);
    pszTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspFilterA);

    pInfo->pFilterA = GetFilterFromFile((LPCTSTR) pszFile,pszTmp);
    CmFree(pszTmp);
    pszTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspFilterB);
    pInfo->pFilterB = GetFilterFromFile((LPCTSTR) pszFile,pszTmp);

    CmFree(pszTmp);
    if (pInfo->pfnSvc) 
    {
        LPTSTR pszSvc;

        pszTmp = iniFile.GPPS(c_pszCmSectionServiceTypes,(LPTSTR) NULL);
        pszSvc = pszTmp;
        while (*pszSvc) 
        {
            LPTSTR pszFilter;
            PPBFS pFilter;

            pszFilter = iniFile.GPPS(c_pszCmSectionServiceTypes,pszSvc);

            pFilter = GetFilterFromFile((LPCTSTR) pszFile,pszFilter);
            CmFree(pszFilter);
            if (!pInfo->pfnSvc(pszSvc,pFilter,pInfo->dwSvcParam)) 
            {
                break;
            }
            pszSvc += lstrlen(pszSvc) + 1;
        }
        CmFree(pszTmp);
    }
    
    if (pInfo->pfnRef) 
    {
        LPTSTR pszRef,pszNext;
        CIni iniRef(g_hInst);

        pszTmp = iniFile.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspReferences);
        pszRef = NULL;
        pszNext = pszTmp;

        while (1) 
        {
            LPTSTR pszURL;
            LPTSTR pszRefTmp;
            PPBFS pFilterA;
            PPBFS pFilterB;

            //
            // Parse out reference list
            //

            pszRef = CmStrtok(pszNext,TEXT(" \t,"));
            if (pszRef)
            {
                pszNext = pszRef + lstrlen(pszRef)+1; // CHECK FOR MBCS COMPATIBLITY
            }

            if (!pszRef) 
            {
                break;
            }
            
            //
            // Setup ini file and paths for this reference
            //

            iniFile.SetEntry(pszRef);

            LPTSTR pszRefFile = (LPTSTR) CmMalloc(MAX_PATH+1);
            LPTSTR pszBasePath = GetBaseDirFromCms(pszFile);
            LPTSTR pszPhoneFile = (LPTSTR) CmMalloc(MAX_PATH+1);
                       
            pszRefTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspCmsFile);
                
            //
            //  Make sure we have a full path to the .CMS
            //

            if (pszRefTmp && *pszRefTmp && pszRefFile && pszPhoneFile && pszBasePath)
            {
                LPTSTR pszTemp = NULL;               

                if (SearchPath(pszBasePath, pszRefTmp, NULL, MAX_PATH, pszRefFile, &pszTemp))
                {
                    iniRef.SetFile(pszRefFile);
                }

                CmFree(pszRefTmp);

                //
                // Verify that phone books for this reference exists.
                //
                
                pszRefTmp = iniRef.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspPbFile);                         

                //
                // If there is a phonebook file name in the .CMS, use 
                // it to construct a full path to the PhoneBook file.
                //

                if (*pszRefTmp)
                {                                       
                    lstrcpy(pszPhoneFile, pszBasePath);
                    lstrcat(pszPhoneFile, TEXT("\\"));
                    lstrcat(pszPhoneFile, pszRefTmp);                   
                }
                else
                {
                    *pszPhoneFile = 0; 
                }

                CmFree(pszRefTmp);

                //
                // If we have a name, see if the file exists
                //

                if (*pszPhoneFile) 
                {
                    HANDLE hFile = CreateFile(pszPhoneFile, 0,  
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        NULL, OPEN_EXISTING, 
                                        FILE_ATTRIBUTE_NORMAL, NULL);                    
                    //
                    // If the file does not exist, we create an empty one
                    //

                    if (INVALID_HANDLE_VALUE == hFile)
                    {                
                        hFile = CreateFile(pszPhoneFile,
                                    GENERIC_READ|GENERIC_WRITE, 0,
                                    (LPSECURITY_ATTRIBUTES)NULL,
                                    CREATE_NEW, FILE_ATTRIBUTE_NORMAL,
                                    NULL);

                        if (INVALID_HANDLE_VALUE == hFile)
                        {
                            //
                            // If for some reason we failed to create the file,
                            // we skip this reference pbk.
                            //

                            CmFree(pszBasePath);
                            CmFree(pszPhoneFile);
                            CmFree(pszRefFile);
                            continue;
                        }

                        CloseHandle(hFile);
                    }
                    else
                    {
                        CloseHandle(hFile);
                    }
                }

                //
                // We have a file, get the URL and the filters
                //

                pszRefTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspUrl);
                pszURL = iniRef.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspUrl,pszRefTmp);
                CmFree(pszRefTmp);

                pszRefTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspFilterA);
                pFilterA = GetFilterFromFile(iniFile.GetFile(),pszRefTmp);
                CmFree(pszRefTmp);

                pszRefTmp = iniFile.GPPS(c_pszCmSectionIsp,c_pszCmEntryIspFilterB);
                pFilterB = GetFilterFromFile(iniFile.GetFile(),pszRefTmp);
                CmFree(pszRefTmp);
                pszRefTmp = NULL;

                pInfo->pfnRef(pszRefFile,pszURL,pFilterA,pFilterB,pInfo->dwRefParam);
                
                PhoneBookFreeFilter(pFilterA);
                PhoneBookFreeFilter(pFilterB);
                CmFree(pszURL);
            } 
            
            //
            // Cleanup
            //
            CmFree(pszRefTmp);
            CmFree(pszRefFile);
            CmFree(pszPhoneFile);
            CmFree(pszBasePath);
        }
        CmFree(pszTmp);
    }
    return TRUE;
}

CM_PHBK_DllExportV PhoneBookEnumCountries(DWORD_PTR dwPB,
                                          PhoneBookCallBack pfnCountry,
                                          PPBFS pFilter,
                                          DWORD_PTR dwParam)
{
    ((CPhoneBook *) dwPB)->EnumCountries(pFilter,pfnCountry,dwParam);
}


//
//  Note: this function and its mirror function PhoneBookGetStringW must stay in sync
//
static BOOL PhoneBookGetStringA(LPCSTR pszSrc, LPSTR pszDest, DWORD *pdwDest)
{
    DWORD dwTmp = lstrlen(pszSrc);

    if (dwTmp > *pdwDest)
    {
        *pdwDest = dwTmp;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    lstrcpy(pszDest,pszSrc);
    *pdwDest = dwTmp;
    return TRUE;
}

//
//  Note: this function and its mirror function PhoneBookGetStringA must stay in sync
//
static BOOL PhoneBookGetStringW(LPCWSTR pszSrc, LPWSTR pszDest, DWORD *pdwDest)
{
    DWORD dwTmp = lstrlenW(pszSrc);

    if (dwTmp > *pdwDest)
    {
        *pdwDest = dwTmp;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    lstrcpyW(pszDest,pszSrc);
    *pdwDest = dwTmp;
    return TRUE;
}



CM_PHBK_DllExportB PhoneBookGetCountryNameA(DWORD_PTR dwPB, unsigned int nIdx, LPSTR pszCountryName, DWORD *pdwCountryName)
{
    return (PhoneBookGetStringA(((CPhoneBook *) dwPB)->GetCountryNameByIdx(nIdx),pszCountryName,pdwCountryName));
}

CM_PHBK_DllExportB PhoneBookGetCountryNameW(DWORD_PTR dwPB, unsigned int nIdx, LPWSTR pszCountryName, DWORD *pdwCountryName)
{
    return (PhoneBookGetStringW(((CPhoneBook *) dwPB)->GetCountryNameByIdxW(nIdx),pszCountryName,pdwCountryName));
}

CM_PHBK_DllExportD PhoneBookGetCountryId(DWORD_PTR dwPB, unsigned int nIdx)
{
    return (((CPhoneBook *) dwPB)->GetCountryIDByIdx(nIdx));
}

CM_PHBK_DllExportB PhoneBookHasPhoneType(DWORD_PTR dwPB, PPBFS pFilter)
{
    return ((CPhoneBook *) dwPB)->FHasPhoneType(pFilter);
}

CM_PHBK_DllExportV PhoneBookEnumRegions(DWORD_PTR dwPB,
                                        PhoneBookCallBack pfnRegion,
                                        DWORD dwCountryID,
                                        PPBFS pFilter,
                                        DWORD_PTR dwParam)
{
    ((CPhoneBook *) dwPB)->EnumRegions(dwCountryID,pFilter,pfnRegion,dwParam);
}


CM_PHBK_DllExportB PhoneBookGetRegionNameA(DWORD_PTR dwPB,
                                           unsigned int nIdx,
                                           LPSTR pszRegionName,
                                           DWORD *pdwRegionName)
{

    return (PhoneBookGetStringA(((CPhoneBook *) dwPB)->GetRegionNameByIdx(nIdx),pszRegionName,pdwRegionName));
}


CM_PHBK_DllExportB PhoneBookGetPhoneCanonicalA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszPhoneNumber, DWORD *pdwPhoneNumber)
{
    char szTmp[64];

    ((CPhoneBook *) dwPB)->GetCanonical(dwIdx,szTmp);
    return (PhoneBookGetStringA(szTmp,pszPhoneNumber,pdwPhoneNumber));
}

CM_PHBK_DllExportB PhoneBookGetPhoneNonCanonicalA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszPhoneNumber, DWORD *pdwPhoneNumber)
{
    char szTmp[64];

    ((CPhoneBook *) dwPB)->GetNonCanonical(dwIdx,szTmp);
    return (PhoneBookGetStringA(szTmp,pszPhoneNumber,pdwPhoneNumber));
}

CM_PHBK_DllExportD PhoneBookGetPhoneType(DWORD_PTR dwPB, unsigned int nIdx)
{
    return (((CPhoneBook *) dwPB)->GetPhoneTypeByIdx(nIdx));
}


CM_PHBK_DllExportV PhoneBookEnumNumbers(DWORD_PTR dwPB,
                                        PhoneBookCallBack pfnNumber,
                                        DWORD dwCountryID,
                                        unsigned int nRegion,
                                        PPBFS pFilter,
                                        DWORD_PTR dwParam)
{
    if (nRegion != UINT_MAX)
    {
        ((CPhoneBook *) dwPB)->EnumNumbersByRegion(nRegion,dwCountryID,pFilter,pfnNumber,dwParam);
    }
    else
    {
        ((CPhoneBook *) dwPB)->EnumNumbersByCountry(dwCountryID,pFilter,pfnNumber,dwParam);
    }
}


CM_PHBK_DllExportV PhoneBookEnumNumbersWithRegionsZero(DWORD_PTR dwPB,
                                                       PhoneBookCallBack pfnNumber,
                                                       DWORD dwCountryID,
                                                       PPBFS pFilter,
                                                       DWORD_PTR dwParam) 
{
    ((CPhoneBook *) dwPB)->EnumNumbersByRegion(UINT_MAX, 
                                               dwCountryID, 
                                               pFilter,
                                               pfnNumber,
                                               dwParam);
}


//+---------------------------------------------------------------------------
//
// Function  static GetPhoneBaudDesc()
//
// Description:
//      Get the phone baudrate discription in " (BaudMin - BaudMax bps)" format
//
// Arguments:
//      IN CPhoneBook* pPB:  Pointer to phone book
//      DWORD dwIdx: Index for PhoneBook.m_rgPhoneBookEntry[] 
//      OUT LPTSTR pszBaudDisp: Hold output text, should have enough space to hold the output
//
//+---------------------------------------------------------------------------

static void GetPhoneBaudDesc(IN CPhoneBook* pPB, DWORD dwIdx, OUT LPTSTR pszBaudDisp)
{
    MYDBGASSERT(pPB != NULL);
    MYDBGASSERT(pszBaudDisp != NULL);

    DWORD dwMinBaud = pPB->GetMinBaudByIdx(dwIdx);
    DWORD dwMaxBaud = pPB->GetMaxBaudByIdx(dwIdx);

    if (dwMinBaud == 0 && dwMaxBaud == 0)
    {
        //
        // If both dwMinBaud and dwMaxBaud are 0, we are done
        //
        pszBaudDisp[0] = 0;
    }
    else
    {
        //
        // If the min/max baud are identical
        // don't bother displaying as a range, just display the number 400: (400 bps)
        //

        if (dwMinBaud == dwMaxBaud)
            wsprintf(pszBaudDisp, " (%lu %s)", dwMaxBaud, c_pszBps); //  " (Baud bps)"
        else if (dwMinBaud == 0)
            wsprintf(pszBaudDisp, " (1-%lu %s)", dwMaxBaud, c_pszBps); //  " (1-dwMaxBaud bps)"
        else if (dwMaxBaud == 0)
            wsprintf(pszBaudDisp, " (%lu+  %s)", dwMinBaud, c_pszBps);  //  " (dwMinBaud+  bps)"
        else
            wsprintf(pszBaudDisp, " (%lu-%lu %s)", dwMinBaud, dwMaxBaud, c_pszBps);  //  " (dwMinBaud-dwMaxBaud bps)"
    }
}


//+---------------------------------------------------------------------------
//
// Function PhoneBookGetPhoneDispA()
//
// Description:
//      Format the phone discription text form phonebook dwPB and index dwIndx
//          "City (AreaCode) AccessNumber (MinBaud-MaxBaud bps)"
//
// Arguments:
//      DWORD_PTR dwPB:  Pointer to phone book
//      DWORD dwIdx: Index for PhoneBook.m_rgPhoneBookEntry[] 
//      LPTSTR pszDisp: ???
//      DWORD *pdwDisp: ???
//
// Return: ???
//
//+---------------------------------------------------------------------------

CM_PHBK_DllExportB PhoneBookGetPhoneDispA(DWORD_PTR dwPB, DWORD dwIdx, LPTSTR pszDisp, DWORD *pdwDisp) 
{
    CPhoneBook *pPB = (CPhoneBook *) dwPB;
    TCHAR szTmp[256];

    MYDBGASSERT(pPB != NULL);

    //
    // If AreaCode is not empty then format is "City (AreaCode) AccessNumber" ...
    //
    if (pPB->GetAreaCodeByIdx(dwIdx)[0] != '\0')
    {
        wsprintf(szTmp,
                 "%s (%s) %s",
                 pPB->GetCityNameByIdx(dwIdx),
                 pPB->GetAreaCodeByIdx(dwIdx),
                 pPB->GetAccessNumberByIdx(dwIdx));
    }
    else 
    {
        //
        // Otherwise, AreaCode is empty, format is "City AccessNumber" ...
        //
        wsprintf(szTmp,
                 "%s %s",
                 pPB->GetCityNameByIdx(dwIdx),
                 pPB->GetAccessNumberByIdx(dwIdx));
    }

    //
    // Get the "(BaudMin-BaudMax bps)" text
    //
    TCHAR szBaudStr[64];
    GetPhoneBaudDesc(pPB, dwIdx, szBaudStr);

    lstrcat(szTmp, szBaudStr);

    return (PhoneBookGetStringA(szTmp,pszDisp,pdwDisp));
}


//+---------------------------------------------------------------------------
//
// PhoneBookGetPhoneDescA()
//
// Description:
//      Format part of the phone discription text form phonebook dwPB and index dwIndx
//          "City (MinBaud-MaxBaud bps)"
//
// Arguments:
//      DWORD_PTR dwPB:  Pointer to phone book
//      DWORD dwIdx: Index for PhoneBook.m_rgPhoneBookEntry[] 
//      LPTSTR pszDisp: ???
//      DWORD *pdwDisp: ???
//
// Return: ???
//
//+---------------------------------------------------------------------------

CM_PHBK_DllExportB PhoneBookGetPhoneDescA(DWORD_PTR dwPB, DWORD dwIdx, LPTSTR pszDesc, DWORD *pdwDesc) 
{
    CPhoneBook *pPB = (CPhoneBook *) dwPB;
    TCHAR szTmp[256];

    lstrcpy(szTmp, pPB->GetCityNameByIdx(dwIdx));

    //
    // Get the "(BaudMin-BaudMax bps)" text
    //
    TCHAR szBaudStr[64];
    GetPhoneBaudDesc(pPB, dwIdx, szBaudStr);

    lstrcat(szTmp, szBaudStr);

    return (PhoneBookGetStringA(szTmp,pszDesc,pdwDesc));
}


VOID FAR PASCAL CMPB_LineCallback(DWORD hDevice,
                                  DWORD dwMsg,
                                  DWORD dwCallbackInstance,
                                  DWORD dwParam1,
                                  DWORD dwParam2,
                                  DWORD dwParam3)
{

    // nothing
}


static LPVOID GetTapiPfn(HINSTANCE *phInst, LPCTSTR pszFn)
{
    LPVOID pvRes = NULL;

    *phInst = LoadLibrary(TEXT("tapi32"));

    if (*phInst)
    {
        pvRes = GetProcAddress(*phInst,pszFn);
        if (pvRes)
        {
            return pvRes;
        }
        FreeLibrary(*phInst);
    }
    return NULL;
}


static LONG PBlineInitialize(LPHLINEAPP lphLineApp,
                             HINSTANCE hInstance,
                             LINECALLBACK lpfnCallback,
                             LPCSTR lpszAppName,
                             LPDWORD lpdwNumDevs)
{
    HINSTANCE hInst;
    LONG (WINAPI *pfn)(LPHLINEAPP,HINSTANCE,LINECALLBACK,LPCSTR,LPDWORD);
    LONG lRes;

    pfn = (LONG (WINAPI *)(LPHLINEAPP,HINSTANCE,LINECALLBACK,LPCSTR,LPDWORD)) GetTapiPfn(&hInst,"lineInitialize");
    if (!pfn)
    {
        return LINEERR_NOMEM;
    }
    lRes = pfn(lphLineApp,hInstance,lpfnCallback,lpszAppName,lpdwNumDevs);
    FreeLibrary(hInst);
    return lRes;
}


static LONG PBlineNegotiateAPIVersion(HLINEAPP hLineApp,
                                      DWORD dwDeviceID,
                                      DWORD dwAPILowVersion,
                                      DWORD dwAPIHighVersion,
                                      LPDWORD lpdwAPIVersion,
                                      LPLINEEXTENSIONID lpExtensionID)
{
    HINSTANCE hInst;
    LONG (WINAPI *pfn)(HLINEAPP,DWORD,DWORD,DWORD,LPDWORD,LPLINEEXTENSIONID);
    LONG lRes;

    pfn = (LONG (WINAPI *)(HLINEAPP,DWORD,DWORD,DWORD,LPDWORD,LPLINEEXTENSIONID)) GetTapiPfn(&hInst,"lineNegotiateAPIVersion");
    if (!pfn)
    {
        return LINEERR_NOMEM;
    }
    lRes = pfn(hLineApp,dwDeviceID,dwAPILowVersion,dwAPIHighVersion,lpdwAPIVersion,lpExtensionID);
    FreeLibrary(hInst);
    return lRes;
}


static LONG PBlineGetTranslateCaps(HLINEAPP hLineApp, DWORD dwAPIVersion, LPLINETRANSLATECAPS lpTranslateCaps)
{
    HINSTANCE hInst;
    LONG (WINAPI *pfn)(HLINEAPP,DWORD,LPLINETRANSLATECAPS);
    LONG lRes;

    pfn = (LONG (WINAPI *)(HLINEAPP,DWORD,LPLINETRANSLATECAPS)) GetTapiPfn(&hInst,"lineGetTranslateCaps");
    if (!pfn)
    {
        return LINEERR_NOMEM;
    }
    lRes = pfn(hLineApp,dwAPIVersion,lpTranslateCaps);
    FreeLibrary(hInst);
    return lRes;
}


static LONG PBlineShutdown(HLINEAPP hLineApp)
{
    HINSTANCE hInst;
    LONG (WINAPI *pfn)(HLINEAPP);
    LONG lRes;

    pfn = (LONG (WINAPI *)(HLINEAPP)) GetTapiPfn(&hInst,"lineShutdown");
    if (!pfn)
    {
        return LINEERR_NOMEM;
    }
    lRes = pfn(hLineApp);
    FreeLibrary(hInst);
    return lRes;
}


static DWORD PhoneBookGetCurrentCountryIdAndCode(LPDWORD pdwCountryCode)
{
    HLINEAPP hLine = NULL;
    DWORD dwCountry = 1;
    DWORD dwCountryCode = 1;
    DWORD dwDevices;
    LPLINETRANSLATECAPS pTC = NULL;
    LPLINELOCATIONENTRY plle;
    DWORD dwAPI;

    PBlineInitialize(&hLine,g_hInst,CMPB_LineCallback,NULL,&dwDevices);
    if (!hLine)
    {
        goto done;
    }
    while (dwDevices)
    {
        LINEEXTENSIONID leid;

        if (PBlineNegotiateAPIVersion(hLine,dwDevices-1,0x00010004,0x00010004,&dwAPI,&leid) == ERROR_SUCCESS)
        {
            break;
        }
        dwDevices--;
    }
    if (!dwDevices)
    {
        goto done;
    }
    dwDevices--;
    pTC = (LPLINETRANSLATECAPS) CmMalloc(sizeof(LINETRANSLATECAPS));

    if (NULL == pTC)
    {
        goto done;
    }

    pTC->dwTotalSize = sizeof(LINETRANSLATECAPS);
    if (PBlineGetTranslateCaps(hLine,dwAPI,pTC) != ERROR_SUCCESS)
    {
        goto done;
    }
    dwCountry = pTC->dwNeededSize;
    CmFree(pTC);
    pTC = (LPLINETRANSLATECAPS) CmMalloc((size_t) dwCountry);

    if (NULL == pTC)
    {
        goto done;
    }

    pTC->dwTotalSize = dwCountry;
    dwCountry = 1;
    if (PBlineGetTranslateCaps(hLine,dwAPI,pTC) != ERROR_SUCCESS)
    {
        goto done;
    }
    plle = (LPLINELOCATIONENTRY) (((LPBYTE) pTC) + pTC->dwLocationListOffset);
    for (dwDevices=0;dwDevices<pTC->dwNumLocations;dwDevices++,plle++)
    {
        if (pTC->dwCurrentLocationID == plle->dwPermanentLocationID)
        {
            dwCountry = plle->dwCountryID;
            dwCountryCode = plle->dwCountryCode;
            break;
        }
    }
done:
    if (hLine)
    {
        PBlineShutdown(hLine);
    }
    CmFree(pTC);
    if (pdwCountryCode)
    {
        *pdwCountryCode = dwCountryCode;
    }
    return dwCountry;
}


CM_PHBK_DllExportD PhoneBookGetCurrentCountryId()
{
    return (PhoneBookGetCurrentCountryIdAndCode(NULL));
}


CM_PHBK_DllExportB PhoneBookGetPhoneDUNA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszDUN, DWORD *pdwDUN)
{
    return (PhoneBookGetStringA(((CPhoneBook *) dwPB)->GetDataCenterByIdx(dwIdx),pszDUN,pdwDUN));
}


#else  // The following routines only exist for UNICODE versions. 

// UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE 
// UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE 
// UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE UNICODE 

// Helpers

static LPSTR wc2mb(UINT nCP, LPCWSTR pszStr)
{
    int iLen;
    LPSTR pszTmp;

    iLen = WideCharToMultiByte(nCP,0,pszStr,-1,NULL,0,NULL,NULL);
    pszTmp = (LPSTR) CmMalloc(iLen*sizeof(*pszTmp));

    if (pszTmp)
    {
        iLen = WideCharToMultiByte(nCP,0,pszStr,-1,pszTmp,iLen,NULL,NULL);
        if (!iLen)
        {
            CmFree(pszTmp);
            return NULL;
        }
    }
    return pszTmp;
}


static LPWSTR mb2wc(UINT nCP, LPCSTR pszStr)
{
    int iLen;
    LPWSTR pszTmp;

    iLen = MultiByteToWideChar(nCP,0,pszStr,-1,NULL,0);
    pszTmp = (LPWSTR) CmMalloc(iLen*sizeof(*pszTmp));

    if (pszTmp)
    {
        iLen = MultiByteToWideChar(nCP,0,pszStr,-1,pszTmp,iLen);
        if (!iLen)
        {
            CmFree(pszTmp);
            return NULL;
        }
    }
    return pszTmp;
}


static void strcpy_wc2mb(UINT nCP, LPSTR pszDest, LPCWSTR pszSrc)
{
    LPSTR pszTmp;

    pszTmp = wc2mb(nCP,pszSrc);
    _mbscpy((unsigned char *) pszDest,(unsigned char *) pszTmp);
    CmFree(pszTmp);
}


static void strcpy_mb2wc(UINT nCP, LPWSTR pszDest, LPCSTR pszSrc)
{
    LPWSTR pszTmp;

    pszTmp = mb2wc(nCP,pszSrc);
    wcscpy(pszDest,pszTmp);
    CmFree(pszTmp);
}

static void reW2A(const RASENTRYW *pIn, RASENTRYA *pOut)
{

    pOut->dwSize = sizeof(*pOut);
    pOut->dwfOptions = pIn->dwfOptions;
    pOut->dwCountryID = pIn->dwCountryID;
    pOut->dwCountryCode = pIn->dwCountryCode;
    strcpy_wc2mb(CP_OEMCP,pOut->szAreaCode,pIn->szAreaCode);
    strcpy_wc2mb(CP_OEMCP,pOut->szLocalPhoneNumber,pIn->szLocalPhoneNumber);

    pOut->dwAlternateOffset = pIn->dwAlternateOffset + sizeof(*pOut) - sizeof(*pIn);

    CopyMemory(&pOut->ipaddr,&pIn->ipaddr,sizeof(pIn->ipaddr));
    CopyMemory(&pOut->ipaddrDns,&pIn->ipaddrDns,sizeof(pIn->ipaddrDns));
    CopyMemory(&pOut->ipaddrDnsAlt,&pIn->ipaddrDnsAlt,sizeof(pIn->ipaddrDnsAlt));
    CopyMemory(&pOut->ipaddrWins,&pIn->ipaddrWins,sizeof(pIn->ipaddrWins));
    CopyMemory(&pOut->ipaddrWinsAlt,&pIn->ipaddrWinsAlt,sizeof(pIn->ipaddrWinsAlt));
    pOut->dwFrameSize = pIn->dwFrameSize;
    pOut->dwfNetProtocols = pIn->dwfNetProtocols;
    pOut->dwFramingProtocol = pIn->dwFramingProtocol;
    strcpy_wc2mb(CP_OEMCP,pOut->szScript,pIn->szScript);
    strcpy_wc2mb(CP_OEMCP,pOut->szAutodialDll,pIn->szAutodialDll);
    strcpy_wc2mb(CP_OEMCP,pOut->szAutodialFunc,pIn->szAutodialFunc);
    strcpy_wc2mb(CP_OEMCP,pOut->szDeviceType,pIn->szDeviceType);
    strcpy_wc2mb(CP_OEMCP,pOut->szDeviceName,pIn->szDeviceName);
    strcpy_wc2mb(CP_OEMCP,pOut->szX25PadType,pIn->szX25PadType);
    strcpy_wc2mb(CP_OEMCP,pOut->szX25Address,pIn->szX25Address);
    strcpy_wc2mb(CP_OEMCP,pOut->szX25Facilities,pIn->szX25Facilities);
    strcpy_wc2mb(CP_OEMCP,pOut->szX25UserData,pIn->szX25UserData);
    pOut->dwChannels = pIn->dwChannels;

    if (pIn->dwAlternateOffset)
    {
        LPWSTR pszIn = (LPWSTR) (((LPBYTE) pIn) + pIn->dwAlternateOffset);
        LPSTR pszOut = (LPSTR) (((LPBYTE) pOut) + pOut->dwAlternateOffset);

        while (*pszIn)
        {
            strcpy_wc2mb(CP_OEMCP,pszOut,pszIn);
            pszIn += wcslen(pszIn) + 1;
            pszOut += _mbslen((unsigned char *) pszOut) + 1;
        }
    }
}


static void reA2W(const RASENTRYA *pIn, RASENTRYW *pOut)
{
    pOut->dwSize = sizeof(*pOut);
    pOut->dwfOptions = pIn->dwfOptions;
    pOut->dwCountryID = pIn->dwCountryID;
    pOut->dwCountryCode = pIn->dwCountryCode;
    strcpy_mb2wc(CP_OEMCP,pOut->szAreaCode,pIn->szAreaCode);
    strcpy_mb2wc(CP_OEMCP,pOut->szLocalPhoneNumber,pIn->szLocalPhoneNumber);

    pOut->dwAlternateOffset = pIn->dwAlternateOffset + sizeof(*pOut) - sizeof(*pIn);
    
    CopyMemory(&pOut->ipaddr,&pIn->ipaddr,sizeof(pIn->ipaddr));
    CopyMemory(&pOut->ipaddrDns,&pIn->ipaddrDns,sizeof(pIn->ipaddrDns));
    CopyMemory(&pOut->ipaddrDnsAlt,&pIn->ipaddrDnsAlt,sizeof(pIn->ipaddrDnsAlt));
    CopyMemory(&pOut->ipaddrWins,&pIn->ipaddrWins,sizeof(pIn->ipaddrWins));
    CopyMemory(&pOut->ipaddrWinsAlt,&pIn->ipaddrWinsAlt,sizeof(pIn->ipaddrWinsAlt));
    pOut->dwFrameSize = pIn->dwFrameSize;
    pOut->dwfNetProtocols = pIn->dwfNetProtocols;
    pOut->dwFramingProtocol = pIn->dwFramingProtocol;
    strcpy_mb2wc(CP_OEMCP,pOut->szScript,pIn->szScript);
    strcpy_mb2wc(CP_OEMCP,pOut->szAutodialDll,pIn->szAutodialDll);
    strcpy_mb2wc(CP_OEMCP,pOut->szAutodialFunc,pIn->szAutodialFunc);
    strcpy_mb2wc(CP_OEMCP,pOut->szDeviceType,pIn->szDeviceType);
    strcpy_mb2wc(CP_OEMCP,pOut->szDeviceName,pIn->szDeviceName);
    strcpy_mb2wc(CP_OEMCP,pOut->szX25PadType,pIn->szX25PadType);
    strcpy_mb2wc(CP_OEMCP,pOut->szX25Address,pIn->szX25Address);
    strcpy_mb2wc(CP_OEMCP,pOut->szX25Facilities,pIn->szX25Facilities);
    strcpy_mb2wc(CP_OEMCP,pOut->szX25UserData,pIn->szX25UserData);
    pOut->dwChannels = pIn->dwChannels;

    if (pIn->dwAlternateOffset)
    {
        LPSTR pszIn = (LPSTR) (((LPBYTE) pIn) + pIn->dwAlternateOffset);
        LPWSTR pszOut = (LPWSTR) (((LPBYTE) pOut) + pOut->dwAlternateOffset);

        while (*pszIn)
        {
            strcpy_mb2wc(CP_OEMCP,pszOut,pszIn);
            pszIn += _mbslen((unsigned char *) pszIn) + 1;
            pszOut += wcslen(pszOut) + 1;
        }
    }
}

// Wide versions of current APIs

static BOOL PhoneBookGetStringW(LPCSTR pszSrc, LPWSTR pszDest, DWORD *pdwDest)
{
    DWORD dwTmp;

    dwTmp = MultiByteToWideChar(GetACP(),0,pszSrc,-1,NULL,0);
    if (dwTmp > *pdwDest)
    {
        *pdwDest = dwTmp;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    dwTmp = MultiByteToWideChar(GetACP(),0,pszSrc,-1,pszDest,*pdwDest);
    *pdwDest = dwTmp;
    return TRUE;
}

static BOOL WINAPI PhoneBookParseInfoWSvcThunk(LPCSTR pszSvc,
                                               PPBFS pFilter, 
                                               DWORD_PTR dwParam)
{
    PhoneBookParseInfoStructW *pParam = (PhoneBookParseInfoStructW *) dwParam;
    LPWSTR pszTmpSvc;
    BOOL bRes;
    DWORD dwErr;

    pszTmpSvc = mb2wc(GetACP(),pszSvc);
    if (!pszTmpSvc) {
        return FALSE;
    }
    bRes = pParam->pfnSvc(pszTmpSvc,pFilter,pParam->dwSvcParam);
    if (!bRes) {
        dwErr = GetLastError();
    }
    CmFree(pszTmpSvc);
    if (!bRes) {
        SetLastError(dwErr);
    }
    return (bRes);
}


static BOOL WINAPI PhoneBookParseInfoWRefThunk(LPCSTR pszFile,
                                               LPCSTR pszURL,
                                               PPBFS pFilterA,
                                               PPBFS pFilterB,
                                               DWORD_PTR dwParam)
{
    PhoneBookParseInfoStructW *pParam = (PhoneBookParseInfoStructW *) dwParam;
    LPWSTR pszTmpFile;
    LPWSTR pszTmpURL;
    DWORD dwErr;
    BOOL bRes;

    pszTmpFile = mb2wc(CP_OEMCP,pszFile);
    if (!pszTmpFile)
    {
        return FALSE;
    }
    pszTmpURL = mb2wc(CP_OEMCP,pszURL);
    if (!pszTmpURL)
    {
        dwErr = GetLastError();
        CmFree(pszTmpFile);
        SetLastError(dwErr);
        return FALSE;
    }
    bRes = pParam->pfnRef(pszTmpFile,pszTmpURL,pFilterA,pFilterB,pParam->dwRefParam);
    if (!bRes)
    {
        dwErr = GetLastError();
    }
    CmFree(pszTmpFile);
    CmFree(pszTmpURL);
    if (!bRes)
    {
        SetLastError(dwErr);
    }
    return bRes;
}

CM_PHBK_DllExportB PhoneBookGetCountryNameW(DWORD_PTR dwPB, unsigned int nIdx, LPWSTR pszCountryName, DWORD *pdwCountryName)
{
    return (PhoneBookGetStringW(((CPhoneBook *) dwPB)->GetCountryNameByIdx(nIdx),pszCountryName,pdwCountryName));
}

CM_PHBK_DllExportB PhoneBookGetRegionNameW(DWORD_PTR dwPB, unsigned int nIdx, LPWSTR pszRegionName, DWORD *pdwRegionName)
{
    return (PhoneBookGetStringW(((CPhoneBook *) dwPB)->GetRegionNameByIdx(nIdx),pszRegionName,pdwRegionName));
}


CM_PHBK_DllExportB PhoneBookGetPhoneCanonicalW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszPhoneNumber, DWORD *pdwPhoneNumber)
{
    char szTmp[64];

    ((CPhoneBook *) dwPB)->GetCanonical(dwIdx,szTmp);
    return (PhoneBookGetStringW(szTmp,pszPhoneNumber,pdwPhoneNumber));
}

CM_PHBK_DllExportB PhoneBookGetPhoneNonCanonicalW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszPhoneNumber, DWORD *pdwPhoneNumber)
{
    char szTmp[64];

    ((CPhoneBook *) dwPB)->GetNonCanonical(dwIdx,szTmp);
    return (PhoneBookGetStringW(szTmp,pszPhoneNumber,pdwPhoneNumber));
}

CM_PHBK_DllExportB PhoneBookParseInfoW(LPCWSTR pszFile, PhoneBookParseInfoStructW *pInfo)
{
    LPSTR pszTmpFile;
    PhoneBookParseInfoStructA iInfo;
    BOOL bRes;
    DWORD dwErr;
    LPWSTR pszTmpURL;

    if (!pszFile || !pInfo || pInfo->dwSize != sizeof(*pInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pszTmpFile = wc2mb(CP_OEMCP,pszFile);
    if (!pszTmpFile)
    {
        return FALSE;
    }
    ZeroMemory(&iInfo,sizeof(iInfo));
    iInfo.dwSize = sizeof(iInfo);
    iInfo.dwURL = MAX_PATH * 3 / 2;
    while (1)
    {
        iInfo.pszURL = (LPSTR) CmMalloc(iInfo.dwURL * sizeof(*iInfo.pszURL));

        if (NULL == iInfo.pszURL)
        {
            CmFree(pszTmpFile);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;		
        }

        bRes = PhoneBookParseInfoA(pszTmpFile,&iInfo);
        if (bRes)
        {
            break;
        }
        dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
        {
            CmFree(iInfo.pszURL);
            CmFree(pszTmpFile);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }
        CmFree(iInfo.pszURL);
    }
    pszTmpURL = mb2wc(CP_OEMCP,iInfo.pszURL);
    if (!pszTmpURL)
    {
        dwErr = GetLastError();
        CmFree(pszTmpFile);
        CmFree(iInfo.pszURL);
        SetLastError(dwErr);
        return FALSE;
    }
    if (pInfo->pszURL && (wcslen(pszTmpURL) >= pInfo->dwURL))
    {
        pInfo->dwURL = wcslen(pszTmpURL) + 1;
        CmFree(pszTmpFile);
        CmFree(iInfo.pszURL);
        CmFree(pszTmpURL);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    pInfo->dwURL = wcslen(pszTmpURL) + 1;
    if (pInfo->pszURL)
    {
        wcscpy(pInfo->pszURL,pszTmpURL);
    }
    CmFree(iInfo.pszURL);
    CmFree(pszTmpURL);
    pInfo->pFilterA = iInfo.pFilterA;
    pInfo->pFilterB = iInfo.pFilterB;
    if (!pInfo->pfnSvc && !pInfo->pfnRef)
    {
        CmFree(pszTmpFile);
        return TRUE;
    }
    iInfo.pszURL = NULL;
    if (pInfo->pfnSvc)
    {
        iInfo.pfnSvc = PhoneBookParseInfoWSvcThunk;
        iInfo.dwSvcParam = (DWORD_PTR) pInfo;
    }
    if (pInfo->pfnRef)
    {
        iInfo.pfnRef = PhoneBookParseInfoWRefThunk;
        iInfo.dwRefParam = (DWORD_PTR) pInfo;
    }
    bRes = PhoneBookParseInfoA(pszTmpFile,&iInfo);
    if (!bRes)
    {
        dwErr = GetLastError();
    }
    CmFree(pszTmpFile);
    if (!bRes)
    {
        SetLastError(dwErr);
    }
    return bRes;
}

CM_PHBK_DllExportB PhoneBookGetPhoneDispW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDisp, DWORD *pdwDisp)
{
    CPhoneBook *pPB = (CPhoneBook *) dwPB;
    char szTmp[256];
    wsprintf(szTmp,
             "%s (%s) %s (%u-%u %s)",
             pPB->GetCityNameByIdx(dwIdx),
             pPB->GetAreaCodeByIdx(dwIdx),
             pPB->GetAccessNumberByIdx(dwIdx),
             pPB->GetMinBaudByIdx(dwIdx),
             pPB->GetMaxBaudByIdx(dwIdx),
             c_pszBps);
    return (PhoneBookGetStringW(szTmp,pszDisp,pdwDisp));
}


CM_PHBK_DllExportB PhoneBookGetPhoneDescW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDesc, DWORD *pdwDesc)
{
    CPhoneBook *pPB = (CPhoneBook *) dwPB;
    char szTmp[256];

    wsprintf(szTmp,
             "%s (%u-%u %s)",
             pPB->GetCityNameByIdx(dwIdx),
             pPB->GetMinBaudByIdx(dwIdx),
             pPB->GetMaxBaudByIdx(dwIdx),
             c_pszBps);
    return (PhoneBookGetStringW(szTmp,pszDesc,pdwDesc));
}


CM_PHBK_DllExportB PhoneBookGetPhoneDUNW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDUN, DWORD *pdwDUN)
{
    return (PhoneBookGetStringW(((CPhoneBook *) dwPB)->GetDataCenterByIdx(dwIdx),pszDUN,pdwDUN));
}

#endif // ndef UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\misc.h ===
//+----------------------------------------------------------------------------
//
// File:     misc.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Miscellaneous phone book utility functions.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// PROTOTYPES
void SzCanonicalFromAE (char *psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE);
void SzNonCanonicalFromAE (char *psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE);
int __cdecl CompareIDLookUpElements(const void*e1, const void*e2);
int __cdecl CompareCntryNameLookUpElementsA(const void*e1, const void*e2);
int __cdecl CompareCntryNameLookUpElementsW(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElements(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2);
BOOL FSz2Dw(PCSTR pSz,DWORD *dw);
BOOL FSz2W(PCSTR pSz,WORD *w);
BOOL FSz2B(PCSTR pSz,BYTE *pb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\misc.cpp ===
//+----------------------------------------------------------------------------
//
// File:     misc.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Miscellaneous phone book utility functions.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// Miscellaneous support routines

#include "cmmaster.h"

/*  Not used anywhere, take out
#define irgMaxSzs 5
char szStrTable[irgMaxSzs][256];

// ############################################################################
PSTR GetSz(WORD wszID)
{
    static int iSzTable=0;
    
    PSTR psz = (PSTR) szStrTable[iSzTable];

    iSzTable++;
    if (iSzTable >= irgMaxSzs)
        iSzTable = 0;
        
    if (!LoadString(g_hInst, wszID, psz, 256))
    {
        CMTRACE1("LoadString failed %d\n", (DWORD) wszID);
        *psz = 0;
    }
        
    return (psz);
}
*/
// ############################################################################
void SzCanonicalFromAE (char *psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE)
{
    if (NO_AREA_CODE == pAE->dwAreaCode)
    {
        wsprintf(psz, "+%lu %s", pLCE->dwCountryCode, pAE->szAccessNumber);
    }
    else
    {
        wsprintf(psz, "+%lu (%s) %s", pLCE->dwCountryCode, pAE->szAreaCode, pAE->szAccessNumber);
    }
    
    return;
}

// ############################################################################
void SzNonCanonicalFromAE (char *psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE)
{
    if (NO_AREA_CODE == pAE->dwAreaCode)
    {
        wsprintf(psz, "%lu %s", pLCE->dwCountryCode, pAE->szAccessNumber);
    }
    else
    {
        wsprintf(psz, "%lu %s %s", pLCE->dwCountryCode, pAE->szAreaCode, pAE->szAccessNumber);
    }
    
    return;
}

// ############################################################################

int MyStrcmp(PVOID pv1, PVOID pv2)
{
    char *pc1 = (char*) pv1;
    char *pc2 = (char*) pv2;
    int iRC = 0;
    // loop while not pointed at the ending NULL character and no difference has been found
    while (*pc1 && *pc2 && !iRC)
    {
        iRC = (int)(*pc1 - *pc2);
        pc1++;
        pc2++;
    }

    // if we exited because we got to the end of one string before we found a difference
    // return -1 if pv1 is longer, else return the character pointed at by pv2.  If pv2
    // is longer than pv1 then the value at pv2 will be greater than 0.  If both strings
    // ended at the same time, then pv2 will point to 0.
    if (!iRC)
    {
        iRC = (*pc1) ? -1 : (*pc2);
    }
    return iRC;
}

// ############################################################################
int __cdecl CompareIDLookUpElements(const void*e1, const void*e2)
{
    if (((PIDLOOKUPELEMENT)e1)->dwID > ((PIDLOOKUPELEMENT)e2)->dwID)
        return 1;
    if (((PIDLOOKUPELEMENT)e1)->dwID < ((PIDLOOKUPELEMENT)e2)->dwID)
        return -1;
    return 0;
}

// ############################################################################
int __cdecl CompareCntryNameLookUpElementsA(const void*e1, const void*e2)
{
    PCNTRYNAMELOOKUPELEMENT pCUE1 = (PCNTRYNAMELOOKUPELEMENT)e1;
    PCNTRYNAMELOOKUPELEMENT pCUE2 = (PCNTRYNAMELOOKUPELEMENT)e2;

    return CompareStringA(LOCALE_USER_DEFAULT,0,pCUE1->psCountryName,
        pCUE1->dwNameSize,pCUE2->psCountryName,
        pCUE2->dwNameSize) - 2;
}

// ############################################################################
int __cdecl CompareCntryNameLookUpElementsW(const void*e1, const void*e2)
{
    PCNTRYNAMELOOKUPELEMENTW pCUE1 = (PCNTRYNAMELOOKUPELEMENTW)e1;
    PCNTRYNAMELOOKUPELEMENTW pCUE2 = (PCNTRYNAMELOOKUPELEMENTW)e2;

    return CompareStringW(LOCALE_USER_DEFAULT,0,pCUE1->psCountryName,
        pCUE1->dwNameSize,pCUE2->psCountryName,
        pCUE2->dwNameSize) - 2;
}

// ############################################################################
int __cdecl CompareIdxLookUpElements(const void*e1, const void*e2)
{
    PIDXLOOKUPELEMENT pidx1 = (PIDXLOOKUPELEMENT) e1;
    PIDXLOOKUPELEMENT pidx2 = (PIDXLOOKUPELEMENT) e2;

    if (pidx1->dwIndex > pidx2->dwIndex)    
    {
        return 1;
    }

    if (pidx1->dwIndex < pidx2->dwIndex)    
    {
        return -1;
    }           
        
    return 0;
}

// ############################################################################
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2)
{
    PACCESSENTRY pae1, pae2;
    int iSort;

    pae1 = (PACCESSENTRY) (((PIDXLOOKUPELEMENT)pv1)->iAE);
    pae2 = (PACCESSENTRY) (((PIDXLOOKUPELEMENT)pv2)->iAE);

    // sort empty enteries to the end of the list
    if (!(pae1 && pae2))
    {
        // return ((int)pae1) ? -1 : ((int)pae2);
        return (pae1 ? -1 : (pae2 ? 1 : 0));
    }

    // country ASC, state ASC, city ASC, toll free DESC, flip DESC, con spd max DESC
    if (pae1->dwCountryID != pae2->dwCountryID)
    {
        return (int) (pae1->dwCountryID - pae2->dwCountryID);
    }
    
    if (pae1->wStateID != pae2->wStateID)
    {
        return (pae1->wStateID - pae2->wStateID);
    }

    iSort  = MyStrcmp((PVOID)pae1->szCity, (PVOID)pae2->szCity);
    if (iSort)
    {
        return (iSort);
    }

    if (pae1->fType != pae2->fType)
    {
        return (int) (pae2->fType - pae1->fType);
    }

    if (pae1->bFlipFactor != pae2->bFlipFactor)
    {
        return (pae2->bFlipFactor - pae1->bFlipFactor);
    }

    if (pae1->dwConnectSpeedMax != pae2->dwConnectSpeedMax)
    {
        return (int) (pae2->dwConnectSpeedMax - pae1->dwConnectSpeedMax);
    }

    return 0;
}

// ############################################################################
//inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw)
BOOL FSz2Dw(PCSTR pSz,DWORD *dw)
{
    DWORD val = 0;
    while (*pSz)
    {
        if (*pSz >= '0' && *pSz <= '9')
        {
            val *= 10;
            val += *pSz++ - '0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
//inline BOOL FSz2W(PCSTR pSz,WORD *w)
BOOL FSz2W(PCSTR pSz,WORD *w)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *w = (WORD)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
//inline BOOL FSz2B(PCSTR pSz,BYTE *pb)
BOOL FSz2B(PCSTR pSz,BYTE *pb)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *pb = (BYTE)dw;
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\phbk.cpp ===
//+----------------------------------------------------------------------------
//
// File:     phbk.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Implementation of CPhoneBook
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------

// ############################################################################
// Phone book APIs

#include "cmmaster.h"

const TCHAR* const c_pszInfDefault = TEXT("INF_DEFAULT");
const TCHAR* const c_pszInfSuffix = TEXT(".CMS");

//#define ReadVerifyPhoneBookDW(x)  CMASSERTMSG(ReadPhoneBookDW(&(x),pcCSVFile),"Invalid DWORD in phone book");
#define ReadVerifyPhoneBookDW(x)    if (!ReadPhoneBookDW(&(x),pcCSVFile))               \
                                        {   CMASSERTMSG(0,"Invalid DWORD in phone book");   \
                                            goto DataError; }
#define ReadVerifyPhoneBookW(x)     if (!ReadPhoneBookW(&(x),pcCSVFile))                \
                                        {   CMASSERTMSG(0,"Invalid WORD in phone book");    \
                                            goto DataError; }
#define ReadVerifyPhoneBookB(x)     if (!ReadPhoneBookB(&(x),pcCSVFile))                \
                                        {   CMASSERTMSG(0,"Invalid BYTE in phone book");    \
                                            goto DataError; }
#define ReadVerifyPhoneBookSZ(x,y)  if (!ReadPhoneBookSZ(&x[0],y+sizeof('\0'),pcCSVFile))   \
                                        {   CMASSERTMSG(0,"Invalid STRING in phone book");      \
                                            goto DataError; }
#define CHANGE_BUFFER_SIZE 50

#define ERROR_USERBACK 32766
#define ERROR_USERCANCEL 32767
                                        
// ############################################################################
void CPhoneBook::EnumNumbersByCountry(DWORD dwCountryID, PPBFS pFilter, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumNumbersByCountry"));

    PACCESSENTRY pAELast, pAE = NULL;
    PIDLOOKUPELEMENT pIDLookUp;
    IDLOOKUPELEMENT LookUpTarget;
    
    LookUpTarget.dwID = dwCountryID;
    pIDLookUp = NULL;
    pIDLookUp = (PIDLOOKUPELEMENT)CmBSearch(&LookUpTarget,m_rgIDLookUp,
        (size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);
    if (pIDLookUp)
        pAE = IdxToPAE(pIDLookUp->iFirstAE);

    // Fill the list for whatever AE's we found
    //
    
    if (pAE)
    {
        pAELast = &(m_rgPhoneBookEntry[m_cPhoneBookEntries - 1]);
        while (pAELast >= pAE)
        {
            if (pAE->dwCountryID == dwCountryID && pAE->wStateID == 0) {
                if (PhoneBookMatchFilter(pFilter,pAE->fType))
                {
                    pfnNumber((unsigned int) (pAE - m_rgPhoneBookEntry),dwParam);
                }
            }
            pAE++;
        }

        // Select the first item
        //

    }
}
// ############################################################################
void CPhoneBook::EnumNumbersByCountry(DWORD dwCountryID, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumNumbersByCountry"));

    PhoneBookFilterStruct sFilter = {1,{{dwMask,fType}}};

    EnumNumbersByCountry(dwCountryID,&sFilter,pfnNumber,dwParam);
}

// ############################################################################
BOOL CPhoneBook::FHasPhoneType(PPBFS pFilter)
{
    MYDBG(("CPhoneBook::FHasPhoneType"));

    PACCESSENTRY pAELast, pAE = NULL;

    pAE = &(m_rgPhoneBookEntry[0]); // pAE points to the first phone  book entry

    // 
    // Examine each entry until we find a match or exhaust the entries
    //

    if (pAE)
    {
        pAELast = &(m_rgPhoneBookEntry[m_cPhoneBookEntries - 1]);

        while (pAELast >= pAE)
        {
            //
            // See if this pop passes the specified filter
            //

            if (PhoneBookMatchFilter(pFilter, pAE->fType))
            {
                return TRUE;
            }

            pAE++;
        }
    }

    return FALSE;
}

// ############################################################################
void CPhoneBook::EnumNumbersByRegion(unsigned int nRegion, DWORD dwCountryID, PPBFS pFilter, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumNumbersByRegion"));

    PACCESSENTRY pAELast, pAE = NULL;
    
    pAE = &m_rgPhoneBookEntry[0]; // pAE points to the first phone  book entry

    // Fill the list for whatever AE's we found
    if (pAE)
    {
        pAELast = &(m_rgPhoneBookEntry[m_cPhoneBookEntries - 1]);
        while (pAELast >= pAE)
        {
            // choose phone number of the same region OR with region ID = 0(which means ALL regions)
            if (pAE->dwCountryID == dwCountryID && 
                ((pAE->wStateID == nRegion+1) || (pAE->wStateID == 0)))
            {
                    
                if (PhoneBookMatchFilter(pFilter,pAE->fType))
                    pfnNumber((unsigned int) (pAE - m_rgPhoneBookEntry), dwParam); 
            }
            pAE++;
        }
        // Select the first item
        //
    }
}
// ############################################################################
void CPhoneBook::EnumNumbersByRegion(unsigned int nRegion, DWORD dwCountryID, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumNumbersByRegion"));
    
    PhoneBookFilterStruct sFilter = {1,{{dwMask,fType}}};

    EnumNumbersByRegion(nRegion,dwCountryID,&sFilter,pfnNumber,dwParam);
}
// ############################################################################
void CPhoneBook::EnumRegions(DWORD dwCountryID, PPBFS pFilter, CB_PHONEBOOK pfnRegion, DWORD_PTR dwParam)
{
    unsigned int idx;

    MYDBG(("CPhoneBook::EnumRegions"));

    for (idx=0;idx<m_cStates;idx++)
    {
        PACCESSENTRY pAE = NULL, pAELast = NULL;

        pAE = &m_rgPhoneBookEntry[0]; 
        MYDBGASSERT(pAE);
        pAELast = &(m_rgPhoneBookEntry[m_cPhoneBookEntries - 1]);
        while (pAELast >= pAE) 
        {
            if (pAE->dwCountryID == dwCountryID &&
                pAE->wStateID == idx+1)
            {
                if (PhoneBookMatchFilter(pFilter,pAE->fType))
                    goto AddRegion;
            }
            pAE++;
        } // while

        continue; // start the next 'for' loop

AddRegion:
        pfnRegion(idx,dwParam);
    }
}


// ############################################################################
void CPhoneBook::EnumRegions(DWORD dwCountryID, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnRegion, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumRegions"));

    PhoneBookFilterStruct sFilter = {1,{{dwMask,fType}}};

    EnumRegions(dwCountryID,&sFilter,pfnRegion,dwParam);
}
// ############################################################################
void CPhoneBook::EnumCountries(PPBFS pFilter, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam)
{
    unsigned int idx;

    MYDBG(("CPhoneBook::EnumCountries"));

    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        if (FHasPhoneNumbers(m_rgNameLookUp[idx].pLCE->dwCountryID,pFilter))
        {
            pfnCountry(idx,dwParam);
        }
    }
}
// ############################################################################
void CPhoneBook::EnumCountries(DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam)
{
    MYDBG(("CPhoneBook::EnumCountries"));

    PhoneBookFilterStruct sFilter = {1,{{dwMask,fType}}};

    EnumCountries(&sFilter,pfnCountry,dwParam);
}
// ############################################################################
BOOL CPhoneBook::FHasPhoneNumbers(DWORD dwCountryID, PPBFS pFilter)
{
    PIDLOOKUPELEMENT pIDLookUp;
    IDLOOKUPELEMENT LookUpTarget;
    PACCESSENTRY pAE = NULL, pAELast = NULL;
    DWORD dwTmpCountryID;

    LookUpTarget.dwID = dwCountryID;

    pIDLookUp = NULL;
    pIDLookUp = (PIDLOOKUPELEMENT)CmBSearch(&LookUpTarget,m_rgIDLookUp,
        (size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);

    if (!pIDLookUp) return FALSE; // no such country

    pAE = IdxToPAE(pIDLookUp->iFirstAE);
    if (!pAE) return FALSE; // no phone numbers at all

    dwTmpCountryID = pAE->dwCountryID;

    pAELast = &(m_rgPhoneBookEntry[m_cPhoneBookEntries - 1]);
    while (pAELast >= pAE) {
        if (pAE->dwCountryID == dwTmpCountryID)
        {
            if (PhoneBookMatchFilter(pFilter,pAE->fType)) return TRUE;
        }
        pAE++;
    }
    return FALSE; // no phone numbers of the right type

//  return ((BOOL)(pIDLookUp->pFirstAE));
}
// ############################################################################
BOOL CPhoneBook::FHasPhoneNumbers(DWORD dwCountryID, DWORD dwMask, DWORD fType)
{
    MYDBG(("CPhoneBook::FHasPhoneNumbers"));
    
    PhoneBookFilterStruct sFilter = {1,{{dwMask,fType}}};

    return FHasPhoneNumbers(dwCountryID,&sFilter);
}

// ############################################################################
CPhoneBook::CPhoneBook()
{
    m_rgPhoneBookEntry = NULL;
    m_cPhoneBookEntries =0;
    m_rgLineCountryEntry=NULL;
    m_rgState=NULL;
    m_cStates=0;
    m_rgIDLookUp = NULL;
    m_rgNameLookUp = NULL;
    m_pLineCountryList = NULL;

    MYDBG(("CPhoneBook::CPhoneBook"));

    ZeroMemory(&m_szINFFile[0],MAX_PATH);
    ZeroMemory(&m_szPhoneBook[0],MAX_PATH);
}

// ############################################################################
CPhoneBook::~CPhoneBook()
{
    MYDBG(("CPhoneBook::~CPhoneBook"));

    CmFree(m_rgPhoneBookEntry);
    m_rgPhoneBookEntry = NULL;

    CmFree(m_pLineCountryList);
    m_pLineCountryList = NULL;

    CmFree(m_rgIDLookUp);
    m_rgIDLookUp = NULL;
    
    CmFree(m_rgNameLookUp);
    m_rgNameLookUp = NULL;
    
    CmFree(m_rgState);
    m_rgState = NULL;
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookDW(DWORD *pdw, CCSVFile *pcCSVFile)
{
    char szTempBuffer[TEMP_BUFFER_LENGTH];
    
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2Dw(szTempBuffer,pdw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookW(WORD *pw, CCSVFile *pcCSVFile)
{
    char szTempBuffer[TEMP_BUFFER_LENGTH];

    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2W(szTempBuffer,pw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookB(BYTE *pb, CCSVFile *pcCSVFile)
{
    char szTempBuffer[TEMP_BUFFER_LENGTH];

    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2B(szTempBuffer,pb));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookSZ(LPSTR psz, DWORD dwSize, CCSVFile *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(psz,dwSize))
            return FALSE;
    return TRUE;
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookNL(CCSVFile *pcCSVFile)
{
    if (!pcCSVFile->ClearNewLines())
            return FALSE;
    return TRUE;
}

//
//  Note: the new fUnicode parameter has been added so that Whistler and newer releases
//        take advantage of the Unicode TAPI functions where available, so that MUI works.
//
static LONG PBlineGetCountry(DWORD dwCountryID, DWORD dwAPIVersion, LPLINECOUNTRYLIST lpLineCountryList, BOOL fUnicode)
{
    HINSTANCE hInst;
    LONG lRes;

    // Try to load the TAPI DLL
    
    hInst = LoadLibrary("tapi32"); 
    
    if (!hInst) 
    {
        return (LINEERR_NOMEM);
    }
    
    // Get the proc address for GetCountry
    
    LONG (WINAPI *pfn)(DWORD,DWORD,LPLINECOUNTRYLIST);
    pfn = (LONG (WINAPI *)(DWORD,DWORD,LPLINECOUNTRYLIST)) GetProcAddress(hInst, fUnicode ? "lineGetCountryW" : "lineGetCountryA");
    
    if (!pfn) 
    {
        FreeLibrary(hInst);
        return (LINEERR_NOMEM);
    }
    
    // Get the country list
    
    lRes = pfn(dwCountryID,dwAPIVersion,lpLineCountryList);

    FreeLibrary(hInst);
    return (lRes);
}


// ############################################################################
HRESULT CPhoneBook::Init(LPCSTR pszISPCode)
{
    char szTempBuffer[TEMP_BUFFER_LENGTH];
    LPLINECOUNTRYLIST pLineCountryTemp = NULL;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD dwLastState = 0;
    DWORD dwLastCountry = 0;
    DWORD dwNumAllocated;
    PACCESSENTRY pCurAccessEntry;
    LPLINECOUNTRYENTRY pLCETemp;
    DWORD idx;
    LPTSTR pszTemp;
    LPTSTR pszCmpDir = NULL;
    CCSVFile *pcCSVFile=NULL;
    PSTATE  ps,psLast; //faster to use pointers.
    DWORD dwAlloc = 0;
    PACCESSENTRY pTempAccessEntry = NULL;

    MYDBG(("CPhoneBook::Init"));
    
    // Get TAPI country list
    m_pLineCountryList = (LPLINECOUNTRYLIST)CmMalloc(sizeof(LINECOUNTRYLIST));
    if (!m_pLineCountryList) 
    {
        goto InitExit;
    }
    
    m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);

    //
    //  Note: For Whistler and newer releases, we take advantage of the Unicode TAPI
    //        functions where available, so that MUI works.  Hence the final parameter
    //        to PBlineGetCountry, and the two different QSorts below.
    //
    
    // get ALL country information 
    idx = PBlineGetCountry(0,0x10003, m_pLineCountryList, OS_NT51);
    if (idx && idx != LINEERR_STRUCTURETOOSMALL)
    {
        goto InitExit;
    }
    
    MYDBGASSERT(m_pLineCountryList->dwNeededSize);

    // reallocate memory for country list
    pLineCountryTemp = (LPLINECOUNTRYLIST)CmMalloc(m_pLineCountryList->dwNeededSize);
    if (!pLineCountryTemp)
    {
        goto InitExit;
    }
    
    pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;

    CmFree(m_pLineCountryList);

    m_pLineCountryList = pLineCountryTemp;
    pLineCountryTemp = NULL;

    if (PBlineGetCountry(0,0x10003, m_pLineCountryList, OS_NT51))
    {
        goto InitExit;
    }

    // Load Look Up arrays
    // keyword:  country ID, 
    // keyvalue: pointer to the country entry in m_pLineCountryList
    //
#ifdef DEBUG
    m_rgIDLookUp = (IDLOOKUPELEMENT*)CmMalloc(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries+5);
#else
    m_rgIDLookUp = (IDLOOKUPELEMENT*)CmMalloc(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries);
#endif
    if (!m_rgIDLookUp) 
    {
        goto InitExit;
    }
    
    // pLCETemp points to the first country information entry
    pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR) m_pLineCountryList + 
               m_pLineCountryList->dwCountryListOffset);

    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        m_rgIDLookUp[idx].dwID = pLCETemp[idx].dwCountryID;
        m_rgIDLookUp[idx].pLCE = &pLCETemp[idx];
    }
    
    // sort the country lines
    
    CmQSort(m_rgIDLookUp, (size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
          CompareIDLookUpElements);

    
    // m_rgNameLookUp: look-up list for country name
    // keyword:  country name
    // keyvalue: pointer to the country entry in m_pLineCountryList

    m_rgNameLookUp = (CNTRYNAMELOOKUPELEMENT*)CmMalloc(sizeof(CNTRYNAMELOOKUPELEMENT) * m_pLineCountryList->dwNumCountries);
    
    if (!m_rgNameLookUp) 
    {
        goto InitExit;
    }
    
    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        m_rgNameLookUp[idx].psCountryName = (LPSTR)((DWORD_PTR)m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
        m_rgNameLookUp[idx].dwNameSize = pLCETemp[idx].dwCountryNameSize;
        m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
    }

    // sort the country names

    if (OS_NT51)
    {
        CmQSort(m_rgNameLookUp,(size_t) m_pLineCountryList->dwNumCountries,sizeof(CNTRYNAMELOOKUPELEMENTW),
            CompareCntryNameLookUpElementsW);
    }
    else
    {
        CmQSort(m_rgNameLookUp,(size_t) m_pLineCountryList->dwNumCountries,sizeof(CNTRYNAMELOOKUPELEMENT),
            CompareCntryNameLookUpElementsA);
        
    }

    //
    // Locate ISP's INF file (aka .CMS)
    //
    
    if (!SearchPath(NULL, (LPCTSTR) pszISPCode, c_pszInfSuffix, MAX_PATH, m_szINFFile, &pszTemp))
    {
        wsprintf(szTempBuffer,"Can not find:%s%s (%d)",pszISPCode,c_pszInfSuffix,GetLastError());
        CMASSERTMSG(0,szTempBuffer);
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    // Load Region file, get region file name

    char szStateFile[sizeof(szTempBuffer)/sizeof(szTempBuffer[0])];

    GetPrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspRegionFile, NULL, szStateFile, sizeof(szStateFile)-1, m_szINFFile);

    //
    // Can't assume current directory, construct path to PBK directory
    //

    pszCmpDir = GetBaseDirFromCms(m_szINFFile);

    //
    // Look for the .PBR file, using CMP dir as base path for search
    //  

    if (!SearchPath(pszCmpDir, szStateFile, NULL, TEMP_BUFFER_LENGTH, szTempBuffer, &pszTemp))
    {
        // CMASSERTMSG(0,"STATE.ICW not found");
        CMASSERTMSG(0,"region file not found");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    // open region file

    pcCSVFile = new CCSVFile;
    if (!pcCSVFile)
    {
        goto InitExit;
    }

    if (!pcCSVFile->Open(szTempBuffer))
    {
        // CMASSERTMSG(0,"Can not open STATE.ICW");
        CMASSERTMSG(0,"Can not open region file");
        delete pcCSVFile;
        pcCSVFile = NULL;
        goto InitExit;
    }

    // first token in region file is the number of regions

    if (!pcCSVFile->ClearNewLines() || !pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
    {
        goto InitExit;
    }
    
    if (!FSz2Dw(szTempBuffer,&m_cStates))
    {
        // CMASSERTMSG(0,"STATE.ICW count is invalid");
        CMASSERTMSG(0,"region count is invalid");
        goto InitExit;
    }

    // Now read in all the regions if there are any

    if (0 != m_cStates)
    {
        m_rgState = (PSTATE)CmMalloc(sizeof(STATE)*m_cStates);

        if (!m_rgState)
        {
            goto InitExit;
        }
    
        for (ps = m_rgState, psLast = &m_rgState[m_cStates - 1]; ps <= psLast;++ps)
        {
            if (pcCSVFile->ClearNewLines())
            {
                pcCSVFile->ReadToken(ps->szStateName,cbStateName);  
            }
        }
    }
    
    pcCSVFile->Close();

    // load Phone Book Name
    
    if (!GetPrivateProfileString(c_pszCmSectionIsp, c_pszCmEntryIspPbFile,c_pszInfDefault,
        szTempBuffer,TEMP_BUFFER_LENGTH,m_szINFFile))
    {
        CMASSERTMSG(0,"PhoneBookFile not specified in INF file");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }
    
#ifdef DEBUG
    if (!lstrcmp(szTempBuffer,c_pszInfDefault))
    {
        wsprintf(szTempBuffer, "%s value not found in ISP file", c_pszCmEntryIspPbFile);
        CMASSERTMSG(0,szTempBuffer);
    }
#endif

    //
    // Look for the .PBK file, using CMP dir as base path for search
    //

    if (!SearchPath(pszCmpDir,szTempBuffer,NULL,MAX_PATH,m_szPhoneBook,&pszTemp))
    {
        CMASSERTMSG(0,"ISP phone book not found");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    // read in phone book entries
    
    if (!pcCSVFile->Open(m_szPhoneBook))
    {
        CMASSERTMSG(0,"Can not open phone book");
        hr = GetLastError();
        goto InitExit;
    }
    
    dwNumAllocated = 0;
    do {

        MYDBGASSERT (dwNumAllocated >= m_cPhoneBookEntries);
    
        if (m_rgPhoneBookEntry)
        {
            // If we already have an array, make sure its big enough
            
            if (dwNumAllocated == m_cPhoneBookEntries)
            {
                // We're maxed out, allocate some more memory

                dwNumAllocated += PHONE_ENTRY_ALLOC_SIZE;
                dwAlloc = (DWORD) dwNumAllocated * sizeof(ACCESSENTRY);
                MYDBG(("PhoneBook::Init - Grow ReAlloc = %lu",dwAlloc));

                // Realloc

                pTempAccessEntry = (PACCESSENTRY)CmRealloc(m_rgPhoneBookEntry, dwAlloc);

                if (!pTempAccessEntry) 
                {
                    MYDBG(("PhoneBook::Init - Grow ReAlloc of %lu failed", dwAlloc));
                    goto InitExit;
                }

                m_rgPhoneBookEntry = pTempAccessEntry;
                pTempAccessEntry = NULL;

                MYDBG(("Grow phone book to %d entries",dwNumAllocated));
                pCurAccessEntry = m_rgPhoneBookEntry + m_cPhoneBookEntries;
            }
        }
        else
        {   
            // Initialization for the first time through

            DWORD dwSize = (DWORD) sizeof(ACCESSENTRY);
            dwAlloc =  (DWORD) dwSize * PHONE_ENTRY_ALLOC_SIZE; 

            MYDBG(("PhoneBook::Init - sizeof(ACCESSENTRY) = %lu",dwSize));
            MYDBG(("PhoneBook::Init - PHONE_ENTRY_ALLOC_SIZE = %d",PHONE_ENTRY_ALLOC_SIZE));
            MYDBG(("PhoneBook::Init - Initial Alloc = %lu",dwAlloc));
            
            // Allocate intial array of PHONE_ENTRY_ALLOC_SIZE items
            
            m_rgPhoneBookEntry = (PACCESSENTRY)CmMalloc(dwAlloc);

            if (!m_rgPhoneBookEntry) 
            {
                MYDBG(("PhoneBook::Init - Initial Alloc of %lu failed",dwAlloc));
                goto InitExit;
            }
            
            dwNumAllocated = PHONE_ENTRY_ALLOC_SIZE;
            pCurAccessEntry = m_rgPhoneBookEntry;
        }

        // Read a line from the phonebook

        hr = ReadOneLine(pCurAccessEntry,pcCSVFile);
        
        if (hr == ERROR_NO_MORE_ITEMS)
        {
            break;
        }
        else if (hr != ERROR_SUCCESS)
        {
            MYDBG(("PhoneBook::Init - ReadOneLine failed"));
            goto InitExit;
        }

        hr = ERROR_NOT_ENOUGH_MEMORY;
    
        // check the first index pointer to prevent it from being overwritten
        // by the second appearance that's scattered around somewhere else -- added by byao

        if (pCurAccessEntry->dwCountryID != dwLastCountry)
        {
            PIDLOOKUPELEMENT pIDLookUpElement;
            // NOTE: Not sure about the first parameter here.
            pIDLookUpElement = (PIDLOOKUPELEMENT)CmBSearch(&pCurAccessEntry->dwCountryID,
                m_rgIDLookUp,(size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
                CompareIDLookUpElements);

            if (!pIDLookUpElement)
            {
                // bad country ID, but we can't assert here
                MYDBG(("Bad country ID in phone book %d\n",pCurAccessEntry->dwCountryID));
                continue;
            }
            else
            {
                // for a given country ID this is the first phone number
                // don't overwrite existing index
                
                if (!pIDLookUpElement->iFirstAE) 
                {  
                    pIDLookUpElement->iFirstAE = PAEToIdx(pCurAccessEntry);
                    dwLastCountry = pCurAccessEntry->dwCountryID;
                }
            }
        }

        // Check to see if this is the first phone number for a given state
        // the code has been changed accordingly
        
        if (pCurAccessEntry->wStateID && (pCurAccessEntry->wStateID != dwLastState))
        {
            idx = pCurAccessEntry->wStateID - 1;
            //
            // don't overwrite existing index
            //
            if ((idx < m_cStates) && !m_rgState[idx].iFirst) 
            { 
                m_rgState[idx].dwCountryID = pCurAccessEntry->dwCountryID;
                m_rgState[idx].iFirst = PAEToIdx(pCurAccessEntry);
            }
            dwLastState = pCurAccessEntry->wStateID;
        }

        pCurAccessEntry++;
        m_cPhoneBookEntries++;
    
    } while (TRUE);

    MYDBG(("PhoneBook::Init - %lu Entries read",m_cPhoneBookEntries));

    if (m_cPhoneBookEntries == 0)
    {
        //
        // Phone book is empty
        //
        goto InitExit;
    }
    
    // Trim the phone book for unused memory
    
    dwAlloc = m_cPhoneBookEntries * sizeof(ACCESSENTRY);
    
    MYDBG(("PhoneBook::Init - Trim ReAlloc = %lu",dwAlloc));

    MYDBGASSERT(m_cPhoneBookEntries);

    // Realloc
    
    pTempAccessEntry = (PACCESSENTRY)CmRealloc(m_rgPhoneBookEntry, dwAlloc);

    MYDBGASSERT(pTempAccessEntry);
    
    if (!pTempAccessEntry) 
    {
        MYDBG(("PhoneBook::Init - Trim ReAlloc of %lu failed",dwAlloc));
        goto InitExit;
    }

    m_rgPhoneBookEntry = pTempAccessEntry;
    pTempAccessEntry = NULL;

    hr = ERROR_SUCCESS;

    // Exit
    
InitExit:

    // If something failed release everything

    if (hr != ERROR_SUCCESS)
    {
        CmFree(m_pLineCountryList);
        m_pLineCountryList = NULL;

        CmFree(m_rgPhoneBookEntry);

        m_rgPhoneBookEntry = NULL;
        m_cPhoneBookEntries = 0 ;
        
        CmFree(m_rgIDLookUp);
        m_rgIDLookUp=NULL;
        
        CmFree(m_rgNameLookUp);
        m_rgNameLookUp=NULL;
        
        CmFree(m_rgState);
        m_rgState = NULL;
        
        m_cStates = 0;
    }

    if (pcCSVFile) 
    {
        pcCSVFile->Close();
        delete pcCSVFile;
    }

    if (pszCmpDir)
    {
        CmFree(pszCmpDir);
    }

    return hr;
}

// ############################################################################
HRESULT CPhoneBook::Merge(LPCSTR pszChangeFile)
{
    char szTempBuffer[TEMP_BUFFER_LENGTH];
    char szTempFileName[MAX_PATH];
    CCSVFile *pcCSVFile = NULL;
    ACCESSENTRY aeChange;
    PIDXLOOKUPELEMENT rgIdxLookUp = NULL;
    PIDXLOOKUPELEMENT pCurIdxLookUp;
    DWORD dwAllocated;
    DWORD dwOriginalSize;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD   dwIdx;
    DWORD cch, cchWritten;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    MYDBG(("CPhoneBook::Merge"));

    // We'll grow the phone book on the first add record (this minimizes the number
    // of places in the code where we have to grow the phone book) - so, for now,
    // just stay with the current size.
    dwAllocated = m_cPhoneBookEntries;

    // Create index to loaded phone book, sorted by index
    rgIdxLookUp = (PIDXLOOKUPELEMENT)CmMalloc(sizeof(IDXLOOKUPELEMENT) * dwAllocated);

    MYDBGASSERT(rgIdxLookUp);
    
    if (!rgIdxLookUp)
    {
        goto MergeExit;
    }

    for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
    {
        rgIdxLookUp[dwIdx].iAE = PAEToIdx(&m_rgPhoneBookEntry[dwIdx]);
        rgIdxLookUp[dwIdx].dwIndex = IdxToPAE(rgIdxLookUp[dwIdx].iAE)->dwIndex;
    }
    dwOriginalSize = m_cPhoneBookEntries;

    CmQSort(rgIdxLookUp,(size_t) dwOriginalSize,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElements);

    // Load changes to phone book
    pcCSVFile = new CCSVFile;
    MYDBGASSERT(pcCSVFile);
    
    if (!pcCSVFile)
    {
        goto MergeExit;
    }

    if (!pcCSVFile->Open(pszChangeFile))
    {
        delete pcCSVFile;
        pcCSVFile = NULL;
        goto MergeExit;
    }
    
    do {

        // Read a change record
        ZeroMemory(&aeChange,sizeof(ACCESSENTRY));
        hr = ReadOneLine(&aeChange, pcCSVFile);

        if (hr == ERROR_NO_MORE_ITEMS)
        {
            break; // no more enteries
        }
        else if (hr != ERROR_SUCCESS)
        {
            goto MergeExit;
        }

        hr = ERROR_NOT_ENOUGH_MEMORY;

/*      if (!ReadPhoneBookDW(&aeChange.dwIndex,pcCSVFile))
            break; // no more enteries
        ReadVerifyPhoneBookDW(aeChange.dwCountryID);
        ReadVerifyPhoneBookW(aeChange.wStateID);
        ReadVerifyPhoneBookSZ(aeChange.szCity,cbCity);
        ReadVerifyPhoneBookSZ(aeChange.szAreaCode,cbAreaCode);
        // NOTE: 0 is a valid area code and ,, is a valid entry for an area code
        if (!FSz2Dw(aeChange.szAreaCode,&aeChange.dwAreaCode))
            aeChange.dwAreaCode = NO_AREA_CODE;
        ReadVerifyPhoneBookSZ(aeChange.szAccessNumber,cbAccessNumber);
        ReadVerifyPhoneBookDW(aeChange.dwConnectSpeedMin);
        ReadVerifyPhoneBookDW(aeChange.dwConnectSpeedMax);
        ReadVerifyPhoneBookB(aeChange.bFlipFactor);
        ReadVerifyPhoneBookDW(aeChange.fType);
        ReadVerifyPhoneBookSZ(aeChange.szDataCenter,cbDataCenter);
        */

        pCurIdxLookUp = (PIDXLOOKUPELEMENT) CmBSearch(&aeChange,
                                                    rgIdxLookUp,
                                                    (size_t) dwOriginalSize,
                                                    sizeof(IDXLOOKUPELEMENT),
                                                    CompareIdxLookUpElements);
        // Determine if this is a delete, add, or merge  record
        if (aeChange.szAccessNumber[0] == '0' && aeChange.szAccessNumber[1] == '\0')
        {
            // This is a delete record
            CMASSERTMSG(pCurIdxLookUp,"Attempting to delete a record that does not exist.  The change file and phone book versions do not match.");
            if (pCurIdxLookUp)
            {
                CMASSERTMSG(IdxToPAE(pCurIdxLookUp->iAE),"Attempting to delete a record that has already been deleted.");
                pCurIdxLookUp->iAE = PAEToIdx(NULL);  //Create a dead entry in the look up table
            }
        }
        else if (pCurIdxLookUp)
        {
            // This is a change record
            CMASSERTMSG(IdxToPAE(pCurIdxLookUp->iAE),"Attempting to change a record which has been deleted.");
            if (IdxToPAE(pCurIdxLookUp->iAE))
            {
                CopyMemory(IdxToPAE(pCurIdxLookUp->iAE),&aeChange,sizeof(ACCESSENTRY));
            }
        }
        else
        {
            // This is an add entry
            // Make sure we have enough room
            if (m_cPhoneBookEntries >= dwAllocated)
            {
                // Grow phone book    
                
                dwAllocated += CHANGE_BUFFER_SIZE;
                DWORD dwNewAlloc = (DWORD) sizeof(ACCESSENTRY) * dwAllocated;
                
                PACCESSENTRY pTempAccessEntry = (PACCESSENTRY)CmRealloc(m_rgPhoneBookEntry, dwNewAlloc);
                MYDBGASSERT(pTempAccessEntry);
                
                if (!pTempAccessEntry)
                {            
                    MYDBG(("PhoneBook::Merge - Grow ReAlloc of %lu failed",dwNewAlloc));
                    goto MergeExit;
                }

                m_rgPhoneBookEntry = pTempAccessEntry;
                
                pTempAccessEntry = NULL;

                MYDBG(("Grow phone book to %lu entries",dwAllocated));

                // Grow look up index
                MYDBGASSERT(rgIdxLookUp);

                PIDXLOOKUPELEMENT pTempLookupElement = (PIDXLOOKUPELEMENT)CmRealloc(rgIdxLookUp, sizeof(IDXLOOKUPELEMENT)*dwAllocated);             
                
                MYDBGASSERT(pTempLookupElement);
                if (!pTempLookupElement)
                {
                    goto MergeExit;
                }

                rgIdxLookUp = pTempLookupElement;
            }

            //Add entry to the end of the phonebook and to end of look up index
            CopyMemory(&m_rgPhoneBookEntry[m_cPhoneBookEntries],&aeChange,sizeof(ACCESSENTRY));
            rgIdxLookUp[m_cPhoneBookEntries].iAE = PAEToIdx(&m_rgPhoneBookEntry[m_cPhoneBookEntries]);
            rgIdxLookUp[m_cPhoneBookEntries].dwIndex = IdxToPAE(rgIdxLookUp[m_cPhoneBookEntries].iAE)->dwIndex;
            m_cPhoneBookEntries++;
            // NOTE: because the entry is added to the end of the list, we can't add
            // and delete entries in the same change file.
        }
    } while (TRUE);

    // The CompareIdxLookupElementFileOrder() function needs the iAE member to be
    // a PACCESSENTRY, and not an index.  So we convert 'em here, and then we'll
    // convert 'em back later.
    for (dwIdx=0;dwIdx<m_cPhoneBookEntries;dwIdx++) {
        rgIdxLookUp[dwIdx].iAE = (LONG_PTR)IdxToPAE(rgIdxLookUp[dwIdx].iAE);
    }

    // resort the IDXLookUp index to reflect the correct order of entries
    // for the phonebook file, including all of the entries to be deleted.
    CmQSort(rgIdxLookUp,(size_t) m_cPhoneBookEntries,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElementsFileOrder);

    // Now we convert 'em back.
    for (dwIdx=0;dwIdx<m_cPhoneBookEntries;dwIdx++) {
        rgIdxLookUp[dwIdx].iAE = PAEToIdx((PACCESSENTRY) rgIdxLookUp[dwIdx].iAE);
    }

    // Build a new phonebook file
#if 0
/*
    #define TEMP_PHONE_BOOK_PREFIX "PBH"

    if (!GetTempPath(TEMP_BUFFER_LENGTH,szTempBuffer))
        goto MergeExit;
    if (!GetTempFileName(szTempBuffer,TEMP_PHONE_BOOK_PREFIX,0,szTempFileName))
        goto MergeExit;
    hFile = CreateFile(szTempFileName,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,
        FILE_FLAG_WRITE_THROUGH,0);
*/
#else
    for (dwIdx=0;;dwIdx++)
    {
        lstrcpy(szTempFileName,m_szPhoneBook);

        wsprintf(szTempFileName+lstrlen(szTempFileName),".%03u",dwIdx);
        hFile = CreateFile(szTempFileName,GENERIC_WRITE,0,NULL,CREATE_NEW,0,0);
        if ((hFile != INVALID_HANDLE_VALUE) || (GetLastError() != ERROR_FILE_EXISTS)) {
            break;
        }
    }
#endif
    if (hFile == INVALID_HANDLE_VALUE)
    {
        goto MergeExit;
    }

    for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
    {
        PACCESSENTRY pAE = IdxToPAE(rgIdxLookUp[dwIdx].iAE);

        if (pAE) {
            cch = wsprintf(szTempBuffer, "%lu,%lu,%lu,%s,%s,%s,%lu,%lu,%lu,%lu,%s\r\n",
                pAE->dwIndex,
                pAE->dwCountryID,
                (DWORD) pAE->wStateID,
                pAE->szCity,
                pAE->szAreaCode,
                pAE->szAccessNumber,
                pAE->dwConnectSpeedMin,
                pAE->dwConnectSpeedMax,
                (DWORD) pAE->bFlipFactor,
                (DWORD) pAE->fType,
                pAE->szDataCenter);

            if (!WriteFile(hFile,szTempBuffer,cch,&cchWritten,NULL))
            {
                // something went wrong, get rid of the temporary file
                hr = GetLastError();
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
                DeleteFile(szTempFileName);
                goto MergeExit;
            }

            MYDBGASSERT(cch == cchWritten);
        }
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    // Move new phone book over old
    if (!DeleteFile(m_szPhoneBook))
    {
        hr = GetLastError();
        goto MergeExit;
    }
    if (!MoveFile(szTempFileName,m_szPhoneBook))
    {
        hr = GetLastError();
        goto MergeExit;
    }

    // discard the phonebook in memory

    CmFree(m_rgPhoneBookEntry);
    m_rgPhoneBookEntry = NULL;
    m_cPhoneBookEntries = 0;

    CmFree(m_pLineCountryList);
    CmFree(m_rgIDLookUp);
    CmFree(m_rgNameLookUp);
    CmFree(m_rgState);

    m_pLineCountryList = NULL;
    m_rgIDLookUp = NULL;
    m_rgNameLookUp = NULL;
    m_rgState = NULL;   
    m_cStates = 0;

    lstrcpy(szTempBuffer,m_szINFFile);
    m_szINFFile[0] = '\0';
    m_szPhoneBook[0] = '\0';

    //  Reload it (and rebuild look up arrays)
    hr = Init(szTempBuffer);

MergeExit:
    if (pcCSVFile)
    {
        pcCSVFile->Close();
        delete pcCSVFile;
    }
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    CmFree(rgIdxLookUp);
    
    return hr;
}

// ############################################################################
HRESULT CPhoneBook::ReadOneLine(PACCESSENTRY pAccessEntry, CCSVFile *pcCSVFile)
{
    HRESULT hr = ERROR_SUCCESS;

    //
    // Skip newlines (trailing or leading) and read first DW token
    // If either fail, then consider this the end of the file
    //

    if (!ReadPhoneBookNL(pcCSVFile) || !ReadPhoneBookDW(&pAccessEntry->dwIndex,pcCSVFile))
    {
        hr = ERROR_NO_MORE_ITEMS; // no more enteries
        MYDBG(("CPhoneBook::ReadOneLine - No More items"));
        goto ReadExit;
    }
    
    ReadVerifyPhoneBookDW(pAccessEntry->dwCountryID);
    ReadVerifyPhoneBookW(pAccessEntry->wStateID);
    ReadVerifyPhoneBookSZ(pAccessEntry->szCity,cbCity);
    ReadVerifyPhoneBookSZ(pAccessEntry->szAreaCode,cbAreaCode);
    // NOTE: 0 is a valid area code and ,, is a valid entry for an area code
    if (!FSz2Dw(pAccessEntry->szAreaCode,&pAccessEntry->dwAreaCode))
        pAccessEntry->dwAreaCode = NO_AREA_CODE;
    ReadVerifyPhoneBookSZ(pAccessEntry->szAccessNumber,cbAccessNumber);
    ReadVerifyPhoneBookDW(pAccessEntry->dwConnectSpeedMin);
    ReadVerifyPhoneBookDW(pAccessEntry->dwConnectSpeedMax);
    ReadVerifyPhoneBookB(pAccessEntry->bFlipFactor);
    ReadVerifyPhoneBookDW(pAccessEntry->fType);
    
    //
    // Attempt to read datacenter, if read fails, find out why before reacting
    //

    if (!ReadPhoneBookSZ(pAccessEntry->szDataCenter, cbDataCenter + 1, pcCSVFile))
    {
        //
        // If the last read was successful, then we must have some bad sz data
        //

        if (!pcCSVFile->ReadError())
        {
            CMASSERTMSG(0,"Invalid STRING in phone book");
            goto DataError;
        }
    }
    
ReadExit:
    return hr;
DataError:
    hr = ERROR_INVALID_DATA;
    goto ReadExit;
}

// ############################################################################
HRESULT CPhoneBook::GetCanonical (PACCESSENTRY pAE, char *psOut)
{
    HRESULT hr = ERROR_SUCCESS;
    PIDLOOKUPELEMENT pIDLookUp;

    pIDLookUp = (PIDLOOKUPELEMENT)CmBSearch(&pAE->dwCountryID,m_rgIDLookUp,
        (size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);

    if (!pIDLookUp)
    {
        hr = ERROR_INVALID_PARAMETER;
    } 
    else 
    {
        if (!psOut)
        {
            hr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            *psOut = 0;
            SzCanonicalFromAE (psOut, pAE, pIDLookUp->pLCE);
        }
    }

    return hr;
}

// ############################################################################
HRESULT CPhoneBook::GetNonCanonical (PACCESSENTRY pAE, char *psOut)
{
    HRESULT hr = ERROR_SUCCESS;
    PIDLOOKUPELEMENT pIDLookUp;

    pIDLookUp = (PIDLOOKUPELEMENT)CmBSearch(&pAE->dwCountryID,m_rgIDLookUp,
        (size_t) m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);

    if (!pIDLookUp)
    {
        hr = ERROR_INVALID_PARAMETER;
    } 
    else 
    {
        if (!psOut)
        {
            hr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            *psOut = 0;
            SzNonCanonicalFromAE (psOut, pAE, pIDLookUp->pLCE);
        }
    }

    return hr;
}

// ############################################################################
DllExportH PhoneBookLoad(LPCSTR pszISPCode, DWORD_PTR *pdwPhoneID)
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    CPhoneBook *pcPhoneBook;

    MYDBG(("CM_PHBK_DllExport - PhoneBookLoad"));

    if (!g_hInst) g_hInst = GetModuleHandleA(NULL);

    // validate parameters
    MYDBGASSERT(pszISPCode && *pszISPCode && pdwPhoneID);
    *pdwPhoneID = NULL;

    // allocate phone book
    pcPhoneBook = new CPhoneBook;

    // initialize phone book
    if (pcPhoneBook)
        hr = pcPhoneBook->Init(pszISPCode);

    // in case of failure
    if (hr && pcPhoneBook)
    {
        delete pcPhoneBook;
        MYDBG(("PhoneBookLoad() - init failed"));
    } else {
        *pdwPhoneID = (DWORD_PTR)pcPhoneBook;
    }

    return hr;
}

// ############################################################################
DllExportH PhoneBookUnload(DWORD_PTR dwPhoneID)
{
    MYDBG(("CM_PHBK_DllExport - PhoneBookUnload"));

    MYDBGASSERT(dwPhoneID);

    // Release contents
    delete (CPhoneBook*)dwPhoneID;

    return ERROR_SUCCESS;
}

// ############################################################################
DllExportH PhoneBookMergeChanges(DWORD_PTR dwPhoneID, LPCSTR pszChangeFile)
{
    MYDBG(("CM_PHBK_DllExport - PhoneBookMergeChanges"));

    return ((CPhoneBook*)dwPhoneID)->Merge(pszChangeFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\phbk.h ===
//+----------------------------------------------------------------------------
//
// File:     phbk.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Definitions for the CPhoneBook class
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------
#ifndef _PHBK
#define _PHBK

#define DllExportH extern "C" HRESULT WINAPI __stdcall 


//#define DllExport extern "C" __stdcall __declspec(dllexport)
//#define DllExport extern "C" __declspec(dllexport)

#define cbAreaCode	11			// maximum number of characters in an area code, not including \0
#define cbCity 31				// maximum number of chars in city name, not including \0
#define cbAccessNumber 41		// maximum number of chars in phone number, not including \0
#define cbStateName 31 			// maximum number of chars in state name, not including \0
#define cbBaudRate 6			// maximum number of chars in a baud rate, not including \0
#define cbDataCenter (MAX_PATH+1)	// max length of data center string

// Our initial allocation of memory when loading the phone book

#define PHONE_ENTRY_ALLOC_SIZE	500 	

#define NO_AREA_CODE (-1)

#define TEMP_BUFFER_LENGTH 1024

typedef struct
{
	DWORD	dwIndex;								// index number
	BYTE	bFlipFactor;							// for auto-pick
	DWORD	fType;									// phone number type
	WORD	wStateID;								// state ID
	DWORD	dwCountryID;							// TAPI country ID
	DWORD	dwAreaCode;								// area code or NO_AREA_CODE if none
	DWORD	dwConnectSpeedMin;						// minimum baud rate
	DWORD	dwConnectSpeedMax;						// maximum baud rate
	char	szCity[cbCity + sizeof('\0')];			// city name
	char	szAccessNumber[cbAccessNumber + sizeof('\0')];	// access number
	char	szDataCenter[cbDataCenter + sizeof('\0')];				// data center access string
	char	szAreaCode[cbAreaCode + sizeof('\0')];					//Keep the actual area code string around.
} ACCESSENTRY, *PACCESSENTRY; 	// ae

typedef struct {
	DWORD dwCountryID;								// country ID that this state occurred in
	LONG_PTR iFirst;									// index of first access entry for this state
	char szStateName[cbStateName + sizeof('\0')];	// state name
} STATE, *PSTATE;

typedef struct tagIDLOOKUPELEMENT {
	DWORD dwID;
	LPLINECOUNTRYENTRY pLCE;
	LONG_PTR iFirstAE;
} IDLOOKUPELEMENT, *PIDLOOKUPELEMENT;

typedef struct tagCNTRYNAMELOOKUPELEMENT {
	LPSTR psCountryName;
	DWORD dwNameSize;
	LPLINECOUNTRYENTRY pLCE;
} CNTRYNAMELOOKUPELEMENT, *PCNTRYNAMELOOKUPELEMENT;

typedef struct tagCNTRYNAMELOOKUPELEMENTW {
	LPWSTR psCountryName;
	DWORD dwNameSize;
	LPLINECOUNTRYENTRY pLCE;
} CNTRYNAMELOOKUPELEMENTW, *PCNTRYNAMELOOKUPELEMENTW;

typedef struct tagIDXLOOKUPELEMENT {
	DWORD dwIndex;
  	LONG_PTR iAE;
} IDXLOOKUPELEMENT,*PIDXLOOKUPELEMENT;

typedef void (WINAPI *CB_PHONEBOOK)(unsigned int, DWORD_PTR);

//
// CPhoneBook
//

class CPhoneBook
{

public:

	CPhoneBook();
	~CPhoneBook();

	HRESULT Init(LPCSTR pszISPCode);
	HRESULT Merge(LPCSTR pszChangeFilename);
	HRESULT GetCanonical(PACCESSENTRY pAE, char *psOut);
	HRESULT GetNonCanonical(PACCESSENTRY pAE, char *psOut);
	HRESULT GetCanonical(DWORD dwIdx, char *psOut) { return (GetCanonical(&m_rgPhoneBookEntry[dwIdx],psOut)); };
	HRESULT GetNonCanonical(DWORD dwIdx, char *psOut) { return (GetNonCanonical(&m_rgPhoneBookEntry[dwIdx],psOut)); };
	void EnumCountries(DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam);
	void EnumCountries(PPBFS pFilter, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam);
	void EnumRegions(DWORD dwCountryID, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam);
	void EnumRegions(DWORD dwCountryID, PPBFS pFilter, CB_PHONEBOOK pfnCountry, DWORD_PTR dwParam);
	void EnumNumbersByCountry(DWORD dwCountryId, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam);
	void EnumNumbersByCountry(DWORD dwCountryId, PPBFS pFilter, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam);
	void EnumNumbersByRegion(unsigned int nRegion, DWORD dwCountryId, DWORD dwMask, DWORD fType, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam);
	void EnumNumbersByRegion(unsigned int nRegion, DWORD dwCountryId, PPBFS pFilter, CB_PHONEBOOK pfnNumber, DWORD_PTR dwParam);
    BOOL FHasPhoneType(PPBFS pFilter);
	BOOL FHasPhoneNumbers(DWORD dwCountryID, DWORD dwMask, DWORD fType);
	BOOL FHasPhoneNumbers(DWORD dwCountryID, PPBFS pFilter);
	LPCSTR GetCountryNameByIdx(DWORD dwIdx) { return (m_rgNameLookUp[dwIdx].psCountryName); };
	LPCWSTR GetCountryNameByIdxW(DWORD dwIdx) { return (((CNTRYNAMELOOKUPELEMENTW *)(&m_rgNameLookUp[dwIdx]))->psCountryName); };
	DWORD GetCountryIDByIdx(DWORD dwIdx) { return (m_rgNameLookUp[dwIdx].pLCE->dwCountryID); };
	LPCTSTR GetRegionNameByIdx(DWORD dwIdx) { return (m_rgState[dwIdx].szStateName); };
	LPCTSTR GetCityNameByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].szCity); };
	LPCTSTR GetAreaCodeByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].szAreaCode); };
	LPCTSTR GetAccessNumberByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].szAccessNumber); };
	LPCTSTR GetDataCenterByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].szDataCenter); };
	DWORD GetPhoneTypeByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].fType); };
	DWORD GetMinBaudByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].dwConnectSpeedMin); };
	DWORD GetMaxBaudByIdx(DWORD dwIdx) { return (m_rgPhoneBookEntry[dwIdx].dwConnectSpeedMax); };

private:
	ACCESSENTRY				*m_rgPhoneBookEntry;
	DWORD					m_cPhoneBookEntries;
	LINECOUNTRYENTRY		*m_rgLineCountryEntry;
	LINECOUNTRYLIST			*m_pLineCountryList;
	IDLOOKUPELEMENT			*m_rgIDLookUp;
	CNTRYNAMELOOKUPELEMENT	*m_rgNameLookUp;
	PSTATE					m_rgState;
	DWORD					m_cStates;

	char					m_szINFFile[MAX_PATH];
	char					m_szPhoneBook[MAX_PATH];

	BOOL ReadPhoneBookDW(DWORD *pdw, CCSVFile *pcCSVFile);
	BOOL ReadPhoneBookW(WORD *pw, CCSVFile *pcCSVFile);
	BOOL ReadPhoneBookSZ(LPSTR psz, DWORD dwSize, CCSVFile *pcCSVFile);
	BOOL ReadPhoneBookB(BYTE *pb, CCSVFile *pcCSVFile);
	BOOL ReadPhoneBookNL(CCSVFile *pcCSVFile);
	HRESULT ReadOneLine(PACCESSENTRY pAccessEntry, CCSVFile *pcCSVFile);

	PACCESSENTRY IdxToPAE(LONG_PTR iIdx) { return ((iIdx==0)?NULL:(m_rgPhoneBookEntry+(iIdx-1))); };
	LONG_PTR PAEToIdx(PACCESSENTRY pAE) { return ((pAE==NULL)?0:((pAE-m_rgPhoneBookEntry)+1)); };

};

extern HINSTANCE g_hInst;	// instance for this DLL

#endif // _PHBK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmpbk\qsort.cpp ===
//+----------------------------------------------------------------------------
//
// File:     qsort.cpp
//
// Module:   CMPBK32.DLL
//
// Synopsis: Quick Sort Implementation (taken from libc)
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:	 quintinb   created header      08/17/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

/* prototypes for local routines */
static void __cdecl shortsort(char *lo, char *hi, unsigned width,
                int (__cdecl *comp)(const void *, const void *));
static void __cdecl swap(char *p, char *q, unsigned int width);

/* this parameter defines the cutoff between using quick sort and
   insertion sort for arrays; arrays with lengths shorter or equal to the
   below value use insertion sort */

#define CUTOFF 8            /* testing shows that this is good value */


/***
*qsort(base, num, wid, comp) - quicksort function for sorting arrays
*
*Purpose:
*       quicksort the array of elements
*       side effects:  sorts in place
*
*Entry:
*       char *base = pointer to base of array
*       unsigned num  = number of elements in the array
*       unsigned width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

/* sort the array between lo and hi (inclusive) */

void __cdecl CmQSort (
    void *base,
    unsigned num,
    unsigned width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *lo, *hi;              /* ends of sub-array currently sorting */
    char *mid;                  /* points to middle of subarray */
    char *loguy, *higuy;        /* traveling pointers for partition step */
    unsigned size;              /* size of the sub-array */
    char *lostk[30], *histk[30];
    int stkptr;                 /* stack for saving sub-array to be processed */

    /* Note: the number of stack entries required is no more than
       1 + log2(size), so 30 is sufficient for any array */

    if (num < 2 || width == 0)
        return;                 /* nothing to do */

    stkptr = 0;                 /* initialize stack */

    lo = (char *)base;
    hi = (char *)base + width * (num-1);        /* initialize limits */

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       prserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = PtrToUlong((PVOID)(hi - lo)) / width + 1;        /* number of el's to sort */

    /* below a certain size, it is faster to use a O(n^2) sorting method */
    if (size <= CUTOFF) {
         shortsort(lo, hi, width, comp);
    }
    else {
        /* First we pick a partititioning element.  The efficiency of the
           algorithm demands that we find one that is approximately the
           median of the values, but also that we select one fast.  Using
           the first one produces bad performace if the array is already
           sorted, so we use the middle one, which would require a very
           wierdly arranged array for worst case performance.  Testing shows
           that a median-of-three algorithm does not, in general, increase
           performance. */

        mid = lo + (size / 2) * width;      /* find middle element */
        swap(mid, lo, width);               /* swap it to beginning of array */

        /* We now wish to partition the array into three pieces, one
           consisiting of elements <= partition element, one of elements
           equal to the parition element, and one of element >= to it.  This
           is done below; comments indicate conditions established at every
           step. */

        loguy = lo;
        higuy = hi + width;

        /* Note that higuy decreases and loguy increases on every iteration,
           so loop must terminate. */
        for (;;) {
            /* lo <= loguy < hi, lo < higuy <= hi + 1,
               A[i] <= A[lo] for lo <= i <= loguy,
               A[i] >= A[lo] for higuy <= i <= hi */

            do  {
                loguy += width;
            } while (loguy <= hi && comp(loguy, lo) <= 0);

            /* lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
               either loguy > hi or A[loguy] > A[lo] */

            do  {
                higuy -= width;
            } while (higuy > lo && comp(higuy, lo) >= 0);

            /* lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
               either higuy <= lo or A[higuy] < A[lo] */

            if (higuy < loguy)
                break;

            /* if loguy > hi or higuy <= lo, then we would have exited, so
               A[loguy] > A[lo], A[higuy] < A[lo],
               loguy < hi, highy > lo */

            swap(loguy, higuy, width);

            /* A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
               of loop is re-established */
        }

        /*     A[i] >= A[lo] for higuy < i <= hi,
               A[i] <= A[lo] for lo <= i < loguy,
               higuy < loguy, lo <= higuy <= hi
           implying:
               A[i] >= A[lo] for loguy <= i <= hi,
               A[i] <= A[lo] for lo <= i <= higuy,
               A[i] = A[lo] for higuy < i < loguy */

        swap(lo, higuy, width);     /* put partition element in place */

        /* OK, now we have the following:
              A[i] >= A[higuy] for loguy <= i <= hi,
              A[i] <= A[higuy] for lo <= i < higuy
              A[i] = A[lo] for higuy <= i < loguy    */

        /* We've finished the partition, now we want to sort the subarrays
           [lo, higuy-1] and [loguy, hi].
           We do the smaller one first to minimize stack usage.
           We only sort arrays of length 2 or more.*/

        if ( higuy - 1 - lo >= hi - loguy ) {
            if (lo + width < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - width;
                ++stkptr;
            }                           /* save big recursion for later */

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           /* do small recursion */
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               /* save big recursion for later */
            }

            if (lo + width < higuy) {
                hi = higuy - width;
                goto recurse;           /* do small recursion */
            }
        }
    }

    /* We have sorted the array, except for any pending sorts on the stack.
       Check if there are any, and do them. */

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           /* pop subarray from stack */
    }
    else
        return;                 /* all subarrays done */
}


/***
*shortsort(hi, lo, width, comp) - insertion sort for sorting short arrays
*
*Purpose:
*       sorts the sub-array of elements between lo and hi (inclusive)
*       side effects:  sorts in place
*       assumes that lo < hi
*
*Entry:
*       char *lo = pointer to low element to sort
*       char *hi = pointer to high element to sort
*       unsigned width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl shortsort (
    char *lo,
    char *hi,
    unsigned width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (comp(p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/***
*swap(a, b, width) - swap two elements
*
*Purpose:
*       swaps the two array elements of size width
*
*Entry:
*       char *a, *b = pointer to two elements to swap
*       unsigned width = width in bytes of each array element
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl swap (
    char *a,
    char *b,
    unsigned width
    )
{
    char tmp;

    if ( a != b )
        /* Do the swap one character at a time to avoid potential alignment
           problems. */
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsecure\cmsecure.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmsecure.cpp
//
// Module:   CMSECURE.LIB
//
// Synopsis: CM Crypto APIs
//           Three methods are support for decryption:
//              CBCEncryption         CMSECURE_ET_CBC_CIPHER
//              Simple xor encryption CMSECURE_ET_STREAM_CIPHER
//              CryptoApi             CMSECURE_ET_RC2
//           Two methods are supported for encryption
//              CBCEncryption
//              CryptoApi
//
//           CBCEncryption algorithm: Cipher Block Chaining Mode with initializing variable
//                EnCipher: C[i] = E[k](p[i] XOR C[i-1])
//                DeCipher: P[i] = C[i-1] XOR D[k](C[i])
//                   P: Plain text
//                   C: Cipher text
//                   E[k]: Encryption function with key
//                   D[k]: Decryption function with key
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   henryt     created                         05/21/97
//           fengsun    changed encryption algorithm    08/21/97
//
//+----------------------------------------------------------------------------
#include "cryptfnc.h"
#include "userinfo_str.h"

//////////////////////////////////////////////////////////////////////////
// defines
//////////////////////////////////////////////////////////////////////////

// we want 40-bit encryption exactly for pre-shared key
const DWORD c_dwEncryptKeyLength = 40;

//
// the max len for the const string for session key generation
//
#define MAX_KEY_STRING_LEN                      40
#define EXTRA_UUDECODE_BUF_LEN                  10

//////////////////////////////////////////////////////////////////////////
// Globals
//////////////////////////////////////////////////////////////////////////

static CCryptFunctions*  g_pCryptFnc = NULL;
static long g_nRefCount=0;   // the reference count, CryptoApi is unloaded when the count is 0
static BOOL g_fFastEncryption;

//
// the const string for session key generation
//
static const TCHAR gc_szKeyStr[] = TEXT("Please enter your password");

//////////////////////////////////////////////////////////////////////////
// Func prototypes
//////////////////////////////////////////////////////////////////////////

static int CBCEncipherData(const char* pszKey, const BYTE* pbData, int dwDataLength, 
                       BYTE* pbOut, int dwOutBufferLength);
static int CBCDecipherData(const char* pszKey, const BYTE* pbData, int dwDataLength, 
                       BYTE* pbOut, int dwOutBufferLength);
inline int CBCDecipherBufferSize(int dataSize);
inline int CBCEncipherBufferSize(int dataSize);


static BOOL 
StreamCipherEncryptData(
    LPTSTR          pszKey,              // password    
    LPBYTE          pbData,              // Data to be encrypted
    DWORD           dwDataLength,        // Length of data in bytes
    LPBYTE          *ppbEncryptedData,     // Encrypted secret key will be stored here
    DWORD           *pdwEncryptedBufferLen, // Length of this buffer
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree
);

static BOOL 
StreamCipherDecryptData(
    LPTSTR          pszKey,              // password    
    LPBYTE          pbEncryptedData,     // Encrypted data
    DWORD           dwEncrytedDataLen,   // Length of encrypted data
    LPBYTE          *ppbData,            // Decrypted Data will be stored here
    DWORD           *pdwDataBufferLength,// Length of the above buffer in bytes
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree,
    DWORD           dwEncryptionType
);

static LPTSTR 
reverse(
    LPTSTR  s
);

static void
GenerateKeyString(
    IN OUT  LPTSTR  pszBuf,
    IN      DWORD   dwBufLen
);

static BOOL SetKeyString(IN OUT  LPTSTR  pszBuf, IN DWORD dwBufLen, IN DWORD dwEncryptionType,
                         IN  PFN_CMSECUREALLOC  pfnAlloc,
                         IN  PFN_CMSECUREFREE   pfnFree,
                         IN LPSTR pszUserKey,
                         OUT BOOL *pfMoreSecure);

static BOOL GetKeyString(IN OUT  LPTSTR  pszBuf, IN DWORD * pdwBufLen, IN DWORD dwEncryptionType, 
                         IN  PFN_CMSECUREALLOC  pfnAlloc,
                         IN  PFN_CMSECUREFREE   pfnFree,
                         IN LPSTR pszUserKey,
                         OUT BOOL *pfMoreSecure);

static BOOL GetCurrentKey(PTCHAR szTempKeyStr, DWORD dwTempKeyStrMaxLen, 
                   IN  PFN_CMSECUREALLOC  pfnAlloc,
                   IN  PFN_CMSECUREFREE   pfnFree);

//////////////////////////////////////////////////////////////////////////
// Implementations
//////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   InitCryptoApi
//
//  Synopsis:   Initialize the CryptoApi.
//
//  Arguments:  
//
//  Returns:    Pointer to  CCryptFunctions, if success
//              NULL if failure
//
//  History:    fengsun Created     8/22/97
//
//----------------------------------------------------------------------------

static CCryptFunctions* InitCryptoApi()
{
    CCryptFunctions* pCryptFnc = new CCryptFunctions();

    if (pCryptFnc == NULL)
        return NULL;

    if (pCryptFnc->InitCrypt()) 
    {
        return pCryptFnc;
    }
    else
    {
        delete pCryptFnc;
        return NULL;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   InitSecure
//
//  Synopsis:   Initialize the security/encryption routines.
//
//  Arguments:  fFastEncryption : TRUE will use a faster algorithm vs a more secure one
//
//  Returns:    TRUE if success, always return TRUE
//              FALSE if failure
//
//  History:    henryt  Created     5/20/97
//              fengsun modified 
//
//----------------------------------------------------------------------------

BOOL
InitSecure(
    BOOL fFastEncryption
)
{
    MYDBGASSERT(g_nRefCount>=0);
    InterlockedIncrement(&g_nRefCount);

    //
    // If already initialized, increase the RefCount and return
    //
    if (g_nRefCount>1)
    {
        return TRUE;
    }

    MYDBGASSERT(g_pCryptFnc == NULL); // not initialized yet

    g_fFastEncryption = fFastEncryption;

    if (!fFastEncryption)
    {
        //
        // CryptoApi is slow on Win95
        // If more secure is desired, try the CryptoApi
        // Ignore return value of InitCrypt()
        //
        g_pCryptFnc = InitCryptoApi();
    }

    //
    // CryptoApi is not available for Win95 Gold
    // we'll use stream cipher.
    //

    return TRUE; 
}



//+---------------------------------------------------------------------------
//
//  Function:   DeInitSecure
//
//  Synopsis:   Clean up function for the security/encryption routines.
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    henryt  Created     5/20/97
//
//----------------------------------------------------------------------------

void
DeInitSecure(
    void
)
{
    MYDBGASSERT(g_nRefCount>=1);

    //
    // DeInit the CryptoApi if RefCount is down to 0
    //
    if (InterlockedDecrement(&g_nRefCount) <=0)    // if ( (--g_nRefCount) <=0 )
    {
        if (g_pCryptFnc)
        {
            delete g_pCryptFnc;
            g_pCryptFnc = NULL;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   StreamCipherEncryptData
//
//  Synopsis:   data encryption using stream cipher algorithm.
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    henryt  Created     6/9/97
//              fengsun modified    8/21/97 
//                                  to use Cipher Block Chaning Mode Algorithm
//
//----------------------------------------------------------------------------

static BOOL 
StreamCipherEncryptData(
    LPTSTR          pszKey,              // password    
    LPBYTE          pbData,              // Data to be encrypted
    DWORD           dwDataLength,        // Length of data in bytes
    LPBYTE          *ppbEncryptedData,     // Encrypted secret key will be stored here
    DWORD           *pdwEncryptedBufferLen, // Length of this buffer
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree
)
{

    LPBYTE  pbTmpBuf = NULL;
    BOOL    fOk = FALSE;
    BOOL    fRet;

    if (!pszKey || !pbData || !dwDataLength || !ppbEncryptedData || !pdwEncryptedBufferLen)
    {
        CMASSERTMSG(FALSE, TEXT("StreamCipherEncryptData - invalid input params"));
        return FALSE;
    }

    //
    // Alloc a buffer to hold enciphered data
    //
    DWORD dwEncipherBufferLen = CBCEncipherBufferSize(dwDataLength);

    if (pfnAlloc)
    {
        pbTmpBuf = (LPBYTE)pfnAlloc(dwEncipherBufferLen);
    }
    else
    {
        pbTmpBuf = (LPBYTE)HeapAlloc(GetProcessHeap(), 
                                     HEAP_ZERO_MEMORY,
                                     dwEncipherBufferLen);
    }
    if (!pbTmpBuf)
    {
        goto cleanup;
    }


    //
    // encipher the data
    //

    dwEncipherBufferLen = CBCEncipherData(pszKey, pbData, dwDataLength, pbTmpBuf, dwEncipherBufferLen);

    //
    // we now have the data encrypted.  we need to uuencode it.
    //
    DWORD   cbBuf;
    cbBuf = 2*dwEncipherBufferLen + EXTRA_UUDECODE_BUF_LEN;     // enough for uuencode

    if (pfnAlloc)
    {
        *ppbEncryptedData = (LPBYTE)pfnAlloc(cbBuf);
    }
    else
    {
        *ppbEncryptedData = (LPBYTE)HeapAlloc(GetProcessHeap(), 
                                              HEAP_ZERO_MEMORY,
                                              cbBuf);
    }
    if (!*ppbEncryptedData)
    {
        goto cleanup;
    }

    
    fRet = uuencode(pbTmpBuf, dwEncipherBufferLen, (CHAR*)*ppbEncryptedData, cbBuf);

    MYDBGASSERT(fRet);

    if (!fRet)
    {
        if (pfnFree)
        {
            pfnFree(*ppbEncryptedData);
        }
        else
        {
            HeapFree(GetProcessHeap(), 0, *ppbEncryptedData);
        }
        *ppbEncryptedData = NULL;

        goto cleanup;
    }

    //
    // set the encrypted buffer len
    //
    *pdwEncryptedBufferLen = lstrlen((LPSTR)*ppbEncryptedData);

    fOk = TRUE;

cleanup:
    if (pbTmpBuf)
    {
        if (pfnFree)
        {
            pfnFree(pbTmpBuf);
        }
        else
        {
            HeapFree(GetProcessHeap(), 0, pbTmpBuf);
        }
    }

    return fOk;
}



//+---------------------------------------------------------------------------
//
//  Function:   StreamCipherDecryptData
//
//  Synopsis:   data decryption using stream cipher algorithm.
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//  History:    henryt  Created     6/9/97
//              fengsun modified    8/21/97 
//                                  to use Cipher Block Chaning Modem Algorithm
//
//----------------------------------------------------------------------------

static BOOL 
StreamCipherDecryptData(
    LPTSTR          pszKey,              // password    
    LPBYTE          pbEncryptedData,     // Encrypted data
    DWORD           dwEncryptedDataLen,   // Length of encrypted data
    LPBYTE          *ppbData,            // Decrypted Data will be stored here
    DWORD           *pdwDataBufferLength,// Length of the above buffer in bytes
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree,
    DWORD           dwEncryptionType
)
{
    BOOL    fRet = FALSE;
    DWORD   dwUUDecodeBufLen;

    if (!pszKey || !pbEncryptedData || !dwEncryptedDataLen || !pdwDataBufferLength)
    {
        CMASSERTMSG(FALSE, TEXT("StreamCipherDecryptData - invalid input params"));
        return FALSE;
    }

    //
    // set uudecode output buf size
    //
    dwUUDecodeBufLen = dwEncryptedDataLen + EXTRA_UUDECODE_BUF_LEN;

    //
    // alloc memory for output buffer
    //
    if (pfnAlloc)
    {
        *ppbData = (LPBYTE)pfnAlloc(dwUUDecodeBufLen);
    }
    else
    {
        *ppbData = (LPBYTE)HeapAlloc(GetProcessHeap(),
                                     HEAP_ZERO_MEMORY,
                                     dwUUDecodeBufLen);
    }
    if (!*ppbData)
    {
        goto cleanup;
    }

    //
    // uudecode it first
    //

    fRet = uudecode((char*)pbEncryptedData, (CHAR*)*ppbData, &dwUUDecodeBufLen);

    MYDBGASSERT(fRet);

    if (!fRet)
    {
        if (pfnFree)
        {
            pfnFree(*ppbData);
        }
        else
        {
            HeapFree(GetProcessHeap(), 0, *ppbData);
        }
        *ppbData = NULL;

        goto cleanup;
    }

    switch(dwEncryptionType)
    {
    case CMSECURE_ET_STREAM_CIPHER:
        {
            //
            //  Simple decipher algorithm used in old version
            //

            DWORD   dwLen = lstrlen(pszKey);

            if (dwLen)
            {
                for (DWORD dwIdx = 0; dwIdx < dwUUDecodeBufLen; dwIdx++)
                {
                    *(*ppbData + dwIdx) ^= pszKey[dwIdx % dwLen];
                }

                *pdwDataBufferLength = dwUUDecodeBufLen;

                fRet = TRUE;
            }
        }
        break;

    case CMSECURE_ET_CBC_CIPHER:
        //
        // Inplace decipher  
        //
        *pdwDataBufferLength = CBCDecipherData(pszKey, *ppbData, dwUUDecodeBufLen, 
                                            *ppbData, dwUUDecodeBufLen);
        fRet = TRUE;

        break;
    default:
        MYDBGASSERT(FALSE);
    }

cleanup:
    return fRet;
}



//+---------------------------------------------------------------------------
//
//  Function:   EncryptData
//
//  Synopsis:   Encrypt the data buffer.
//
//  Arguments:  IN  PBYTE   pbData,                 // Data to be encrypted                    
//              IN  DWORD   dwDataLength,           // Length of data in bytes                 
//              OUT PBYTE   pbEncryptedData,        // Encrypted secret key will be stored here
//              OUT DWORD   *pdwEncrytedBufferLen   // Length of this buffer                   
//              IN  PCMSECUREALLOC  pfnAlloc        // memory allocator(if NULL, then the default is used.   
//                                                  //      Win32 - HeapAlloc(GetProcessHeap(), ...)         
//              IN  PCMSECUREFREE   pfnFree         // memory deallocator(if NULL, then the default is used. 
//                                                  //      Win32 - HeapFree(GetProcessHeap(), ...)          
//              IN  LPTSTR  pszUserKey              // Reg key where to store encrypted key
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    henryt  Created     5/20/97
//
//----------------------------------------------------------------------------

BOOL
EncryptData(
    IN  LPBYTE  pbData,                 // Data to be encrypted
    IN  DWORD   dwDataLength,           // Length of data in bytes
    OUT LPBYTE  *ppbEncryptedData,      // Encrypted secret key will be stored here
    OUT LPDWORD pdwEncrytedBufferLen,  // Length of this buffer
    OUT LPDWORD pEncryptionType,        // type of the encryption used
    IN  PFN_CMSECUREALLOC  pfnAlloc,
    IN  PFN_CMSECUREFREE   pfnFree,
    IN  LPSTR   pszUserKey
)
{
    BOOL    fOk = FALSE;
    TCHAR   szKeyStr[MAX_KEY_STRING_LEN + 1]={0};
    BOOL    fMoreSecure = FALSE;

    DWORD dwUseKey = *pEncryptionType;

    //
    // get a key string for session key generation
    //
    SetKeyString(szKeyStr, MAX_KEY_STRING_LEN, dwUseKey, pfnAlloc, pfnFree, pszUserKey, &fMoreSecure);

    *pEncryptionType = CMSECURE_ET_NOT_ENCRYPTED;
   
    //
    // If user want use CryptoApi and it is available
    //
    if (!g_fFastEncryption && g_pCryptFnc)
    {
        //
        // encrypt the data with the key string
        //
        if (fOk = g_pCryptFnc->EncryptDataWithKey(
            szKeyStr,                       // Key
            pbData,                         // Secret key
            dwDataLength,                   // Length of secret key
            ppbEncryptedData,               // Encrypted data will be stored here
            pdwEncrytedBufferLen,           // Length of this buffer
            pfnAlloc,                       // mem allocator
            pfnFree,                        // mem deallocator
            0))                             // not specifying keylength
        {
            *pEncryptionType = CMSECURE_ET_RC2;

            //
            // If the key is randomly generated then we want to make sure we 
            // set the random key mask
            //
            if (fMoreSecure)
            {
                *pEncryptionType |= CMSECURE_ET_RANDOM_KEY_MASK;
            }
        }
    }

    if (!fOk)
    {
        if (fOk = StreamCipherEncryptData(
            szKeyStr,                       // Key
            pbData,                         // Secret key
            dwDataLength,                   // Length of secret key
            ppbEncryptedData,               // Encrypted data will be stored here
            pdwEncrytedBufferLen,           // Length of this buffer
            pfnAlloc,                       // mem allocator
            pfnFree))                       // mem deallocator
        {
            *pEncryptionType = CMSECURE_ET_CBC_CIPHER;
            
            //
            // If the key is randomly generated then we want to make sure we 
            // set the random key mask
            //
            if (fMoreSecure)
            {
                *pEncryptionType |= CMSECURE_ET_RANDOM_KEY_MASK;
            }
        }
    }

    ZeroMemory((LPVOID)szKeyStr, sizeof(szKeyStr));

    return fOk;
}


//+---------------------------------------------------------------------------
//
//  Function:   DecryptData
//
//  Synopsis:   Decrypt the data buffer.
//
//  Arguments:  IN  PBYTE   pbEncryptedData,        // Encrypted data                      
//              IN  DWORD   dwEncrytedDataLen       // Length of encrypted data            
//              OUT PBYTE   *ppbData,               // Decrypted Data will be stored here  
//              OUT DWORD   *pdwDataBufferLength,   // Length of the above buffer in bytes 
//              IN  PCMSECUREALLOC  pfnAlloc        // memory allocator(if NULL, then the default is used.   
//                                                  //      Win32 - HeapAlloc(GetProcessHeap(), ...)         
//              IN  PCMSECUREFREE   pfnFree         // memory deallocator(if NULL, then the default is used. 
//                                                  //      Win32 - HeapFree(GetProcessHeap(), ...)          
//              IN  LPTSTR  pszUserKey              // Reg key where to store encrypted key
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    henryt  Created     5/20/97
//
//----------------------------------------------------------------------------

BOOL
DecryptData(
    IN  LPBYTE          pbEncryptedData,        // Encrypted data
    IN  DWORD           dwEncrytedDataLen,      // Length of encrypted data
    OUT LPBYTE          *ppbData,               // Decrypted Data will be stored here
    OUT LPDWORD         pdwDataBufferLength,    // Length of the above buffer in bytes
    IN  DWORD           dwEncryptionType,       // encryption type for decryption
    IN  PFN_CMSECUREALLOC  pfnAlloc,
    IN  PFN_CMSECUREFREE   pfnFree,
    IN  LPSTR           pszUserKey
)
{
    TCHAR   szKeyStr[MAX_KEY_STRING_LEN + 1]={0}; // Plus NULL
    DWORD   dwRet = 0xf;        // some non-zero value
    BOOL fMoreSecure = FALSE;

    //
    // To speed things up we only want to generate a key
    // in case the data is encrypted
    //
    if (CMSECURE_ET_NOT_ENCRYPTED != dwEncryptionType)
    {
        //
        // get a key string for session key generation
        //

        //
        // Here we don't care if the pszUserKey is NULL, the called function will determine
        // this and set fMoreSecure appropriately. Right now we don't check for the random key mask 
        // in dwEncryptionType, but if it isn't set the blob (encrypted key) will not be in the registry 
        // thus it will try to default to using the hardcoded key. This should probably be made more explicit
        // in the code at a later time.
        //
        DWORD dwMaxSize = MAX_KEY_STRING_LEN;
        GetKeyString(szKeyStr, &dwMaxSize, dwEncryptionType, pfnAlloc, pfnFree, pszUserKey, &fMoreSecure);
    
        //
        // If the random key bit mask is set, we better have have fMoreSecure flag set to true.
        // This has to be always true in order for decryption to work
        // 
        CMASSERTMSG(((dwEncryptionType & CMSECURE_ET_RANDOM_KEY_MASK) && fMoreSecure), TEXT("DecryptData - Trying to use mismatched keys"));
    }

    // 
    // Clear the random key mask 
    //
    dwEncryptionType &= ~CMSECURE_ET_RANDOM_KEY_MASK;
    dwEncryptionType &= ~CMSECURE_ET_USE_SECOND_RND_KEY;

    switch (dwEncryptionType)
    {
        case CMSECURE_ET_RC2:
            if (g_fFastEncryption && !g_pCryptFnc)
            {
                //
                // if we want fast encryption initially,
                // We have to initialize the CryptoApi now
                //
                g_pCryptFnc = InitCryptoApi();
            }

            if (g_pCryptFnc)
            {
                dwRet = g_pCryptFnc->DecryptDataWithKey(
                            szKeyStr,                // Key
                            pbEncryptedData,         // Encrypted data
                            dwEncrytedDataLen,       // Length of encrypted data
                            ppbData,                 // decrypted data
                            pdwDataBufferLength,     // Length of decrypted data
                            pfnAlloc,                // mem allocator
                            pfnFree,                 // mem deallocator
                            0);                      // not specifying keylength
                            
            }
            break;

        case CMSECURE_ET_STREAM_CIPHER:
        case CMSECURE_ET_CBC_CIPHER:
            //
            // Use our own encryption algorithm
            //
            dwRet = (DWORD)!StreamCipherDecryptData(
                        szKeyStr,                // Key
                        pbEncryptedData,         // Encrypted data
                        dwEncrytedDataLen,       // Length of encrypted data
                        ppbData,                 // decrypted data
                        pdwDataBufferLength,     // Length of decrypted data
                        pfnAlloc,                // mem allocator
                        pfnFree,                 // mem deallocator
                        dwEncryptionType         // Encryption type used
                        );
            break;

        case CMSECURE_ET_NOT_ENCRYPTED:
            // 
            // Just copy the exact contents into the OUT buffer
            //
            if (pbEncryptedData && dwEncrytedDataLen && 
                ppbData && pdwDataBufferLength)
            {
                if (pfnAlloc)
                {
                    *ppbData = (LPBYTE)pfnAlloc(dwEncrytedDataLen);
                }
                else
                {
                    *ppbData = (LPBYTE)HeapAlloc(GetProcessHeap(), 
                                                 HEAP_ZERO_MEMORY,
                                                 dwEncrytedDataLen);
                }
                
                if (*ppbData)
                {
                    CopyMemory(*ppbData, pbEncryptedData, dwEncrytedDataLen);
                    *pdwDataBufferLength = dwEncrytedDataLen;
                    dwRet = 0; // the return statement correctly returns TRUE 
                }
            }

            break;

        default:
            MYDBGASSERT(FALSE);
            break;
    }
    
    ZeroMemory((LPVOID)szKeyStr, sizeof(szKeyStr));

    return (!dwRet);
}


//+----------------------------------------------------------------------------
//
// Func:    EncryptString
//
// Desc:    encrypt a given (Ansi) string using RC2 encryption
//
// Args:    pszToEncrypt         -- Ansi string to be encrypted
//          pszUserKey           -- Key to use for Encryption
//          ppbEncryptedData     -- Encrypted secret key will be stored here(memory will be allocated)
//          pdwEncrytedBufferLen -- Length of this buffer
//
// Return:  BOOL (FALSE if a fatal error occurred, else TRUE)
//
// Notes:   The encryption type must be at least RC2, and exactly 40-bit
//
//-----------------------------------------------------------------------------
BOOL
EncryptString(
    IN  LPSTR           pszToEncrypt,           // Ansi string to be encrypted
    IN  LPSTR           pszUserKey,             // Key to use for Encryption
    OUT LPBYTE *        ppbEncryptedData,       // Encrypted secret key will be stored here(memory will be allocated)
    OUT LPDWORD         pdwEncrytedBufferLen,   // Length of this buffer
    IN  PFN_CMSECUREALLOC  pfnAlloc,
    IN  PFN_CMSECUREFREE   pfnFree
)
{
    BOOL fOk = FALSE;

    CMASSERTMSG(pszToEncrypt, TEXT("EncryptData - first arg must be a valid string"));
    CMASSERTMSG(pszUserKey,  TEXT("EncryptData - second arg must be a valid user key"));

    DWORD dwDataLength = lstrlen(pszToEncrypt) + 1; // get the NULL in as well.

    if (!g_fFastEncryption && g_pCryptFnc)
    {
        if (fOk = g_pCryptFnc->EncryptDataWithKey(
            pszUserKey,                     // Key
            (LPBYTE)pszToEncrypt,           // Secret key
            dwDataLength,                   // Length of secret key
            ppbEncryptedData,               // Encrypted data will be stored here
            pdwEncrytedBufferLen,           // Length of this buffer
            pfnAlloc,
            pfnFree,
            c_dwEncryptKeyLength))
        {
            CMTRACE(TEXT("EncryptString - succeeded."));
        }
    }

    return fOk;
}


//+----------------------------------------------------------------------------
//
// Func:    DecryptString
//
// Desc:    encrypt a given (Ansi) string using RC2 encryption
//
// Args:    pszToEncrypt         -- Ansi string to be encrypted
//          pszUserKey           -- Key to use for Encryption
//          ppbEncryptedData     -- Encrypted secret key will be stored here(memory will be allocated)
//          pdwEncrytedBufferLen -- Length of this buffer
//
// Return:  BOOL (FALSE if a fatal error occurred, else TRUE)
//
// Notes:   The encryption type must be at least RC2, and exactly 40-bit
//
//-----------------------------------------------------------------------------
BOOL
DecryptString(
    IN  LPBYTE          pbEncryptedData,        // Encrypted data
    IN  DWORD           dwEncrytedDataLen,      // Length of encrypted data
    IN  LPSTR           pszUserKey,             // Registry key to store encrypted key for passwords
    OUT LPBYTE *        ppbData,                // Decrypted Data will be stored here
    OUT LPDWORD         pdwDataBufferLength,    // Length of the above buffer in bytes
    IN  PFN_CMSECUREALLOC  pfnAlloc,
    IN  PFN_CMSECUREFREE   pfnFree

)
{
    DWORD   dwRet = 0xf;        // some non-zero value

    if (!g_fFastEncryption && g_pCryptFnc)
    {
        dwRet = g_pCryptFnc->DecryptDataWithKey(
                    pszUserKey,              // Key
                    pbEncryptedData,         // Encrypted data
                    dwEncrytedDataLen,       // Length of encrypted data
                    ppbData,                 // decrypted data
                    pdwDataBufferLength,     // Length of decrypted data
                    pfnAlloc,
                    pfnFree,
                    c_dwEncryptKeyLength);   // 40-bit
    }

    return (!dwRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   CBCEncipherBufferSize
//
//  Synopsis:   Get the buffer size needed for Enciphering
//
//  Arguments:  dataSize sizeof data to be enciphered
//
//  Returns:    Encipher buffer size needed
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------

inline int CBCEncipherBufferSize(int dataSize)
{
    MYDBGASSERT(dataSize > 0);    

    //
    // We need one byte to hold the initializing variable
    //

    return dataSize + 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBCDecipherBufferSize
//
//  Synopsis:   Get the buffer size needed for Deciphering
//
//  Arguments:  dataSize sizeof data to be Deciphered
//
//  Returns:    Decipher buffer size needed
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------
inline int CBCDecipherBufferSize(int dataSize)
{
    MYDBGASSERT(dataSize > 1);    
    return dataSize - 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   EncryptByte
//
//  Synopsis:   Encrypt a single byte
//
//  Arguments:  pszKey  key string
//              byteSource byte to be encrypted
//              param   aditional parameter for encryption
//
//  Returns:    byte encrypted
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------

inline BYTE EncryptByte(LPCTSTR pszKey, BYTE byteSource, BYTE Param)
{
    if (NULL == pszKey)
    {
        return NULL;
    }

    DWORD   dwLen = lstrlen(pszKey);

    if (0 == dwLen)
    {
        return NULL;
    }

    return ((byteSource ^ (BYTE)pszKey[Param % dwLen]) + Param);
}

//+---------------------------------------------------------------------------
//
//  Function:   DecryptByte
//
//  Synopsis:   Decrypt a single byte
//
//  Arguments:  pszKey  key string
//              byteSource byte to be Decrypted
//              param   aditional parameter for encryption
//
//  Returns:    byte decrypted
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------

inline BYTE DecryptByte(LPCTSTR pszKey, BYTE byteSource, BYTE Param)
{
    if (NULL == pszKey)
    {
        return NULL;
    }

    DWORD   dwLen = lstrlen(pszKey);

    if (0 == dwLen)
    {
        return NULL;
    }

    return ((byteSource - Param) ^ (BYTE)pszKey[Param % dwLen]);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBCEncipherData
//
//  Synopsis:   Encipher a block of data
//
//  Arguments:  pszKey  key string
//              pbData  Data to be enciphered
//              dwDataLength size of pbData
//              pbOut   Buffer for encipher result
//              dwOutBufferLength size of pbOut, must be >= CBCEncipherBufferSize(dwDataLength)
//
//  Returns:    size of encipher byte in pbOut, 0 means failed
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------
static int CBCEncipherData(const char* pszKey, const BYTE* pbData, int dwDataLength, 
                       BYTE* pbOut, int dwOutBufferLength)
{
    MYDBGASSERT(pszKey != NULL);    
    MYDBGASSERT(pbData != NULL);    
    MYDBGASSERT(pbOut != NULL);    
    MYDBGASSERT(dwDataLength > 0);    
    MYDBGASSERT(pbData != pbOut);

    if (dwDataLength <= 0)
        return 0;

    if (dwOutBufferLength < CBCEncipherBufferSize(dwDataLength))
        return 0;

    dwOutBufferLength = CBCEncipherBufferSize(dwDataLength);

    //
    // Add a random number as the initializing variable (first byte)
    //
    pbOut[0] = (BYTE)((GetTickCount() >> 4 ) % 256);


    //
    // encipher it
    //
    // EnCipher: C[i] = E[k](p[i] XOR C[i-1])
    //

    BYTE lastPlainText = pbOut[0];   //first initilizing byte
    pbOut[0] = EncryptByte(pszKey, pbOut[0], 0);
    for (int dwIdx=1; dwIdx<dwOutBufferLength; dwIdx++)
    {
        pbOut[dwIdx] = EncryptByte(pszKey, pbData[dwIdx-1]^pbOut[dwIdx-1], lastPlainText);
        lastPlainText = pbData[dwIdx-1];
    }

    return dwOutBufferLength;

}

//+---------------------------------------------------------------------------
//
//  Function:   CBCDecipherData
//
//  Synopsis:   Decipher a block of data,  inplace deciper is supported
//
//  Arguments:  pszKey  key string
//              pbData  Data to be Deciphered
//              dwDataLength size of pbData
//              pbOut   Buffer for decipher result
//              dwOutBufferLength size of pbOut, must be >= CBCDecipherBufferSize(dwDataLength)
//
//  Returns:    size of decipher byte in pbOut, 0 means failed
//
//  History:    fengsun Created     8/21/97
//
//----------------------------------------------------------------------------
static int CBCDecipherData(const char* pszKey, const BYTE* pbData, int dwDataLength, 
                       BYTE* pbOut, int dwOutBufferLength)
{
    MYDBGASSERT(pszKey != NULL);    
    MYDBGASSERT(pbData != NULL);    
    MYDBGASSERT(pbOut != NULL);    
    MYDBGASSERT(dwDataLength > 1);    

    if (dwDataLength <= 1)
        return 0;

    if (dwOutBufferLength < CBCDecipherBufferSize(dwDataLength))
        return 0;

    dwOutBufferLength = CBCDecipherBufferSize(dwDataLength);

    //
    // decipher data
    //
    // DeCipher: P[i] = C[i-1] XOR D[k](C[i]), 
    //
    
    BYTE lastPlainText = DecryptByte(pszKey, pbData[0], 0);   //first initilizing byte
    for (int dwIdx=0; dwIdx<dwOutBufferLength; dwIdx++)
    {
        pbOut[dwIdx] = pbData[dwIdx] ^ DecryptByte(pszKey, pbData[dwIdx+1], lastPlainText);
        lastPlainText = pbOut[dwIdx];
    }

    return dwOutBufferLength; 
}

////////////////////////////////////////////////////////////////////////////////
// Helper functions
////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   reverse
//
//  Synopsis:   reverse the given strings.
//
//  Arguments:  s   the string.
//
//  Returns:    the reversed string
//
//  History:    henryt  Created     5/20/97
//
//----------------------------------------------------------------------------
static LPTSTR 
reverse(
    LPTSTR  s
)
{
    int     i = 0;
    int     j = lstrlen(s) - 1;
    TCHAR   ch;

    while (i < j)
    {
        ch = s[i];
        s[i++] = s[j];
        s[j--] = ch;
    }
    return s;
}


//+---------------------------------------------------------------------------
//
//  Function:   GenerateKeyString
//
//  Synopsis:   reverse the key str and use it as a password to generate a session key.
//
//  Arguments:  OUT LPTSTR  pszBuf,   The buffer
//              IN  DWORD   dwBufLen     size of the buffer in # of chars.
//              
//              
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    henryt  Created     5/20/97
//
//----------------------------------------------------------------------------
static void
GenerateKeyString(
    IN OUT  LPTSTR  pszBuf,
    IN      DWORD   dwBufLen
)
{
    lstrcpyn(pszBuf, gc_szKeyStr, dwBufLen);
    pszBuf[dwBufLen - 1] = 0;
    reverse(pszBuf);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetKeyString
//
//  Synopsis:   Generates a random key that will be used to create the
//              session key that is used to encrypt the password. Once the key
//              created it is encrypted and stored in the registry so that we
//              can use the key to decrypt the password again. The key used to 
//              encrypt and decrypt is generated in GetCurrentKey(). If 
//              anything fails we default to using a hardcoded key by calling
//              GenerateKeyString.
//
//  Arguments:  pszBuf      The buffer
//              dwBufLen    size of the buffer in # of chars.
//              dwEncryptionType - selects which reg key to use
//              pfnAlloc    memory allocator(if NULL, then the default is used.   
//                           Win32 - HeapAlloc(GetProcessHeap(), ...)         
//              pfnFree     memory deallocator(if NULL, then the default is used. 
//                           Win32 - HeapFree(GetProcessHeap(), ...)          
//              pszUserKey  reg key used to store the encrypted key, if not 
//                          provided (NULL), it will default to GenerateKeyString
//              pfMoreSecure TRUE if we are using the randomly generated key
//                           FALSE if using the hardcoded key  
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    03/14/2001  tomkel      Created
//
//----------------------------------------------------------------------------
static BOOL SetKeyString(IN OUT LPTSTR  pszBuf,
                         IN     DWORD dwBufLen,
                         IN     DWORD dwEncryptionType,
                         IN     PFN_CMSECUREALLOC  pfnAlloc,
                         IN     PFN_CMSECUREFREE   pfnFree,
                         IN     LPSTR pszUserKey,
                         OUT    BOOL *pfMoreSecure)
{
    BOOL fReturn = FALSE;
    BOOL fFuncRet = FALSE;
    BOOL fOk = FALSE;
    TCHAR szTempKeyStr[MAX_KEY_STRING_LEN]={0};
    DWORD cbEncryptedData = 0; 
    PBYTE pbEncryptedData = NULL;

    //
    // Don't check for pszUserKey here
    //
    if (NULL == pszBuf || NULL == pfMoreSecure)
    {
        return fReturn;
    }
    
    *pfMoreSecure = FALSE;

    //
    // Check to see if we should try to generate a random key and then store it 
    // into the reg key supplied by the caller. If not, then use the hardcoded key.
    //
    if (pszUserKey)
    {
        //
        // Try to generate random key otherwise use the hardcoded string. GenerateRandomKey
        // takes a PBYTE pointer and a count in bytes, thus we have to convert the character count
        // to bytes by multiplying it by sizeof(TCHAR)
        //
        if (g_pCryptFnc->GenerateRandomKey((PBYTE)pszBuf, dwBufLen*sizeof(TCHAR)))
        {
            // Now that we have the randomkey, we need to store it in the registry so 
            // we can use it when decrypting. In order to store it, we have 
            // to encrypt it first. 
        
            //
            // Generate a machine specific key that's used to encrypt the random number 
            // used for the session key
            //
            fFuncRet = GetCurrentKey(szTempKeyStr, MAX_KEY_STRING_LEN, pfnAlloc, pfnFree);
            if (fFuncRet)
            {
                //
                // If user want use CryptoApi and it is available
                //
                if (!g_pCryptFnc)
                {
                    g_pCryptFnc = InitCryptoApi();
                }

                if (g_pCryptFnc)
                {
                    //
                    // encrypt the data with the key string
                    //
                    fOk = g_pCryptFnc->EncryptDataWithKey(
                        szTempKeyStr,                // Key
                        (PBYTE)pszBuf,               // Secret key to encrypt
                        dwBufLen,                    // Length of secret key
                        &pbEncryptedData,            // Encrypted data will be stored here
                        &cbEncryptedData,            // Length of this buffer
                        pfnAlloc,                    // mem allocator
                        pfnFree,                     // mem deallocator
                        0);                          // not specifying keylength
                }

                if (fOk)
                {
                    //
                    // Store the encrypted key in the registry so we can use it later
                    // for decryption
                    // 
                    HKEY hKeyCm;
    
                    //
                    // Try to open the key for writing
                    //

                    LONG lRes = RegOpenKeyEx(HKEY_CURRENT_USER,
                                              pszUserKey,
                                              0,
                                              KEY_SET_VALUE ,
                                              &hKeyCm);

                    //
                    // If we can't open it the key may not be there, try to create it.
                    //

                    if (ERROR_SUCCESS != lRes)
                    {
                        DWORD dwDisposition;
                        lRes = RegCreateKeyEx(HKEY_CURRENT_USER,
                                               pszUserKey,
                                               0,
                                               TEXT(""),
                                               REG_OPTION_NON_VOLATILE,
                                               KEY_SET_VALUE,
                                               NULL,
                                               &hKeyCm,
                                               &dwDisposition);     
                    }

                    //
                    // On success, update the value, then close
                    //

                    if (ERROR_SUCCESS == lRes)
                    {
                        if (dwEncryptionType & CMSECURE_ET_USE_SECOND_RND_KEY)
                        {
                            lRes = RegSetValueEx(hKeyCm, c_pszCmRegKeyEncryptedInternetPasswordKey, NULL, REG_BINARY,
                                          pbEncryptedData, cbEncryptedData);
                        }
                        else
                        {
                            lRes = RegSetValueEx(hKeyCm, c_pszCmRegKeyEncryptedPasswordKey, NULL, REG_BINARY,
                                          pbEncryptedData, cbEncryptedData);
                        }
                        
                        RegCloseKey(hKeyCm);
                    
                        if (ERROR_SUCCESS == lRes)
                        {
                            fReturn = TRUE;
                            *pfMoreSecure = TRUE;
                        }
                    }
                }
            }
        }
    }

    //
    // Check if we need to default to the old key
    //
    if (FALSE == fReturn)
    {
        GenerateKeyString(pszBuf, dwBufLen);
        fReturn = TRUE;
    }

    if (pfnFree)
    {
        pfnFree(pbEncryptedData);
    }
    else
    {
        HeapFree(GetProcessHeap(), 0, pbEncryptedData);
    }
    
    ZeroMemory((LPVOID)szTempKeyStr, sizeof(szTempKeyStr));
    
    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetKeyString
//
//  Synopsis:   Gets the key that is used to create a session key for
//              decrypting the password. Reads the encrypted key from the 
//              registry. Get the key used for decrypting by calling GetCurrentKey.
//              Decrypts the data and returns the key. If anything fails we 
//              default to using a hardcoded key by calling GenerateKeyString.
//
//  Arguments:  pszBuf      The buffer
//              pdwBufLen   pointer to the size of the buffer in # of chars.
//              dwEncryptionType - selects which reg key to use
//              pfnAlloc    memory allocator(if NULL, then the default is used.   
//                           Win32 - HeapAlloc(GetProcessHeap(), ...)         
//              pfnFree     memory deallocator(if NULL, then the default is used. 
//                           Win32 - HeapFree(GetProcessHeap(), ...)          
//              pszUserKey  reg key used to store the encrypted key, if not 
//                          provided (NULL), it will default to GenerateKeyString
//              pfMoreSecure TRUE if we are using the randomly generated key
//                           FALSE if using the hardcoded key  
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    03/14/2001  tomkel      Created
//
//----------------------------------------------------------------------------
static BOOL GetKeyString(IN OUT  LPTSTR  pszBuf, IN DWORD *pdwBufLen, IN DWORD dwEncryptionType,
                         IN PFN_CMSECUREALLOC  pfnAlloc,
                         IN PFN_CMSECUREFREE   pfnFree,
                         IN LPSTR pszUserKey,
                         OUT BOOL *pfMoreSecure)
{
    BOOL fReturn = FALSE;
    BOOL fFuncRet = FALSE;
    HKEY hKeyCm;
    TCHAR szTempKeyStr[MAX_KEY_STRING_LEN]={0};
    DWORD dwRet = 0;
    DWORD cbEncryptedData = 0;
    PBYTE pbEncryptedData = NULL; 
    PBYTE pbData = NULL;
    DWORD dwDataBufferLength = 0;

    //
    // Don't Check for pszUserKey here
    //
    if (NULL == pszBuf || NULL == pdwBufLen || NULL == pfMoreSecure)
    {
        return fReturn;
    }

    *pfMoreSecure = FALSE;
    
    //
    // If we have the user key then we are using the randomly generated key. 
    // Try to get it from the reg.
    //
    if (pszUserKey)
    {
        //
        // Try to open the key for writing
        //

        LONG lRes = RegOpenKeyEx(HKEY_CURRENT_USER,
                                  pszUserKey,
                                  0,
                                  KEY_READ ,
                                  &hKeyCm);

        //
        // On success, read the value, then close
        //
        if (ERROR_SUCCESS == lRes)
        {
            DWORD dwType = REG_BINARY;
            //
            // Get the size first
            //
            if (dwEncryptionType & CMSECURE_ET_USE_SECOND_RND_KEY)
            {
                lRes = RegQueryValueEx(hKeyCm, c_pszCmRegKeyEncryptedInternetPasswordKey, NULL, &dwType,
                              NULL, &cbEncryptedData); 
            }
            else
            {
                lRes = RegQueryValueEx(hKeyCm, c_pszCmRegKeyEncryptedPasswordKey, NULL, &dwType,
                              NULL, &cbEncryptedData); 
            }

            //
            // Alloc the appropriate sized buffer. Need to add a space for null,
            // otherwise decrypt doesn't work.
            //
            if (pfnAlloc)
            {
                pbEncryptedData = (PBYTE)pfnAlloc(cbEncryptedData + sizeof(TCHAR));
            }
            else
            {
                pbEncryptedData = (PBYTE)HeapAlloc(GetProcessHeap(), 
                                         HEAP_ZERO_MEMORY,
                                         cbEncryptedData + sizeof(TCHAR));
            }
            
            if (pbEncryptedData)
            {
                if (dwEncryptionType & CMSECURE_ET_USE_SECOND_RND_KEY)
                {
                    lRes = RegQueryValueEx(hKeyCm, c_pszCmRegKeyEncryptedInternetPasswordKey, NULL, &dwType,
                                  pbEncryptedData, &cbEncryptedData); 
                }
                else
                {
                    lRes = RegQueryValueEx(hKeyCm, c_pszCmRegKeyEncryptedPasswordKey, NULL, &dwType,
                                  pbEncryptedData, &cbEncryptedData); 
                }
            }
            RegCloseKey(hKeyCm);
    
            // 
            // If we find the value decrypt it, otherwise we fall through and use the default key
            //
            if (ERROR_SUCCESS == lRes && pbEncryptedData)
            {
                //
                // Decrypt it using the machine specific key
                //
                fFuncRet = GetCurrentKey(szTempKeyStr, MAX_KEY_STRING_LEN, pfnAlloc, pfnFree);
                if (fFuncRet)
                {
                    if (!g_pCryptFnc)
                    {
                        g_pCryptFnc = InitCryptoApi();
                    }

                    if (g_pCryptFnc)
                    {
                        dwRet = g_pCryptFnc->DecryptDataWithKey(
                                    szTempKeyStr,            // Key
                                    pbEncryptedData,         // Encrypted data
                                    cbEncryptedData,         // Length of encrypted data
                                    &pbData,                 // decrypted data
                                    &dwDataBufferLength,     // Length of decrypted data
                                    pfnAlloc,                // mem allocator
                                    pfnFree,                 // mem deallocator
                                    0);                      // not specifying keylength

                        if (ERROR_SUCCESS == dwRet)
                        {
                            fReturn = TRUE;
                            *pfMoreSecure = TRUE;           // Using the random key
                        }
                    }
                }
            }
        }
    }

    if (fReturn)
    {
        DWORD dwLen = *pdwBufLen;
        if (dwDataBufferLength < *pdwBufLen)
        {
            dwLen = dwDataBufferLength;
        }

        //
        // Copy into out param
        //
        CopyMemory((LPVOID)pszBuf, pbData, dwLen);
    }
    else
    {
        GenerateKeyString(pszBuf, *pdwBufLen);
        fReturn = TRUE;
    }

    if (pfnFree)
    {
        pfnFree(pbEncryptedData);
        pfnFree(pbData);
    }
    else
    {
        HeapFree(GetProcessHeap(), 0, pbEncryptedData);
        HeapFree(GetProcessHeap(), 0, pbData);
    }

    ZeroMemory((LPVOID)szTempKeyStr, sizeof(szTempKeyStr));

    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCurrentKey
//
//  Synopsis:   Creates a machine dependent key by using the Hard Drive's 
//              serial number. This serial number is then used to fil lup the
//              output buffer. If the hard drive is replaced then this of course
//              will not generate the same serial number. 
//
//  Arguments:  szTempKeyStr        The buffer
//              dwTempKeyStrMaxLen  max length of the buffer in # of chars.
//              pfnAlloc  memory allocator(if NULL, then the default is used.   
//                        Win32 - HeapAlloc(GetProcessHeap(), ...)         
//              pfnFree   memory deallocator(if NULL, then the default is used. 
//                        Win32 - HeapFree(GetProcessHeap(), ...)          
//
//  Returns:    TRUE if success
//              FALSE if failure
//
//  History:    03/14/2001  tomkel      Created
//
//----------------------------------------------------------------------------
static BOOL GetCurrentKey(PTCHAR szTempKeyStr, DWORD dwTempKeyStrMaxLen, 
                   IN  PFN_CMSECUREALLOC  pfnAlloc,
                   IN  PFN_CMSECUREFREE   pfnFree)
{
    BOOL fFuncRet = FALSE;
    DWORD dwVolumeSerialNumber = 0;
    DWORD dwMaxComponentLen = 0;
    DWORD dwFileSysFlags = 0;
    LPTSTR pszSerialNum = NULL;
    
    if (NULL == szTempKeyStr)
    {
        return fFuncRet;
    }

    //
    // Lets generate the key from the HD serial number. This means that encrypted
    // passwords and keys will only be valid on this machine. If the user replaces
    // the drive, then the decryption will fail.
    //
    fFuncRet = GetVolumeInformation(NULL, NULL, 0, &dwVolumeSerialNumber, 
                                    &dwMaxComponentLen, &dwFileSysFlags, NULL, 0);
    if (fFuncRet)
    {
        DWORD dwLen = 0;
        
        //
        // Make sure we have a buffer large enough to hold the value. 
        // Allocate a string based on the number of bits, thus a decimal number
        // will always fit. Maybe an exaggeration, but the length isn't hardcoded.
        //
        if (pfnAlloc)
        {
            pszSerialNum = (LPTSTR)pfnAlloc(sizeof(dwVolumeSerialNumber)*8*sizeof(TCHAR));
        }
        else
        {
            pszSerialNum = (LPTSTR)HeapAlloc(GetProcessHeap(), 
                                     HEAP_ZERO_MEMORY,
                                     sizeof(dwVolumeSerialNumber)*8*sizeof(TCHAR));
        }
        
        if (pszSerialNum)
        {
            DWORD dwSNLen = 0;

            wsprintf(pszSerialNum, TEXT("%u"), dwVolumeSerialNumber);

            //
            // See how many times the serial number string will fit into our buffer
            // Need to check the length due to PREFIX. If the length is 0, just return. 
            //
            dwSNLen = lstrlen(pszSerialNum);

            if (dwSNLen)
            {
                dwLen = (dwTempKeyStrMaxLen - 1) / dwSNLen;
            }
            else
            {
                fFuncRet = FALSE;
                goto done;
            }

            if (0 < dwLen)
            {
                DWORD i = 0;
            
                lstrcpy(szTempKeyStr, pszSerialNum);
                //
                // Fill up the buffer. Start at 1 because we already copied the first 
                // serial number into the buffer
                //
                for (i = 1; i<dwLen; i++)
                {
                    lstrcat(szTempKeyStr, pszSerialNum);
                }
            }
            else
            {
                //
                // the length is larger than the buffer so just copy what fits into the buffer
                //
                lstrcpyn(szTempKeyStr, pszSerialNum, dwTempKeyStrMaxLen-1);
            }
        }
        else
        {
            fFuncRet = FALSE;
        }
    }

done:
    if (pfnFree)
    {
        pfnFree(pszSerialNum);
    }
    else
    {
        HeapFree(GetProcessHeap(), 0, (LPVOID)pszSerialNum);
    }

    return fFuncRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsecure\cryptfnc.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cryptfnc.cpp
//
// Module:   CMSECURE.LIB
//
// Synopsis: This file implements the cryptfnc class that provides
//           easy to use interfaces on the CryptoAPI.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   AshishS    Created             12/03/96
//           henryt     modified for CM     5/21/97
//
//+----------------------------------------------------------------------------

#include "cryptfnc.h"

#ifdef UNICODE
#define LoadLibraryExU LoadLibraryExW
#else
#define LoadLibraryExU LoadLibraryExA
#endif
#include "linkdll.h" // LinkToDll and BindLinkage

CCryptFunctions::~CCryptFunctions()
{
     // Release provider handle.    
    if (m_hProv != 0)
    {
        m_fnCryptReleaseContext(m_hProv, 0);
    }

    if (m_AdvApiLink.hInstAdvApi32)
    {
        FreeLibrary(m_AdvApiLink.hInstAdvApi32);
        ZeroMemory(&m_AdvApiLink, sizeof(m_AdvApiLink));
    }
}


CCryptFunctions::CCryptFunctions()
{
    m_hProv = 0;
    ZeroMemory(&m_AdvApiLink, sizeof(m_AdvApiLink));
}

BOOL CCryptFunctions::m_fnCryptAcquireContext(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, 
                             DWORD dwProvType, DWORD dwFlags)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptAcquireContext);
    if (m_AdvApiLink.pfnCryptAcquireContext)
    {
        bReturn = m_AdvApiLink.pfnCryptAcquireContext(phProv, pszContainer, pszProvider, 
                                                      dwProvType, dwFlags);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, 
                         DWORD dwFlags, HCRYPTHASH *phHash)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(m_AdvApiLink.pfnCryptCreateHash);
   
    if (m_AdvApiLink.pfnCryptCreateHash)
    {
        bReturn = m_AdvApiLink.pfnCryptCreateHash(hProv, Algid, hKey, dwFlags, phHash);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, 
                      BYTE *pbData, DWORD *pdwDataLen)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(m_AdvApiLink.pfnCryptDecrypt);
    
    if (m_AdvApiLink.pfnCryptDecrypt)
    {
        bReturn = m_AdvApiLink.pfnCryptDecrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, 
                        DWORD dwFlags, HCRYPTKEY *phKey)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptDeriveKey);

    if (m_AdvApiLink.pfnCryptDeriveKey)
    {
        bReturn = m_AdvApiLink.pfnCryptDeriveKey(hProv, Algid, hBaseData, dwFlags, phKey);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptDestroyHash(HCRYPTHASH hHash)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptDestroyHash);

    if (m_AdvApiLink.pfnCryptDestroyHash)
    {
        bReturn = m_AdvApiLink.pfnCryptDestroyHash(hHash);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptDestroyKey(HCRYPTKEY hKey)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptDestroyKey);

    if (m_AdvApiLink.pfnCryptDestroyKey)
    {
        bReturn = m_AdvApiLink.pfnCryptDestroyKey(hKey);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags,
                      BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptEncrypt);

    if (m_AdvApiLink.pfnCryptEncrypt)
    {
        bReturn = m_AdvApiLink.pfnCryptEncrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptHashData(HCRYPTHASH hHash, CONST BYTE *pbData, DWORD dwDataLen, DWORD dwFlags)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptHashData);

    if (m_AdvApiLink.pfnCryptHashData)
    {
        bReturn = m_AdvApiLink.pfnCryptHashData(hHash, pbData, dwDataLen, dwFlags);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_fnCryptReleaseContext(HCRYPTPROV hProv, ULONG_PTR dwFlags)
{
    BOOL bReturn = FALSE;
    
    MYDBGASSERT(m_AdvApiLink.pfnCryptReleaseContext);

    if (m_AdvApiLink.pfnCryptReleaseContext)
    {
        bReturn = m_AdvApiLink.pfnCryptReleaseContext(hProv, dwFlags);
    }

    return bReturn;
}

BOOL CCryptFunctions::m_pfnCryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer)
{
    BOOL bReturn = FALSE;

    MYDBGASSERT(m_AdvApiLink.pfnCryptGenRandom);

    if (m_AdvApiLink.pfnCryptGenRandom)
    {
        bReturn = m_AdvApiLink.pfnCryptGenRandom(hProv, dwLen, pbBuffer);
    }

    return bReturn;
}

//
// Calls m_pfnCryptGenRandom to create a random key
//
BOOL CCryptFunctions::GenerateRandomKey(PBYTE pbData, DWORD cbData)
{
    BOOL fReturn = FALSE;
    if (pbData)
    {
        fReturn = m_pfnCryptGenRandom(m_hProv, cbData, pbData);
    }
    return fReturn;
}

//+----------------------------------------------------------------------------
//
// Func:    CCryptFunctions::GenerateSessionKeyFromPassword
//
// Desc:    this function Generates a SessionKey using the pszPassword parameter
//
// Args:    [phKey]       - location to store the session key
//          [pszPassword] - password to generate the session key from
//          [dwEncKeyLen] - how many bits of encryption
//
// Return:  BOOL (FALSE if a fatal error occurred, else TRUE)
//
// Notes:   
//
//-----------------------------------------------------------------------------
BOOL CCryptFunctions::GenerateSessionKeyFromPassword(    
        HCRYPTKEY * phKey,
        LPTSTR      pszPassword,
        DWORD       dwEncKeyLen)
{
    DWORD dwLength; 
    HCRYPTHASH hHash = 0;

    // Create hash object.
    //
    if (!m_fnCryptCreateHash(m_hProv, // handle to CSP
                             CALG_SHA, // use SHA hash algorithm
                             0, // not keyed hash
                             0, // flags - always 0
                             &hHash)) // address where hash object should be created
    {
        MYDBG(("Error 0x%x during CryptCreateHash", GetLastError()));
        goto cleanup;
    }

    // Hash password string.
    //
    dwLength = lstrlen(pszPassword) * sizeof(TCHAR);
    if (!m_fnCryptHashData(hHash, // handle to hash object
                           (BYTE *)pszPassword, // address of data to be hashed
                           dwLength, // length of data 
                           0)) // flags
    {
        MYDBG(("Error 0x%x during CryptHashData", GetLastError()));
        goto cleanup;
    }

    // Create block cipher session key based on hash of the password.
    //
    if (!m_fnCryptDeriveKey(m_hProv, //CSP provider
                            CALG_RC2, // use RC2 block cipher algorithm
                            hHash, //handle to hash object 
                            (dwEncKeyLen << 16), // just the key length, no flags - we do not need the key to be exportable
                            phKey)) //address the newly created key should be copied
    {
        MYDBG(("Error 0x%x during CryptDeriveKey", GetLastError()));
        goto cleanup;
    }
    
     // Destroy hash object.
    m_fnCryptDestroyHash(hHash);
    return TRUE;
    
cleanup:

    // Destroy hash object.
    if (hHash != 0)
    {
        m_fnCryptDestroyHash(hHash);
    }
    return FALSE;
}

// This function must be called before any member functions of the
// class are used.
// Returns FALSE if a Fatal error occured, TRUE otherwise
BOOL CCryptFunctions::InitCrypt()
{
    LPCSTR ArrayOfCryptFuncs [] = 
    {
#ifdef UNICODE
        "CryptAcquireContextW", // this has never been tested
#else
        "CryptAcquireContextA",        
#endif
        "CryptCreateHash",
        "CryptDecrypt",
        "CryptDeriveKey",
        "CryptDestroyHash",
        "CryptDestroyKey",
        "CryptEncrypt",
        "CryptHashData",
        "CryptReleaseContext",
        "CryptGenRandom",       // to create a random session key
        NULL
    };

    BOOL bRet = LinkToDll(&(m_AdvApiLink.hInstAdvApi32), TEXT("Advapi32.dll"), ArrayOfCryptFuncs, 
                          m_AdvApiLink.apvPfn);

    if (!bRet)
    {
        goto cleanup;
    }

    // Get handle to user default provider.
    if (! m_fnCryptAcquireContext(&m_hProv, //  address to get the handle to CSP
                                  CM_CRYPTO_CONTAINER, // contianer name
                                  MS_DEF_PROV, //  provider
                                  PROV_RSA_FULL, // type of provider
                                  0)) // no flags
    {
        DWORD dwError = GetLastError();
        MYDBGTST(dwError, ("Error 0x%x during CryptAcquireContext", dwError));

        MYDBG(("Calling CryptAcquireContext again to create keyset"));

        if (! m_fnCryptAcquireContext(&m_hProv,// handle to CSP
                                      CM_CRYPTO_CONTAINER,// contianer name
                                      MS_DEF_PROV, // provider
                                      PROV_RSA_FULL, // type of provider
                                      CRYPT_NEWKEYSET) ) // create the keyset
        {
            MYDBG(("Fatal Error 0x%x during second call to CryptAcquireContext", GetLastError()));
            goto cleanup;               
        }
    }

    return TRUE;
    
cleanup:
     // Release provider handle.
    if (m_hProv != 0)
    {
        m_fnCryptReleaseContext(m_hProv, 0);
    }
    return FALSE;   
}



// Given a key string, and data to encrypt this function generates a
// session key from the key string. This session key is then used to
// encrypt the data.

// Returns FALSE if a Fatal error occured, TRUE otherwise
BOOL CCryptFunctions::EncryptDataWithKey(
    LPTSTR          pszKey,              // password    
    PBYTE           pbData,              // Data to be encrypted
    DWORD           dwDataLength,        // Length of data in bytes
    PBYTE           *ppbEncryptedData,     // Encrypted secret key will be stored here
    DWORD           *pdwEncryptedBufferLen, // Length of this buffer
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree,
    DWORD           dwEncKeySize         // how many bits of encryption do we want?  (0 implies "don't care")
    )
{
    HCRYPTKEY   hKey = 0;   
    DWORD       dwErr;
    DWORD       dwBufferLen;
    BOOL        fOk = FALSE;
    PBYTE       pbBuf = NULL;
    
    //
    // Init should have been successfully called before
    // if no data to be encrypted, don't do anything
    //
    if (m_hProv == 0 || !dwDataLength)
    {
        return FALSE;
    }
    
    if (!GenerateSessionKeyFromPassword(&hKey, pszKey, dwEncKeySize))
        goto cleanup;

     // copy the data into another buffer to encrypt it
    *pdwEncryptedBufferLen = dwDataLength;
    dwBufferLen = dwDataLength + DEFAULT_CRYPTO_EXTRA_BUFFER_SIZE; 

    while (1)
    {
        //
        // alloc memory for output buffer
        //
        if (pfnAlloc)
        {
            *ppbEncryptedData = (PBYTE)pfnAlloc(dwBufferLen);
        }
        else
        {
            *ppbEncryptedData = (PBYTE)HeapAlloc(GetProcessHeap(), 
                                                 HEAP_ZERO_MEMORY,
                                                 dwBufferLen);
        }
        if (!*ppbEncryptedData)
        {
            MYDBG(("EncryptDataWithKey: out of memory error"));
            goto cleanup;
        }
    
         // copy the data into another buffer to encrypt it
        memcpy (*ppbEncryptedData, pbData, dwDataLength);
    
    
         // now encrypt the secret key using the key generated
        if ( ! m_fnCryptEncrypt(hKey,
                                0, // no hash required
                                TRUE, // Final packet
                                0, // Flags - always 0
                                *ppbEncryptedData, // data buffer
                                pdwEncryptedBufferLen, // length of data
                                dwBufferLen ) ) // size of buffer
        {
            MYDBG(("Error 0x%x during CryptEncrypt", GetLastError()));

            if (pfnFree)
            {
                pfnFree(*ppbEncryptedData);
            }
            else
            {
                HeapFree(GetProcessHeap(), 0, *ppbEncryptedData);
            }
            *ppbEncryptedData = NULL;
            
            dwErr = GetLastError();
            //
            // if the output is too small, realloc it.
            //
            if (dwErr == ERROR_MORE_DATA  || dwErr == NTE_BAD_LEN)
            {
                dwBufferLen += DEFAULT_CRYPTO_EXTRA_BUFFER_SIZE;
                continue;
            }

            goto cleanup;
        }

        //
        // we now have the data encrypted.  we need to uuencode it.
        //
        if (pfnAlloc)
        {
            pbBuf = (PBYTE)pfnAlloc(*pdwEncryptedBufferLen);
        }
        else
        {
            pbBuf = (PBYTE)HeapAlloc(GetProcessHeap(), 
                                     HEAP_ZERO_MEMORY,
                                     *pdwEncryptedBufferLen);
        }
        if (!pbBuf)
        {
            MYDBG(("EncryptDataWithKey: out of memory error"));
            if (pfnFree)
            {
                pfnFree(*ppbEncryptedData);
            }
            else
            {
                HeapFree(GetProcessHeap(), 0, *ppbEncryptedData);
            }
            *ppbEncryptedData = NULL;
            goto cleanup;
        }

        memcpy(pbBuf, *ppbEncryptedData, *pdwEncryptedBufferLen);
        uuencode(pbBuf, *pdwEncryptedBufferLen, (CHAR*)*ppbEncryptedData, dwBufferLen);
        //
        // set the encrypted buffer len
        //
        *pdwEncryptedBufferLen = lstrlen((LPTSTR)*ppbEncryptedData);

        if (pfnFree)
        {
            pfnFree(pbBuf);
        }
        else
        {
            HeapFree(GetProcessHeap(), 0, pbBuf);
        }
        pbBuf = NULL;

        break;
    }

    fOk = TRUE;
    
cleanup:
         // destroy session key
    if (hKey != 0)
        m_fnCryptDestroyKey(hKey);
    
    return fOk;
}

// Given a key string, and encrypted data using EncryptDataWithPassword,
// this function generates a session key from the key string. This
// session key is then used to decrypt the data.

//  returns
//   CRYPT_FNC_NO_ERROR   no error
//   CRYPT_FNC_BAD_PASSWORD password bad try again
//   CRYPT_FNC_INSUFFICIENT_BUFFER larger buffer is required
//   *pdwEncrytedBufferLen is set to required length
//   CRYPT_FNC_INIT_NOT_CALLED InitCrypt not successfully called
//   CRYPT_FNC_INTERNAL_ERROR 
DWORD CCryptFunctions::DecryptDataWithKey(
    LPTSTR          pszKey,              // password    
    PBYTE           pbEncryptedData,     // Encrypted data
    DWORD           dwEncrytedDataLen,   // Length of encrypted data
    PBYTE           *ppbData,            // Decrypted Data will be stored here
    DWORD           *pdwDataBufferLength,// Length of the above buffer in bytes
    PFN_CMSECUREALLOC  pfnAlloc,
    PFN_CMSECUREFREE   pfnFree,
    DWORD           dwEncKeySize         // how many bits of encryption do we want?  (0 implies "don't care")
    )
{
    DWORD dwBufferLen;
    DWORD dwUUDecodeBufLen;
    HCRYPTKEY hKey = 0; 
    DWORD dwError;
    DWORD dwMaxBufSize = 1024 * 10;     // Just some max buffer size (10K) in order to exit the while loop

    //
    // Init should have been successfully called before
    // if no data to be decrypted, then don't do anything
    //
    if (m_hProv == 0 || !dwEncrytedDataLen)
    {
        dwError = CRYPT_FNC_INIT_NOT_CALLED;
        goto cleanup;
    }
    
    if (!GenerateSessionKeyFromPassword(&hKey, pszKey, dwEncKeySize))
    {
        dwError = CRYPT_FNC_INTERNAL_ERROR;     
        goto cleanup;
    }

     // copy the data into another buffer to encrypt it
    dwBufferLen = dwEncrytedDataLen + DEFAULT_CRYPTO_EXTRA_BUFFER_SIZE;
    // *pdwDataBufferLength = dwEncrytedDataLen;

    //
    // Loop until we get to dwMaxBufSize. This is a safeguard to get out
    // of the infinite loop problem. DBCS passwords used to loop continuously.
    //

    while(dwBufferLen < dwMaxBufSize)  
    {
        //
        // alloc memory for output buffer
        //
        if (pfnAlloc)
        {
            *ppbData = (PBYTE)pfnAlloc(dwBufferLen);
        }
        else
        {
            *ppbData = (PBYTE)HeapAlloc(GetProcessHeap(),
                                        HEAP_ZERO_MEMORY,
                                        dwBufferLen);
        }
        if (!*ppbData)
        {
            dwError = CRYPT_FNC_OUT_OF_MEMORY;
            goto cleanup;
        }

        //
        // set uudecode output buf size
        //
        dwUUDecodeBufLen = dwBufferLen;

        uudecode((char*)pbEncryptedData, (CHAR*)*ppbData, &dwUUDecodeBufLen);
        
        *pdwDataBufferLength = dwUUDecodeBufLen;

         // now decrypt the secret key using the key generated
        if ( ! m_fnCryptDecrypt(hKey,
                                0, // no hash required
                                TRUE, // Final packet
                                0, // Flags - always 0
                                *ppbData, // data buffer
                                pdwDataBufferLength )) // length of data
        {
            DWORD dwCryptError = GetLastError();
            MYDBGTST(dwCryptError, ("Error 0x%x during CryptDecrypt", dwCryptError));
    
            if (pfnFree)
            {
                pfnFree(*ppbData);
            }
            else
            {
                HeapFree(GetProcessHeap(), 0, *ppbData);
            }
            *ppbData = NULL;
            
            //
            // if the output is too small, realloc it.
            //
            if (dwCryptError == NTE_BAD_LEN)
            {
                dwBufferLen *= 2;  // to speed up memory alloc double the size
                continue;
            }

             // CryptDecrypt fails with error NTE_BAD_DATA if the password
             // is incorrect. Hence we should check for this error and prompt the
             // user again for the password.  If the data is garbled in transit, then the secret key
             // will still be  decrypted into a wrong value and the user will not
             // know about it.
            if (dwCryptError == NTE_BAD_DATA)
            {
                dwError = CRYPT_FNC_BAD_KEY;
            }
            else
            {
                dwError = CRYPT_FNC_INTERNAL_ERROR;         
            }

            goto cleanup;
        }

        break;
    }
    if (dwBufferLen < dwMaxBufSize)
    {
        dwError = CRYPT_FNC_NO_ERROR;
    }
    else
    {
        CMTRACE1(TEXT("DecryptDataWithKey: not enough buffer = %d bytes"), dwBufferLen);
        MYDBGASSERT(FALSE);
        dwError = NTE_BAD_LEN;
    }
    
    
cleanup:
         // destroy session key
    if (hKey != 0)
    {
        m_fnCryptDestroyKey(hKey);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsecure\cryptfnc.h ===
//+----------------------------------------------------------------------------
//
// File:     cryptfnc.h
//
// Module:   CMSECURE.LIB
//
// Synopsis: Definition for the cryptfnc class that provides
//           an easy to use interface to the CryptoAPI.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:       AshishS    Created             12/03/96
//           henryt     modified for CM     5/21/97
//
//+----------------------------------------------------------------------------

#ifndef _CRYPTFNC_INC_
#define _CRYPTFNC_INC_

#include <stdio.h>
#include <stdarg.h>
#include <windows.h>
#include <wincrypt.h>
#include "cmuufns.h"
#include "cmsecure.h"
#include "cmdebug.h"
//#include "cmutil.h"

//************************************************************************
// define's
//************************************************************************

#define CRYPT_FNC_NO_ERROR              0
#define CRYPT_FNC_INIT_NOT_CALLED       1
#define CRYPT_FNC_INTERNAL_ERROR        2
#define CRYPT_FNC_BAD_KEY               3
#define CRYPT_FNC_INSUFFICIENT_BUFFER   4
#define CRYPT_FNC_OUT_OF_MEMORY         5

#define DEFAULT_CRYPTO_EXTRA_BUFFER_SIZE     256

#define CM_CRYPTO_CONTAINER             TEXT("CM Crypto Container")

//************************************************************************
// Typedefs for Advapi Linkage
//************************************************************************

typedef BOOL (WINAPI* pfnCryptAcquireContextSpec)(HCRYPTPROV *, LPCTSTR, LPCTSTR, DWORD, DWORD);
typedef BOOL (WINAPI* pfnCryptCreateHashSpec)(HCRYPTPROV, ALG_ID, HCRYPTKEY, DWORD, HCRYPTHASH *);
typedef BOOL (WINAPI* pfnCryptDecryptSpec)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE *, DWORD *);
typedef BOOL (WINAPI* pfnCryptDeriveKeySpec)(HCRYPTPROV, ALG_ID, HCRYPTHASH, DWORD, HCRYPTKEY *);
typedef BOOL (WINAPI* pfnCryptDestroyHashSpec)(HCRYPTHASH);
typedef BOOL (WINAPI* pfnCryptDestroyKeySpec)(HCRYPTKEY);
typedef BOOL (WINAPI* pfnCryptEncryptSpec)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE *, DWORD *, DWORD);
typedef BOOL (WINAPI* pfnCryptHashDataSpec)(HCRYPTHASH, CONST BYTE *, DWORD, DWORD);
typedef BOOL (WINAPI* pfnCryptReleaseContextSpec)(HCRYPTPROV , ULONG_PTR);
typedef BOOL (WINAPI* pfnCryptGenRandomSpec)(HCRYPTPROV, DWORD, BYTE*);

typedef struct _Advapi32LinkageStruct {
        HINSTANCE hInstAdvApi32;
        union {
                struct {
                pfnCryptAcquireContextSpec pfnCryptAcquireContext;
                pfnCryptCreateHashSpec pfnCryptCreateHash;
                pfnCryptDecryptSpec pfnCryptDecrypt;
                pfnCryptDeriveKeySpec pfnCryptDeriveKey;
                pfnCryptDestroyHashSpec pfnCryptDestroyHash;
                pfnCryptDestroyKeySpec pfnCryptDestroyKey;
                pfnCryptEncryptSpec pfnCryptEncrypt;
                pfnCryptHashDataSpec pfnCryptHashData;
                pfnCryptReleaseContextSpec pfnCryptReleaseContext;
                pfnCryptGenRandomSpec pfnCryptGenRandom;
                };
                void *apvPfn[11];   // The size of apvPfn[] should always be 1 size bigger than
                                                   // the number of functions. 
        };
} Advapi32LinkageStruct;


//************************************************************************
// function prototypes
//************************************************************************

class CCryptFunctions
{

protected:
    HCRYPTPROV  m_hProv;
    Advapi32LinkageStruct m_AdvApiLink;

    BOOL m_fnCryptAcquireContext(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, 
                                 DWORD dwProvType, DWORD dwFlags);
    
    BOOL m_fnCryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, 
                             DWORD dwFlags, HCRYPTHASH *phHash);
    
    BOOL m_fnCryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, 
                          BYTE *pbData, DWORD *pdwDataLen);

    BOOL m_fnCryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, 
                            DWORD dwFlags, HCRYPTKEY *phKey);

    BOOL m_fnCryptDestroyHash(HCRYPTHASH hHash);

    BOOL m_fnCryptDestroyKey(HCRYPTKEY hKey);

    BOOL m_fnCryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags,
                          BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen);

    BOOL m_fnCryptHashData(HCRYPTHASH hHash, CONST BYTE *pbData, DWORD dwDataLen, DWORD dwFlags);

    BOOL m_fnCryptReleaseContext(HCRYPTPROV hProv, ULONG_PTR dwFlags);

    BOOL m_pfnCryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer);

public:
    CCryptFunctions();

    ~CCryptFunctions();


    BOOL GenerateSessionKeyFromPassword(
            HCRYPTKEY   *phKey,         // location to store the session key
            LPTSTR      pszPassword,    // password to generate the session key from
            DWORD       dwEncKeyLen);   // how many bits of encryption
    
    BOOL InitCrypt();

    BOOL EncryptDataWithKey(
        LPTSTR              pszKey,
        PBYTE               pbData, 
        DWORD               dwDataLength, 
        PBYTE               *ppbEncryptedData,
        DWORD               *pdwEncryptedBufferLen,
        PFN_CMSECUREALLOC   pfnAlloc,
        PFN_CMSECUREFREE    pfnFree,
        DWORD               dwEncKeyLen);


    DWORD DecryptDataWithKey(
        LPTSTR              pszKey,
        PBYTE               pbEncryptedData,
        DWORD               dwEncrytedDataLen, 
        PBYTE               *ppbData, 
        DWORD               *pdwDataBufferLength,
        PFN_CMSECUREALLOC   pfnAlloc,
        PFN_CMSECUREFREE    pfnFree,
        DWORD               dwEncKeyLen);

    BOOL GenerateRandomKey(PBYTE pbData, DWORD cbData);
};

#endif // _CRYPTFNC_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsecure\uufuncs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     uufuncs.cpp
//
// Module:   CMSECURE.LIB
//
// Synopsis: uuencode and uudecode support
//
// Copyright (c) 1994-1998 Microsoft Corporation
//
// Author:	 quintinb       created header      08/18/99
//
//+----------------------------------------------------------------------------

#include <windows.h>
#include "cmuufns.h"
#include "cmdebug.h"

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

static const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

static const char six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL uudecode(
              const char   * bufcoded,
              CHAR   * pbuffdecoded,
              LPDWORD  pcbDecoded )
{
    DWORD nbytesdecoded;
    const char *bufin = bufcoded;
    unsigned char *bufout;
    INT32 nprbytes;

    MYDBGASSERT(pcbDecoded);

    if (!pcbDecoded)
        return FALSE;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = (INT32)(bufin - bufcoded - 1);
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if (*pcbDecoded < (nbytesdecoded + 4 ))
        return FALSE;

    bufout = (unsigned char *) pbuffdecoded;

    bufin = bufcoded;

    while (nprbytes > 0) 
    {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if (nprbytes & 03) 
    {
        if (pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }
    
    *pcbDecoded = nbytesdecoded;

    pbuffdecoded[nbytesdecoded] = '\0';

    return TRUE;
}

BOOL uuencode( const BYTE*   bufin,
               DWORD    nbytes,
               CHAR * pbuffEncoded,
               DWORD    outbufmax)
{
   MYDBGASSERT(!IsBadReadPtr(bufin, nbytes));
   MYDBGASSERT(!IsBadWritePtr(pbuffEncoded, outbufmax));

   unsigned char *outptr;
   unsigned int i;

   //
   //  Resize the buffer to 133% of the incoming data
   //

   if (outbufmax < (nbytes + ((nbytes + 3) / 3) + 4))
   {
       CMASSERTMSG(FALSE, "The outputbuf for uuencode is not large enough");
       return FALSE;
   }

   outptr = (unsigned char *) pbuffEncoded;

   //
   // Encode 3 byte at a time
   //
   for (i=0; i<(nbytes/3)*3; i += 3) 
   {
      *(outptr++) = six2pr[bufin[i] >> 2];            /* c1 */
      *(outptr++) = six2pr[((bufin[i] << 4) & 060) | ((bufin[i+1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[i+1] << 2) & 074) | ((bufin[i+2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[i+2] & 077];         /* c4 */
   }

   /* If nbytes was not a multiple of 3, then we have encoded too
    * many characters.  Adjust appropriately.
    */
   if (i+2 == nbytes) 
   {
      /* There were only 2 bytes in that last group */
      *(outptr++) = six2pr[bufin[i] >> 2];            /* c1 */
      *(outptr++) = six2pr[((bufin[i] << 4) & 060) | ((bufin[i+1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[(bufin[i+1] << 2) & 074];/*c3*/
      *(outptr++) = '=';         /* c4 */
   } 
   else 
   {
       if (i+1 == nbytes) 
       {

          /* There was only 1 byte in that last group */
          *(outptr++) = six2pr[bufin[i] >> 2];            /* c1 */
          *(outptr++) = six2pr[(bufin[i] << 4) & 060]; /*c2*/
          *(outptr++) = '=';                             /*c3*/
          *(outptr++) = '=';                             /*c4*/
       }
       else
       {
           MYDBGASSERT(i == nbytes);
       }
   }

   *outptr = '\0';

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\cfilename.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cfilename.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CFileNameParts Class
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    08/19/99
//
//+----------------------------------------------------------------------------
#include "cfilename.h"

CFileNameParts::CFileNameParts(LPCTSTR szFullPath)
{

	if (NULL == szFullPath)
	{
		CMASSERTMSG(FALSE, TEXT("NULL Input to CFileNameParts"));
		return;
	}

    MYDBGASSERT(MAX_PATH >= lstrlen(szFullPath));


    ZeroMemory(m_szFullPath, sizeof(m_szFullPath));
    ZeroMemory(m_Drive, sizeof(m_Drive));
    ZeroMemory(m_Dir, sizeof(m_Dir));
    ZeroMemory(m_FileName, sizeof(m_FileName));
    ZeroMemory(m_Extension, sizeof(m_Extension));

	TCHAR* pszStart = m_szFullPath;
	const TCHAR* pszCurrentSource = szFullPath;
	TCHAR* pszLastSlash = NULL;
	TCHAR* pszColon = NULL;
	TCHAR* pszLastDot = NULL;
	TCHAR* pszCurrentDest = m_szFullPath;


    //
    //  Copy szFullPath to m_szFullPath
    //
    lstrcpy(m_szFullPath, szFullPath);


	while ((TEXT('\0') != *pszCurrentSource) && (MAX_PATH >= (pszCurrentSource - szFullPath)))
	{
		switch(*pszCurrentSource)
		{
		case TEXT(':'):
			//
			//	Found a colon, take the drive letter.
			//
			if ((NULL == pszColon) && (pszCurrentDest != m_szFullPath) &&
				(m_szFullPath == CharPrev(m_szFullPath, pszCurrentDest)))
			{
				pszColon = pszCurrentDest;
				lstrcpyn(m_Drive, pszStart, (size_t)((pszCurrentDest - pszStart) + 2));
				pszStart = CharNext(pszColon);
			}
			else
			{
				CMASSERTMSG(FALSE, TEXT("CFileNameParts -- Error, we only allow one colon in a path."));
				return;
			}
			break;

		case TEXT('\\'):
		case TEXT('/'):
			pszLastSlash = pszCurrentDest;
			break;

		case TEXT('.'):
			pszLastDot = pszCurrentDest;
			break;

		}
		
        pszCurrentSource = CharNext(pszCurrentSource);
        pszCurrentDest = CharNext(pszCurrentDest);
	}

	if (pszLastSlash)
	{
		lstrcpyn(m_Dir, pszStart, (size_t)((pszLastSlash - pszStart) + 2));
		pszStart = CharNext(pszLastSlash) ;
	}

	if (pszLastDot && (pszLastDot > pszLastSlash))
	{
		lstrcpyn(m_FileName, pszStart, (size_t)((pszLastDot - pszStart) + 1));
		lstrcpyn(m_Extension, pszLastDot, _MAX_EXT+1);
	}
	else
	{
		//
		//	No extension
		//
		lstrcpyn(m_FileName, pszStart, _MAX_FNAME+1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\cmver.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmver.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of CmVersion class, a utility class that 
//           helps in detecting the version of Connection Mananger that 
//           is installed.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   a-anasj    Created                             02/11/98
//           quintinb   Cleaned Up and removed CRegValue    07/14/98
//           quintinb   Rewrote                             09/14/98
//
//+----------------------------------------------------------------------------

#include "cmsetup.h"
#include "reg_str.h"

CmVersion::CmVersion()
{
    HKEY hKey;
    LONG lResult;

    m_szCmmgrPath[0] = TEXT('\0');

	//
	//	We always want to look in the system directory for cmmgr32.exe first.  This is
	//  its new install location and the app paths key may be corrupted by a 1.0 profile
	//  install.
	//

	MYVERIFY(0 != GetSystemDirectory(m_szCmmgrPath, CELEMS(m_szCmmgrPath)));
	MYVERIFY(CELEMS(m_szPath) > (UINT)wsprintf(m_szPath, TEXT("%s\\cmdial32.dll"), 
		m_szCmmgrPath));

	if (!FileExists(m_szPath))
	{
		//
		//	The file wasn't in the system directory, now try the app paths key
		//
		m_szCmmgrPath[0] = TEXT('\0');
		m_szPath[0] = TEXT('\0');
	
		lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmAppPaths, 0, KEY_READ, &hKey);
    
		if (ERROR_SUCCESS == lResult)
		{        
			//
			//  Check to see if we have a path to work from.
			//
        
			DWORD dwSize = MAX_PATH;
			DWORD dwType = REG_SZ;
        
			if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegPath, NULL, &dwType, 
				(LPBYTE)m_szCmmgrPath, &dwSize))
			{
				//
				//	Now construct the base object
				//
				MYVERIFY(CELEMS(m_szPath) > (UINT)wsprintf(m_szPath, TEXT("%s\\cmdial32.dll"), 
					m_szCmmgrPath));

				Init();
			}
            RegCloseKey(hKey);
		}
	}
	else
	{
		Init();
	}
}

CmVersion::~CmVersion()
{
	//	nothing to do really
}

BOOL CmVersion::GetInstallLocation(LPTSTR szStr)
{
    if ((m_bIsPresent) && (TEXT('\0') != m_szCmmgrPath[0]) && (NULL != szStr))
    {
        lstrcpy(szStr, m_szCmmgrPath);
    }

    return m_bIsPresent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\createld.cpp ===
//+----------------------------------------------------------------------------
//
// File:     createld.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CreateLayerDirectory function.
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#include <windows.h>
#include <tchar.h>
#include <cmsetup.h>

//+----------------------------------------------------------------------------
//
// Function:  CreateLayerDirectory
//
// Synopsis:  Given a path to a directory, this function creates the path (if necessary)
//			  layer by layer.
//
// Arguments: LPCTSTR str - path to be created
//
// Returns:   TRUE if the directory was created (or exists), FALSE otherwise.
//
// Note:	This function was taken from cmocm.cpp.
//
// History:   quintinb   Created Header		12/15/97
//			  
//
//+----------------------------------------------------------------------------

BOOL CreateLayerDirectory( LPCTSTR str )
{
    BOOL fReturn = TRUE;

    do
    {
        INT index=0;
        INT iLength = _tcslen(str);

        // first find the index for the first directory
        if ( iLength > 2 )
        {
            if ( str[1] == _T(':'))
            {
                // assume the first character is driver letter
                if ( str[2] == _T('\\'))
                {
                    index = 2;
                } else
                {
                    index = 1;
                }
            } else if ( str[0] == _T('\\'))
            {
                if ( str[1] == _T('\\'))
                {
                    BOOL fFound = FALSE;
                    INT i;
                    INT nNum = 0;
                    // unc name
                    for (i = 2; i < iLength; i++ )
                    {
                        if ( str[i]==_T('\\'))
                        {
                            // find it
                            nNum ++;
                            if ( nNum == 2 )
                            {
                                fFound = TRUE;
                                break;
                            }
                        }
                    }
                    if ( fFound )
                    {
                        index = i;
                    } else
                    {
                        // bad name
                        break;
                    }
                } else
                {
                    index = 1;
                }
            }
        } else if ( str[0] == _T('\\'))
        {
            index = 0;
        }

        // okay ... build directory
        do
        {
            // find next one
            do
            {
                if ( index < ( iLength - 1))
                {
                    index ++;
                } else
                {
                    break;
                }
            } while ( str[index] != _T('\\'));


            TCHAR szCurrentDir[MAX_PATH+1];

            GetCurrentDirectory( MAX_PATH+1, szCurrentDir );

            TCHAR szNewDir[MAX_PATH+1];
            _tcscpy(szNewDir, str);
            szNewDir[index+1]=0;

            if ( !SetCurrentDirectory(szNewDir))
            {
                if (( fReturn = CreateDirectory(szNewDir, NULL )) != TRUE )
                {
                    break;
                }
            }

            SetCurrentDirectory( szCurrentDir );

            if ( index >= ( iLength - 1 ))
            {
                fReturn = TRUE;
                break;
            }
        } while ( TRUE );
    } while (FALSE);

    return(fReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\cmakver.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmakver.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of CmakVersion, a utility class that is used to 
//           detect the version of the Connection Mananger Administration Kit
//           that is installed.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created    09/14/98
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"
#include "cmakreg.h"
#include "reg_str.h"

CmakVersion::CmakVersion()
{
    HKEY hKey;
    LONG lResult;

    m_szCmakPath[0] = TEXT('\0');

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszCmakAppPath, 0, KEY_READ, &hKey);

    if (ERROR_SUCCESS == lResult)
    {        
        //
        //  Check to see if we have a path to work from.
        //

        DWORD dwSize = MAX_PATH;
        DWORD dwType = REG_SZ;

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegPath, NULL, &dwType, 
            (LPBYTE)m_szCmakPath, &dwSize))
        {
            //
            //	Now construct the base object
            //
            MYVERIFY(CELEMS(m_szPath) > (UINT)wsprintf(m_szPath, TEXT("%s\\cmak.exe"), m_szCmakPath));

            Init();
        }
    }
}

CmakVersion::~CmakVersion()
{
    //	nothing to do really
}

BOOL CmakVersion::GetInstallLocation(LPTSTR szStr)
{
    if ((m_bIsPresent) && (TEXT('\0') != m_szCmakPath[0]) && (NULL != szStr))
    {
        lstrcpy(szStr, m_szCmakPath);
    }

    return m_bIsPresent;
}

BOOL CmakVersion::Is10Cmak()
{		
    if (m_bIsPresent)
    {
        if ((c_dwVersionSix == m_dwVersion) && (c_dwCmak10BuildNumber == m_dwBuild))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CmakVersion::Is11or12Cmak()
{
//
//  1.1 and 1.2 CMAK had the 1.1 file format (cm32\enu to get to the support files).  This
//  version never shipped in production but was beta-ed
//
    if (m_bIsPresent)
    {
        if ((c_dwVersionSix == m_dwVersion) && (c_dwCmak10BuildNumber < m_dwBuild)
            && (c_dwFirst121BuildNumber > m_dwBuild))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CmakVersion::Is121Cmak()
{
//
//  CMAK 1.21 was the version that shipped in IEAK5 and in NT5 Beta3.  This was the CMAK 1.2 with
//  the updated directory structure (since cm16 was never shipped, the cm16/cm32 directory structure
//  of CMAK was unnecessary).  Thus we have the current support directory structure.
//
    if (m_bIsPresent) 
    {
	    if (((c_dwVersionSeven == m_dwVersion) || (c_dwVersionSix == m_dwVersion)) 
              && (c_dwFirst121BuildNumber < m_dwBuild))
        {
            return TRUE;
        }
    }
    return FALSE;
}

//
//  Cmak 1.22 was the same as CMAK 1.21 except that by this time CM was Unicode enabled and required
//  CMUTOA.DLL to run on Win9x.  Versions of CMAK prior to this one knew nothing of CMUTOA.DLL and
//  thus would not bundle it.  Cmak 1.22 shipped in Win2k.
//
BOOL CmakVersion::Is122Cmak()
{
    if (m_bIsPresent) 
    {	
        if ((c_dwVersionSevenPointOne == m_dwVersion) && 
            (c_dwFirstUnicodeBuildNumber <= m_dwBuild) && 
            (c_dwWin2kRTMBuildNumber >= m_dwBuild))
        {
	        return TRUE;
        }
    }
    return FALSE;
}

//
//  Cmak 1.3 was the version we shipped in Whistler.  This version of CMAK bundled the CM
//  bins from a cab instead of scooping them from the system dir and used the CM exception
//  inf to install CM bins on Win2k.
//
BOOL CmakVersion::Is13Cmak()
{
    if (m_bIsPresent) 
    {	
        if (((c_dwCurrentCmakVersionNumber == m_dwVersion)) && (c_dwWin2kRTMBuildNumber <= m_dwBuild))
        {
	        return TRUE;
        }
    }
    return FALSE;
}

DWORD CmakVersion::GetNativeCmakLCID()
{
    return m_dwLCID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\extractcm.cpp ===
#include <windows.h>
#include <shellapi.h>
//+----------------------------------------------------------------------------
//
// Function:  ExtractCmBinsFromExe
//
// Synopsis:  Launches cmbins.exe to extract the cm binaries from the executable
//            cab file.
//
// Arguments: LPTSTR pszPathToExtractFrom -- path where cmbins.exe lives
//            LPTSTR pszPathToExtractTo -- path to where cm binaries are extracted to
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created      03/14/2001
//
//+----------------------------------------------------------------------------
HRESULT ExtractCmBinsFromExe(LPTSTR pszPathToExtractFrom, LPTSTR pszPathToExtractTo)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPathToExtractTo && (TEXT('\0') != pszPathToExtractTo[0]) &&
        pszPathToExtractFrom && (TEXT('\0') != pszPathToExtractFrom[0])) 
    {
        TCHAR szFile[MAX_PATH+1] = {0};
        TCHAR szParams[MAX_PATH+1] = {0};
        LPCTSTR c_pszParamsFmt = TEXT("/c /q /t:%s");
        LPCTSTR c_pszFileFmt = TEXT("%scmbins.exe");
        LPCTSTR c_pszFileFmtWithSlash = TEXT("%s\\cmbins.exe");

        wsprintf(szParams, c_pszParamsFmt, pszPathToExtractTo);

        if (TEXT('\\') == pszPathToExtractFrom[lstrlen(pszPathToExtractFrom) - 1])
        {
            wsprintf(szFile, c_pszFileFmt, pszPathToExtractFrom);
        }
        else
        {
            wsprintf(szFile, c_pszFileFmtWithSlash, pszPathToExtractFrom);
        }
        
        SHELLEXECUTEINFO  sei = {0};

        sei.cbSize = sizeof(sei);
        sei.fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS;
        sei.nShow = SW_SHOWNORMAL;
        sei.lpFile = szFile;
        sei.lpParameters = szParams;
        sei.lpDirectory = pszPathToExtractFrom;

        if (ShellExecuteEx(&sei))
        {
            if (sei.hProcess)
            {
                WaitForSingleObject(sei.hProcess, 1000*60*1); // wait for one minute.
                CloseHandle(sei.hProcess);
            }

            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            //
            //  Make sure to return failure
            //
            if (SUCCEEDED(hr))
            {
                hr = E_UNEXPECTED;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\cversion.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cversion.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CVersion class, a utility class that 
//           wraps up the functionality for detecting the version of a 
//           given module filename.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"
#include "getmodulever.cpp"

CVersion::CVersion(LPTSTR szFile)
{
    m_bIsPresent = FALSE;
    m_szPath[0] = TEXT('\0');
    DWORD dwVersion = 0;
    DWORD dwBuild = 0;

    if ((NULL != szFile) && (TEXT('\0') != szFile[0]))
    {
        lstrcpy(m_szPath, szFile);
        Init();
    }
}

CVersion::CVersion()
{
    m_bIsPresent = FALSE;
    m_szPath[0] = TEXT('\0');
    DWORD dwVersion = 0;
    DWORD dwBuild = 0;
}

CVersion::~CVersion()
{
    //  nothing to do really
}

void CVersion::Init()
{
    MYDBGASSERT(TEXT('\0') != m_szPath[0]);

    //
    //  Check to see if we have version information
    //

    HRESULT hr = GetModuleVersionAndLCID(m_szPath, &m_dwVersion, &m_dwBuild, &m_dwLCID);
    
    if (SUCCEEDED(hr))
    {
        m_bIsPresent = TRUE;
        CMTRACE3(TEXT("%s has Version = %u.%u"), m_szPath, (DWORD)HIWORD(m_dwVersion), (DWORD)LOWORD(m_dwVersion));
        CMTRACE3(TEXT("%s has Build Number = %u.%u"), m_szPath, (DWORD)HIWORD(m_dwBuild), (DWORD)LOWORD(m_dwBuild));
        CMTRACE2(TEXT("%s has LCID = %u"), m_szPath, m_dwLCID);
    }
}

BOOL CVersion::IsPresent()
{
    return m_bIsPresent;
}

BOOL CVersion::GetVersionString(LPTSTR szStr)
{
    if ((NULL != szStr) && (0 != m_dwVersion))
    {
        MYVERIFY(0 != (UINT)wsprintf(szStr, TEXT("%u.%u"), (DWORD)HIWORD(m_dwVersion), 
            (DWORD)LOWORD(m_dwVersion)));
        return TRUE;
    }

    return FALSE;
}

BOOL CVersion::GetBuildNumberString(LPTSTR szStr)
{
    if ((NULL != szStr) && (0 != m_dwBuild))
    {
        MYVERIFY(0 != (UINT)wsprintf(szStr, TEXT("%u.%u"), (DWORD)HIWORD(m_dwBuild), 
            (DWORD)LOWORD(m_dwBuild)));
        return TRUE;
    }

    return FALSE;
}


BOOL CVersion::GetFilePath(LPTSTR szStr)
{
    if ((m_bIsPresent) && (TEXT('\0') != m_szPath[0]) && (NULL != szStr))
    {
        lstrcpy(szStr, m_szPath);
    }

    return m_bIsPresent;
}


DWORD CVersion::GetVersionNumber()
{
    return m_dwVersion;
}

DWORD CVersion::GetBuildAndQfeNumber()
{
    return m_dwBuild;
}

DWORD CVersion::GetMajorVersionNumber()
{
    return (DWORD)HIWORD(m_dwVersion);
}

DWORD CVersion::GetMinorVersionNumber()
{
    return (DWORD)LOWORD(m_dwVersion);
}

DWORD CVersion::GetBuildNumber()
{
    return (DWORD)HIWORD(m_dwBuild);
}

DWORD CVersion::GetQfeNumber()
{
    return (DWORD)LOWORD(m_dwBuild);
}

DWORD CVersion::GetLCID()
{
    return m_dwLCID;
}

// Note the following is a non-class function:

//+----------------------------------------------------------------------------
//
// Function:  ArePrimaryLangIDsEqual
//
// Synopsis:  Helper routine to compare the Primary Language IDs of two given
//            LCIDs.
//
// Arguments: DWORD dwLCID1 - first LCID
//            DWORD dwLCID2 - second LCID
//
// Returns:   BOOL - TRUE if the LCIDs have the same Primary Language ID
//
// History:   quintinb Created     7/8/99
//
//+----------------------------------------------------------------------------
BOOL ArePrimaryLangIDsEqual(DWORD dwLCID1, DWORD dwLCID2)
{
    WORD wLangId1 = LANGIDFROMLCID(dwLCID1);
    WORD wLangId2 = LANGIDFROMLCID(dwLCID2);

    //
    //  Now Convert the LANG IDs into their respective Primary Lang IDs and compare
    //
    return (PRIMARYLANGID(wLangId1) == PRIMARYLANGID(wLangId2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\cmplat.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmplat.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of CPlatform class
//				use it to query the system for all kinds of platform info
//				OSVersion, machine architecture, etc....
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header   08/19/99
//
//+----------------------------------------------------------------------------

#include "cmplat.h"

//
//	Constants
//
 
const TCHAR* const c_pszSrvOrWksPath = TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions");
const TCHAR* const c_pszProductType = TEXT("ProductType");
const TCHAR* const c_pszSrvString = TEXT("ServerNT");
const TCHAR* const c_pszEntString = TEXT("LanManNT");
const TCHAR* const c_pszWksString = TEXT("WinNT");

//________________________________________________________________________________
//
// Function:  CPlatform constructor
//
// Synopsis:  .initializes the class, all the functions are ready to be used
//
// Arguments: None
//
// Returns:   NONE
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________

CPlatform::CPlatform()
{
    ZeroMemory(&m_SysInfo, sizeof(m_SysInfo));
    GetSystemInfo(&m_SysInfo);	// Does not fail!

    m_OSVer.dwOSVersionInfoSize = sizeof(m_OSVer); 
    if (!GetVersionEx(&m_OSVer)) 
    { 
        m_ClassState = bad; //Something went wrong 
    }
    else
    {
        m_ClassState = good;
    }
}

//________________________________________________________________________________
//
// Function:  IsOS
//
// Synopsis:  
//
// Arguments: DWORD OS, DWORD buildNum
//
// Returns:   BOOL - TRUE means running on OS specified
//
// History:   Created Header    1/30/98
//
//________________________________________________________________________________

BOOL CPlatform::IsOS(DWORD OS, DWORD buildNum)
{

    if (m_OSVer.dwPlatformId != OS)
    {
        return FALSE;
    }

    if ( (m_OSVer.dwBuildNumber & 0xffff) > buildNum) //Check for higher than developer release 
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsOSExact
//
// Synopsis:  
//
// Arguments: DWORD OS, DWORD buildNum
//
// Returns:   BOOL - TRUE means running on OS specified
//
// History:   Created Header    1/30/98
//
//________________________________________________________________________________

BOOL CPlatform::IsOSExact(DWORD OS, DWORD buildNum)
{

    if (m_OSVer.dwPlatformId != OS)
    {
        return FALSE;
    }

    if ((m_OSVer.dwBuildNumber & 0xffff) == buildNum) //Check for exact match
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//________________________________________________________________________________
//
// Function:  IsX86
//
// Synopsis:  Determines if the current platform IsX86.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsX86
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsX86()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    return (m_SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL);
}
//________________________________________________________________________________
//
// Function:  IsAlpha
//
// Synopsis:  Determines if the current platform IsAlpha.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsAlpha
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________
BOOL	
CPlatform::IsAlpha()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    return (m_SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA);
}

//________________________________________________________________________________
//
// Function:  IsIA64
//
// Synopsis:  Determines if the current platform is an IA64 machine.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is an itanium.
//
// History:   quintinb Created    07/20/2000
//
//________________________________________________________________________________
BOOL	
CPlatform::IsIA64()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    return (m_SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64);
}

//________________________________________________________________________________
//
// Function:  IsWin95Gold
//
// Synopsis:  Determines if the current platform IsWin95.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsWin95
//
// History:   quintinb Created 2/20/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsWin95Gold()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if (IsOSExact(VER_PLATFORM_WIN32_WINDOWS, 950))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsWin95
//
// Synopsis:  Determines if the current platform IsWin95Gold.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsWin95Gold
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________

BOOL	
CPlatform::IsWin95()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if ( (IsOS(VER_PLATFORM_WIN32_WINDOWS, 950)) && (!IsOS(VER_PLATFORM_WIN32_WINDOWS, 1352)) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsWin98
//
// Synopsis:  Determines if the current platform IsWin98.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsWin98
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsWin98()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    return IsOS(VER_PLATFORM_WIN32_WINDOWS, 1353);
}

//________________________________________________________________________________
//
// Function:  IsWin98Sr
//
// Synopsis:  Determines if the current platform is a Service Release of Win98 (not
//            win98 gold).
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is a Sr of win98
//
// History:   quintinb created 1-8-99
//
//________________________________________________________________________________

BOOL	
CPlatform::IsWin98Sr()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    
    //
    //  Win98 gold had 1998 for the build number
    //
    return IsOS(VER_PLATFORM_WIN32_WINDOWS, 1998);
}

//________________________________________________________________________________
//
// Function:  IsWin98Gold
//
// Synopsis:  Determines if the current platform is Win98 Gold (build Num 1998)
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is Gold win98
//
// History:   quintinb created 1-8-99
//
//________________________________________________________________________________
BOOL	
CPlatform::IsWin98Gold()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if ((IsOS(VER_PLATFORM_WIN32_WINDOWS, 1353)) && (!IsOS(VER_PLATFORM_WIN32_WINDOWS, 1998)))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsWin9x
//
// Synopsis:  Determines if the current platform IsWin9x.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsWin9x
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsWin9x()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    return IsOS(VER_PLATFORM_WIN32_WINDOWS, 950-1);
}
//________________________________________________________________________________
//
// Function:  IsNT31
//
// Synopsis:  Determines if the current platform IsNT31.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsNT31
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsNT31()
{
    if (bad == m_ClassState)
    {
        return false;
    }

    if ( (IsOS(VER_PLATFORM_WIN32_NT , 0)) && (!IsOS(VER_PLATFORM_WIN32_NT , 1057)) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}
//________________________________________________________________________________
//
// Function:  IsNT351
//
// Synopsis:  Determines if the current platform IsNT351.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsNT351
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsNT351()
{
    if (bad == m_ClassState)
    {
        return false;
    }

    if ( (IsOS(VER_PLATFORM_WIN32_NT , 1056)) && (!IsOS(VER_PLATFORM_WIN32_NT , 1382)) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
//________________________________________________________________________________
//
// Function:  IsNT4
//
// Synopsis:  Determines if the current platform IsNT4.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsNT4
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


BOOL	
CPlatform::IsNT4()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if ( (IsOS(VER_PLATFORM_WIN32_NT , 1380)) && (!IsOS(VER_PLATFORM_WIN32_NT , 1500)) )	//1500 not sure
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsAtLeastNT5
//
// Synopsis:  Determines if the current platform at least NT5.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is NT5 or newer
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________
BOOL	
CPlatform::IsAtLeastNT5()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    return IsOS(VER_PLATFORM_WIN32_NT, 1500);
}

//________________________________________________________________________________
//
// Function:  IsAtLeastNT51
//
// Synopsis:  Determines if the current platform at least NT51.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is NT5 or newer
//
// History:   quintinb Created    02/09/2001
//
//________________________________________________________________________________
BOOL
CPlatform::IsAtLeastNT51()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    return IsOS(VER_PLATFORM_WIN32_NT, 2200);
}

//________________________________________________________________________________
//
// Function:  IsNT5
//
// Synopsis:  Determines if the current platform is NT5.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is NT5
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________
BOOL	
CPlatform::IsNT5()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if ( (IsOS(VER_PLATFORM_WIN32_NT , 1500)) && (!IsOS(VER_PLATFORM_WIN32_NT , 2195)))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//________________________________________________________________________________
//
// Function:  IsNT51
//
// Synopsis:  Determines if the current platform at least NT51.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform is NT51
//
// History:   quintinb Created    02/09/2001
//
//________________________________________________________________________________
BOOL	
CPlatform::IsNT51()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }

    if ((IsOS(VER_PLATFORM_WIN32_NT , 2195)) && (!IsOS(VER_PLATFORM_WIN32_NT , 2600))) // ISSUE quintinb 3/22/01: Update this if we need it.
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//________________________________________________________________________________
//
// Function:  IsNT
//
// Synopsis:  Determines if the current platform IsNT.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsNT
//
// History:   quintinb Created    9/22/1998
//
//________________________________________________________________________________
BOOL	
CPlatform::IsNT()
{
    if (bad == m_ClassState)
    {
        return FALSE;
    }
    return IsOS(VER_PLATFORM_WIN32_NT, 0);
}

//________________________________________________________________________________
//
// Function:  IsNTSrv
//
// Synopsis:  Determines if the current platform IsNT.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current platform IsNT
//
// History:   quintinb Created    9/22/1998
//
//________________________________________________________________________________
BOOL CPlatform::IsNTSrv()
{
    HKEY hKey;
    TCHAR szTemp[MAX_PATH+1];
    BOOL bReturn = FALSE;

    if ((good == m_ClassState)  && (IsOS(VER_PLATFORM_WIN32_NT, 0)))
    {
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, c_pszSrvOrWksPath, &hKey))
        {
            DWORD dwSize = MAX_PATH;
            DWORD dwType = REG_SZ;

            if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszProductType, NULL, &dwType, 
                (LPBYTE)szTemp, &dwSize))
            {
                bReturn = ((0 == lstrcmpi(szTemp, c_pszSrvString)) || 
                    (0 == lstrcmpi(szTemp, c_pszEntString)));
            }

            RegCloseKey(hKey);
        }
    }
    return bReturn;
}

BOOL CPlatform::IsNTWks()
{
    HKEY hKey;
    TCHAR szTemp[MAX_PATH+1];
    BOOL bReturn = FALSE;

    if ((good == m_ClassState)  && (IsOS(VER_PLATFORM_WIN32_NT, 0)))
    {
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, c_pszSrvOrWksPath, &hKey))
        {
            DWORD dwSize = MAX_PATH;
            DWORD dwType = REG_SZ;

            if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszProductType, NULL, &dwType, 
                (LPBYTE)szTemp, &dwSize))
            {
                bReturn = (0 == lstrcmpi(szTemp, c_pszWksString));
            }

            RegCloseKey(hKey);
        }
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\fileexists.cpp ===
//+----------------------------------------------------------------------------
//
// File:     fileexists.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the FileExists function.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"

//+----------------------------------------------------------------------------
//
// Function:  FileExists
//
// Synopsis:  Helper function to encapsulate determining if a file exists. 
//
// Arguments: LPCTSTR pszFullNameAndPath - The FULL Name and Path of the file.
//
// Returns:   BOOL - TRUE if the file is located
//
// History:   nickball    Created    3/9/98
//
//+----------------------------------------------------------------------------
BOOL FileExists(LPCTSTR pszFullNameAndPath)
{
    MYDBGASSERT(pszFullNameAndPath);

    if (pszFullNameAndPath && pszFullNameAndPath[0])
    {
        HANDLE hFile = CreateFile(pszFullNameAndPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            return TRUE;
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\nativecm.cpp ===
//+----------------------------------------------------------------------------
//
// File:     nativecm.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CmIsNative function.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created       01/14/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"
#include "reg_str.h"



//+----------------------------------------------------------------------------
//
// Function:  CmIsNative
//
// Synopsis:  This function Returns TRUE if CM is native to the current OS.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if CM is native.
//
// History:   Created Header    1/17/99
//            quintinb NTRAID 364533 -- Changed IsNative so that Win98 SE won't be
//                     considered Native even if CmNative is set to 1.  See below
//                     and the bug for details.
//
//+----------------------------------------------------------------------------
BOOL CmIsNative()
{
    static BOOL bCmNotNative = -1;

    if (-1 == bCmNotNative)
    {
        const TCHAR* const c_pszRegCmNative = TEXT("CmNative");
        HKEY hKey;
        DWORD dwCmNative;

        ZeroMemory(&dwCmNative, sizeof(DWORD));

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmAppPaths, 0, KEY_READ, &hKey))
        {
            DWORD dwSize = sizeof(DWORD);
            DWORD dwType = REG_DWORD;

            if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegCmNative, NULL, &dwType, 
                (LPBYTE)&dwCmNative, &dwSize))
            {
                CPlatform cmplat;

                if (cmplat.IsWin98Sr())
                {
                    //
                    //  We no longer want Win98 SE to be native even though the key was set and
                    //  CM is a system component.  However, we may want to give ourselves an out
                    //  someday so if CmNative is set to 2 on win98 SE we will still consider it Native.
                    //  We hopefully will never need this but we might.
                    //
                    bCmNotNative = (2 != dwCmNative);
                }
                else
                {                
                    bCmNotNative = (dwCmNative ? 0 : 1);
                }
            }
            else
            {
               bCmNotNative = 1;
            }
            RegCloseKey(hKey);
        }
        else
        {
            bCmNotNative = 1;
        }
    }

    return !bCmNotNative;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\processcmdln.cpp ===
//+----------------------------------------------------------------------------
//
// File:     processcmdln.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CProcessCmdLn class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"
#include "setupmem.h"

//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::CProcessCmdLn
//
// Synopsis:  Inits the class by copying the valid command line switches to the
//            command line switch array.
//
// Arguments: UINT NumSwitches - Number of switches in the array
//            UINT NumCharsInSwitch - Number of chars in each switch, counting the terminating NULL
//            TCHAR pszCommandLineSwitches[][] - Array of command line switches.
//
// Returns:   Nothing
//
// History:   quintinb  Created     7/24/98
//
//+----------------------------------------------------------------------------
CProcessCmdLn::CProcessCmdLn(UINT NumSwitches, ArgStruct* pArrayOfArgStructs, 
							 BOOL bSkipFirstToken, BOOL bBlankCmdLnOkay)
{
    m_NumSwitches = NumSwitches;
    m_bSkipFirstToken = bSkipFirstToken;
    m_bBlankCmdLnOkay = bBlankCmdLnOkay;
    m_CommandLineSwitches = NULL;

    m_CommandLineSwitches = (ArgStruct*)CmMalloc(m_NumSwitches*sizeof(ArgStruct));

    if (m_CommandLineSwitches)
    {
        for(UINT i =0; i < NumSwitches; i++)
        {
            m_CommandLineSwitches[i].pszArgString = 
                (TCHAR*)CmMalloc(sizeof(TCHAR)*(lstrlen(pArrayOfArgStructs[i].pszArgString) + 1));

            if (m_CommandLineSwitches[i].pszArgString)
            {
                lstrcpyn(m_CommandLineSwitches[i].pszArgString, 
                    pArrayOfArgStructs[i].pszArgString, 
                    (lstrlen(pArrayOfArgStructs[i].pszArgString) + 1));

                m_CommandLineSwitches[i].dwFlagModifier = pArrayOfArgStructs[i].dwFlagModifier;
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::~CProcessCmdLn
//
// Synopsis:  Cleans up after the class by deleting the dynamically allocated
//            string.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    7/24/98
//
//+----------------------------------------------------------------------------
CProcessCmdLn::~CProcessCmdLn()
{
    if (m_CommandLineSwitches)
    {
        for(UINT i =0; i < m_NumSwitches; i++)
        {
            CmFree(m_CommandLineSwitches[i].pszArgString);			
        }
        CmFree(m_CommandLineSwitches);
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::IsValidSwitch
//
// Synopsis:  This function tells whether the inputed switch is a recognized
//            command line switch.
//
// Arguments: LPCTSTR pszSwitch - Input switch string to be tested
//
// Returns:   BOOL - Returns TRUE if the switch passed in is recognized as valid
//
// History:   quintinb Created    7/13/98
//
//+----------------------------------------------------------------------------
BOOL CProcessCmdLn::IsValidSwitch(LPCTSTR pszSwitch, LPDWORD pdwFlags)
{
    for (UINT i = 0; i < m_NumSwitches; i++)
    {
        if (m_CommandLineSwitches[i].pszArgString && (0 == lstrcmpi(m_CommandLineSwitches[i].pszArgString, pszSwitch)))
        {
            //
            //  Then we have a match
            //
            *pdwFlags |= m_CommandLineSwitches[i].dwFlagModifier;
            return TRUE;
        }
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::IsValidFilePath
//
// Synopsis:  This file checks to see if the inputted file path is a valid filepath.
//            This function depends on setfileattributes.
//
// Arguments: LPCTSTR pszFile - File to check to see if it exists.
//
// Returns:   BOOL - Returns TRUE if we can set the attributes of the file inputed.
//
// History:   quintinb Created   7/13/98
//
//+----------------------------------------------------------------------------
BOOL CProcessCmdLn::IsValidFilePath(LPCTSTR pszFile)
{
     return SetFileAttributes(pszFile, FILE_ATTRIBUTE_NORMAL);
}



//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::EnsureFullFilePath
//
// Synopsis:  This file checks to see if a file path passed in is a full path.
//            If it is not a full path then it adds the current directory path
//            to the beginning (assuming that we have a filename and extension).
//
// Arguments: LPTSTR pszFile - File to check
//            UINT uNumChars - Number of chars in the buffer holding pszFile
//
// Returns:   BOOL - TRUE if a full file path
//
// History:   quintinb  Created    7/24/98
//
//+----------------------------------------------------------------------------
BOOL CProcessCmdLn::EnsureFullFilePath(LPTSTR pszFile, UINT uNumChars)
{
    BOOL bReturn = FALSE;

    if (SetFileAttributes(pszFile, FILE_ATTRIBUTE_NORMAL))
    {
        CFileNameParts InstallFileParts(pszFile);

        if ((TEXT('\0') == InstallFileParts.m_Drive[0]) && 
            (TEXT('\0') == InstallFileParts.m_Dir[0]) &&
            (TEXT('\0') != InstallFileParts.m_FileName[0]) &&
            (TEXT('\0') != InstallFileParts.m_Extension[0]))
        {
            //
            //  Then we have a filename and extension but we don't
            //  have a full path.  Thus we want to add the current
            //  directory onto the filename and extension.
            //
            TCHAR szTemp[MAX_PATH+1];

            if (GetCurrentDirectory(MAX_PATH, szTemp))
            {
                if (uNumChars > (UINT)(lstrlen(szTemp) + lstrlen(InstallFileParts.m_FileName) + lstrlen(InstallFileParts.m_Extension) + 2))
                {
                    wsprintf(pszFile, TEXT("%s\\%s%s"), szTemp, InstallFileParts.m_FileName, InstallFileParts.m_Extension);
                    bReturn = TRUE;
                }
            }
        }
        else
        {
            //
            //  Could be a UNC path, a path with a drive letter and filename, or
            //  a full path with a drive and a dir
            //
            bReturn = TRUE;
        }
    }

    return bReturn;
}




//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::CheckIfValidSwitchOrPath
//
// Synopsis:  Bundles code to determine if a token is a valid switch or path.
//
// Arguments: LPCTSTR pszToken - current token
//            BOOL* pbFoundSwitch - pointer to the BOOL which tells if a switch has been found yet
//            BOOL* pbFoundPath - pointer to the BOOL which tells if a path has been found yet
//            LPTSTR pszSwitch - string to hold the switch
//            LPTSTR pszPath - string to hold the path
//
// Returns:   BOOL - returns TRUE if successful
//
// History:   quintinb Created    8/25/98
//
//+----------------------------------------------------------------------------
BOOL CProcessCmdLn::CheckIfValidSwitchOrPath(LPCTSTR pszToken, LPDWORD pdwFlags, 
                              BOOL* pbFoundPath, LPTSTR pszPath)
{
    if (IsValidSwitch(pszToken, pdwFlags))
    {
        CMTRACE1(TEXT("ProcessCmdLn - ValidSwitch is %s"), pszToken);
    }
    else if (!(*pbFoundPath))
    {
        if (IsValidFilePath(pszToken))
        {
            *pbFoundPath = TRUE;
            lstrcpy(pszPath, pszToken);

            CMTRACE1(TEXT("ProcessCmdLn - ValidFilePath is %s"), pszToken);
        }
        else
        {
            //
            //  Maybe the path contains environment variables, try to expand them.
            //
            TCHAR szExpandedPath[MAX_PATH+1] = TEXT("");

            CMTRACE1(TEXT("ProcessCmdLn - %s is not a valid path, expanding environment strings"), pszToken);
            
            ExpandEnvironmentStrings(pszToken, szExpandedPath, MAX_PATH);

            CMTRACE1(TEXT("ProcessCmdLn - expanded path is %s"), szExpandedPath);
                        
            if (IsValidFilePath(szExpandedPath))
            {
                *pbFoundPath = TRUE;
                lstrcpy(pszPath, szExpandedPath);
            }
            else
            {
                //
                //  Still no luck, return an error
                //
                CMTRACE1(TEXT("ProcessCmdLn - %s is not a valid path"), szExpandedPath);

                return FALSE;
            }
        }
    }
    else
    {
        //
        //  We don't know what this is, send back an error
        //
        CMTRACE1(TEXT("ProcessCmdLn - Invalid token is %s"), pszToken);
        
        return FALSE;                    
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  CProcessCmdLn::GetCmdLineArgs
//
// Synopsis:  This function looks for any combination of just a command line 
//            switch, just a path, or both.  Handles long paths if quoted. 
//              
//
// Arguments: IN LPTSTR pszCmdln - the command line to parse 
//            OUT LPTSTR pszSwitch - Out parameter for the command line switch
//            OUT LPTSTR pszPath -  Out parameter for the path
//
// Returns:   BOOL - Returns TRUE if it was able to parse the args
//
//  History:    quintinb    rewrote InitArgs from cmmgr.cpp to make it
//                          simpler and more taylored to cmstp.     7-13-98
//              
//----------------------------------------------------------------------------
BOOL CProcessCmdLn::GetCmdLineArgs(IN LPTSTR pszCmdln, OUT LPDWORD pdwFlags, OUT LPTSTR pszPath, 
					UINT uPathStrLimit)
{
    LPTSTR  pszCurr;
    LPTSTR  pszToken;
    CMDLN_STATE state;
    BOOL bFoundSwitch = FALSE;
    BOOL bFoundPath = FALSE;

	if ((NULL == pdwFlags) || (NULL == pszPath))
	{
		return FALSE;
	}

	//
	//	Init pdwFlags to Zero
	//
	*pdwFlags = 0;

	//
	//	If m_bSkipFirstToken is TRUE, the we will skip the first Token.  Otherwise,
	//  we won't.
	//
    BOOL bFirstToken = m_bSkipFirstToken;
	
    state = CS_CHAR;
    pszCurr = pszToken = pszCmdln;

    CMTRACE1(TEXT("CProcessCmdLn::GetCmdLineArgs - Command line is %s"), pszCmdln);

    do
    {
        switch (*pszCurr)
        {
            case TEXT(' '):
                if (state == CS_CHAR)
                {
                    //
                    // we found a token
                    //

                    *pszCurr = TEXT('\0');
                    if (bFirstToken)
                    {
                        //
                        //  The first token is the name of the exe, thus throw it away
                        //
                        bFirstToken = FALSE;
                        CMTRACE1(TEXT("Throwing away, first token: %s"), pszToken);
                    }
                    else if(!CheckIfValidSwitchOrPath(pszToken, pdwFlags, &bFoundPath, 
                             pszPath))
                    {
                        //
                        //  return an error
                        //
                        return FALSE;
                    }
                 
                    *pszCurr = TEXT(' ');
                    pszCurr = pszToken = CharNext(pszCurr);
                    state = CS_END_SPACE;
                    continue;
                }
                else if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    pszToken = CharNext(pszToken);
                }
                break;

            case TEXT('\"'):
                if (state == CS_BEGIN_QUOTE)
                {
                    //
                    // we found a token
                    //
                    *pszCurr = TEXT('\0');

                    //
                    // skip the opening quote
                    //
                    pszToken = CharNext(pszToken);
                    if (bFirstToken)
                    {
                        //
                        //  The first token is the name of the exe, thus throw it away
                        //
                        bFirstToken = FALSE;
                        CMTRACE1(TEXT("Throwing away, first token: %s"), pszToken);
                    }
                    else if(!CheckIfValidSwitchOrPath(pszToken, pdwFlags, &bFoundPath, 
                             pszPath))
                    {
                        //
                        //  return an error
                        //
                        return FALSE;
                    }
                    
                    *pszCurr = TEXT('\"');
                    pszCurr = pszToken = CharNext(pszCurr);
                    state = CS_END_QUOTE;
                    continue;
                }
                else
                {
                    state = CS_BEGIN_QUOTE;
                }
                break;

            case TEXT('\0'):
                if (state != CS_END_QUOTE)
                {
                    if (bFirstToken)
                    {
                        //
                        //  The first token is the name of the exe, thus throw it away
                        //
                        bFirstToken = FALSE;
                        CMTRACE1(TEXT("Throwing away, first token: %s"), pszToken);
                    }
                    else if(!CheckIfValidSwitchOrPath(pszToken, pdwFlags, &bFoundPath, 
                             pszPath))
                    {
                        //
                        //  return an error
                        //
                        return FALSE;
                    }
                }
                state = CS_DONE;
                break;

            default:
                if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    state = CS_CHAR;
                }
                break;
        }
        
        pszCurr = CharNext(pszCurr);
    } while (state != CS_DONE);


    if (bFoundPath)
    {
        //
        //  Then at least we found a path (and maybe switches, maybe not)
        //
        return EnsureFullFilePath(pszPath, uPathStrLimit);
    }
    else if (0 != *pdwFlags)
    {
        //
        //  Then at least we found a switch
        //
        return TRUE;
    }
    else
    {
		//
		//	If it is okay to have a blank command line, then this is okay, otherwise it isn't.
		//  Note that if m_bSkipFirstToken == TRUE, then the command line might not be completely
		//  blank, it could contain the name of the executable for instance.
		//
		return m_bBlankCmdLnOkay;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\regutil.cpp ===
//+----------------------------------------------------------------------------
//
// File:     regutil.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the CmDeleteRegKeyWithoutSubKeys function.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"

//+----------------------------------------------------------------------------
//
// Function:  CmDeleteRegKeyWithoutSubKeys
//
// Synopsis:  This function is used to safely delete keys on both Winnt and win95.
//            The win95 version of RegDeleteKey will delete a key with subkeys.
//            In certain situations this is desirable but in others it is not.
//
// Arguments: HKEY hBaseKey - key that pszSubKey is relative to (usually a predefined key)
//            LPCTSTR pszSubKey - String containing the subkey to delete.
//            BOOL bIgnoreValues - if TRUE, we delete even if values exist
//                                 if FALSE, then we won't delete if values exist.
//
// Returns:   LONG - Returns the value from RegDeleteKey unless it couldn't find the
//                   key specified (then returns ERROR_FILE_NOT_FOUND).  If the key
//                   exists but has subkeys (or values if bIgnoreValues == FALSE), then 
//                   it returns ERROR_FILE_EXISTS.
//
// History:   quintinb Created    9/21/98
//
//+----------------------------------------------------------------------------
LONG CmDeleteRegKeyWithoutSubKeys(HKEY hBaseKey, LPCTSTR pszKey, BOOL bIgnoreValues)
{
    DWORD dwSubKeys;
    DWORD dwValues;
    HKEY hKey = NULL;
    LPTSTR pszSubKey = NULL;
    LONG lReturn = ERROR_INVALID_PARAMETER;
    BOOL bFreePszSubKey = FALSE;

    if (hBaseKey && pszKey)
    {
        //
        //  First check to see if the subkey ends with a final slash.  If it
        //  does we need to remove it because the win9x versions of the registry
        //  APIs don't deal well with trailing slashes.
        //
        DWORD dwLen = lstrlen(pszKey);
        if (TEXT('\\') == pszKey[dwLen-1])
        {
            pszSubKey = (LPTSTR)CmMalloc((dwLen +1)*sizeof(TCHAR));
            if (pszSubKey)
            {
                lstrcpy(pszSubKey, pszKey);
                pszSubKey[dwLen-1] = TEXT('\0');
                bFreePszSubKey = TRUE; // we allocated it, so we need to delete it.
            }
            else
            {
                lReturn = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }
        else
        {
            pszSubKey = (LPTSTR)pszKey;
        }

        //
        //  Now open the key, check for values and subkeys, and then delete
        //  the key if it is appropriate.
        //
        if (ERROR_SUCCESS == RegOpenKeyEx(hBaseKey, pszSubKey, 0, KEY_ALL_ACCESS, &hKey))
        {
            if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwSubKeys, NULL,
                                                 NULL, &dwValues, NULL, NULL, NULL, NULL))
            {
                if ((0 == dwSubKeys) && (bIgnoreValues || (0 == dwValues)))
                {
                    lReturn = RegDeleteKey(hBaseKey, pszSubKey);
                    goto exit;
                }
                else
                {
                    lReturn = ERROR_FILE_EXISTS;
                    goto exit;
                }
            }
        }

        lReturn = ERROR_FILE_NOT_FOUND;
    }

exit:

    if (hKey)
    {
        RegCloseKey(hKey);        
    }

    if (bFreePszSubKey)
    {
        CmFree(pszSubKey);
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\setupmem.cpp ===
//+----------------------------------------------------------------------------
//
// File:     regutil.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Memory utility functions taken from cmutil.  Bare minimum of functionality
//           used in Cmutil, but gives a simple Heapalloc wrapper.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb       Created     10/06/98
//
//+----------------------------------------------------------------------------
#ifndef __SETUPMEM_CPP
#define __SETUPMEM_CPP
#include "cmsetup.h"

//+----------------------------------------------------------------------------
// definitions
//+----------------------------------------------------------------------------

#ifdef DEBUG
LONG    g_lMallocCnt = 0;  // a counter to detect memory leak
#endif

void *CmRealloc(void *pvPtr, size_t nBytes) 
{
	void* p = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pvPtr, nBytes);

    CMASSERTMSG(p, TEXT("CmRealloc failed"));

    return p;
}


void *CmMalloc(size_t nBytes) 
{
#ifdef DEBUG
	InterlockedIncrement(&g_lMallocCnt);
#endif

    MYDBGASSERT(nBytes < 1024*1024); // It should be less than 1 MB
    
    void* p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nBytes);
    
    CMASSERTMSG(p, TEXT("CmMalloc failed"));

    return p;
}


void CmFree(void *pvPtr) 
{
	if (pvPtr) 
    {	
	    MYVERIFY(HeapFree(GetProcessHeap(), 0, pvPtr));

#ifdef DEBUG
	    InterlockedDecrement(&g_lMallocCnt);
#endif
    
    }
}


void EndDebugMemory()
{
#ifdef DEBUG
    if (g_lMallocCnt)
    {
        TCHAR buf[256];
        wsprintf(buf, TEXT("Detect Memory Leak of %d blocks"), g_lMallocCnt);
        CMASSERTMSG(FALSE, buf);
    }
#endif
}

#endif //__SETUPMEM_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmsetup\launchinf.cpp ===
//+----------------------------------------------------------------------------
//
// File:     launchinf.cpp
//
// Module:   CMSETUP.LIB
//
// Synopsis: Implementation of the LaunchInfSection function.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb       Created Header        09/19/99
//
//+----------------------------------------------------------------------------
#include "cmsetup.h"
#include <advpub.h> // advpack.dll (IExpress) includes

//+----------------------------------------------------------------------------
//
// Function:  LaunchInfSection
//
// Synopsis:  Launches an specified inf section in a specified inf file using
//            advpack.dll's RunSetupCommand Function.
//
// Arguments: HINSTANCE hInstance - Instance Handle for string resources
//            LPCTSTR szInfFile - Inf file
//            LPCTSTR szInfSection - section to launch
//
// Returns:   HRESULT -- return code from advpack.dll's RunSetupCommand Function
//
// History:   Anas Jarrah A-anasj Created    2/10/98
//            quintinb  added hInstance to signature and modified to use
//                      CDynamicLibrary class       7-14-98
//            quintinb  added bQuiet Flag           7-27-98
//            quintinb  changed to use static linking to advpack.lib   11-1-98
//
//+----------------------------------------------------------------------------
HRESULT LaunchInfSection(LPCTSTR szInfFile, LPCTSTR szInfSection, LPCTSTR szTitle, BOOL bQuiet)
{

    //
    //  These flags control how the Inf Files are launched.
    //

    DWORD dwFlags;
    if (bQuiet)
    {
        dwFlags = RSC_FLAG_INF | RSC_FLAG_QUIET;
    }
    else
    {
        dwFlags = RSC_FLAG_INF;
    }
    
    //
    // holds return value of the calls to RunSetupCommand
    //
    HRESULT hrReturn;   
    
    //
    //	Set the current directory to the dir where the inf is located.
    //
    CHAR   szCurDir[MAX_PATH+1];
    CFileNameParts InfFile(szInfFile);
    
#ifdef UNICODE
    MYVERIFY(CELEMS(szCurDir) > (UINT)wsprintfA(szCurDir, "%S%S", InfFile.m_Drive, InfFile.m_Dir));
#else
    MYVERIFY(CELEMS(szCurDir) > (UINT)wsprintfA(szCurDir, "%s%s", InfFile.m_Drive, InfFile.m_Dir));
#endif


    HANDLE hWait = NULL;    // passed to the RunSetupCommand function.  Can be used to hold a process handle

    //
    //  Create the Char pointers to pass to RunSetupCommand
    //
    CHAR* pszInfFile;
    CHAR* pszInfSection;
    CHAR* pszTitle;

    //
    //  There is no UNICODE version of RunSetupCommand.  Thus we must convert strings and
    //  run it with the CHAR versions.
    //
#ifdef UNICODE

    pszInfFile = (CHAR*)CmMalloc(sizeof(CHAR)*(MAX_PATH+1));
    pszInfSection = (CHAR*)CmMalloc(sizeof(CHAR)*(MAX_PATH+1));
    pszTitle = (CHAR*)CmMalloc(sizeof(CHAR)*(MAX_PATH+1));

    if (pszInfFile && pszInfSection && pszTitle)
    {
        MYVERIFY (0 != WideCharToMultiByte(CP_ACP, 0, szInfFile, -1, 
		        pszInfFile, MAX_PATH, NULL, NULL));

        MYVERIFY (0 != WideCharToMultiByte(CP_ACP, 0, szInfSection, -1, 
		        pszInfSection, MAX_PATH, NULL, NULL));

        MYVERIFY (0 != WideCharToMultiByte(CP_ACP, 0, szTitle, -1, 
		        pszTitle, MAX_PATH, NULL, NULL));	
    }
    else
    {
        CmFree(pszInfFile);
        CmFree(pszInfSection);
        CmFree(pszTitle);

        return E_OUTOFMEMORY;
    }

#else

    pszInfFile = (char*)szInfFile;
    pszInfSection = (char*)szInfSection;
    pszTitle = (char*)szTitle;

#endif

    hrReturn = RunSetupCommand(NULL, pszInfFile, 
                    pszInfSection, szCurDir, pszTitle, &hWait, dwFlags, NULL);

    CloseHandle(hWait);

#ifdef UNICODE

    //
    //  Free the Allocated Buffers
    //
    CmFree(pszInfFile);
    CmFree(pszInfSection);
    CmFree(pszTitle);
#endif

    return hrReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CallLaunchInfSectionEx
//
// Synopsis:  Launches an specified inf section in a specified inf file using
//            advpack.dll's RunSetupCommand Function.
//
// Arguments: LPCSTR pszInfFile - full path to the Inf file
//            LPCSTR pszInfSection - section to launch from the inf file
//            DWORD dwFlags - flags to give LaunchINFSectionEx, see advpub.h for more details
//
// Returns:   HRESULT -- standard COM error codes.  If ERROR_SUCCESS_REBOOT_REQUIRED,
//                       is returned, the caller should ask the user to reboot.
//                       
//
// History:   quintinb  created         02/09/2001
//
//+----------------------------------------------------------------------------
HRESULT CallLaunchInfSectionEx(LPCSTR pszInfFile, LPCSTR pszInfSection, DWORD dwFlags)
{
    //
    //  Check the inputs
    //
    if ((NULL == pszInfFile) || (NULL == pszInfSection) || (TEXT('\0') == pszInfFile[0]) || (TEXT('\0') == pszInfSection[0]))
    {
        return E_INVALIDARG;
    }

    //
    //  Now calculate how large of a buffer we will need to send to LaunchINFSectionEx with the params and allocate it.
    //
    DWORD dwSize = (lstrlenA(pszInfFile) + lstrlenA(pszInfSection) + 10 + 2 + 1)*sizeof(CHAR); // 10 chars is max size of a DWORD + 2 commas + a NULL

    LPSTR pszParams = (LPSTR)CmMalloc (dwSize);

    if (NULL == pszParams)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Fill in the allocated buffer
    //
    wsprintfA(pszParams, "%s,%s,,%d", pszInfFile, pszInfSection, dwFlags);

    //
    //  Call LaunchINFSectionEx
    //
    HRESULT hr = LaunchINFSectionEx(NULL, NULL, pszParams, 0);

    if (FAILED(hr))
    {
        CMTRACE3A("CallLaunchInfSectionEx -- LaunchINFSectionEx on file ""%s"" and section ""%s"" FAILED!  hr=0x%x", pszInfFile, pszInfSection, hr);
    }
    else
    {
        if (ERROR_SUCCESS_REBOOT_REQUIRED == hr)
        {
            CMTRACE2A("CallLaunchInfSectionEx -- LaunchINFSectionEx on file ""%s"" and section ""%s"" returned reboot required.", pszInfFile, pszInfSection);
        }    
    }

    CmFree(pszParams);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//
// Module:   CMSTP.EXE
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    08/19/99
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include "common.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\cmstp.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmstp.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This file is the main function for the CM profile installer.  This
//           file basically processes command line switches for the installer and
//           then launches the appropriate function.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/13/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "installerfuncs.h"
#include "cmstpex.h"
//
//  Text Constants
//
static const TCHAR CMSTPMUTEXNAME[] = TEXT("Connection Manager Profile Installer Mutex");


//
//  Global Dynamic Library Classes to hold the ras dll's and shell32.  See
//  the EnsureRasDllsLoaded and the EnsureShell32Loaded in common.cpp/common.h
//
CDynamicLibrary* g_pRasApi32 = NULL;
CDynamicLibrary* g_pRnaph = NULL;
CDynamicLibrary* g_pShell32 = NULL;
CDynamicLibrary* g_pNetShell = NULL;


//
//  Function Headers
//
BOOL PromptUserToUninstallProfile(HINSTANCE hInstance, LPCTSTR pszInfFile); // from uninstall.cpp
BOOL PromptUserToUninstallCm(HINSTANCE hInstance); // from uninstallcm.cpp


//
//  Enum for the LastManOut function which follows.
//
typedef enum _UNINSTALLTYPE
{
    PROFILEUNINSTALL,   // a profile is being uninstalled
    CMUNINSTALL        // the cm bits themselves are being uninstalled.

} UNINSTALLTYPE;


//+----------------------------------------------------------------------------
//
// Function:  LastManOut
//
// Synopsis:  This function determines if the current uninstall action is the
//            last uninstall action which should then delete cmstp.exe.  If the
//            uninstall action is a profile uninstall we need to check that 
//            cm has already been uninstalled and that there is only one profile
//            installed currently (the one we are about to delete).  If the
//            uninstall action is uninstalling CM then we need to make sure there
//            are no other profiles on the machine.  Notice that this function
//            never returns TRUE on Native CM platforms.  If it did, then cmstp.exe
//            would be deleted inadvertently even though UninstallCm wouldn't
//            actually delete the rest of CM.
//
// Arguments: UNINSTALLTYPE UninstallType - an enum value which tells if this is
//                                          a profile uninstall or a CM uninstall.
//
// Returns:   BOOL - TRUE if this install is the last one out and cmstp.exe should
//                   be deleted.
//
// History:   quintinb Created     6/28/99
//
//+----------------------------------------------------------------------------
BOOL LastManOut(UNINSTALLTYPE UninstallType, LPCTSTR pszInfFile)
{
    BOOL bReturn = FALSE;

    //
    //  First check to make sure that remcmstp.inf doesn't exist in the system
    //  directory.  If it does, then we know that Cmstp.exe has already determined
    //  that it is the last man and should delete itself.  Thus it wrote the cmstp.exe
    //  command into remcmstp.inf and the inf engine will delete cmstp.exe when it is done.
    //  Thus we need to check for this file and if it exists return FALSE.
    //

    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];

    if (0 == GetSystemDirectory(szSystemDir, CELEMS(szSystemDir)))
    {
        CMASSERTMSG(FALSE, TEXT("LastManOut -- Unable to obtain a path to the System Directory"));
        return FALSE;
    }
    
    wsprintf(szTemp, TEXT("%s\\remcmstp.inf"), szSystemDir);
    
    if (FileExists(szTemp))
    {
        CMTRACE1(TEXT("\tDetected remcmstp.inf, not setting last man out -- Process ID is 0x%x "), GetCurrentProcessId());
        Sleep(2000); // we sleep here to put a little delay in the processing to let any other copies
                     // of cmstp.exe clean themselves up.  I found that on a system with several copies of
                     // cmstp.exe all deleting profiles and then a cmstp to delete CM, not all of the cmstps
                     // would clean up in time and thus cmstp.exe wouldn't get deleted.  A sleep is hokey, but
                     // two seconds in the last man out situation only fixes it and it no down level user should
                     // ever have 8 profiles (which was home many I tested it with) let alone delete them 
                     // all at once.  It works fine for deleting two profiles and CM simultaneously either way.
        return FALSE;
    }

    //
    //  Make sure that we aren't trying to Remove cmstp.exe on a platform where CM is Native.
    //  If CM is Native, then always return FALSE because the CM uninstall function won't
    //  uninstall CM and we don't want to accidently delete cmstp.exe.
    //

    if (!CmIsNative())
    {
        if (PROFILEUNINSTALL == UninstallType)
        {
            //
            //  We are uninstalling a profile.  We need to check to see if CM has been deleted and
            //  if there are any other profiles on the machine besides the one we are going to delete.
            //
            wsprintf(szTemp, TEXT("%s\\cmdial32.dll"), szSystemDir);

            if (!FileExists(szTemp))
            {
                //
                //  Then we know that CM is already gone.  We need to check and see if any other
                //  profiles exist besides the one we are about to delete.
                //
                HKEY hKey;
                DWORD dwNumValues;
                TCHAR szServiceName[MAX_PATH+1];

                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
                    KEY_READ, &hKey))
                {
                    if ((ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, 
                        &dwNumValues, NULL, NULL, NULL, NULL)) && (dwNumValues == 1))
                    {
                        //
                        //  Then we have only the one profile mappings key, is it the correct one?
                        //
                        if (0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, 
                                                         TEXT(""), szServiceName, MAX_PATH, pszInfFile))
                        {
                            DWORD dwSize = MAX_PATH;
                            LONG lResult = RegQueryValueEx(hKey, szServiceName, NULL, 
                                                           NULL, (LPBYTE)szTemp, &dwSize);

                            if ((ERROR_SUCCESS == lResult) && (TEXT('\0') != szTemp[0]))
                            {
                                CMTRACE1(TEXT("\tDetected Last Man Out -- Process ID is 0x%x "), GetCurrentProcessId());
                                bReturn = TRUE;
                            }                            
                        }
                    }
                    RegCloseKey(hKey);
                }
            }
        }
        else if (CMUNINSTALL == UninstallType)
        {
            //
            //  We are uninstalling CM.  We want to make sure that we don't have any profiles
            //  still installed.  If not, then we are the last man out.
            //
            if (!AllUserProfilesInstalled())
            {
                CMTRACE1(TEXT("\tDetected Last Man Out -- Process ID is 0x%x "), GetCurrentProcessId());
                bReturn = TRUE;
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("LastManOut -- Unknown Uninstall Type"));
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ExtractInfAndRelaunchCmstp
//
// Synopsis:  This function is used to cleanup Cmstp.exe in the last man out
//            scenario.  In order to not leave cmstp.exe on a users machine,
//            we must extract remcmstp.inf and write the uninstall command to it.
//            That way, the inf will monitor the cmstp.exe process and when it is
//            finished it can then delete cmstp.exe.
//
// Arguments: HINSTANCE hInstance - Instance handle to load resources
//            DWORD dwFlags - Command line param flags
//            LPCTSTR szInfPath - path to the inf file.
//
// Returns:   BOOL -- TRUE if Successful
//
// History:   quintinb Created    6/28/99
//
//+----------------------------------------------------------------------------
BOOL ExtractInfAndRelaunchCmstp(HINSTANCE hInstance, DWORD dwFlags, LPCTSTR pszInfPath)
{

    //
    //  Check Parameters
    //

    if (0 == dwFlags || NULL == pszInfPath || TEXT('\0') == pszInfPath[0])
    {
        CMASSERTMSG(FALSE, TEXT("Invalid Paramater passed to ExtractInfAndRelaunchCmstp."));
        return FALSE;
    }

    //
    //  Get the Path to the System Directory
    //
    TCHAR szSystemDir[MAX_PATH+1];
    if (0 == GetSystemDirectory(szSystemDir, CELEMS(szSystemDir)))
    {
        CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unable to obtain a path to the System Directory"));
        return FALSE;
    }

    //
    //  Extract remcmstp.inf
    //
    HGLOBAL hRemCmstp = NULL;
    LPTSTR pszRemCmstpInf = NULL;
    HRSRC hResource = FindResource(hInstance, MAKEINTRESOURCE(IDT_REMCMSTP_INF), TEXT("REGINST"));

    if (hResource)
    {
        hRemCmstp = LoadResource(hInstance, hResource);

        if (hRemCmstp)
        {
            //
            //  Note that we don't need to call FreeResource, which is obsolete, this
            //  will be cleaned up when cmstp.exe exits.
            //
            pszRemCmstpInf = (LPTSTR)LockResource(hRemCmstp);
        }
    }

    //
    //  Now that we have the remcmstp.inf file that is stored in the cmstp.exe resource
    //  loaded into memory and have a pointer to it, lets create the file that we are
    //  going to write it out to.
    //
    if (pszRemCmstpInf)
    {
        TCHAR szRemCmstpPath[MAX_PATH+1];
        wsprintf(szRemCmstpPath, TEXT("%s\\remcmstp.inf"), szSystemDir);

        HANDLE hFile = CreateFile(szRemCmstpPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL, NULL);

        if (INVALID_HANDLE_VALUE != hFile)
        {
            //
            //  Then we have the file, lets write the data to it.
            //
            DWORD cbWritten;

            if (WriteFile(hFile, pszRemCmstpInf, lstrlen(pszRemCmstpInf)*sizeof(TCHAR), 
                          &cbWritten, NULL))
            {
                //
                //  We launch the inf to delete cmstp right now.  The inf has a PreSetupCommand that
                //  launches the cmstp.exe uninstall command with a /s switch (which we write in the 
                //  inf after extracting it).  The inf then launches the new cmstp, which forces the newly 
                //  launched cmstp.exe to wait on the mutex of the current cmstp.exe until it is finished.
                //  Since profile installs will error on the mutex instead of waiting for it, we 
                //  shouldn't get any installs until after the uninstall and the cleanup inf have run.  
                //  Note that the inf will wait for the PreSetupCommands to finish before processing the inf.
                //  This is important because we could be waiting on User input (the OK dialog from 
                //  deleting CM for instance).
                //
                CloseHandle(hFile);

                //
                //  Now lets write the cmstp.exe command into remcmstp.inf
                //
                LPTSTR pszUninstallFlag = NULL;
                if (dwFlags & c_dwUninstallCm)
                {
                    pszUninstallFlag = c_pszUninstallCm;
                }
                else if (dwFlags & c_dwUninstall)
                {
                    pszUninstallFlag = c_pszUninstall;
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unknown Uninstall Type, exiting"));
                    return FALSE;
                }

                TCHAR szShortInfPath[MAX_PATH+1] = {0};
                TCHAR szParams[2*MAX_PATH+1] = {0};

                DWORD dwRet = GetShortPathName(pszInfPath, szShortInfPath, MAX_PATH);
                
                if (0 == dwRet || MAX_PATH < dwRet)
                {
                    CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unable to get the short path to the Inf, exiting"));
                    return FALSE;
                }

                wsprintf(szParams, TEXT("%s\\cmstp.exe %s %s %s"), szSystemDir, pszUninstallFlag, c_pszSilent, szShortInfPath);

                WritePrivateProfileSection(TEXT("PreSetupCommandsSection"), szParams, szRemCmstpPath);  

                //
                //  Finally lets launch the inf uninstall with the new cmstp command in it.
                //
                wsprintf(szParams, 
                         TEXT("advpack.dll,LaunchINFSection %s\\remcmstp.inf, Uninstall"), 
                         szSystemDir);

                SHELLEXECUTEINFO  sei = {0};

                sei.cbSize = sizeof(sei);
                sei.fMask = SEE_MASK_FLAG_NO_UI;
                sei.nShow = SW_SHOWNORMAL;
                sei.lpFile = TEXT("Rundll32.exe");
                sei.lpParameters = szParams;
                sei.lpDirectory = szSystemDir;

                if (!ShellExecuteEx(&sei))
                {
                    CMTRACE1(TEXT("ExtractInfAndRelaunchCmstp -- ShellExecute Returned an error, GLE %d"), GetLastError());
                }
                else
                {
                    return TRUE;
                }
            }
            else
            {
                CloseHandle(hFile);
                CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unable to write the file data to remcmstp.inf"));
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unable to Create remcmstp.inf in the system directory."));
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("ExtractInfAndRelaunchCmstp -- Unable to load the remcmstp.inf custom resource."));
    }

    return FALSE;
}




//+----------------------------------------------------------------------------
//
// Function:  IsInstall
//
// Synopsis:  Wrapper function to check and see if this is an install or not.
//
// Arguments: DWORD dwFlags - the action flags parameter returned from the 
//                            command line parsing class.
//
// Returns:   BOOL - TRUE if this is an Install command
//
// History:   quintinb Created Header    6/28/99
//
//+----------------------------------------------------------------------------
BOOL IsInstall(DWORD dwFlags)
{
    return (0 == (dwFlags & 0xFF));
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessCmstpExtensionDll
//
// Synopsis:  Processes the cmstp extension dll registry keys and calls out
//            to the extension proc as necessary to modify the action behavior.
//            Using the extension proc, we can modify the install, uninstall,
//            etc. behavior that cmstp exhibits.  This is most useful on platforms
//            that have Native CM (or just a very new copy of CM) but an older
//            profile is being installed.  Since the cmstp.exe that is in the package
//            does the actual installation, we can modify the installation parameters,
//            modify the inf path, or even stop the install.  Since we get called
//            after the install as well, we can even take post-install or cleanup
//            actions.
//
// Arguments: LPDWORD pdwFlags - pointer to the flags parameter, note that it 
//                               can be modified by the extension proc
//            LPTSTR pszInfPath - Inf path, note that it can be modified 
//                                by the extension proc.
//            HRESULT hrRet - current return value, this is only used on 
//                            the post action proc call.
//            EXTENSIONDLLPROCTIMES PreOrPost - if this is a Pre action 
//                                              call or a Post action call.
//
// Returns:   BOOL - TRUE if cmstp.exe should continue, FALSE stops the action 
//                   (install, uninstall, migration, whatever) without further 
//                   action.
//
// History:   quintinb Created Header    6/28/99
//
//+----------------------------------------------------------------------------
BOOL ProcessCmstpExtensionDll (LPDWORD pdwFlags, LPTSTR pszInfPath, HRESULT hrRet, EXTENSIONDLLPROCTIMES PreOrPost)
{

    //
    //  Check for the CmstpExtensionDll reg key in Cm App Paths
    //
    const TCHAR* const c_pszRegCmstpExtensionDll = TEXT("CmstpExtensionDll");
    const char* const c_pszCmstpExtensionProc = "CmstpExtensionProc";   // GetProcAddress takes ANSI strings -- quintinb
    pfnCmstpExtensionProcSpec pfnCmstpExtensionProc = NULL;

    HKEY hKey;

    TCHAR szCmstpExtensionDllPath[MAX_PATH+1];
    ZeroMemory(szCmstpExtensionDllPath, CELEMS(szCmstpExtensionDllPath));

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmAppPaths, 0, KEY_READ, &hKey))
    {
        DWORD dwSize = CELEMS(szCmstpExtensionDllPath);
        DWORD dwType = REG_SZ;

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegCmstpExtensionDll, NULL, &dwType, 
            (LPBYTE)szCmstpExtensionDllPath, &dwSize))
        {
            CDynamicLibrary CmstpExtensionDll (szCmstpExtensionDllPath);

            pfnCmstpExtensionProc = (pfnCmstpExtensionProcSpec)CmstpExtensionDll.GetProcAddress(c_pszCmstpExtensionProc);
            if (NULL == pfnCmstpExtensionProc)
            {
                return TRUE;
            }
            else
            {
                return (pfnCmstpExtensionProc)(pdwFlags, pszInfPath, hrRet, PreOrPost);
            }            
        }
        RegCloseKey(hKey);
    }

    return TRUE;
}

//_____________________________________________________________________________
//
// Function:  WinMain 
//
// Synopsis:  Processes command line switches -- see common\inc\cmstpex.h for full list
//             
//
// Arguments: HINSTANCE hInstance - 
//            HINSTANCE hPrevInstance - 
//            PSTR szCmdLine -      pass in the inf file name here
//            int iCmdShow - 
//
// Returns:   int WINAPI - 
//
// History:   Re-created    quintinb    7-13-98
//
//_____________________________________________________________________________
int WINAPI 
WinMain (HINSTANCE, //hInstance
         HINSTANCE, //hPrevInstance
         PSTR, //szCmdLine
         int //iCmdShow
         )
{
    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMSTP.EXE - LOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE(TEXT("====================================================="));

    BOOL bUsageError = FALSE;
    BOOL bAnotherInstanceRunning = FALSE;
    HRESULT hrReturn = S_OK;
    TCHAR szMsg[MAX_PATH+1];
    TCHAR szTitle[MAX_PATH+1];
    TCHAR szInfPath[MAX_PATH+1];
    DWORD dwFlags = 0;
    CPlatform plat;
    CNamedMutex CmstpMutex; // keep this here so it doesn't get destructed until main ends.
                            // this gives us better control of when it is unlocked.
    
    HINSTANCE hInstance = GetModuleHandleA(NULL);
    LPTSTR szCmdLine = GetCommandLine();

    //
    //  Check to make sure that we aren't an x86 version of cmstp running on an Alpha
    //
#ifdef CMX86BUILD
    if (plat.IsAlpha())
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
        MYVERIFY(0 != LoadString(hInstance, IDS_BINARY_NOT_ALPHA, szMsg, MAX_PATH));
        
        MessageBox(NULL, szMsg, szTitle, MB_OK);            
        return FALSE;        
    }
#endif

    //
    //  Setup the Command Line Arguments
    //

    ZeroMemory(szInfPath, sizeof(szInfPath));

    {   // Make sure ArgProcessor gets destructed properly and we don't leak mem

        CProcessCmdLn ArgProcessor(c_NumArgs, (ArgStruct*)&Args, TRUE, 
            FALSE); //bSkipFirstToken == TRUE, bBlankCmdLnOkay == FALSE

        if (ArgProcessor.GetCmdLineArgs(szCmdLine, &dwFlags, szInfPath, MAX_PATH))
        {
            
            //
            //  We want to wait indefinitely, unless this is an install.  If it is an
            //  install then we want to return immediately and throw an error if we couldn't
            //  get the lock (NTRAID 261248).  We also want to be able to launch two profiles
            //  simulaneously on NT5 (cmstp.exe takes the place of explorer.exe) thus we will
            //  pass the pointer to the CNamedMutex object to the install function so that
            //  it can release the mutex once the install is finished except for launching the
            //  profile (NTRAID 310478).
            //
            BOOL bWait = !IsInstall(dwFlags);

            if (CmstpMutex.Lock(CMSTPMUTEXNAME, bWait, INFINITE))
            {
                //
                //  We got the mutex lock, so go ahead and process the command line
                //  arguments.  First, however, check for a cmstp Dll listed in the 
                //  app paths key of CM.  If a dll is listed here, then we want to load
                //  the dll and pass it the inf path and the install flags.  If the dll
                //  proc returns FALSE, then we want to exit.  Otherwise continue with
                //  the install as normal.
                //  Of the install flags we first check for /x, ,/m, or /mp 
                //  (these switches must be by themselves, we don't allow any 
                //  modifier switches with these), the non-install commands.  We now allow the uninstall
                //  command to take the Silent switch to silence our uninstall prompt.
                //

                if (ProcessCmstpExtensionDll(&dwFlags, szInfPath, S_OK, PRE))
                {
                    CMTRACE2(TEXT("CMSTP.EXE -- Entering Flag Processing Loop, dwFlags = %u and szInfPath = %s"), dwFlags, szInfPath);
                    if (c_dwHelp & dwFlags)
                    {
                        bUsageError = TRUE;
                    }
                    else if (c_dwUninstall & dwFlags)
                    {
                        if (((c_dwUninstall == dwFlags) || ((c_dwUninstall | c_dwSilent) == dwFlags)) && 
                            (TEXT('\0') != szInfPath[0]))
                        {
                            BOOL bSilent = (dwFlags & c_dwSilent);

                            if (bSilent || PromptUserToUninstallProfile(hInstance, szInfPath))
                            {
                                //
                                //  Okay, the user wants to uninstall.  Now check to see if we are the last
                                //  man out.  If we are then we also need to delete cmstp.
                                //

                                if (LastManOut(PROFILEUNINSTALL, szInfPath))
                                {
                                    ExtractInfAndRelaunchCmstp(hInstance, dwFlags, szInfPath);
                                }
                                else
                                {
                                    hrReturn = UninstallProfile(hInstance, szInfPath, TRUE); // bCleanUpCreds == TRUE
                                    MYVERIFY(SUCCEEDED(hrReturn));
                                }
                            }
                        }
                        else
                        {
                            bUsageError = TRUE;
                        }
                    }
                    else if (c_dwOsMigration & dwFlags)
                    {
                        if ((c_dwOsMigration == dwFlags) && (TEXT('\0') == szInfPath[0]))
                        {
                            hrReturn = MigrateCmProfilesForWin2kUpgrade(hInstance);
                            MYVERIFY(SUCCEEDED(hrReturn));
                        }
                        else
                        {
                            bUsageError = TRUE;
                        }
                    }
                    else if (c_dwProfileMigration & dwFlags)
                    { 
                        if ((c_dwProfileMigration == dwFlags) && (TEXT('\0') == szInfPath[0]))
                        {
                            TCHAR szCurrentDir[MAX_PATH+1];
                            if (0 == GetCurrentDirectory(MAX_PATH, szCurrentDir))
                            {
                                return FALSE;
                            }
                            lstrcat(szCurrentDir, TEXT("\\"));

                            hrReturn = MigrateOldCmProfilesForProfileInstall(hInstance, szCurrentDir);
                            MYVERIFY(SUCCEEDED(hrReturn));
                        }
                        else
                        {
                            bUsageError = TRUE;
                        }
                    }                    
                    else if (c_dwUninstallCm & dwFlags)
                    {
                        if (((c_dwUninstallCm == dwFlags) || ((c_dwUninstallCm | c_dwSilent) == dwFlags)) && 
                            (TEXT('\0') != szInfPath[0]))
                        {
                            BOOL bNoBeginPrompt = (dwFlags & c_dwSilent);

                            if (bNoBeginPrompt || PromptUserToUninstallCm(hInstance))
                            {
                                //
                                //  Okay, the user wants to uninstall.  Now check to see if we are the last
                                //  man out.  If we are then we also need to delete cmstp.
                                //

                                if (LastManOut(CMUNINSTALL, szInfPath))
                                {
                                    if (ExtractInfAndRelaunchCmstp(hInstance, dwFlags, szInfPath))
                                    {
                                        //
                                        //  We need to delete the Uninstall key so that we don't leave
                                        //  it in Add/Remove Programs (the refresh is keyed off of this
                                        //  executable ending not the relaunched cmstp.exe's ending).
                                        //  NTRAID 336249
                                        //
                                        HRESULT hrTemp = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, 
                                                                            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Connection Manager"));
                                        MYDBGASSERT(SUCCEEDED(hrTemp));
                                    }
                                }
                                else
                                {
                                    hrReturn = UninstallCm(hInstance, szInfPath);
                                    MYVERIFY(SUCCEEDED(hrReturn));
                                }
                            }
                        }
                        else
                        {
                            bUsageError = TRUE;
                        }
                    }
                    else
                    {
                        //
                        //  Install, note that on NT5 we will release the CmstpMutex once
                        //  we are finished installing and just want to launch the profile.
                        //
                        hrReturn = InstallInf(hInstance, szInfPath, 
                            (dwFlags & c_dwNoSupportFiles), (dwFlags & c_dwNoLegacyIcon), 
                            (dwFlags & c_dwNoNT5Shortcut), (dwFlags & c_dwSilent),
                            (dwFlags & c_dwSingleUser), (dwFlags & c_dwSetDefaultCon), &CmstpMutex);

                        if (FAILED(hrReturn))
                        {
                            CMTRACE2("Cmstp.exe -- InstallInf failed with error %d (0x%lx)", hrReturn, hrReturn);
                        }
                    }

                    //
                    //  Again call the Cmstp Extension Dll if one exists.  We want to give it
                    //  a chance to take post install actions if necessary.

                    ProcessCmstpExtensionDll(&dwFlags, szInfPath, hrReturn, POST);
                }
            }
            else
            {
                bAnotherInstanceRunning = TRUE;
            }        
        }
        else
        {
            bUsageError = TRUE;    
        }
    }
    
    //
    //  Clean up our Dll's
    //
    if (g_pRasApi32)
    {
        g_pRasApi32->Unload();
        CmFree(g_pRasApi32);
    }

    if (g_pRnaph)
    {
        g_pRnaph->Unload();
        CmFree(g_pRnaph);
    }

    if (g_pShell32)
    {
        g_pShell32->Unload();
        CmFree(g_pShell32);
    }

    if (g_pNetShell)
    {
        g_pNetShell->Unload();
        CmFree(g_pNetShell);
    }

    //
    //  UnLock the cmstp mutex, note that it may never have been locked or
    //  it could have been unlocked on Windows 2000 upon launching a profile,
    //  the named mutex class will handle this.
    //
    CmstpMutex.Unlock();
    
    //
    //  Display any error messages after unlocking the mutex so that don't hold
    //  it in the Usage message case.  Another instance running should only
    //  happen when an install tries to acquire the mutex while another cmstp
    //  is running, thus the mutex was never acquired but put the message code
    //  here to keep it in one place.
    //
    if (bUsageError)
    {
        CMTRACE("Cmstp.exe -- Usage Error!");
        if (0 == (dwFlags & c_dwSilent))
        {
            const int c_MsgLen = 1024;
            TCHAR* pszMsg = (TCHAR*)CmMalloc(sizeof(TCHAR)*(c_MsgLen+1));
            if (pszMsg)
            {
                MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
                MYVERIFY(0 != LoadString(hInstance, IDS_USAGE_MSG, pszMsg, c_MsgLen));
        
                MessageBox(NULL, pszMsg, szTitle, MB_OK | MB_ICONINFORMATION);
                CmFree(pszMsg);
            }        
        }
    }
    else if (bAnotherInstanceRunning)
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
        MYVERIFY(0 != LoadString(hInstance, IDS_INUSE_MSG, szMsg, MAX_PATH));
        
        MessageBox(NULL, szMsg, szTitle, MB_OK);    
    }

    //
    //  Check for memory leaks
    //
    EndDebugMemory();

    //
    // get return value
    //
    BOOL bRet = SUCCEEDED(hrReturn) && !bUsageError && !bAnotherInstanceRunning;

    //
    //  Since we don't link to libc, we need to do this ourselves.
    //
    CMTRACE(TEXT("====================================================="));
    CMTRACE1(TEXT(" CMSTP.EXE - UNLOADING - Process ID is 0x%x "), GetCurrentProcessId());
    CMTRACE(TEXT("====================================================="));

    ExitProcess((UINT)bRet);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\loadconnfolder.h ===
//+----------------------------------------------------------------------------
//
// File:     loadconnfolder.h
//
// Module:   CMSTP.EXE
//
// Synopsis: This header file contains the CLoadConnFolder Class definition.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    07/14/98
//
//+----------------------------------------------------------------------------
#ifndef _LOADCONNFOLDER_H_
#define _LOADCONNFOLDER_H_

#include <windows.h>
#include <shlobj.h>
#include <shellapi.h>

class CLoadConnFolder
{

public:
    CLoadConnFolder();
    ~CLoadConnFolder();
    HRESULT HrLaunchConnFolder();

    inline HRESULT GetConnFolder(LPSHELLFOLDER* ppConnectionsFolder)
    {
        if (SUCCEEDED(m_HrClassState))
        {
            *ppConnectionsFolder = m_pConnectionsFolder;
        }

        return m_HrClassState;
    }

    inline LPITEMIDLIST pidlGetConnFolderPidl()
    {
        return m_ConnFolderpidl;
    }


private:    
    LPSHELLFOLDER m_pConnectionsFolder;
    LPSHELLFOLDER m_pDesktopFolder;
    LPITEMIDLIST m_ConnFolderpidl;
    HRESULT m_HrClassState;
    BOOL m_CoInit;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\install.cpp ===
//+----------------------------------------------------------------------------
//
// File:     install.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains the code for installing CM profiles.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/14/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "installerfuncs.h"
#include "winuserp.h"
#include <advpub.h>
#include "tunl_str.h"
#include "cmsecure.h"
// linkdll is needed because of cmsecure
#include "linkdll.h" // LinkToDll and BindLinkage
#include "linkdll.cpp" // LinkToDll and BindLinkage

#include "gppswithalloc.cpp"

//
//  This global var, contains the path to the source files to install such as the
//  cmp, cms, and inf.  (From the inf path passed in to InstallInf).
//
TCHAR g_szProfileSourceDir[MAX_PATH+1];

//  This is really ugly, we need to consolidate our platform detection code between CM and
//  the setup components.
BOOL IsNT()
{
    CPlatform plat;
    return plat.IsNT();
}

#define OS_NT (IsNT())
#include "cmexitwin.cpp"

//+----------------------------------------------------------------------------
//
// Function:  CheckIeDllRequirements
//
// Synopsis:  This function checks to see if the browser agnostic dlls are of
//            a sufficient version for CM to work, or if we should copy the
//            dlls we carry in the package with us.
//
// Arguments: CPlatform* pPlat - a CPlatform object
//
// Returns:   BOOL - returns TRUE if all browser files meet the requirements, FALSE
//                   if any one of the files fails to meet what CM needs.
//
// History:   quintinb Created Header    5/24/99
//
//+----------------------------------------------------------------------------
BOOL CheckIeDllRequirements(CPlatform* pPlat)
{
    TCHAR szSysDir[MAX_PATH+1];
    TCHAR szDllToCheck[MAX_PATH+1];
    if(GetSystemDirectory(szSysDir, MAX_PATH))
    {
        if (pPlat->IsWin9x())
        {
            //
            //  Need Advapi32.dll to be version 4.70.0.1215 or greater.
            //
            const DWORD c_dwRequiredAdvapi32Version = (4 << c_iShiftAmount) + 70;
            const DWORD c_dwRequiredAdvapi32BuildNumber = 1215;

            MYVERIFY(CELEMS(szDllToCheck) > (UINT)wsprintf(szDllToCheck, TEXT("%s%s"), 
                szSysDir, TEXT("\\advapi32.dll")));
        
            CVersion AdvApi32Version(szDllToCheck);

            if ((c_dwRequiredAdvapi32Version > AdvApi32Version.GetVersionNumber()) ||
                ((c_dwRequiredAdvapi32Version == AdvApi32Version.GetVersionNumber()) && 
                 (c_dwRequiredAdvapi32BuildNumber > AdvApi32Version.GetBuildAndQfeNumber())))
            {
                return FALSE;
            }

            //
            //  Need comctl32.dll to be version 4.70.0.1146 or greater.
            //
            const DWORD c_dwRequiredComctl32Version = (4 << c_iShiftAmount) + 70;
            const DWORD c_dwRequiredComctl32BuildNumber = 1146;

            MYVERIFY(CELEMS(szDllToCheck) > (UINT)wsprintf(szDllToCheck, TEXT("%s%s"), 
                szSysDir, TEXT("\\comctl32.dll")));
        
            CVersion Comctl32Version(szDllToCheck);

            if ((c_dwRequiredComctl32Version > Comctl32Version.GetVersionNumber()) ||
                ((c_dwRequiredComctl32Version == Comctl32Version.GetVersionNumber()) && 
                 (c_dwRequiredComctl32BuildNumber > Comctl32Version.GetBuildAndQfeNumber())))
            {
                return FALSE;
            }

            //
            //  Need rnaph.dll to be version 4.40.311.0 or greater.
            //
            const DWORD c_dwRequiredRnaphVersion = (4 << c_iShiftAmount) + 40;
            const DWORD c_dwRequiredRnaphBuildNumber = (311 << c_iShiftAmount);

            MYVERIFY(CELEMS(szDllToCheck) > (UINT)wsprintf(szDllToCheck, TEXT("%s%s"), 
                szSysDir, TEXT("\\rnaph.dll")));
        
            CVersion RnaphVersion(szDllToCheck);
            if ((c_dwRequiredRnaphVersion > RnaphVersion.GetVersionNumber()) ||
                ((c_dwRequiredRnaphVersion == RnaphVersion.GetVersionNumber()) && 
                 (c_dwRequiredRnaphBuildNumber > RnaphVersion.GetBuildAndQfeNumber())))
            {
                return FALSE;
            }
        }

        //
        //  Need wininet.dll to be version 4.70.0.1301 or greater.
        //
        const DWORD c_dwRequiredWininetVersion = (4 << c_iShiftAmount) + 70;
        const DWORD c_dwRequiredWininetBuildNumber = 1301;

        MYVERIFY(CELEMS(szDllToCheck) > (UINT)wsprintf(szDllToCheck, TEXT("%s%s"), 
            szSysDir, TEXT("\\wininet.dll")));
    
        CVersion WininetVersion(szDllToCheck);

        if ((c_dwRequiredWininetVersion > WininetVersion.GetVersionNumber()) ||
            ((c_dwRequiredWininetVersion == WininetVersion.GetVersionNumber()) && 
             (c_dwRequiredWininetBuildNumber > WininetVersion.GetBuildAndQfeNumber())))
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteSingleUserProfileMappings
//
// Synopsis:  This function write the single user mappings key.
//
// Arguments: HINSTANCE hInstance - an Instance handle to load string resources with
//            LPCTSTR pszShortServiceName - short service name of the profile
//            LPCTSTR pszServiceName - Long service name of the profile
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb Created     5/23/99
//
//+----------------------------------------------------------------------------
BOOL WriteSingleUserProfileMappings(LPCTSTR pszInstallDir, LPCTSTR pszShortServiceName, LPCTSTR pszServiceName)
{
    BOOL bReturn = FALSE;
    TCHAR szCmpFile [MAX_PATH+1];
    TCHAR szTemp [MAX_PATH+1];
    TCHAR szUserProfilePath [MAX_PATH+1];
    HKEY hKey = NULL;

    //
    //  Construct the Cmp Path
    //
    MYVERIFY(CELEMS(szCmpFile) > (UINT)wsprintf(szCmpFile, TEXT("%s\\%s.cmp"), 
        pszInstallDir, pszShortServiceName));

    //
    //  Figure out the User Profile directory
    //

    DWORD dwChars = ExpandEnvironmentStrings(TEXT("%AppData%"), szUserProfilePath, MAX_PATH);

    if (dwChars && (MAX_PATH >= dwChars))
    {
        //
        //  We want to do a lstrcmpi but with only so many chars.  Unfortunately this doesn't
        //  exist in Win32 so we will use lstrcpyn into a temp buffer and then use lstrcmpi.
        //
        lstrcpyn(szTemp, szCmpFile, lstrlen(szUserProfilePath) + 1);

        if (0 == lstrcmpi(szTemp, szUserProfilePath))
        {
            lstrcpy(szTemp, szCmpFile + lstrlen(szUserProfilePath));
            lstrcpy(szCmpFile, TEXT("%AppData%"));
            lstrcat(szCmpFile, szTemp);
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("Unable to build the Single User Mappings key value, exiting."));
            goto exit;
        }

        //
        //  Okay, now we need to write out the single user mappings key
        //
        DWORD dwDisposition;
        LONG lResult = RegCreateKeyEx(HKEY_CURRENT_USER, c_pszRegCmMappings, 0, NULL, 
                                      REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, 
                                      &hKey, &dwDisposition);

        if (ERROR_SUCCESS == lResult)
        {
            DWORD dwType = REG_SZ;
            DWORD dwSize = lstrlen(szCmpFile) + 1;

            if (ERROR_SUCCESS != RegSetValueEx(hKey, pszServiceName, NULL, dwType, 
                                               (CONST BYTE *)szCmpFile, dwSize))
            {
                CMASSERTMSG(FALSE, TEXT("Unable to write the Single User Mappings key value, exiting."));
                goto exit;
            }
            else
            {
                bReturn = TRUE;
            }
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("Unable to expand the AppData String, exiting."));
        goto exit;
    }

exit:

    if (hKey)
    {
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ProcessPreferencesUI
//
// Synopsis:  This function processes messages for either of the two dialogs used
//            to ask the user if they want a desktop shortcut.  One dialog is for 
//            non-admins and only contains the shortcut question, the other dialog
//            is for local admins and also contains whether the admin wants the 
//            profile installed for all users or just for single users.
//
//
// History:   quintinb Created    2/19/98
//            quintinb Renamed from ProcessAdminUI to ProcessPreferencesUI and 
//                     added new functionality  6/9/8
//            quintinb removed mention of Start Menu Shortcut  2/17/99
//
//+----------------------------------------------------------------------------
BOOL APIENTRY ProcessPreferencesUI(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    int iUiChoices;
    HKEY hKey;
    DWORD dwSize;
    DWORD dwTemp;
    DWORD dwType;
    InitDialogStruct* pDialogArgs = NULL;

    switch (message)
    {

        case WM_INITDIALOG:
            //
            //  Look up the preferences for Desktop Shortcuts/Start Menu Links
            //  in the registry and set them accordingly.
            // 
            pDialogArgs = (InitDialogStruct*)lParam;

            if (pDialogArgs->bNoDesktopIcon)
            {
                MYVERIFY(0 != CheckDlgButton(hDlg, IDC_DESKTOP, FALSE));
            }
            else
            {
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_pszRegStickyUiDefault, 
                    0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hKey, &dwTemp))
                {
                    //
                    //  The default of whether a desktop shortcut should be created is stored in the
                    //  registry.  Get this value to populate the UI.  (default is off)
                    //
                    dwType = REG_DWORD;
                    dwSize = sizeof(DWORD);
                    dwTemp = 0;
                    RegQueryValueEx(hKey, c_pszRegDesktopShortCut, NULL, &dwType, (LPBYTE)&dwTemp, 
                        &dwSize);  //lint !e534
                    MYVERIFY(0 != CheckDlgButton(hDlg, IDC_DESKTOP, dwTemp));                    
                
                    MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
                }
            }

            //
            //  Set the Window Text to the Profile Name
            //
            MYVERIFY(FALSE != SetWindowText(hDlg, pDialogArgs->pszTitle));

            if (!(pDialogArgs->bSingleUser))
            {
                CheckDlgButton(hDlg, IDC_ALLUSERS, TRUE); //lint !e534 this will fail if using the nochoice UI
            }
            else
            {
                CheckDlgButton(hDlg, IDC_YOURSELF, TRUE); //lint !e534 this will fail if using the nochoice UI          
            }

            //
            //  We return FALSE here but the focus is correctly set.
            //
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    //
                    //  Build the return value
                    //
                    if (IsDlgButtonChecked(hDlg, IDC_ALLUSERS) == BST_CHECKED)
                    {
                        iUiChoices = ALLUSERS;
                    }
                    else
                    {
                        iUiChoices = 0;
                    }
                    
                    if (IsDlgButtonChecked(hDlg, IDC_DESKTOP))
                    {
                        iUiChoices |= CREATEDESKTOPICON;
                    }

                    //
                    //  Make sure to save the users preferences for Desktop Icons
                    //  and Start Menu Links.
                    //

                    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_pszRegStickyUiDefault, 
                        0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwTemp))
                    {
                        //
                        //  Store the current state of whether we should create a desktop shortcut
                        //
                        dwTemp = IsDlgButtonChecked(hDlg, IDC_DESKTOP);
                        MYVERIFY(ERROR_SUCCESS == RegSetValueEx(hKey, c_pszRegDesktopShortCut, 0, 
                            REG_DWORD, (LPBYTE)&dwTemp, sizeof(DWORD)));
            
                        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
                    }

                    MYVERIFY(FALSE != EndDialog(hDlg, iUiChoices));

                    return (TRUE);

                case IDCANCEL:
                    MYVERIFY(FALSE != EndDialog(hDlg, -1));
                    return TRUE;

                default:
                    break;
            }
            break;

        case WM_CLOSE:
            MYVERIFY(FALSE != EndDialog(hDlg, -1));
            return TRUE;
            
        default:
            return FALSE;
    }
    return FALSE;   
}



//+----------------------------------------------------------------------------
//
// Function:  InstallCm
//
// Synopsis:  This function calls LaunchInfSection on the appropriate
//            install section to install Connection Manager.  It also installs
//            the browser files as appropriate.
//
// Arguments: HINSTANCE hInstance - Instance handle for strings
//            LPCTSTR szInfPath - Full path to the inf
//
// Returns:   HRESULT - standard com codes, could return ERROR_SUCCESS_REBOOT_REQUIRED
//                      so the caller must check for this case and ask for a reboot
//                      if required.
//
// History:   quintinb Created    8/12/98
//            quintinb Moved Browser file installation code here, since it is
//                     part of the installation of CM.      10-2-98
//
//+----------------------------------------------------------------------------
HRESULT InstallCm(HINSTANCE hInstance, LPCTSTR szInfPath)
{
    HRESULT hr = E_UNEXPECTED;

    MYDBGASSERT((szInfPath) && (TEXT('\0') != szInfPath[0]));

    //
    //  Load the Cmstp Title just in case we need to show error messages.
    //

    TCHAR szTitle[MAX_PATH+1] = {TEXT("")};
    MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);

    //
    //  Make sure that the Inf File exists
    //
    if (!FileExists(szInfPath))
    {
        CMTRACE1(TEXT("InstallCm -- Can't find %s, the inputted Inf file."), szInfPath);
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    CPlatform plat;
    TCHAR szInstallSection[MAX_PATH+1] = {TEXT("")};

    if (plat.IsNT())
    {
        MYVERIFY(CELEMS(szInstallSection) > (UINT)wsprintf(szInstallSection, 
            TEXT("DefaultInstall_NT")));
    }
    else
    {
        MYVERIFY(CELEMS(szInstallSection) > (UINT)wsprintf(szInstallSection, 
            TEXT("DefaultInstall")));    
    }

    hr = LaunchInfSection(szInfPath, szInstallSection, szTitle, TRUE);  // bQuiet = TRUE

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  InstallWhistlerCmOnWin2k
//
// Synopsis:  This function uses the CM exception inf (cmexcept.inf) to install
//            the Whistler CM binaries on Win2k.
//
// Arguments: LPCSTR pszSourceDir - source directory for cmexcept.inf and CM
//                                  binaries, including the trailing slash.
//
// Returns:   HRESULT - standard com codes, could return ERROR_SUCCESS_REBOOT_REQUIRED
//                      which means the caller needs to request a reboot.
//
// History:   quintinb Created    02/09/2001
//
//+----------------------------------------------------------------------------
HRESULT InstallWhistlerCmOnWin2k(LPCSTR pszSourceDir)
{
    CPlatform cmplat;
    HRESULT hr = E_UNEXPECTED;
    LPSTR pszInfFile = NULL;
    LPCSTR c_pszExceptionInf = "cmexcept.inf";
    LPCSTR c_pszInstallSection = "DefaultInstall";
    LPCSTR c_pszUnInstallSection = "DefaultUninstall_NoPrompt";

    if (cmplat.IsNT5())
    {
        if (pszSourceDir && pszSourceDir[0])
        {
            DWORD dwSize = sizeof(CHAR)*(lstrlenA(pszSourceDir) + lstrlenA(c_pszExceptionInf) + 1);

            pszInfFile = (LPSTR)CmMalloc(dwSize);

            if (pszInfFile)
            {
                wsprintf(pszInfFile, "%s%s", pszSourceDir, c_pszExceptionInf);

                if (FileExists(pszInfFile))
                {
                    hr = CallLaunchInfSectionEx(pszInfFile, c_pszInstallSection, (ALINF_BKINSTALL | ALINF_QUIET));

                    if (FAILED(hr))
                    {
                        CMTRACE1(TEXT("InstallWhistlerCmOnWin2k -- CallLaunchInfSectionEx failed with hr=0x%x"), hr);

                        HRESULT hrTemp = CallLaunchInfSectionEx(pszInfFile, c_pszUnInstallSection, (ALINF_ROLLBKDOALL | ALINF_QUIET));

                        CMTRACE1(TEXT("InstallWhistlerCmOnWin2k -- Rolling back.  CallLaunchInfSectionEx returned hr=0x%x"), hrTemp);
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSTALL_PLATFORM_UNSUPPORTED); // kind of a double use of this error
    }

    CmFree(pszInfFile);

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  UpdateCmpDataFromExistingProfile
//
// Synopsis:  This function enumerates all of the keys in all of the sections
//            of an existing cmp file and copies them to the cmp file to be
//            installed.  This function copies all of the data in the existing
//            cmp unless that data already exists in the cmp to install.  This
//            allows Admins to preseed cmp files and have their settings override
//            what the user currently has in their cmp.
//
// Arguments: LPCTSTR pszShortServiceName - Short Service name of the profile
//            LPCTSTR szCurrentCmp - Full path to the currently installed cmp
//            LPCTSTR szCmpToBeInstalled - Full path to the cmp to install 
//
// Returns:   BOOL - TRUE if the cmp is copied and updated properly
//
// History:   quintinb Created                              03/16/99
//            quintinb rewrote for Whistler bug 18021       03/05/00
//
//+----------------------------------------------------------------------------
BOOL UpdateCmpDataFromExistingProfile(LPCTSTR pszShortServiceName, LPCTSTR pszCurrentCmp, LPCTSTR pszCmpToBeInstalled)
{

    if((NULL == pszShortServiceName) && (TEXT('\0') == pszShortServiceName[0]) &&
       (NULL == pszCurrentCmp) && (TEXT('\0') == pszCurrentCmp[0]) &&
       (NULL == pszCmpToBeInstalled) && (TEXT('\0') == pszCmpToBeInstalled[0]))
    {
        CMASSERTMSG(FALSE, TEXT("UpdateCmpDataFromExistingProfile -- Invalid parameter."));
        return FALSE;
    }

    BOOL bReturn = FALSE;
    BOOL bExitLoop = FALSE;
    DWORD dwSize = MAX_PATH;
    DWORD dwReturnedSize;
    LPTSTR pszAllSections = NULL;
    LPTSTR pszAllKeysInCurrentSection = NULL;
    LPTSTR pszCurrentSection = NULL;
    LPTSTR pszCurrentKey = NULL;
    TCHAR szData[MAX_PATH+1];

    //
    //  First lets get all of the sections from the existing cmp
    //
    pszAllSections = (TCHAR*)CmMalloc(dwSize*sizeof(TCHAR));

    do
    {
        MYDBGASSERT(pszAllSections);

        if (pszAllSections)
        {
            dwReturnedSize = GetPrivateProfileString(NULL, NULL, TEXT(""), pszAllSections, dwSize, pszCurrentCmp);

            if (dwReturnedSize == (dwSize - 2))
            {
                //
                //  The buffer is too small, lets allocate a bigger one
                //
                dwSize = 2*dwSize;
                if (dwSize > 1024*1024)
                {
                    CMASSERTMSG(FALSE, TEXT("UpdateCmpDataFromExistingProfile -- Allocation above 1MB, bailing out."));
                    goto exit;
                }

                pszAllSections = (TCHAR*)CmRealloc(pszAllSections, dwSize*sizeof(TCHAR));                
            }
            else if (0 == dwReturnedSize)
            {
                //
                //  We got an error, lets exit.
                //
                CMASSERTMSG(FALSE, TEXT("UpdateCmpDataFromExistingProfile -- GetPrivateProfileString returned failure."));
                goto exit;
            }
            else
            {
                bExitLoop = TRUE;
            }
        }
        else
        {
            goto exit; 
        }

    } while (!bExitLoop);

    //
    //  Okay, now we have all of the sections in the existing cmp file.  Lets enumerate
    //  all of the keys in each section and see which ones need to be copied over.
    //
    
    pszCurrentSection = pszAllSections;
    dwSize = MAX_PATH;

    pszAllKeysInCurrentSection = (TCHAR*)CmMalloc(dwSize*sizeof(TCHAR));

    while (TEXT('\0') != pszCurrentSection[0])
    {
        //
        //  Get all of the keys in the current section
        //
        bExitLoop = FALSE;

        do
        {
            if (pszAllKeysInCurrentSection)
            {
                dwReturnedSize = GetPrivateProfileString(pszCurrentSection, NULL, TEXT(""), pszAllKeysInCurrentSection, 
                                                         dwSize, pszCurrentCmp);

                if (dwReturnedSize == (dwSize - 2))
                {
                    //
                    //  The buffer is too small, lets allocate a bigger one
                    //
                    dwSize = 2*dwSize;
                    if (dwSize > 1024*1024)
                    {
                        CMASSERTMSG(FALSE, TEXT("UpdateCmpDataFromExistingProfile -- Allocation above 1MB, bailing out."));
                        goto exit;
                    }

                    pszAllKeysInCurrentSection = (TCHAR*)CmRealloc(pszAllKeysInCurrentSection, dwSize*sizeof(TCHAR));

                }
                else if (0 == dwReturnedSize)
                {
                    //
                    //  We got an error, lets exit.
                    //
                    CMASSERTMSG(FALSE, TEXT("UpdateCmpDataFromExistingProfile -- GetPrivateProfileString returned failure."));
                    goto exit;
                }
                else
                {
                    bExitLoop = TRUE;
                }
            }
            else
            {
               goto exit; 
            }

        } while (!bExitLoop);

        //
        //  Now process all of the keys in the current section
        //
        pszCurrentKey = pszAllKeysInCurrentSection;

        while (TEXT('\0') != pszCurrentKey[0])
        {
            //
            //  Try to get the value of the key from the new cmp.  If it
            //  doesn't exist, then copy of the old cmp value.  If it
            //  does exist keep the new cmp value and ignore the old one.
            //
            dwReturnedSize = GetPrivateProfileString(pszCurrentSection, pszCurrentKey, TEXT(""), 
                                                     szData, MAX_PATH, pszCmpToBeInstalled);
            if (0 == dwReturnedSize)
            {
                //
                //  Then we have a value in the old profile that we don't have in the new profile.
                //
                dwReturnedSize = GetPrivateProfileString(pszCurrentSection, pszCurrentKey, TEXT(""), 
                                                         szData, MAX_PATH, pszCurrentCmp);

                if (dwReturnedSize)
                {
                    MYVERIFY(0 != WritePrivateProfileString(pszCurrentSection, pszCurrentKey, szData, pszCmpToBeInstalled));
                }
            }

            //
            //  Advance to the next key in pszAllKeysInCurrentSection
            //
            pszCurrentKey = pszCurrentKey + lstrlen(pszCurrentKey) + 1;
        }


        //
        //  Now advance to the next string in pszAllSections 
        //
        pszCurrentSection = pszCurrentSection + lstrlen(pszCurrentSection) + 1;
    }


    //
    //  Flush the updated cmp
    //
    WritePrivateProfileString(NULL, NULL, NULL, pszCmpToBeInstalled); //lint !e534 this call will return 0

    bReturn = TRUE;

exit:

    CmFree(pszAllSections);
    CmFree(pszAllKeysInCurrentSection);

    return bReturn;

}

//+----------------------------------------------------------------------------
//
// Function:  MigrateCmpData
//
// Synopsis:  This function checks to see if a profile of the same long service
//            and short service name is already installed.  If it is, it migrates
//            the existing cmp data to the cmp file that is to be installed.
//            If the same piece of data exists in both profiles the data in the
//            cmp to be installed wins (allows admins to pre-seed data in the
//            cmp and override what users have picked).
//
// Arguments: HINSTANCE hInstance - Instance handle for string resources
//            BOOL bInstallForAllUsers - whether this is an all users profile or not
//            LPCTSTR pszServiceName - ServiceName of the current profile
//            LPCTSTR pszShortServiceName - Short Service name of the current profile
//            BOOL bSilent - whether messages to the user can be displayed or not
//
// Returns:   int - returns -1 on error, otherwise TRUE or FALSE depending on if a same name
//                  profile was discovered
//
// History:   quintinb  Created     9/8/98
//
//+----------------------------------------------------------------------------
BOOL MigrateCmpData(HINSTANCE hInstance, BOOL bInstallForAllUsers, LPCTSTR pszServiceName, 
                    LPCTSTR pszShortServiceName, BOOL bSilent)
{
    //
    //  Check the parameters
    //
    if ((NULL == pszShortServiceName) || (TEXT('\0') == pszShortServiceName[0]) || 
        (NULL == pszServiceName) || (TEXT('\0') == pszServiceName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("MigrateCmpData -- Invalid Parameter"));
        return FALSE;
    }

    BOOL bReturn = TRUE;
    DWORD dwSize = MAX_PATH;
    HKEY hKey;
    HKEY hBaseKey = bInstallForAllUsers ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER;
    TCHAR szExistingCmp[MAX_PATH+1];
    TCHAR szCmpToBeInstalled[MAX_PATH+1];
    TCHAR szFmtString[2*MAX_PATH+1] = TEXT("");
    TCHAR szMsg[2*MAX_PATH+1] = TEXT("");

    //
    //  Read the mappings value
    //
    LONG lResult = RegOpenKeyEx(hBaseKey, c_pszRegCmMappings, 0, KEY_READ, &hKey);

    if (ERROR_SUCCESS == lResult)
    {
        lResult = RegQueryValueEx(hKey, pszServiceName, NULL, NULL, (LPBYTE)szFmtString, &dwSize);

        if (ERROR_SUCCESS == lResult)
        {
            //
            //  Expand the path in case it contains environment vars
            //
            if (0 == ExpandEnvironmentStrings(szFmtString, szExistingCmp, MAX_PATH))
            {
                CMASSERTMSG(FALSE, TEXT("MigrateCmpData -- Unable to expand environment strings, not migrating cmp data."));
                goto exit;
            }

            //
            //  If the file doesn't exist we have nothing to get cmp settings from ... thus
            //  lets just happily exit.
            //
            if (!FileExists(szExistingCmp))
            {                
                goto exit;
            }

            //
            //  Check to make sure that the Short Service Names agree for the two profiles
            //
            
            CFileNameParts ExistingCmpParts(szExistingCmp);
            if (0 != lstrcmpi(pszShortServiceName, ExistingCmpParts.m_FileName))
            {
                if (!bSilent)
                {
                    MYVERIFY(0 != LoadString(hInstance, IDS_SAME_LS_DIFF_SS, szFmtString, CELEMS(szFmtString)));
                    
                    MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szFmtString, pszShortServiceName, 
                                                            ExistingCmpParts.m_FileName, pszServiceName));

                    MessageBox(NULL, szMsg, pszServiceName, MB_OK);
                }

                bReturn = -1;
                goto exit;
            }
            
            //
            //  Get the path of the cmp to install
            //
            MYVERIFY(CELEMS(szCmpToBeInstalled) > (UINT)wsprintf(szCmpToBeInstalled, 
                TEXT("%s%s.cmp"), g_szProfileSourceDir, pszShortServiceName));
            
            if (FALSE == UpdateCmpDataFromExistingProfile(pszShortServiceName, szExistingCmp, szCmpToBeInstalled))
            {
                bReturn = -1;
            }
        }
    }

exit:
    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  NeedCM10Upgrade
//
// Synopsis:  This function detects and prepares data for the same name upgrade of a CM 1.0 profile.
//            Thus if you pass in a short service name and a service name, the
//            function detects if this profile is already installed for all users.
//            If it is, then the function checks the profile version stamps in the cmp.
//            If the current version isn't already newer and the user isn't a non-admin
//            on NT5, then we prompt the user if they want to upgrade the current install.
//            If they choose to upgrade then this function migrates the cmp data and
//            finds the uninstall inf.
//
// Arguments: HINSTANCE hInstance - Instance handle for string resources
//            LPCTSTR pszServiceName - ServiceName of the current profile
//            LPCTSTR pszShortServiceName - Short Service name of the current profile
//            LPTSTR pszOldInfPath - Out param for the old inf path, if the same name
//                                     upgrade is needed.
//
// Returns:   int - returns -1 on error, otherwise TRUE or FALSE depending on if a same name
//                  profile was discovered
//
// History:   quintinb  Created     9/8/98
//
//+----------------------------------------------------------------------------
int NeedCM10Upgrade(HINSTANCE hInstance, LPCTSTR pszServiceName, LPCTSTR pszShortServiceName, 
                    LPTSTR pszOldInfPath, BOOL bSilent, CPlatform* plat)
{
    HKEY hKey;
    TCHAR   szFmtString[2*MAX_PATH+1] = TEXT("");
    TCHAR   szMsg[2*MAX_PATH+1] = TEXT("");
    const int c_iCM12ProfileVersion = 4;

    MYDBGASSERT((NULL != pszShortServiceName) && (TEXT('\0') != pszShortServiceName[0]));
    MYDBGASSERT((NULL != pszServiceName) && (TEXT('\0') != pszServiceName[0]));

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
        KEY_READ, &hKey))
    {
        int iCurrentCmpVersion;
        int iCmpVersionToInstall;
        TCHAR szCurrentCmp[MAX_PATH+1];
        TCHAR szCmpToBeInstalled[MAX_PATH+1];
        DWORD dwSize = MAX_PATH;

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, pszServiceName, NULL, 
                                             NULL, (LPBYTE)szCurrentCmp, &dwSize))
        {
            //
            //  First check to see that the file really exists.  It is a somewhat probable case
            //  that the users will have deleted their Profile files but left the registry
            //  keys intact (they didn't uninstall it).  In fact, MSN 2.5 and 2.6 operate this
            //  way.   Thus if the cmp doesn't actually exist then we don't need a same name
            //  upgrade.
            //
            if (!FileExists(szCurrentCmp))
            {
                CMASSERTMSG(FALSE, TEXT("Detected a CM 1.0 Upgrade, but the cmp didn't exist.  Not Processing the upgrade."));
                return FALSE;
            }

            //
            //  Check to make sure that the Short Service Names agree for the two profiles
            //
            
            CFileNameParts CurrentCmpParts(szCurrentCmp);
            if (0 != lstrcmpi(pszShortServiceName, CurrentCmpParts.m_FileName))
            {
                if (!bSilent)
                {
                    MYVERIFY(0 != LoadString(hInstance, IDS_SAME_LS_DIFF_SS, szFmtString, CELEMS(szFmtString)));
                    
                    MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szFmtString, pszShortServiceName, 
                                                            CurrentCmpParts.m_FileName, pszServiceName));

                    MessageBox(NULL, szMsg, pszServiceName, MB_OK);
                }

                return -1;
            }

            //
            //  Then we have the same servicename profile installed as an all users install.
            //  Check the version number in the CMP.  If the same version or less then we want
            //  to run the same name upgrade.  If the current version is more recent, then
            //  we want to prevent the user from installing.
            //

            //
            //  Get Currently Installed Profile version
            //
            iCurrentCmpVersion = GetPrivateProfileInt(c_pszCmSectionProfileFormat, c_pszVersion, 
                0, szCurrentCmp);
            
            //
            //  Get the version of the profile to install
            //
            MYVERIFY(CELEMS(szCmpToBeInstalled) > (UINT)wsprintf(szCmpToBeInstalled, 
                TEXT("%s%s.cmp"), g_szProfileSourceDir, pszShortServiceName));
            
            iCmpVersionToInstall = GetPrivateProfileInt(c_pszCmSectionProfileFormat, c_pszVersion, 0, 
                szCmpToBeInstalled);

            if (iCurrentCmpVersion > iCmpVersionToInstall)
            {
                //
                //  We must not allow the install because a newer version of the profile format
                //  is already installed.
                //
                if (!bSilent)
                {
                    MYVERIFY(0 != LoadString(hInstance, IDS_NEWER_SAMENAME, szFmtString, CELEMS(szFmtString)));
                    MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szFmtString, pszServiceName));
                    MessageBox(NULL, szMsg, pszServiceName, MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
                }
                return -1;
            }
            else if (iCurrentCmpVersion < c_iCM12ProfileVersion)
            {
                int iRet;

                //
                //  Make sure that this isn't a Non-Admin NT5 person trying to install
                //
                if (plat->IsAtLeastNT5() && !IsAdmin())
                {
                    CMASSERTMSG(!bSilent, TEXT("NeedCM10Upgrade -- NonAdmin trying to Same Name upgrade a profile, exiting!"));
                    if (!bSilent)
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_GET_ADMIN, szFmtString, CELEMS(szFmtString)));
                        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szFmtString, pszServiceName));
                        MessageBox(NULL, szMsg, pszServiceName, MB_OK);
                    }
                    return -1;              
                } 
                else
                {
                    //
                    //  Now prompt the user to make sure that they want to go ahead with the upgrade
                    //
                    if (!bSilent)
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_UPGRADE_SAMENAME, szFmtString, CELEMS(szFmtString)));
                        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szFmtString, pszServiceName));
                        iRet = MessageBox(NULL, szMsg, pszServiceName, MB_YESNO | MB_TOPMOST | MB_SYSTEMMODAL);
                    }
                    else
                    {
                        //
                        //  Assume yes with Silent Same Name Upgrade
                        //

                        iRet = IDYES;
                    }
                }

                if (IDYES == iRet)
                {
                    if (UpdateCmpDataFromExistingProfile(pszShortServiceName, szCurrentCmp, szCmpToBeInstalled))
                    {                    
                        CFileNameParts FileParts(szCurrentCmp);
                        if (0 != GetSystemDirectory(szFmtString, MAX_PATH)) // use szFmtString as a temp
                        {
                            MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, TEXT("%s\\%s.inf"), szFmtString, FileParts.m_FileName));
                            if (FileExists(szMsg))
                            {
                                lstrcpy(pszOldInfPath, szMsg);
                            }
                            else
                            {
                                //
                                //  Not in the system directory, try profile dir.
                                //
                                MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, 
                                    TEXT("%s%s%s\\%s.inf"), FileParts.m_Drive, 
                                    FileParts.m_Dir, FileParts.m_FileName, 
                                    FileParts.m_FileName));
                                
                                if (FileExists(szMsg))
                                {
                                    lstrcpy(pszOldInfPath, szMsg);
                                }
                                else
                                {
                                    CMASSERTMSG(FALSE, TEXT("Unable to locate the profile INF -- old profile won't be uninstalled but installation will continue."));
                                    pszOldInfPath[0] = TEXT('\0');
                                }

                            }
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("Couldn't copy cmp file for same name upgrade.  Exiting."));
                        return -1;
                    }
                    return TRUE;
                }
                else
                {
                    return -1;
                }
            }
            else
            {
                //
                //  Then either the version numbers are the same or the version to install is newer but
                //  the existing profile is at least a 1.2 profile.
                //
                return FALSE;
            }
        }
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  MeetsMinimumProfileInstallVersion
//
// Synopsis:  Because of problems with previous profile installers (namely 1.0),
//            we built in minimum install requirements for profiles.  Thus we
//            look under the Connection Manager App Paths key for a minimum profile
//            version, a minimum build number, and a minimum profile format version.
//            If the profile trying to install doesn't meet any of these requirements,
//            then the function returns FALSE and the install is failed.
//
// Arguments: DWORD dwInstallerVersionNumber - current installer version number
//            DWORD dwInstallerBuildNumber - current installer build number
//            LPCTSTR pszInfFile - path to the inf to get the profile format version number
//
// Returns:   BOOL - TRUE if all the version requirements are met
//
// History:   quintinb Created Header    5/24/99
//
//+----------------------------------------------------------------------------
BOOL MeetsMinimumProfileInstallVersion(DWORD dwInstallerVersionNumber, 
                                       DWORD dwInstallerBuildNumber, LPCTSTR pszInfFile)
{
    const TCHAR* const c_pszRegMinProfileVersion = TEXT("MinProfileVersion");
    const TCHAR* const c_pszRegMinProfileBuildNum = TEXT("MinProfileBuildNum");
    const TCHAR* const c_pszRegMinProfileFmtVersion = TEXT("MinProfileFmtVersion");

    HKEY hKey;
    DWORD dwTemp;

    //
    //  First check the format version.
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmAppPaths, 0, KEY_READ, &hKey))
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = REG_DWORD;

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegMinProfileFmtVersion, NULL, 
            &dwType, (LPBYTE)&dwTemp, &dwSize))
        {
            //
            //  Get the profile format version from the cmp file
            //
            DWORD dwFormatVersion;
            CFileNameParts InfParts(pszInfFile);
            TCHAR szCmpFile[MAX_PATH+1];

            MYVERIFY(CELEMS(szCmpFile) > (UINT)wsprintf(szCmpFile, TEXT("%s%s%s%s"), 
                InfParts.m_Drive, InfParts.m_Dir, InfParts.m_FileName, c_pszCmpExt));

            dwFormatVersion = (DWORD)GetPrivateProfileInt(c_pszCmSectionProfileFormat, 
                c_pszVersion, -1, szCmpFile);

            if (dwTemp > dwFormatVersion)
            {
                return FALSE;
            }
        }

        //
        //  Next Check the profile version (equivalent to the version number of the 
        //  CM bits the profile was built with)
        //
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegMinProfileVersion, NULL, 
            &dwType, (LPBYTE)&dwTemp, &dwSize))
        {
            //
            //  If the minimum version number from the registry is higher than the
            //  version number listed here, fail the install.
            //
            if (dwTemp > dwInstallerVersionNumber)
            {
                return FALSE;
            }
        }

        //
        //  Next Check the profile build number (equivalent to the build number of the 
        //  CM bits the profile was built with)
        //
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegMinProfileBuildNum, NULL, 
            &dwType, (LPBYTE)&dwTemp, &dwSize))
        {
            //
            //  If the minimum version number from the registry is higher than the
            //  version number listed here, fail the install.
            //
            if (dwTemp > dwInstallerBuildNumber)
            {
                return FALSE;
            }
        }
        RegCloseKey(hKey);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  UninstallExistingCmException
//
// Synopsis:  This function looks for the cmexcept.inf file in the %windir%\inf
//            directory.  If this file exists, then we uninstall the
//            existing exception before we install the new one.  This prevents
//            the rollback information from being lost.
//
// Arguments: none
//
// Returns:   BOOL - returns TRUE if the installer needs to uninstall the
//                   existing CM exception install and FALSE if the install
//                   can continue without it.
//
// History:   quintinb Created      11/1/98
//
//+----------------------------------------------------------------------------
HRESULT UninstallExistingCmException()
{
    HRESULT hr = E_UNEXPECTED;
    LPCSTR c_pszCmExceptInfRelative = TEXT("\\Inf\\cmexcept.inf");
    LPCSTR c_pszUnInstallSection = "DefaultUninstall_NoPrompt";

    UINT uNumChars = GetWindowsDirectoryA(NULL, 0);

    if (uNumChars)
    {
        uNumChars = uNumChars + lstrlenA(c_pszCmExceptInfRelative);

        LPSTR pszPathToCmExceptInf = (LPSTR)CmMalloc(sizeof(CHAR)*(uNumChars + 1));

        if (pszPathToCmExceptInf)
        {
            if (GetWindowsDirectoryA(pszPathToCmExceptInf, uNumChars))
            {
                lstrcatA(pszPathToCmExceptInf, c_pszCmExceptInfRelative);

                if (FileExists(pszPathToCmExceptInf))
                {
                    //
                    //  We have an exception inf in the directory so we need to uninstall it.  Were the
                    //  bits already on the machine newer than the bits we have in the cab, then we wouldn't
                    //  be installing.  If the bits on the machine don't match the version that the inf says,
                    //  then we are better uninstalling those bits and putting them in a known state anyway.
                    //
                    hr = CallLaunchInfSectionEx(pszPathToCmExceptInf, c_pszUnInstallSection, ALINF_ROLLBKDOALL);

                    CMTRACE1(TEXT("UninstallExistingCmException -- CM Exception inf found, uninstalling.  CallLaunchInfSectionEx returned hr=0x%x"), hr);
                }
                else
                {
                    hr = S_FALSE; // nothing to delete
                }            
            }

            CmFree(pszPathToCmExceptInf);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CheckCmAndIeRequirements
//
// Synopsis:  This function checks the CM and IE requirements for a profile
//            and returns whether the CM should be installed, whether profile
//            migration should occur, and most importantly if the install should
//            exit now because of insufficient requirements.
//
// Arguments: BOOL* pbInstallCm -   tells if CM should be installed or not
//            BOOL* pbMigrateExistingProfiles - tells if profile migration should occur
//            LPCTSTR szInfFile - the inf file to install
//            LPCTSTR szServiceName - The Service name, used as a title
//
// Returns:   BOOL - returns TRUE if the install should continue, FALSE if
//                   if the install should be failed.
//
// History:   quintinb Created      11/1/98
//
//+----------------------------------------------------------------------------
BOOL CheckCmAndIeRequirements(HINSTANCE hInstance, BOOL* pbInstallCm, 
                              BOOL* pbMigrateExistingProfiles, LPCTSTR szInfFile, 
                              BOOL bNoSupportFiles, LPCTSTR szServiceName, BOOL bSilent)
{
    CmVersion   CmVer;
    CPlatform   plat;
    BOOL        bReturn;
    BOOL        bCMRequired;
    TCHAR       szMsg[2*MAX_PATH+1];
    TCHAR       szTemp[MAX_PATH+1];
    TCHAR       szString[MAX_PATH+1];
    DWORD dwInstallerBuildNumber = 0;
    DWORD dwInstallerVersionNumber = 0;


    //
    //  The inf file tells us if we included the CM bits
    //
    if (plat.IsNT5())
    {
        //
        //  We now need to check to see if we need to install the Windows XP bits on
        //  Windows 2000.  Thus we check the inf to see if this profile includes the CM
        //  bits or not.  Note that we never want to install the IE support files on
        //  Win2k so set bIERequired to TRUE.
        //
        bCMRequired = !GetPrivateProfileInt(c_pszCmakStatus, TEXT("IncludeCMCode"), 0, szInfFile);
    }
    else if (CmIsNative())
    {
        //
        //  CM and IE are required on Windows XP and any platforms with the Native
        //  regkey set except NT5 and Win98 SE as they are special cases.
        //
        bCMRequired = TRUE;
    }
    else
    {
        bCMRequired = !GetPrivateProfileInt(c_pszCmakStatus, TEXT("IncludeCMCode"), 
            0, szInfFile);
    }

    //
    //  Now try to get the version numbers from the profile INF
    //
    dwInstallerBuildNumber = (DWORD)GetPrivateProfileInt(c_pszSectionCmDial32, 
        c_pszVerBuild, ((VER_PRODUCTBUILD << c_iShiftAmount) + VER_PRODUCTBUILD_QFE), 
        szInfFile);

    dwInstallerVersionNumber = (DWORD)GetPrivateProfileInt(c_pszSectionCmDial32, 
        c_pszVersion, (HIBYTE(VER_PRODUCTVERSION_W) << c_iShiftAmount) + (LOBYTE(VER_PRODUCTVERSION_W)), 
        szInfFile);

    //
    //  First check to see if we have any install minimums in the registry.  If these
    //  minimums exist and our profile doesn't meet those minimums then we must
    //  throw an error message and exit.
    //
    if (!MeetsMinimumProfileInstallVersion(dwInstallerVersionNumber, 
                                           dwInstallerBuildNumber, szInfFile))
    {
        if (!bSilent)
        {
            MYVERIFY(0 != LoadString(hInstance, IDS_PROFILE_TOO_OLD, szMsg, MAX_PATH));
            MessageBox(NULL, szMsg, szServiceName, MB_OK | MB_ICONERROR);
        }

        return FALSE;
    }

    //
    //  Should we migrate existing profiles?  Always try to migrate if we find all user
    //  profiles already on the machine.
    //
    *pbMigrateExistingProfiles = AllUserProfilesInstalled();

    //
    //  Do CM bits exist on the machine?
    //
    if (CmVer.IsPresent())
    {
        if ((dwInstallerVersionNumber < CmVer.GetVersionNumber()) ||
                 (dwInstallerBuildNumber < CmVer.GetBuildAndQfeNumber()))
        {
            //
            //  If the CM bits on the machine are newer than the bits we have in the cab,
            //  then we only want to install the profile files and not the CM bits themselves.
            //

            *pbInstallCm = FALSE;
            bReturn = TRUE;        
        }
        else
        {
            //
            //  Then the CM bits on the machine are older than the bits in the cab or
            //  the two versions match.  Either way, we should install the bits in the
            //  cab unless this is Win2k where we never want to re-install the same
            //  version of CM bits as we will lose our rollback information.
            //

            if (bCMRequired)
            {
                if ((dwInstallerVersionNumber == CmVer.GetVersionNumber()) &&
                   (CmVer.GetBuildNumber() > c_CmMin13Version))
                {
                    //
                    //  Then the builds have the same major and minor version number
                    //  and should be considered in the same "Version Family".  Note
                    //  that we also check for a minimum build number because 7.00 is
                    //  the version number for the CM 1.0 release in NT4 SP4 and we want CM
                    //  profiles to not install on NT5 Beta2 Bits.
                    //

                    *pbInstallCm = FALSE;
                    bReturn = TRUE;                                    
                }
                else
                {
                    MYVERIFY(CELEMS(szString) > (UINT)wsprintf(szString, TEXT("%u.%u.%u.%u"), 
                        HIWORD(dwInstallerVersionNumber), LOWORD(dwInstallerVersionNumber), 
                        HIWORD(dwInstallerBuildNumber), LOWORD(dwInstallerBuildNumber)));

                    if (!bSilent)
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_CM_OLDVERSION, szTemp, MAX_PATH));
                        MYVERIFY(CELEMS(szMsg) > (UINT)wsprintf(szMsg, szTemp, szString));
                        MessageBox(NULL, szMsg, szServiceName, MB_OK);
                    }
                    return FALSE;
                }
            }
            else
            {
                if ((dwInstallerVersionNumber == CmVer.GetVersionNumber()) &&
                    (dwInstallerBuildNumber == CmVer.GetBuildAndQfeNumber()))
                {
                    //
                    //  Don't reinstall the CM bits if they are the same version
                    //  and we are on Win2k.  Doing so will overwrite the version of
                    //  CM ready for rollback.
                    //
                    *pbInstallCm = !(plat.IsNT5());
                    bReturn = TRUE;           
                }
                else if (plat.IsNT5() && (FALSE == IsAdmin()))
                {
                    //
                    //  If this is Win2k and we need to install the CM binaries via the exception installer,
                    //  then the user must be an Administrator to do so.  Since this user isn't, fail
                    //  the install and give the user a warning message.
                    //

                    if (!bSilent)
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_CANNOT_INSTALL_CM, szMsg, 2*MAX_PATH));
                        
                        MessageBox(NULL, szMsg, szServiceName, MB_OK | MB_ICONEXCLAMATION);
                    }

                    return FALSE;
                }
                else
                {
                    //
                    //  If this is Win2k, we need to make sure we aren't doing a cross language install.
                    //  Basically, we want to ensure that we aren't installing English CM bits on a native
                    //  German machine for instance.  If so, fail the install and inform the user why.
                    //
                    if (plat.IsNT5())
                    {
                        const TCHAR* const c_pszCmstp = TEXT("cmstp.exe");
                        CFileNameParts InfFileParts(szInfFile);
                        DWORD dwLen = lstrlen(InfFileParts.m_Drive) + lstrlen(InfFileParts.m_Dir) + lstrlen(c_pszCmstp);

                        if (MAX_PATH >= dwLen)
                        {
                            wsprintf(szTemp, TEXT("%s%s%s"), InfFileParts.m_Drive, InfFileParts.m_Dir, c_pszCmstp);
                            
                            CVersion CmstpVer(szTemp);
                            DWORD dwExistingCmLcid = CmVer.GetLCID();                            
                            DWORD dwCmstpLcid = CmstpVer.GetLCID();

                            if (FALSE == ArePrimaryLangIDsEqual(dwExistingCmLcid, dwCmstpLcid))
                            {
                                if (!bSilent)
                                {
                                    MYVERIFY(0 != LoadString(hInstance, IDS_CROSS_LANG_INSTALL, szMsg, 2*MAX_PATH));
                        
                                    MessageBox(NULL, szMsg, szServiceName, MB_OK | MB_ICONEXCLAMATION);
                                }

                                return FALSE;
                            }
                        }
                    }

                    //
                    //  Now check to see if installing CM is going to have an effect on CMAK
                    //
                    CmakVersion CmakVer;

                    if (CmakVer.Is121Cmak() || CmakVer.Is122Cmak())
                    {
                        //
                        //  Then the Win2k or IEAK5 version of CMAK is installed.  Installing
                        //  the Whistler version of CM will break this version of CMAK.  We
                        //  need to ask the user if they wish to continue the install and break
                        //  CMAK or abort the install and leave it as is.
                        //
                        if (bSilent)
                        {
                            return FALSE;
                        }
                        else
                        {
                            MYVERIFY(0 != LoadString(hInstance, IDS_INSTCM_WITH_OLD_CMAK, szMsg, 2*MAX_PATH));

                            if (IDNO == MessageBox(NULL, szMsg, szServiceName, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION))
                            {
                                return FALSE;                        
                            }
                        }
                    }

                    *pbInstallCm = TRUE;
                    bReturn = TRUE;
                }
            }
        }
    }
    else
    {
        if (bCMRequired)
        {
            //
            //  This is an error because we need CM bits but don't have any on
            //  the machine or in the cab (or its Whistler and we won't install them).
            //
            if (!bSilent)
            {
                MYVERIFY(0 != LoadString(hInstance, IDS_CM_NOTPRESENT, szMsg, MAX_PATH));
                MessageBox(NULL, szMsg, szServiceName, MB_OK);
            }

            return FALSE;
        }
        else
        {
            MYDBGASSERT(FALSE == plat.IsNT5()); // we shouldn't be in this state on Win2k but it is probably
                                                // better for the user if we install.

            *pbInstallCm = TRUE;
            bReturn = TRUE;
        }
    }

    if (!bNoSupportFiles)
    {
        if (!CheckIeDllRequirements(&plat))
        {
            if (!bSilent)
            {
                MYVERIFY(0 != LoadString(hInstance, IDS_NO_SUPPORTFILES, szMsg, MAX_PATH));
                MessageBox(NULL, szMsg, szServiceName, MB_OK);
            }
            return FALSE;        
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetInstallOptions
//
// Synopsis:  This function decides if the profile should be installed for all
//            users or the current user only, as well as whether the user prefers
//            a desktop icon, a start menu link, both, or neither.
//
// Arguments: OUT BOOL* pbInstallForAllUsers - should the profile be installed for all users
//            OUT BOOL* pbCreateDesktopIcon - should a desktop icon be created (if NT5)
//            IN BOOL bCM10Upgrade - is this profile upgrading an older same name profile
//            IN BOOL bNoNT5Shortcut - whether the user specified a switch saying they didn't want an NT5 Shortcut
//            IN BOOL bSilentSingleUser - whether the user specified a switch saying they wanted a silent Single User install
//            IN BOOL bSilentAllUser - whether the user specified a switch saying they wanted a silent ALL User install
//
// Returns:   TRUE if the install should continue, FALSE otherwise
//
// History:   quintinb Created    11/1/98
//
//+----------------------------------------------------------------------------
BOOL GetInstallOptions(HINSTANCE hInstance, BOOL* pbInstallForAllUsers, 
                       BOOL* pbCreateDesktopIcon, BOOL bCM10Upgrade, BOOL bNoNT5Shortcut, 
                       BOOL bSingleUser, BOOL bSilent, LPTSTR pszServiceName)
{
    //
    //  We will only allow NT5 users who are administrators to have a choice of how 
    //  the profile is installed.  If the user is on a legacy platform then the profile 
    //  will be installed for all users just as before.  If the profile is installed by 
    //  an NT5 user that is not an admin, it will be installed just for them.  If they 
    //  are an admin then they can choose if they want the profile available to all users
    //  or just for themselves.  If we are on NT5 we also allow the user to choose if 
    //  they want a Desktop Shortcut or not.
    //
    INT_PTR iUiReturn;
    CPlatform   plat;

    if (plat.IsWin9x() || plat.IsNT4())
    {
        //
        //  Legacy install, force to all users (ignore SingleUser flag because not supported).
        //
        *pbInstallForAllUsers = TRUE;
    }
    else
    {
        int iDialogID;
        
        if (bSilent)
        {
            *pbCreateDesktopIcon = !bNoNT5Shortcut;

            if (IsAdmin() && !bSingleUser)
            {
                *pbInstallForAllUsers = TRUE;
            }            
            else
            {
                *pbInstallForAllUsers = FALSE;
            }
        }
        else
        {
            if (IsAdmin())
            {
                //
                //  The user is a local admin, we need to prompt to see if they want to install 
                //  the profile for themselves or for all users.  However, if we are doing a
                //  same name upgrade, then we always do an all users install and don't give the
                //  admin any choice.
                //
                if (bCM10Upgrade)
                {
                    iDialogID = IDD_NOCHOICEUI;         
                }
                else
                {
                    iDialogID = IDD_ADMINUI;
                }
            }
            else
            {
                //
                //  Just a normal user, but we still need to prompt for whether they want 
                //  a desktop shortcut
                //
                if (bCM10Upgrade)
                {
                    CMASSERTMSG(FALSE, TEXT("Non-Admin NT5 made it to UI choice section.  Check CM 1.0 upgrade code."));
                    return FALSE;
                }
                else
                {
                    iDialogID = IDD_NOCHOICEUI;         
                }
            }

            InitDialogStruct DialogArgs;
            DialogArgs.pszTitle = pszServiceName;
            DialogArgs.bNoDesktopIcon = bNoNT5Shortcut;
            DialogArgs.bSingleUser = bSingleUser;

            iUiReturn = DialogBoxParam(hInstance, MAKEINTRESOURCE(iDialogID), NULL, 
                (DLGPROC)ProcessPreferencesUI, (LPARAM)&DialogArgs);

            if (-1 == iUiReturn)
            {
                // then we had an error or the user hit cancel.  Either way bail.
                return FALSE;
            }
            else
            {
                *pbInstallForAllUsers = (BOOL)(iUiReturn & ALLUSERS) || bCM10Upgrade;
                *pbCreateDesktopIcon = (BOOL)(iUiReturn & CREATEDESKTOPICON);
            }
        }
    }
    return TRUE;
}

BOOL VerifyProfileOverWriteIfExists(HINSTANCE hInstance, LPCTSTR pszCmsFile, LPCTSTR pszServiceName, 
                                    LPCTSTR pszShortServiceName, LPTSTR pszOldInfPath, BOOL bSilent)
{
    TCHAR szTmpServiceName [MAX_PATH+1] = TEXT("");
    TCHAR szDisplayMsg[3*MAX_PATH+1] = TEXT("");
    TCHAR szTemp [2*MAX_PATH+1] = TEXT("");
    int iRet;

    if (FileExists(pszCmsFile))
    {
        //
        //  If the file exists then we want to make sure that the service name is the same.
        //  If the Long Service Names are the same then we have a re-install.
        //  If they aren't the same then we need to prompt the user and find out whether to
        //  abandon the install or continue and overwrite it.
        //

        MYVERIFY(0 != GetPrivateProfileString(c_pszCmSection, c_pszCmEntryServiceName, 
            TEXT(""), szTmpServiceName, CELEMS(szTmpServiceName), pszCmsFile));

        if (0 != lstrcmp(szTmpServiceName, pszServiceName))
        {
            //
            //  If the install is silent, we will assume they know what they are doing
            //  and we will overwrite.  Otherwise prompt the user to see what they want
            //  us to do.
            //
            if (!bSilent)
            {
                MYVERIFY(0 != LoadString(hInstance, IDS_SAME_SS_DIFF_LS, szTemp, 2*MAX_PATH));

                MYVERIFY(CELEMS(szDisplayMsg) > (UINT)wsprintf(szDisplayMsg, szTemp, pszServiceName, 
                    szTmpServiceName, pszShortServiceName));
            
                MessageBox(NULL, szDisplayMsg, pszServiceName, MB_OK | MB_TOPMOST | MB_SYSTEMMODAL);
            }

            return FALSE;
        }
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  PresharedKeyPINDlgProc
//
// Synopsis:  This function obtains the PIN to be used for the Pre-Shared key
//
// History:   SumitC    29-Mar-2001         Created
//
//+----------------------------------------------------------------------------
BOOL APIENTRY PresharedKeyPINDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    static PresharedKeyPINStruct * pPSKArgs;

    switch (message)
    {
        case WM_INITDIALOG:
            pPSKArgs = (PresharedKeyPINStruct*)lParam;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    MYDBGASSERT(pPSKArgs);
                    if (pPSKArgs && pPSKArgs->szPIN)
                    {
                        GetDlgItemText(hDlg, IDC_PSK_PIN, pPSKArgs->szPIN, c_dwMaxPresharedKeyPIN);
                    }
                    MYVERIFY(FALSE != EndDialog(hDlg, 1));
                    return TRUE;

                case IDCANCEL:
                    MYVERIFY(FALSE != EndDialog(hDlg, -1));
                    return TRUE;

                default:
                    break;
            }
            break;

        case WM_CLOSE:
            MYVERIFY(FALSE != EndDialog(hDlg, -1));
            return TRUE;
            
        default:
            return FALSE;
    }
    return FALSE;   
}


//+----------------------------------------------------------------------------
//
// Function:  GetPINforPresharedKey
//
// Synopsis:  Asks the user for a PIN (to be used to decrypt the pre-shared key)
//
// Arguments: [hInstance]  - used for bringing up dialogs
//            [ppszPIN]    - ptr to where to put Pre-Shared Key PIN
//
// Returns:   LRESULT (ERROR_SUCCESS if we got a PIN,
//                     ERROR_INVALID_DATA if user cancelled out of PIN dialog,
//                     ERROR_INVALID_PARAMETER if params are bad (this is a coding issue)
//
// History:   3-Apr-2001    SumitC      Created
//
//-----------------------------------------------------------------------------
LRESULT GetPINforPresharedKey(HINSTANCE hInstance, LPTSTR * ppszPIN)
{
    LRESULT lRet = ERROR_SUCCESS;
    
    MYDBGASSERT(hInstance);
    MYDBGASSERT(ppszPIN);

    if (NULL == hInstance || NULL == ppszPIN)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    *ppszPIN = NULL;

    //
    //  Get the PIN
    //
    PresharedKeyPINStruct PresharedKeyPINArgs = {0};

    INT_PTR iUiReturn = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_PRESHAREDKEY_PIN), NULL, 
        (DLGPROC)PresharedKeyPINDlgProc, (LPARAM)&PresharedKeyPINArgs);

    if (-1 == iUiReturn)
    {
        lRet = ERROR_INVALID_DATA;  // caller maps to appropriate error message.
    }
    else
    {
        DWORD dwLen = lstrlen(PresharedKeyPINArgs.szPIN);
        if (0 == dwLen)
        {
            lRet = ERROR_INVALID_DATA;  // caller maps to appropriate error message.
        }
        else
        {
            *ppszPIN = (LPTSTR) CmMalloc((dwLen + 1) * sizeof(TCHAR));
            if (*ppszPIN)
            {
                lstrcpy(*ppszPIN, PresharedKeyPINArgs.szPIN);
            }
        }
    }

    return lRet;
}


//+----------------------------------------------------------------------------
//
// Function:  DecryptPresharedKeyUsingPIN
//
// Synopsis:  Given an encoded preshared key and a PIN to be used for decoding,
//            performs the decoding job.
//
// Arguments: [pszEncodedPresharedKey] - encoded Preshared key
//            [pszPreSharedKeyPIN]     - the PIN
//            [ppszPreSharedKey]       - ptr to buffer to place Pre-Shared Key
//
// Returns:   LRESULT (ERROR_SUCCESS successfully decoded
//                     ERROR_INVALID_PARAMETER if params are bad (this is a coding issue)
//                     other errors as encountered while calling crypto APIs
//
// History:   3-Apr-2001    SumitC      Created
//
//-----------------------------------------------------------------------------
LRESULT DecryptPresharedKeyUsingPIN(LPCTSTR pszEncodedPresharedKey,
                                    LPCTSTR pszPresharedKeyPIN,
                                    LPTSTR * ppszPresharedKey)
{
    LRESULT lRet = ERROR_BADKEY;

    if (lstrlen(pszPresharedKeyPIN) < c_dwMinPresharedKeyPIN)
    {
        CMTRACE(TEXT("DecryptPresharedKeyUsingPIN - PIN is too short"));
        return lRet;
    }
    if (lstrlen(pszPresharedKeyPIN) > c_dwMaxPresharedKeyPIN)
    {
        CMTRACE(TEXT("DecryptPresharedKeyUsingPIN - PIN is too long"));
        return lRet;
    }

    //
    //  Init Cmsecure
    //
    InitSecure(FALSE);      // use secure, not fast encryption

    //
    //  decrypt to get Preshared key
    //
    if (pszEncodedPresharedKey && pszPresharedKeyPIN)
    {
        DWORD dwLen = 0;

        if (FALSE == DecryptString((LPBYTE)pszEncodedPresharedKey,
                                   lstrlen(pszEncodedPresharedKey) * sizeof(TCHAR),
                                   (LPSTR)pszPresharedKeyPIN,
                                   (LPBYTE *)ppszPresharedKey,
                                   &dwLen,
                                   (PFN_CMSECUREALLOC)CmMalloc,
                                   (PFN_CMSECUREFREE)CmFree))
        {
            CMTRACE1(TEXT("DecryptPresharedKeyUsingPIN - DecryptString failed with %d"), GetLastError());
            lRet = ERROR_BADKEY;
        }
        else
        {
            lRet = ERROR_SUCCESS;
            CMASSERTMSG(dwLen, TEXT("DecryptString succeeded, but pre-shared key retrieved was 0 bytes?"));
        }
    }

    //
    //  Deinit cmsecure
    //
    DeInitSecure();

    return lRet;
}


//+----------------------------------------------------------------------------
//
// Function:  SetThisConnectionAsDefault
//
// Synopsis:  This function loads inetcfg.dll and calls the InetSetAutodial
//            entry on the given service name.  Thus this function sets the
//            given servicename as the IE default connection.
//
// Arguments: LPCSTR pszServiceName - Long service name of the connection to set
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb Created    03/04/00
//
//+----------------------------------------------------------------------------
BOOL SetThisConnectionAsDefault(LPSTR pszServiceName)
{
    BOOL bReturn = FALSE;
    typedef HRESULT (WINAPI *pfnInetSetAutodialProc)(BOOL, LPSTR);

    if (pszServiceName && (TEXT('\0') != pszServiceName[0]))
    {
        CDynamicLibrary CnetCfg;

        if (CnetCfg.Load(TEXT("inetcfg.dll")))
        {
            pfnInetSetAutodialProc pfnInetSetAutodial = (pfnInetSetAutodialProc)CnetCfg.GetProcAddress("InetSetAutodial");

            if (pfnInetSetAutodial)
            {
                HRESULT hr = pfnInetSetAutodial(TRUE, pszServiceName); // TRUE == fEnable
                bReturn = SUCCEEDED(hr);
            }
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  InstallInf
//
// Synopsis:  This is the driver code for installing a CM profile.
//
// Arguments: HINSTANCE hInstance - Instance handle for resources
//            LPCTSTR szInfFile - INF file to install
//            BOOL bNoSupportFiles - forces browser files not to be installed.
//            BOOL bNoLegacyIcon - Don't install with a legacy Icon
//            BOOL bNoNT5Shortcut - Don't give the user a NT5 Desktop Shortcut
//            BOOL bSilentSingleUser - Install the profile silently for a single user (NT5 only)
//            BOOL bSilentAllUser - Install the profile for All Users silently
//            BOOL bSetAsDefault - set as the default connection once installed
//            CNamedMutex* pCmstpMutex - pointer to the cmstp mutex object so 
//                                       that it can be released once the profile is launched
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created    7/14/98
//            quintinb added support for new switches (252872)    11/20/98
//
//+----------------------------------------------------------------------------
HRESULT InstallInf(HINSTANCE hInstance, LPCTSTR szInfFile, BOOL bNoSupportFiles, 
                BOOL bNoLegacyIcon, BOOL bNoNT5Shortcut, BOOL bSilent, 
                BOOL bSingleUser, BOOL bSetAsDefault, CNamedMutex* pCmstpMutex)
{
    CPlatform   plat;

    BOOL bMigrateExistingProfiles;
    BOOL bInstallCm;
    BOOL bMustReboot = FALSE;
    BOOL bCM10Upgrade = FALSE;
    HRESULT hrReturn = S_OK;
    HRESULT hrTemp = S_OK;
    BOOL bInstallForAllUsers;
    BOOL bCreateDesktopIcon = FALSE;

    HKEY hKey;

    DWORD dwSize;
    DWORD dwType;
    TCHAR szInstallDir[MAX_PATH+1];
    TCHAR szTemp[2*MAX_PATH+1];
    TCHAR szCmsFile[MAX_PATH+1];
    TCHAR szOldInfPath[MAX_PATH+1];
    TCHAR szServiceName[MAX_PATH+1];
    TCHAR szShortServiceName[MAX_PATH+1];
    TCHAR szTitle[MAX_PATH+1];
    LPTSTR pszPhonebook = NULL;
    LPTSTR pszCmpFile = NULL;
    LPTSTR pszPresharedKey = NULL;

//CMASSERTMSG(FALSE, TEXT("Attach the Debugger now!"));
    MYDBGASSERT((szInfFile) && (TEXT('\0') != szInfFile[0]));

    CFileNameParts InfParts(szInfFile);
    wsprintf(g_szProfileSourceDir, TEXT("%s%s"), InfParts.m_Drive, InfParts.m_Dir);

    MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, CELEMS(szTitle)));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);

    //
    //  Get the ServiceName and ShortServicename from the inf file
    //

    MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, 
        TEXT(""), szServiceName, CELEMS(szServiceName), szInfFile));

    MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszShortSvcName, 
        TEXT(""), szShortServiceName, CELEMS(szShortServiceName), szInfFile));

    if ((TEXT('\0') == szServiceName[0]) || (TEXT('\0') == szShortServiceName[0]))
    {
        CMASSERTMSG(FALSE, TEXT("Either the ServiceName or the ShortServiceName are empty, exiting."));
        hrReturn = E_FAIL;
        goto exit;
    }

    //
    //  If this is NT5, check the New Connection Wizard Policy to see if the user is allowed to
    //  create new connections.  If not, then don't let them install.
    //
    if (plat.IsAtLeastNT5())
    {
        LPTSTR c_pszNewPolicy = TEXT("NC_NewConnectionWizard");
        LPTSTR c_pszConnectionsPoliciesKey = TEXT("Software\\Policies\\Microsoft\\Windows\\Network Connections");

        HKEY hKey = NULL;

        //
        //  Administrators and all Authenticated users have access to install profiles
        //  by default.  Non-Authenticated users don't have access to install profiles
        //  because they don't have permission to start Rasman.  Thus, even if we
        //  allowed them to try to install, it would fail when we couldn't create a
        //  connectoid for the profile.
        //
        DWORD dwAllowedToInstall = IsAuthenticatedUser() || IsAdmin();

        //
        //  Now we need to check the policy registry key to see if someone has overriden
        //  the default behavior.  If so, then we will honor it by setting dwAllowedToInstall
        //  to the value of the policy key.  Note that we even check the registry key for
        //  authenticated users (an Admin could enable installation for all users, but users
        //  that weren't Authenticated, namely guests, wouldn't be able to The default is to allow Users, Power Users (who are users), and Admins to install
        //  connections.  However the policy may be setup so that they cannot.  Lets assume they
        //  can and then check the regkey.
        //
        if (dwAllowedToInstall)
        {
            LONG lResult = RegOpenKeyEx(HKEY_CURRENT_USER, c_pszConnectionsPoliciesKey, 
                                        0, KEY_READ, &hKey);

            if (ERROR_SUCCESS == lResult)
            {
                dwSize = sizeof(dwAllowedToInstall);

                lResult = RegQueryValueEx(hKey, c_pszNewPolicy, NULL, 
                                          NULL, (LPBYTE)&dwAllowedToInstall, &dwSize);                
                RegCloseKey(hKey);
            }
        }

        if (!dwAllowedToInstall)
        {
            //
            //  The user isn't allowed to create new connections, thus they aren't allowed to install
            //  CM connections.  Throw an error message about permissions and exit.
            //
            MYVERIFY(0 != LoadString(hInstance, IDS_INSTALL_NOT_ALLOWED, szTemp, CELEMS(szTemp)));
            MessageBox(NULL, szTemp, szServiceName, MB_OK);
            hrReturn = E_ACCESSDENIED;
            goto exit;
        }
    }

    if (!CheckCmAndIeRequirements(hInstance, &bInstallCm, &bMigrateExistingProfiles, 
        szInfFile, bNoSupportFiles, szServiceName, bSilent))
    {
        hrReturn = E_FAIL;
        goto exit;
    }

    //
    //  Check to see if we have a same name upgrade
    //
    
    bCM10Upgrade = NeedCM10Upgrade(hInstance, szServiceName, szShortServiceName, 
                                   szOldInfPath, bSilent, &plat);

    if (-1 == bCM10Upgrade)
    {
        //
        //  if NeedCM10Upgrade returned -1 then either an error occurred or
        //  the user decided not to upgrade.  Either way, bail.
        //
        hrReturn = S_FALSE;
        goto exit;
    }

    //
    //  Check to see if a Pre-shared Key is present, and require a PIN if so
    //
    pszCmpFile = szTemp;    // re-use szTemp to save stack space and not get into trouble on Win9x
    MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(pszCmpFile, TEXT("%s%s.cmp"), 
        g_szProfileSourceDir, szShortServiceName));

    if (FileExists(pszCmpFile))
    {
        pszPresharedKey = GetPrivateProfileStringWithAlloc(c_pszCmSection, c_pszCmEntryPresharedKey, TEXT(""), pszCmpFile);

        if (pszPresharedKey && (0 != lstrcmp(pszPresharedKey, TEXT(""))))
        {
            CMTRACE(TEXT("Got a pre-shared key"));

            if (FALSE == plat.IsAtLeastNT51())
            {
                // NOTE: pszCmpFile is really szTemp, and we're about to overwrite it, but
                //       it's ok because we're also about to exit
                MYVERIFY(0 != LoadString(hInstance, IDS_PSK_NEEDS_XP, szTemp, CELEMS(szTemp)));
                MessageBox(NULL, szTemp, szServiceName, MB_OK | MB_ICONERROR);
                hrReturn = S_FALSE;
                goto exit;
            }

            BOOL bEncrypted = (BOOL) GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryKeyIsEncrypted, FALSE, pszCmpFile);

            if (bEncrypted)
            {
                CMTRACE(TEXT("Pre-shared key is encrypted"));

                LPTSTR pszPresharedKeyPIN = NULL;
                LRESULT lRet = GetPINforPresharedKey(hInstance, &pszPresharedKeyPIN);

                if ((ERROR_SUCCESS == lRet) && pszPresharedKeyPIN)
                {
                    //
                    //  The Pre-shared key is encoded
                    //
                    LPTSTR pszPresharedKeyDecoded = NULL;
                    lRet = DecryptPresharedKeyUsingPIN(pszPresharedKey, pszPresharedKeyPIN, &pszPresharedKeyDecoded);

                    CmFree(pszPresharedKey);
                    if (ERROR_SUCCESS == lRet)
                    {
                        pszPresharedKey = pszPresharedKeyDecoded;
                    }
                    else
                    {
                        pszPresharedKey = NULL;
                        lRet = ERROR_BADKEY;
                    }
                }

                CmFree(pszPresharedKeyPIN);

                if (ERROR_SUCCESS != lRet)
                {
                    switch (lRet)
                    {
                    case ERROR_INVALID_DATA:
                        MYVERIFY(0 != LoadString(hInstance, IDS_PSK_GOTTA_HAVE_IT, szTemp, CELEMS(szTemp)));
                        break;
                    case ERROR_BADKEY:
                        MYVERIFY(0 != LoadString(hInstance, IDS_PSK_INCORRECT_PIN, szTemp, CELEMS(szTemp)));
                        break;
                    default:
                        MYVERIFY(0 != LoadString(hInstance, IDS_UNEXPECTEDERR, szTemp, CELEMS(szTemp)));
                        MYDBGASSERT(0);
                        break;
                    }

                    MessageBox(NULL, szTemp, szServiceName, MB_OK | MB_ICONEXCLAMATION);
                    hrReturn = E_ACCESSDENIED;
                    goto exit;
                }
            }
        }
    }    
    
    if (!GetInstallOptions(hInstance, &bInstallForAllUsers, &bCreateDesktopIcon, 
        bCM10Upgrade, bNoNT5Shortcut, bSingleUser, bSilent, szServiceName))
    {
        hrReturn = S_FALSE;
        goto exit;    
    }

    //
    //  Get the installation path
    //

    ZeroMemory(szInstallDir, sizeof(szInstallDir));

    if (bInstallForAllUsers)
    {
        //
        //  Install for All Users
        //

        if (!GetAllUsersCmDir(szInstallDir, hInstance))
        {
            hrReturn = E_FAIL;
            goto exit; 
        }
    }
    else
    {
        //
        //  Install only for the current user
        //
        
        GetPrivateCmUserDir(szInstallDir, hInstance);   //lint !e534

        if (TEXT('\0') == szInstallDir[0])
        {
            hrReturn = E_FAIL;
            goto exit;        
        }
    }

    MYVERIFY(CELEMS(szCmsFile) > (UINT)wsprintf(szCmsFile, TEXT("%s\\%s\\%s.cms"), 
        szInstallDir, szShortServiceName, szShortServiceName));

    //
    //  Check for two profiles with the same Short Service Name and different Long Service
    //  Names
    //
    if (!VerifyProfileOverWriteIfExists(hInstance, szCmsFile, 
         szServiceName, szShortServiceName, szOldInfPath, bSilent))
    {
        hrReturn = S_FALSE;
        goto exit;
    }

    //  Now Migrate users old cm profiles (to have full paths to their CMP files in the 
    //  desktop GUID) if necessary
    //
    if (bMigrateExistingProfiles)
    {
        //
        //  Ignore the return here for now.  Not much we can do about it at this stage.
        //  Should we give them an error?
        //
        MYVERIFY(SUCCEEDED(MigrateOldCmProfilesForProfileInstall(hInstance, g_szProfileSourceDir)));
    }

    if (bCM10Upgrade)
    {
        //
        //  Uninstall the current profile so that we can install the newer version.  Note
        //  that we don't want to use the uninstall string because it might call for
        //  cmstp.exe which is already running.  Thus uninstall by calling UninstallProfile
        //  directly.  Note that we do not delete the credentials on a same name upgrade
        //  profile uninstall.
        //

        if (szOldInfPath[0])
        {
            RemoveShowIconFromRunPostSetupCommands(szOldInfPath);

            MYVERIFY(SUCCEEDED(UninstallProfile(hInstance, szOldInfPath, FALSE))); // bCleanUpCreds == FALSE
        }
    }
    else
    {
        //
        //  We need to check if we are installing over another profile of the same name.
        //  If so, then we want to recover the cmp data unless this is a CM 1.0 upgrade
        //  in which case we have already done this as part of that upgrade code.
        //
        if (-1 == MigrateCmpData(hInstance, bInstallForAllUsers, szServiceName, szShortServiceName, bSilent))
        {
            hrReturn = S_FALSE;
            goto exit;        
        }
    }

    //
    //  In order to keep MSN's online setup working we need to keep the all user install 
    //  registry key (used to communicate the path to the inf) in the same place that it was
    //  for the Win98 SE/Beta3 release.  The Single user reg key location had to be moved to 
    //  allow plain old users to install profiles.
    //
    HKEY hBaseKey;
    LPTSTR pszRegInfCommKeyPath;

    if (bInstallForAllUsers)
    {
        hBaseKey = HKEY_LOCAL_MACHINE;
        pszRegInfCommKeyPath = (LPTSTR)c_pszRegCmAppPaths;
    }
    else
    {
        hBaseKey = HKEY_CURRENT_USER;
        pszRegInfCommKeyPath = (LPTSTR)c_pszRegCmRoot;
    }


    //
    //  Now create the install dir and the reg key to communicate this info to the inf file.
    //
    if (TEXT('\0') != szInstallDir[0])
    {
        //
        //  Create the full path to the installation directory.
        //
        MYVERIFY(FALSE != CreateLayerDirectory(szInstallDir));

        //
        //  Create the Profile subdirectory too, that way we avoid profile
        //  install problems on Win98 -- NTRAID 376878
        //
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s"), szInstallDir, szShortServiceName));
        MYVERIFY(FALSE != CreateLayerDirectory(szTemp));

        //
        //  We now need to write the registry key that the inf will use as the
        //  installation directory.  See the CustomDestination section of the 
        //  profile inf to see where this ties in.
        //
        if (plat.IsWin9x())
        {
            //
            //  Then we need to use the Short Name in the regkey or the inf will not install properly
            //
            MYVERIFY(0 != GetShortPathName(szInstallDir, szTemp, CELEMS(szTemp)));

            lstrcpy(szInstallDir, szTemp);
        }

        if (ERROR_SUCCESS != RegCreateKey(hBaseKey, pszRegInfCommKeyPath, &hKey))
        {
            CMASSERTMSG(FALSE, TEXT("InstallInf -- Unable to create the Inf Communication Key"));
            MYVERIFY(0 != LoadString(hInstance, IDS_UNEXPECTEDERR, szTemp, CELEMS(szTemp)));
            MessageBox(NULL, szTemp, szServiceName, MB_OK);
            hrReturn = E_FAIL;
            goto exit;
        }

        //
        //  We now need to create the value with our szInstallDir string.
        //
        
        dwType = REG_SZ;
        dwSize = lstrlen(szInstallDir);
        if (ERROR_SUCCESS != RegSetValueEx(hKey, c_pszProfileInstallPath, NULL, dwType, 
            (CONST BYTE *)szInstallDir, dwSize))
        {
            CMASSERTMSG(FALSE, TEXT("InstallInf -- Unable to set the Profile Install Path value."));
            MYVERIFY(0 != LoadString(hInstance, IDS_UNEXPECTEDERR, szTemp, CELEMS(szTemp)));
            MessageBox(NULL, szTemp, szServiceName, MB_OK);

            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
            hrReturn = E_FAIL;
            goto exit;
        }

        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("InstallInf -- Unable to resolve the Install Directory."));
        MYVERIFY(0 != LoadString(hInstance, IDS_UNEXPECTEDERR, szTemp, CELEMS(szTemp)));
        MessageBox(NULL, szTemp, szServiceName, MB_OK);
        hrReturn = E_FAIL;
        goto exit;
    }

    //
    //  Install the Profile Files and create the mappings entry
    //

    if (bInstallForAllUsers)
    {
        hrTemp = LaunchInfSection(szInfFile, TEXT("DefaultInstall"), szTitle, bSilent);
        MYDBGASSERT(SUCCEEDED(hrTemp));
        bMustReboot = (ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;

        //
        //  Still launch this for Legacy (read MSN online setup reasons, perhaps others)
        //
        hrTemp = LaunchInfSection(szInfFile, TEXT("Xnstall_AllUser"), szTitle, bSilent);
        MYDBGASSERT(SUCCEEDED(hrTemp));
        bMustReboot = (ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;
    }
    else
    {
        hrTemp = LaunchInfSection(szInfFile, TEXT("DefaultInstall_SingleUser"), szTitle, bSilent);
        MYDBGASSERT(SUCCEEDED(hrTemp));
        bMustReboot = (ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;

        //
        //  Still launch this for Legacy (I doubt anyone is using this but kept 
        //  for consistency with All User which at least MSN was using)
        //
        hrTemp = LaunchInfSection(szInfFile, TEXT("Xnstall_Private"), szTitle, bSilent);
        MYDBGASSERT(SUCCEEDED(hrTemp));
        bMustReboot = (ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;

        //
        //  Write the single user mappings key in code since parsing is involved.
        //

        if (!WriteSingleUserProfileMappings(szInstallDir, szShortServiceName, szServiceName))
        {
            CMASSERTMSG(FALSE, TEXT("InstallInf -- WriteSingleUserProfileMappings Failed."));
            MYVERIFY(0 != LoadString(hInstance, IDS_UNEXPECTEDERR, szTemp, CELEMS(szTemp)));
            MessageBox(NULL, szTemp, szServiceName, MB_OK);
            hrReturn = E_FAIL;
            goto exit;            
        }
    }

    //
    //  Install the CM bits as necessary
    //
    if (bInstallCm)
    {
        MYDBGASSERT(FALSE == plat.IsNT51());

        //
        //  First, we must extract the CM binaries from the binaries
        //  executable/cab to the cmbins sub dir.
        //
        wsprintf(szTemp, TEXT("%scmbins\\"), g_szProfileSourceDir);

        hrTemp = ExtractCmBinsFromExe(g_szProfileSourceDir, szTemp);

        if (SUCCEEDED(hrTemp))
        {
            if (plat.IsNT5())
            {
                //
                //  Check to see if we need to uninstall a previous CM exception inf
                //  and uninstall it as necessary.
                //
                hrTemp = UninstallExistingCmException();
                MYDBGASSERT((S_OK == hrTemp) || (S_FALSE == hrTemp));

                //
                //  Finally, install the CM bits
                //
                hrTemp = InstallWhistlerCmOnWin2k(szTemp);

                if (FAILED(hrTemp))
                {
                    if (!bSilent)
                    {
                        MYVERIFY(0 != LoadString(hInstance, IDS_WIN2K_CM_INSTALL_FAILED, szTemp, CELEMS(szTemp)));
                        
                        MessageBox(NULL, szTemp, szServiceName, MB_OK | MB_ICONEXCLAMATION);
                    }                
                }
            }
            else
            {
                //
                //  Okay, we need to copy the instcm.inf file to the cmbins dir and then
                //  call InstallCm
                //
                LPCTSTR ArrayOfFileNames[] = {
                                                TEXT("cnet16.dll"),
                                                TEXT("ccfg95.dll"),
                                                TEXT("cmutoa.dll"),
                                                TEXT("instcm.inf") // instcm.inf must be last so it is given to InstallCm correctly.
                };

                TCHAR szSource [MAX_PATH+1] = {0};
                TCHAR szDest [MAX_PATH+1] = {0};

                for (int i = 0; i < (sizeof(ArrayOfFileNames)/sizeof(LPCTSTR)); i++)
                {
                    MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s%s"), szTemp, ArrayOfFileNames[i]));
                    MYVERIFY(CELEMS(szSource) > (UINT)wsprintf(szSource, TEXT("%s%s"), g_szProfileSourceDir, ArrayOfFileNames[i]));
            
                    MYVERIFY(CopyFile(szSource, szDest, FALSE)); // FALSE == bFailIfExists
                }

                hrTemp = InstallCm(hInstance, szDest);
            }

            MYDBGASSERT(SUCCEEDED(hrTemp));
            bMustReboot = (ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("InstallInf -- ExtractCmBinsFromExe failed!"));
        }
    }

    //
    //  Now Create the Connectoid. Even if it fails, continue to install. 
    //
    if (GetPhoneBookPath(szInstallDir, &pszPhonebook, bInstallForAllUsers))
    {
       BOOL bReturn = WriteCmPhonebookEntry(szServiceName, pszPhonebook, szCmsFile);

       if (!bReturn && plat.IsAtLeastNT5())
       {
           CMASSERTMSG(FALSE, TEXT("CMSTP Failed to create a pbk entry on NT5, exiting."));
           hrReturn = E_FAIL;
           goto exit;      
       }
    }
    else if (plat.IsAtLeastNT5())
    {
        CMASSERTMSG(FALSE, TEXT("CMSTP Failed to get a pbk path on NT5, exiting."));
        hrReturn = E_FAIL;
        goto exit;
    }

    //
    //  Now we have all the files installed and the pbk entry written,
    //  finally create the desktop shortcut/GUID
    //
    if ((plat.IsWin9x()) || (plat.IsNT4()))
    {
        //
        //  If we have a Legacy install, then we need to create a desktop icon
        //
        if  (!bNoLegacyIcon)
        {
            hrTemp = LaunchInfSection(szInfFile, TEXT("Xnstall_Legacy"), szTitle, bSilent);
            MYDBGASSERT(SUCCEEDED(hrTemp));
            bMustReboot = (ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;
        }
    }
    else
    {
        //
        //  Create a desktop shortcut if necessary
        //
        DeleteNT5ShortcutFromPathAndName(hInstance, szServiceName, 
            bInstallForAllUsers ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY);

        if (bCreateDesktopIcon)
        {
            HRESULT hr = CreateNT5ProfileShortcut(szServiceName, pszPhonebook, bInstallForAllUsers);
            MYVERIFY(SUCCEEDED(hr));
        }
    }

    //
    //  The profile is now basically installed.  Before doing any post install commands, lets check to see
    //  if the caller asked us to set this connection as the default connection.  If so, then
    //  lets set it here.
    //
    if (bSetAsDefault)
    {
        MYVERIFY(SetThisConnectionAsDefault(szServiceName));
    }

    //
    //  if we have a preshared key, give it to RAS
    //
    if (pszPresharedKey)
    {
        if (FALSE == plat.IsAtLeastNT51())
        {
            CMASSERTMSG(0, TEXT("profile has a preshared key on pre-XP platform - we should never get here."));

            MYVERIFY(0 != LoadString(hInstance, IDS_PSK_NEEDS_XP, szTemp, CELEMS(szTemp)));
            MessageBox(NULL, szTemp, szServiceName, MB_OK | MB_ICONERROR);
            hrReturn = S_FALSE;
            goto exit;
        }

        pfnRasSetCredentialsSpec pfnSetCredentials;

        hrReturn = E_FAIL;

        if (FALSE == GetRasApis(NULL, NULL, NULL, NULL, NULL, &pfnSetCredentials))
        {
            CMASSERTMSG(FALSE, TEXT("CMSTP Failed to get RAS API RasSetCredentials, exiting."));
            goto exit;      
        }
        
        if (lstrlen(pszPresharedKey) > PWLEN)
        {
            CMASSERTMSG(FALSE, TEXT("preshared key is larger than RasSetCredentials can handle!"));
            goto exit;      
        }

        RASCREDENTIALS * pRasCreds = NULL;

        pRasCreds = (RASCREDENTIALS *) CmMalloc(sizeof(RASCREDENTIALS));
        if (NULL == pRasCreds)
        {
            hrReturn = E_OUTOFMEMORY;
            goto exit;
        }

        pRasCreds->dwSize = sizeof(RASCREDENTIALS);
        pRasCreds->dwMask = RASEO2_UsePreSharedKey;
        lstrcpyn(pRasCreds->szPassword, pszPresharedKey, lstrlen(pszPresharedKey) + 1);
            
        if (0 != pfnSetCredentials(pszPhonebook, szServiceName, pRasCreds, FALSE))    // FALSE => set the credentials
        {
           CMASSERTMSG(FALSE, TEXT("CMSTP RasSetCredentials failed, exiting."));
           CmFree(pRasCreds);
           goto exit;
        }

        CmFree(pRasCreds);
        hrReturn = S_OK;

        //
        //  remove the pre-shared key from the .CMP file
        //
        pszCmpFile = szTemp;    // re-use szTemp to save stack space and not get into trouble on Win9x
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(pszCmpFile, TEXT("%s%s.cmp"), 
            g_szProfileSourceDir, szShortServiceName));

        if (FileExists(pszCmpFile))
        {
            WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPresharedKey, NULL, pszCmpFile);
            WritePrivateProfileString(c_pszCmSection, c_pszCmEntryKeyIsEncrypted, NULL, pszCmpFile);
        }
     }

    //
    //  Do any postinstall cmds here
    //
    LPTSTR pszPostInstallSection;

    if (bInstallForAllUsers)
    {
        pszPostInstallSection = TEXT("PostInstall");
    }
    else
    {
        pszPostInstallSection = TEXT("PostInstall_Single");
    }

    hrTemp = LaunchInfSection(szInfFile, pszPostInstallSection, szTitle, bSilent);
    MYDBGASSERT(SUCCEEDED(hrTemp));
    bMustReboot = (ERROR_SUCCESS_REBOOT_REQUIRED == hrTemp) ? TRUE: bMustReboot;

    //
    //  Delete the temporary reg key that we used to communicate the install path to the inf
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(hBaseKey, pszRegInfCommKeyPath, 
                                      0, KEY_ALL_ACCESS, &hKey))
    {
        MYVERIFY(ERROR_SUCCESS == RegDeleteValue(hKey, c_pszProfileInstallPath));
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("Unable to delete the ProfileInstallPath temporary Reg value."));
    }

    //
    //  Refresh the desktop so that any GUID or shortcut changes will appear
    //
    RefreshDesktop();

    //
    //  For Win98 and Millennium, we write an App Compatibility flag in order to
    //  fix SetForegroundWindow.  Refer also to Q135788 for more details of the
    //  original fix (which requires this extra code on Win9x to actually work).
    //
    //  This fixes Whistler bugs 41696 and 90576.
    //
    if (plat.IsWin98())
    {
        if (!WriteProfileString(TEXT("Compatibility95"), TEXT("CMMON32"), TEXT("0x00000002")))
        {
            CMTRACE(TEXT("InstallInf - failed to write app compat entry for CMMON32 to fix SetForegroundWindow"));
        }
    }

    //
    //  We are finally completed.  If we need to reboot, show the user the reboot prompt.
    //  Otherwise, show the user a completion message.
    //

    if (bMustReboot)
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_REBOOT_MSG, szTemp, CELEMS(szTemp)));

        int iRes = MessageBoxEx(NULL,
                                szTemp,
                                szServiceName,
                                MB_YESNO | MB_DEFBUTTON1 | MB_ICONWARNING | MB_SETFOREGROUND,
                                LANG_USER_DEFAULT);

        if (IDYES == iRes) 
        {
            //
            // Shutdown Windows
            //
            DWORD dwReason = plat.IsAtLeastNT51() ? (SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_INSTALLATION) : 0;

            MyExitWindowsEx(EWX_REBOOT, dwReason);
        }
    }
    else if (!bSilent)
    {
        //
        //  Instead of giving the user a message box, we will launch the profile
        //  for them. (NTRAID 201307)
        //

        if (plat.IsAtLeastNT5())
        {
            pCmstpMutex->Unlock();  //NTRAID 310478

        }

        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s\\%s.cmp"), 
            szInstallDir, szShortServiceName));

        LaunchProfile(szTemp, szServiceName, pszPhonebook, bInstallForAllUsers);
    }

exit:

    CmFree(pszPresharedKey);
    CmFree(pszPhonebook);
    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\loadconnfolder.cpp ===
//+----------------------------------------------------------------------------
//
// File:     loadconnfolder.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains the code that implements the 
//           CLoadConnFolder Class.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/14/98
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

CLoadConnFolder::CLoadConnFolder()
{
    ULONG ulCount;

    // "CLSID_MyComputer\CLSID_ControlPanel\CLSID_ConnectionsFolder"
    // Note -- ParseDisplayName() is miss declared, it should take a const ptr
    //
    #define NETCON_FOLDER_PATH  L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\" \
                                L"::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\" \
                                L"::{7007acc7-3202-11d1-aad2-00805fc1270e}";

    WCHAR c_szMyFolderName[] =  NETCON_FOLDER_PATH;

    //
    //  Set initial states of class vars
    //

    m_pConnectionsFolder = NULL;
    m_ConnFolderpidl = NULL;
    m_pDesktopFolder = NULL;
    m_HrClassState = E_UNEXPECTED;


    //
    //  Start retrieving the conn folder
    //

    m_HrClassState = CoInitialize(NULL);

    //
    //  Save whether CoInit succeeded or not
    //
    m_CoInit = SUCCEEDED(m_HrClassState);
    
    if (SUCCEEDED(m_HrClassState))
    {
        //
        // Get the desktop folder, so we can parse the display name and get
        // the UI object of the connections folder
        //

        m_HrClassState = SHGetDesktopFolder(&m_pDesktopFolder);
        if (SUCCEEDED(m_HrClassState))
        {
            m_HrClassState = m_pDesktopFolder->ParseDisplayName(NULL, 0, (WCHAR *) c_szMyFolderName,
                                &ulCount, &m_ConnFolderpidl, NULL);
            if (SUCCEEDED(m_HrClassState))
            {
                //
                //  Now we have the pidl for the Connections Folder
                //
                m_HrClassState = m_pDesktopFolder->BindToObject(m_ConnFolderpidl, NULL, IID_IShellFolder, 
                    (LPVOID*)(&m_pConnectionsFolder));
            }
        }
    }
}


CLoadConnFolder::~CLoadConnFolder()
{
    if (m_pConnectionsFolder)
    {
        m_pConnectionsFolder->Release();
        m_pConnectionsFolder = NULL;
    }

    if (m_pDesktopFolder)
    {
        m_pDesktopFolder->Release();
        m_pDesktopFolder = NULL;
    }

    if (m_ConnFolderpidl)
    {
        LPMALLOC pMalloc;
        HRESULT hr = SHGetMalloc(&pMalloc);
        if (SUCCEEDED(hr))
        {
            pMalloc->Free(m_ConnFolderpidl);
            pMalloc->Release();
            m_ConnFolderpidl = NULL;
        }
    }

    if (m_CoInit)
    {
        CoUninitialize();
    }

    m_HrClassState = S_FALSE;

}

HRESULT CLoadConnFolder::HrLaunchConnFolder()
{
    SHELLEXECUTEINFO  sei;
    HRESULT hr = S_OK;

    if (NULL != m_ConnFolderpidl)
    {
        ZeroMemory(&sei, sizeof(sei));
        sei.cbSize = sizeof(sei);
        sei.fMask = SEE_MASK_IDLIST | SEE_MASK_CLASSNAME;
        sei.lpIDList = m_ConnFolderpidl;
        sei.lpClass = TEXT("folder");
        sei.hwnd = NULL; //lpcmi->hwnd;
        sei.nShow = SW_SHOWNORMAL;
        sei.lpVerb = TEXT("open");

        if (!ShellExecuteEx(&sei))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\common.cpp ===
//+----------------------------------------------------------------------------
//
// File:     common.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains functions common to several 
//           different aspects of the CM profile installer (install, 
//           uninstall, migration).
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     11/18/97
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
//  for GetPhoneBookPath
//
#include "getpbk.cpp"

//
//  For GetAllUsersCmDir
//
#include "allcmdir.cpp"

//
//  Need the definition for CM_PBK_FILTER_PREFIX
//
#include "cmdefs.h"

//
//  Include the Connections folder specific headers
//
//#include "shlobjp.h"
//#include <objbase.h>    // needed for initing guids
//#include <initguid.h>   // DON'T CHANGE the ORDER of these header files unless you know what you are doing
//#include <oleguid.h>    // IID_IDataObject
//#include <shlguid.h>    // IID_IShellFolder

//+----------------------------------------------------------------------------
//
// Function:  GetHiddenPhoneBookPath
//
// Synopsis:  This function returns the path for the hidden RAS pbk to contain
//            the PPP connectoid of a double dial connection.  Before returing
//            it checks to see if the phonebook exists or not.  If the phonebook
//            doesn't exist then it returns FALSE.  If the function returns
//            TRUE the path allocated and stored in *ppszPhonebook must be
//            freed using CmFree.
//
// Arguments: LPCTSTR pszProfileDir - full path to the profile directory (dir where cmp resides)
//            LPTSTR* ppszPhonebook - pointer to hold the allocated path
//
// Returns:   BOOL - TRUE if the phonebook path can be constructed and the
//                   phonebook file exists.
//
// History:   quintinb Created Header    04/14/00
//
//+----------------------------------------------------------------------------
BOOL GetHiddenPhoneBookPath(LPCTSTR pszProfileDir, LPTSTR* ppszPhonebook)
{
// REVIEW:  quintinb  12-18-00
//          This function returns the wrong path for the Hidden phonebook.  This file is
//          now named _CMPhone (no .pbk extension) and is now located in the same directory
//          as the rasphone.pbk file on NT4, NT5, and whistler.  Note that this function isn't
//          used on Win9x.  Since the problem was low priority (leaving a few K file on the users
//          harddrive at uninstall time, we punted the problem as it was close to Beta2 lockdown.
//
    BOOL bReturn = FALSE;

    if (pszProfileDir && ppszPhonebook && (TEXT('\0') != pszProfileDir[0]))
    {        
        LPTSTR pszPathToReturn = NULL;

        *ppszPhonebook = (LPTSTR) CmMalloc((lstrlen(pszProfileDir) + lstrlen(CM_PBK_FILTER_PREFIX) + 13) * sizeof(TCHAR));

        MYDBGASSERT(*ppszPhonebook);

        if (*ppszPhonebook)
        {    
            //
            // Note -- The connection enumerator (netman) will filter out notifications
            // for connections created in files with the CM_PBK_FILTER_PREFIX in their
            // name. 
            //
            wsprintf(*ppszPhonebook, TEXT("%s\\%sphone.pbk"), pszProfileDir, CM_PBK_FILTER_PREFIX);

            bReturn = FileExists(*ppszPhonebook);
        }
    }

    if (FALSE == bReturn)
    {
        CmFree(*ppszPhonebook);
        *ppszPhonebook = NULL;
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RemoveShowIconFromRunPostSetupCommands
//
// Synopsis:  This function removes showicon.exe from the RunPostSetupCommands
//            section of old 1.0 Infs.
//
// Arguments: LPCTSTR szInfFile - the inf file to remove showicon.exe from
//
// Returns:   Nothing
//
// History:   quintinb Created Header    10/22/98
//
//+----------------------------------------------------------------------------
void RemoveShowIconFromRunPostSetupCommands(LPCTSTR szInfFile)
{
    DWORD dwSize = 1024;
    DWORD dwSizeNeeded = 1024;
    TCHAR* pszBuffer = NULL;
    TCHAR* pszNewBuffer = NULL;
    const TCHAR* const c_pszRunPostSetupCommandsSection = TEXT("RunPostSetupCommandsSection");
    const TCHAR* const c_pszShowIcon = TEXT("showicon.exe");
    
    pszBuffer = (TCHAR*)CmMalloc(sizeof(TCHAR)*dwSize);
    if (NULL == pszBuffer)
    {
        CMASSERTMSG(FALSE, TEXT("RemoveShowIconFromRunPostSetupCommands -- CmMalloc returned a NULL pointer."));
        goto exit;
    }

    dwSizeNeeded = GetPrivateProfileSection(c_pszRunPostSetupCommandsSection, pszBuffer, 
        dwSize, szInfFile);

    while((dwSizeNeeded + 2) == dwSize)
    {
        //
        // the buffer isn't big enough, try again.
        //

        dwSize += 1024;

        MYDBGASSERT(dwSize <= 32*1024); // 32767 is the max size on Win95

        CmFree(pszBuffer);

        pszBuffer = (TCHAR*)CmMalloc(sizeof(TCHAR)*dwSize);
        if (NULL == pszBuffer)
        {
            CMASSERTMSG(FALSE, TEXT("RemoveShowIconFromRunPostSetupCommands -- CmMalloc returned a NULL pointer."));
            goto exit;
        }

        dwSizeNeeded = GetPrivateProfileSection(c_pszRunPostSetupCommandsSection, 
            pszBuffer, dwSize, szInfFile);
    }

    //
    //  Search the Buffer to find and remove and occurences of showicon.exe
    //

    if (0 != dwSizeNeeded)
    {
        //
        //  Allocate a new buffer of the same size.
        //
        pszNewBuffer = (TCHAR*)CmMalloc(sizeof(TCHAR)*dwSize);
        if (NULL == pszNewBuffer)
        {
            CMASSERTMSG(FALSE, TEXT("RemoveShowIconFromRunPostSetupCommands -- CmMalloc returned a NULL pointer."));
            goto exit;
        }

        //
        //  Use Temp pointers to walk the buffers
        //
        TCHAR *pszNewBufferTemp = pszNewBuffer;
        TCHAR *pszBufferTemp = pszBuffer;


        while (TEXT('\0') != pszBufferTemp[0])
        {
            //
            //  If the string isn't showicon.exe then go ahead and copy it to the new
            //  buffer.  Otherwise, don't.
            //
            if (0 != lstrcmpi(c_pszShowIcon, pszBufferTemp))
            {
                lstrcpy(pszNewBufferTemp, pszBufferTemp);
                pszNewBufferTemp = pszNewBufferTemp + (lstrlen(pszNewBufferTemp) + 1)*sizeof(TCHAR);
            }

            pszBufferTemp = pszBufferTemp + (lstrlen(pszBufferTemp) + 1)*sizeof(TCHAR);
        }

        //
        //  Erase the current Section and then rewrite it with the new section
        //

        MYVERIFY(0 != WritePrivateProfileSection(c_pszRunPostSetupCommandsSection, 
            NULL, szInfFile));

        MYVERIFY(0 != WritePrivateProfileSection(c_pszRunPostSetupCommandsSection, 
            pszNewBuffer, szInfFile));
    }

exit:
    CmFree(pszBuffer);
    CmFree(pszNewBuffer);
}


//+----------------------------------------------------------------------------
//
// Function:  HrRegDeleteKeyTree
//
// Synopsis:  Deletes an entire registry hive.
//
// Arguments:   hkeyParent  [in]   Handle to open key where the desired key resides.
//              szRemoveKey [in]   Name of key to delete.
//
// Returns:   HRESULT HrRegDeleteKeyTree - 
//
// History:   danielwe   25 Feb 1997
//            borrowed and modified -- quintinb -- 4-2-98
//
//+----------------------------------------------------------------------------
HRESULT HrRegDeleteKeyTree (HKEY hkeyParent, LPCTSTR szRemoveKey)
{
    LONG        lResult;
    HRESULT hr;
    MYDBGASSERT(hkeyParent);
    MYDBGASSERT(szRemoveKey);


    // Open the key we want to remove
    HKEY hkeyRemove;
    lResult = RegOpenKeyEx(hkeyParent, szRemoveKey, 0, KEY_ALL_ACCESS,
                                &hkeyRemove);
    hr = HRESULT_FROM_WIN32 (lResult);

    if (SUCCEEDED(hr))
    {
        TCHAR       szValueName [MAX_PATH+1];
        DWORD       cchBuffSize = MAX_PATH;
        FILETIME    ft;

        // Enum the keys children, and remove those sub-trees
        while (ERROR_NO_MORE_ITEMS != (lResult = RegEnumKeyEx(hkeyRemove,
                0,
                szValueName,
                &cchBuffSize,
                NULL,
                NULL,
                NULL,
                &ft)))
        {
            MYVERIFY(SUCCEEDED(HrRegDeleteKeyTree (hkeyRemove, szValueName)));
            cchBuffSize = MAX_PATH;
        }
        MYVERIFY(ERROR_SUCCESS == RegCloseKey (hkeyRemove));

        if ((ERROR_SUCCESS == lResult) || (ERROR_NO_MORE_ITEMS == lResult))
        {
            lResult = RegDeleteKey(hkeyParent, szRemoveKey);
        }

        hr = HRESULT_FROM_WIN32 (lResult);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  RemovePhonebookEntry
//
// Synopsis:  This function loads RAS dynamically and then deletes the specified
//            connectoids.  It will either delete only the connectoid exactly 
//            specified by the phonebook and entry name (bMatchSimilarEntries == FALSE)
//            or it will enumerate all entries in the phonebook and delete any
//            entry that matches the first lstrlen(pszEntryName) chars of the given
//            connectoid name (thus deleting backup and tunnel connectoids).  Note
//            that on NT5 we must set the <> parameter of the connectoid to "" so
//            that the RasCustomDeleteEntryNotify will not get called and thus have
//            cmstp.exe /u launched on the connection.
//
// Arguments: LPTSTR pszEntryName - the long service name of the profile to delete
//            LPTSTR pszPhonebook - the full path to the pbk file to delete entries from
//            BOOL bMatchSimilarEntries - whether the function should delete similarly
//                                        named connectoids or only the exact connectoid
//                                        specified.
//
// Returns:   BOOL - returns TRUE if the function was successful, FALSE otherwise
//
// History:   quintinb 7/14/98  Created    
//            quintinb 7/27/99  rewrote to include deleting a single connectoid or
//                              enumerating to delete all similarly named connectoids
//
//+----------------------------------------------------------------------------
BOOL RemovePhonebookEntry(LPCTSTR pszEntryName, LPTSTR pszPhonebook, BOOL bMatchSimilarEntries)
{
    pfnRasDeleteEntrySpec pfnDeleteEntry;
    pfnRasEnumEntriesSpec pfnEnumEntries;
    pfnRasSetEntryPropertiesSpec pfnSetEntryProperties;
    pfnRasSetCredentialsSpec pfnSetCredentials;

    DWORD dwStructSize;
    DWORD dwSize;
    DWORD dwNum;
    DWORD dwRet;
    DWORD dwIdx;
    DWORD dwLen;
    CPlatform plat;
    BOOL bReturn = FALSE;
    BOOL bExit;
    TCHAR szTemp[MAX_PATH+1];
    RASENTRYNAME* pRasEntries = NULL;
    RASENTRYNAME* pCurrentRasEntry = NULL;

    //
    //  Check Inputs
    //
    MYDBGASSERT(NULL != pszEntryName);
    MYDBGASSERT((NULL == pszPhonebook) || (TEXT('\0') != pszPhonebook[0]));

    if ((NULL == pszEntryName) || ((NULL != pszPhonebook) && (TEXT('\0') == pszPhonebook[0])))
    {
        CMTRACE(TEXT("RemovePhonebookEntry -- Invalid Parameter passed in."));
        goto exit;
    }
    
    //
    //  Get Function Pointers for the Ras Apis that we need
    //
    if(!GetRasApis(&pfnDeleteEntry, &pfnEnumEntries, &pfnSetEntryProperties, NULL, NULL, 
                   (plat.IsAtLeastNT5() ? &pfnSetCredentials : NULL)))
    {
        CMTRACE(TEXT("RemovePhonebookEntry -- Unable to get RAS apis."));
        bReturn = FALSE;
        goto exit;
    }

    //
    //  Setup the Structure Sizes correctly
    //
    if (plat.IsAtLeastNT5())
    {
        dwStructSize = sizeof(RASENTRYNAME_V500);
    }
    else
    {
        dwStructSize = sizeof(RASENTRYNAME);    
    }

    //
    //  Init the Size to one struct and dwNum to zero entries
    //
    bExit = FALSE;
    dwSize = dwStructSize*1;
    dwNum = 0;

    do
    {
        pRasEntries = (RASENTRYNAME*)CmMalloc(dwSize);

        if (NULL == pRasEntries)
        {
            CMASSERTMSG(FALSE, TEXT("RemovePhonebookEntry -- CmMalloc returned a NULL pointer."));
            goto exit;
        }

        //
        //  Set the struct size
        //
        pRasEntries->dwSize = dwStructSize;

        dwRet = (pfnEnumEntries)(NULL, pszPhonebook, (RASENTRYNAME*)pRasEntries, &dwSize, &dwNum); 

        //
        //  Check the return code from RasEnumEntries
        //

        if (ERROR_BUFFER_TOO_SMALL == dwRet)
        {
            CMTRACE1(TEXT("RemovePhonebookEntry -- RasEnumEntries said our buffer was too small, New Size=%u"), dwNum*dwStructSize);
            CmFree(pRasEntries);
            dwSize = dwStructSize * dwNum;
            dwNum = 0;
        }
        else if (ERROR_SUCCESS == dwRet)
        {
            CMTRACE1(TEXT("RemovePhonebookEntry -- RasEnumEntries successful, %u entries enumerated."), dwNum);
            bExit = TRUE;
        }
        else
        {
            CMTRACE1(TEXT("RemovePhonebookEntry -- RasEnumEntries Failed, dwRet == %u"), dwRet);
            goto exit;            
        }
    
    } while (!bExit);

    //
    //  At this point we should have entries to process, if not then we will exit here.  Otherwise
    //  we will look for matches and then delete any we find.
    //

    dwLen = lstrlen(pszEntryName) + 1; // get the length of the Entry Name
    bReturn = TRUE; // assume everything is okay at this point.

    //
    // okay now we are ready to perform the deletions
    //
    pCurrentRasEntry = pRasEntries;
    for (dwIdx=0; dwIdx < dwNum; dwIdx++)
    {
        CMTRACE2(TEXT("\tRemovePhonebookEntry -- RasEnumEntries returned %s in %s"), pCurrentRasEntry->szEntryName, MYDBGSTR(pszPhonebook));

        if (bMatchSimilarEntries)
        {
            //
            //  Match entries that have the first lstrlen(pszEntryName) chars
            //  the same.
            //
            lstrcpyn(szTemp, pCurrentRasEntry->szEntryName, dwLen);
        }
        else
        {
            //
            //  Only match exact entries.
            //
            lstrcpy(szTemp, pCurrentRasEntry->szEntryName);        
        }

        if (0 == lstrcmp(szTemp, pszEntryName))
        {
            //
            //  We have an entry that starts with the Long Service Name, so delete it.  Note
            //  that if this is NT5 then we need to clear the szCustomDialDll param of the 
            //  connectoid so we don't get called again on the RasCustomDeleteNotify entry
            //  point
            //

            if (plat.IsAtLeastNT5())
            {
                //
                //  On NT5, we also want to make sure we clean up any credentials associated with this
                //  connectoid.  We do that by calling RasSetCredentials
                //
                RASCREDENTIALSA RasCreds = {0};

                RasCreds.dwSize = sizeof(RASCREDENTIALSA);
                RasCreds.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;

                dwRet = (pfnSetCredentials)(pszPhonebook, pCurrentRasEntry->szEntryName, &RasCreds, TRUE); // TRUE == fClearCredentials
                MYDBGASSERT(ERROR_SUCCESS == dwRet);

                RASENTRY_V500 RasEntryV5 = {0};

                RasEntryV5.dwSize = sizeof(RASENTRY_V500);
                RasEntryV5.dwType = RASET_Internet;
                // RasEntryV5.szCustomDialDll[0] = TEXT('\0'); -- already zero-ed

                dwRet = ((pfnSetEntryProperties)(pszPhonebook, pCurrentRasEntry->szEntryName, 
                                                 (RASENTRY*)&RasEntryV5, RasEntryV5.dwSize, NULL, 0));
                if (ERROR_SUCCESS != dwRet)
                {
                    CMTRACE3(TEXT("\t\tRemovePhonebookEntry -- RasSetEntryProperties failed on entry %s in %s, dwRet = %u"), pCurrentRasEntry->szEntryName, MYDBGSTR(pszPhonebook), dwRet);
                    bReturn = FALSE;
                    continue; // don't try to delete the entry it might cause a re-launch problem
                }
                else
                {
                    CMTRACE2(TEXT("\t\tRemovePhonebookEntry -- Clearing CustomDialDll setting with RasSetEntryProperties on entry %s in %s"), pCurrentRasEntry->szEntryName, MYDBGSTR(pszPhonebook));
                }
            }

            dwRet = (pfnDeleteEntry)(pszPhonebook, pCurrentRasEntry->szEntryName);
            
            if (ERROR_SUCCESS != dwRet)
            {
                CMTRACE3(TEXT("\t\tRemovePhonebookEntry -- RasDeleteEntry failed on entry %s in %s, dwRet = %u"), pCurrentRasEntry->szEntryName, MYDBGSTR(pszPhonebook), dwRet);
                bReturn = FALSE;  // set return to FALSE but continue trying to delete entries
            }
            else
            {
                CMTRACE2(TEXT("\t\tRemovePhonebookEntry -- Deleted entry %s in %s"), pCurrentRasEntry->szEntryName, MYDBGSTR(pszPhonebook));
            }
        }

        //
        //  Increment to next RasEntryName struct, note we have to do this manually since
        //  the sizeof(RASENTRYNAME) is wrong for NT5 structs.
        //
        pCurrentRasEntry = (RASENTRYNAME*)((BYTE*)pCurrentRasEntry + dwStructSize);
    }

exit:

    CmFree(pRasEntries);
  
    return bReturn;

}


//+----------------------------------------------------------------------------
//
// Function:  DeleteNT5ShortcutFromPathAndName
//
// Synopsis:  This function deletes the link specified by the CSIDL (see SHGetSpecialFolderLocation),
//            and the profilename.  Used before installing a profile to make
//            sure we don't get duplicate links.
//
// Arguments: LPCTSTR szProfileName - string that holds the profilename
//            int nFolder - the CSIDL identifier of the folder that holds the
//                          link to delete
//
// Returns:   Nothing
//
// History:   quintinb  Created    5/26/98
//
//+----------------------------------------------------------------------------
void DeleteNT5ShortcutFromPathAndName(HINSTANCE hInstance, LPCTSTR szProfileName, int nFolder)
{

    TCHAR szFolderDir[MAX_PATH+1];

    if (SUCCEEDED(GetNT5FolderPath(nFolder, szFolderDir)))
    {
        //
        //  Now add \Shortcut to %LongServiceName% to the end of path
        //

        TCHAR szCleanString[MAX_PATH+1];
        TCHAR szShortCutPreface[MAX_PATH+1];

        ZeroMemory(szCleanString, sizeof(szCleanString));
        MYVERIFY(0 != LoadString(hInstance, IDS_SHORTCUT_TO, szShortCutPreface, MAX_PATH));
        MYVERIFY(CELEMS(szCleanString) > (UINT)wsprintf(szCleanString, TEXT("%s\\%s %s.lnk"), szFolderDir, szShortCutPreface, szProfileName));
        
        if (SetFileAttributes(szCleanString, FILE_ATTRIBUTE_NORMAL))
        {
            SHFILEOPSTRUCT fOpStruct;
            ZeroMemory(&fOpStruct, sizeof(fOpStruct));
            fOpStruct.wFunc = FO_DELETE;
            fOpStruct.pFrom = szCleanString;
            fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

            //
            //  The shell32.dll on Win95 doesn't contain the SHFileOperationW function.  Thus if we compile
            //  this Unicode we must revisit this code and dynamically link to it.
            //

            MYVERIFY(0 == SHFileOperation(&fOpStruct));
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CreateNT5ProfileShortcut
//
// Synopsis:  This function uses private APIs in NetShell.dll to create a desktop
//            shortcut to the specified connections.
//
// Arguments: LPTSTR pszProfileName - Name of the Connection to look for
//            LPTSTR pszPhoneBook - Full path to the pbk that the connection resides in
//            BOOL bAllUsers - TRUE if looking for an All Users connection
//
// Returns:   HRESULT - returns normal hr codes
//
// History:   quintinb Created    5/5/98
//            quintinb Updated to use Netshell APIs    2/17/99
//
//+----------------------------------------------------------------------------
HRESULT CreateNT5ProfileShortcut(LPCTSTR pszProfileName, LPCTSTR pszPhoneBook, BOOL bAllUsers)
{

    HRESULT hr = E_FAIL;
    pfnCreateShortcutSpec pfnCreateShortcut = NULL;
    pfnRasGetEntryPropertiesSpec pfnGetEntryProperties = NULL;

    //
    //  Check Inputs
    //
    if ((NULL == pszProfileName) || (TEXT('\0') == pszProfileName[0]) || 
        (NULL != pszPhoneBook && TEXT('\0') == pszPhoneBook[0]))
    {
        //
        //  Then they passed in an invalid string argument, thus return invalid arg.  Note
        //  that pszPhoneBook can be NULL but that if it isn't NULL it cannot be empty.
        //
        return E_INVALIDARG;    
    }

    //
    //  First Find the GUID of the connection
    //

    if (!GetRasApis(NULL, NULL, NULL, NULL, &pfnGetEntryProperties, NULL))
    {
        return E_UNEXPECTED;   
    }

    DWORD dwRes;
    DWORD dwSize;
    LPRASENTRY_V500 pRasEntry = NULL;

    pRasEntry = (LPRASENTRY_V500)CmMalloc(sizeof(RASENTRY_V500));

    if (NULL != pRasEntry)
    {
        ZeroMemory(pRasEntry, sizeof(RASENTRY_V500));        
        pRasEntry->dwSize = sizeof(RASENTRY_V500);
        dwSize = sizeof(RASENTRY_V500);

        dwRes = (pfnGetEntryProperties)(pszPhoneBook, pszProfileName, (LPRASENTRY)pRasEntry, &dwSize, NULL, NULL);
        if (0 == dwRes)
        {
            //
            //  Then we were able to get the RasEntry, load the NetShell API 
            //  and call HrCreateShortcut        
            //
            pfnSHGetSpecialFolderPathWSpec pfnSHGetSpecialFolderPathW;

            if(GetShell32Apis(NULL, &pfnSHGetSpecialFolderPathW))
            {                   
                WCHAR szwPath[MAX_PATH+1];
                
                hr = (pfnSHGetSpecialFolderPathW)(NULL, szwPath, 
                    bAllUsers ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY, FALSE);

                if (SUCCEEDED(hr) && GetNetShellApis(NULL, &pfnCreateShortcut, NULL))
                {
                    hr = (pfnCreateShortcut)(pRasEntry->guidId, szwPath);
                }
            }
        }
        else
        {
            CMTRACE1(TEXT("CreateNT5ProfileShortcut -- RasGetEntryProperties returned %u"), dwRes);
            CMASSERTMSG(FALSE, TEXT("Unable to find the connection for which the shortcut was requested in the RAS pbk."));
            return HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
        }
        CmFree(pRasEntry);
    }
    
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteCmPhonebookEntry
//
// Synopsis: This function creates an NT5 phonebook entry for a CM connection.
//           .
//           The function sets:
//              - the szAutoDialDll to cmdial32.dll
//              - the modem name and device type
//              - the type to RASET_Inernet. 
//
// Arguments: LPCTSTR szLongServiceName - Name of the Connectoid to be created
//            LPCTSTR szFullPathtoPBK - full path to the pbk to put the connectoid in, if NULL
//                                     the system phonebook is used.
//            LPCTSTR pszCmsFile - The full path of the referencing .CMS for the profile 
//
// Returns:   BOOL - TRUE on success
//
// History:   05/05/98 - quintinb - Created Header    
//            ??/??/?? - henryt   - Modified to work on multiple platforms.  added modem stuff.
//            01/12/99 - nickball - Replaced fDoDirectConnect with szCmsFile. Handled no modem case.
//
//+----------------------------------------------------------------------------
BOOL WriteCmPhonebookEntry(LPCTSTR szLongServiceName, 
                           LPCTSTR szFullPathtoPBK, 
                           LPCTSTR pszCmsFile)
{
    pfnRasSetEntryPropertiesSpec pfnSetEntryProperties;
    DWORD dwRet = 1;
    CPlatform plat;
    RASENTRY    *pRasEntry = NULL;
    BOOL bReturn = FALSE;
    DWORD dwReturn;
    BOOL fSupportDialup;
    BOOL fSupportDirect;
    BOOL fDoDirectConnect;
    BOOL fSeekVpn;
    const TCHAR* const c_pszOne                 = TEXT("1");

    MYDBGASSERT(szLongServiceName);
    MYDBGASSERT(pszCmsFile);

    if (NULL == szLongServiceName || NULL == pszCmsFile)
    {
        return FALSE;
    }

    CMTRACE2(TEXT("WriteCmPhonebookEntry() - szLongServiceName  is %s, szFullPathtoPBK is %s"), szLongServiceName, szFullPathtoPBK ? szFullPathtoPBK : TEXT("<NULL>"));

    if (!GetRasApis(NULL, NULL, &pfnSetEntryProperties, NULL, NULL, NULL))
    {
        return FALSE;   
    }

    //
    // alloc RASENTRY properly
    //

    if (plat.IsAtLeastNT5())
    {
        RASENTRY_V500 *pRasEntryV500 = (RASENTRY_V500 *)CmMalloc(sizeof(RASENTRY_V500));

        if (!pRasEntryV500)
        {
            CMTRACE(TEXT("WriteCmPhonebookEntry failed to alloc mem"));
            goto exit;
        }

        ZeroMemory(pRasEntryV500, sizeof(RASENTRY_V500));

        pRasEntryV500->dwSize = sizeof(RASENTRY_V500);
        pRasEntryV500->dwType = RASET_Internet;

        pRasEntry = (RASENTRY *)pRasEntryV500;
    }
    else
    {
        pRasEntry = (RASENTRY *)CmMalloc(sizeof(RASENTRY));

        if (!pRasEntry)
        {
            CMTRACE(TEXT("WriteCmPhonebookEntry failed to alloc mem"));
            goto exit;
        }

        pRasEntry->dwSize = sizeof(RASENTRY);
    }

    //
    // Update the RAS entry with our DLL name for AutoDial and CustomDial
    // Note: NT5 gets CustomDial only, no AutoDial and AutoDialFunc.
    //

    if (plat.IsAtLeastNT5())
    {
        //
        // Use the machine independent %windir%\system32\cmdial32.dll on NT5
        //

        lstrcpy(((RASENTRY_V500 *)pRasEntry)->szCustomDialDll, c_pszCmDialPath);
    }
    else
    {
        TCHAR szSystemDirectory[MAX_PATH+1];

        //
        // Specify _InetDialHandler@16 as the entry point used for AutoDial.
        //

        lstrcpy(pRasEntry->szAutodialFunc, c_pszInetDialHandler);

        //
        //  Get the system directory path
        //

        if (0 == GetSystemDirectory(szSystemDirectory, CELEMS(szSystemDirectory)))
        {
            goto exit;
        }

        UINT uCount = (UINT)wsprintf(pRasEntry->szAutodialDll, TEXT("%s\\cmdial32.dll"), szSystemDirectory);

        MYDBGASSERT(uCount < CELEMS(pRasEntry->szAutodialDll));
    }

    if (plat.IsWin9x())
    {
        //
        // Win9x requires these to be set
        //
        pRasEntry->dwFramingProtocol = RASFP_Ppp;
        pRasEntry->dwCountryID = 1;
        pRasEntry->dwCountryCode = 1;
        //lstrcpy(pRasEntry->szAreaCode, TEXT("425"));
        lstrcpy(pRasEntry->szLocalPhoneNumber, TEXT("default"));
    }

    //
    // Is the profile configured to first use Direct Connect
    //

    fSupportDialup = GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryDialup, 1, pszCmsFile);
    fSupportDirect = GetPrivateProfileInt  (c_pszCmSection, c_pszCmEntryDirect, 1, pszCmsFile);

    fDoDirectConnect = ((fSupportDialup && fSupportDirect && 
                        GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryConnectionType, 0, pszCmsFile)) ||
                        (!fSupportDialup));

   
    fSeekVpn = fDoDirectConnect;    

    //
    // First try dial-up if appropriate
    //

    if (!fDoDirectConnect && !PickModem(pRasEntry->szDeviceType, pRasEntry->szDeviceName, FALSE))
    {
        CMTRACE(TEXT("*******Failed to pick a dial-up device!!!!"));

        //
        // If direct capable, try to find a VPN device
        //
        
        fSeekVpn = fSupportDirect;
    }

    //
    // If seeking a VPN device
    //

    if (fSeekVpn)
    {
        if (!PickModem(pRasEntry->szDeviceType, pRasEntry->szDeviceName, TRUE))
        {
            CMTRACE(TEXT("*******Failed to pick a VPN device!!!!"));   
        }
        else
        {
            //
            // Found VPN device, set default type as appropriate
            //

            if (!fDoDirectConnect)
            {
                CFileNameParts CmsParts(pszCmsFile);
                TCHAR szCmpFile[MAX_PATH+1];

                MYVERIFY(CELEMS(szCmpFile) > (UINT)wsprintf(szCmpFile, TEXT("%s%s"), CmsParts.m_Drive, 
                    CmsParts.m_Dir));

                szCmpFile[lstrlen(szCmpFile) - 1] = TEXT('\0');
                lstrcat(szCmpFile, c_pszCmpExt);
                
                WritePrivateProfileString(c_pszCmSection, c_pszCmEntryConnectionType, c_pszOne, szCmpFile);  
            }       
        }
    }

    //
    // No device??? Use last resort for dial-up on NT5
    //
    
    if (plat.IsAtLeastNT5() && !pRasEntry->szDeviceType[0])
    {
        lstrcpy(pRasEntry->szDeviceType, RASDT_Modem);
        lstrcpy(pRasEntry->szDeviceName, TEXT("Unavailable device ()"));

        CMTRACE2(TEXT("*******Writing szDeviceType - %s and szDeviceName %s"), 
                 pRasEntry->szDeviceType, pRasEntry->szDeviceName);       
    }

    //
    //  Zero is the success return value from RasSetEntryProperties
    //      
    dwReturn = ((pfnSetEntryProperties)(szFullPathtoPBK, szLongServiceName, 
                                        pRasEntry, pRasEntry->dwSize, NULL, 0));
            
    if (ERROR_SUCCESS == dwReturn)
    {
        bReturn = TRUE;
    }

    CMTRACE1(TEXT("WriteCmPhonebookEntry() - RasSetEntryProperties failed with error %d"), dwReturn);      


exit:
    CmFree(pRasEntry);

    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  GetRasModems
//
// Synopsis:  get a list of modem devices from RAS
//
// Arguments: pprdiRasDevInfo   Ras device info list
//            pdwCnt    modem count
//
// Returns:   TRUE, if a list is obtained
//
//+----------------------------------------------------------------------------
BOOL GetRasModems(
    LPRASDEVINFO    *pprdiRasDevInfo, 
    LPDWORD         pdwCnt
) 
{
    DWORD dwLen;
    DWORD dwRes;
    DWORD dwCnt;
    pfnRasEnumDevicesSpec pfnEnumDevices;

    if (pprdiRasDevInfo) 
    {
        *pprdiRasDevInfo = NULL;
    }
    
    if (pdwCnt) 
    {
        *pdwCnt = 0;
    }
    
    if (!GetRasApis(NULL, NULL, NULL, &pfnEnumDevices, NULL, NULL))
    {
        return FALSE;   
    }

    dwLen = 0;
    dwRes = pfnEnumDevices(NULL, &dwLen, &dwCnt);
    
    CMTRACE3(TEXT("GetRasModems() RasEnumDevices(NULL,pdwLen,&dwCnt) returns %u, dwLen=%u, dwCnt=%u."), dwRes, dwLen, dwCnt);
    
    if ((dwRes != ERROR_SUCCESS) && (dwRes != ERROR_BUFFER_TOO_SMALL) || 
        (dwLen < sizeof(**pprdiRasDevInfo))) 
    {
        return FALSE;
    }
    
    *pprdiRasDevInfo = (LPRASDEVINFO) CmMalloc(__max(dwLen, sizeof(**pprdiRasDevInfo)));

    if (*pprdiRasDevInfo)
    {
        (*pprdiRasDevInfo)->dwSize = sizeof(**pprdiRasDevInfo);

        dwRes = pfnEnumDevices(*pprdiRasDevInfo, &dwLen, &dwCnt);
    
        CMTRACE3(TEXT("GetRasModems() RasEnumDevices(NULL,pdwLen,&dwCnt) returns %u, dwLen=%u, dwCnt=%u."), dwRes, dwLen, dwCnt);
    
        if (dwRes != ERROR_SUCCESS) 
        {
            CmFree(*pprdiRasDevInfo);
            *pprdiRasDevInfo = NULL;
            return FALSE;
        }
        if (pdwCnt)
        {
            *pdwCnt = dwCnt;
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("GetRasModems -- CmMalloc returned a NULL pointer for *pprdiRasDevInfo."));
        return FALSE;
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  PickModem
//
// Synopsis:  Pick a default modem
//
// Arguments: OUT pszDeviceType, the device type if not NULL
//            OUT pszDeviceName, the device name if not NULL
//            OUT fUseVpnDevice  Use VPN device or not 
//
// Returns:   TRUE, is modem is found
//
//+----------------------------------------------------------------------------
BOOL PickModem(
    LPTSTR           pszDeviceType, 
    LPTSTR           pszDeviceName,
    BOOL             fUseVpnDevice
)
{
    LPRASDEVINFO    prdiModems;
    DWORD           dwCnt;
    DWORD           dwIdx;

    //
    // First, get a list of modems from RAS
    //
    
    if (!GetRasModems(&prdiModems, &dwCnt) || dwCnt == 0) 
    {
        return FALSE;
    }

    //
    // find the first device and use it by default.
    // Use VPN device if it's a VPN connection.
    //

    for (dwIdx=0; dwIdx<dwCnt; dwIdx++) 
    {       
        if (fUseVpnDevice && !lstrcmpi(prdiModems[dwIdx].szDeviceType, RASDT_Vpn) ||
            !fUseVpnDevice && (!lstrcmpi(prdiModems[dwIdx].szDeviceType, RASDT_Isdn) ||
                               !lstrcmpi(prdiModems[dwIdx].szDeviceType, RASDT_Modem)))
        {
            break;
        }
    }

    // 
    // If we have a match, fill device name and device type
    //

    if (dwIdx < dwCnt)
    {
        if (pszDeviceType) 
        {
            lstrcpy(pszDeviceType, prdiModems[dwIdx].szDeviceType);
        }
        
        if (pszDeviceName) 
        {
            lstrcpy(pszDeviceName, prdiModems[dwIdx].szDeviceName);
        }
    }

    CmFree(prdiModems);

    return (dwIdx < dwCnt);
}


//+----------------------------------------------------------------------------
//
// Function:  IsMemberOfGroup
//
// Synopsis:  This function return TRUE if the current user is a member of 
//            the passed and FALSE passed in Group RID.
//
// Arguments: DWORD dwGroupRID -- the RID of the group to check membership of
//            BOOL bUseBuiltinDomainRid -- whether the SECURITY_BUILTIN_DOMAIN_RID
//                                         RID should be used to build the Group
//                                         SID
//
// Returns:   BOOL - TRUE if the user is a member of the specified group
//
// History:   quintinb  Shamelessly stolen from MSDN            02/19/98
//            quintinb  Reworked and renamed                    06/18/99
//                      to apply to more than just Admins 
//            quintinb  Rewrote to use CheckTokenMemberShip     08/18/99
//                      since the MSDN method was no longer
//                      correct on NT5 -- 389229
//
//+----------------------------------------------------------------------------
BOOL IsMemberOfGroup(DWORD dwGroupRID, BOOL bUseBuiltinDomainRid)
{
    CPlatform cmplat;
    PSID psidGroup = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL bSuccess = FALSE;

    if (FALSE == cmplat.IsAtLeastNT5())
    {
        CMASSERTMSG(FALSE, TEXT("IsMemberOfGroup -- Trying to use an NT5 only function on a downlevel platform."));
        return FALSE;
    }

    //
    //  Make a SID for the Group we are checking for, Note that we if we need the Built 
    //  in Domain RID (for Groups like Administrators, PowerUsers, Users, etc)
    //  then we will have two entries to pass to AllocateAndInitializeSid.  Otherwise,
    //  (for groups like Authenticated Users) we will only have one.
    //
    BYTE byNum;
    DWORD dwFirstRID;
    DWORD dwSecondRID;

    if (bUseBuiltinDomainRid)
    {
        byNum = 2;
        dwFirstRID = SECURITY_BUILTIN_DOMAIN_RID;
        dwSecondRID = dwGroupRID;
    }
    else
    {
        byNum = 1;
        dwFirstRID = dwGroupRID;
        dwSecondRID = 0;
    }

    if (AllocateAndInitializeSid(&siaNtAuthority, byNum, dwFirstRID, dwSecondRID,
                                 0, 0, 0, 0, 0, 0, &psidGroup))

    {
        //
        //  Now we need to dynamically load the CheckTokenMemberShip API from 
        //  advapi32.dll since it is a Win2k only API.
        //        
        HMODULE hAdvapi = GetModuleHandle(TEXT("advapi32.dll"));
        if (hAdvapi)
        {
            typedef BOOL (WINAPI *pfnCheckTokenMembershipSpec)(HANDLE, PSID, PBOOL);
            pfnCheckTokenMembershipSpec pfnCheckTokenMembership;

            pfnCheckTokenMembership = (pfnCheckTokenMembershipSpec)GetProcAddress(hAdvapi, "CheckTokenMembership");

            if (pfnCheckTokenMembership)
            {
                //
                //  Check to see if the user is actually a member of the group in question
                //
                if (!(pfnCheckTokenMembership)(NULL, psidGroup, &bSuccess))
                {
                    bSuccess = FALSE;
                    CMASSERTMSG(FALSE, TEXT("CheckTokenMemberShip Failed."));
                }            
            }   
            else
            {
                CMASSERTMSG(FALSE, TEXT("IsMemberOfGroup -- GetProcAddress failed for CheckTokenMemberShip"));
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("IsMemberOfGroup -- Unable to get the module handle for advapi32.dll"));            
        }

        FreeSid (psidGroup);
    }
    
    return bSuccess;
}



//+----------------------------------------------------------------------------
//
// Function:  IsAdmin
//
// Synopsis:  Check to see if the user is a member of the Administrators group
//            or not.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current user is an Administrator
//
// History:   quintinb Created Header    8/18/99
//
//+----------------------------------------------------------------------------
BOOL IsAdmin(void)
{
    return IsMemberOfGroup(DOMAIN_ALIAS_RID_ADMINS, TRUE); // TRUE == bUseBuiltinDomainRid
}

//+----------------------------------------------------------------------------
//
// Function:  IsAuthenticatedUser
//
// Synopsis:  Check to see if the current user is a member of the 
//            Authenticated Users group.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current user is a member of the
//                   Authenticated Users group. 
//
// History:   quintinb Created Header    8/18/99
//
//+----------------------------------------------------------------------------
BOOL IsAuthenticatedUser(void)
{
      return IsMemberOfGroup(SECURITY_AUTHENTICATED_USER_RID, FALSE); // FALSE == bUseBuiltinDomainRid
}

//+----------------------------------------------------------------------------
//
// Function:  GetNT5FolderPath
//
// Synopsis:  Get the folder path on NT5
//            Since cmstp.exe is launched in netman by CreateProcessAsUser
//            SHGetSpecialFolderPath does not work.  We have to call 
//            SHGetFolderPath with an access token.
//
// Arguments: int nFolder - Value specifying the folder for which to retrieve 
//                          the location. 
//            OUT LPTSTR lpszPath - Address of a character buffer that receives 
//                          the drive and path of the specified folder. This 
//                          buffer must be at least MAX_PATH characters in size. 
 
//
// Returns:   HRESULT - 
//
// History:   fengsun Created Header    6/18/98
//            quintinb modified to use GetShell32Apis   11-22-98
//
//+----------------------------------------------------------------------------
HRESULT GetNT5FolderPath(int nFolder, OUT LPTSTR lpszPath)
{
    MYDBGASSERT(lpszPath);
    pfnSHGetFolderPathSpec pfnSHGetFolderPath;

    //
    // Call shell32.dll-->SHGetFolderPath, which takes a token.
    //
    if(!GetShell32Apis(&pfnSHGetFolderPath, NULL))
    {
        CMASSERTMSG(FALSE, TEXT("Failed to load shell32.dll or ShGetFolderPath"));
        return E_UNEXPECTED;    
    }

    //
    // Get the current process token
    //
    HANDLE hToken;              // The token of the process, to be passed to SHGetFolderPath
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) 
    {
        CMASSERTMSG(FALSE, TEXT("OpenThreadToken failed"));
        return E_UNEXPECTED;
    }

    HRESULT hr = pfnSHGetFolderPath(NULL, nFolder, hToken, 0, lpszPath);

    MYVERIFY(0 != CloseHandle(hToken));

    return hr;
}



//+----------------------------------------------------------------------------
//
// Function:  HrIsCMProfilePrivate
//
// Synopsis:  This function compares the inputed file path with the application
//            data path of the system.  If the file path contains the app data
//            path then it is considered to be a private profile.
//
// Arguments: LPTSTR szFilePath - directory or file path to compare against
//
// Returns:   HRESULT - S_OK if a private profile, S_FALSE if it is an all users
//                      profile.  Standard error codes otherwise.
//
// History:   quintinb original code
//
//+----------------------------------------------------------------------------
HRESULT HrIsCMProfilePrivate(LPCTSTR szFilePath)
{
    UINT uiLen;
    TCHAR szAppDataDir[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1] = {TEXT("")};
    CPlatform plat;

    if ((NULL == szFilePath) || (TEXT('\0') == szFilePath[0]))
    {
        return E_POINTER;
    }

    //
    //  Can't be a private user profile unless we are on NT5
    //

    if (!(plat.IsAtLeastNT5()))
    {
        return S_FALSE;
    }

    //
    //  Figure out what the user directory of the current user is.  We can compare this
    //  against the directory of the phonebook and see if we have a private user
    //  profile or an all user profile.

    if (FAILED(GetNT5FolderPath(CSIDL_APPDATA, szAppDataDir)))
    {
        return E_UNEXPECTED;
    }

    uiLen = lstrlen(szAppDataDir) + 1;
    lstrcpyn(szTemp, szFilePath, uiLen);

    if ((NULL != szTemp) && (0 == lstrcmpi(szAppDataDir, szTemp)))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  RefreshDesktop
//
// Synopsis:  This function refreshes the desktop and basically takes the place
//            of showicon.exe (in fact the code is a cut and paste from the 
//            main of showicon).
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    5/5/98
//
//+----------------------------------------------------------------------------
void RefreshDesktop()
{
    LPMALLOC     pMalloc        = NULL;
    LPITEMIDLIST pItemIDList    = NULL;

    //
    //  Get the IMalloc for the Shell.
    //
    HRESULT hr = SHGetMalloc(&pMalloc);
    if (SUCCEEDED(hr))
    {
        //  Get the desktop ID list..
        hr = SHGetSpecialFolderLocation(NULL,
                                        CSIDL_DESKTOP,
                                        &pItemIDList);
        if (SUCCEEDED(hr))
        {
            //  Notify of change.
            SHChangeNotify(SHCNE_UPDATEDIR,
                           SHCNF_IDLIST,
                           (LPCVOID)pItemIDList,
                           NULL);

            pMalloc->Free(pItemIDList);
        }
        MYVERIFY(SUCCEEDED(pMalloc->Release()));
    }
}

//+----------------------------------------------------------------------------
//
// Function:  GetPrivateCmUserDir
//
// Synopsis:  This function fills in the string passed in with the path to the
//            path where CM should be installed.  For instance, it should return
//            c:\users\quintinb\Application Data\Microsoft\Network\Connection Manager
//            for me.  Please note that this function is NT5 only.
//
// Arguments: LPTSTR  pszDir - String to the Users Connection Manager Directory
//
// Returns:   LPTSTR - String to the Users Connection Manager Directory
//
// History:   quintinb Created Header    2/19/98
//
//+----------------------------------------------------------------------------
LPTSTR GetPrivateCmUserDir(LPTSTR  pszDir, HINSTANCE hInstance)
{
    LPITEMIDLIST pidl;
    LPMALLOC     pMalloc;
    CPlatform   plat;
    TCHAR szTemp[MAX_PATH+1];

    MYDBGASSERT(pszDir);
    pszDir[0] = TEXT('\0');

    if (!plat.IsAtLeastNT5())
    {
        CMASSERTMSG(FALSE, TEXT("GetPrivateCmUserDir -- This NT5 only function was called from a different platform."));
        goto exit;
    }

    if (FAILED(GetNT5FolderPath(CSIDL_APPDATA, pszDir)))
    {
        goto exit;
    }

    MYVERIFY(0 != LoadString(hInstance, IDS_CMSUBFOLDER, szTemp, MAX_PATH));
    MYVERIFY(NULL != lstrcat(pszDir, szTemp));

exit:
    return pszDir;
}

//+----------------------------------------------------------------------------
//
// Function:  LaunchProfile
//
// Synopsis:  This function handles launching the CM profile (NTRAID 201307) after
//            installation.  On NT5 it opens the connfolder and launches the 
//            correct connection by doing a shell execute on the pidl we get from
//            enumerating the connections folder.  On down level we use Cmmgr32.exe
//            and the full path to the cmp file.  Please note that on downlevel we
//            only care about the input param pszFullPathToCmpFile, while on NT5
//            we only care about pszwServiceName and bInstallForAllUsers.
//
// Arguments: LPCTSTR pszFullPathToCmpFile - the full path to the cmp file (used on legacy only)
//            LPCSTR pszServiceName - the Long Service Name
//            BOOL bInstallForAllUsers - 
//
// Returns:   HRESULT -- standard COM error codes
//
// History:   quintinb Created    11/16/98
//
//+----------------------------------------------------------------------------
HRESULT LaunchProfile(LPCTSTR pszFullPathToCmpFile, LPCTSTR pszServiceName, 
                   LPCTSTR pszPhoneBook, BOOL bInstallForAllUsers)
{
    CPlatform plat;
    HRESULT hr = E_FAIL;

    if ((NULL == pszFullPathToCmpFile) || (NULL == pszServiceName) ||
        (NULL != pszPhoneBook && TEXT('\0') == pszPhoneBook[0]))
    {
        CMASSERTMSG(FALSE, TEXT("Invalid argument passed to LaunchProfile"));
        return E_INVALIDARG;
    }

    if (plat.IsAtLeastNT5())
    {
        CMASSERTMSG((TEXT('\0') != pszServiceName), TEXT("Empty ServiceName passed to LaunchProfile on win2k."));
        
        pfnRasGetEntryPropertiesSpec pfnGetEntryProperties = NULL;

        if (!GetRasApis(NULL, NULL, NULL, NULL, &pfnGetEntryProperties, NULL))
        {
            return E_UNEXPECTED;   
        }

        DWORD dwRes;
        DWORD dwSize;
        LPRASENTRY_V500 pRasEntry = NULL;

        pRasEntry = (LPRASENTRY_V500)CmMalloc(sizeof(RASENTRY_V500));

        if (NULL != pRasEntry)
        {
            ZeroMemory(pRasEntry, sizeof(RASENTRY_V500));        
            pRasEntry->dwSize = sizeof(RASENTRY_V500);
            dwSize = sizeof(RASENTRY_V500);

            dwRes = (pfnGetEntryProperties)(pszPhoneBook, pszServiceName, (LPRASENTRY)pRasEntry, &dwSize, NULL, NULL);
        
            if (0 == dwRes)
            {
                //
                //  Then we were able to get the RasEntry, load the NetShell API 
                //  and call HrCreateShortcut
                //
                if (plat.IsAtLeastNT51())
                {
                    pfnLaunchConnectionExSpec pfnLaunchConnectionEx = NULL;

                    if (GetNetShellApis(NULL, NULL, &pfnLaunchConnectionEx))
                    {
                        //
                        //  Launch Connections Folder and Connection together
                        //
                        DWORD dwFlags = 0x1;    // 0x1 => Opens the folder before launching the connection

                        hr = (pfnLaunchConnectionEx)(dwFlags, pRasEntry->guidId);
                        MYVERIFY(SUCCEEDED(hr));
                    }
                }
                else
                {
                    pfnLaunchConnectionSpec pfnLaunchConnection = NULL;

                    if (GetNetShellApis(&pfnLaunchConnection, NULL, NULL))
                    {
                        //
                        //  Now Launch the Connections Folder
                        //

                        CLoadConnFolder Connections;
                        Connections.HrLaunchConnFolder();

                        //
                        //  Finally Launch the Connection
                        //
                        hr = (pfnLaunchConnection)(pRasEntry->guidId);
                        MYVERIFY(SUCCEEDED(hr));
                    }
                }
            }
            else
            {
                CMTRACE1(TEXT("LaunchProfile -- RasGetEntryProperties returned %u"), dwRes);
                CMASSERTMSG(FALSE, TEXT("Unable to find the connection that we are supposed to launch in the RAS pbk."));
                return HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
            }
            CmFree(pRasEntry);
        }
    }
    else
    {
        SHELLEXECUTEINFO  sei;

        if ((NULL != pszFullPathToCmpFile) && (TEXT('\0') != pszFullPathToCmpFile))
        {
            TCHAR szCmmgrPath[MAX_PATH+1];
            TCHAR szSystemDir[MAX_PATH+1];
            TCHAR szCmp[MAX_PATH+1];
            ZeroMemory(&szCmp, sizeof(szCmp));
            ZeroMemory(&szCmmgrPath, sizeof(szCmmgrPath));
            ZeroMemory(&szSystemDir, sizeof(szSystemDir));

            lstrcpy(szCmp, TEXT("\""));
            lstrcat(szCmp, pszFullPathToCmpFile);
            lstrcat(szCmp, TEXT("\""));

            UINT uRet = GetSystemDirectory(szSystemDir, MAX_PATH);
            if ((0 == uRet) || (MAX_PATH < uRet))
            {
                //
                //  Give up, not the end of the world not to launch the profile
                //
                return E_UNEXPECTED;         
            }
            else
            {
                wsprintf(szCmmgrPath, TEXT("%s\\cmmgr32.exe"), szSystemDir);
            }

            ZeroMemory(&sei, sizeof(sei));
            sei.cbSize = sizeof(sei);
            sei.fMask = SEE_MASK_FLAG_NO_UI;
            sei.nShow = SW_SHOWNORMAL;
            sei.lpFile = szCmmgrPath;
            sei.lpParameters = szCmp;
            sei.lpDirectory = szSystemDir;

            if (!ShellExecuteEx(&sei))
            {
                CMASSERTMSG(FALSE, TEXT("Unable to launch installed connection!"));
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  AllUserProfilesInstalled
//
// Synopsis:  Checks if any profiles are listed in the HKLM Mappings key.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if mappings values exist in the HKLM mappings key
//
// History:   quintinb Created Header    11/1/98
//
//+----------------------------------------------------------------------------
BOOL AllUserProfilesInstalled()
{
    BOOL bReturn = FALSE;
    HKEY hKey;
    DWORD dwNumValues;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
        KEY_READ, &hKey))
    {
        if ((ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, 
            &dwNumValues, NULL, NULL, NULL, NULL)) && (dwNumValues > 0))
        {
            //
            //  Then we have mappings values
            //
            bReturn = TRUE;

        }
        RegCloseKey(hKey);
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  GetProcAddressFromRasApi32orRnaph
//
// Synopsis:  A helper function to first look in RasApi32.dll (using the global
//            dll class pointer) and then check in Rnaph.dll if the required
//            function was not found.
//
// Arguments: LPTSTR pszFunc - String of the function to look for
//            CPlatform* pPlat - a CPlatform class pointer to prevent creating
//                               and destructing a new one everytime this is called.
//
// Returns:   LPVOID - NULL if the function wasn't found, a pFunc otherwise.
//
// History:   quintinb Created  11/23/98
//
//+----------------------------------------------------------------------------
LPVOID GetProcAddressFromRasApi32orRnaph(LPCSTR pszFunc, CPlatform* pPlat)
{
    LPVOID pFunc;
    MYDBGASSERT(g_pRasApi32);

    pFunc = g_pRasApi32->GetProcAddress(pszFunc);
    if (NULL == pFunc)
    {
        //
        //  On win95 gold check rnaph
        //
        if (pPlat->IsWin95Gold())
        {
            if (NULL == g_pRnaph)
            {
                g_pRnaph = (CDynamicLibrary*)CmMalloc(sizeof(CDynamicLibrary));
                if (NULL == g_pRnaph)
                {
                    return FALSE;
                }
            }

            if (!(g_pRnaph->IsLoaded()))
            {
                g_pRnaph->Load(TEXT("rnaph.dll"));
            }

            pFunc = g_pRnaph->GetProcAddress(pszFunc);                   
        }
    }
    return pFunc;
}

//+----------------------------------------------------------------------------
//
// Function:  GetNetShellApis
//
// Synopsis:  This is a wrapper function to access the private Netshell api's that allow
//            cmstp.exe to interact with the Connections folder on Windows 2000.
//            This function caches the Netshell function pointers as they are
//            accessed for later use.  NULL can be passed if a function isn't required.
//
// Arguments: pfnLaunchConnectionSpec* pLaunchConnection - var to hold function pointer
//            pfnCreateShortcutSpec* pCreateShortcut - var to hold function pointer
//            pfnLaunchConnectionEx pLaunchConnectionEx - var to hold function pointer
//
// Returns:   BOOL - TRUE if all required APIs were retrieved
//
// History:   quintinb Created    2/17/99
//
//+----------------------------------------------------------------------------
BOOL GetNetShellApis(pfnLaunchConnectionSpec* pLaunchConnection, pfnCreateShortcutSpec* pCreateShortcut,
                     pfnLaunchConnectionExSpec* pLaunchConnectionEx)
{
    CPlatform plat;
    static pfnLaunchConnectionSpec pfnLaunchConnection = NULL;
    static pfnCreateShortcutSpec pfnCreateShortcut = NULL;
    static pfnLaunchConnectionExSpec pfnLaunchConnectionEx = NULL;

    if (!(plat.IsAtLeastNT5()))
    {
        //
        //  These functions are only used on NT5.  Return FALSE otherwise.
        //
        CMASSERTMSG(FALSE, TEXT("Trying to use NetShell Private Api's on platforms other than Windows 2000."));
        return FALSE;
    }

    if (NULL == g_pNetShell)
    {
        g_pNetShell = (CDynamicLibrary*)CmMalloc(sizeof(CDynamicLibrary));
        if (NULL == g_pNetShell)
        {
            return FALSE;
        }
    }

    if (!(g_pNetShell->IsLoaded()))
    {
        g_pNetShell->Load(TEXT("netshell.dll"));
    }
    
    if (NULL != pLaunchConnection)
    {
        if (pfnLaunchConnection)
        {
            *pLaunchConnection = pfnLaunchConnection;
        }
        else
        {
            *pLaunchConnection = (pfnLaunchConnectionSpec)g_pNetShell->GetProcAddress("HrLaunchConnection");
            if (NULL == *pLaunchConnection)
            {
                return FALSE;
            }
            else
            {
                pfnLaunchConnection = *pLaunchConnection;
            }
        }
    }

    if (NULL != pCreateShortcut)
    {
        if (pfnCreateShortcut)
        {
            *pCreateShortcut = pfnCreateShortcut;
        }
        else
        {
            *pCreateShortcut = (pfnCreateShortcutSpec)g_pNetShell->GetProcAddress("HrCreateDesktopIcon");
            if (NULL == *pCreateShortcut)
            {
                return FALSE;
            }
            else
            {
                pfnCreateShortcut = *pCreateShortcut;
            }
        }
    }

    if (NULL != pLaunchConnectionEx)
    {
        if (pfnLaunchConnectionEx)
        {
            *pLaunchConnectionEx = pfnLaunchConnectionEx;
        }
        else
        {
            if (!(plat.IsAtLeastNT51()))
            {
                return FALSE;
            }
            else
            {
                *pLaunchConnectionEx = (pfnLaunchConnectionExSpec)g_pNetShell->GetProcAddress("HrLaunchConnectionEx");
                if (NULL == *pLaunchConnectionEx)
                {
                    return FALSE;
                }
                else
                {
                    pfnLaunchConnectionEx = *pLaunchConnectionEx;
                }
            }
        }
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  GetRasApis
//
// Synopsis:  This is a wrapper function to access the RasApis that cmstp.exe uses.
//            This function caches the RAS api function pointers as they are
//            accessed for later use.  NULL can be passed if a function isn't required.
//
// Arguments: pfnRasDeleteEntrySpec* pRasDeleteEntry - var to hold func pointer
//            pfnRasEnumEntriesSpec* pRasEnumEntries - var to hold func pointer
//            pfnRasSetEntryPropertiesSpec* pRasSetEntryProperties - var to hold func pointer
//            pfnRasEnumDevicesSpec* pRasEnumDevices - var to hold func pointer
//            pfnRasSetCredentialsSpec* pRasSetCredentials - var to hold func pointer
//
// Returns:   BOOL - TRUE if all required APIs were retrieved
//
// History:   quintinb Created    11/23/98
//
//+----------------------------------------------------------------------------
BOOL GetRasApis(pfnRasDeleteEntrySpec* pRasDeleteEntry, pfnRasEnumEntriesSpec* pRasEnumEntries, 
                pfnRasSetEntryPropertiesSpec* pRasSetEntryProperties, 
                pfnRasEnumDevicesSpec* pRasEnumDevices, pfnRasGetEntryPropertiesSpec* pRasGetEntryProperties,
                pfnRasSetCredentialsSpec* pRasSetCredentials)
{
    CPlatform plat;
    static pfnRasDeleteEntrySpec pfnRasDeleteEntry = NULL;
    static pfnRasEnumEntriesSpec pfnRasEnumEntries = NULL;
    static pfnRasSetEntryPropertiesSpec pfnRasSetEntryProperties = NULL;
    static pfnRasEnumDevicesSpec pfnRasEnumDevices = NULL;
    static pfnRasGetEntryPropertiesSpec pfnRasGetEntryProperties = NULL;
    static pfnRasSetCredentialsSpec pfnRasSetCredentials = NULL;

    if (NULL == g_pRasApi32)
    {
        g_pRasApi32 = (CDynamicLibrary*)CmMalloc(sizeof(CDynamicLibrary));
        if (NULL == g_pRasApi32)
        {
            return FALSE;
        }
    }

    if (!(g_pRasApi32->IsLoaded()))
    {
        g_pRasApi32->Load(TEXT("rasapi32.dll"));
    }
    
    if (NULL != pRasDeleteEntry)
    {
        if (pfnRasDeleteEntry)
        {
            *pRasDeleteEntry = pfnRasDeleteEntry;
        }
        else
        {
            *pRasDeleteEntry = (pfnRasDeleteEntrySpec)GetProcAddressFromRasApi32orRnaph("RasDeleteEntryA",
                                                                                        &plat);
            if (NULL == *pRasDeleteEntry)
            {
                return FALSE;
            }
            else
            {
                pfnRasDeleteEntry = *pRasDeleteEntry;
            }
        }
    }

    if (NULL != pRasEnumEntries)
    {
        if (pfnRasEnumEntries)
        {
            *pRasEnumEntries = pfnRasEnumEntries;
        }
        else
        {
            *pRasEnumEntries = (pfnRasEnumEntriesSpec)g_pRasApi32->GetProcAddress("RasEnumEntriesA");

            if (NULL == *pRasEnumEntries)
            {
                //
                //  A required Function couldn't be loaded
                //
                return FALSE;
            }
            else
            {
                pfnRasEnumEntries = *pRasEnumEntries;
            }
        }
    }

    if (NULL != pRasSetEntryProperties)
    {
        if (pfnRasSetEntryProperties)
        {
            *pRasSetEntryProperties = pfnRasSetEntryProperties;
        }
        else
        {
            *pRasSetEntryProperties = (pfnRasSetEntryPropertiesSpec)GetProcAddressFromRasApi32orRnaph("RasSetEntryPropertiesA",
                                                                                        &plat);
            if (NULL == *pRasSetEntryProperties)
            {
                return FALSE;
            }
            else
            {
                pfnRasSetEntryProperties = *pRasSetEntryProperties;
            }
        }
    }

    if (NULL != pRasEnumDevices)
    {
        if (pfnRasEnumDevices)
        {
            *pRasEnumDevices = pfnRasEnumDevices;
        }
        else
        {
            *pRasEnumDevices = (pfnRasEnumDevicesSpec)GetProcAddressFromRasApi32orRnaph("RasEnumDevicesA",
                                                                                        &plat);
            if (NULL == *pRasEnumDevices)
            {
                return FALSE;
            }
            else
            {
                pfnRasEnumDevices = *pRasEnumDevices;
            }
        }
    }

    if (NULL != pRasGetEntryProperties)
    {
        if (pfnRasGetEntryProperties)
        {
            *pRasGetEntryProperties = pfnRasGetEntryProperties;
        }
        else
        {
            *pRasGetEntryProperties = (pfnRasGetEntryPropertiesSpec)GetProcAddressFromRasApi32orRnaph("RasGetEntryPropertiesA", &plat);
            if (NULL == *pRasGetEntryProperties)
            {
                return FALSE;
            }
            else
            {
                pfnRasGetEntryProperties = *pRasGetEntryProperties;
            }
        }
    }

    if (NULL != pRasSetCredentials)
    {
        if (pfnRasSetCredentials)
        {
            *pRasSetCredentials = pfnRasSetCredentials;
        }
        else
        {
            *pRasSetCredentials = (pfnRasSetCredentialsSpec)GetProcAddressFromRasApi32orRnaph("RasSetCredentialsA", &plat);
            if (NULL == *pRasSetCredentials)
            {
                return FALSE;
            }
            else
            {
                pfnRasSetCredentials = *pRasSetCredentials;
            }
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  GetShell32Apis
//
// Synopsis:  This function is used to load the shell32.dll and call getprocaddress
//            on the needed functions.  This function is used to speed up the process
//            by keeping one copy of shell32.dll in memory and caching the function
//            pointers requested.  If a function pointer hasn't been requested yet,
//            then it will have to be looked up.
//
// Arguments: pfnSHGetFolderPathSpec* pGetFolderPath - pointer for SHGetFolderPath
//            pfnSHGetSpecialFolderPathWSpec* pGetSpecialFolderPathW - pointer for GetSpecialFolderPathW
//
// Returns:   BOOL - TRUE if all requested function pointers were retreived.
//
// History:   quintinb Created     11/23/98
//
//+----------------------------------------------------------------------------
BOOL GetShell32Apis(pfnSHGetFolderPathSpec* pGetFolderPath,
                    pfnSHGetSpecialFolderPathWSpec* pGetSpecialFolderPathW)
{
    static pfnSHGetFolderPathSpec pfnSHGetFolderPath = NULL; // this takes a User token
    static pfnSHGetSpecialFolderPathWSpec pfnSHGetSpecialFolderPathW = NULL;

#ifdef UNICODE
    const CHAR c_pszSHGetFolderPath[] = "SHGetFolderPathW";
#else
    const CHAR c_pszSHGetFolderPath[] = "SHGetFolderPathA";
#endif
    const CHAR c_pszSHGetSpecialFolderPathW[] = "SHGetSpecialFolderPathW";


    if (NULL == g_pShell32)
    {
        g_pShell32 = (CDynamicLibrary*)CmMalloc(sizeof(CDynamicLibrary));
        if (NULL == g_pShell32)
        {
            return FALSE;
        }
    }

    if (!(g_pShell32->IsLoaded()))
    {
        if(!g_pShell32->Load(TEXT("shell32.dll")))
        {
            return FALSE;
        }
    }

    if (NULL != pGetFolderPath)
    {
        if (pfnSHGetFolderPath)
        {
            *pGetFolderPath = pfnSHGetFolderPath;
        }
        else
        {
            *pGetFolderPath = (pfnSHGetFolderPathSpec)g_pShell32->GetProcAddress(c_pszSHGetFolderPath);
            if (NULL == *pGetFolderPath)
            {
                return FALSE;
            }
            else
            {
                pfnSHGetFolderPath = *pGetFolderPath;
            }
        }
    }

    if (NULL != pGetSpecialFolderPathW)
    {
        if (pfnSHGetSpecialFolderPathW)
        {
            *pGetSpecialFolderPathW = pfnSHGetSpecialFolderPathW;
        }
        else
        {
            *pGetSpecialFolderPathW = (pfnSHGetSpecialFolderPathWSpec)g_pShell32->GetProcAddress(c_pszSHGetSpecialFolderPathW);
            if (NULL == *pGetSpecialFolderPathW)
            {
                return FALSE;
            }
            else
            {
                pfnSHGetSpecialFolderPathW = *pGetSpecialFolderPathW;
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\mutexclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mutexclass.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file pound includes the mutex class from 
//           common\source\mutex.cpp.  Please see this file for details.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header     08/19/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

#ifndef UNICODE
#define CreateMutexU CreateMutexA
#else
#define CreateMutexU CreateMutexW
#endif

//
//	Please see pnpu\common\source for the actual source here.
//
#include "mutex.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\installerfuncs.h ===
//+----------------------------------------------------------------------------
//
// File:     installerfuncs.h
//
// Module:   CMSTP.EXE
//
// Synopsis: This header contains definitions for the mode entry point
//           functions (installing, uninstalling, uninstalling CM,
//           profile migration, OS upgrade migration, etc.) which need
//           to be shared because they may be called from other files within
//           cmstp.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    07/14/98
//
//+----------------------------------------------------------------------------
HRESULT InstallInf(HINSTANCE hInstance, LPCTSTR szInfFile, BOOL bNoSupportFiles, 
				BOOL bNoLegacyIcon, BOOL bNoNT5Shortcut, BOOL bSilent, 
				BOOL bSingleUser, BOOL bSetAsDefault, CNamedMutex* pCmstpMutex);
HRESULT MigrateOldCmProfilesForProfileInstall(HINSTANCE hInstance, LPCTSTR szCurrentDir);
HRESULT MigrateCmProfilesForWin2kUpgrade(HINSTANCE hInstance);
HRESULT UninstallProfile(HINSTANCE hInstance, LPCTSTR szInfFile, BOOL bCleanUpCreds);
HRESULT UninstallCm(HINSTANCE hInstance, LPCTSTR szInfPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\common.h ===
//+----------------------------------------------------------------------------
//
// File:     common.h
//
// Module:   CMSTP.EXE
//
// Synopsis: This header contains common functions used for the different 
//           aspects of the profile installer (install, uninstall, migration).
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    07/14/98
//
//+----------------------------------------------------------------------------
#ifndef _CMSTP_COMMON_H
#define _CMSTP_COMMON_H

#define _MBCS

//
//  Standard Windows Includes
//
#include <windows.h>
#include <ras.h>
#include <raserror.h>
#include <shlobj.h>
#include <shellapi.h>
//#include <objbase.h>

//
//  Our own includes
//
#include "cmdebug.h"
#include "resource.h"
#include "cmsetup.h"
#include "dynamiclib.h"
#include "cmras.h"
#include "mutex.h"
//#include "pidlutil.h"
//#include "netcon.h"
//#include "netconp.h"
//#include "cfpidl.h"
#include "loadconnfolder.h"

#include "base_str.h"
#include "mgr_str.h"
#include "inf_str.h"
#include "ras_str.h"
#include "stp_str.h"
#include "reg_str.h"
#include "userinfo_str.h"
#include "ver_str.h"

//
//  Type Definitions
//
typedef DWORD (WINAPI *pfnRasSetEntryPropertiesSpec)(LPCTSTR, LPCTSTR, LPRASENTRY, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI *pfnRasGetEntryPropertiesSpec)(LPCTSTR, LPCTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD (WINAPI *pfnRasDeleteEntrySpec)(LPCTSTR, LPCTSTR);
typedef DWORD (WINAPI *pfnRasEnumEntriesSpec)(LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD);
typedef DWORD (WINAPI *pfnRasEnumDevicesSpec)(LPRASDEVINFO, LPDWORD, LPDWORD);
typedef DWORD (WINAPI *pfnRasSetCredentialsSpec)(LPCSTR, LPCSTR, LPRASCREDENTIALSA, BOOL);
typedef DWORD (WINAPI *pfnSHGetFolderPathSpec)(HWND, int, HANDLE, DWORD, LPTSTR);
typedef HRESULT (WINAPI *pfnLaunchConnectionSpec)(const GUID&); 
typedef HRESULT (WINAPI *pfnCreateShortcutSpec)(const GUID&, WCHAR*);
typedef HRESULT (WINAPI *pfnLaunchConnectionExSpec)(DWORD, const GUID&);
typedef DWORD (WINAPI *pfnSHGetSpecialFolderPathWSpec)(HWND, WCHAR*, int, BOOL);

typedef struct _InitDialogStruct
{
    LPTSTR pszTitle;
    BOOL bNoDesktopIcon;
    BOOL bSingleUser;
} InitDialogStruct;

//
//  Constants
//
const TCHAR* const c_pszRegNameSpace = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\explorer\\Desktop\\NameSpace");
const TCHAR* const c_pszRegUninstall = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
const TCHAR* const c_pszProfileInstallPath = TEXT("ProfileInstallPath");

const TCHAR* const c_pszRegStickyUiDefault = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Network Connections");
const TCHAR* const c_pszRegDesktopShortCut = TEXT("DesktopShortcut");

const int ALLUSERS = 0x1;
const int CREATEDESKTOPICON = 0x10;

typedef struct _PresharedKeyPINStruct
{
    TCHAR szPIN[c_dwMaxPresharedKeyPIN + 1];
} PresharedKeyPINStruct;

//
//  Internal Functions (Used by other functions in the file)
//
void DeleteNT5ShortcutFromPathAndNameW(HINSTANCE hInstance, LPCWSTR szwProfileName, int nFolder);
void DeleteNT5ShortcutFromPathAndNameA(HINSTANCE hInstance, LPCSTR szProfileName, int nFolder);

//
//  Functions
//
BOOL RemovePhonebookEntry(LPCTSTR pszEntryName, LPTSTR pszPhonebook, BOOL bMatchSimilarEntries);
BOOL RemoveSpecificPhoneBookEntry(LPCTSTR szLongServiceName, LPTSTR pszPhonebook);
HRESULT CreateNT5ProfileShortcut(LPCTSTR pszProfileName, LPCTSTR pszPhoneBook, BOOL bAllUsers);
BOOL WriteCmPhonebookEntry(LPCTSTR szLongServiceName, LPCTSTR szFullPathtoPBK, LPCTSTR pszCmsFile);
BOOL GetRasModems(LPRASDEVINFO *pprdiRasDevInfo, LPDWORD pdwCnt);
BOOL PickModem(LPTSTR pszDeviceType, LPTSTR pszDeviceName, BOOL fUseVpnDevice);
BOOL IsAdmin(void);
BOOL IsAuthenticatedUser(void);
HRESULT HrIsCMProfilePrivate(LPCTSTR szPhonebook);
HRESULT GetNT5FolderPath(int nFolder, OUT LPTSTR lpszPath);
void RefreshDesktop(void);
BOOL GetAllUsersCmDir(LPTSTR  pszDir, HINSTANCE hInstance);
LPTSTR GetPrivateCmUserDir(LPTSTR  pszDir, HINSTANCE hInstance);
HRESULT HrRegDeleteKeyTree (HKEY hkeyParent, LPCTSTR szRemoveKey);
HRESULT LaunchProfile(LPCTSTR pszFullPathToCmpFile, LPCTSTR pszServiceName, 
                   LPCTSTR pszPhoneBook, BOOL bInstallForAllUsers);
BOOL AllUserProfilesInstalled();
BOOL GetPhoneBookPath(LPCTSTR pszInstallDir, LPTSTR* ppszPhoneBook, BOOL fAllUser);
void RemoveShowIconFromRunPostSetupCommands(LPCTSTR szInfFile);
BOOL GetHiddenPhoneBookPath(LPCTSTR pszProfileDir, LPTSTR* ppszPhonebook);

BOOL GetRasApis(pfnRasDeleteEntrySpec* pRasDeleteEntry, pfnRasEnumEntriesSpec* pRasEnumEntries, 
                pfnRasSetEntryPropertiesSpec* pRasSetEntryProperties, 
                pfnRasEnumDevicesSpec* pRasEnumDevices, pfnRasGetEntryPropertiesSpec* pRasGetEntryProperties,
                pfnRasSetCredentialsSpec* pRasSetCredentials);

BOOL GetShell32Apis(pfnSHGetFolderPathSpec* pGetFolderPath,
                    pfnSHGetSpecialFolderPathWSpec* pGetSpecialFolderPathW);

BOOL GetNetShellApis(pfnLaunchConnectionSpec* pLaunchConnection, 
                     pfnCreateShortcutSpec* pCreateShortcut,
                     pfnLaunchConnectionExSpec* pLaunchConnectionEx);

//
//  Defines
//
#ifdef UNICODE
#define DeleteNT5ShortcutFromPathAndName DeleteNT5ShortcutFromPathAndNameW
#else
#define DeleteNT5ShortcutFromPathAndName DeleteNT5ShortcutFromPathAndNameA
#endif

//
//  Externs -- these are defined in cmstp.cpp and allow us to use EnsureRasDllsLoaded and
//             EnsureShell32Loaded so that we only load the Ras Dll's and Shell32 once per
//             run of the exe.
//
extern CDynamicLibrary* g_pRasApi32;
extern CDynamicLibrary* g_pRnaph;
extern CDynamicLibrary* g_pShell32;
extern CDynamicLibrary* g_pNetShell;


#endif //_CMSTP_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\migrate.cpp ===
//+----------------------------------------------------------------------------
//
// File:     migrate.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains most of the code necessary for 
//           the migration of CM profiles.  This code handles both migrating 
//           a user when a CM1.2 profile is installed on a machine with 
//           existing 1.0 profiles and if the user upgrades their OS to NT5.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/14/98
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
//  For ProfileNeedsMigration
//
#include "needsmig.cpp"

//+----------------------------------------------------------------------------
//
// Function:  CreateRegAndValue
//
// Synopsis:  This function is a wrapper to Create a Reg Key and then add a defualt 
//            value to that same key.
//
// Arguments: HKEY hBaseKey - Relative starting point for the new subkey
//            LPTSTR szSubKey - SubKey path
//            LPTSTR szValue - String to put in the Keys default value.
//
// Returns:   BOOL - TRUE if the key and value were successfully created
//
// History:   quintinb Created Header    5/5/98
//
//+----------------------------------------------------------------------------
BOOL CreateRegAndValue(HKEY hBaseKey, LPCTSTR szSubKey, LPCTSTR szValue)
{
    DWORD dwDisp;
    BOOL bReturn = FALSE;
    HKEY hKey;


    if (ERROR_SUCCESS == RegCreateKeyEx(hBaseKey, szSubKey, 0, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp))
    {
        bReturn = (ERROR_SUCCESS == RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE*)szValue, (lstrlen(szValue)+1)));

        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    return bReturn;
}

// Note: I added this function because I needed to get the following CFileNameParts
//       off the stack of UpdateProfileLegacyGUIDs so that I didn't need a
//       stack checking function.  Not the greatest workaround but it sufficed.
BOOL IsDefaultIcon(LPCTSTR szIconPath)
{
    BOOL bReturn = TRUE;
    CFileNameParts IconPath(szIconPath);

    if (0 != lstrcmpi(IconPath.m_FileName, TEXT("cmmgr32")))
    {
        //
        //  Then the icon path is something else besides cmmgr32.exe, we must not
        //  update it.
        //
        bReturn = FALSE;
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  UpdateProfileLegacyGUIDs
//
// Synopsis:  This function upgrades GUIDs on a Legacy OS install to make sure
//            that older profile still function.  This is necessary because CM
//            1.0/1.1 profiles expected the CM bits to be in the same directory as
//            the cmp file.  Thus only the cmp filename was given.  In CM 1.2 we need
//            the full path to the CMP file since the cm bits are now located in
//            system32.  The GUIDs are also updated to have a delete option and
//            the attributes were changed to not allow renaming.
//
// Arguments: LPTSTR szCmpFile - Full path to the cmp file of the profile to update
//
// Returns:   BOOL - returns TRUE if the profile was successfully updated
//
// History:   quintinb Created Header    5/5/98
//
//+----------------------------------------------------------------------------
BOOL UpdateProfileLegacyGUIDs(LPCTSTR szCmpFile)
{
    TCHAR szInfFile[MAX_PATH+1];
    TCHAR szGUID[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szSubKey[MAX_PATH+1];
    TCHAR szCommandStr[2*MAX_PATH+1];
    BOOL bReturn = TRUE;
    HKEY hKey;
    UINT nNumChars;

    MYDBGASSERT(NULL != szCmpFile);
    MYDBGASSERT(TEXT('\0') != szCmpFile[0]);

    //
    //  Now split the path
    //
    CFileNameParts FileParts(szCmpFile);

    //
    //  Now construct the path to the INF file (1.0 and 1.1 profiles kept the infs in 
    //  the system dir)
    //
    MYVERIFY(0 != GetSystemDirectory(szTemp, MAX_PATH));

    nNumChars = (UINT)wsprintf(szInfFile, TEXT("%s\\%s%s"), szTemp, FileParts.m_FileName, TEXT(".inf"));
    MYDBGASSERT(CELEMS(szInfFile) > nNumChars);

    //
    //  Get the GUID from the inf file.
    //
    ZeroMemory(szGUID, sizeof(szGUID));
    GetPrivateProfileString(c_pszInfSectionStrings, c_pszDesktopGuid, TEXT(""), szGUID, 
        MAX_PATH, szInfFile);

    if (0 != szGUID[0])
    {

        //
        //  Update the DefaultIcon Value if it points to cmmgr32.exe
        //
        BOOL bUpdateIconPath = TRUE;

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\DefaultIcon"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szSubKey, 0, KEY_READ | KEY_WRITE, &hKey))
        {
            DWORD dwSize = CELEMS(szTemp);
            DWORD dwType = REG_SZ;

            if (ERROR_SUCCESS == RegQueryValueEx(hKey, NULL, NULL, &dwType, (LPBYTE)szTemp, &dwSize))
            {
                bUpdateIconPath = IsDefaultIcon(szTemp);
            }

            RegCloseKey(hKey);
        }

        if (bUpdateIconPath)
        {
            if (GetSystemDirectory(szTemp, CELEMS(szTemp)))
            {
                nNumChars = (UINT)wsprintf(szCommandStr, TEXT("%s\\cmmgr32.exe,0"), szTemp);
                MYDBGASSERT(CELEMS(szCommandStr) > nNumChars);

                bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);
            }
        }

        //
        //  Update Settings to Properties on the desktop icon menu
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Settings..."), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        nNumChars = (UINT)wsprintf(szCommandStr, TEXT("P&roperties"));
        MYDBGASSERT(CELEMS(szCommandStr) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);

        //
        //  Now change the underlying command to give the full
        //  path to the cmp file.
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Settings...\\Command"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        nNumChars = (UINT)wsprintf(szCommandStr, TEXT("cmmgr32.exe /settings \"%s\""), szCmpFile);
        MYDBGASSERT(CELEMS(szCommandStr) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);
        

        //
        //  Update Open to Connect on the desktop icon menu
        //
        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Open"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        nNumChars = (UINT)wsprintf(szCommandStr, TEXT("C&onnect"));
        MYDBGASSERT(CELEMS(szCommandStr) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);

        //
        //  Now change the underlying command string to use the full path to the cmp file.
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Open\\Command"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        nNumChars = (UINT)wsprintf(szCommandStr, TEXT("cmmgr32.exe \"%s\""), szCmpFile);
        MYDBGASSERT(CELEMS(szCommandStr) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);

        //
        //  Remove the showicon command from the inf. 
        //
//      RemoveShowIconFromRunPostSetupCommands(szInfFile);
        
        //
        //  Add the delete menu option
        //
        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Delete"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        nNumChars = (UINT)wsprintf(szCommandStr, TEXT("&Delete"));
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szCommandStr);

        //
        //  Create the uninstall command
        //
        lstrcpy(szTemp, TEXT("cmstp.exe /u \""));
        lstrcat(szTemp, szInfFile);
        lstrcat(szTemp, TEXT("\""));

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\Shell\\Delete\\Command"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        bReturn &= CreateRegAndValue(HKEY_CLASSES_ROOT, szSubKey, szTemp);

        //
        //  Remove the Add/Remove Programs entry, making sure to leave the uninstall dir
        //  value.
        //
        
        nNumChars = (UINT)wsprintf(szSubKey, TEXT("%s\\%s"), c_pszRegUninstall, 
            FileParts.m_FileName);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);
        
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            szSubKey, 0, KEY_ALL_ACCESS, &hKey))
        {
            RegDeleteValue(hKey, TEXT("UninstallString"));
            RegDeleteValue(hKey, TEXT("DisplayName"));
            RegCloseKey(hKey);
        }

        //
        //  Change the attributes to not allow rename
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s\\ShellFolder"), szGUID);
        MYDBGASSERT(CELEMS(szSubKey) > nNumChars);

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, 
            szSubKey, 0, KEY_ALL_ACCESS, &hKey))
        {
            DWORD dwZero = 0;
            bReturn &= (ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("Attributes"), 
                0, REG_DWORD, (BYTE*)&dwZero, sizeof(DWORD)));  //lint !e514 this is desired behavior

            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
        }
        else
        {
            bReturn = FALSE;
        }
    }
    else
    {
        bReturn = FALSE;
    }

    return bReturn;
}


//+----------------------------------------------------------------------------
//
// Function:  UpdateProfileDesktopIconsOnNT5
//
// Synopsis:  This function is meant to be called in an upgrade scenario of NT5.
//            Thus if the user has Connection Manager installed on a legacy platform
//            and then upgrades to NT5, this code would be called.  Basically the code
//            removes the users existing Desktop GUID and replaces it with a Desktop
//            icon that is a shortcut to the connection object in the connections folder.
//            This code assumes the new NT5 pbk entry is written and that the connections folder
//            is uptodate.
//
// Arguments: LPTSTR szCmpFilePath - path to the cmp file for the profile
//            LPTSTR szLongServiceName -  Long Service Name of the profile
//
// Returns:   BOOL - TRUE if the profile is successfully updated
//
// History:   quintinb Created Header    5/5/98
//
//+----------------------------------------------------------------------------
BOOL UpdateProfileDesktopIconsOnNT5(HINSTANCE hInstance, LPCTSTR szCmpFilePath, LPCTSTR szLongServiceName)
{

    TCHAR szInfFile[MAX_PATH+1];
    TCHAR szGUID[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szSubKey[MAX_PATH+1];
    BOOL bReturn = TRUE;
    HKEY hKey;
    HRESULT hr;
    UINT nNumChars;

    //
    //  Now split the path
    //

    CFileNameParts FileParts(szCmpFilePath);

    //
    //  Now construct the path to the 1.2 inf file location
    //
    nNumChars = (UINT)wsprintf(szInfFile, TEXT("%s%s%s\\%s%s"), FileParts.m_Drive, 
        FileParts.m_Dir, FileParts.m_FileName, FileParts.m_FileName, TEXT(".inf"));

    MYDBGASSERT(nNumChars < CELEMS(szInfFile));

    if (!FileExists(szInfFile))
    {
        //
        //  Now construct the path to the INF file (1.0 and 1.1 profiles kept the infs in 
        //  the system dir)
        //
        MYVERIFY(0 != GetSystemDirectory(szTemp, MAX_PATH));

        nNumChars = (UINT)wsprintf(szInfFile, TEXT("%s\\%s%s"), szTemp, FileParts.m_FileName, TEXT(".inf"));
        MYDBGASSERT(nNumChars < CELEMS(szInfFile));

        if (!FileExists(szInfFile))
        {
            return FALSE;
        }
//else
//{
            //
            //  Remove ShowIcon from the Inf File so that the user won't get an error if they
            //  try to uninstall it.
            //
//  RemoveShowIconFromRunPostSetupCommands(szInfFile);      
//}
    }

    //
    //  Get the GUID from the inf file.
    //
    ZeroMemory(szGUID, sizeof(szGUID));
    MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszDesktopGuid, TEXT(""), szGUID, 
        MAX_PATH, szInfFile));

    if (0 != szGUID[0])
    {
        //
        //  Delete the Explorer\Desktop entry
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("%s\\%s"), c_pszRegNameSpace, szGUID);
        if (CELEMS(szSubKey) > nNumChars)
        {
            hr = HrRegDeleteKeyTree (HKEY_LOCAL_MACHINE, szSubKey);
            bReturn &= SUCCEEDED(hr);   //lint !e514 intended use, quintinb
        }

        //
        //  Delete the GUID
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("CLSID\\%s"), szGUID);
        if (CELEMS(szSubKey) > nNumChars)
        {
            hr = HrRegDeleteKeyTree (HKEY_CLASSES_ROOT, szSubKey);
            bReturn &= SUCCEEDED(hr);//lint !e514 intended use, quintinb
        }

        //
        //  Delete the uninstall strings
        //

        nNumChars = (UINT)wsprintf(szSubKey, TEXT("%s\\%s"), c_pszRegUninstall, FileParts.m_FileName);

        if (CELEMS(szSubKey) > nNumChars)
        {
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                szSubKey, 0, KEY_ALL_ACCESS, &hKey))
            {
                //
                //  Leave the UninstallDir value but delete the other two.  We still use
                //  UninstallDir to know where to uninstall from.
                //

                bReturn &= (ERROR_SUCCESS == RegDeleteValue(hKey, 
                    TEXT("DisplayName")));    //lint !e514 intended use, quintinb
                bReturn &= (ERROR_SUCCESS ==RegDeleteValue(hKey, 
                    TEXT("UninstallString"))); //lint !e514 intended use, quintinb
            }
        }

        //
        //  Construct the InstallDir path to get the phonebook path to 
        //  pass to CreateShortcut
        //
        szTemp[0] = TEXT('\0');

        if (GetAllUsersCmDir(szTemp, hInstance))
        {
            LPTSTR pszPhoneBook = NULL;

            //
            //  Assuming that legacy platform was All-Users thus we use TRUE
            //
            if (GetPhoneBookPath(szTemp, &pszPhoneBook, TRUE))
            {
                //
                //  Create a desktop shortcut
                //
                DeleteNT5ShortcutFromPathAndName(hInstance, szLongServiceName, CSIDL_COMMON_DESKTOPDIRECTORY);

                hr = CreateNT5ProfileShortcut(szLongServiceName, pszPhoneBook, TRUE); // bAllUsers == TRUE
                bReturn &= SUCCEEDED(hr);   //lint !e514 intended use, quintinb        
            }
            CmFree(pszPhoneBook);
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  RemoveOldCmInstalls
//
// Synopsis:  This function tries to remove old Connection Manager installs by
//            using the instcm.inf file.
//
// Arguments: LPTSTR szCmpFile - Path to a cmp file (gives the directory of 
//                               the CM install to delete)
//
// Returns:   BOOL - returns TRUE if instcm.inf was successfully launched or
//                   if the cmp was in winsys, in which case we don't want to 
//                   launch.
//
// History:   quintinb Created Header    5/5/98
//
//+----------------------------------------------------------------------------
BOOL RemoveOldCmInstalls(HINSTANCE hInstance, LPCTSTR szCmpFile, LPCTSTR szCurrentDir)
{
    TCHAR szDest[MAX_PATH+1];
    TCHAR szSource[MAX_PATH+1];
    TCHAR szCmDir[MAX_PATH+1];
    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    UINT nNumChars;
    BOOL bReturn = FALSE;
    HKEY hKey;

    //
    //  Check the input
    //
    if ((szCmpFile == NULL) || (TEXT('\0') == szCmpFile[0]))
    {
        return FALSE;
    }

    //
    //  Next make a copy of instcm.inf
    //

    const TCHAR* const c_pszInstCmInfFmt = TEXT("%sinstcm.inf");
    const TCHAR* const c_pszRemoveCmInfFmt = TEXT("%sremovecm.inf");

    if (0 == GetSystemDirectory(szSystemDir, MAX_PATH))
    {
        return FALSE;
    }

    lstrcat(szSystemDir, TEXT("\\"));

    nNumChars = (UINT)wsprintf(szSource, c_pszInstCmInfFmt, szSystemDir);
    MYDBGASSERT(CELEMS(szSource) > nNumChars);

    nNumChars = (UINT)wsprintf(szDest, c_pszRemoveCmInfFmt, szSystemDir);
    MYDBGASSERT(CELEMS(szDest) > nNumChars);

    if (!FileExists(szSource))
    {
        //
        //  We probably haven't installed instcm.inf yet, check in the current dir.
        //

        nNumChars = (UINT)wsprintf(szSource, c_pszInstCmInfFmt, szCurrentDir);
        MYDBGASSERT(CELEMS(szSource) > nNumChars);

        nNumChars = (UINT)wsprintf(szDest, c_pszRemoveCmInfFmt, szCurrentDir);
        MYDBGASSERT(CELEMS(szDest) > nNumChars);
    }

    if (CopyFile(szSource, szDest, FALSE))
    {
        //
        //  Now construct the directory that the old cm bits could be in.
        //

        CFileNameParts FileParts(szCmpFile);

        nNumChars = (UINT)wsprintf(szCmDir, TEXT("%s%s"), FileParts.m_Drive, FileParts.m_Dir);
        MYDBGASSERT(CELEMS(szCmDir) > nNumChars);
        
        //
        //  Make sure that we are not uninstalling CM from system32 (the new 1.2 location)
        //

        if (0 == lstrcmpi(szSystemDir, szCmDir))
        {
            //
            //  Then the cmp file is in winsys, so don't remove the new cm bits
            //
            return TRUE;
        }

        //  Next put the path to the CM bits in the OldPath Value of the CMMGR32.EXE
        //  App Paths Key

        nNumChars = (UINT)wsprintf(szTemp, c_pszRegCmAppPaths);
        MYDBGASSERT(CELEMS(szTemp) > nNumChars);

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            szTemp, 0, KEY_ALL_ACCESS, &hKey))
        {
            if (ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("OldPath"), 0, REG_SZ, 
                (BYTE*)szCmDir, (lstrlen(szCmDir) + sizeof(TCHAR)))) // must include size of NULL char
            {
                //
                //  Finally launch the inf file to uninstall CM
                // 
                
                TCHAR szTitle[MAX_PATH+1] = {TEXT("")};
                MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
                MYDBGASSERT(TEXT('\0') != szTitle[0]);

                MYVERIFY(SUCCEEDED(LaunchInfSection(szDest, TEXT("Remove"), szTitle, TRUE)));  // bQuiet = TRUE
                
                RegDeleteValue(hKey, TEXT("OldPath")); //lint !e534 if CM app path is removed so is this
                
                bReturn = TRUE;
            }

            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  MigratePhonebookEntry
//
// Synopsis:  This function migrates an old phonebook entry to the new 
//
// Arguments: HINSTANCE hInstance - Module instance handle so that resources can be accessed
//            LPCTSTR pszCmpFile - full path to the cmp file
//            LPCTSTR pszLongServiceName - Long service name of the profile
//
// Returns:   BOOL - returns TRUE on success
//
// History:   quintinb Created for NTRAID 227444    9/30/98
//            quintinb modified to delete from ras\rasphone.pbk 
//                     as well on NT5 (NTRAID 280738)           2/1/99
//
//+----------------------------------------------------------------------------
BOOL MigratePhonebookEntry(HINSTANCE hInstance, LPCTSTR pszCmpFile, LPCTSTR pszLongServiceName)
{
    TCHAR szCmsFile[MAX_PATH+1];
    TCHAR szInstallDir[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    LPTSTR pszPhonebook = NULL;
    CPlatform plat;

    //
    //  First try to delete the phonebook entry from the old phonebook location,
    //  namely %windir%\system32\ras\rasphone.pbk
    //
    if (plat.IsAtLeastNT5() && GetSystemDirectory(szTemp, CELEMS(szTemp)))
    {
        pszPhonebook = (LPTSTR)CmMalloc(1 + lstrlen(c_pszRasDirRas) + 
                                            lstrlen(c_pszRasPhonePbk) + 
                                            lstrlen (szTemp));
        if (NULL != pszPhonebook)
        {
            wsprintf(pszPhonebook, TEXT("%s%s%s"), szTemp, c_pszRasDirRas, c_pszRasPhonePbk);
        
            CMTRACE2(TEXT("MigratePhonebookEntry -- Calling RemovePhonebookEntry on %s in phone book %s"), pszLongServiceName, MYDBGSTR(pszPhonebook));

            RemovePhonebookEntry(pszLongServiceName, pszPhonebook, TRUE);

            CmFree(pszPhonebook);
        }
    }

    //
    //  Next try to delete the phonebook entry from the new location, namely
    //  C:\Documents and Settings\All Users\Application Data\Microsoft\Network\Connections\PBK\rasphone.pbk
    //
    if (!GetAllUsersCmDir(szInstallDir, hInstance))
    {
        return FALSE;
    }

    //
    //  Construct the cms file
    //
    CFileNameParts  CmpFileParts(pszCmpFile);

    MYVERIFY(CELEMS(szCmsFile) > (UINT)wsprintf(szCmsFile, TEXT("%s%s\\%s.cms"), 
        szInstallDir, CmpFileParts.m_FileName, CmpFileParts.m_FileName));

    //
    //  Get the new phonebook path.
    //  Assuming that legacy platform was All-Users thus we use TRUE
    //
    if (!GetPhoneBookPath(szInstallDir, &pszPhonebook, TRUE))
    {
        return FALSE;
    }

    CMTRACE2(TEXT("MigratePhonebookEntry -- Calling RemovePhonebookEntry on %s in phone book %s"), pszLongServiceName, MYDBGSTR(pszPhonebook));

    MYVERIFY(FALSE != RemovePhonebookEntry(pszLongServiceName, pszPhonebook, TRUE));

    //
    //  Finally write the new pbk entry.
    //
    BOOL bReturn = WriteCmPhonebookEntry(pszLongServiceName, pszPhonebook, szCmsFile);

    CmFree(pszPhonebook);

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  MigrateOldCmProfileForProfileInstall
//
// Synopsis:  This function is used to migrate Old cm profiles when a 1.2 profile
//            is installed.  This ensures that old profiles will still work but
//            that already migrated profiles won't be migrated over and over again.
//            This function should only be called when a 1.2 profile is installed
//            and not on OS migration, call MigrateCmProfilesForWin2kUpgrade for
//            that.  Migration of the profile consists of deleting the old connectoids
//            and creating new style connectoids.  Ensuring that the desktop guid
//            is up to date or is replaced by a shortcut on NT5.  It also removes
//            old installs of CM as neccessary.
//
// Arguments: HINSTANCE hInstance - Instance handle to load resources as necessary
//
// Returns:   HRESULT -- Standard COM Error Codes
//
// History:   quintinb Created    11/18/98
//
//+----------------------------------------------------------------------------
HRESULT MigrateOldCmProfilesForProfileInstall(HINSTANCE hInstance, LPCTSTR szCurrentDir)
{
    HKEY hKey;
    DWORD dwValueSize;
    DWORD dwType;
    DWORD dwDataSize;
    TCHAR szCurrentValue[MAX_PATH+1];
    TCHAR szCurrentData[MAX_PATH+1];
    BOOL bReturn = TRUE;
    CPlatform plat;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, KEY_ALL_ACCESS, &hKey))
    {
        DWORD dwIndex = 0;
        dwValueSize = MAX_PATH;
        dwDataSize = MAX_PATH;
                
        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType, 
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            if (REG_SZ == dwType)
            {
                MYDBGASSERT(0 != szCurrentValue[0]);
                MYDBGASSERT(0 != szCurrentData[0]);

                if (ProfileNeedsMigration(szCurrentValue, szCurrentData))
                {
                    //
                    //  Update the phonebook entries
                    //
                    bReturn &= MigratePhonebookEntry(hInstance, szCurrentData, szCurrentValue);

                    if (plat.IsAtLeastNT5())
                    {
                        //
                        //  when we are moving a machine to NT5 we need to remove the profiles
                        //  old pbk entries and create new ones.  Then we need to remove the 
                        //  profile GUIDS and replace them with desktop shortcuts.
                        //

                        bReturn &= UpdateProfileDesktopIconsOnNT5(hInstance, szCurrentData, 
                            szCurrentValue);
                    }
                    else
                    {
                        //
                        //  Fix up the users desktop GUIDs so they work with the new
                        //  command line format.
                        //
                        bReturn &= UpdateProfileLegacyGUIDs(szCurrentData);
                    }
                
                    //
                    //  Always try to remove old CM installs
                    //
                    bReturn &= RemoveOldCmInstalls(hInstance, szCurrentData, szCurrentDir);                
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    else
    {
       CMTRACE(TEXT("No CM mappings key to migrate."));
    }

    RefreshDesktop();

    return (bReturn ? S_OK : E_FAIL);
}

//+----------------------------------------------------------------------------
//
// Function:  MigrateCmProfilesForWin2kUpgrade
//
// Synopsis: 
//  
//  This function opens the HKLM Mappings key and enumerates all the profiles that are 
//  listed there.  This function is used when a legacy machine is upgraded to Win2K and
//  CM is installed.  In this case we have 1.0/1.1/1.2 profiles that need to be migrated to use
//  the NT5 connections folder.  Thus they need to have their connectoids upgraded to the new
//  NT 5 style and they need to have their Desktop Guids replaced by shortcuts to the connections
//  folder.  We should always attempt to remove any old installations of connection manager 
//  that are discovered in the old cmp directories.
//
// Arguments: hInstance - Instance handle for string resources
//
// Returns:   HRESULT -- Standard COM Error codes
//
// History:   quintinb created  5/2/98
//
//+----------------------------------------------------------------------------
HRESULT MigrateCmProfilesForWin2kUpgrade(HINSTANCE hInstance)
{
    HKEY hKey;
    DWORD dwValueSize;
    DWORD dwType;
    DWORD dwDataSize;
    TCHAR szCurrentDir[MAX_PATH+1];
    TCHAR szCurrentValue[MAX_PATH+1];
    TCHAR szCurrentData[MAX_PATH+1];

    CPlatform plat;
    if (0 == GetCurrentDirectory(MAX_PATH, szCurrentDir))
    {
        return E_FAIL;
    }
    lstrcat(szCurrentDir, TEXT("\\"));

    if (!(plat.IsAtLeastNT5()))
    {
        CMASSERTMSG(FALSE, TEXT("MigrateCmProfilesForWin2kUpgrade - This function is supposed to be NT5 only"));
        return E_FAIL;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, KEY_ALL_ACCESS, &hKey))
    {
        DWORD dwIndex = 0;
        dwValueSize = MAX_PATH;
        dwDataSize = MAX_PATH;
                
        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType, 
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            if (REG_SZ == dwType)
            {
                MYDBGASSERT(0 != szCurrentValue[0]);
                MYDBGASSERT(0 != szCurrentData[0]);

                //
                //  Update the phonebook entries
                //
                BOOL bReturn = MigratePhonebookEntry(hInstance, szCurrentData, szCurrentValue);

                if (!bReturn)
                {
                    CMTRACE2(TEXT("MigrateCmProfilesForWin2kUpgrade -- MigratePhonebookEntry for profile %s failed.  Cmp path is %s"), szCurrentValue, szCurrentData);
                }

                //
                //  when we are moving a machine to NT5 we need to remove the profiles
                //  old pbk entries and create new ones.  Then we need to remove the 
                //  profile GUIDS and replace them with desktop shortcuts.
                //

                bReturn = UpdateProfileDesktopIconsOnNT5(hInstance, szCurrentData, szCurrentValue);

                if (!bReturn)
                {
                    CMTRACE2(TEXT("MigrateCmProfilesForWin2kUpgrade -- UpdateProfileDesktopIconsOnNT5 for profile %s failed.  Cmp path is %s"), szCurrentValue, szCurrentData);
                }

                
                //
                //  Always try to remove old CM installs
                //

                bReturn = RemoveOldCmInstalls(hInstance, szCurrentData, szCurrentDir);

                if (!bReturn)
                {
                    CMTRACE2(TEXT("MigrateCmProfilesForWin2kUpgrade -- RemoveOldCmInstalls for profile %s failed.  Cmp path is %s"), szCurrentValue, szCurrentData);
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    else
    {
       CMTRACE(TEXT("No CM mappings key to migrate."));
    }

    RefreshDesktop();

    static const TCHAR c_ValueString[] = TEXT("Connection Manager Profiles Upgrade");

    LONG lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"),
                           0,
                           KEY_SET_VALUE,
                           &hKey);

    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    if (SUCCEEDED(hr))
    {
        RegDeleteValue(hKey, c_ValueString); //lint !e534 this value may not exist
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }        

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\atol.cpp ===
//+----------------------------------------------------------------------------
//
// File:     atol.cpp (from libc atox.c)
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Conversion routines
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:	 henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
// Function:  WINAPI CmAtolW
//
// Synopsis:  This function converts a Unicode string to a long
//
// Arguments: *nptr - Unicode string to convert
//
// Returns:   LONG - long representation of the string passed in
//
// History:   quintinb Rewrote for Unicode conversion     4/8/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LONG WINAPI CmAtolW(const WCHAR *nptr)
{
    WCHAR* pszCurrent = (WCHAR*)nptr;
    WCHAR sign = L'\0';       // if '-', then negative, otherwise positive
    long total = 0;           // current total

    MYDBGASSERT(nptr);

    if (nptr)
    {
        //
        //  skip whitespace
        //
        while (CmIsSpaceW(pszCurrent))
        {
            pszCurrent = CharNextU(pszCurrent);
        }

        //
        //  Save the sign if necessary
        //
        sign = *pszCurrent;
        if ((L'-' == sign) || (L'+' == sign))
        {
            pszCurrent = CharNextU(pszCurrent);
        }

        //
        //  Construct the number
        //
        total = 0;

        while (CmIsDigitW(pszCurrent))
        {
            total = (10 * total) + (*pszCurrent - L'0');     // accumulate digit
            pszCurrent = CharNextU(pszCurrent);  // get next char
        }
    }

    if (sign == L'-')
    {
        return -total;
    }
    else
    {
        return total;   // return result, negated if necessary
    }
}

//+----------------------------------------------------------------------------
//
// Function:  WINAPI CmAtolA
//
// Synopsis:  This function converts an ANSI string to a long value
//
// Arguments: *nptr - string to convert
//
// Returns:   LONG - long representation of the string passed in
//
// History:   quintinb Rewrote for Unicode conversion     4/8/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LONG WINAPI CmAtolA(const CHAR *nptr)
{
    CHAR* pszCurrent = (CHAR*)nptr;
    CHAR sign = '\0';           // if '-', then negative, otherwise positive
    long total = 0;           // current total

    MYDBGASSERT(nptr);

    if (nptr)
    {
        //
        //  skip whitespace
        //
        while (CmIsSpaceA(pszCurrent))
        {
            pszCurrent = CharNextA(pszCurrent);
        }

        //
        //  Save the sign if necessary
        //
        sign = *pszCurrent;
        if (('-' == sign) || ('+' == sign))
        {
            pszCurrent = CharNextA(pszCurrent);
        }

        //
        //  Construct the number
        //
        total = 0;

        while (CmIsDigitA(pszCurrent))
        {
            total = (10 * total) + (*pszCurrent - '0');     // accumulate digit
            pszCurrent = CharNextA(pszCurrent);  // get next char
        }
    }

    if (sign == '-')
    {
        return -total;
    }
    else
    {
        return total;   // return result, negated if necessary
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\uninstallcm.cpp ===
//+----------------------------------------------------------------------------
//
// File:     uninstallcm.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains the code for installing Connection Manager.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/14/98
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"
#include "installerfuncs.h"

//+----------------------------------------------------------------------------
//
// Function:  CheckAndPromptForCmakAndProfiles
//
// Synopsis:  This function checks to see if CM profiles are installed or if
//            CMAK 1.21 is installed.  If it is, then uninstalling CM will make
//            the profiles and CMAK unusable and we want to prompt the user
//            to make sure they know what they are doing.
//
// Arguments: HINSTANCE hInstance - Exe instance handle to access resources
//
// Returns:   BOOL - returns TRUE if it is okay to continue with the uninstall
//
// History:   quintinb Created Header    10/21/98
//
//+----------------------------------------------------------------------------
BOOL CheckAndPromptForCmakAndProfiles(HINSTANCE hInstance, LPCTSTR pszTitle)
{
    BOOL bCmakInstalled = FALSE;
    BOOL bCmProfiles = FALSE;
    TCHAR szMsg[2*MAX_PATH+1];

    //
    //  First check to see if CMAK is installed.  If it is and has a version of 1.21 
    //  (build 1886 or newer) then we must prompt the user before uninstalling.
    //  Otherwise, if you uninstall CM out from under it, CMAK will no longer
    //  function.
    //
    DWORD dwFirst121VersionNumber = 0;
    const int c_Cmak121Version = 1886;
    int iShiftAmount = ((sizeof(DWORD)/2) * 8);
    //
    //  Construct the current version and build numbers
    //

    dwFirst121VersionNumber = (HIBYTE(VER_PRODUCTVERSION_W) << iShiftAmount) + (LOBYTE(VER_PRODUCTVERSION_W));
    
    CmakVersion CmakVer;
    
    if (CmakVer.IsPresent()) 
    {
        if ((dwFirst121VersionNumber < CmakVer.GetVersionNumber()) ||
            (c_Cmak121Version < CmakVer.GetBuildNumber()))
        {
            bCmakInstalled = TRUE;
        }
    }

    //
    //  Now check to see if we have CM profiles installed.
    //
    HKEY hKey;
    DWORD dwNumValues;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
        KEY_READ, &hKey))
    {
        if ((ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, 
            &dwNumValues, NULL, NULL, NULL, NULL)) && (dwNumValues > 0))
        {
            //
            //  Then we have mappings values, so we need to migrate them.
            //
            bCmProfiles = TRUE;

        }
        RegCloseKey(hKey);
    }

    if (bCmProfiles)
    {
        MYVERIFY(0 != LoadString(hInstance, bCmakInstalled ? IDS_UNINSTCM_BOTH : IDS_UNINSTCM_WCM, szMsg, 2*MAX_PATH));
        MYDBGASSERT(TEXT('\0') != szMsg[0]);
        if (IDNO == MessageBox(NULL, szMsg, pszTitle, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION))
        {
            return FALSE;
        }
    }
    else if (bCmakInstalled)
    {
        //
        //  Just CMAK is installed
        //

        MYVERIFY(0 != LoadString(hInstance, IDS_UNINSTCM_WCMAK, szMsg, 2*MAX_PATH));
        MYDBGASSERT(TEXT('\0') != szMsg[0]);
        if (IDNO == MessageBox(NULL, szMsg, pszTitle, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  PromptUserToUninstallCm
//
// Synopsis:  This function prompts the user to see if they wish to uninstall
//            Connection Manager.  It also deals with the warning prompts if
//            the user has CMAK or CM profiles installed.
//
// Arguments: HINSTANCE hInstance - Instance handle to load resources with.
//
// Returns:   BOOL - Returns TRUE if CM should be uninstalled, FALSE otherwise
//
// History:   quintinb Created    6/28/99
//
//+----------------------------------------------------------------------------
BOOL PromptUserToUninstallCm(HINSTANCE hInstance)
{
    BOOL bReturn = FALSE;
    TCHAR szMsg[MAX_PATH+1] = {TEXT("")};
    TCHAR szTitle[MAX_PATH+1] = {TEXT("")};

    //
    //  Load the Cmstp Title just in case we need to show error messages.
    //
    MYVERIFY(0 != LoadString(hInstance, IDS_CM_UNINST_TITLE, szTitle, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);

    //
    //  Now show the uninstall prompt to see if the user wants to uninstall CM
    //
    MYVERIFY(0 != LoadString(hInstance, IDS_CM_UNINST_PROMPT, szMsg, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szMsg[0]);

    if (IDYES == MessageBox(NULL, szMsg, szTitle, MB_YESNO | MB_DEFBUTTON2))
    {
        //
        //  Check to see if CMAK is installed or if there are profiles that are installed.
        //
        if (CheckAndPromptForCmakAndProfiles(hInstance, szTitle))
        {
            bReturn = TRUE;
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  UninstallCm
//
// Synopsis:  Uninstalls connection manager.
//
// Arguments: HINSTANCE hInstance - instance handle to access resources
//            LPCTSTR szInfPath - path to the instcm.inf file to use to uninstall cm with
//
// Returns:   HRESULT -- Standard COM Error Codes
//
// History:   Created Header    10/21/98
//
//+----------------------------------------------------------------------------
HRESULT UninstallCm(HINSTANCE hInstance, LPCTSTR szInfPath)
{
    MYDBGASSERT((szInfPath) && (TEXT('\0') != szInfPath[0]));

    //
    //  Load the Cmstp Title just in case we need to show error messages.
    //
    TCHAR szTitle[MAX_PATH+1] = {TEXT("")};
    TCHAR szMsg[MAX_PATH+1] = {TEXT("")};

    MYVERIFY(0 != LoadString(hInstance, IDS_CM_UNINST_TITLE, szTitle, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);

    //
    //  Protect /x on NT5 and win98 SR1.  We don't want CM uninstalled on Native Platforms.
    //
    HRESULT hr = S_FALSE;
    if (!CmIsNative())
    {
        if (SUCCEEDED(LaunchInfSection(szInfPath, TEXT("1.2Legacy_Uninstall"), szTitle, FALSE)))  // bQuiet = FALSE
        {
            MYVERIFY(0 != LoadString(hInstance, IDS_CM_UNINST_SUCCESS, szMsg, MAX_PATH));
            MYDBGASSERT(TEXT('\0') != szMsg[0]);

            MYVERIFY(IDOK == MessageBox(NULL, szMsg, szTitle, MB_OK));

            hr = S_OK;
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("Connection Manager Uninstall Failed."));
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\uninstall.cpp ===
//+----------------------------------------------------------------------------
//
// File:     uninstall.cpp
//
// Module:   CMSTP.EXE
//
// Synopsis: This source file contains most of the code to uninstall CM profiles.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created     07/14/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

const TCHAR* const c_pszCmPath = TEXT("%s\\SOFTWARE\\Microsoft\\Connection Manager");
const TCHAR* const c_pszUserInfoPath = TEXT("%s\\SOFTWARE\\Microsoft\\Connection Manager\\UserInfo");
const TCHAR* const c_pszProfileUserInfoPath = TEXT("%s\\SOFTWARE\\Microsoft\\Connection Manager\\UserInfo\\%s");

//+----------------------------------------------------------------------------
//
// Function:  PromptUserToUninstallProfile
//
// Synopsis:  This function prompts the user to see if they wish to uninstall
//            the given profile.
//
// Arguments: HINSTANCE hInstance - Instance Handle to get resources with
//            LPCTSTR pszInfFile - full path to the profile inf file
//
// Returns:   int - Return Value of the MessageBox prompt, IDNO signifies an
//                  error or that the user didn't want to continue.  IDYES
//                  signifies that the install should continue.
//
// History:   quintinb Created     6/28/99
//
//+----------------------------------------------------------------------------
BOOL PromptUserToUninstallProfile(HINSTANCE hInstance, LPCTSTR pszInfFile)
{

    BOOL bReturn = FALSE;

    //
    //  On Legacy Platforms we need to prompt to see if the user wants to uninstall.
    //  On NT5 this is taken care of by the connections folder.  We also use no prompt
    //  when uninstalling the old profile for a same name upgrade.
    //
    TCHAR szServiceName[MAX_PATH+1];
    TCHAR szMessage[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
    TCHAR szTitle[MAX_PATH+1] = {TEXT("")};

    MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);
    
    MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, 
        TEXT(""), szServiceName, MAX_PATH, pszInfFile));

    if(TEXT('\0') != szServiceName[0])
    {
        MYVERIFY(0 != LoadString(hInstance, IDS_UNINSTALL_PROMPT, szTemp, MAX_PATH));
        MYDBGASSERT(TEXT('\0') != szTemp[0]);

        MYVERIFY(CELEMS(szMessage) > (UINT)wsprintf(szMessage, szTemp, szServiceName));

        bReturn = (IDYES == MessageBox(NULL, szMessage, szTitle, MB_YESNO | MB_DEFBUTTON2));
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("PromptUserToUninstallProfile: Failed to retrieve ServiceName from INF"));            
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  BuildUninstallDirKey
//
// Synopsis:  Utility function to expand any environment strings in the passed
//            in Mappings Data value and then parse that path into the Install
//            dir value (basically remove the \<short service name>.cmp from
//            the full path to the cmp)
//
// Arguments: LPCTSTR pszMappingsData - Raw data from the mappings key, may 
//                                      contain environment strings.
//            LPTSTR szInstallDir - Out buffer for the install dir
//
// Returns:   Nothing
//
// History:   quintinb Created Header    6/28/99
//
//+----------------------------------------------------------------------------
void BuildUninstallDirKey(LPCTSTR pszMappingsData, LPTSTR szInstallDir)
{
    TCHAR szCmp[MAX_PATH+1];
    ExpandEnvironmentStrings(pszMappingsData, szCmp, CELEMS(szCmp));

    CFileNameParts CmpParts(szCmp);

    wsprintf(szInstallDir, TEXT("%s%s"), CmpParts.m_Drive, CmpParts.m_Dir);

    if (TEXT('\\') == szInstallDir[lstrlen(szInstallDir) - 1])
    {
        szInstallDir[lstrlen(szInstallDir) - 1] = TEXT('\0');
    }
}

//+----------------------------------------------------------------------------
//
// Function:  UninstallProfile
//
// Synopsis:  This function uninstalls a CM profile.
//
// Arguments: HINSTANCE hInstance - Instance handle for resources
//            LPCTSTR szInfPath - full path of the INF to uninstall
//            BOOL bCleanUpCreds -- whether credential info in the registry 
//                                  should be cleaned up or not
//
// Returns:   HRESULT -- Standard COM Error Codes
//
// History:   Created Header    7/14/98
//
//+----------------------------------------------------------------------------
HRESULT UninstallProfile(HINSTANCE hInstance, LPCTSTR szInfFile, BOOL bCleanUpCreds)
{
    TCHAR* pszPhonebook = NULL;
    TCHAR szSectionName[MAX_PATH+1];
    TCHAR szCmsFile[MAX_PATH+1];
    TCHAR szProfileDir[MAX_PATH+1];
    TCHAR szInstallDir[MAX_PATH+1];
    TCHAR szShortServiceName[MAX_PATH+1];
    TCHAR szPhonebookPath[MAX_PATH+1];
    TCHAR szTemp[MAX_PATH+1];
	TCHAR szLongServiceName[MAX_PATH+1];

    CPlatform plat;
    HANDLE hFile;
    BOOL bReturn = FALSE;
	BOOL bAllUserUninstall;
    HKEY hBaseKey;
    HKEY hKey;
    int nDesktopFolder;
    int iCmsVersion;
    HRESULT  hr;

    const TCHAR* const c_pszRegGuidMappings = TEXT("SOFTWARE\\Microsoft\\Connection Manager\\Guid Mappings");

    ZeroMemory(szCmsFile, sizeof(szCmsFile));
    ZeroMemory(szLongServiceName, sizeof(szLongServiceName));
    ZeroMemory(szProfileDir, sizeof(szProfileDir));
    ZeroMemory(szPhonebookPath, sizeof(szPhonebookPath));
    
    //
    //  Load the title in case IExpress needs to show error dialogs
    //

    TCHAR szTitle[MAX_PATH+1] = {TEXT("")};
    MYVERIFY(0 != LoadString(hInstance, IDS_CMSTP_TITLE, szTitle, MAX_PATH));
    MYDBGASSERT(TEXT('\0') != szTitle[0]);
    
    //
 	//	Get the Long Service Name
 	//
    if (0 == GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, 
		                             TEXT(""), szLongServiceName, MAX_PATH, szInfFile))
    {
        CMASSERTMSG(FALSE, TEXT("UninstallProfile -- Unable to get Long Service Name.  This situation will occur normally when cmstp.exe /u is called by hand on NT5."));
        return E_FAIL;
    }

    //
    //  Determine if we are a private user profile or not
    //
    hr = HrIsCMProfilePrivate(szInfFile);

    if (FAILED(hr))
    {
        CMASSERTMSG(FALSE, TEXT("UninstallProfile: HrIsCMProfilePrivate failed"));
        goto exit;
    }
    else if (S_OK == hr)
    {
        //
        //  Then we have a Private Profile, send Remove_Private as the uninstall command
        //
        lstrcpy(szSectionName, TEXT("Remove_Private"));

        //
        //  All Registry access should be to the HKCU key
        //
        hBaseKey = HKEY_CURRENT_USER;
        
        //
        //  Set these just in case we are on NT5 and will need them to remove the
        //  Desktop and Start Menu shortcuts.
        //
        nDesktopFolder = CSIDL_DESKTOPDIRECTORY;

		//
		//	We use this to determine if we need a phonebook path or if NULL will work
		//
		bAllUserUninstall = FALSE;

    }
    else
    {
        //
        //  Then we have an All User profile, so send Remove as the uninstall command
        //
        lstrcpy(szSectionName, TEXT("Remove"));

        //
        //  All Registry settings will be under HKLM
        //
        hBaseKey = HKEY_LOCAL_MACHINE;

        //
        //  Set these just in case we are on NT5 and will need them to remove the
        //  Desktop shortcut.
        //
        nDesktopFolder = CSIDL_COMMON_DESKTOPDIRECTORY;

		//
		//	We use this to determine if we need a phonebook path or if NULL will work
		//
		bAllUserUninstall = TRUE;
    }

    //
    //  Get the Short Service Name from the INF and use it to build the UninstallDir in the
    //  registry.
    //
    MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszShortSvcName, 
        TEXT(""), szShortServiceName, MAX_PATH, szInfFile));

    if (0 != szShortServiceName[0])
    {
        MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, 
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\%s"), 
            szShortServiceName));

        DWORD dwDisposition = 0;

        LONG lResult = RegCreateKeyEx(hBaseKey, szTemp, 0, NULL, REG_OPTION_NON_VOLATILE, 
                                      KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisposition);
        if (ERROR_SUCCESS == lResult)
        {
            const TCHAR* const c_pszUninstallDir = TEXT("UninstallDir");
            DWORD dwType = REG_SZ;
            DWORD dwSize;

            //
            //  If this value doesn't exist then the inf will fail, so we need to create it from the
            //  cmp path value.  We used to write it on install, but since we were always expanding
            //  it and rewriting it anyway (because of single user profiles), it is just easier 
            //  to ignore the existing value and create it from scratch.
            //
            HKEY hMappingsKey;

            lResult = RegOpenKeyEx(hBaseKey, c_pszRegCmMappings, 0, KEY_READ, &hMappingsKey);

            if (ERROR_SUCCESS == lResult)
            {
                dwSize = CELEMS(szTemp);

                lResult = RegQueryValueEx(hMappingsKey, szLongServiceName, NULL, 
                                          NULL, (LPBYTE)szTemp, &dwSize);

                if (ERROR_SUCCESS == lResult)
                {
                    //
                    //  Now build the UninstallDir key
                    //
                    BuildUninstallDirKey(szTemp, szInstallDir);
                }
                else
                {
                    MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
                    CMASSERTMSG(FALSE, TEXT("UninstallProfile: Unable  to find the Profile Entry in Mappings!"));
                    goto exit;                    
                }

                RegCloseKey(hMappingsKey);
            }
            else
            {
                MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
                CMASSERTMSG(FALSE, TEXT("UninstallProfile: Unable to open the Mappings key!"));
                goto exit;
            }

            //
            //  We need to write the UninstallDir key to the registry now that we
            //  have created it.  We do this because the inf processing code in advpack
            //  doesn't understand environment strings and single user strings contain
            //  the %userprofile% variable, thus we were always rewriting it anyway.
            //  Note we only write this on install of All User profiles and only because
            //  we cannot update the bits on win98 OSR1 and on IEAK5 machines (with CMAK).
            //  Otherwise we don't write this at setup time anymore.
            //
            dwSize = lstrlen(szInstallDir) + 1;
            if (ERROR_SUCCESS != RegSetValueEx(hKey, c_pszUninstallDir, NULL, dwType, 
                (CONST BYTE *)szInstallDir, dwSize))
            {
                CMASSERTMSG(FALSE, TEXT("UninstallProfile: Unable to set the UninstallDir key!"));
                goto exit;
            }

            //
            //  szInstallDir currently contains the directory above the profile directory, add
            //  the shortservice name on the end
            //
            UINT uCount = (UINT)wsprintf(szProfileDir, TEXT("%s\\%s"), szInstallDir, szShortServiceName);
            MYDBGASSERT(uCount <= CELEMS(szProfileDir));
            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));

        }
        else
        {
            //
            //  If this key doesn't exist then the inf will fail, so exit.
            //
            CMASSERTMSG(FALSE, TEXT("UninstallProfile: Unable to open profile uninstall key."));
            goto exit;
        }
    }
    else
    {
        //
        //  We shouldn't have a problem getting the short service name from a profile.
        //  something is definitely wrong here.
        //
        CMASSERTMSG(FALSE, TEXT("UninstallProfile: Unable to retrieve the ShortServiceName"));
        goto exit;
    }

    //
    //  Create the path to the cms file
    //

    MYVERIFY(CELEMS(szCmsFile) > (UINT)wsprintf(szCmsFile, TEXT("%s\\%s.cms"), szProfileDir, 
        szShortServiceName));
    
    //
    //  Remove the phonebook entry
    //

    if (TEXT('\0') != szLongServiceName[0])
    {
        if (plat.IsAtLeastNT5())
        {
            //
            //  On NT5 we want to delete the hidden phonebook entry for
            //  double dial profiles.
            //

            if (GetHiddenPhoneBookPath(szInstallDir , &pszPhonebook))
            {
                MYVERIFY(FALSE != RemovePhonebookEntry(szLongServiceName, pszPhonebook, !(plat.IsAtLeastNT5())));
		        CmFree(pszPhonebook);
            }

            if (bAllUserUninstall)
            {
                //
                //  On NT5 legacy profiles could be installed anywhere and the
                //  install dir may not reflect the actual pbk path.  Thus if it
                //  is an all user install we want to force the directory to
                //  the Cm All Users dir so we get the correct phonebook.
                //
                MYVERIFY(FALSE != GetAllUsersCmDir(szInstallDir, hInstance));
            }
        }

        if (GetPhoneBookPath(szInstallDir, &pszPhonebook, bAllUserUninstall))
        {
            //
            //  Note that usually on NT5 we are called by RasCustomDeleteEntryNotify (in cmdial32.dll)
            //  throw RasDeleteEntry.  Thus we don't really need to delete the entry.  However, it is
            //  possible that someone would call cmstp.exe /u directly and not through the RAS API, thus
            //  we want to delete the connectoid in that case.  Since we are called after RAS has already
            //  deleted the entry it shouldn't be a problem.
            //  Note that on NT5 we only remove the exact entry to fix NTRAID 349749
            //  otherwise we could end up deleting similarly named connectoids
            //  and lose the users only interface to CM.
            //
            MYVERIFY(FALSE != RemovePhonebookEntry(szLongServiceName, pszPhonebook, !(plat.IsAtLeastNT5())));
        }

		CmFree(pszPhonebook);
    }

    //
    //  Launch the uninstall INF
    //
    iCmsVersion = GetPrivateProfileInt(c_pszCmSectionProfileFormat, c_pszVersion, 
		0, szCmsFile);

    if (1 >= iCmsVersion)
    {
        //
        //  Then we have an old 1.0 profile and we should remove the showicon.exe
        //  postsetup command.
        //
        RemoveShowIconFromRunPostSetupCommands(szInfFile);
    }

    bReturn = SUCCEEDED(LaunchInfSection(szInfFile, szSectionName, szTitle, FALSE));  // bQuiet = FALSE

    //
    //  On NT5 we need to delete the desktop shortcut
    //
    if (plat.IsAtLeastNT5())
    {    
        DeleteNT5ShortcutFromPathAndName(hInstance, szLongServiceName, nDesktopFolder);
    }

    //
    //  Finally delete the profile directory. (Not deleted because the inf file resides there.  
    //  The dir can't be removed because the inf file is still in it and in use, unless this 
    //  is a legacy profile).  Not that we could cause cmstp to cause an Access Violation 
    //  if we ask it to delete an empty string.
    //
    if ((TEXT('\0') != szProfileDir[0]) && SetFileAttributes(szProfileDir, FILE_ATTRIBUTE_NORMAL))
    {
    
        SHFILEOPSTRUCT fOpStruct;
        ZeroMemory(&fOpStruct, sizeof(fOpStruct));
        
        fOpStruct.wFunc = FO_DELETE;
        fOpStruct.pFrom = szProfileDir;
        fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
        
        MYVERIFY(ERROR_SUCCESS == SHFileOperation(&fOpStruct));
    }

    //
    //  We need to try to delete the following regkeys:
    //  HKCU\\Software\\Microsoft\\Connection Manager\\<UserInfo/SingleUserInfo>
    //  HKCU\\Software\\Microsoft\\Connection Manager\\Mappings
    //  HKLM\\Software\\Microsoft\\Connection Manager\\Mappings
    //  HKCU\\Software\\Microsoft\\Connection Manager
    //  HKLM\\Software\\Microsoft\\Connection Manager
    //  

    //
    //  Registry Cleanup.  We want to delete the UserInfo keys if they are empty.
    //  We then want to delete the mappings keys if they don't contain any more
    //  values.  We also want to delete the CM registry keys if they don't contain
    //  any subkeys.  Also kill the GUID Mappings key (this was beta only but still
    //  should be deleted).  The problem here is that win95 infs delete keys recursively,
    //  even if they have subkeys.  Thus we must use code to safely delete these keys.
    //  Please note that this does mean we could be unnecessarily deleting the Components
    //  Checked value in HKLM\\...\\Connection Manager but this can't be helped.  I
    //  would rather take the small startup perf hit than leave the users registry
    //  dirty.
    //

    if (bAllUserUninstall)
    {
        wsprintf(szTemp, TEXT("%s%s"), c_pszRegCmUserInfo, szLongServiceName);
    }
    else
    {
        wsprintf(szTemp, TEXT("%s%s"), c_pszRegCmSingleUserInfo, szLongServiceName);    
    }

    //
    //  Delete the User Data, note that we have to do this programatically because
    //  of 1.0 profiles that don't know to delete their User Data on uninstall (no commands
    //  in the 1.0 inf to do so).  Note that we don't want to cleanup user data if this
    //  is a same name upgrade uninstall (uninstall the 1.0 profile before installing the
    //  new profile).
    //

    if (bCleanUpCreds)
    {
        CmDeleteRegKeyWithoutSubKeys(HKEY_CURRENT_USER, szTemp, TRUE);

        CmDeleteRegKeyWithoutSubKeys(HKEY_CURRENT_USER, c_pszRegCmUserInfo, TRUE);
        CmDeleteRegKeyWithoutSubKeys(HKEY_CURRENT_USER, c_pszRegCmSingleUserInfo, TRUE);
    }

    CmDeleteRegKeyWithoutSubKeys(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, FALSE);
    CmDeleteRegKeyWithoutSubKeys(HKEY_CURRENT_USER, c_pszRegCmMappings, FALSE);

    HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, c_pszRegGuidMappings);

    CmDeleteRegKeyWithoutSubKeys(HKEY_LOCAL_MACHINE, c_pszRegCmRoot, TRUE);
    CmDeleteRegKeyWithoutSubKeys(HKEY_CURRENT_USER, c_pszRegCmRoot, TRUE);

    //
    //  Refresh the desktop so Desktop GUIDS disappear
    //
    RefreshDesktop();

exit:
    return (bReturn ? S_OK : E_FAIL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmstp\resource.h ===
//+----------------------------------------------------------------------------
//
// File:     resource.h
//
// Module:   CMSTP.EXE
//
// Synopsis: Resource IDs
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb    Created    06/09/98
//
//+----------------------------------------------------------------------------
#ifndef _CMSTP_RESOURCE_H
#define _CMSTP_RESOURCE_H

#include "allcmdir.h"

#define IDC_STATIC               -1
#define IDC_ALLUSERS                101
#define IDC_YOURSELF                102
#define IDD_ADMINUI                 103
#define IDD_NOCHOICEUI              104
//#define IDC_STARTMENU             105
#define IDC_DESKTOP                 106
#define EXE_ICON                    107

#define IDS_USAGE_MSG               200
#define IDS_SHORTCUT_TO             201
#define IDS_UNINSTALL_PROMPT        202
#define IDS_NO_SUPPORTFILES         207
#define IDS_CM_NOTPRESENT           208
#define IDS_INUSE_MSG               209
#define IDS_CMSTP_TITLE             210
#define IDS_UNEXPECTEDERR           211
//#define IDS_RASPBKPATH              212
#define IDD_PRESHAREDKEY_PIN        213
#define IDC_PSK_PIN                 214
#define IDS_SUCCESS                 215
#define IDS_CM_OLDVERSION           216
//#define   IDS_CMSUBFOLDER           217
#define IDS_INSTCM_WITH_OLD_CMAK    218
#define IDS_BINARY_NOT_ALPHA        219
#define IDS_REBOOT_MSG              220
#define IDS_NEWER_SAMENAME          221
#define IDS_UPGRADE_SAMENAME        222
#define IDS_GET_ADMIN               223
#define IDS_CM_UNINST_PROMPT        224
#define IDS_CM_UNINST_TITLE         225
#define IDS_CM_UNINST_SUCCESS       226
#define IDS_UNINSTCM_BOTH           227
#define IDS_UNINSTCM_WCM            228
#define IDS_UNINSTCM_WCMAK          229
#define IDS_NEEDSERVICEPACK         230
#define IDS_PROFILE_TOO_OLD         231
#define IDS_SAME_SS_DIFF_LS         232
#define IDS_SAME_LS_DIFF_SS         233
#define IDS_INSTALL_NOT_ALLOWED     234
#define IDS_CANNOT_INSTALL_CM       235
#define IDS_WIN2K_CM_INSTALL_FAILED 236
#define IDS_CROSS_LANG_INSTALL      237
#define IDS_PSK_GOTTA_HAVE_IT       238
#define IDS_PSK_INCORRECT_PIN       239
#define IDS_PSK_NEEDS_XP            240


// custom resource, remcmstp.inf, must have an ID greater than 255
#define IDT_REMCMSTP_INF                5000

#endif //_CMSTP_RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\cinia.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ciniA.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Ansi CIni implementation
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   henryt - relocated to CMUTIL           03/15/98
//           quintinb - created A and W versions    05/12/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
// Function:  CIniA_Set
//
// Synopsis:  This function takes a pointer to a string and a string as arguments.  It
//            frees the string currently in the destination pointer, allocates the correct
//            amount of memory and then copies the source string to the string pointed
//            to by the destination string pointer.  The allocated memory is the
//            responsibility of the caller.
//
// Arguments: LPSTR *ppszDest - pointer to the destination string
//            LPCSTR pszSrc - source string for the set
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static void CIniA_Set(LPSTR *ppszDest, LPCSTR pszSrc)
{
    MYDBGASSERT(ppszDest);

    if (ppszDest)
    {
        CmFree(*ppszDest);
        *ppszDest = ((pszSrc && *pszSrc) ? CmStrCpyAllocA(pszSrc) : NULL);    
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA_LoadCat
//
// Synopsis:  This function concatenates the suffix argument onto the string
//            argument and returns the resulting string through the return
//            value.  Note that the function allocates the correct amount of
//            memory which must be freed by the caller.  Also not passing in
//            an empty string returns NULL while passing just an empty suffix
//            returns just a copy of the string.
//
// Arguments: LPCSTR pszStr - source string to duplicate
//            LPCSTR pszSuffix - suffix to add onto the duplicated string
//
// Returns:   LPSTR - a duplicate of the concatenated string
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static LPSTR CIniA_LoadCat(LPCSTR pszStr, LPCSTR pszSuffix)
{
    LPSTR pszTmp;

    if (!pszStr || !*pszStr)
    {
        return (NULL);
    }

    if (!pszSuffix || !*pszSuffix)
    {
        pszTmp = CmStrCpyAllocA(pszStr);
    }
    else
    {
        pszTmp = CmStrCpyAllocA(pszStr);

        if (pszTmp)
        {
            CmStrCatAllocA(&pszTmp,pszSuffix);
        }
    }

    MYDBGASSERT(pszTmp);

    return (pszTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA_GPPS
//
// Synopsis:  Wrapper for the Windows API GetPrivateProfileString.  The return
//            value is the requested value, allocated on behalf of the caller.
//            Note that the function assumes a reasonable default size and then
//            loops and reallocates until it can fit the whole string.
//
// Arguments: LPCSTR pszSection - Ini file section to retrieve data from
//            LPCSTR pszEntry - key name to retrieve data from
//            LPCSTR pszDefault - the default string value to return, defaults
//                                to the empty string ("") if not specified
//            LPCSTR pszFile - full path to the ini file to get the data from
//
// Returns:   LPSTR - the requested data from the ini file, must be freed 
//                    by the caller
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static LPSTR CIniA_GPPS(LPCSTR pszSection, LPCSTR pszEntry, LPCSTR pszDefault, LPCSTR pszFile)
 {
    LPSTR pszBuffer;
    LPCSTR pszLocalDefault = pszDefault ? pszDefault : "";

    if ((NULL == pszFile) || ('\0' == *pszFile))
    {
        CMASSERTMSG(FALSE, "CIniA_GPPS -- NULL or Empty file path passed.");
        return CmStrCpyAllocA(pszLocalDefault);
    }
    
    size_t nLen = __max((pszDefault ? lstrlenA(pszDefault) : 0) +4,48);

    while (1)
    {
        size_t nNewLen;

        pszBuffer = (LPSTR) CmMalloc(nLen*sizeof(CHAR));
		
        MYDBGASSERT(pszBuffer);

        if (pszBuffer)
        {
            nNewLen = GetPrivateProfileStringA(pszSection, pszEntry, pszLocalDefault,
                                               pszBuffer, nLen, pszFile);

            if (nNewLen+2 < nLen) 
            {
                return (pszBuffer);
            }

            CmFree(pszBuffer);
            nLen *= 2;
        }
        else
        {
            CMASSERTMSG(FALSE, "CIniA_GPPS -- CmMalloc Failed.");
            return CmStrCpyAllocA(pszLocalDefault);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CIni_SetFile
//
// Synopsis:  This function is very similar to CIniA_Set in that it takes
//            a source string and duplicates it into the string pointed to
//            by the destination pointer.  However, the difference is that
//            this function assumes the pszSrc argument to be a full path to
//            a file and thus calls CreateFile on the pszSrc string
//            before duplicating the string.
//
// Arguments: LPSTR* ppszDest - pointer to a string to accept the duplicated buffer
//            LPCSTR pszSrc - full path to a file, text to be duplicated
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::CIni_SetFile(LPSTR *ppszDest, LPCSTR pszSrc) 
{
    MYDBGASSERT(ppszDest);

    if (ppszDest)
    {
        CmFree(*ppszDest);           
        *ppszDest = NULL;

        if (pszSrc && *pszSrc) // pszSrc could be NULL
        {
            //
            // A full path to an existing file is expected
            //
	    
            HANDLE hFile = CreateFileA(pszSrc, 0, 
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            MYDBGASSERT(hFile != INVALID_HANDLE_VALUE);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);

                //
                // Update internal file
                //

                *ppszDest = CmStrCpyAllocA(pszSrc);
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CIniA
//
// Synopsis:  CIniA constructor
//
// Arguments: HINSTANCE hInst - Instance handle used to load resources
//            LPCSTR pszFile - Ini file the object describes
//            LPCSTR pszSection - a section suffix that will be appended to 
//                                all section references
//			  LPCSTR pszRegPath - a path to be used for registry access
//            LPCSTR pszEntry - an entry suffix that will be appended to all 
//                              entry references
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama Modified			 07/19/2000
//
//+----------------------------------------------------------------------------
CIniA::CIniA(HINSTANCE hInst, LPCSTR pszFile, LPCSTR pszRegPath, LPCSTR pszSection, LPCSTR pszEntry) 
{
    //
    //  Input pointers default to NULL and in fact the constructor is rarely called
    //  with parameters.  Thus we will skip checking the input pointers and just
    //  pass them on to the functions below, which are designed to except NULL inputs.
    //

    m_hInst = hInst;

    //
    //  Make sure to NULL the string params before setting them below.  This
    //  is because we call free on the inputted params and we don't want to try
    //  to free garbage.
    //
	m_pszFile = NULL;
	m_pszSection = NULL;
	m_pszEntry = NULL;	
	m_pszPrimaryFile = NULL;
	m_pszRegPath = NULL;
    m_pszPrimaryRegPath = NULL;
    m_pszICSDataPath = NULL;
    m_fReadICSData = FALSE;
    m_fWriteICSData = FALSE;

    SetFile(pszFile);
	SetSection(pszSection);
	SetEntry(pszEntry);
	SetRegPath(pszRegPath);
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA::~CIniA
//
// Synopsis:  CIniA destructor, frees dynamically allocated strings held onto
//            by the CIniA object.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
CIniA::~CIniA()
{
	CmFree(m_pszFile);
	CmFree(m_pszSection);
	CmFree(m_pszEntry);
	CmFree(m_pszPrimaryFile);
	CmFree(m_pszRegPath);
    CmFree(m_pszPrimaryRegPath);
    CmFree(m_pszICSDataPath);
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA::Clear
//
// Synopsis:  Clears all of the member variables of the CIniA class.  Used
//            so that a single CIniA object can be re-used without having to
//            destruct the old object and construct a new one.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
void CIniA::Clear()
{
	SetHInst(NULL);
	SetFile(NULL);
	SetSection(NULL);
	SetEntry(NULL);
	SetPrimaryFile(NULL);
	SetRegPath(NULL);
    SetPrimaryRegPath(NULL);
    SetICSDataPath(NULL);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetSection
//
// Synopsis:  Sets the internal section suffix using the CIniA_Set 
//            helper function.
//
// Arguments: LPCSTR pszSection - section suffix to remember
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetSection(LPCSTR pszSection)
{
	CIniA_Set(&m_pszSection, pszSection);
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetEntry
//
// Synopsis:  Sets the internal entry suffix using the CIniA_Set 
//            helper function.
//
// Arguments: LPCSTR pszSection - entry suffix to remember
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetEntry(LPCSTR pszEntry)
{
	CIniA_Set(&m_pszEntry, pszEntry);
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetEntryFromIdx
//
// Synopsis:  Sets the internal entry suffix just as SetEntry does.  However,
//            the input parameter is a DWORD value that must be converted to
//            a string before it is stored as the index
//
// Arguments: DWORD dwEntry - index number to append to entries
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetEntryFromIdx(DWORD dwEntry)
{
	CHAR szEntry[sizeof(dwEntry)*6+1];

	wsprintfA(szEntry, "%u", dwEntry);
	SetEntry(szEntry);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::LoadSection
//
// Synopsis:  This function concatenates the given section parameter and the
//            section suffix and returns the result via the return value.  Note
//            that the memory must be freed by the calller.
//
// Arguments: LPCSTR pszSection - base section to concatenate the suffix to
//
// Returns:   LPSTR - a newly allocated string containing the pszSection value
//                    with the section suffix appended
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPSTR CIniA::LoadSection(LPCSTR pszSection) const
{
	return (CIniA_LoadCat(pszSection, m_pszSection));
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::LoadEntry
//
// Synopsis:  This function concatenates the given entry parameter and the
//            entry suffix and returns the result via the return value.  Note
//            that the memory must be freed by the calller.
//
// Arguments: LPCSTR pszEntry - base entry to concatenate the suffix to
//
// Returns:   LPSTR - a newly allocated string containing the pszEntry value
//                    with the entry suffix appended
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPSTR CIniA::LoadEntry(LPCSTR pszEntry) const
{
	return (CIniA_LoadCat(pszEntry, m_pszEntry));
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::GPPS
//
// Synopsis:  CIni's version of GetPrivateProfileString.  Duplicates the Win32
//            API functionality except that it will append the Section and Entry
//            suffixes (if any) before calling the Win32 API.  The function all
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: LPCSTR pszSection - Ini section to look for the data in
//            LPCSTR pszEntry - Ini key name that contains the requested data
//            LPCSTR pszDefault - default value to return if the key 
//                                cannot be found
//
// Returns:   LPSTR - the requested string value
//
// History:   quintinb Created Header    01/05/2000
//			  t-urama	modified		 07/15/2000
//
//+----------------------------------------------------------------------------
LPSTR CIniA::GPPS(LPCSTR pszSection, LPCSTR pszEntry, LPCSTR pszDefault) const
{
    //
    // Skip input pointer check since pszSection could be NULL to get all of 
    // the Section Names in the file, pszEntry could be NULL to get all of the
    // key names in a section, and pszDefault is NULL by default.
    // GetPrivateProfileString cannot take a NULL default but this is taken care of
    // by CIniA_GPPS.
    //

    LPSTR pszSectionTmp = LoadSection(pszSection);
    LPSTR pszEntryTmp = LoadEntry(pszEntry);
	LPSTR pszBuffer = NULL;

    if (m_fReadICSData)
    {
        //
        // We need first read the data from ICSData reg key, if it's not present then try to 
        // get it from the file and then see if we have a primary file and read it from there.
        //
        pszBuffer = (LPTSTR)CIniA_GetEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(CHAR))); 
        if (NULL == pszBuffer)
        {
            LPSTR pszICSTmp = NULL;
            pszBuffer = CIniA_GPPS(pszSectionTmp, pszEntryTmp, pszDefault, GetFile());

            if (m_pszPrimaryFile)
            {
                pszICSTmp = pszBuffer;
                pszBuffer = CIniA_GPPS(pszSectionTmp, pszEntryTmp, pszICSTmp, GetPrimaryFile());
            }

            if (NULL == pszBuffer)
            {
                if (pszDefault)
                {
                    pszBuffer = CmStrCpyAllocA(pszDefault);
                }
                else
                {
                    //
                    // We should not return a null from this wrapper, but an empty string instead
                    //
                    pszBuffer = CmStrCpyAllocA(TEXT(""));
                }
            }

            CmFree(pszICSTmp);
        }
    }
    else
    {
        //
        // If there is a reg path present. Registry access for m_pszFile
        // unless we want to read it from the file
        //
        if (m_pszRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                pszBuffer = (LPTSTR) CIniA_GetEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(CHAR))); 
            }
        }

        if (NULL == pszBuffer)
        {
            // This could mean that there is no reg path, or that the reg access failed. Either way, we 
            // try to get the entry from pszFile
            //
            // Skip input pointer check since pszSection could be NULL to get all of 
            // the Section Names in the file, pszEntry could be NULL to get all of the
            // key names in a section, and pszDefault is NULL by default.
            // GetPrivateProfileString cannot take a NULL default but this is taken care of
            // by CIniW_GPPS.
            //
            pszBuffer = CIniA_GPPS(pszSectionTmp, pszEntryTmp, pszDefault, GetFile());
        }

        MYDBGASSERT(pszBuffer);

        // Now we try to get the entry from the primary file
        //
        LPTSTR pszTmp = NULL;

        if (m_pszPrimaryRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                pszTmp = pszBuffer;
                pszBuffer = (LPTSTR) CIniA_GetEntryFromReg(HKEY_CURRENT_USER, m_pszPrimaryRegPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(CHAR)));
            }
        }

        if (NULL == pszBuffer)
        {
    
            // Skip input pointer check since pszSection could be NULL to get all of 
            // the Section Names in the file, pszEntry could be NULL to get all of the
            // key names in a section, and pszDefault is NULL by default.
            // GetPrivateProfileString cannot take a NULL default but this is taken care of
            // by CIniW_GPPS.
            //
            pszBuffer = CIniA_GPPS(pszSectionTmp, pszEntryTmp, pszTmp, GetPrimaryFile());
        
        }

        CmFree(pszTmp);

    }

    CmFree(pszEntryTmp);
    CmFree(pszSectionTmp);
    
    MYDBGASSERT(pszBuffer);
    
    return (pszBuffer);
}
			


//+----------------------------------------------------------------------------
//
// Function:  CIniA::GPPI
//
// Synopsis:  CIni's version of GetPrivateProfileInt.  Duplicates the Win32
//            API functionality except that it will append the Section and Entry
//            suffixes (if any) before calling the Win32 API.  The function all
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: LPCSTR pszSection - Ini section to look for the data in
//            LPCSTR pszEntry - Ini key name that contains the requested data
//            DWORD dwDefault - default value to return if the key 
//                              cannot be found
//
// Returns:   DWORD - the requested numerical value
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//
//+----------------------------------------------------------------------------
DWORD CIniA::GPPI(LPCSTR pszSection, LPCSTR pszEntry, DWORD dwDefault) const
{
    //
    //  GetPrivateProfileInt doesn't take NULL's for the section and entry
    //  parameters as GetPrivateProfileString will.  Thus check the values returned
    //  from LoadSection and LoadEntry, which will return NULL if the input parameter
    //  is either NULL or empty.  Since we don't really know what to do in this
    //  situation lets just assert and return the default value.
    //
    DWORD   dwRet = dwDefault;
    LPSTR pszSectionTmp = LoadSection(pszSection);
    LPSTR pszEntryTmp = LoadEntry(pszEntry);
    LPCSTR pszFileTmp = GetFile();
    DWORD* pdwData = NULL;

    if (m_fReadICSData)
    {
        //
        // We need first read the data from ICSData reg key, if it's not present then try to 
        // get it from the file and then see if we have a primary file and read it from there.
        //
        pdwData = (DWORD*)CIniA_GetEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
        
        //
        // If we got something, assign it to the return value, otherwise try reading from the files
        // and using the default.
        //
        if (NULL == pdwData)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszFile
            //
            MYDBGASSERT(pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp);

            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
            {
                dwRet = GetPrivateProfileIntA(pszSectionTmp, pszEntryTmp, dwDefault, pszFileTmp);
            }

            if (m_pszPrimaryFile)
            {
                //
                // The registry access failed, or there is no reg. path. try to get the 
                // entry from pszPrimaryFile
                //
        
                pszFileTmp = GetPrimaryFile();
                if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
                {
                    dwRet = GetPrivateProfileIntA(pszSectionTmp, pszEntryTmp, dwRet, pszFileTmp);
                }
            }
        }
        else
        {
            dwRet = *pdwData;
        }
    }
    else
    {
        //
        // Follow the normal rules
        // 
        if (m_pszRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                pdwData = (DWORD*)CIniA_GetEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
            }
        }

        if (NULL == pdwData)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszFile
            //
            MYDBGASSERT(pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp);

            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
		    {
			    dwRet = GetPrivateProfileIntA(pszSectionTmp, pszEntryTmp, dwDefault, pszFileTmp);
		    }
        }
        else
	    {
		    dwRet = *pdwData;
	    }

        if (m_pszPrimaryRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
               CmFree(pdwData);
          
               pdwData = (DWORD*)CIniA_GetEntryFromReg(HKEY_CURRENT_USER, m_pszPrimaryRegPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
               if (pdwData)
                {
                    dwRet = *pdwData;
                }
            }
        
        }

        if (NULL == pdwData && m_pszPrimaryFile)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszPrimaryFile
            //

            pszFileTmp = GetPrimaryFile();
            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
            {
	            dwRet = GetPrivateProfileIntA(pszSectionTmp, pszEntryTmp, dwRet, pszFileTmp);
            }
        }
    }

    CmFree(pdwData);
	CmFree(pszEntryTmp);
	CmFree(pszSectionTmp);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::GPPB
//
// Synopsis:  CIni's version of GetPrivateProfileBool (which doesn't exactly
//            exist). Basically this function is the same as GPPI except that
//            the return value is cast to a BOOL value (1 or 0).
//
// Arguments: LPCSTR pszSection - Ini section to look for the data in
//            LPCSTR pszEntry - Ini key name that contains the requested data
//            DWORD dwDefault - default value to return if the key 
//                              cannot be found
//
// Returns:   DWORD - the requested BOOL value
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
BOOL CIniA::GPPB(LPCSTR pszSection, LPCSTR pszEntry, BOOL bDefault) const
{
    return (GPPI(pszSection, pszEntry, (DWORD)bDefault) != 0);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::WPPI
//
// Synopsis:  CIni's version of WritePrivateProfileInt (which doesn't exist as
//            a Win32 function).  Basically takes the inputted DWORD and prints
//            it into a string and then calls WPPS.
//
// Arguments: LPCSTR pszSection - Ini section to write the data to
//            LPCSTR pszEntry - Ini key name to store the data at
//            DWORD dwBuffer - Numeric value to write
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------

void CIniA::WPPI(LPCSTR pszSection, LPCSTR pszEntry, DWORD dwBuffer)
{
    // Technically pszEntry could be NULL, which would erase all of the keys in
    // the section pointed to by pszSection.  However, this doesn't seem to be
    // in the spirit of this wrapper so we will check both string pointers to make
    // sure they are valid.
	BOOL bRes = FALSE;
    
	//
    // Check is we are allowed to save info
    //
    if ((NULL != pszSection) && ('\0' != pszSection[0]) &&
        (NULL != pszEntry) && ('\0' != pszEntry[0]))
    {
        LPSTR pszEntryTmp = LoadEntry(pszEntry);
		
        if(m_pszRegPath)
		{
			MYDBGASSERT(pszEntryTmp || (NULL == pszEntry) || ('\0' == pszEntry[0]));

			if (NULL != pszEntryTmp && *pszEntryTmp)
			{
    			bRes = CIniA_WriteEntryToReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, (BYTE *) &dwBuffer, REG_DWORD, sizeof(DWORD));
			}
		}
		
		if(!bRes)
		{
		    // This loop is only entered if we are trying to write to the cmp and the registry 
			// write failed, or we are writing to the cms, in which case we will not even 
			// try to write to the reg.

            LPSTR pszSectionTmp = LoadSection(pszSection);
	        LPCSTR pszFileTmp = GetFile();
			        
	        MYDBGASSERT(pszFileTmp && *pszFileTmp);
	        MYDBGASSERT(pszSectionTmp && *pszSectionTmp);

            CHAR szBuffer[sizeof(dwBuffer)*6+1] = {0};
    	
			wsprintfA(szBuffer, "%u", dwBuffer);
					
			if (pszFileTmp && *pszFileTmp && pszSectionTmp && *pszSectionTmp && pszEntryTmp && *pszEntryTmp)
			{
    			bRes = WritePrivateProfileStringA(pszSectionTmp, pszEntryTmp, szBuffer, pszFileTmp);
			}
            if (!bRes)
            {
                DWORD dwError = GetLastError();
                CMTRACE3A("CIniA::WPPI() WritePrivateProfileString[*pszSection=%s,*pszEntry=%s,*pszBuffer=%s", pszSectionTmp, MYDBGSTRA(pszEntryTmp), MYDBGSTRA(szBuffer));
                CMTRACE2A("*pszFile=%s] failed, GLE=%u", pszFileTmp, dwError);
            }
            CmFree(pszSectionTmp);
               	
		}

        if (m_fWriteICSData)
        {
            if (NULL != pszEntryTmp && *pszEntryTmp)
			{
    			bRes = CIniA_WriteEntryToReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, (BYTE *) &dwBuffer, REG_DWORD, sizeof(DWORD));
			}
        }

        CmFree(pszEntryTmp);
    }
	else
    {
        CMASSERTMSG(FALSE, "Invalid input paramaters to CIniA::WPPI");
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::WPPB
//
// Synopsis:  CIni's version of WritePrivateProfileBool (which doesn't exist as
//            a Win32 function).  Basically takes the inputted BOOL and prints
//            either 1 or 0 into a string and then calls WPPI.
//
// Arguments: LPCSTR pszSection - Ini section to write the data to
//            LPCSTR pszEntry - Ini key name to store the data at
//            DWORD dwBuffer - Numeric value to write
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::WPPB(LPCSTR pszSection, LPCSTR pszEntry, BOOL bBuffer)
{
	WPPI(pszSection, pszEntry, bBuffer ? 1 : 0);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::WPPS
//
// Synopsis:  CIni's version of WritePrivateProfileString
//
// Arguments: LPCSTR pszSection - Ini section to write the data to
//            LPCSTR pszEntry - Ini key name to store the data at
//            LPCSTR pszBuffer - data buffer to write to the ini file
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
void CIniA::WPPS(LPCSTR pszSection, LPCSTR pszEntry, LPCSTR pszBuffer) 
{
    
    LPSTR pszEntryTmp = LoadEntry(pszEntry);
    LPSTR pszSectionTmp = LoadSection(pszSection);
	LPCSTR pszFileTmp = GetFile();
			
	MYDBGASSERT(pszFileTmp && *pszFileTmp);
	MYDBGASSERT(pszSectionTmp && *pszSectionTmp);
	MYDBGASSERT(pszEntryTmp || (NULL == pszEntry) || (L'\0' == pszEntry[0]));

    // Both pszEntry and pszBuffer could be NULL or Empty.  However, pszSection and
    // the file path must not be NULL or empty.  We also don't want to have a non-NULL
    // or non-Empty value for pszEntry and then get a NULL value back from LoadEntry
    // (indicating that LoadEntry had text to duplicate but failed for some reason).
    // Writing with a NULL value accidently will delete the key value we were trying to set.
    // Make sure to assert and prevent data loss in this case.
    //
   
	//
    // Check is we are allowed to save info
    //
    if(pszEntryTmp || (NULL == pszEntry) || (L'\0' == pszEntry[0]))
    {	
		BOOL bRes = FALSE;
		
		// First try to write to registry if pszRegPath exists

		if(m_pszRegPath)
		{
            if (NULL == pszBuffer)
            {
                CIniA_DeleteEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp);
                bRes = TRUE; // never erase from the cmp or cms file if there is a regpath.
            }
            else
            {
			    DWORD dwSize = (lstrlenA(pszBuffer) + 1) * sizeof(CHAR);            
        
			    bRes = CIniA_WriteEntryToReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, (BYTE *) pszBuffer, REG_SZ, dwSize);
            }
		}

		if(!bRes)
		{
			// This loop is only entered if we are trying to write to the cmp and the registry 
			// write failed, or we are writing to the cms, in which case we will not even 
			// try to write to the reg.
			
			if (pszFileTmp && *pszFileTmp && pszSectionTmp && *pszSectionTmp )
			{
    			bRes = WritePrivateProfileStringA(pszSectionTmp, pszEntryTmp, pszBuffer, pszFileTmp);
			}
		}
        if (!bRes)
        {
            DWORD dwError = GetLastError();
            CMTRACE3A("CIniA::WPPS() WritePrivateProfileStringA[*pszSection=%s,*pszEntry=%s,*pszBuffer=%s", pszSectionTmp, MYDBGSTRA(pszEntryTmp), MYDBGSTRA(pszBuffer));
        	CMTRACE2A("*pszFile=%s] failed, GLE=%u", GetFile(), dwError);
        }

        if (m_fWriteICSData)
        {
            //
            // The return values are ignored and are here to prevent prefix errors
            //
            if (NULL == pszBuffer)
            {
                bRes = CIniA_DeleteEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp);
            }
            else
            {
			    DWORD dwSize = (lstrlenA(pszBuffer) + 1) * sizeof(CHAR);            
        
			    bRes = CIniA_WriteEntryToReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, (BYTE *) pszBuffer, REG_SZ, dwSize);
            }
        }
    }

    CmFree(pszEntryTmp);
  	CmFree(pszSectionTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::GetSection
//
// Synopsis:  Accessor function for the Section suffix member variable.  Will
//            return the empty string if m_pszSection is NULL.
//
// Arguments: None
//
// Returns:   LPCSTR - Value of the section suffix member variable or "" 
//                     if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCSTR CIniA::GetSection() const
{
    return (m_pszSection ? m_pszSection : "");
}


//+----------------------------------------------------------------------------
//
// Function:  CIniA::GetPrimaryFile
//
// Synopsis:  Accessor function for the Primary File member variable.  Will
//            return the empty string if m_pszPrimaryFile is NULL.
//
// Arguments: None
//
// Returns:   LPCSTR - Value of the primary file member variable or "" 
//                     if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCSTR CIniA::GetPrimaryFile() const
{
    return (m_pszPrimaryFile ? m_pszPrimaryFile : "");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::GetHInst
//
// Synopsis:  Accessor function for the m_hInst member variable.
//
// Arguments: None
//
// Returns:   HINSTANCE - Value of the m_hInst
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
HINSTANCE CIniA::GetHInst() const
{
    return (m_hInst);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetFile
//
// Synopsis:  Function to set the m_pszFile member variable.  Uses CIni_SetFile.
//            Note that if the input parameter is NULL or the empty string then
//            m_pszFile will be set to NULL.
//
// Arguments: LPCSTR pszFile - full path to set the m_pszFile member var to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetFile(LPCSTR pszFile) 
{
    CIni_SetFile(&m_pszFile, pszFile);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetPrimaryFile
//
// Synopsis:  Function to set the m_pszPrimaryFile member variable.  Uses CIni_SetFile.
//            Note that if the input parameter is NULL or the empty string then
//            m_pszPrimaryFile will be set to NULL.
//
// Arguments: LPCSTR pszFile - full path to set the m_pszPrimaryFile member var to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetPrimaryFile(LPCSTR pszFile) 
{
    CIni_SetFile(&m_pszPrimaryFile, pszFile);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::GetFile
//
// Synopsis:  Accessor function for the File member variable.  Will
//            return the empty string if m_pszFile is NULL.
//
// Arguments: None
//
// Returns:   LPCSTR - the contents of m_pszFile or "" if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCSTR CIniA::GetFile() const
{
    return (m_pszFile ? m_pszFile : "");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetHInst
//
// Synopsis:  Function to set the m_hInst member variable.
//
// Arguments: HINSTANCE hInst - instance handle to set m_hInst to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniA::SetHInst(HINSTANCE hInst) 
{
    m_hInst = hInst;
}

//
//	Loading sections by string resource isn't used anymore
//
#if 0
LPSTR CIniA::LoadSection(UINT nSection) const
{
	LPSTR pszTmp = CmLoadStringA(GetHInst(),nSection);
	CmStrCatAllocA(&pszTmp,GetSection());
	return (pszTmp);
}
#endif

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetRegPath
//
// Synopsis:  Sets the registry path for registry access
//
// Arguments: LPCSTR pszRegPath - entry suffix to remember
//
// Returns:   Nothing
//
// History:   t-urama Created Header    07/13/2000
//
//+----------------------------------------------------------------------------

void CIniA::SetRegPath(LPCSTR pszRegPath)
{
	CIniA_Set(&m_pszRegPath, pszRegPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetPrimaryRegPath
//
// Synopsis:  Sets the primary registry path for registry access
//
// Arguments: LPCSTR pszPrimaryRegPath - Primary reg path
//
// Returns:   Nothing
//
// History:   t-urama Created Header    07/13/2000
//
//+----------------------------------------------------------------------------

void CIniA::SetPrimaryRegPath(LPCSTR pszPrimaryRegPath)
{
	CIniA_Set(&m_pszPrimaryRegPath, pszPrimaryRegPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetICSDataPath
//
// Synopsis:  Sets the internal registry key to store data for ICS.
//            Need to make sure the string isn't empty since we don't want
//            to write in HKLM
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniA::SetICSDataPath(LPCSTR pszICSPath)
{
    CIniA_Set(&m_pszICSDataPath, pszICSPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetReadICSData
//
// Synopsis:  Sets the read flag, to read data from the ICS registry key.
//
// Arguments: fValue
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniA::SetReadICSData(BOOL fValue)
{
    m_fReadICSData = fValue;
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::SetWriteICSData
//
// Synopsis:  Sets the write flag, to write data to the ICS registry key.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniA::SetWriteICSData(BOOL fValue)
{
    m_fWriteICSData = fValue;
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CiniA_GetRegPath
//
// Synopsis:  Function to get the value ofm_pszRegPath
//
// Arguments: none
//
// Returns:   LPCSTR - Value of m_pszRegPath
//
// History:   t-urama Created Header    07/15/2000
//
//+----------------------------------------------------------------------------
LPCSTR CIniA::GetRegPath() const
{
	return (m_pszRegPath ? m_pszRegPath : "");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CiniA_GetPrimaryRegPath
//
// Synopsis:  Function to get the value ofm_pszPrimaryRegPath
//
// Arguments: none
//
// Returns:   LPCSTR - Value of m_pszPrimaryRegPath
//
// History:   t-urama Created     07/15/2000
//
//+----------------------------------------------------------------------------
LPCSTR CIniA::GetPrimaryRegPath() const
{
	return (m_pszPrimaryRegPath ? m_pszPrimaryRegPath : "");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CIniA_DeleteEntryFromReg
//
// Synopsis:  Function to delete an entry from the registry. 
//
// Arguments: HKEY - hkey
//            LPCSTR pszRegPathTmp - Reg path
//            LPCSTR pszEntry - Registry value name to be deleted
//
// Returns:   BOOL - Success or failure
//
// History:   t-urama Created     07/15/2000
//            04/03/2001    tomkel  Added reg key string to parameters
//
//+----------------------------------------------------------------------------
BOOL CIniA::CIniA_DeleteEntryFromReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry) const
{
    
    MYDBGASSERT(pszEntry);

    if (NULL == pszEntry || !*pszEntry || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return FALSE;
    }
       
    //
    // Everything is ok. We have a reg path and a entry name. 
    //
    
    HKEY    hKeyCm;

    BOOL dwRes = RegOpenKeyExA(hKey,
                               pszRegPathTmp,
                               0,
                               KEY_SET_VALUE,
                               &hKeyCm);

    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegDeleteValueA(hKeyCm, pszEntry);
    }

    return (ERROR_SUCCESS == dwRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CiniA_GetEntryFromReg
//
// Synopsis:  Function to get the value from the registry. The function 
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: HKEY hKey - reg hkey
//            pszRegPathTmp - reg key name
//            LPCSTR pszEntry - Registry value name that contains the requested data
//            DWORD dwType - Type of value
//			  DWORD dwSize - Size of value
//            
//
// Returns:   LPBYTE - the requested value
//
// History:   07/15/2000    t-urama Created Header    
//            04/03/2001    tomkel  Changed to pass in registry key string
//
//+----------------------------------------------------------------------------
LPBYTE CIniA::CIniA_GetEntryFromReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry, DWORD dwType, DWORD dwSize) const
    
{    
    MYDBGASSERT(pszEntry);

    if (NULL == pszEntry || !*pszEntry || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return NULL;
    }

    //
    // Everything is ok. We have a reg path and a entry name. 
    //

    DWORD dwTypeTmp = dwType;
    DWORD dwSizeTmp = dwSize;
    HKEY hKeyCm;
    LPBYTE lpData = NULL;

    //
    // Open the sub key under HKCU
    //
    
    DWORD dwRes = RegOpenKeyExA(hKey,
                                pszRegPathTmp,
                                0,
                                KEY_QUERY_VALUE,
                                &hKeyCm);

    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {
        do
        {
            //
            //	Allocate a buffer
            //
            CmFree(lpData);
            lpData = (BYTE *) CmMalloc(dwSizeTmp);

            if (NULL == lpData)
            {
                RegCloseKey(hKeyCm);
                return FALSE;
            }

            dwRes = RegQueryValueExA(hKeyCm, 
                                     pszEntry,
                                     NULL,
                                     &dwTypeTmp,
                                     lpData, 
                                     &dwSizeTmp);        
       			
        } while (ERROR_MORE_DATA == dwRes);
          
        RegCloseKey(hKeyCm);
    }

    if (ERROR_SUCCESS == dwRes && dwTypeTmp == dwType)
    {
       return lpData;     
    }
	else
	{
		CmFree(lpData);
		return NULL;
	}
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::CiniA_WriteEntryToReg
//
// Synopsis:  Function to write and entry to the registry. 
//
// Arguments: HKEY hKey
//            LPCSTR pszRegPathTmp - name of the reg key
//            LPCSTR pszEntry - Registry value name to which data is to be written
//			  CONST BYTE *lpData - Data to be written
//            DWORD dwType - The type of value to be entered
//			  DWORD dwSize - The size of the value entered
//
// Returns:   BOOL - Success or failure
//
// History:   t-urama Created Header    07/15/2000
//
//+----------------------------------------------------------------------------
BOOL CIniA::CIniA_WriteEntryToReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry, CONST BYTE *lpData, DWORD dwType, DWORD dwSize) const
{
   MYDBGASSERT(pszEntry && *pszEntry);
   MYDBGASSERT(lpData);
   MYDBGASSERT(pszRegPathTmp && *pszRegPathTmp);

    

   if (NULL == pszEntry || !*pszEntry || NULL == lpData || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return FALSE;
    }

   HKEY    hKeyCm;
   DWORD   dwDisposition;
   DWORD   dwRes = 1;

   dwRes = RegCreateKeyExA(hKey,
                           pszRegPathTmp,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_SET_VALUE,
                           NULL,
                           &hKeyCm,
                           &dwDisposition);


	//
    // If we opened the key successfully, write the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegSetValueExA(hKeyCm, 
                               pszEntry, 
                               0, 
                               dwType,
                               lpData, 
                               dwSize);             

        
        RegCloseKey(hKeyCm);
    }

#ifdef DEBUG
        if (ERROR_SUCCESS != dwRes)
        {
            CMTRACE1(TEXT("CIniA_WriteEntryToReg() - %s failed"), (LPTSTR)pszEntry);
        }
#endif

    return (ERROR_SUCCESS == dwRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\cmlogstr.h ===
//+----------------------------------------------------------------------------
//
// File:    CmLogStr.h
//
// Module:  CMLOG.LIB
//
// Synopsis: Resource ID definitions for Connection Manager Logging
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  24-May-2000 SumitC  Created
//
// Note:
//
//-----------------------------------------------------------------------------


#define IDS_LOGDESC_LOGENABLED                  15000
#define IDS_LOGDESC_LOGDISABLED                 15001
#define IDS_LOGDESC_PREINIT                     15002
#define IDS_LOGFMT_PREINIT                      15003
#define IDS_LOGDESC_PRECONNECT                  15004
#define IDS_LOGFMT_PRECONNECT                   15005
#define IDS_LOGDESC_PREDIAL                     15006
#define IDS_LOGFMT_PREDIAL                      15007
#define IDS_LOGDESC_PRETUNNEL                   15008
#define IDS_LOGFMT_PRETUNNEL                    15009
#define IDS_LOGDESC_CONNECT                     15010
#define IDS_LOGDESC_CUSTOMACTIONDLL             15011
#define IDS_LOGFMT_CUSTOMACTIONDLL              15012
#define IDS_LOGDESC_CUSTOMACTIONEXE             15013
#define IDS_LOGFMT_CUSTOMACTIONEXE              15014
#define IDS_LOGDESC_DISCONNECT                  15015
#define IDS_LOGFMT_DISCONNECT                   15016
#define IDS_LOGDESC_RECONNECT                   15017
#define IDS_LOGDESC_RETRYAUTH                   15018
#define IDS_LOGDESC_CALLBACKNUMBER              15019
#define IDS_LOGFMT_CALLBACKNUMBER               15020
#define IDS_LOGDESC_PWDEXPIRED                  15021
#define IDS_LOGFMT_PWDEXPIRED                   15022
#define IDS_LOGDESC_PWDRESET                    15023
#define IDS_LOGFMT_PWDRESET                     15024
#define IDS_LOGDESC_CUSTOMBUTTON                15025
#define IDS_LOGDESC_ONCANCEL                    15026
#define IDS_LOGDESC_ONERROR                     15027
#define IDS_LOGFMT_ONERROR                      15028
#define IDS_LOGDESC_CLEARLOG                    15029
#define IDS_LOGDESC_EXT_DISCONNECT              15030
#define IDS_LOGDESC_INT_DISCONNECT_MANUAL       15031
#define IDS_LOGDESC_INT_DISCONNECT_AUTO         15032
#define IDS_LOGDESC_EXT_DISCONNECT_LOST_CONN    15033
#define IDS_LOGDESC_CUSTOMACTION_NOT_ALLOWED    15034
#define IDS_LOGFMT_CUSTOMACTION_NOT_ALLOWED     15035
#define IDS_LOGDESC_CUSTOMACTION_WONT_RUN       15036
#define IDS_LOGFMT_CUSTOMACTION_WONT_RUN        15037
#define IDS_LOGDESC_PB_DOWNLOAD_SUCCESS         15038
#define IDS_LOGFMT_PB_DOWNLOAD_SUCCESS          15039
#define IDS_LOGDESC_PB_DOWNLOAD_FAILURE         15040
#define IDS_LOGFMT_PB_DOWNLOAD_FAILURE          15041
#define IDS_LOGDESC_PB_UPDATE_SUCCESSFUL        15042
#define IDS_LOGFMT_PB_UPDATE_SUCCESSFUL         15043
#define IDS_LOGDESC_PB_UPDATE_FAILED_PBS        15044
#define IDS_LOGFMT_PB_UPDATE_FAILED_PBS         15045
#define IDS_LOGDESC_PB_UPDATE_FAILED_CMPBK      15046
#define IDS_LOGFMT_PB_UPDATE_FAILED_CMPBK       15047
#define IDS_LOGDESC_PB_ABORTED                  15048

#define IDS_LOGFMT_BANNER                       16000
#define IDS_LOGSTR_ALLUSERS                     16001
#define IDS_LOGSTR_SINGLEUSER                   16002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\cmlog.cpp ===
//+----------------------------------------------------------------------------
//
// File:    cmlog.cpp
//
// Module:  CMLOG.LIB
//
// Synopsis: Connection Manager Logging File i/o class
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  25-May-2000 SumitC  Created
//
// Note:
//
//-----------------------------------------------------------------------------

#define CMLOG_IMPLEMENTATION
#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <psapi.h>
#include <tlhelp32.h>

#include "cmmaster.h"

#include "CmLogStr.h"
#include "cmlog.h"
#include "cmlogutil.h"

#include "getmodulever.cpp"

//
//  Constants
//
LPCTSTR c_szSep     = TEXT("\\");
LPCTSTR c_szDotLog  = TEXT(".log");
LPCTSTR c_szNewLine = TEXT("\r\n");
LPCTSTR c_szEmpty   = TEXT("");
#define CHECKEMPTY(sz) ((sz) ? (sz) : c_szEmpty)

LPCTSTR c_szLineOfStars = TEXT("******************************************************************");
LPCTSTR c_szFieldSeparator = TEXT("\t");

//
// Byte order mark constant, written as the first two bytes to a Unicode file to mark it as such
//
const WCHAR c_wchBOM = BYTE_ORDER_MARK;

//
//  Globals
//
extern HINSTANCE g_hInst;

//
//  utility macros
//
#define INBETWEEN(x, a, b)      ( ( (x) >= (a) ) && ( (x) <= (b) ) )

//
//  local function declarations
//
LPTSTR GetLogDesc(_CMLOG_ITEM eItem);
LPTSTR GetLogFormat(_CMLOG_ITEM eItem, BOOL fUnicode);



typedef struct _CM_LOG_ITEM_DESC
{
    enum _CMLOG_ITEM    eLogItem;       // id of the log item (enum is in cmlog.h)
    UINT                idDesc;         // resource id of the description string
    UINT                idFormat;       // resource id of the format string used
}
CMLOGITEM;

//
//
//  Array with information about each log entry.  All logging is driven by this table.
//  See above for column details.
//
//
static CMLOGITEM s_aCmLogItems[] =
{
    { LOGGING_ENABLED_EVENT,    IDS_LOGDESC_LOGENABLED,                 0 },
    { LOGGING_DISABLED_EVENT,   IDS_LOGDESC_LOGDISABLED,                0 },
    { PREINIT_EVENT,            IDS_LOGDESC_PREINIT,                    IDS_LOGFMT_PREINIT, },
    { PRECONNECT_EVENT,         IDS_LOGDESC_PRECONNECT,                 IDS_LOGFMT_PRECONNECT },
    { PREDIAL_EVENT,            IDS_LOGDESC_PREDIAL,                    IDS_LOGFMT_PREDIAL },
    { PRETUNNEL_EVENT,          IDS_LOGDESC_PRETUNNEL,                  IDS_LOGFMT_PRETUNNEL },
    { CONNECT_EVENT,            IDS_LOGDESC_CONNECT,                    0 },
    { CUSTOMACTIONDLL,          IDS_LOGDESC_CUSTOMACTIONDLL,            IDS_LOGFMT_CUSTOMACTIONDLL },
    { CUSTOMACTIONEXE,          IDS_LOGDESC_CUSTOMACTIONEXE,            IDS_LOGFMT_CUSTOMACTIONEXE },
    { CUSTOMACTION_NOT_ALLOWED, IDS_LOGDESC_CUSTOMACTION_NOT_ALLOWED,   IDS_LOGFMT_CUSTOMACTION_NOT_ALLOWED},
    { CUSTOMACTION_WONT_RUN,    IDS_LOGDESC_CUSTOMACTION_WONT_RUN,      IDS_LOGFMT_CUSTOMACTION_WONT_RUN},
    { DISCONNECT_EVENT,         IDS_LOGDESC_DISCONNECT,                 IDS_LOGFMT_DISCONNECT },
    { RECONNECT_EVENT,          IDS_LOGDESC_RECONNECT,                  0 },
    { RETRY_AUTH_EVENT,         IDS_LOGDESC_RETRYAUTH,                  0 },
    { CALLBACK_NUMBER_EVENT,    IDS_LOGDESC_CALLBACKNUMBER,             IDS_LOGFMT_CALLBACKNUMBER },
    { PASSWORD_EXPIRED_EVENT,   IDS_LOGDESC_PWDEXPIRED,                 IDS_LOGFMT_PWDEXPIRED },
    { PASSWORD_RESET_EVENT,     IDS_LOGDESC_PWDRESET,                   IDS_LOGFMT_PWDRESET },
    { CUSTOM_BUTTON_EVENT,      IDS_LOGDESC_CUSTOMBUTTON,               0 },
    { ONCANCEL_EVENT,           IDS_LOGDESC_ONCANCEL,                   0 },
    { ONERROR_EVENT,            IDS_LOGDESC_ONERROR,                    IDS_LOGFMT_ONERROR },
    { CLEAR_LOG_EVENT,          IDS_LOGDESC_CLEARLOG,                   0 },
    { DISCONNECT_EXT,           IDS_LOGDESC_EXT_DISCONNECT,             0 },
    { DISCONNECT_INT_MANUAL,    IDS_LOGDESC_INT_DISCONNECT_MANUAL,      0 },
    { DISCONNECT_INT_AUTO,      IDS_LOGDESC_INT_DISCONNECT_AUTO,        0 },
    { DISCONNECT_EXT_LOST_CONN, IDS_LOGDESC_EXT_DISCONNECT_LOST_CONN,   0 },
    { PB_DOWNLOAD_SUCCESS,      IDS_LOGDESC_PB_DOWNLOAD_SUCCESS,        IDS_LOGFMT_PB_DOWNLOAD_SUCCESS },
    { PB_DOWNLOAD_FAILURE,      IDS_LOGDESC_PB_DOWNLOAD_FAILURE,        IDS_LOGFMT_PB_DOWNLOAD_FAILURE },
    { PB_UPDATE_SUCCESS,        IDS_LOGDESC_PB_UPDATE_SUCCESSFUL,       IDS_LOGFMT_PB_UPDATE_SUCCESSFUL  },
    { PB_UPDATE_FAILURE_PBS,    IDS_LOGDESC_PB_UPDATE_FAILED_PBS,       IDS_LOGFMT_PB_UPDATE_FAILED_PBS  },
    { PB_UPDATE_FAILURE_CMPBK,  IDS_LOGDESC_PB_UPDATE_FAILED_CMPBK,     IDS_LOGFMT_PB_UPDATE_FAILED_CMPBK },
    { PB_ABORTED,               IDS_LOGDESC_PB_ABORTED,                 0 },
    { USER_FORMATTED,           0,                                      0 }
};

int s_cCmLogItems = sizeof(s_aCmLogItems) / sizeof(CMLOGITEM);

#define VERIFY_CMLOG_ITEM_OK(x)  INBETWEEN(x, 1, s_cCmLogItems)


//
//  Usage Note:  Caller/User of logging must:
//                  p = new CmLogFile
//                  p->Init( instancehandle, fIsItAnAllUserProfile, "name of connectoid" )
//                  p->SetParams( ... the params ... )
//                  if (p->m_fEnabled)
//                      p->Start
//                  else
//                      p->Stop
//


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::CmLogFile
//
// Desc:    constructor
//
// Args:    none
//
// Return:  n/a
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
CmLogFile::CmLogFile()
{
    m_fInitialized = FALSE;
    
    m_hfile = NULL;
    m_dwSize = 0;
    m_pszServiceName = NULL;
    m_szModule[0] = TEXT('\0');
    m_pszLogFile = NULL;

    m_dwMaxSize = 0;
    m_fEnabled = FALSE;
    m_pszLogFileDir = NULL;
}
    

//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::~CmLogFile
//
// Desc:    destructor
//
// Args:    none
//
// Return:  n/a
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
CmLogFile::~CmLogFile()
{
    if (m_fInitialized)
    {
        DeInit();
    }
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Init
//
// Desc:    Initializes the CmLogFile object
//
// Args:    [hInst]          -- instance handle
//          [fAllUser]       -- is this an all user profile?
//          [pszServiceName] -- long service name
//
// Return:  HRESULT
//
// Notes:   There are both Ansi and Unicode versions for this function
//
// History: 18-Jul-2000   SumitC      Created
//          11-Apr-2001   SumitC      Added Ansi version
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::Init(HINSTANCE hInst, BOOL fAllUser, LPCSTR pszAnsiServiceName)
{
    LPWSTR pszServiceName = SzToWzWithAlloc(pszAnsiServiceName);

    HRESULT hr = pszServiceName ? Init(hInst, fAllUser, pszServiceName) : E_OUTOFMEMORY;

    CmFree(pszServiceName);
    return hr;
}

HRESULT
CmLogFile::Init(HINSTANCE hInst, BOOL fAllUser, LPCWSTR pszServiceName)
{
    HRESULT hr = S_OK;
    
    // if m_fInitialized is already true, assert and exit
    CMASSERTMSG(!m_fInitialized, TEXT("CmLogFile::Init - called twice"));
    if (TRUE == m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    CMASSERTMSG(pszServiceName && pszServiceName[0], TEXT("CmLogFile::Init - invalid servicename, investigate"));
    if ((NULL == pszServiceName) || (TEXT('\0') == pszServiceName[0]))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // set the args as member vars
    m_fAllUser = fAllUser;

    m_pszServiceName = CmStrCpyAlloc(pszServiceName);
    if (NULL == m_pszServiceName)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    //  store away the module name
    //
    if (FALSE == CmGetModuleBaseName(hInst, m_szModule))
    {
        lstrcpyU(m_szModule, TEXT("cm"));
    }
    
    // if all is well, set m_fInitialized to true
    m_fInitialized = TRUE;

Cleanup:
    CMTRACEHR(TEXT("CmLogFile::Init"), hr);
    return hr;
}



//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::SetParams
//
// Desc:    Read logging params from the CMS file
//
// Args:    [fEnabled]      -- is logging enabled?
//          [dwMaxFileSize] -- maximum file size, in KB.
//          [pszLogFileDir] -- put logging files in this dir.
//
// Return:  HRESULT
//
// Notes:   There are both Ansi and Unicode versions for this function
//
// History: 18-Jul-2000   SumitC      Created
//          11-Apr-2001   SumitC      Added Ansi version
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::SetParams(BOOL fEnabled, DWORD dwMaxFileSize, LPCSTR pszAnsiLogFileDir)
{
    LPWSTR pszLogFileDir = SzToWzWithAlloc(pszAnsiLogFileDir);

    HRESULT hr = pszLogFileDir ? SetParams(fEnabled, dwMaxFileSize, pszLogFileDir) : E_OUTOFMEMORY;

    CmFree(pszLogFileDir);
    return hr;
}

HRESULT
CmLogFile::SetParams(BOOL fEnabled, DWORD dwMaxFileSize, LPCWSTR pszLogFileDir)
{
    HRESULT hr = S_OK;
    LPTSTR  szUnexpanded = NULL;
    CIni *  pIni = NULL;

    //
    //  logging must be stopped for this function to be called
    //
    CMASSERTMSG(NULL == m_hfile, TEXT("CmLogFile::SetParams - m_hfile must be null when this is called"));
    if (m_hfile)
    {
        CMTRACE(TEXT("CmLogFile::SetParams was called during logging - must call Stop first"));
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    //  EnableLogging (BOOL)
    //
    m_fEnabled = fEnabled;
    
    //
    //  MaxFileSize (DWORD)
    //
    m_dwMaxSize = dwMaxFileSize;
    if (0 == m_dwMaxSize)
    {
        m_dwMaxSize = c_dwMaxFileSize;
    }
    m_dwMaxSize *= 1024;        // size was in KB, convert to bytes.

    //
    //  FileDirectory (string)
    //
    if (CmStrStr(pszLogFileDir, TEXT("%")))
    {
        //
        //  now expand the string we have
        //

        LPTSTR sz = NULL;
        DWORD  cch = ExpandEnvironmentStringsU(pszLogFileDir, NULL, 0);

        //
        //  if cch is zero, the pszLogFileDir string supplied is essentially bogus,
        //  i.e. it contains '%' indicating there's a macro to be expanded, but
        //  ExpandEnvironmentStrings can't expand it.  Here we let m_pszLogFileDir
        //  be set to NULL (the logging code will then use the Temp dir.
        //
        if (cch)
        {
            sz = (LPTSTR) CmMalloc(cch * sizeof(TCHAR));
            if (NULL == sz)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            if (cch != ExpandEnvironmentStringsU(pszLogFileDir, sz, cch))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CmFree(sz);
                goto Cleanup;
            }

            // success...
        }
        CmFree(m_pszLogFileDir);
        m_pszLogFileDir = sz;
    }
    else
    {
        CmFree(m_pszLogFileDir);
        if (pszLogFileDir)
        {
            m_pszLogFileDir = CmStrCpyAlloc(pszLogFileDir);
            if (NULL == m_pszLogFileDir)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        else
        {
            m_pszLogFileDir = NULL;
        }
    }

Cleanup:

    CMTRACEHR(TEXT("CmLogFile::SetParams"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Start
//
// Desc:    Start logging
//
// Args:    [fBanner] -- write a banner when starting
//
// Return:  HRESULT
//
// Notes:   
//
// History: 18-Jul-2000     SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::Start(BOOL fBanner)
{
    HRESULT hr = S_OK;
    
    // if already started, or already Initialized, or not enabled, exit
    CMASSERTMSG(!m_hfile, TEXT("CmLogFile::Start - already started!"));
    CMASSERTMSG(m_fInitialized, TEXT("CmLogFile::Start - must be initialized"));
    CMASSERTMSG(m_fEnabled, TEXT("CmLogFile::Start - must be enabled"));
    if (NULL != m_hfile || FALSE == m_fInitialized || FALSE == m_fEnabled)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // open log file
    hr = OpenFile();
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    // set m_dwSize while doing so.

    m_dwSize = GetFileSize(m_hfile, NULL);
    if (DWORD(-1) == m_dwSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        m_dwSize = 0;
        goto Cleanup;
    }

    //
    //  no matter what the size of the file, we only clear an 'over the size limit'
    //  file at the start of a call.  The fBanner param covers this.
    //
    if (fBanner)
    {
        // check file size, if over size Clear the file
        if (m_dwSize > m_dwMaxSize)
        {
            Clear();    // this writes a banner as well
        }
        else
        {
            // log banner
            Banner();
        }
    }

    CMASSERTMSG(m_hfile, TEXT("CmLogFile::Start - at end of fn, m_hfile must be valid"));

Cleanup:
    CMTRACEHR(TEXT("CmLogFile::Start"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Stop
//
// Desc:    Stops logging
//
// Args:    none
//
// Return:  HRESULT
//
// Notes:   
//
// History: 18-Jul-2000     SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::Stop()
{
    HRESULT hr = S_OK;

    //
    //  if initialized is false, assert and exit
    //
    CMASSERTMSG(m_fInitialized, TEXT("CmLogFile::Stop - must be initialized"));
    if (FALSE == m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    //  if already stopped, exit - nothing to do
    //
    if (NULL == m_hfile || FALSE == m_fEnabled)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    //  end log and close file
    //
    CloseFile();

    m_fEnabled = FALSE;

    CMASSERTMSG(NULL == m_hfile, TEXT("CmLogFile::Stop - at end of fn, m_hfile must be NULL"));
    
Cleanup:

    CMTRACEHR(TEXT("CmLogFile::Stop"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::DeInit
//
// Desc:    Uninitializes cm logging
//
// Args:    none
//
// Return:  HRESULT
//
// Notes:   
//
// History: 18-Jul-2000     SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::DeInit()
{
    HRESULT hr = S_OK;

    //
    //  if initialized is false, assert and exit
    //
    CMASSERTMSG(m_fInitialized, TEXT("CmLogFile::DeInit - must be initialized"));
    if (FALSE == m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    //  end log and close file
    //
    CloseFile();

    CmFree(m_pszServiceName);
    m_pszServiceName = NULL;
    CmFree(m_pszLogFileDir);
    m_pszLogFileDir = NULL;
    CmFree(m_pszLogFile);
    m_pszLogFile = NULL;

    m_fInitialized = FALSE;

Cleanup:

    CMTRACEHR(TEXT("CmLogFile::DeInit"), hr);
    return hr;

}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Log
//
// Desc:    Logs a connection manager or connection point services event
//
// Args:    [fUnicode] - are the args Unicode or ANSI?
//          [eLogItem] - word containing source, type & description of log item
//          [...]       - optional args (depends on log item)
//
// Return:  void
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
void
CmLogFile::Log(_CMLOG_ITEM eLogItem, ...)
{
    TCHAR   sz[2*MAX_PATH]; // REVIEW: Is this big enough?  Could we dynamically allocate it?
    LPTSTR  pszTmp = NULL;

    CMASSERTMSG(m_fInitialized, TEXT("CmLogFile::Log - must be initialized"));
    CMASSERTMSG((m_hfile && m_fEnabled) || (!m_hfile && !m_fEnabled), TEXT("CmLogFile::Log - m_hfile and m_fenabled must be in sync"));

    if (NULL == m_hfile || NULL == m_fEnabled)
    {
        // Start hasn't been called yet, or logging is disabled.  Nothing to do.
        goto Cleanup;
    }

    //
    //  Verify that the log item is a valid one
    //
    CMASSERTMSG(VERIFY_CMLOG_ITEM_OK(eLogItem), TEXT("CmLogFile::Log - eItem must represent valid Log item"));

#if DBG
    pszTmp = GetLogDesc(eLogItem);
    CMTRACE2(TEXT("Logging item = %d, desc = %s"), eLogItem, CHECKEMPTY(pszTmp));
    CmFree(pszTmp);
#endif

    if (VERIFY_CMLOG_ITEM_OK(eLogItem))
    {
        switch (eLogItem)
        {
        case USER_FORMATTED:
            va_list valArgs;

            va_start(valArgs, eLogItem);
            lstrcpyU(sz, va_arg(valArgs, LPTSTR));
            FormatWrite(eLogItem, sz);
            va_end(valArgs);
            break;

        default:
            //
            //  Format the arguments, and log the result
            //
            lstrcpyU(sz, c_szEmpty);

            pszTmp = GetLogFormat(eLogItem, TRUE);
            if (pszTmp)
            {
                va_list valArgs;

                va_start(valArgs, eLogItem);
                wvsprintfU(sz, pszTmp, valArgs);
                CmFree(pszTmp);
                FormatWrite(eLogItem, sz);
                va_end(valArgs);
            }
            else
            {
                FormatWrite(eLogItem, NULL);
            }
        }
    }
    else
    {
        CMTRACE2(TEXT("Illegal CmLog entry %d (0x%x)"), eLogItem, eLogItem);
        CMASSERTMSG(FALSE, TEXT("Illegal CmLog type - check trace, then edit code to fix"));
    }

Cleanup:
    ;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Write
//
// Desc:    Actually writes out the logged string (to debug console and logfile)
//
// Args:    [szLog] - string to log
//
// Return:  void
//
// Notes:   *ALL* writes to the log file must be done using this function
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::Write(LPTSTR szLog)
{
    HRESULT hr = S_OK;
    DWORD   cb = 0;
    DWORD   cbActuallyWritten = 0;
    LPSTR   szLogAnsi = NULL;

    CMASSERTMSG(m_hfile, TEXT("CmLogFile::Write - m_hfile must be valid, check code"));

    if (NULL == m_hfile)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

#if 0    
    //
    //  Dump string to debug console as well
    //
    CMTRACE(szLog);
#endif

    //
    //  Check for max size, open new log file if necessary
    //
    if (OS_NT)
    {
        cb = lstrlenW(szLog) * sizeof(TCHAR);
    }
    else
    {
        szLogAnsi = WzToSzWithAlloc(szLog);
        cb = lstrlenA(szLogAnsi) * sizeof(CHAR);
    }

#if 0
    // I'm leaving this here, but for now logging will not terminate a log file
    // during a log even if it goes past the max size.
    //
    if (m_dwSize + cb > m_dwMaxSize)
    {
        Clear();
    }
#endif

    //
    //  Write string to logfile
    //

    SetFilePointer(m_hfile, 0, NULL, FILE_END);
    if (OS_NT)
    {
        WriteFile(m_hfile, szLog, cb, &cbActuallyWritten, 0);
    }
    else
    {
        WriteFile(m_hfile, szLogAnsi, cb, &cbActuallyWritten, 0);
    }

    if (cb != cbActuallyWritten)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CMTRACE(TEXT("CMLOG: incomplete write to logfile"));
        goto Cleanup;
    }

    m_dwSize += cb;

Cleanup:

    CmFree(szLogAnsi);
    
    CMTRACEHR(TEXT("CmLogFile::Write"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::FormatWrite
//
// Desc:    Formats a log message with additional information and call Write fn
//
// Args:    [eItem]  - id of item being logged
//          [szArgs] - string containing all the args.
//
// Return:  void
//
// Notes:   
//
// History: 30-Apr-2000     SumitC      Created
//
//-----------------------------------------------------------------------------
void
CmLogFile::FormatWrite(_CMLOG_ITEM eItem, LPTSTR szArgs)
{
    TCHAR       szLog[2*MAX_PATH]; // REVIEW: Is this big enough?  Could we dynamically allocate it?
    TCHAR       sz[2*MAX_PATH]; // REVIEW: Is this big enough?  Could we dynamically allocate it?

    CMASSERTMSG(VERIFY_CMLOG_ITEM_OK(eItem), TEXT("CmLogFile::FormatWrite - eItem must represent valid Log item"));

    lstrcpyU(szLog, TEXT(""));
    
    //
    //  Thread and Module name
    //
    TCHAR szModuleWithParens[11];

    wsprintfU(szModuleWithParens, TEXT("[%s]"), m_szModule);
    
    wsprintfU(sz, TEXT("%-10s%s"), szModuleWithParens, c_szFieldSeparator);
    lstrcatU(szLog, sz);
    
    //
    //  Time
    //
    LPTSTR pszTime = NULL;

    CmGetDateTime(NULL, &pszTime);
    if (pszTime)
    {
        lstrcatU(szLog, pszTime);
        lstrcatU(szLog, c_szFieldSeparator);
        CmFree(pszTime);
    }

    //
    //  Description
    //
    if (USER_FORMATTED == eItem)
    {
        wsprintfU(sz, TEXT("%02d%s%s\r\n"), eItem, c_szFieldSeparator, szArgs);
    }
    else
    {
        LPTSTR pszDesc = GetLogDesc(eItem);
        if (szArgs)
        {
            wsprintfU(sz, TEXT("%02d%s%s%s%s\r\n"),
                      eItem, c_szFieldSeparator, CHECKEMPTY(pszDesc), c_szFieldSeparator, szArgs);
        }
        else
        {
            wsprintfU(sz, TEXT("%02d%s%s\r\n"),
                      eItem, c_szFieldSeparator, CHECKEMPTY(pszDesc));
        }
        CmFree(pszDesc);
    }

    lstrcatU(szLog, sz);

    //
    //  Write it out...
    //
    Write(szLog);
}



//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::OpenFile
//
// Desc:    Utility function to open the log file
//
// Args:    none
//
// Return:  HRESULT (S_OK for success, else error)
//
// Notes:   
//
// History: 22-Jul-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::OpenFile()
{
    HRESULT hr          = S_OK;
    HANDLE  hDir        = NULL;
    LPTSTR  pszUsers    = NULL;
    BOOL    fFileOpened = FALSE;

    CMASSERTMSG(m_pszServiceName, TEXT("CmLogFile::OpenFile - m_pszServiceName must be valid"));

    if (m_fAllUser)
    {
        // this is the more common case, so no suffix
        pszUsers = CmStrCpyAlloc(TEXT(""));
    }
    else
    {
        LPTSTR pszTmp = CmLoadString(g_hInst, IDS_LOGSTR_SINGLEUSER);
        if (pszTmp)
        {
            pszUsers = (LPTSTR) CmMalloc((lstrlenU(pszTmp) + 4) * sizeof(TCHAR));
            if (pszUsers)
            {
                wsprintfU(pszUsers, TEXT(" (%s)"), pszTmp);
            }
            CmFree(pszTmp);
        }
    }

    if (NULL == pszUsers)
    {
        hr = E_OUTOFMEMORY;
        CMTRACE1(TEXT("CmLogFile::OpenFile - couldn't get Users strings, hr=%x"), hr);
        goto Cleanup;
    }

    //
    //  To open a log file, we first try the location provided by the user.  If
    //  that fails for whatever reason, we try GetTempPath.  If that fails, no
    //  logging.
    //
    for (int i = 0; (i < 2) && (FALSE == fFileOpened); ++i)
    {
        TCHAR szBuf[2 * MAX_PATH];

        CMTRACE1(TEXT("CmLogFile::OpenFile, iteration %d."), i + 1);

        //
        //  get the directory name
        //
        switch (i)
        {
        case 0:
            if (m_pszLogFileDir)
            {
                lstrcpyU(szBuf, m_pszLogFileDir);
            }
            else
            {
                continue;
            }
            break;

        case 1:
            if (0 == GetTempPathU(2 * MAX_PATH, szBuf))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CMTRACE1(TEXT("GetTempPath failed with error 0x%x"), hr);
                goto Cleanup;
            }
            break;

        default:
            MYDBGASSERT(0);
            goto Cleanup;
            break;
        }

        CMTRACE1(TEXT("CmLogFile::OpenFile, directory name is %s"), szBuf);

        //
        //  see if the directory exists, if not try to create it
        //
        DWORD dwAttrib = GetFileAttributesU(szBuf);
        if (-1 == dwAttrib)
        {
            // directory does not exist
            CMTRACE(TEXT("CmLogFile::OpenFile - directory does not exist, trying to create it"));
            if (FALSE == CreateDirectoryU(szBuf, NULL))
            {
                DWORD dw = GetLastError();

                if (ERROR_ALREADY_EXISTS != dw)
                {
                    // real failure
                    hr = HRESULT_FROM_WIN32(dw);
                    CMTRACE2(TEXT("CmLogFile::OpenFile - Failed to create logging directory (%s), hr=%x"), szBuf, hr);
                    continue;
                }
                //
                //  On Win95/98, CreateDirectory fails with ERROR_ALREADY_EXISTS
                //  if the dir already exists. i.e. we have a dir, so keep going.
                //
                CMTRACE(TEXT("CmLogFile::OpenFile - directory created"));
            }
        }
        else
        {
            CMTRACE(TEXT("CmLogFile::OpenFile - directory already exists"));
            
            if (0 == (FILE_ATTRIBUTE_DIRECTORY & dwAttrib))
            {
                // there is a file of that name
                CMTRACE(TEXT("CmLogFile::OpenFile - there is a file of the same name as requested dir"));
                hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
                continue;
            }
            else if (FILE_ATTRIBUTE_READONLY & dwAttrib)
            {
                // the directory is readonly
                CMTRACE(TEXT("CmLogFile::OpenFile - the directory is readonly"));
                hr = E_ACCESSDENIED;
                continue;
            }
        }

        //
        //  the directory exists, try to create/open the logfile
        //
        if (*c_szSep != szBuf[lstrlenU(szBuf) - 1])
        {
            lstrcatU(szBuf, c_szSep);
        }
        lstrcatU(szBuf, m_pszServiceName);
        lstrcatU(szBuf, pszUsers);
        lstrcatU(szBuf, c_szDotLog);

        m_hfile = CreateFileU(szBuf,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

        //
        //  Since we asked for open existing, the file may just need to be created
        //
        if (INVALID_HANDLE_VALUE == m_hfile)
        {
            m_hfile = CreateFileU(szBuf,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  CREATE_NEW,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

            if ((INVALID_HANDLE_VALUE != m_hfile) && OS_NT)
            {
                //
                //  Set the Byte order mark on the file
                //
                DWORD cbActuallyWritten = 0;

                WriteFile(m_hfile, &c_wchBOM, sizeof(c_wchBOM), &cbActuallyWritten, 0);

                if (sizeof(c_wchBOM) != cbActuallyWritten)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CMTRACE(TEXT("CMLOG: Unable to set the Byte order mark while opening the file"));
                    goto Cleanup;
                }

                m_dwSize += sizeof(c_wchBOM);
            }
        }

        if (INVALID_HANDLE_VALUE == m_hfile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CMTRACE2(TEXT("CmLogFile::OpenFile - Failed to open log file in dir %s with error 0x%x"), szBuf, hr);
            continue;
        }

        //
        //  Success!!
        //
        CmFree(m_pszLogFile);
        m_pszLogFile = CmStrCpyAlloc(szBuf);
        if (NULL == m_pszLogFile)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = S_OK;
        fFileOpened = TRUE;
    }

#if DBG
    if (S_OK == hr)
    {
        CMASSERTMSG(m_hfile, TEXT("CmLogFile::OpenFile - at end.  m_hfile must be valid here"));
    }
#endif    

Cleanup:

    CmFree(pszUsers);

    CMTRACEHR(TEXT("CmLogFile::OpenFile"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::CloseFile
//
// Desc:    Closes the logging file
//
// Args:    none
//
// Return:  HRESULT
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CmLogFile::CloseFile()
{
    HRESULT hr = S_OK;
    
    if (m_hfile)
    {
        //
        //  Close the file
        //
        FlushFileBuffers(m_hfile);
        CloseHandle(m_hfile);
        m_hfile = NULL;
    }

    CMTRACEHR(TEXT("CmLogFile::CloseFile"), hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Clear
//
// Desc:    Clears (resets) the logging file
//
// Args:    [fWriteBannerAfterwards] -- after clearing, write the banner?
//
// Return:  void
//
// Notes:   
//
// History: 17-Jul-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
void
CmLogFile::Clear(BOOL fWriteBannerAfterwards)
{
    HRESULT hr              = S_OK;
    BOOL    fWasDisabled    = FALSE;

    if (NULL == m_hfile)
    {
        fWasDisabled = TRUE;    // if called when logging is disabled, we still clear the log file
        
        hr = OpenFile();
        if (S_OK != hr)
        {
            goto Cleanup;
        }
    }

    //
    //  make sure everything gets written out (ignore errors for this one)
    //
    FlushFileBuffers(m_hfile);

    //
    //  clear the file (set fileptr to the start, then set EOF to that).
    //
    if (INVALID_SET_FILE_POINTER == SetFilePointer(m_hfile, 0, NULL, FILE_BEGIN))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    
    if (FALSE == SetEndOfFile(m_hfile))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    m_dwSize = 0;

    CMTRACE(TEXT("CmLogFile::Clear - cleared log file"));

    //
    //  If this is NT and thus a Unicode file, we need to set the Byte order mark
    //
    if (OS_NT)
    {
        if ((INVALID_HANDLE_VALUE != m_hfile) && OS_NT)
        {
            //
            //  Set the Byte order mark on the file
            //
            DWORD cbActuallyWritten = 0;

            WriteFile(m_hfile, &c_wchBOM, sizeof(c_wchBOM), &cbActuallyWritten, 0);

            if (sizeof(c_wchBOM) != cbActuallyWritten)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CMTRACE(TEXT("CMLOG: Unable to set the Byte order mark while clearing the file"));
                goto Cleanup;
            }

            m_dwSize += sizeof(c_wchBOM);
        }    
    }

    if (fWriteBannerAfterwards)
    {
        Banner();
    }

    if (fWasDisabled)
    {
        CloseFile();
    }

Cleanup:
    CMTRACEHR(TEXT("CmLogFile::Clear"), hr);
    return;
}


//+----------------------------------------------------------------------------
//
// Func:    CmLogFile::Banner
//
// Desc:    Logs the banner heading for a Connection Manager log
//
// Args:    none
//
// Return:  void
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
void
CmLogFile::Banner()
{
    HRESULT     hr = S_OK;
    LPTSTR      psz = NULL;

    if (NULL == m_hfile)
    {
        return;
    }

    //
    //  System information, Process, Time
    //
    OSVERSIONINFO VersionInfo;
    LPTSTR        pszPlatform = TEXT("NT");

    ZeroMemory(&VersionInfo, sizeof(VersionInfo));
    VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
    GetVersionExU(&VersionInfo);

    if (VER_PLATFORM_WIN32_WINDOWS == VersionInfo.dwPlatformId)
    {
        pszPlatform = TEXT("9x");
    }
    else if (VER_PLATFORM_WIN32_NT == VersionInfo.dwPlatformId)
    {
        pszPlatform = TEXT("NT");
    }
    else
    {
        CMASSERTMSG(0, TEXT("CmLogFile::Banner - platform ID is not Windows or NT"));
    }

    //
    //  Connection Manager version number (using cmdial32.dll)
    //
    DWORD dwCMVer = 0;
    DWORD dwCMBuild = 0;
    DWORD dwLCID = 0;
    TCHAR szModulePath[MAX_PATH + 1];
    UINT  uRet = 0;

    uRet = GetSystemDirectoryU(szModulePath, MAX_PATH);
    if (0 == uRet)
    {
        CMTRACE1(TEXT("CmLogFile::Banner - GetSystemDirectoryU failed, GLE=%d"), GetLastError());
    }
    else
    {
        const LPTSTR c_pszCmdial32 = TEXT("\\cmdial32.dll");

        if ((uRet + lstrlenU(c_pszCmdial32) + 1) <= MAX_PATH)
        {
            lstrcatU(szModulePath, c_pszCmdial32);

            hr = GetModuleVersionAndLCID(szModulePath, &dwCMVer, &dwCMBuild, &dwLCID);
            if (FAILED(hr))
            {
                CMTRACE1(TEXT("CmLogFile::Banner - couldn't get CM version, hr=%x"), hr);
            }
        }
    }
   
    //
    //  Date & Time
    //

    LPTSTR pszDate = NULL;
    LPTSTR pszTime = NULL;
    
    CmGetDateTime(&pszDate, &pszTime);
    // strings can be NULL, but we handle that when using them (below)

    LPTSTR pszFmt = CmLoadString(g_hInst, IDS_LOGFMT_BANNER);
    LPTSTR pszUsers = CmLoadString(g_hInst,
                                   m_fAllUser ? IDS_LOGSTR_ALLUSERS : IDS_LOGSTR_SINGLEUSER);

    if (pszFmt && pszUsers)
    {
        UINT cch = lstrlenU(pszFmt) +
                   1 +
                   (3 * lstrlenU(c_szLineOfStars)) +     // occurs thrice total
                   lstrlenU(pszPlatform) +
                   (6 * 10) +               // how big can a DWORD get
                   lstrlenU(VersionInfo.szCSDVersion) +
                   lstrlenU(m_pszServiceName) +
                   lstrlenU(pszUsers) +
                   (pszDate ? lstrlenU(pszDate) : 0) +
                   (pszTime ? lstrlenU(pszTime) : 0) +
                   1;
        
        psz = (LPTSTR) CmMalloc(cch * sizeof(TCHAR));
        CMASSERTMSG(psz, TEXT("CmLogFile::Banner - couldn't log banner, malloc failed"));
        if (psz)
        {
            //
            //  Unicode logfiles are marked as such using a byte order mark, which
            //  means that to check for an "empty" file we have to account for the
            //  presence of the BOM.
            //
            BOOL fFileIsEmpty = (m_dwSize == (OS_NT ? sizeof(c_wchBOM) : 0));
            
            wsprintfU(psz, pszFmt,
                  fFileIsEmpty ? c_szEmpty : c_szNewLine,    // don't start with a newline if the file is empty
                  c_szLineOfStars,
                  pszPlatform,
                  VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.szCSDVersion,
                  HIWORD(dwCMVer), LOWORD(dwCMVer), HIWORD(dwCMBuild), LOWORD(dwCMBuild),
                  m_pszServiceName,
                  pszUsers,
                  (pszDate ? pszDate : TEXT("")),
                  (pszTime ? pszTime : TEXT("")),
                  c_szLineOfStars,
                  c_szLineOfStars);

            CMTRACE(TEXT("CmLogFile::Banner - wrote banner"));
        }
    }
    
    CmFree(pszFmt);
    CmFree(pszUsers);
    CmFree(pszDate);
    CmFree(pszTime);

    //
    //  Write it out...
    //
    if (psz)
    {
        Write(psz);
        CmFree(psz);
    }
}


//+----------------------------------------------------------------------------
//
// Func:    GetLogDesc
//
// Desc:    Utility function, returns log item friendly name (desc)
//
// Args:    [eItem] - the log item about which to return information
//
// Return:  LPTSTR if found, or NULL if not
//
// Notes:
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
LPTSTR
GetLogDesc(_CMLOG_ITEM eItem)
{
    CMASSERTMSG(VERIFY_CMLOG_ITEM_OK(eItem), TEXT("GetLogDesc - eItem must represent valid Log item"));

    return CmLoadString(g_hInst, s_aCmLogItems[eItem - 1].idDesc);
}



//+----------------------------------------------------------------------------
//
// Func:    GetLogFormat
//
// Desc:    Utility function, returns log item Format
//
// Args:    [eItem]    - the log item about which to return information
//          [fUnicode] - is the caller unicode?
//
// Return:  LPTSTR if found, or NULL if not
//
// Notes:
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
LPTSTR
GetLogFormat(_CMLOG_ITEM eItem, BOOL fUnicode)
{
    CMASSERTMSG(VERIFY_CMLOG_ITEM_OK(eItem), TEXT("GetLogFormat - eItem must represent valid Log item"));

    CMASSERTMSG(fUnicode, TEXT("GetLogFormat - currently cmlog is only being compiled unicode"));
    
    LPTSTR pszFmt = CmLoadString(g_hInst, s_aCmLogItems[eItem - 1].idFormat);

    if (0 == lstrcmpU(TEXT(""), pszFmt))
    {
        // NOTE: CmLoadString has a rather broken implementation where it decides
        //       to return empty strings in case of failure.  This is a problem
        //       because (a) it makes it impossible to detect an actual failure,
        //       as opposed to an empty string, and and (b) it uses an alloc within
        //       a return statement, so it can fail anyway.  This 'if' block
        //       gives me back a NULL so that my code can work the way it should.
        CmFree(pszFmt);
        return NULL;
    }
    else if (pszFmt)
    {
        // If the module is compiled unicode, then fUnicode=false requires conversion.
        // If the module is compiled ANSI, then fUnicode=true requires conversion.

#if 0 // since we're compiled Unicode for now        
#ifdef UNICODE
        if (!fUnicode)
        {
            if (FALSE == ConvertFormatString(pszFmt))
            {
                return NULL;
            }
        }
#else
        if (fUnicode)
        {
            if (FALSE == ConvertFormatString(pszFmt))
            {
                return NULL;
            }
        }
#endif
#endif // 0
        return pszFmt;
    }
    else
    {
        return NULL;
    }
}


#undef CMLOG_IMPLEMENTATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:	 henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>

#include "uapi.h"
#include "cm_def.h"
#include "cmdebug.h"
#define  _CMUTIL_MODULE_
#include "cmutil.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\ciniw.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ciniW.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Unicode CIni implementation
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:	 henryt - relocated to CMUTIL           03/15/98
//           quintinb - created A and W versions    05/12/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
//
// Function:  CIniW_Set
//
// Synopsis:  This function takes a pointer to a string and a string as arguments.  It
//            frees the string currently in the destination pointer, allocates the correct
//            amount of memory and then copies the source string to the string pointed
//            to by the destination string pointer.  The allocated memory is the
//            responsibility of the caller.
//
// Arguments: LPWSTR *ppszDest - pointer to the destination string
//            LPCWSTR pszSrc - source string for the set
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static void CIniW_Set(LPWSTR *ppszDest, LPCWSTR pszSrc)
{
    MYDBGASSERT(ppszDest);

    if (ppszDest)
    {
        CmFree(*ppszDest);
        *ppszDest = ((pszSrc && *pszSrc) ? CmStrCpyAllocW(pszSrc) : NULL);
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CIniW_LoadCat
//
// Synopsis:  This function concatenates the suffix argument onto the string
//            argument and returns the resulting string through the return
//            value.  Note that the function allocates the correct amount of
//            memory which must be freed by the caller.  Also not passing in
//            an empty string returns NULL while passing just an empty suffix
//            returns just a copy of the string.
//
// Arguments: LPCWSTR pszStr - source string to duplicate
//            LPCWSTR pszSuffix - suffix to add onto the duplicated string
//
// Returns:   LPWSTR - a duplicate of the concatenated string
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static LPWSTR CIniW_LoadCat(LPCWSTR pszStr, LPCWSTR pszSuffix)
{
	LPWSTR pszTmp;

	if (!pszStr || !*pszStr)
    {
		return (NULL);
	}
	
	if (!pszSuffix || !*pszSuffix)
    {
		pszTmp = CmStrCpyAllocW(pszStr);
	}
	else
	{
        pszTmp = CmStrCpyAllocW(pszStr);

        if (pszTmp)
        {
    	    CmStrCatAllocW(&pszTmp, pszSuffix);
    	}
	}

    MYDBGASSERT(pszTmp);
	
	return (pszTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW_GPPS
//
// Synopsis:  Wrapper for the Windows API GetPrivateProfileString.  The return
//            value is the requested value, allocated on behalf of the caller.
//            Note that the function assumes a reasonable default size and then
//            loops and reallocates until it can fit the whole string.
//
// Arguments: LPCWSTR pszSection - Ini file section to retrieve data from
//            LPCWSTR pszEntry - key name to retrieve data from
//            LPCWSTR pszDefault - the default string value to return, defaults
//                                to the empty string ("") if not specified
//            LPCWSTR pszFile - full path to the ini file to get the data from
//
// Returns:   LPWSTR - the requested data from the ini file, must be freed 
//                     by the caller
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
static LPWSTR CIniW_GPPS(LPCWSTR pszSection, LPCWSTR pszEntry, LPCWSTR pszDefault, LPCWSTR pszFile)
 {
	LPWSTR pszBuffer;
	LPCWSTR pszLocalDefault = pszDefault ? pszDefault : L"";

    
    if ((NULL == pszFile) || (L'\0' == *pszFile))
    {
        CMASSERTMSG(FALSE, "CIniW_GPPS -- NULL or Empty file path passed.");
        return CmStrCpyAllocW(pszLocalDefault);
    }

    size_t nLen = __max((pszDefault ? lstrlenU(pszDefault) : 0) +4,48);

	while (1)
    {
		size_t nNewLen;

		pszBuffer = (LPWSTR) CmMalloc(nLen*sizeof(WCHAR));

        MYDBGASSERT(pszBuffer);

        if (pszBuffer)
        {
		
    		nNewLen = GetPrivateProfileStringU(pszSection, pszEntry, pszLocalDefault, 
                                               pszBuffer, nLen, pszFile);

    		if (nNewLen+2 < nLen) 
            {
    			return (pszBuffer);
    		}

    		CmFree(pszBuffer);
    		nLen *= 2;
    	}
    	else
    	{
            CMASSERTMSG(FALSE, "CIniW_GPPS -- CmMalloc Failed.");
            return CmStrCpyAllocW(pszLocalDefault);
    	}
	}
}

//+----------------------------------------------------------------------------
//
// Function:  CIni_SetFile
//
// Synopsis:  This function is very similar to CIniA_Set in that it takes
//            a source string and duplicates it into the string pointed to
//            by the destination pointer.  However, the difference is that
//            this function assumes the pszSrc argument to be a full path to
//            a file and thus calls CreateFile on the pszSrc string
//            before duplicating the string.
//
// Arguments: LPWSTR* ppszDest - pointer to a string to accept the duplicated buffer
//            LPCWSTR pszSrc - full path to a file, text to be duplicated
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::CIni_SetFile(LPWSTR *ppszDest, LPCWSTR pszSrc) 
{


    MYDBGASSERT(ppszDest);

    if (ppszDest)
    {
        CmFree(*ppszDest);           
        *ppszDest = NULL;

        if (pszSrc && *pszSrc) // pszSrc could be NULL
        {
            //
            // A full path to an existing file is expected
            //
        
            HANDLE hFile = CreateFileU(pszSrc, 0, 
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
    					               NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            MYDBGASSERT(hFile != INVALID_HANDLE_VALUE);

    	    if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);

                //
                // Update internal file
                //

                *ppszDest = CmStrCpyAllocW(pszSrc);
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CIniW
//
// Synopsis:  CIniW constructor
//
// Arguments: HINSTANCE hInst - Instance handle used to load resources
//            LPCWSTR pszFile - Ini file the object describes
//            LPCWSTR pszSection - a section suffix that will be appended to 
//                                all section references
//            LPCWSTR pszEntry - an entry suffix that will be appended to all 
//                              entry references
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
CIniW::CIniW(HINSTANCE hInst, LPCWSTR pszFile, LPCWSTR pszRegPath, LPCWSTR pszSection, LPCWSTR pszEntry) 
{

    //
    //  Input pointers default to NULL and in fact the constructor is rarely called
    //  with parameters.  Thus we will skip checking the input pointers and just
    //  pass them on to the functions below, which are designed to except NULL inputs.
    //

	m_hInst = hInst;

    //
    //  Make sure to NULL the string params before setting them below.  This
    //  is because we call free on the inputted params and we don't want to try
    //  to free garbage.
    //
	m_pszFile = NULL;
	m_pszSection = NULL;
	m_pszEntry = NULL;	
	m_pszPrimaryFile = NULL;
	m_pszRegPath = NULL;
    m_pszPrimaryRegPath = NULL;
    //m_fIgnoreRegOnRead = FALSE;
    //m_fWriteToBoth = FALSE;
    //m_fReadOnlyAccess = FALSE;
    m_pszICSDataPath = NULL;
    m_fReadICSData = FALSE;
    m_fWriteICSData = FALSE;

	SetFile(pszFile);
	SetSection(pszSection);
	SetEntry(pszEntry);
	SetRegPath(pszRegPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::~CIniW
//
// Synopsis:  CIniW destructor, frees dynamically allocated strings held onto
//            by the CIniW object.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
CIniW::~CIniW()
{
	CmFree(m_pszFile);
	CmFree(m_pszSection);
	CmFree(m_pszEntry);
	CmFree(m_pszPrimaryFile);
	CmFree(m_pszRegPath);
    CmFree(m_pszPrimaryRegPath);
    CmFree(m_pszICSDataPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::Clear
//
// Synopsis:  Clears all of the member variables of the CIniW class.  Used
//            so that a single CIniW object can be re-used without having to
//            destruct the old object and construct a new one.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
void CIniW::Clear()
{
	SetHInst(NULL);
	SetFile(NULL);
	SetSection(NULL);
	SetEntry(NULL);
	SetPrimaryFile(NULL);
	SetRegPath(NULL);
    SetPrimaryRegPath(NULL);
    SetICSDataPath(NULL);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetSection
//
// Synopsis:  Sets the internal section suffix using the CIniW_Set 
//            helper function.
//
// Arguments: LPCWSTR pszSection - section suffix to remember
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetSection(LPCWSTR pszSection)
{
	CIniW_Set(&m_pszSection, pszSection);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetEntry
//
// Synopsis:  Sets the internal entry suffix using the CIniW_Set 
//            helper function.
//
// Arguments: LPCWSTR pszSection - entry suffix to remember
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetEntry(LPCWSTR pszEntry)
{
	CIniW_Set(&m_pszEntry, pszEntry);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetEntryFromIdx
//
// Synopsis:  Sets the internal entry suffix just as SetEntry does.  However,
//            the input parameter is a DWORD value that must be converted to
//            a string before it is stored as the index
//
// Arguments: DWORD dwEntry - index number to append to entries
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetEntryFromIdx(DWORD dwEntry)
{
	WCHAR szEntry[sizeof(dwEntry)*6+1];

	wsprintfU(szEntry, L"%u", dwEntry);
	SetEntry(szEntry);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::LoadSection
//
// Synopsis:  This function concatenates the given section parameter and the
//            section suffix and returns the result via the return value.  Note
//            that the memory must be freed by the calller.
//
// Arguments: LPCWSTR pszSection - base section to concatenate the suffix to
//
// Returns:   LPWSTR - a newly allocated string containing the pszSection value
//                     with the section suffix appended
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPWSTR CIniW::LoadSection(LPCWSTR pszSection) const
{
	return (CIniW_LoadCat(pszSection, m_pszSection));
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::LoadEntry
//
// Synopsis:  This function concatenates the given entry parameter and the
//            entry suffix and returns the result via the return value.  Note
//            that the memory must be freed by the calller.
//
// Arguments: LPCWSTR pszEntry - base entry to concatenate the suffix to
//
// Returns:   LPWSTR - a newly allocated string containing the pszEntry value
//                     with the entry suffix appended
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPWSTR CIniW::LoadEntry(LPCWSTR pszEntry) const
{

	return (CIniW_LoadCat(pszEntry ,m_pszEntry));
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GPPS
//
// Synopsis:  CIni's version of GetPrivateProfileString.  Duplicates the Win32
//            API functionality except that it will append the Section and Entry
//            suffixes (if any) before calling the Win32 API.  The function all
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: LPCWSTR pszSection - Ini section to look for the data in
//            LPCWSTR pszEntry - Ini key name that contains the requested data
//            LPCWSTR pszDefault - default value to return if the key 
//                                 cannot be found
//
// Returns:   LPWSTR - the requested string value
//
// History:   quintinb Created Header    01/05/2000
//			  t-urama	modified		 07/15/2000
//
//+----------------------------------------------------------------------------
LPWSTR CIniW::GPPS(LPCWSTR pszSection, LPCWSTR pszEntry, LPCWSTR pszDefault) const
{
    LPWSTR pszSectionTmp = LoadSection(pszSection);
    LPWSTR pszEntryTmp = LoadEntry(pszEntry);
	LPWSTR pszBuffer = NULL;
    

    if (m_fReadICSData)
    {
        //
        // We need first read the data from ICSData reg key, if it's not present then try to 
        // get it from the file and then see if we have a primary file and read it from there.
        //
        pszBuffer = (LPWSTR)CIniW_GetEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(TCHAR))); 
        if (NULL == pszBuffer)
        {
            LPWSTR pszICSTmp = NULL;
            pszBuffer = CIniW_GPPS(pszSectionTmp, pszEntryTmp, pszDefault, GetFile());
            
            if (m_pszPrimaryFile)
            {
                pszICSTmp = pszBuffer;
                pszBuffer = CIniW_GPPS(pszSectionTmp, pszEntryTmp, pszICSTmp, GetPrimaryFile());
            }

            if (NULL == pszBuffer)
            {
                if (pszDefault)
                {
                    pszBuffer = CmStrCpyAllocW(pszDefault);
                }
                else
                {
                    //
                    // We should not return a null from this wrapper, but an empty string instead
                    //
                    pszBuffer = CmStrCpyAllocW(L"");
                }
            }

            CmFree(pszICSTmp);
        }
    }
    else
    {
        //
        // If there is a reg path present. Registry access for m_pszFile
        // unless we want to read it from the file
        //
        if (m_pszRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                pszBuffer = (LPWSTR) CIniW_GetEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(TCHAR))); 
            }
        }

        if (NULL == pszBuffer)
        {
            // This could mean that there is no reg path, or that the reg access failed. Either way, we 
            // try to get the entry from pszFile
            //
            // Skip input pointer check since pszSection could be NULL to get all of 
            // the Section Names in the file, pszEntry could be NULL to get all of the
            // key names in a section, and pszDefault is NULL by default.
            // GetPrivateProfileString cannot take a NULL default but this is taken care of
            // by CIniW_GPPS.
            //
            pszBuffer = CIniW_GPPS(pszSectionTmp, pszEntryTmp, pszDefault, GetFile());
        }

        MYDBGASSERT(pszBuffer);

        // Now we try to get the entry from the primary file
        //
        LPWSTR pszTmp = NULL;

        if (m_pszPrimaryRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                pszTmp = pszBuffer;
                pszBuffer = (LPWSTR) CIniW_GetEntryFromReg(HKEY_CURRENT_USER, m_pszPrimaryRegPath, pszEntryTmp, REG_SZ, ((MAX_PATH + 1) * sizeof(TCHAR)));
            }
        }

        if (NULL == pszBuffer)
        {
    
            // Skip input pointer check since pszSection could be NULL to get all of 
            // the Section Names in the file, pszEntry could be NULL to get all of the
            // key names in a section, and pszDefault is NULL by default.
            // GetPrivateProfileString cannot take a NULL default but this is taken care of
            // by CIniW_GPPS.
            //
            pszBuffer = CIniW_GPPS(pszSectionTmp, pszEntryTmp, pszTmp, GetPrimaryFile());
        
        }

        CmFree(pszTmp);
    }

    
    CmFree(pszEntryTmp);
    CmFree(pszSectionTmp);
    
    MYDBGASSERT(pszBuffer);
    
    return (pszBuffer);
}



//+----------------------------------------------------------------------------
//
// Function:  CIniW::GPPI
//
// Synopsis:  CIni's version of GetPrivateProfileInt.  Duplicates the Win32
//            API functionality except that it will append the Section and Entry
//            suffixes (if any) before calling the Win32 API.  The function all
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: LPCWSTR pszSection - Ini section to look for the data in
//            LPCWSTR pszEntry - Ini key name that contains the requested data
//            DWORD dwDefault - default value to return if the key 
//                              cannot be found
//
// Returns:   DWORD - the requested numerical value
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//+----------------------------------------------------------------------------
DWORD CIniW::GPPI(LPCWSTR pszSection, LPCWSTR pszEntry, DWORD dwDefault) const
{
	//
	//  GetPrivateProfileInt doesn't take NULL's for the section and entry
	//  parameters as GetPrivateProfileString will.  Thus check the values returned
	//  from LoadSection and LoadEntry, which will return NULL if the input parameter
	//  is either NULL or empty.  Since we don't really know what to do in this
	//  situation lets just assert and return the default value.
	//
    DWORD   dwRet = dwDefault;
	LPWSTR pszSectionTmp = LoadSection(pszSection);
	LPWSTR pszEntryTmp = LoadEntry(pszEntry);
	LPCWSTR pszFileTmp = GetFile();
    DWORD* pdwData = NULL;
	
    if (m_fReadICSData)
    {
        //
        // We need first read the data from ICSData reg key, if it's not present then try to 
        // get it from the file and then see if we have a primary file and read it from there.
        //
        pdwData = (DWORD*)CIniW_GetEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
        
        //
        // If we got something, assign it to the return value, otherwise try reading from the files
        // and using the default.
        //
        if (NULL == pdwData)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszFile
            //
            MYDBGASSERT(pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp);

            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
            {
                dwRet = GetPrivateProfileIntU(pszSectionTmp, pszEntryTmp, dwDefault, pszFileTmp);
            }

            if (m_pszPrimaryFile)
            {
                //
                // The registry access failed, or there is no reg. path. try to get the 
                // entry from pszPrimaryFile
                //
        
                pszFileTmp = GetPrimaryFile();
                if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
                {
                    dwRet = GetPrivateProfileIntU(pszSectionTmp, pszEntryTmp, dwRet, pszFileTmp);
                }
            }
        }
        else
        {
            dwRet = *pdwData;
        }

    }
    else
    {
        //
        // Follow the normal rules
        // 
        if (m_pszRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
		        pdwData = (DWORD*)CIniW_GetEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
            }
        }

        if (NULL == pdwData)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszFile
            //
            MYDBGASSERT(pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp);

            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
		    {
			    dwRet = GetPrivateProfileIntU(pszSectionTmp, pszEntryTmp, dwDefault, pszFileTmp);
		    }
        }
        else
	    {
		    dwRet = *pdwData;
	    }

        if (m_pszPrimaryRegPath)
        {
            MYDBGASSERT(pszEntryTmp && *pszEntryTmp);
            if (pszEntryTmp && *pszEntryTmp)
            {
                CmFree(pdwData);

                pdwData = (DWORD*)CIniW_GetEntryFromReg(HKEY_CURRENT_USER, m_pszPrimaryRegPath, pszEntryTmp, REG_DWORD, sizeof(DWORD));
                if (pdwData)
                {
                    dwRet = *pdwData;
                }
            }
        }

        if (NULL == pdwData && m_pszPrimaryFile)
        {
            //
            // The registry access failed, or there is no reg. path. try to get the 
            // entry from pszPrimaryFile
            //
        
            pszFileTmp = GetPrimaryFile();
            if (pszSectionTmp && pszEntryTmp && pszFileTmp && *pszFileTmp)
            {
	            dwRet = GetPrivateProfileIntU(pszSectionTmp, pszEntryTmp, dwRet, pszFileTmp);
            }
        }
    }

    CmFree(pdwData);
	CmFree(pszEntryTmp);
	CmFree(pszSectionTmp);

    return dwRet;
}
		
   

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GPPB
//
// Synopsis:  CIni's version of GetPrivateProfileBool (which doesn't exactly
//            exist). Basically this function is the same as GPPI except that
//            the return value is cast to a BOOL value (1 or 0).
//
// Arguments: LPCWSTR pszSection - Ini section to look for the data in
//            LPCWSTR pszEntry - Ini key name that contains the requested data
//            DWORD dwDefault - default value to return if the key 
//                              cannot be found
//
// Returns:   DWORD - the requested BOOL value
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
BOOL CIniW::GPPB(LPCWSTR pszSection, LPCWSTR pszEntry, BOOL bDefault) const
{
    return (GPPI(pszSection, pszEntry, (DWORD)bDefault) != 0);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::WPPI
//
// Synopsis:  CIni's version of WritePrivateProfileInt (which doesn't exist as
//            a Win32 function).  Basically takes the inputted DWORD and prints
//            it into a string and then calls WPPS.
//
// Arguments: LPCWSTR pszSection - Ini section to write the data to
//            LPCWSTR pszEntry - Ini key name to store the data at
//            DWORD dwBuffer - Numeric value to write
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//
//+----------------------------------------------------------------------------
void CIniW::WPPI(LPCWSTR pszSection, LPCWSTR pszEntry, DWORD dwBuffer)
{
    // Technically pszEntry could be NULL, which would erase all of the keys in
    // the section pointed to by pszSection.  However, this doesn't seem to be
    // in the spirit of this wrapper so we will check both string pointers to make
    // sure they are valid.
	BOOL bRes = FALSE;

	//
    // Check is we are allowed to save info
    //
	if ((NULL != pszSection) && (L'\0' != pszSection[0]) &&
        (NULL != pszEntry) && (L'\0' != pszEntry[0]))
    {
		LPWSTR pszEntryTmp = LoadEntry(pszEntry);
			
	    MYDBGASSERT(pszEntryTmp || (NULL == pszEntry) || (L'\0' == pszEntry[0]));

        if (m_pszRegPath)
		{
			
			if (NULL != pszEntryTmp && *pszEntryTmp)
			{
    			bRes = CIniW_WriteEntryToReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, (BYTE *) &dwBuffer, REG_DWORD, sizeof(DWORD));
			}
		}
		
		if (!bRes)
		{
			// This loop is only entered if we are trying to write to the cmp and the registry 
			// write failed, or we are writing to the cms, in which case we will not even 
			// try to write to the reg.

            LPWSTR pszSectionTmp = LoadSection(pszSection);
	        LPCWSTR pszFileTmp = GetFile();
			        
	        MYDBGASSERT(pszFileTmp && *pszFileTmp);
	        MYDBGASSERT(pszSectionTmp && *pszSectionTmp);

            WCHAR szBuffer[sizeof(dwBuffer)*6+1];
    	
			wsprintfU(szBuffer, L"%u", dwBuffer);
					
			if (pszFileTmp && *pszFileTmp && pszSectionTmp && *pszSectionTmp && pszEntryTmp && *pszEntryTmp)
			{
    			bRes = WritePrivateProfileStringU(pszSectionTmp, pszEntryTmp, szBuffer, pszFileTmp);
			}
            if (!bRes)
            {
                DWORD dwError = GetLastError();
                CMTRACE3W(L"CIniW::WPPI() WritePrivateProfileString[*pszSection=%s,*pszEntry=%s,*pszBuffer=%s", pszSectionTmp, MYDBGSTRW(pszEntryTmp), MYDBGSTRW(szBuffer));
                CMTRACE2W(L"*pszFile=%s] failed, GLE=%u", pszFileTmp, dwError);
            }
            CmFree(pszSectionTmp);
               	
		}

        if (m_fWriteICSData)
        {
            if (NULL != pszEntryTmp && *pszEntryTmp)
			{
    			bRes = CIniW_WriteEntryToReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, (BYTE *) &dwBuffer, REG_DWORD, sizeof(DWORD));
			}
        }

        CmFree(pszEntryTmp);
    }
	else
    {
        CMASSERTMSG(FALSE, "Invalid input paramaters to CIniW::WPPI");
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CIniA::WPPB
//
// Synopsis:  CIni's version of WritePrivateProfileBool (which doesn't exist as
//            a Win32 function).  Basically takes the inputted BOOL and prints
//            either 1 or 0 into a string and then calls WPPI.
//
// Arguments: LPCWSTR pszSection - Ini section to write the data to
//            LPCWSTR pszEntry - Ini key name to store the data at
//            DWORD dwBuffer - Numeric value to write
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::WPPB(LPCWSTR pszSection, LPCWSTR pszEntry, BOOL bBuffer)
{

	WPPI(pszSection, pszEntry, bBuffer ? 1 : 0);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::WPPS
//
// Synopsis:  CIni's version of WritePrivateProfileString
//
// Arguments: LPCWSTR pszSection - Ini section to write the data to
//            LPCWSTR pszEntry - Ini key name to store the data at
//            LPCWSTR pszBuffer - data buffer to write to the ini file
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//			  t-urama	modified		 07/19/2000
//
//+----------------------------------------------------------------------------
void CIniW::WPPS(LPCWSTR pszSection, LPCWSTR pszEntry, LPCWSTR pszBuffer) 
{
    
    LPWSTR pszEntryTmp = LoadEntry(pszEntry);
    LPWSTR pszSectionTmp = LoadSection(pszSection);
	LPCWSTR pszFileTmp = GetFile();
			
	MYDBGASSERT(pszFileTmp && *pszFileTmp);
	MYDBGASSERT(pszSectionTmp && *pszSectionTmp);
    // Both pszEntry and pszBuffer could be NULL or Empty.  However, pszSection and
    // the file path must not be NULL or empty.  We also don't want to have a non-NULL
    // or non-Empty value for pszEntry and then get a NULL value back from LoadEntry
    // (indicating that LoadEntry had text to duplicate but failed for some reason).
    // Writing with a NULL value accidently will delete the key value we were trying to set.
    // Make sure to assert and prevent data loss in this case.
    //

   
    MYDBGASSERT(pszEntryTmp || (NULL == pszEntry) || (L'\0' == pszEntry[0]));

	//
    // Check is we are allowed to save info
    //
    if(pszEntryTmp || (NULL == pszEntry) || (L'\0' == pszEntry[0]))
    {	
		BOOL bRes = FALSE;
		
		// First try to write to registry if pszRegPath exists

		if (m_pszRegPath)
		{
            if (NULL == pszBuffer)
            {
                CIniW_DeleteEntryFromReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp);
                bRes = TRUE; // never erase from the cmp or cms file if there is a regpath.
            }
            else
            {
			    DWORD dwSize = (lstrlenU(pszBuffer) + 1) * sizeof(WCHAR);            
        
			    bRes = CIniW_WriteEntryToReg(HKEY_CURRENT_USER, m_pszRegPath, pszEntryTmp, (BYTE *) pszBuffer, REG_SZ, dwSize);
            }
		}

		if (!bRes)
		{
			// This loop is only entered if we are trying to write to the cmp and the registry 
			// write failed, or we are writing to the cms, in which case we will not even 
			// try to write to the reg.
			
			
			if (pszFileTmp && *pszFileTmp && pszSectionTmp && *pszSectionTmp )
			{
    			bRes = WritePrivateProfileStringU(pszSectionTmp, pszEntryTmp, pszBuffer, pszFileTmp);
			}
		}
        if (!bRes)
        {
            DWORD dwError = GetLastError();
            CMTRACE3W(L"CIniW::WPPS() WritePrivateProfileString[*pszSection=%s,*pszEntry=%s,*pszBuffer=%s", pszSectionTmp, MYDBGSTRW(pszEntryTmp), MYDBGSTRW(pszBuffer));
            CMTRACE2W(L"*pszFile=%s] failed, GLE=%u", pszFileTmp, dwError);
        }

        if (m_fWriteICSData)
        {
            if (NULL == pszBuffer)
            {
                CIniW_DeleteEntryFromReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp);
                bRes = TRUE; // never erase from the cmp or cms file if there is a regpath.
            }
            else
            {
			    DWORD dwSize = (lstrlenU(pszBuffer) + 1) * sizeof(WCHAR);            
        
			    bRes = CIniW_WriteEntryToReg(HKEY_LOCAL_MACHINE, m_pszICSDataPath, pszEntryTmp, (BYTE *) pszBuffer, REG_SZ, dwSize);
            }

        }
    }

    CmFree(pszEntryTmp);
    CmFree(pszSectionTmp);
	
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GetSection
//
// Synopsis:  Accessor function for the Section suffix member variable.  Will
//            return the empty string if m_pszSection is NULL.
//
// Arguments: None
//
// Returns:   LPCWSTR - Value of the section suffix member variable or "" 
//                      if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCWSTR CIniW::GetSection() const
{
	return (m_pszSection ? m_pszSection : L"");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GetPrimaryFile
//
// Synopsis:  Accessor function for the Primary File member variable.  Will
//            return the empty string if m_pszPrimaryFile is NULL.
//
// Arguments: None
//
// Returns:   LPCWSTR - Value of the primary file member variable or "" 
//                      if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCWSTR CIniW::GetPrimaryFile() const
{
    return (m_pszPrimaryFile ? m_pszPrimaryFile : L"");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GetHInst
//
// Synopsis:  Accessor function for the m_hInst member variable.
//
// Arguments: None
//
// Returns:   HINSTANCE - Value of the m_hInst
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
HINSTANCE CIniW::GetHInst() const
{
	return (m_hInst);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetFile
//
// Synopsis:  Function to set the m_pszFile member variable.  Uses CIni_SetFile.
//            Note that if the input parameter is NULL or the empty string then
//            m_pszFile will be set to NULL.
//
// Arguments: LPCWSTR pszFile - full path to set the m_pszFile member var to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetFile(LPCWSTR pszFile) 
{
    CIni_SetFile(&m_pszFile, pszFile);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetPrimaryFile
//
// Synopsis:  Function to set the m_pszPrimaryFile member variable.  Uses CIni_SetFile.
//            Note that if the input parameter is NULL or the empty string then
//            m_pszPrimaryFile will be set to NULL.
//
// Arguments: LPCWSTR pszFile - full path to set the m_pszPrimaryFile member var to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetPrimaryFile(LPCWSTR pszFile) 
{
    CIni_SetFile(&m_pszPrimaryFile, pszFile);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::GetFile
//
// Synopsis:  Accessor function for the File member variable.  Will
//            return the empty string if m_pszFile is NULL.
//
// Arguments: None
//
// Returns:   LPCWSTR - the contents of m_pszFile or "" if it is NULL
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
LPCWSTR CIniW::GetFile() const
{
    return (m_pszFile ? m_pszFile : L"");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetHInst
//
// Synopsis:  Function to set the m_hInst member variable.
//
// Arguments: HINSTANCE hInst - instance handle to set m_hInst to
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/05/2000
//
//+----------------------------------------------------------------------------
void CIniW::SetHInst(HINSTANCE hInst) 
{
    m_hInst = hInst;
}

//
//	Loading sections by string resource isn't used anymore
//
#if 0

LPWSTR CIniW::LoadSection(UINT nSection) const
{
	LPWSTR pszTmp;

	pszTmp = CmLoadStringW(GetHInst(), nSection);
	CmStrCatAllocW(&pszTmp, GetSection());
	return (pszTmp);
}
#endif

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetRegPath
//
// Synopsis:  Sets the registry path for registry access
//
// Arguments: LPCSTR pszRegPath - entry suffix to remember
//
// Returns:   Nothing
//
// History:   t-urama Created Header    07/13/2000
//
//+----------------------------------------------------------------------------

void CIniW::SetRegPath(LPCWSTR pszRegPath)
{
	CIniW_Set(&m_pszRegPath, pszRegPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetPrimaryRegPath
//
// Synopsis:  Sets the registry path for primary file registry access
//
// Arguments: LPCSTR pszPrimaryRegPath - Primary reg path 
//
// Returns:   Nothing
//
// History:   t-urama Created Header    07/13/2000
//
//+----------------------------------------------------------------------------

void CIniW::SetPrimaryRegPath(LPCWSTR pszPrimaryRegPath)
{
	CIniW_Set(&m_pszPrimaryRegPath, pszPrimaryRegPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetICSDataPath
//
// Synopsis:  Sets the internal registry key to store data for ICS.
//            Need to make sure the string isn't empty since we don't want
//            to write in HKLM
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniW::SetICSDataPath(LPCWSTR pszICSPath)
{
    CIniW_Set(&m_pszICSDataPath, pszICSPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetReadICSData
//
// Synopsis:  Sets the read flag, to read data from the ICS registry key.
//
// Arguments: fValue
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniW::SetReadICSData(BOOL fValue)
{
    m_fReadICSData = fValue;
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::SetWriteICSData
//
// Synopsis:  Sets the write flag, to write data to the ICS registry key.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   03/30/2001    tomkel      Created 
//
//+----------------------------------------------------------------------------
void CIniW::SetWriteICSData(BOOL fValue)
{
    m_fWriteICSData = fValue;
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CiniW_WriteEntryToReg
//
// Synopsis:  Function to write and entry to the registry. 
//
// Arguments: HKEY hKey 
//            LPCWSTR pszRegPathTmp - reg key name
//            LPCWSTR pszEntry - Registry value name to which data is to be written
//			  CONST BYTE *lpData - Data to be written
//            DWORD dwType - The type of value to be entered
//			  DWORD dwSize - The size of the value entered
//
// Returns:   BOOL - Success or failure
//
// History:   t-urama Created Header    07/15/2000
//
//+----------------------------------------------------------------------------
BOOL CIniW::CIniW_WriteEntryToReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry, CONST BYTE *lpData, DWORD dwType, DWORD dwSize) const
{
   MYDBGASSERT(pszEntry && *pszEntry);
   MYDBGASSERT(lpData);
   MYDBGASSERT(pszRegPathTmp && *pszRegPathTmp);

    

   if (NULL == pszEntry || !*pszEntry || NULL == lpData || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return FALSE;
    }

   HKEY    hKeyCm;
   DWORD   dwDisposition;

   DWORD dwRes = RegCreateKeyExU(hKey,
                                 pszRegPathTmp,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_ALL_ACCESS,
                                 NULL,
                                 &hKeyCm,
                                 &dwDisposition);


	//
    // If we opened the key successfully, write the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegSetValueExU(hKeyCm, 
                               pszEntry, 
                               0, 
                               dwType,
                               lpData, 
                               dwSize);             

        
        RegCloseKey(hKeyCm);
    }
#ifdef DEBUG
        if (ERROR_SUCCESS != dwRes)
        {
            CMTRACE1(TEXT("CIniW_WriteEntryToReg() - %s failed"), (LPWSTR)pszEntry);
        }
#endif

    return (ERROR_SUCCESS == dwRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CiniW_GetEntryFromReg
//
// Synopsis:  Function to get the value from the registry. The function 
//            allocates the string it returns in the return value which must be
//            freed by the caller.
//
// Arguments: HKEY hKey - reg hkey
//            LPCWSTR pszRegPathTmp - reg key
//            LPCWSTR pszEntry - Registry value name that contains the requested data
//            DORD dwType - Type of value
//            DWORD dwSize - Size of value
//
// Returns:   LPBYTE - the requested value
//
// History:   07/15/2000    t-urama Created Header    
//            04/03/2001    tomkel  Added hkey and reg key path name to parameters
//
//+----------------------------------------------------------------------------
LPBYTE CIniW::CIniW_GetEntryFromReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry, DWORD dwType, DWORD dwSize) const
    
{    
    MYDBGASSERT(pszEntry);

    if (NULL == pszEntry || !*pszEntry || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return NULL;
    }
    
    //
    // Everything is ok. We have a reg path and a entry name. 
    //

    LPBYTE lpData = NULL;
    DWORD dwTypeTmp = dwType;
    DWORD dwSizeTmp = dwSize;
    HKEY hKeyCm;
 
    //
    // Open the sub key under hKey
    //

    DWORD dwRes = RegOpenKeyExU(hKey,
                               pszRegPathTmp,
                               0,
                               KEY_QUERY_VALUE,
                               &hKeyCm);
    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {
        do
        {
            //
            //	Allocate a buffer
            //
            CmFree(lpData);
            lpData = (BYTE *) CmMalloc(dwSizeTmp);

            if (NULL == lpData)
            {
                RegCloseKey(hKeyCm);
                return FALSE;
            }

            dwRes = RegQueryValueExU(hKeyCm, 
                                     pszEntry,
                                     NULL,
                                     &dwTypeTmp,
                                     lpData, 
                                     &dwSizeTmp);

        } while (ERROR_MORE_DATA == dwRes);

		RegCloseKey(hKeyCm);
	}
	
	if (ERROR_SUCCESS == dwRes && dwTypeTmp == dwType)
	{
		return lpData;     
	}
	else
	{
		CmFree(lpData);
		return NULL;
	}

}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CiniW_GetRegPath
//
// Synopsis:  Function to get the value ofm_pszRegPath
//
// Arguments: none
//
// Returns:   LPWCSTR - Value of m_pszRegPath
//
// History:   t-urama Created Header    07/15/2000
//
//+----------------------------------------------------------------------------
LPCWSTR CIniW::GetRegPath() const
{
	return (m_pszRegPath ? m_pszRegPath : L"");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CiniW_GetPrimaryRegPath
//
// Synopsis:  Function to get the value ofm_pszPrimaryRegPath
//
// Arguments: none
//
// Returns:   LPWCSTR - Value of m_pszPrimaryRegPath
//
// History:   t-urama Created     07/15/2000
//
//+----------------------------------------------------------------------------
LPCWSTR CIniW::GetPrimaryRegPath() const
{
	return (m_pszPrimaryRegPath ? m_pszPrimaryRegPath : L"");
}

//+----------------------------------------------------------------------------
//
// Function:  CIniW::CiniW_DeleteEntryFromReg
//
// Synopsis:  Function to delete an entry from the registry. 
//
// Arguments: HKEY hKey
//            LPCWSTR pszRegPathTmp - reg key name
//            LPCWSTR pszEntry - Registry value name to be deleted
//
// Returns:   BOOL - Success or failure
//
// History:   07/15/2000    t-urama Created
//            04/03/2001    tomkel  Added Hkey and reg key name to parameters
//
//+----------------------------------------------------------------------------
BOOL CIniW::CIniW_DeleteEntryFromReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry) const
{
    
    MYDBGASSERT(pszEntry);

    if (NULL == pszEntry || !*pszEntry || NULL == pszRegPathTmp || !*pszRegPathTmp || NULL == hKey)
    {
        return FALSE;
    }
       
    //
    // Everything is ok. We have a reg path and a entry name.
    //
    
    HKEY    hKeyCm;
    BOOL dwRes = RegOpenKeyExU(hKey,
                               pszRegPathTmp,
                               0,
                               KEY_SET_VALUE,
                               &hKeyCm);

    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegDeleteValueU(hKeyCm, pszEntry);
        RegCloseKey(hKeyCm);
    }

    return (ERROR_SUCCESS == dwRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\cmlogutil.h ===
//+----------------------------------------------------------------------------
//
// File:    cmlogutil.h
//
// Module:  logging.LIB
//
// Synopsis: Connection Manager Logging
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  25-May-2000 SumitC  Created
//
//-----------------------------------------------------------------------------


BOOL ConvertFormatString(LPTSTR pszFmt);
BOOL CmGetModuleBaseName(HINSTANCE hInst, LPTSTR szModule);
void CmGetDateTime(LPTSTR * ppszDate, LPTSTR * ppszTime);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\image.cpp ===
//+----------------------------------------------------------------------------
//
// File:     image.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Common image loading routines
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   nickball   Created   03/30/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadImageA
//
//  Synopsis:   ANSI Wrapper for LoadImage API which loads a resource based upon
//              pszSpec which can be any of 3 formats:
//
//              1) Filename
//              2) Resource ID name
//
//  Arguments:  hMainInst - Our application instance handle
//              pszSpec   - The name of the resource
//              nResType  - The resource type
//              nCX       - Resource X dimension (ie. 32 X 32 icon)
//              nCY       - Resource Y dimension (ie. 32 X 32 icon)
//
// Notes:       Now includes hInst of main app for portability, due to different OS 
//              implementations of GetModuleHandle, the 16-bit compilation would grab 
//              default icons (ie. Question Mark) from the system dll.
//
//  Returns:    TRUE on Success
//
//  History:    a-nichb     Re-Written                      03/21/97
//              quintinb    Implemented Wide/ANSI forms     04/08/99
//              sumitc      cleanup                         03/14/2000
//
//----------------------------------------------------------------------------

HANDLE CmLoadImageA(HINSTANCE hMainInst, LPCSTR pszSpec, UINT nResType, UINT nCX, UINT nCY) 
{
    HANDLE hRes = NULL;
    
    // Ensure that the resource is one we can handle
    MYDBGASSERT(nResType == IMAGE_BITMAP || nResType == IMAGE_ICON);
    // enforce that icons can only be 16x16 or 32x32.
    MYDBGASSERT(nResType != IMAGE_ICON ||
                ((GetSystemMetrics(SM_CXICON) == (int) nCX && GetSystemMetrics(SM_CYICON) == (int) nCY)) ||
                 (GetSystemMetrics(SM_CXSMICON) == (int) nCX && GetSystemMetrics(SM_CYSMICON) == (int) nCY));

    if (NULL == pszSpec) 
    {
        return NULL;
    }

    DWORD dwFlags = 0;
    
    if (HIWORD(PtrToUlong(pszSpec))) 
    {
        if (NULL == *pszSpec) 
        {
            return NULL;
        }
        CMASSERTMSG(NULL == CmStrchrA(pszSpec, ','), TEXT("dll,id syntax no longer supported "));

        // If the HIWORD is empty, it's a resource ID, else it is a string.
        dwFlags |= LR_LOADFROMFILE;
    }

    if (nResType == IMAGE_BITMAP)
    {
        dwFlags |= LR_CREATEDIBSECTION;
    }

    // Apparently, this is intended to cause the low-order word of the 
    // name to used as an OEM image identifier by LoadImage on Win95. 
    
    HINSTANCE hInstTmp = (dwFlags & LR_LOADFROMFILE) ? NULL : hMainInst;
    
    hRes = LoadImageA(hInstTmp, pszSpec, nResType, nCX, nCY, (UINT) dwFlags);

#ifdef DEBUG
    if (!hRes)
    {
        if (dwFlags & LR_LOADFROMFILE)
        {
            CMTRACE3A("LoadImage(hInst=0x%x, pszSpec=%S, dwFlags|dwImageFlags=0x%x) failed.", hInstTmp, pszSpec, dwFlags);
        }
        else
        {
            CMTRACE3A("LoadImage(hInst=0x%x, pszSpec=0x%x, dwFlags|dwImageFlags=0x%x) failed.", hInstTmp, pszSpec, dwFlags);
        }
    }
#endif

    return hRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadImageW
//
//  Synopsis:   Wide Wrapper for LoadImage API which loads a resource based upon
//              pszSpec which can be any of 2 formats:
//
//              1) Filename
//              2) Resource ID name
//
//  Arguments:  hMainInst - Our application instance handle
//              pszSpec   - The name of the resource
//              nResType  - The resource type
//              nCX       - Resource X dimension (ie. 32 X 32 icon)
//              nCY       - Resource Y dimension (ie. 32 X 32 icon)
//
// Notes:       Now includes hInst of main app for portability, due to different OS 
//              implementations of GetModuleHandle, the 16-bit compilation would grab 
//              default icons (ie. Question Mark) from the system dll.
//
//  Returns:    TRUE on Success
//
//  History:    a-nichb     Re-Written                      03/21/1997
//              quintinb    Implemented Wide/ANSI forms     04/08/1999
//              sumitc      cleanup                         03/14/2000
//
//----------------------------------------------------------------------------

HANDLE CmLoadImageW(HINSTANCE hMainInst, LPCWSTR pszSpec, UINT nResType, UINT nCX, UINT nCY) 
{
    HANDLE hRes = NULL;
    
    // Ensure that the resource is one we can handle
    MYDBGASSERT(nResType == IMAGE_BITMAP || nResType == IMAGE_ICON);
    // enforce that icons can only be 16x16 or 32x32.
    MYDBGASSERT(nResType != IMAGE_ICON ||
                ((GetSystemMetrics(SM_CXICON) == (int) nCX && GetSystemMetrics(SM_CYICON) == (int) nCY)) ||
                 (GetSystemMetrics(SM_CXSMICON) == (int) nCX && GetSystemMetrics(SM_CYSMICON) == (int) nCY));

    if (NULL == pszSpec) 
    {
        return NULL;
    }

    DWORD dwFlags = 0;
    
    if (HIWORD(PtrToUlong(pszSpec))) 
    {
        if (NULL == *pszSpec) 
        {
            return NULL;
        }
        CMASSERTMSG(NULL == CmStrchrW(pszSpec, L','), TEXT("dll,id syntax no longer supported "));

        // If the HIWORD is empty, it's a resource ID, else it is a string.
        dwFlags |= LR_LOADFROMFILE;
        
    }

    if (nResType == IMAGE_BITMAP)
    {
        dwFlags |= LR_CREATEDIBSECTION;
    }

    // Apparently, this is intended to cause the low-order word of the 
    // name to used as an OEM image identifier by LoadImage on Win95. 

    HINSTANCE hInstTmp = (dwFlags & LR_LOADFROMFILE) ? NULL : hMainInst;
    
    hRes = LoadImageU(hInstTmp, pszSpec, nResType, nCX, nCY, (UINT) dwFlags);

#ifdef DEBUG
    if (!hRes)
    {
        if (dwFlags & LR_LOADFROMFILE)
        {
            CMTRACE3W(L"LoadImage(hInst=0x%x, pszSpec=%s, dwFlags|dwImageFlags=0x%x) failed.", hInstTmp, pszSpec, dwFlags);
        }
        else
        {
            CMTRACE3W(L"LoadImage(hInst=0x%x, pszSpec=0x%x, dwFlags|dwImageFlags=0x%x) failed.", hInstTmp, pszSpec, dwFlags);
        }
    }
#endif
    
    return hRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadIconA
//
//  Synopsis:   This function loads a large icon from the given file path or
//              the given instance handle and resource ID.
//
//  Arguments:  HINSTANCE hInst - Instance Handle
//              LPCSTR pszSpec - either filename path or a resource ID, see
//                               CmLoadImage for details.
//
//  Returns:    HICON - Handle to an Icon on Success, NULL on Failure
//
//  History:    quintinb    Created Header      01/13/2000
//
//----------------------------------------------------------------------------
HICON CmLoadIconA(HINSTANCE hInst, LPCSTR pszSpec) 
{
    return ((HICON) CmLoadImageA(hInst,
                                 pszSpec,
                                 IMAGE_ICON,
                                 GetSystemMetrics(SM_CXICON),
                                 GetSystemMetrics(SM_CYICON)));
}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadIconW
//
//  Synopsis:   This function loads a large icon from the given file path or
//              the given instance handle and resource ID.
//
//  Arguments:  HINSTANCE hInst - Instance Handle
//              LPCWSTR pszSpec - either filename path or a resource ID, see
//                               CmLoadImage for details.
//
//  Returns:    HICON - Handle to an Icon on Success, NULL on Failure
//
//  History:    quintinb    Created Header      01/13/2000
//
//----------------------------------------------------------------------------
HICON CmLoadIconW(HINSTANCE hInst, LPCWSTR pszSpec) 
{
    return ((HICON) CmLoadImageW(hInst,
                                 pszSpec,
                                 IMAGE_ICON,
                                 GetSystemMetrics(SM_CXICON),
                                 GetSystemMetrics(SM_CYICON)));
}


//+---------------------------------------------------------------------------
//
//  Function:   CmLoadSmallIconA
//
//  Synopsis:   This function loads a small icon from the given file path or
//              the given instance handle and resource ID.
//
//  Arguments:  HINSTANCE hInst - Instance Handle
//              LPCWSTR pszSpec - either filename path or a resource ID, see
//                               CmLoadImage for details.
//
//  Returns:    HICON - Handle to an Icon on Success, NULL on Failure
//
//  History:    quintinb    Created Header      01/13/2000
//
//----------------------------------------------------------------------------
HICON CmLoadSmallIconA(HINSTANCE hInst, LPCSTR pszSpec) 
{
    HICON hRes = NULL;

    hRes = (HICON) CmLoadImageA(hInst,
                                pszSpec,
                                IMAGE_ICON,
                                GetSystemMetrics(SM_CXSMICON),
                                GetSystemMetrics(SM_CYSMICON));
    if (!hRes) 
    {
        hRes = CmLoadIconA(hInst, pszSpec);
    }

    return hRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadSmallIconW
//
//  Synopsis:   This function loads a small icon from the given file path or
//              the given instance handle and resource ID.
//
//  Arguments:  HINSTANCE hInst - Instance Handle
//              LPCWSTR pszSpec - either filename path or a resource ID, see
//                               CmLoadImage for details.
//
//  Returns:    HICON - Handle to an Icon on Success, NULL on Failure
//
//  History:    quintinb    Created Header      01/13/2000
//
//----------------------------------------------------------------------------
HICON CmLoadSmallIconW(HINSTANCE hInst, LPCWSTR pszSpec) 
{
    HICON hRes = NULL;

    hRes = (HICON) CmLoadImageW(hInst,
                                pszSpec,
                                IMAGE_ICON,
                                GetSystemMetrics(SM_CXSMICON),
                                GetSystemMetrics(SM_CYSMICON));
    if (!hRes) 
    {
        hRes = CmLoadIconW(hInst, pszSpec);
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\makefile.inc ===
$(O)\cmutilp.def: cmutil.src
    $(C_PREPROCESSOR) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Main entry point for cmutil.dll
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:	 henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "cmlog.h"

HINSTANCE g_hInst = NULL;

//
// thread local storage index
//
DWORD  g_dwTlsIndex;

extern HANDLE g_hProcessHeap;  // defined in mem.cpp
extern void EndDebugMemory();  // impemented in mem.cpp

extern "C" BOOL WINAPI DllMain(
    HINSTANCE   hinstDLL,       // handle to DLL module 
    DWORD       fdwReason,      // reason for calling function 
    LPVOID      lpvReserved     // reserved 
)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        //
        //  First Things First, lets initialize the U Api's
        //
        if (!InitUnicodeAPI())
        {
            //
            //  Without our U api's we are going no where.  Bail.
            //
            return FALSE;
        }

        g_hProcessHeap = GetProcessHeap();

        //
        // alloc tls index
        //
        g_dwTlsIndex = TlsAlloc();
        if (g_dwTlsIndex == TLS_OUT_OF_INDEXES)
        {
            return FALSE;
        }
        
        MYVERIFY(DisableThreadLibraryCalls(hinstDLL));

        g_hInst = hinstDLL;
    }

    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        //
        // free the tls index
        //
        if (g_dwTlsIndex != TLS_OUT_OF_INDEXES)
        {
            TlsFree(g_dwTlsIndex);
        }

        if (!UnInitUnicodeAPI())
        {
            CMASSERTMSG(FALSE, TEXT("cmutil Dllmain, UnInitUnicodeAPI failed - we are probably leaking a handle"));
        }

#ifdef  DEBUG
        EndDebugMemory();
#endif
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\cmlogutil.cpp ===
//+----------------------------------------------------------------------------
//
// File:    cmlogutil.cpp
//
// Module:  CMLOG.LIB
//
// Synopsis: Utility function for Connection Manager Logging
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  25-May-2000 SumitC  Created
//
// Note:
//
//-----------------------------------------------------------------------------

#define CMLOG_IMPLEMENTATION
#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <psapi.h>
#include <tlhelp32.h>

#include "cmmaster.h"

#include "cmlog.h"
#include "cmlogutil.h"

#if 0
const DWORD c_szFmtSize = 128;          // largest format string possible.

/*
//+----------------------------------------------------------------------------
//
// Func:    ConvertFormatString
//
// Desc:    Utility function, converts %s to %S within a given format string
//
// Args:    [pszFmt] - format string with %s's and %c's in it, to be converted
//
// Return:  LPTSTR buffer containing new format string
//
// Notes:   return value is a static buffer and doesn't have to be freed.
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
ConvertFormatString(LPTSTR pszFmt)
{
    MYDBGASSERT(pszFmt);

    if (lstrlenU(pszFmt) > c_szFmtSize)
    {
        MYDBGASSERT(!"Cmlog format string too large, fix code");
        return FALSE;
    }

    for (int i = 1; i < lstrlenU(pszFmt); i++)
    {
        if (pszFmt[i - 1] == TEXT('%') && pszFmt[i] == TEXT('s'))
        {
            // uppercase it.
            pszFmt[i] = TEXT('S');
        }
        if (pszFmt[i - 1] == TEXT('%') && pszFmt[i] == TEXT('c'))
        {
            // uppercase it.
            pszFmt[i] = TEXT('C');
        }
    }
    
    return TRUE;
}
*/
#endif




//+----------------------------------------------------------------------------
//
// Func:    CmGetModuleNT
//
// Desc:    Utility function to get module name on WinNT systems
//
// Args:    [hInst]    -- IN, instance handle
//          [szModule] -- OUT, buffer to return module name
//
// Return:  BOOL
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
CmGetModuleNT(HINSTANCE hInst, LPTSTR szModule)
{
    BOOL    fRet = FALSE;
    HMODULE hModLib = NULL;

    typedef DWORD (WINAPI* PFN_GMBN)(HANDLE, HMODULE, LPTSTR, DWORD);
    
    PFN_GMBN pfnGetModuleBaseName = NULL;

    //
    //  Load the library
    //
    hModLib = LoadLibrary(TEXT("PSAPI.dll"));
    if (NULL == hModLib)
    {
        CMTRACE(TEXT("NT - could not load psapi.dll"));
        goto Cleanup;
    }

    //
    //  Get the necessary function(s)
    //
#ifdef UNICODE
    pfnGetModuleBaseName = (PFN_GMBN)GetProcAddress(hModLib, "GetModuleBaseNameW");
#else
    pfnGetModuleBaseName = (PFN_GMBN)GetProcAddress(hModLib, TEXT("GetModuleBaseNameA"));
#endif
    if (NULL == pfnGetModuleBaseName)
    {
        CMTRACE(TEXT("NT - couldn't find GetModuleBaseName within psapi.dll !!"));
        goto Cleanup;
    }

    //
    //  Get the module name
    //
    fRet = (0 != pfnGetModuleBaseName(GetCurrentProcess(), hInst, szModule, 13));

Cleanup:
    if (hModLib)
    {
        FreeLibrary(hModLib);
    }

    return fRet;
}


//+----------------------------------------------------------------------------
//
// Func:    CmGetModule9x
//
// Desc:    Utility function to get module name on Win9x systems
//
// Args:    [hInst]    -- IN, instance handle
//          [szModule] -- OUT, buffer to return module name
//
// Return:  BOOL
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
CmGetModule9x(HINSTANCE hInst, LPTSTR szModule)
{
    BOOL    fRet = FALSE;
    HMODULE hModLib = NULL;
    HANDLE  hSnap = NULL;

    typedef HANDLE (WINAPI* PFN_TH32SS) (DWORD, DWORD);
    typedef BOOL (WINAPI* PFN_MOD32F) (HANDLE, LPMODULEENTRY32);
    typedef BOOL (WINAPI* PFN_MOD32N) (HANDLE, LPMODULEENTRY32);
    
    PFN_TH32SS      pfnSnapshot = NULL;
    PFN_MOD32F      pfnModule32First = NULL;
    PFN_MOD32N      pfnModule32Next = NULL;

    //
    //  Load the library
    //
    hModLib = LoadLibraryA("kernel32.dll");
    if (NULL == hModLib)
    {
        CMTRACE(TEXT("9x - could not load kernel32.dll"));
        goto Cleanup;
    }

    //
    //  Get the necessary function(s)
    //
    pfnSnapshot = (PFN_TH32SS) GetProcAddress(hModLib, "CreateToolhelp32Snapshot");
    pfnModule32First = (PFN_MOD32F) GetProcAddress(hModLib, "Module32First");
    pfnModule32Next = (PFN_MOD32N) GetProcAddress(hModLib, "Module32Next");

    if (NULL == pfnModule32Next || NULL == pfnModule32First || NULL == pfnSnapshot)
    {
        CMTRACE(TEXT("9x - couldn't get ToolHelp functions"));
        goto Cleanup;
    }

    //
    //  Get the module name
    //
    hSnap = pfnSnapshot(TH32CS_SNAPMODULE, 0);

    if (INVALID_HANDLE_VALUE == hSnap)
    {
        CMTRACE(TEXT("9x - could not get ToolHelp32Snapshot"));
        goto Cleanup;
    }
    else
    {
        MODULEENTRY32   moduleentry;
        BOOL            fDone = FALSE;
        CHAR            szModuleAnsi[13];

        moduleentry.dwSize = sizeof(MODULEENTRY32);

        for (fDone = pfnModule32First(hSnap, &moduleentry);
             fDone;
             fDone = pfnModule32Next(hSnap, &moduleentry))
        {
            if ((HMODULE)moduleentry.hModule == hInst)
            {
                memcpy(szModuleAnsi, moduleentry.szModule, 12 * sizeof(CHAR));
                szModuleAnsi[12] = '\0';
                fRet = TRUE;
                break;
            }
        }

        SzToWz(szModuleAnsi, szModule, 13);
    }

Cleanup:

    if (hSnap)
    {
        CloseHandle(hSnap);
    }
    if (hModLib)
    {
        FreeLibrary(hModLib);
    }

    return fRet;
}


//+----------------------------------------------------------------------------
//
// Func:    CmGetModuleBaseName
//
// Desc:    Utility function to figure out our module name
//
// Args:    [hInst]    -- IN, instance handle
//          [szModule] -- OUT, buffer to return module name
//
// Return:  BOOL
//
// Notes:   
//
// History: 30-Apr-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
CmGetModuleBaseName(HINSTANCE hInst, LPTSTR szModule)
{
    BOOL fRet = FALSE;

    if (OS_NT)
    {
        fRet = CmGetModuleNT(hInst, szModule);
    }
    else
    {
        fRet = CmGetModule9x(hInst, szModule);
    }

    if (fRet)
    {
        // trim the string to just the basename
        for (int i = 0; i < lstrlenU(szModule); ++i)
        {
            if (TEXT('.') == szModule[i])
            {
                szModule[i] = TEXT('\0');
                break;
            }
        }
    }

    return fRet;
}


//+----------------------------------------------------------------------------
//
// Func:    CmGetDateTime
//
// Desc:    Utility function to get system-formatted date and/or time
//
// Args:    [ppszDate] -- OUT, ptr to where to put the date (NULL=>don't want the date)
//          [ppszTime] -- OUT, ptr to where to put the time (NULL=>don't want the time)
//
// Return:  void
//
// Notes:   
//
// History: 17-Nov-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
void
CmGetDateTime(LPTSTR * ppszDate, LPTSTR * ppszTime)
{
    int iRet;
    
    if (ppszDate)
    {
        iRet = GetDateFormatU(LOCALE_SYSTEM_DEFAULT, DATE_SHORTDATE, NULL, NULL, NULL, 0);

        if (iRet)
        {
            *ppszDate = (LPTSTR) CmMalloc(iRet * sizeof(TCHAR));
            if (*ppszDate)
            {
                iRet = GetDateFormatU(LOCALE_SYSTEM_DEFAULT, DATE_SHORTDATE, NULL, NULL, *ppszDate, iRet);
            }
        }
        else
        {
            MYDBGASSERT(!"CmGetDateTime - GetDateFormat failed");
            *ppszDate = NULL;
        }
    }

    if (ppszTime)
    {
        iRet = GetTimeFormatU(LOCALE_SYSTEM_DEFAULT, 0, NULL, NULL, NULL, 0);

        if (iRet)
        {
            *ppszTime = (LPTSTR) CmMalloc(iRet * sizeof(TCHAR));
            if (*ppszTime)
            {
                iRet = GetTimeFormatU(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT|TIME_NOTIMEMARKER, NULL, NULL, *ppszTime, iRet);
            }
        }
        else
        {
            MYDBGASSERT(!"CmGetDateTime - GetTimeFormat failed");
            *ppszTime = NULL;
        }
    }
}

#undef CMLOG_IMPLEMENTATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\font.cpp ===
//+----------------------------------------------------------------------------
//
// File:     font.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Font handling utility routines provided by CMUTIL
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb       Created   04/11/99
//
//+----------------------------------------------------------------------------

//
//  Moved these routines from cmutil\misc.cpp
//

#include "cmmaster.h"


//+---------------------------------------------------------------------------
//
//  Function:   EnumChildProc
//
//  Synopsis:   Callback function to manipulate enumerated child windows.
//              Interprets lParam as a font and applies it to each child.
//
//  Arguments:  hwndChild - Handle of child control
//              lParam    - App defined data (font)
//
//  Returns:    TRUE
//
//  Note:       This function is never exposed to clients of CMUTIL
// 
//  History:    5/13/97 - a-nichb - Created
//
//----------------------------------------------------------------------------

BOOL CALLBACK EnumChildProc(HWND hwndChild, LPARAM lParam) 
{
    HFONT hFont = (HFONT) lParam;

    if (hFont)
    {
        SendMessageU(hwndChild, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
    }
    
    MYDBGTST(!hFont, (TEXT("EnumChildProc() - Invalid hFont - NULL lParam.")));

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeBold
//
//  Synopsis:   Bold the text in the given window (usually a control).  The
//              caller is responsbile for calling ReleaseBold to free the
//              allocated font resources.
//
//  Arguments:  hwnd - Window handle of the page
//              fSize - If height should be changed proportionately
//
//  Returns:    ERROR_SUCCESS if successful
//              Otherwise error code
// 
//  History:    10/16/1996    VetriV        Created
//              01/12/2000    Quintinb      Commonized for Cmmon and Profwiz
//----------------------------------------------------------------------------
CMUTILAPI HRESULT MakeBold (HWND hwnd, BOOL fSize)
{
    HRESULT hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONTA* plogfont = NULL;

    //
    //  No window, no-op
    //
    if (!hwnd)
    {
        goto MakeBoldExit;
    }

    //
    //  Get the current Font
    //
    hfont = (HFONT)SendMessageU(hwnd, WM_GETFONT, 0, 0);
    
    if (!hfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    //
    //  Allocate a logical font struct to work with
    //
    plogfont = (LOGFONTA*) CmMalloc(sizeof(LOGFONTA));
    
    if (!plogfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    //
    //  Get the logical font and make it bold and a larger size
    //  if the caller specified the fSize flag as TRUE.
    //
    if (!GetObjectA(hfont, sizeof(LOGFONTA), (LPVOID)plogfont))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (abs(plogfont->lfHeight) < 24 && fSize)
    {
        plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
    }

    plogfont->lfWeight = FW_BOLD;

    //
    //  Create the new font
    //
    if (!(hnewfont = CreateFontIndirectA(plogfont)))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    //
    //  Tell the window to use the new font
    //
    SendMessageU(hwnd, WM_SETFONT, (WPARAM)hnewfont, MAKELPARAM(TRUE,0)); //lint !e534 WM_SETFONT doesn't return anything
        
MakeBoldExit:

    CmFree(plogfont);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseBold
//
//  Synopsis:   Release the bold font use for title of the page
//
//  Arguments:  hwnd - Window handle of the page
//
//  Returns:    ERROR_SUCCESS
// 
//  History:    10/16/96    VetriV  Created
//----------------------------------------------------------------------------
CMUTILAPI HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessageU(hwnd, WM_GETFONT, 0, 0);

    if (hfont) 
    {
        DeleteObject(hfont);
    }
    
    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   UpdateFont
//
//  Synopsis:   Converts all child controls of the specified dialog to use 
//              DBCS compatible font. Use this in WM_INITDIALOG.
//
//  Arguments:  hwnd - Window handle of the dialog
//
//  Returns:    Nothing
// 
//  History:    4/31/97  - a-frankh - Created
//              5/13/97  - a-nichb  - Revised to enum child windows
//
//----------------------------------------------------------------------------
CMUTILAPI void UpdateFont(HWND hDlg)
{
    BOOL bEnum = FALSE;
    HFONT hFont = NULL;
    
    //
    // Get the default UI font, or system font if that fails
    //

    hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
            
    if (hFont == NULL)
    {
        hFont = (HFONT) GetStockObject(SYSTEM_FONT);
    }
            
    //
    // Enum child windows and set new font
    //

    if (hFont)
    {
        bEnum = EnumChildWindows(hDlg, EnumChildProc, (LPARAM) hFont);
        MYDBGTST(!bEnum, (TEXT("UpdateFont() - EnumChildWindows() failed.")));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\clsutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  CLSUTIL.H - header file for utility C++ classes
//

//  HISTORY:
//  
//  12/07/94  jeremys    Borrowed from WNET common library
//

#ifndef _CLSUTIL_H_
#define _CLSUTIL_H_

/*************************************************************************

    NAME:    BUFFER_BASE

    SYNOPSIS:  Base class for transient buffer classes

    INTERFACE:  BUFFER_BASE()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Returns TRUE if
          successful.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    None

    USES:    None

    CAVEATS:  This is an abstract class, which unifies the interface
        of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
  UINT _cb;

  virtual BOOL Alloc( UINT cbBuffer ) = 0;
  virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
  BUFFER_BASE()
    { _cb = 0; }  // buffer not allocated yet
  ~BUFFER_BASE()
    { _cb = 0; }  // buffer size no longer valid
  BOOL Resize( UINT cbNew );
  UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER  BUFFER

/*************************************************************************

    NAME:    BUFFER

    SYNOPSIS:  Wrapper class for new and delete

    INTERFACE:  BUFFER()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Only works if the
          buffer hasn't been allocated yet.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    BUFFER_BASE

    USES:    operator new, operator delete

    CAVEATS:

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
  CHAR *_lpBuffer;

  virtual BOOL Alloc( UINT cbBuffer );
  virtual BOOL Realloc( UINT cbBuffer );

public:
  BUFFER( UINT cbInitial=0 );
  ~BUFFER();
  BOOL Resize( UINT cbNew );
  CHAR * QueryPtr() const { return (CHAR *)_lpBuffer; }
  operator CHAR *() const { return (CHAR *)_lpBuffer; }
};

class RegEntry
{
  public:
    RegEntry(const char *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
    ~RegEntry();
    
    long  GetError()  { return _error; }
    long  SetValue(const char *pszValue, const char *string);
    long  SetValue(const char *pszValue, unsigned long dwNumber);
    char *  GetString(const char *pszValue, char *string, unsigned long length);
    long  GetNumber(const char *pszValue, long dwDefault = 0);
    long  DeleteValue(const char *pszValue);
    long  FlushKey();
        long    MoveToSubKey(const char *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

  private:
    HKEY  _hkey;
    long  _error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
  public:
    RegEnumValues(RegEntry *pRegEntry);
    ~RegEnumValues();
    long  Next();
    char *  GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}
    long  GetError()  { return _error; }

  private:
        RegEntry * pRegEntry;
    DWORD   iEnum;
        DWORD   cEntries;
    CHAR *  pchName;
    LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

/*************************************************************************

    NAME:    WAITCURSOR

    SYNOPSIS:  Sets the cursor to an hourclass until object is destructed

**************************************************************************/
class WAITCURSOR
{
private:
    HCURSOR m_curOld;
    HCURSOR m_curNew;

public:
    WAITCURSOR() { m_curNew = ::LoadCursor( NULL, IDC_WAIT ); m_curOld = ::SetCursor( m_curNew ); }
    ~WAITCURSOR() { ::SetCursor( m_curOld ); }
};

#endif  // _CLSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\mem.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mem.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Basic memory manipulation routines
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:	 henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//+----------------------------------------------------------------------------
// definitions
//+----------------------------------------------------------------------------
HANDLE  g_hProcessHeap = NULL;

#ifdef DEBUG
LONG    g_lMallocCnt = 0;  // a counter to detect memory leak
#endif


#if defined(DEBUG) && defined(DEBUG_MEM)

//////////////////////////////////////////////////////////////////////////////////
//
// If DEBUG_MEM is defined, track all the memory alloction in debug version.
// Keep all the allocated memory blocks in the double link list.
// Record the file name and line #, where memory is allocated.
// Add extra tag at the beginning and end of the memory to watch for overwriten
// The whole list is checked against corruption for every alloc/free operation
//
// The folowing three function is exported:
// BOOL   CheckDebugMem(void); // return TRUE for succeed
// void* AllocDebugMem(long size,const char* lpFileName,int nLine);
// BOOL   FreeDebugMem(void* pMem); // return TRUE for succeed
//
///////////////////////////////////////////////////////////////////////////////////

//#undef new

#define MEMTAG 0xBEEDB77D     // the tag before/after the block to watch for overwriten
#define FREETAG 0xBD          // the flag to fill freed memory
#define TAGSIZE (sizeof(long))// Size of the tags appended to the end of the block


//
// memory block, a double link list
//
struct TMemoryBlock
{
     TMemoryBlock* pPrev;
     TMemoryBlock* pNext;
     long size;
     const char*   lpFileName;   // The filename
     int      nLine;             // The line number
     long     topTag;            // The watch tag at the beginning
     // followed by:
     //  BYTE            data[nDataSize];
     //  long     bottomTag;
     BYTE* pbData() const        // Return the pointer to the actual data
        { return (BYTE*) (this + 1); }
};

//
// The following internal function can be overwritten to change the behaivor
//
   
static void* MemAlloc(long size);    
static BOOL  MemFree(void* pMem);    
static void  LockDebugMem();   
static void  UnlockDebugMem();   
   
//
// Internal function
//
static BOOL RealCheckMemory();  // without call Enter/Leave critical Section
static BOOL CheckBlock(const TMemoryBlock* pBlock) ;

//
// Internal data, protected by the lock to be multi-thread safe
//
static long nTotalMem;    // Total bytes of memory allocated
static long nTotalBlock;  // Total # of blocks allocated
static TMemoryBlock head; // The head of the double link list


//
// critical section to lock \ unlock DebugMemory
// The constructor lock the memory, the destructor unlock the memory
//
class MemCriticalSection
{
public:
   MemCriticalSection()
   {
      LockDebugMem();
   }                                  
   
   ~MemCriticalSection()
   {
      UnlockDebugMem();
   }
};

static BOOL fDebugMemInited = FALSE; // whether the debug memory is initialized

//+----------------------------------------------------------------------------
//
// Function:  StartDebugMemory
//
// Synopsis:  Initialize the data for debug memory
//
// Arguments: None
//
// Returns:   
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static void StartDebugMemory()
{
   fDebugMemInited = TRUE;

   head.pNext = head.pPrev = NULL;
   head.topTag = MEMTAG;
   head.size = 0;
   nTotalMem = 0;
   nTotalBlock = 0;
}                




//+----------------------------------------------------------------------------
//
// Function:  MemAlloc
//
// Synopsis:  Allocate a block of memory.  This function should be overwriten
//            if different allocation method is used
//
// Arguments: long size - size of the memory
//
// Returns:   void* - the memory allocated or NULL
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static void* MemAlloc(long size) 
{ 
	return (HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size));
}



//+----------------------------------------------------------------------------
//
// Function:    MemFree
//
// Synopsis:  Free a block of memory.  This function should be overwriten
//            if different allocation method is used
//
// Arguments: void* pMem - The memory to be freed
//
// Returns:   static BOOL - TRUE if succeeded
//
// History:   Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static BOOL MemFree(void* pMem)
{ 
    return HeapFree(GetProcessHeap(), 0, pMem);
}

//
// Data / functions to provide mutual exclusion.
// Can be overwritten, if other methed is to be used.
//
static BOOL fLockInited = FALSE;   // whether the critical section is inialized
static CRITICAL_SECTION cSection;  // The critical section to protect the link list

//+----------------------------------------------------------------------------
//
// Function:  InitLock
//
// Synopsis:  Initialize the memory lock which protects the doublely linked list
//            that contains all of the allocated memory blocks.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb      Created Header    01/14/2000
//
//+----------------------------------------------------------------------------
static void InitLock()
{
   fLockInited = TRUE;
   InitializeCriticalSection(&cSection);
}

//+----------------------------------------------------------------------------
//
// Function:  LockDebugMem
//
// Synopsis:  Locks the doublely linked list that contains all of the 
//            allocated memory blocks so that it can only be accessed by the
//            locking thread.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb      Created Header    01/14/2000
//
//+----------------------------------------------------------------------------
static void LockDebugMem()
{
   static int i = 0;
   if(!fLockInited)
   {
      InitLock();
   }
   
   EnterCriticalSection(&cSection);
}

//+----------------------------------------------------------------------------
//
// Function:  UnlockDebugMem
//
// Synopsis:  Unlocks the doublely linked list that contains all of the 
//            allocated memory blocks.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb      Created Header    01/14/2000
//
//+----------------------------------------------------------------------------
static void UnlockDebugMem()
{
   LeaveCriticalSection(&cSection);
}

//+----------------------------------------------------------------------------
//
// Function:  AllocDebugMem
//
// Synopsis:  Process memory allocation request.
//            Check the link list.  Allocate a larger block.  
//            Record filename/linenumber, add tags and insert to the list
//
// Arguments: long size - Size of the memory to be allocated
//            const char* lpFileName - File name to be recorded
//            int nLine - Line number to be recorted
//
// Returns:   CMUTILAPI void* - The memory allocated. Ready to use by the caller
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
CMUTILAPI void* AllocDebugMem(long size,const char* lpFileName,int nLine)
{
    if (!fDebugMemInited)
    {
        StartDebugMemory();
    }

    if (size<0)
    {
        CMASSERTMSG(FALSE,"Negtive size for alloc");
        return NULL;
    }

    if (size>1024*1024)
    {
        CMASSERTMSG(FALSE," size for alloc is great than 1Mb");
        return NULL;
    }

    if (size == 0)
    {
        CMTRACE("Allocate memory of size 0");
        return NULL;
    }


    //
    // Protect the access to the list
    //
    MemCriticalSection criticalSection;

    //
    // Check the link list first
    //
    if (!RealCheckMemory())
    {
        return NULL;
    }
              
    //
    // Allocate a large block to hold additional information
    //
    TMemoryBlock* pBlock = (TMemoryBlock*)MemAlloc(sizeof(TMemoryBlock)+size + TAGSIZE);
    if (!pBlock)                  
    {
        CMTRACE("Outof Memory");
        return NULL;
    }               

    //
    // record filename/line/size, add tag to the beginning and end
    //
    pBlock->size = size;
    pBlock->topTag = MEMTAG;   
    pBlock->lpFileName = lpFileName;
    pBlock->nLine = nLine;
    *(long*)(pBlock->pbData() + size) = MEMTAG;

    //
    // insert at head
    //
    pBlock->pNext = head.pNext;
    pBlock->pPrev = &head;  
    if(head.pNext)
      head.pNext->pPrev = pBlock; 
    head.pNext = pBlock;

    nTotalMem += size;
    nTotalBlock ++;

    return  pBlock->pbData();
}



//+----------------------------------------------------------------------------
//
// Function:  FreeDebugMem
//
// Synopsis: Free the memory allocated by AllocDebugMem
//           Check the link list, and the block to be freed.
//           Fill the block data with FREETAG before freed 
//
// Arguments: void* pMem - Memory to be freed
//
// Returns:   BOOL - TRUE for succeeded
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL FreeDebugMem(void* pMem)
{
    if (!fDebugMemInited)
    {
        StartDebugMemory();
    }

    if (!pMem)
    {
        return FALSE;
    }            
  
    //
    // Get the lock
    //
    MemCriticalSection criticalSection;

    //
    // Get pointer to our structure
    //
    TMemoryBlock* pBlock =(TMemoryBlock*)( (char*)pMem - sizeof(TMemoryBlock));

    //
    // Check the block to be freed
    //
    if (!CheckBlock(pBlock))
    {
        return FALSE;
    }

    //
    // Check the link list
    //
    if (!RealCheckMemory())
    {
        return FALSE;
    }

    //
    // remove the block from the list
    //
    pBlock->pPrev->pNext = pBlock->pNext;
    if (pBlock->pNext)
    {
      pBlock->pNext->pPrev = pBlock->pPrev;
    }
                 
    nTotalMem -= pBlock->size;
    nTotalBlock --;

    //
    // Fill the freed memory with 0xBD, leave the size/filename/lineNumber unchanged
    //
    memset(&pBlock->topTag, FREETAG, (size_t)pBlock->size + sizeof(pBlock->topTag) + TAGSIZE);
    return MemFree(pBlock);
}


//+----------------------------------------------------------------------------
//
// Function:  void* ReAllocDebugMem
//
// Synopsis:  Reallocate a memory with a diffirent size
//
// Arguments: void* pMem - memory to be reallocated
//            long nSize - size of the request
//            const char* lpFileName - FileName to be recorded
//            int nLine - Line umber to be recorded
//
// Returns:   void* - new memory returned
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
CMUTILAPI void* ReAllocDebugMem(void* pMem, long nSize, const char* lpFileName,int nLine)
{
   if (!fDebugMemInited)
   {
       StartDebugMemory();
   }

   if (!pMem)
   {
      CMTRACE("Free a NULL pointer");
      return NULL;
   }            
      
   //
   // Allocate a new block, copy the information over and free the old block.
   //
   TMemoryBlock* pBlock =(TMemoryBlock*)( (char*)pMem - sizeof(TMemoryBlock));

   long lOrginalSize = pBlock->size;

   void* pNew = AllocDebugMem(nSize, lpFileName, nLine);
   if(pNew)
   {
       CopyMemory(pNew, pMem, (nSize < lOrginalSize ? nSize : lOrginalSize));
       FreeDebugMem(pMem);
   }
    
   return pNew;
}

//+----------------------------------------------------------------------------
//
// Function:  CheckDebugMem
//
// Synopsis:  Exported to external module.
//            Call this function, whenever, you want to check against 
//            memory curruption
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the memory is fine.
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL CheckDebugMem()
{
   if (!fDebugMemInited)
   {
      StartDebugMemory();
   }

   MemCriticalSection criticalSection;

   return RealCheckMemory();                           
}

//+----------------------------------------------------------------------------
//
// Function:  RealCheckMemory
//
// Synopsis:  Go through the link list to check for memory corruption
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the memory is fine.
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static BOOL RealCheckMemory() 
{
    TMemoryBlock* pBlock = head.pNext;
   
    int nBlock =0;
    while(pBlock!=NULL)
    {
        if(!CheckBlock(pBlock))
        {
            return FALSE;
        }            

        pBlock = pBlock->pNext;
        nBlock++;
    }
                              
    if(nBlock != nTotalBlock)
    {
        CMASSERTMSG(FALSE,"Memery corrupted");
        return FALSE;
    }            

    return TRUE;                           
}
   
//+----------------------------------------------------------------------------
//
// Function:  CheckBlock
//
// Synopsis:  Check a block for memory corruption
//
// Arguments: const TMemoryBlock* pBlock - 
//
// Returns:   BOOL - TRUE, if the block is fine
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
static BOOL CheckBlock(const TMemoryBlock* pBlock) 
{
   if (pBlock->topTag != MEMTAG)     // overwriten at top
   {
         CMASSERTMSG(FALSE, "Memery corrupted");
         return FALSE;
   }            

   if (pBlock->size<0)
   {
         CMASSERTMSG(FALSE, "Memery corrupted");
         return FALSE;
   }            

   if (*(long*)(pBlock->pbData() +pBlock->size) != MEMTAG) // overwriten at bottom
   {
         CMASSERTMSG(FALSE, "Memery corrupted");
         return FALSE;
   }            

   if (pBlock->pPrev && pBlock->pPrev->pNext != pBlock)
   {
         CMASSERTMSG(FALSE, "Memery corrupted");
         return FALSE;
   }            

   if (pBlock->pNext && pBlock->pNext->pPrev != pBlock)
   {
         CMASSERTMSG(FALSE, "Memery corrupted");
         return FALSE;
   }            
      
   return TRUE;
}  

/////////////////////////////////////////////////////////////////////////////
// operator new, delete
/*  We did not redefine new and delete

void*   __cdecl operator new(size_t nSize)
{
   void* p = AllocDebugMem(nSize,NULL,0);

   if (p == NULL)
   {
      CMTRACE("New failed");
   }

   return p;
}

void*   __cdecl operator new(size_t nSize, const char* lpszFileName, int nLine)
{
   void* p = AllocDebugMem(nSize, lpszFileName,nLine);

   if (p == NULL)
   {
      CMTRACE("New failed");
   }

   return p;
}

void  __cdecl operator delete(void* p)
{
   if(p)
      FreeDebugMem(p);
}
*/


//+----------------------------------------------------------------------------
//
// Function:  EndDebugMemory
//
// Synopsis:  Called before the program exits.  Report any unreleased memory leak
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/2/98
//
//+----------------------------------------------------------------------------
void EndDebugMemory()
{
   if(head.pNext != NULL || nTotalMem!=0 || nTotalBlock !=0)
   {
      CMTRACE("Detected memory leaks");
      TMemoryBlock * pBlock;

      for(pBlock = head.pNext; pBlock != NULL; pBlock = pBlock->pNext)
      {
         TCHAR buf[1024];
         wsprintf(buf, TEXT("Memory Leak of %d bytes:\n%S"), pBlock->size, pBlock->pbData());
         MyDbgAssertA(pBlock->lpFileName, pBlock->nLine, buf);    // do not print the file name
      }
      DeleteCriticalSection(&cSection);
   }
}                

#else // defined(DEBUG) && defined(DEBUG_MEM)

//////////////////////////////////////////////////////////////////////////////////
//
// If DEBUG_MEM if NOT defined, only track a count of memory for debug version
//
///////////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG

void TraceHeapBlock(PROCESS_HEAP_ENTRY* pheEntry)
{
    CMTRACE(TEXT("TraceHeapBlock -- Begin Entry Trace"));

    CMTRACE1(TEXT("\tEntry->lpData = 0x%x"), pheEntry->lpData);
    CMTRACE1(TEXT("\tEntry->cbData = %u"), pheEntry->cbData);
    CMTRACE1(TEXT("\tEntry->cbOverhead = %u"), pheEntry->cbOverhead);
    CMTRACE1(TEXT("\tEntry->iRegionIndex = %u"), pheEntry->iRegionIndex);

    if (pheEntry->wFlags & PROCESS_HEAP_REGION)
    {
        CMTRACE1(TEXT("\tEntry->dwCommittedSize = %u"), pheEntry->Region.dwCommittedSize);
        CMTRACE1(TEXT("\tEntry->dwUnCommittedSize = %u"), pheEntry->Region.dwUnCommittedSize);
        CMTRACE1(TEXT("\tEntry->lpFirstBlock = 0x%x"), pheEntry->Region.lpFirstBlock);
        CMTRACE1(TEXT("\tEntry->lpLastBlock = 0x%x"), pheEntry->Region.lpLastBlock);
        CMTRACE(TEXT("\tPROCESS_HEAP_REGION flag set."));
    }

    if (pheEntry->wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE)
    {        
        CMTRACE(TEXT("\tPROCESS_HEAP_UNCOMMITTED_RANGE flag set."));
    }

    if ((pheEntry->wFlags & PROCESS_HEAP_ENTRY_BUSY) && (pheEntry->wFlags & PROCESS_HEAP_ENTRY_MOVEABLE))
    {
        CMTRACE1(TEXT("\tEntry->hMem = 0x%x"), pheEntry->Block.hMem);
        CMTRACE1(TEXT("\tEntry->dwReserved = %u"), pheEntry->Block.dwReserved);
        
        CMTRACE(TEXT("\tPROCESS_HEAP_ENTRY_BUSY and PROCESS_HEAP_ENTRY_MOVEABLE flags are set."));
    }

    if ((pheEntry->wFlags & PROCESS_HEAP_ENTRY_BUSY) && (pheEntry->wFlags & PROCESS_HEAP_ENTRY_DDESHARE))
    {
        CMTRACE(TEXT("\tPROCESS_HEAP_ENTRY_BUSY and PROCESS_HEAP_ENTRY_DDESHARE flags are set."));
    }

    CMTRACE(TEXT("TraceHeapBlock -- End Entry Trace"));
    CMTRACE(TEXT(""));
}

BOOL CheckProcessHeap()
{
    BOOL bRet;
    DWORD dwError;
    PROCESS_HEAP_ENTRY pheEntry;

    ZeroMemory(&pheEntry, sizeof(pheEntry));

    do
    {
        bRet = HeapWalk(g_hProcessHeap, &pheEntry);
        if (!bRet)
        {               
            dwError = GetLastError();
            if (ERROR_NO_MORE_ITEMS != dwError)
            {
                CMTRACE1(TEXT("HeapWalk returned FALSE, GLE returns %u"), dwError);
            }
            else
            {
                TraceHeapBlock(&pheEntry);
            }
        }
        else
        {
            TraceHeapBlock(&pheEntry);
        }
    
    } while(!bRet);

    return TRUE;
}
#endif // DEBUG

CMUTILAPI void *CmRealloc(void *pvPtr, size_t nBytes) 
{

#ifdef DEBUG
    if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
    {
        CMTRACE(TEXT("CmRealloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

        CheckProcessHeap();
    }
#endif

    void* p = HeapReAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY, pvPtr, nBytes);

#ifdef DEBUG
    if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
    {
        CMTRACE(TEXT("CmRealloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

        CheckProcessHeap();
    }

    CMASSERTMSG(p, TEXT("CmRealloc failed"));
#endif

    return p;
}


CMUTILAPI void *CmMalloc(size_t nBytes) 
{

#ifdef DEBUG

    InterlockedIncrement(&g_lMallocCnt);

    MYDBGASSERT(nBytes < 1024*1024); // It should be less than 1 MB
    MYDBGASSERT(nBytes > 0);         // It should be *something*

    if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
    {
        CMTRACE(TEXT("CmMalloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

        CheckProcessHeap();
    }

#endif
    
    void* p = HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY, nBytes);
    
#ifdef DEBUG
    
    if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
    {
        CMTRACE(TEXT("CmMalloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

        CheckProcessHeap();
    }

    CMASSERTMSG(p, TEXT("CmMalloc failed"));

#endif

    return p;
}


CMUTILAPI void CmFree(void *pvPtr) 
{

#ifdef DEBUG
    if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
    {
        CMTRACE(TEXT("CmMalloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

        CheckProcessHeap();
    }
#endif

	if (pvPtr) 
    {	
	    MYVERIFY(HeapFree(g_hProcessHeap, 0, pvPtr));

#ifdef DEBUG

        if (OS_NT && !HeapValidate(g_hProcessHeap, 0, NULL))
        {
            CMTRACE(TEXT("CmMalloc -- HeapValidate Returns FALSE.  Checking Process Heap."));

            CheckProcessHeap();
        }

	    InterlockedDecrement(&g_lMallocCnt);
#endif
    
    }
}

#ifdef DEBUG
void EndDebugMemory()
{
    if (g_lMallocCnt)
    {
        char buf[256];
        wsprintfA(buf, TEXT("Detect Memory Leak of %d blocks"), g_lMallocCnt);
        CMASSERTMSGA(FALSE, buf);
    }
}
#endif

#endif

//
// the memory functions are for i386 only.
//
#ifdef _M_IX86
//+----------------------------------------------------------------------------
//
// memmove - Copy source buffer to destination buffer.  The code is copied from
//           libc.
//                                                                                
// Purpose:                                                                       
//        memmove() copies a source memory buffer to a destination memory buffer. 
//        This routine recognize overlapping buffers to avoid propogation.        
//        For cases where propogation is not a problem, memcpy() can be used.     
//                                                                                
// Entry:                                                                         
//        void *dst = pointer to destination buffer                               
//        const void *src = pointer to source buffer                              
//        size_t count = number of bytes to copy                                  
//                                                                                
// Exit:                                                                          
//        Returns a pointer to the destination buffer                             
//
//+----------------------------------------------------------------------------
CMUTILAPI PVOID WINAPI CmMoveMemory(
    PVOID       dst,
    CONST PVOID src,
    size_t      count
) 
{
    void * ret = dst;
    PVOID src1 = src;

    if (dst <= src1 || (char *)dst >= ((char *)src1 + count)) {
            /*
             * Non-Overlapping Buffers
             * copy from lower addresses to higher addresses
             */
            while (count--) {
                    *(char *)dst = *(char *)src1;
                    dst = (char *)dst + 1;
                    src1 = (char *)src1 + 1;
            }
    }
    else {
            /*
             * Overlapping Buffers
             * copy from higher addresses to lower addresses
             */
            dst = (char *)dst + count - 1;
            src1 = (char *)src1 + count - 1;

            while (count--) {
                    *(char *)dst = *(char *)src1;
                    dst = (char *)dst - 1;
                    src1 = (char *)src1 - 1;
            }
    }

    return(ret);
}

#endif //_M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\misc.cpp ===
//+----------------------------------------------------------------------------
//
// File:     misc.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Misc. utility routines provided by CMUTIL
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
  
//+----------------------------------------------------------------------------
// defines
//+----------------------------------------------------------------------------
#define WIN95_OSR2_BUILD_NUMBER             1111
#define LOADSTRING_BUFSIZE                  24
#define FAREAST_WIN95_LOADSTRING_BUFSIZE    512

#define MAX_STR_LEN 512 // Maximum length for Format Message string
     
//+----------------------------------------------------------------------------
// code
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function    GetOSVersion
//
//  Synopsis    returns the OS version(platform ID)
//
//  Arguments   NONE
//
// Returns:     DWORD - VER_PLATFORM_WIN32_WINDOWS or
//                      VER_PLATFORM_WIN32_WINDOWS98 or
//                      VER_PLATFORM_WIN32_NT
//
// History:   Created Header    2/13/98
//
//+----------------------------------------------------------------------------

CMUTILAPI DWORD WINAPI GetOSVersion()
{
    static dwPlatformID = 0;

    //
    // If this function is called before, reture the saved value
    //
    if (dwPlatformID != 0)
    {
        return dwPlatformID;
    }

    OSVERSIONINFO oviVersion;

    ZeroMemory(&oviVersion,sizeof(oviVersion));
    oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);
    GetVersionEx(&oviVersion);

    if (oviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
        CMASSERTMSG(oviVersion.dwMajorVersion == 4, "Major Version must be 4 for this version of CM");

        //
        //  If this is Win95 then leave it as VER_PLATFORM_WIN32_WINDOWS, however if this
        //  is Millennium, Win98 SE, or Win98 Gold we want to modify the returned value
        //  as follows:  VER_PLATFORM_WIN32_MILLENNIUM -> Millennium
        //               VER_PLATFORM_WIN32_WINDOWS98 -> Win98 SE and Win98 Gold
        //
        if (oviVersion.dwMajorVersion == 4)
        {
            if (LOWORD(oviVersion.dwBuildNumber) > 2222)
            {
                //
                //  Millennium
                //
                oviVersion.dwPlatformId = VER_PLATFORM_WIN32_MILLENNIUM;
            }
            else if (LOWORD(oviVersion.dwBuildNumber) >= 1998)
            {
                //
                // Win98 Gold and Win98 SE
                //

                oviVersion.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS98; 
            }
        }
    }

    dwPlatformID = oviVersion.dwPlatformId;
    return(dwPlatformID);
}



//+----------------------------------------------------------------------------
//
//  Function    GetOSBuildNumber
//
//  Synopsis    Get the build number of Operating system
//
//  Arguments   None
//
//  Returns     Build Number of OS
//
//  History     3/5/97      VetriV      Created
//
//-----------------------------------------------------------------------------
CMUTILAPI DWORD WINAPI GetOSBuildNumber()
{
    static dwBuildNumber = 0;
    OSVERSIONINFO oviVersion;

    if (0 != dwBuildNumber)
    {
        return dwBuildNumber;
    }

    ZeroMemory(&oviVersion,sizeof(oviVersion));
    oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);
    GetVersionEx(&oviVersion);
    dwBuildNumber = oviVersion.dwBuildNumber;
    return dwBuildNumber;
}


//+----------------------------------------------------------------------------
//
//  Function    GetOSMajorVersion
//
//  Synopsis    Get the Major version number of Operating system
//
//  Arguments   None
//
//  Returns     Major version Number of OS
//
//  History     2/19/98     VetriV      Created
//
//-----------------------------------------------------------------------------
CMUTILAPI DWORD WINAPI GetOSMajorVersion(void)
{
    static dwMajorVersion = 0;
    OSVERSIONINFO oviVersion;

    if (0 != dwMajorVersion)
    {
        return dwMajorVersion;
    }

    ZeroMemory(&oviVersion,sizeof(oviVersion));
    oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);
    GetVersionEx(&oviVersion);
    dwMajorVersion = oviVersion.dwMajorVersion;
    return dwMajorVersion;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsFarEastNonOSR2Win95()
//
//  Synopsis:   Checks to see if the OS is a far east version of Win95(golden
//              and OPK1, NOT OSR2).
//
//  Arguments:  NONE
//
//  Returns:    TRUE/FALSE
//
//  History:    henryt      07/09/97    Created         
//              nickball    03/11/98    Moved to cmutil
//----------------------------------------------------------------------------
CMUTILAPI BOOL WINAPI IsFarEastNonOSR2Win95(void)
{
    OSVERSIONINFO oviVersion;

    ZeroMemory(&oviVersion, sizeof(oviVersion));
    oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);

    GetVersionEx(&oviVersion);

    //
    // Is it (Win95) and (not OSR2) and (DBCS enabled)?
    // Far east Win95 are DBCS enabled while other non-English versions
    // are SBCS-enabled.
    //
    MYDBGTST((oviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS       &&
              LOWORD(oviVersion.dwBuildNumber) != WIN95_OSR2_BUILD_NUMBER &&
              GetSystemMetrics(SM_DBCSENABLED)), (TEXT("It's a Far East non-OSR2 machine!\n")));

    return (oviVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS       &&
            LOWORD(oviVersion.dwBuildNumber) != WIN95_OSR2_BUILD_NUMBER &&
            GetSystemMetrics(SM_DBCSENABLED));

}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadStringA
//
//  Synopsis:   Loads the ANSI version of the string resource specified by
//              the passed in module instance handle and resource ID.  The
//              function returns the requested string in a CmMalloc-ed buffer
//              through the return value.  This buffer must be freed by the
//              caller.  Note that CmLoadString figures out the proper buffer
//              size by guessing and then calling loadstring again if the buffer
//              is too small.
//
//  Arguments:  HINSTANCE hInst - module to load the string resource from
//              UINT nId - resource ID of the string to load
//
//  Returns:    LPSTR - On success returns a pointer to the requested string
//                      resource.  On failure the function tries to return
//                      a pointer to the Empty string ("") but if the memory
//                      allocation fails it can return NULL.
//
//  History:    quintinb     Created Header     01/14/2000
//
//----------------------------------------------------------------------------
CMUTILAPI LPSTR CmLoadStringA(HINSTANCE hInst, UINT nId) 
{
    //
    // In some far east versions of non-OSR2 win95, LoadString() ignores the 
    // nBufferMax paramater when loading DBCS strings.  As a result, if the
    // DBCS string is bigger than the buffer, the API overwrites the memory.
    // We workaround the bug by using a larger buffer size.
    //
    static fFarEastNonOSR2Win95 = IsFarEastNonOSR2Win95();
    size_t nLen = fFarEastNonOSR2Win95? 
                    FAREAST_WIN95_LOADSTRING_BUFSIZE : 
                    LOADSTRING_BUFSIZE;
    LPSTR pszString;

    if (!nId) 
    {
        return (CmStrCpyAllocA(""));
    }
    while (1) 
    {
        size_t nNewLen;

        pszString = (LPSTR) CmMalloc(nLen*sizeof(CHAR));

        MYDBGASSERT(pszString);
        if (NULL == pszString)
        {
            return (CmStrCpyAllocA(""));
        }
        
        nNewLen = LoadStringA(hInst, nId, pszString, nLen-1);
        //
        // we use nNewLen+3 because a DBCS char len can be 2 and a UNICODE
        // char len is 2.  Ideally, we can use nLen in the above LoadString()
        // call and use nNewLen+2 in the line below.  But nLen+3 is a safer
        // fix now...
        //
        if ((nNewLen + 3) < nLen) 
        {
            return (pszString);
        }

        //
        // shouldn't reach here for far east non osr2
        // this will allow us to catch DBCS string resources that are
        // longer than FAREAST_WIN95_LOADSTRING_BUFSIZE.
        //
        MYDBGASSERT(!fFarEastNonOSR2Win95);

        CmFree(pszString);
        nLen *= 2;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CmLoadStringW
//
//  Synopsis:   Loads the Unicode version of the string resource specified by
//              the passed in module instance handle and resource ID.  The
//              function returns the requested string in a CmMalloc-ed buffer
//              through the return value.  This buffer must be freed by the
//              caller.  Note that CmLoadString figures out the proper buffer
//              size by guessing and then calling loadstring again if the buffer
//              is too small.
//
//  Arguments:  HINSTANCE hInst - module to load the string resource from
//              UINT nId - resource ID of the string to load
//
//  Returns:    LPWSTR - On success returns a pointer to the requested string
//                       resource.  On failure the function tries to return
//                       a pointer to the Empty string ("") but if the memory
//                       allocation fails it can return NULL.
//
//  History:    quintinb     Created Header     01/14/2000
//
//----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmLoadStringW(HINSTANCE hInst, UINT nId) 
{  
    size_t nLen = LOADSTRING_BUFSIZE;

    LPWSTR pszString;

    if (!nId) 
    {
        return (CmStrCpyAllocW(L""));
    }

    while (1) 
    {
        size_t nNewLen;

        pszString = (LPWSTR) CmMalloc(nLen*sizeof(WCHAR));
        
        MYDBGASSERT(pszString);
        if (NULL == pszString)
        {
            return (CmStrCpyAllocW(L""));
        }
        
        nNewLen = LoadStringU(hInst, nId, pszString, nLen-1);
        //
        // we use nNewLen+3 because a DBCS char len can be 2 and a UNICODE
        // char len is 2.  Ideally, we can use nLen in the above LoadString()
        // call and use nNewLen+2 in the line below.  But nLen+3 is a safer
        // fix now...
        //
        if ((nNewLen + 3) < nLen) 
        {
            return (pszString);
        }

        CmFree(pszString);
        nLen *= 2;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CmFmtMsgW
//
//  Synopsis:   Simulation of FormatMessage using wvsprintf for cross-platform
//              compatibility.
//
//  Arguments:  hInst   - Application instance handle
//              dwMsgId - ID of message to use for formatting final output
//              ...     - Variable arguments to used in message fromatting
//
//  Returns:    Allocated to formatted string.
//
//  History:    nickball - Added function header    - 5/12/97
//              nickball - Moved to cmutil          - 03/30/98    
//              quintinb - Added W and A versions   - 03/09/99
//
//----------------------------------------------------------------------------

CMUTILAPI LPWSTR CmFmtMsgW(HINSTANCE hInst, DWORD dwMsgId, ...) 
{
    LPWSTR pszTmp = NULL;
    LPWSTR lpszOutput = NULL;
    LPWSTR lpszFormat = NULL;

    if (!dwMsgId) 
    {
        return (CmStrCpyAllocW(L""));
    }
    
    // Allocate a buffer to receive the RC string with specified msg ID

    lpszFormat = (LPWSTR) CmMalloc(MAX_STR_LEN*sizeof(WCHAR));

    if (!lpszFormat)
    {
        CMASSERTMSG(FALSE, "CmFmtMsgW -- CmMalloc returned a NULL pointer for lpszFormat");
        return (CmStrCpyAllocW(L""));
    }
    
    // Initialize argument list

    va_list valArgs;
    va_start(valArgs,dwMsgId);

    // Load the format string from the RC

    int nRes = LoadStringU(hInst, (UINT) dwMsgId, lpszFormat, MAX_STR_LEN - 1);

#ifdef DEBUG
    if (0 == nRes)
    {
        CMTRACE3(TEXT("MyFmtMsg() LoadString(dwMsgId=0x%x) return %u, GLE=%u."), dwMsgId, nRes, 
            nRes ? 0: GetLastError());
    }
#endif

    // If nothing loaded, free format buffer and bail

    if (nRes == 0 || lpszFormat[0] == '\0') 
    {
        CMASSERTMSG(FALSE, "CmFmtMsgW -- LoadStringU returned 0 or an empty buffer.");
        pszTmp = (CmStrCpyAllocW(L""));
        goto done;
    }

    // Allocate another buffer and for use by vsprintf

    lpszOutput = (LPWSTR) CmMalloc(MAX_STR_LEN*sizeof(WCHAR));

    if (!lpszOutput)
    {
        CMASSERTMSG(FALSE, "CmFmtMsgW -- CmMalloc returned a NULL pointer for lpszOutput");
        pszTmp = (CmStrCpyAllocW(L""));
        goto done;
    }

    // Format the final output using vsprintf

    nRes = wvsprintfU(lpszOutput, lpszFormat, valArgs);
    
    // If wvsprintfU failed, we're done 

    if (nRes < 0 || lpszOutput[0] == L'\0') 
    {
        CMASSERTMSG(FALSE, "CmFmtMsgW -- wvsprintfU returned 0 or an empty buffer");
        pszTmp = (CmStrCpyAllocW(L""));
        goto done;
    }
    
    // Remove trailing spaces

    pszTmp = lpszOutput + lstrlenU(lpszOutput) - 1;
    while (CmIsSpaceW(pszTmp) && (*pszTmp != L'\n')) 
    {
        *pszTmp = 0;
        if (pszTmp == lpszOutput) 
        {
            break;
        }
        pszTmp--;
    }

    pszTmp = CmStrCpyAllocW(lpszOutput); // allocates and copies
    CMASSERTMSG(pszTmp, "CmFmtMsgW -- CmStrCpyAllocW returned a NULL pointer.");

done:
    
    // Cleanup buffers, etc.

    if (lpszFormat)
    {
        CmFree(lpszFormat);
    }
    
    if (lpszOutput)
    {
        CmFree(lpszOutput);
    }
    
    va_end(valArgs);
    
    return (pszTmp);
}

//+---------------------------------------------------------------------------
//
//  Function:   CmFmtMsgA
//
//  Synopsis:   Simulation of FormatMessage using wvsprintf for cross-platform
//              compatibility.
//
//  Arguments:  hInst   - Application instance handle
//              dwMsgId - ID of message to use for formatting final output
//              ...     - Variable arguments to used in message fromatting
//
//  Returns:    Allocated to formatted string.
//
//  History:    nickball - Added function header    - 5/12/97
//              nickball - Moved to cmutil          - 03/30/98
//              quintinb - Added W and A versions   - 03/09/99    
//
//----------------------------------------------------------------------------

CMUTILAPI LPSTR CmFmtMsgA(HINSTANCE hInst, DWORD dwMsgId, ...) 
{
    LPSTR pszTmp = NULL;
    LPSTR lpszOutput = NULL;
    LPSTR lpszFormat = NULL;

    if (!dwMsgId) 
    {
        return (CmStrCpyAllocA(""));
    }
    
    // Allocate a buffer to receive the RC string with specified msg ID

    lpszFormat = (LPSTR) CmMalloc(MAX_STR_LEN);

    if (!lpszFormat)
    {
        CMASSERTMSG(FALSE, "CmFmtMsgA -- CmMalloc returned a NULL pointer for lpszFormat");
        return (CmStrCpyAllocA(""));
    }
    
    // Initialize argument list

    va_list valArgs;
    va_start(valArgs,dwMsgId);

    // Load the format string from the RC

    int nRes = LoadStringA(hInst, (UINT) dwMsgId, lpszFormat, MAX_STR_LEN - 1);
#ifdef DEBUG
    if (0 == nRes)
    {
        CMTRACE3(TEXT("MyFmtMsg() LoadString(dwMsgId=0x%x) return %u, GLE=%u."), dwMsgId, nRes, 
            nRes ? 0: GetLastError());
    }
#endif

    // If nothing loaded, free format buffer and bail

    if (nRes == 0 || lpszFormat[0] == '\0') 
    {
        pszTmp = (CmStrCpyAllocA(""));
        CMASSERTMSG(FALSE, "CmFmtMsgA -- LoadStringA returned 0 or an empty buffer.");
        goto done;
    }

    // Allocate another buffer and for use by vsprintf

    lpszOutput = (LPSTR) CmMalloc(MAX_STR_LEN);

    if (!lpszOutput)
    {
        pszTmp = (CmStrCpyAllocA(""));
        CMASSERTMSG(FALSE, "CmFmtMsgA -- CmMalloc returned a NULL pointer for lpszOutput");
        goto done;
    }

    // Format the final output using vsprintf

    nRes = wvsprintfA(lpszOutput, lpszFormat, valArgs);
    
    // If wvsprintfA failed, we're done 

    if (nRes < 0 || lpszOutput[0] == '\0') 
    {
        pszTmp = (CmStrCpyAllocA(""));
        CMASSERTMSG(FALSE, "CmFmtMsgA -- wvsprintfA returned 0 or an empty buffer");
        goto done;
    }
    
    // Remove trailing spaces

    pszTmp = lpszOutput + lstrlenA(lpszOutput) - 1;
    while (CmIsSpaceA(pszTmp) && (*pszTmp != '\n')) 
    {
        *pszTmp = 0;
        if (pszTmp == lpszOutput) 
        {
            break;
        }
        pszTmp--;
    }

    pszTmp = CmStrCpyAllocA(lpszOutput); // allocates and copies
    CMASSERTMSG(pszTmp, "CmFmtMsgA -- CmStrCpyAllocA returned a NULL pointer.");

done:
    
    // Cleanup buffers, etc.

    if (lpszFormat)
    {
        CmFree(lpszFormat);
    }
    
    if (lpszOutput)
    {
        CmFree(lpszOutput);
    }
    
    va_end(valArgs);
    
    return (pszTmp);

#if 0
/*
    // Replaced by the above code because we no longer use the platform specific .MC files
    // All strings resources are now managed via standard .RC files

    va_list valArgs;
    DWORD dwRes;
    LPTSTR pszBuffer = NULL;

    if (!dwMsgId) 
    {
        return (CmStrCpy(TEXT("")));
    }
    va_start(valArgs,dwMsgId);
    

    dwRes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_MAX_WIDTH_MASK,
                          hInst,
                          dwMsgId,
                          LANG_USER_DEFAULT,
                          (LPTSTR) &pszBuffer,
                          0,
                          &valArgs);
    MYDBGTST(dwRes==0,("MyFmtMsg() FormatMessage(dwMsgId=0x%x) return %u, GLE=%u.",dwMsgId,dwRes,dwRes?0:GetLastError()));
    va_end(valArgs);
    if (dwRes == 0) 
    {
        if (pszBuffer) 
        {
            LocalFree(pszBuffer);
        }
        return (CmStrCpy(TEXT("")));
    }
    if (!CmStrLen(pszBuffer)) 
    {
        LocalFree(pszBuffer);
        return (CmStrCpy(TEXT("")));
    }
    pszTmp = pszBuffer + CmStrLen(pszBuffer) - 1;
    while (MyIsSpace(*pszTmp) && (*pszTmp != '\n')) 
    {
        *pszTmp = 0;
        if (pszTmp == pszBuffer) 
        {
            break;
        }
        pszTmp--;
    }
    pszTmp = CmStrCpy(pszBuffer);
    LocalFree(pszBuffer);

    return (pszTmp);
*/
#endif

}

#if 0 // not used anywhere
/*
//+----------------------------------------------------------------------------
//
// Function:  GetMaxStringNumber
//
// Synopsis:  Given a buffer containing strings in INI section format, determines
//            which is the highest numbered string.
//
// Arguments: LPTSTR pszStr - The string containing an INI section
//            LPDWORD pdwMax - Ptr to a DOWRD to be filled with the result
//            *pdwMax gets the highest value of atol() of the strings.
//
// Returns:   Nothing
//
// History:   Anonymous    Created    3/30/98
//
//+----------------------------------------------------------------------------
CMUTILAPI void GetMaxStringNumber(LPTSTR pszStr, LPDWORD pdwMax)
{
    LPTSTR pszTmp;
    DWORD dwMax = 0;

    if (pszStr) 
    {
        pszTmp = pszStr;
        while (*pszTmp) 
        {
            DWORD dwMaxTmp;

            if (pdwMax) 
            {
                dwMaxTmp = (DWORD)CmAtol(pszTmp);
                if (dwMaxTmp > dwMax) 
                {
                    dwMax = dwMaxTmp;
                }
            }
            pszTmp += lstrlen(pszTmp) + 1;
        }
    }
    if (pdwMax) 
    {
        *pdwMax = dwMax;
    }
}
*/
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CmParsePathW
//
//  Synopsis:   Converts a Cm command line and args path into its component
//              parts. If the command portion is a relative path, it is expanded
//              to a full path. A ptr to the top level service filename is required 
//              to make the relative path determination.
//              
//  Arguments:  pszCmdLine      - Ptr to the full entry
//              pszServiceFile  - Ptr to top-level service filename
//              ppszCommand     - Ptr-ptr to be allocated and filled with command portion
//              ppszArguments   - Ptr-ptr to be allocated and filled with args portion
//
//  Returns:    TRUE if ppszCmd and ppszArgs are allocated/filled. FALSE otherwise.
// 
//  History:    02/19/99    nickball    Created
//              02/21/99    nickball    Moved to cmutil 
//              03/09/99    quintinb    Created A and W versions
//
//----------------------------------------------------------------------------
CMUTILAPI BOOL CmParsePathW(LPCWSTR pszCmdLine, LPCWSTR pszServiceFile, LPWSTR *ppszCommand, LPWSTR *ppszArguments)
{
    LPWSTR pszArgs = NULL;
    LPWSTR pszCmd = NULL;
    LPWSTR pszTmp = NULL;

    BOOL bRet = FALSE;

    MYDBGASSERT(pszCmdLine);
    MYDBGASSERT(pszServiceFile);
    MYDBGASSERT(ppszCommand);
    MYDBGASSERT(ppszArguments);

    if (NULL == pszCmdLine      || 
        NULL == pszServiceFile  ||
        NULL == ppszCommand     ||
        NULL == ppszArguments)
    {       
        return FALSE;    
    }
    
    CMTRACE1(TEXT("CmParsePathW() pszCmdLine is %s"), pszCmdLine);

    //
    // Determine where our string begins and what the delimiting char should
    // be then make a copy of the entire command line string to muck with.
    //

    WCHAR tchDelim = L'+';

    if (pszCmdLine == CmStrchrW(pszCmdLine, tchDelim))
    {
        pszCmd = CmStrCpyAllocW(CharNextU(pszCmdLine));
    }
    else
    {
        pszCmd = CmStrCpyAllocW(pszCmdLine);
        tchDelim = L' ';
    }
    
    MYDBGASSERT(pszCmd);
    CmStrTrimW(pszCmd);

    //
    // Assuming valid inputs, pszCmd is now one of the following:
    //
    // "C:\\Program Files\\Custom.Exe+"
    // "C:\\Program Files\\Custom.Exe+ Args"
    // "C:\\Progra~1\\Custom.Exe 
    // "C:\\Progra~1\\Custom.Exe Args"
    // "service\custom.exe"
    // "service\custom.exe Args"
    //
    
    if (pszCmd && L'\0' != *pszCmd)
    {       
        //
        // Locate the right command delimiter
        //
    
        pszArgs = CmStrchrW(pszCmd, tchDelim);

        if (pszArgs)
        {        
            //
            // Content of pszTmp is now either "+ Args", "", or "+"
            // Get a pointer to the next char and truncate the pszCmd
            // that we have thus far.
            //

            pszTmp = CharNextU(pszArgs);    // pszArgs is " Args" or ""             
            *pszArgs = L'\0';               // The "+" becomes ""
            pszArgs = pszTmp;               // pszTmp is " Args" or ""             
        }

        //
        // Fill argument buffer from pszTmp and command buffer 
        // from pszCmd with a complete path if necessary.
        // 

        if (NULL == pszArgs)
        {
            *ppszArguments = (LPWSTR)CmMalloc(sizeof(WCHAR)); // one Zero-ed WCHAR
        }
        else
        {
            MYVERIFY(*ppszArguments = CmStrCpyAllocW(pszArgs));
        }

        MYVERIFY(*ppszCommand = CmConvertRelativePathW(pszServiceFile, pszCmd));
        
        //
        // Trim blanks as needed
        //
        
        if (*ppszCommand)
        {
            CmStrTrimW(*ppszCommand);
        }
        
        if (*ppszArguments)
        {
            CmStrTrimW(*ppszArguments);
        }

        bRet = TRUE;
    }

    //
    // Cleanup. Note: pszArgs is never allocated, so we don't have to free it.
    //

    CmFree(pszCmd); 

    return bRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CmParsePathA
//
//  Synopsis:   Converts a Cm command line and args path into its component
//              parts. If the command portion is a relative path, it is expanded
//              to a full path. A ptr to the top level service filename is required 
//              to make the relative path determination.
//              
//  Arguments:  pszCmdLine      - Ptr to the full entry
//              pszServiceFile  - Ptr to top-level service filename
//              ppszCommand     - Ptr-ptr to be allocated and filled with command portion
//              ppszArguments   - Ptr-ptr to be allocated and filled with args portion
//
//  Returns:    TRUE if ppszCmd and ppszArgs are allocated/filled. FALSE otherwise.
// 
//  History:    02/19/99    nickball    Created
//              02/21/99    nickball    Moved to cmutil 
//              03/09/99    quintinb    Created A and W versions
//
//----------------------------------------------------------------------------
CMUTILAPI BOOL CmParsePathA(LPCSTR pszCmdLine, LPCSTR pszServiceFile, LPSTR *ppszCommand, LPSTR *ppszArguments)
{
    LPSTR pszArgs = NULL;
    LPSTR pszCmd = NULL;
    LPSTR pszTmp = NULL;

    BOOL bRet = FALSE;

    MYDBGASSERT(pszCmdLine);
    MYDBGASSERT(pszServiceFile);
    MYDBGASSERT(ppszCommand);
    MYDBGASSERT(ppszArguments);

    if (NULL == pszCmdLine      || 
        NULL == pszServiceFile  ||
        NULL == ppszCommand     ||
        NULL == ppszArguments)
    {       
        return FALSE;    
    }
    
    CMTRACE1(TEXT("CmParsePathA() pszCmdLine is %s"), pszCmdLine);

    //
    // Determine where our string begins and what the delimiting char should
    // be then make a copy of the entire command line string to muck with.
    //

    CHAR tchDelim = '+';

    if (pszCmdLine == CmStrchrA(pszCmdLine, tchDelim))
    {
        pszCmd = CmStrCpyAllocA(CharNextA(pszCmdLine));
    }
    else
    {
        pszCmd = CmStrCpyAllocA(pszCmdLine);
        tchDelim = ' ';
    }
    
    MYDBGASSERT(pszCmd);
    CmStrTrimA(pszCmd);

    //
    // Assuming valid inputs, pszCmd is now one of the following:
    //
    // "C:\\Program Files\\Custom.Exe+"
    // "C:\\Program Files\\Custom.Exe+ Args"
    // "C:\\Progra~1\\Custom.Exe 
    // "C:\\Progra~1\\Custom.Exe Args"
    // "service\custom.exe"
    // "service\custom.exe Args"
    //
    
    if (pszCmd && '\0' != *pszCmd)
    {       
        //
        // Locate the right command delimiter
        //
    
        pszArgs = CmStrchrA(pszCmd, tchDelim);

        if (pszArgs)
        {        
            //
            // Content of pszTmp is now either "+ Args", "", or "+"
            // Get a pointer to the next char and truncate the pszCmd
            // that we have thus far.
            //

            pszTmp = CharNextA(pszArgs);    // pszArgs is " Args" or ""             
            *pszArgs = '\0';                // The "+" becomes ""
            pszArgs = pszTmp;               // pszTmp is " Args" or ""             
        }

        //
        // Fill argument buffer from pszTmp and command buffer 
        // from pszCmd with a complete path if necessary.
        // 

        if (NULL == pszArgs)
        {
            MYVERIFY(*ppszArguments = (LPSTR)CmMalloc(sizeof(CHAR))); // one Zero-ed char
        }
        else
        {
            MYVERIFY(*ppszArguments = CmStrCpyAllocA(pszArgs));
        }

        MYVERIFY(*ppszCommand = CmConvertRelativePathA(pszServiceFile, pszCmd));
        
        //
        // Trim blanks as needed
        //
        
        if (*ppszCommand)
        {
            CmStrTrimA(*ppszCommand);
        }
        
        if (*ppszArguments)
        {
            CmStrTrimA(*ppszArguments);
        }

        bRet = TRUE;
    }

    //
    // Cleanup. Note: pszArgs is never allocated, so we don't have to free it.
    //

    CmFree(pszCmd); 

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CmConvertRelativePathA
//
// Synopsis:  Converts the specified relative path to a full path. If the 
//            specified path is not a relative path specific to this profile, 
//            it is ignored.
//
// Arguments: LPCSTR pszServiceFile - Full path to the .cms file
//            LPCSTR pszRelative    - The relative path fragment
//
// Returns:   LPSTR - NULL on failure
//
// Note:      Do not pass referenced profile service objects to this routine.
//            It is designed to derive the short-service name from the top-level
//            service filename and path.
//
// History:   03/11/98  nickball    Created    
//            02/03/99  nickball    Added header Note
//            02/21/99  nickball    Moved to cmutil
//            03/09/99  quintinb    Added W and A versions
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmConvertRelativePathA(LPCSTR pszServiceFile,
    LPSTR pszRelative)
{
    MYDBGASSERT(pszServiceFile);
    MYDBGASSERT(*pszServiceFile);
    MYDBGASSERT(pszRelative);
    MYDBGASSERT(*pszRelative);

    if (NULL == pszRelative     || 0 == pszRelative[0] ||
        NULL == pszServiceFile  || 0 == pszServiceFile[0])
    {
        return NULL;
    }
    
    //
    // Get the relative dir that we expect to find
    //

    LPSTR pszConverted = NULL;
    LPSTR pszRelDir = CmStripPathAndExtA(pszServiceFile);

    if (pszRelDir && *pszRelDir)
    {
        lstrcatA(pszRelDir, "\\");

        //
        // Compare against the specifed FRAGMENT. If it matches, convert.
        // 

        CharUpperA(pszRelDir);
        CharUpperA(pszRelative);

        if (pszRelative == CmStrStrA(pszRelative, pszRelDir))
        {
            //
            // Combine CMS path and relative for complete
            //

            LPSTR pszTmp = CmStripFileNameA(pszServiceFile, FALSE);           
            pszConverted = CmBuildFullPathFromRelativeA(pszTmp, pszRelative);    
            CmFree(pszTmp);
        }
        else
        {
            //
            // Its not a relative path for this profile, just make a copy
            //
    
            pszConverted = CmStrCpyAllocA(pszRelative);
        }
    }

    CmFree(pszRelDir);

    return pszConverted;
}

//+----------------------------------------------------------------------------
//
// Function:  CmConvertRelativePathW
//
// Synopsis:  Converts the specified relative path to a full path. If the 
//            specified path is not a relative path specific to this profile, 
//            it is ignored.
//
// Arguments: LPCWSTR pszServiceFile - Full path to the .cms file
//            LPCWSTR pszRelative    - The relative path fragment
//
// Returns:   LPWSTR - NULL on failure
//
// Note:      Do not pass referenced profile service objects to this routine.
//            It is designed to derive the short-service name from the top-level
//            service filename and path.
//
// History:   03/11/98  nickball    Created    
//            02/03/99  nickball    Added header Note
//            02/21/99  nickball    Moved to cmutil
//            03/09/99  quintinb    Added W and A versions
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmConvertRelativePathW(LPCWSTR pszServiceFile,
    LPWSTR pszRelative)
{
    MYDBGASSERT(pszServiceFile);
    MYDBGASSERT(*pszServiceFile);
    MYDBGASSERT(pszRelative);
    MYDBGASSERT(*pszRelative);

    if (NULL == pszRelative     || 0 == pszRelative[0] ||
        NULL == pszServiceFile  || 0 == pszServiceFile[0])
    {
        return NULL;
    }
    
    //
    // Get the relative dir that we expect to find
    //

    LPWSTR pszConverted = NULL;
    LPWSTR pszRelDir = CmStripPathAndExtW(pszServiceFile);

    if (pszRelDir && *pszRelDir)
    {
        lstrcatU(pszRelDir, L"\\");

        //
        // Compare against the specifed FRAGMENT. If it matches, convert.
        // 

        CharUpperU(pszRelDir);
        CharUpperU(pszRelative);

        if (pszRelative == CmStrStrW(pszRelative, pszRelDir))
        {
            //
            // Combine CMS path and relative for complete
            //

            LPWSTR pszTmp = CmStripFileNameW(pszServiceFile, FALSE);           
            pszConverted = CmBuildFullPathFromRelativeW(pszTmp, pszRelative);    
            CmFree(pszTmp);
        }
        else
        {
            //
            // Its not a relative path for this profile, just make a copy
            //
    
            pszConverted = CmStrCpyAllocW(pszRelative);
        }
    }

    CmFree(pszRelDir);

    return pszConverted;
}


//+----------------------------------------------------------------------------
//
// Function:  CmStripPathAndExtA
//
// Synopsis:  Helper function, strips path and extension from a filename path
//
// Arguments: pszFileName - the filename path to be modified
//
// Returns:   LPSTR - The base filename sub-string
//
// History:   nickball    Created header   8/12/98
//            nickball    Moved to cmutil   02/21/99
//            quintinb    Added W and A versions 03/09/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStripPathAndExtA(LPCSTR pszFileName) 
{
    MYDBGASSERT(pszFileName);

    if (NULL == pszFileName)
    {
        return NULL;
    }

    MYDBGASSERT(*pszFileName);
    
    //
    // Make a copy of the string and validate format "\\." required.
    //

    LPSTR pszTmp = CmStrCpyAllocA(pszFileName);
    
    if (NULL == pszTmp)
    {
        MYDBGASSERT(pszTmp);
        return NULL;
    }

    LPSTR pszDot = CmStrrchrA(pszTmp, '.');
    LPSTR pszSlash = CmStrrchrA(pszTmp, '\\');

    if (NULL == pszDot || NULL == pszSlash || pszDot < pszSlash)
    {
        CmFree(pszTmp);
        MYDBGASSERT(FALSE);
        return NULL;
    }
    
    *pszDot = '\0';
   
    //
    // Increment past slash and copy remainder
    //

    pszSlash = CharNextA(pszSlash);       
        
    lstrcpyA(pszTmp, pszSlash);

    return (pszTmp);
}
//+----------------------------------------------------------------------------
//
// Function:  CmStripPathAndExtW
//
// Synopsis:  Helper function, strips path and extension from a filename path
//
// Arguments: pszFileName - the filename path to be modified
//
// Returns:   LPWSTR - The base filename sub-string
//
// History:   nickball    Created header   8/12/98
//            nickball    Moved to cmutil   02/21/99
//            quintinb    Added W and A versions 03/09/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStripPathAndExtW(LPCWSTR pszFileName) 
{
    MYDBGASSERT(pszFileName);

    if (NULL == pszFileName)
    {
        return NULL;
    }

    MYDBGASSERT(*pszFileName);
    
    //
    // Make a copy of the string and validate format "\\." required.
    //

    LPWSTR pszTmp = CmStrCpyAllocW(pszFileName);

    if (NULL == pszTmp)
    {
        MYDBGASSERT(FALSE);
        return NULL;
    }

    LPWSTR pszDot = CmStrrchrW(pszTmp, L'.');
    LPWSTR pszSlash = CmStrrchrW(pszTmp, L'\\');

    if (NULL == pszDot || NULL == pszSlash || pszDot < pszSlash)
    {
        CmFree(pszTmp);
        MYDBGASSERT(FALSE);
        return NULL;
    }
    
    *pszDot = L'\0';
   
    //
    // Increment past slash and copy remainder
    //

    pszSlash = CharNextU(pszSlash);       
        
    lstrcpyU(pszTmp, pszSlash);

    return (pszTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CmStripFileNameA
//
// Synopsis:  Helper function to deal with the tedium of extracting the path 
//            part of a complete filename.
//
// Arguments: LPCSTR pszFullNameAndPath - Ptr to the filename 
//            BOOL fKeepSlash - Flag indicating that trailing directory '\' should be retained.
//
// Returns:   LPSTR - Ptr to an allocated buffer containing the dir, or NULL on failure.
//
// Note:      It is up to the caller to provide reasonable input, the only requirement
//            is that the input contain '\'. 
//
// History:   nickball    Created           3/10/98
//            nickball    Moved to cmutil   02/21/99
//            quintinb    Added W and A versions 03/09/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStripFileNameA(LPCSTR pszFullNameAndPath, BOOL fKeepSlash)
{
    MYDBGASSERT(pszFullNameAndPath);

    if (NULL == pszFullNameAndPath)
    {
        return NULL;
    }

    //
    // Make a copy of the filename and locate the last '\'
    //
    
    LPSTR pszTmp = CmStrCpyAllocA(pszFullNameAndPath);
    
    if (NULL == pszTmp)
    {
        CMASSERTMSG(NULL, "CmStripFileNameA -- CmStrCpyAllocA returned a NULL pointer for pszTmp");
        return NULL;
    }

    LPSTR pszSlash = CmStrrchrA(pszTmp, '\\');

    if (NULL == pszSlash)
    {
        MYDBGASSERT(FALSE);
        CmFree(pszTmp);
        return NULL;
    }

    //
    // If slash is desired, move to next char before truncating
    //

    if (fKeepSlash)
    {
        pszSlash = CharNextA(pszSlash);
    }

    *pszSlash = '\0';

    return pszTmp;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStripFileNameW
//
// Synopsis:  Helper function to deal with the tedium of extracting the path 
//            part of a complete filename.
//
// Arguments: LPCWSTR pszFullNameAndPath - Ptr to the filename 
//            BOOL fKeepSlash - Flag indicating that trailing directory '\' should be retained.
//
// Returns:   LPWSTR - Ptr to an allocated buffer containing the dir, or NULL on failure.
//
// Note:      It is up to the caller to provide reasonable input, the only requirement
//            is that the input contain '\'. 
//
// History:   nickball    Created           3/10/98
//            nickball    Moved to cmutil   02/21/99
//            quintinb    Added W and A versions 03/09/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStripFileNameW(LPCWSTR pszFullNameAndPath, BOOL fKeepSlash)
{
    MYDBGASSERT(pszFullNameAndPath);

    if (NULL == pszFullNameAndPath)
    {
        return NULL;
    }

    //
    // Make a copy of the filename and locate the last '\'
    //
    
    LPWSTR pszTmp = CmStrCpyAllocW(pszFullNameAndPath); 
    
    if (NULL == pszTmp)
    {
        CMASSERTMSG(NULL, "CmStripFileNameW -- CmStrCpyAllocW returned a NULL pointer for pszTmp");
        return NULL;
    }

    LPWSTR pszSlash = CmStrrchrW(pszTmp, L'\\');

    if (NULL == pszSlash)
    {
        MYDBGASSERT(FALSE);
        CmFree(pszTmp);
        return NULL;
    }

    //
    // If slash is desired, move to next char before truncating
    //

    if (fKeepSlash)
    {
        pszSlash = CharNextU(pszSlash);
    }

    *pszSlash = L'\0';

    return pszTmp;
}

//+----------------------------------------------------------------------------
//
// Function:  CmBuildFullPathFromRelativeA
//
// Synopsis:  Builds a full path by stripping the filename from pszFullFileName
//            and appending pszRelative.
//
// Arguments: LPCSTR pszFullFileName - A full path and filename
//            LPCSTR pszRelative - Relative path fragment. 
//
//            Typically used to construct a full path to a file in the profile directory
//            based upon the path to the .CMP file.
//
// Returns:   LPSTR - Ptr to the completed path which must be freed by the caller.
//
// Note:      pszRelative must NOT contain a leading "\"
//
// History:   nickball    Created           03/08/98
//            nickball    Moved to cmutil   02/21/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmBuildFullPathFromRelativeA(LPCSTR pszFullFileName,
    LPCSTR pszRelative)
{
    MYDBGASSERT(pszFullFileName);
    MYDBGASSERT(pszRelative);

    //
    // Check assumptions
    //

    if (NULL == pszFullFileName || NULL == pszRelative)
    {
        return NULL;
    }

    //
    // No empty strings please
    //

    MYDBGASSERT(*pszFullFileName);       
    MYDBGASSERT(*pszRelative);
    MYDBGASSERT(pszRelative[0] != '\\');

    //
    // Get the directory name including trailing '\'
    //
    
    LPSTR pszFull = NULL;
    LPSTR pszProfile = CmStripFileNameA(pszFullFileName, TRUE);

    if (pszProfile && *pszProfile)
    {
        pszFull = (LPSTR) CmMalloc(lstrlenA(pszProfile) + lstrlenA(pszRelative) + sizeof(CHAR));
    
        MYDBGASSERT(pszFull);

        if (pszFull)
        {           
            //
            // Build the complete path with new relative extension
            //

            lstrcpyA(pszFull, pszProfile);
            lstrcatA(pszFull, pszRelative);
        }   
    }
    
    CmFree(pszProfile);

    return pszFull;
}

//+----------------------------------------------------------------------------
//
// Function:  CmBuildFullPathFromRelativeW
//
// Synopsis:  Builds a full path by stripping the filename from pszFullFileName
//            and appending pszRelative.
//
// Arguments: LPWTSTR pszFullFileName - A full path and filename
//            LPWTSTR pszRelative - Relative path fragment. 
//
//            Typically used to construct a full path to a file in the profile directory
//            based upon the path to the .CMP file.
//
// Returns:   LPWSTR - Ptr to the completed path which must be freed by the caller.
//
// Note:      pszRelative must NOT contain a leading "\"
//
// History:   nickball    Created    3/8/98
//            nickball    Moved to cmutil   02/21/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmBuildFullPathFromRelativeW(LPCWSTR pszFullFileName,
    LPCWSTR pszRelative)
{
    MYDBGASSERT(pszFullFileName);
    MYDBGASSERT(pszRelative);

    //
    // Check assumptions
    //

    if (NULL == pszFullFileName || NULL == pszRelative)
    {
        return NULL;
    }

    //
    // No empty strings please
    //

    MYDBGASSERT(*pszFullFileName);       
    MYDBGASSERT(*pszRelative);
    MYDBGASSERT(pszRelative[0] != L'\\');

    //
    // Get the directory name including trailing '\'
    //
    
    LPWSTR pszFull = NULL;
    LPWSTR pszProfile = CmStripFileNameW(pszFullFileName, TRUE);

    if (pszProfile && *pszProfile)
    {
        pszFull = (LPWSTR) CmMalloc((lstrlenU(pszProfile) + lstrlenU(pszRelative) + 1)*sizeof(WCHAR));
    
        MYDBGASSERT(pszFull);

        if (pszFull)
        {           
            //
            // Build the complete path with new relative extension
            //

            lstrcpyU(pszFull, pszProfile);
            lstrcatU(pszFull, pszRelative);
        }   
    }
    
    CmFree(pszProfile);

    return pszFull;
}

//+-----------------------------------------------------------------------------------------
// Function: CmWinHelp
//
// Synopsis: Calls Winhelp using the command line parameters
//
// Arguments: See winhelp documentation
//              hWndItem - This is a additional parameter we use to designate the window/control for
//                          which help(context) is needed.
// Returns: TRUE if help was launched successfully otherwise FALSE
//
// Notes:
//
// History: v-vijayb 7/10/99
//
//+-----------------------------------------------------------------------------------------

CMUTILAPI BOOL CmWinHelp(HWND hWndMain, HWND hWndItem, CONST WCHAR *lpszHelp, UINT uCommand, ULONG_PTR dwData)
{
    DWORD   cb;
    TCHAR   szName[MAX_PATH];
    HDESK   hDesk = GetThreadDesktop(GetCurrentThreadId());
    BOOL    fRun = FALSE;
    DWORD   *prgWinIdHelpId = (DWORD *) dwData;

    //
    // Get the name of the desktop. Normally returns default or Winlogon or system or WinNT
    // On Win95/98 GetUserObjectInformation is not supported and thus the desktop name
    // will be empty so we will use the good old help API
    //  
    szName[0] = 0;
    GetUserObjectInformation(hDesk, UOI_NAME, szName, sizeof(szName), &cb);
    CMTRACE1(TEXT("Desktop = %s"), szName);
    if (lstrcmpi(TEXT("Winlogon"), szName) == 0)
    {
        return FALSE;
/*
        STARTUPINFOW         StartupInfo;
        PROCESS_INFORMATION ProcessInfo;
        WCHAR szCommandLine[MAX_PATH+1];

        //
        // Launch winhelp
        //

        ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.lpDesktop = L"Winsta0\\Winlogon";
        StartupInfo.wShowWindow = SW_SHOW;

        ZeroMemory(&szCommandLine, sizeof(szCommandLine));

        lstrcpyU(szCommandLine, L"winhlp32.exe ");
        
        switch (uCommand)
        {
            case HELP_FORCEFILE:
                break;
            case HELP_QUIT:
                lstrcatU(szCommandLine, L"-G ");
                break;
            case HELP_WM_HELP:
            case HELP_CONTEXTMENU:
                {
                    DWORD       dwWinId;
                    WCHAR       szTemp[MAX_PATH];
                    
                    MYDBGASSERT(prgWinIdHelpId);
                    dwWinId = GetWindowLong(hWndItem, GWL_ID);
                    // 
                    // Check if user press right click on a valid window.
                    // If not abort
                    //
                    if (dwWinId == 0)
                    {
                        return (fRun);
                    }

                    // Find the context help Id
                    while (*prgWinIdHelpId != 0)
                    {
                        if (*prgWinIdHelpId == dwWinId)
                        {
                            prgWinIdHelpId ++;
                            wsprintfW(szTemp, L"-P -N %d ", *prgWinIdHelpId);
                            lstrcatU(szCommandLine, szTemp);
                            break;
                        }
                        
                        // One for window id & one for help id
                        prgWinIdHelpId ++;
                        prgWinIdHelpId ++;
                    }
                }
                break;
            default:
                CMTRACE1(TEXT("CMWinHelp Invalid uCommand = %d"), uCommand);
            break;
        }

        if (lpszHelp)
        {
            lstrcatU(szCommandLine, lpszHelp);
        }
        
        CMTRACE1(TEXT("Help() - Launching %s"), szCommandLine);

        if (NULL == CreateProcessU(NULL, szCommandLine, 
                                    NULL, NULL, FALSE, 0, 
                                    NULL, NULL,
                                    &StartupInfo, &ProcessInfo))
        {
            LONG    lRes;

            lRes = GetLastError();
            CMTRACE2(TEXT("CMWinHelp CreateProcess() of %s failed, GLE=%u."), szCommandLine, lRes);
        }
        else
        {
            CloseHandle(ProcessInfo.hProcess);
            CloseHandle(ProcessInfo.hThread);
            fRun = TRUE;
        }
*/
    }
    else
    {
        fRun = WinHelpU(hWndMain, lpszHelp, uCommand, (ULONG_PTR) prgWinIdHelpId);               
    }

    return (fRun);
}

//+----------------------------------------------------------------------------
//
// Function:  IsLogonAsSystem
//
// Synopsis:  Whether the current process is running in the system account
//
// Arguments: None
//
// Returns:   BOOL - TRUE if running in system account
//
// History:   fengsun Created Header    7/13/98
//            v-vijayb Modified to use SIDs instead of username 
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL IsLogonAsSystem()
{
    static BOOL fLogonAsSystem = -1;

    //
    // If this function has been called before, return the saved value.
    //

    if (fLogonAsSystem != -1)
    {
        return fLogonAsSystem;
    }

    //
    // Runs only under NT
    //

    if (OS_NT)
    {
        HANDLE          hProcess, hAccess;
        DWORD           cbTokenInfo, cbRetInfo;
        PTOKEN_USER     pTokenInfo;
        SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
        PSID            pSystemSID = NULL;

        //
        //  On NT, we pick the more stringent value for the default.
        //
        fLogonAsSystem = TRUE;
        
        if (AllocateAndInitializeSid(&SIDAuthNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSystemSID))
        {
            hProcess = GetCurrentProcess();     // Pseudo handle, no need to close
            if (OpenProcessToken(hProcess, TOKEN_READ, &hAccess))
            {
                BOOL bRet = GetTokenInformation(hAccess, TokenUser, NULL, 0, &cbRetInfo);
                MYDBGASSERT((FALSE == bRet) && (0 != cbRetInfo));

                if (cbRetInfo)
                {
                    cbTokenInfo = cbRetInfo;
                    pTokenInfo = (PTOKEN_USER) CmMalloc( cbTokenInfo * sizeof(BYTE) );
                    if (pTokenInfo)
                    {
                        if (GetTokenInformation(hAccess, TokenUser, (PVOID) pTokenInfo, cbTokenInfo, &cbRetInfo))
                        {
                            if (EqualSid(pTokenInfo->User.Sid, pSystemSID))
                            {
                                CMTRACE(TEXT("Running under LOCALSYSTEM account"));
                                fLogonAsSystem = TRUE;
                            }
                            else
                            {
                                fLogonAsSystem = FALSE;
                            }
                        }
                        CmFree(pTokenInfo);
                    }
                }
                CloseHandle(hAccess);                   
            }
            
            FreeSid(pSystemSID);
        }
    }
    else
    {
        fLogonAsSystem = FALSE;
    }
    
    return fLogonAsSystem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmutil\strings.cpp ===
//+----------------------------------------------------------------------------
//
// File:     strings.cpp
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Basic string manipulation routines
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"


//+----------------------------------------------------------------------------
//
// Function:  WzToSz
//
// Synopsis:  Standard conversion function for converting Wide Characters to
//            Ansi Characters
//
// Arguments: IN LPCWSTR pszwStrIn - Input Unicode string
//            OUT LPSTR pszStrOut - Ansi Ouput Buffer
//            IN int nOutBufferSize - number of Chars in pszStrOut
//
// Returns:   int - 0 on failure, if return Value is > nOutBufferSize then the
//                  buffer is too small.  Otherwise the number of chars copied
//                  to pszStrOut.
//
// History:   Created Header    4/22/99
//
//+----------------------------------------------------------------------------
CMUTILAPI int WzToSz(IN LPCWSTR pszwStrIn, OUT LPSTR pszStrOut, IN int nOutBufferSize)
{
    int nReturn = 0;

    //
    //  nOutBufferSize could be 0 and pszStrOut could be NULL (passing zero size and a NULL out
    //  buffer causes WideCharToMultiByte to return the number of chars needed to convert the
    //  input string.  It is used as a sizing technique).  Only check pszwStrIn
    //

    if (pszwStrIn)
    {
        nReturn = WideCharToMultiByte(CP_ACP, 0, pszwStrIn, -1, pszStrOut, nOutBufferSize, NULL, NULL);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return nReturn; 
}

//+----------------------------------------------------------------------------
//
// Function:  SzToWz
//
// Synopsis:  Standard Wrapper for converting from an Ansi string to a Wide String
//
// Arguments: IN LPCSTR pszInput - Ansi String to Convert
//            OUT LPWSTR pszwOutput - Wide string output buffer
//            IN int nBufferSize - number of chars in Wide String buffer
//
// Returns:   int - 0 on failure, otherwise if return is < nBufferSize then insufficient
//                  buffer space.  Otherwise the number of chars copied to the buffer.
//
// History:   quintinb Created  4/22/99
//
//+----------------------------------------------------------------------------
CMUTILAPI int SzToWz(IN LPCSTR pszInput, OUT LPWSTR pszwOutput, IN int nBufferSize)
{
    int nReturn = 0;

    if (pszInput)
    {
        return MultiByteToWideChar(CP_ACP, 0, pszInput, -1, pszwOutput, nBufferSize);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return nReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SzToWzWithAlloc
//
// Synopsis:  Simple wrapper to encapsulate converting a string from
//            MultiByte To Wide Char that Allocates memory using the sizing
//            capabilities of the MultiByteToWideChar Api.
//
// Arguments: LPCSTR pszAnsiString - Source string to be converted.
//
// Returns:   LPWSTR - returns NULL on failure, otherwise the converted string.
//                     The caller is responsible for freeing the Alloc-ed Memory.
//
// History:   quintinb Created    4/8/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR SzToWzWithAlloc(LPCSTR pszAnsiString)
{    
    LPWSTR pszwString = NULL;
        
    //
    //  Find out how large the string is by calling MultiByteToWideChar with
    //  Zero for the size field.
    //
    if (NULL != pszAnsiString)
    {
        DWORD dwSize = SzToWz(pszAnsiString, NULL, 0);
        
        CMASSERTMSG((dwSize != 0), TEXT("SzToWzWithAlloc -- First MultiByteToWideChar Failed."));
        
        if (0 != dwSize)
        {
            pszwString = (LPWSTR)CmMalloc(dwSize*sizeof(WCHAR));

            CMASSERTMSG(pszwString, TEXT("SzToWzWithAlloc -- CmMalloc of pszwString Failed."));

            if (pszwString)
            {
                if (!SzToWz(pszAnsiString, pszwString, dwSize))
                {
                    //
                    //  Make sure to return a NULL string if we fail.
                    //
                    CMASSERTMSG(FALSE, TEXT("SzToWzWithAlloc -- Second MultiByteToWideChar Failed."));
                    CmFree(pszwString);
                    pszwString = NULL;
                }
#ifdef DEBUG
                else
                {
                    //
                    //  If this is a debug build then we want to take the Wide string that we are going to
                    //  return, convert it to Ansi and compare it to the original ansi string passed in.
                    //
                    LPSTR pszString;
                    DWORD dwSize = WzToSz(pszwString, NULL, 0);

                    if (0 != dwSize)
                    {
                        pszString = (LPSTR)CmMalloc(dwSize*sizeof(CHAR));
                        CMASSERTMSG(pszString, TEXT("SzToWzWithAlloc -- conversion of return value back to original Ansi string failed.  Unable to allocate memory."));

                        if (pszString)
                        {
                            if (WzToSz(pszwString, pszString, dwSize))
                            {
                                MYDBGASSERT(0 == lstrcmpA(pszString, pszAnsiString));
                            }
                            else
                            {
                                CMASSERTMSG(FALSE, TEXT("SzToWzWithAlloc -- conversion of return value back to original Ansi string failed."));
                            }
                            CmFree(pszString);
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("SzToWzWithAlloc -- conversion of return value back to original Ansi string failed.  Unable to properly size the string."));                        
                    }
  
                }
#endif
            }
        }
    }

    return pszwString;
}

//+----------------------------------------------------------------------------
//
// Function:  WzToSzWithAlloc
//
// Synopsis:  Simple wrapper to encapsulate converting a string from
//            Unicode to MBCS that allocates memory using the sizing
//            capabilities of the WideCharToMultiByte Api.
//
// Arguments: LPCWSTR pszwWideString - Source string to be converted.
//
// Returns:   LPSTR - returns NULL on failure, otherwise the converted string.
//                     The caller is responsible for freeing the Alloc-ed Memory.
//
// History:   quintinb Created    4/8/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR WzToSzWithAlloc(LPCWSTR pszwWideString)
{    
    LPSTR pszString = NULL;
        
    //
    //  Find out how large the string is by calling WideCharToMultiByte with
    //  Zero for the size field.
    //
    if (NULL != pszwWideString)
    {
        DWORD dwSize = WzToSz(pszwWideString, NULL, 0);

        CMASSERTMSG((0 != dwSize), TEXT("WzToSzWithAlloc -- First WzToSz Failed."));

        if (0 != dwSize)
        {
            pszString = (LPSTR)CmMalloc(dwSize*sizeof(CHAR));

            CMASSERTMSG(pszString, TEXT("WzToSzWithAlloc -- CmMalloc failed to alloc pszString."));

            if (pszString)
            {
                if (!WzToSz(pszwWideString, pszString, dwSize))
                {
                    //
                    //  Make sure to return a NULL string if we fail.
                    //
                    CMASSERTMSG(FALSE, TEXT("WzToSzWithAlloc -- Second WzToSz Failed."));
                    CmFree(pszString);
                    pszString = NULL;
                }
#ifdef DEBUG
                else
                {
                    //
                    //  If this is a debug build then we want to take the Ansi string that we are 
                    //  going to return, convert it to Unicode and compare it to the original Unicode 
                    //  string passed in.
                    //
                    LPWSTR pszwString;
                    DWORD dwSize = SzToWz(pszString, NULL, 0);
        
                    if (0 != dwSize)
                    {
                        pszwString = (LPWSTR)CmMalloc(dwSize*sizeof(WCHAR));

                        CMASSERTMSG(pszwString, TEXT("WzToSzWithAlloc -- conversion of return value back to original Ansi string failed.  Unable to allocate memory."));

                        if (pszwString)
                        {
                            if (SzToWz(pszString, pszwString, dwSize))
                            {
                                MYDBGASSERT(0 == lstrcmpU(pszwString, pszwWideString));
                            }
                            else
                            {
                                CMASSERTMSG(FALSE, TEXT("WzToSzWithAlloc -- conversion of return value back to original Ansi string failed."));
                            }
                            CmFree(pszwString);
                        }
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("WzToSzWithAlloc -- conversion of return value back to original Ansi string failed.  Unable to properly size the string."));                        
                    }
                }
#endif
            }
        }
    }

    return pszString;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrTrimA
//
// Synopsis:  Helper function to trim leading and trailing blanks from a
//            string
//
// Arguments: LPTSTR pszStr - The string to be trimmed
//
// Returns:   void WINAPI - Nothing
//
// History:   nickball    Created Header   3/11/98
//
//+----------------------------------------------------------------------------
CMUTILAPI void WINAPI CmStrTrimA(LPSTR pszStr) 
{
    //
    // first, skip all the spaces at the begining of the string
    //
    MYDBGASSERT(pszStr);       

    if (pszStr)
    {
        LPSTR pszTmp = pszStr;

        while (CmIsSpaceA(pszTmp)) 
        {
            pszTmp = CharNextA(pszTmp);
        }
        
        if (pszTmp != pszStr) 
        {
            CmMoveMemory(pszStr, pszTmp, lstrlenA(pszTmp)+1);
        }

        //
        // secondly, delete all the spaces at the end of the string
        //
    
        pszTmp = CmEndOfStrA(pszStr);
        while (pszTmp != pszStr) 
        {
            pszTmp = CharPrevA(pszStr, pszTmp);
            if (!CmIsSpaceA(pszTmp)) 
            {
                break;
            }
            *pszTmp = TEXT('\0');
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrTrimW
//
// Synopsis:  Helper function to trim leading and trailing blanks from a
//            string. 
//
// Arguments: LPTSTR pszStr - The string to be trimmed
//
// Returns:   void WINAPI - Nothing
//
// History:   quintinb    Created   2/27/99
//
//+----------------------------------------------------------------------------
CMUTILAPI void WINAPI CmStrTrimW(LPWSTR pszStr)
{  
    //
    // first, skip all the spaces at the begining of the string
    //

    MYDBGASSERT(pszStr);

    if (pszStr)
    {
        LPWSTR pszTmp = pszStr;

        while (CmIsSpaceW(pszTmp)) 
        {
            pszTmp = CharNextU(pszTmp);
        }

        if (pszTmp != pszStr) 
        {
            CmMoveMemory(pszStr, pszTmp, (lstrlenU(pszTmp)+1)*sizeof(WCHAR));
        }

        //
        // secondly, delete all the spaces at the end of the string
        //
    
        pszTmp = CmEndOfStrW(pszStr);

        while (pszTmp != pszStr) 
        {
            pszTmp = CharPrevU(pszStr, pszTmp);

            if (!CmIsSpaceW(pszTmp)) 
            {
                break;
            }

            *pszTmp = TEXT('\0');
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CmIsSpaceA
//
// Synopsis:  Checks to see if the char is a space.  Note that spaces, new line chars,
//            line feed chars, tabs, and most other forms of whitespace are considered
//            spaces.
//
// Arguments: psz - an ansi or dbcs char
//
// Returns:   TRUE or FALSE
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL WINAPI CmIsSpaceA(LPSTR psz) 
{    
    WORD wType = 0;

    MYDBGASSERT(psz);

    if (psz)
    {
        if (IsDBCSLeadByte(*psz))
        {
            MYVERIFY(GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
        }
        else
        {
            MYVERIFY(GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
        }
    }

    return (wType & C1_SPACE);
}

//+----------------------------------------------------------------------------
//
// Function:  CmIsSpaceW
//
// Synopsis:  Checks to see if the char is a space.  Note that spaces, new line chars,
//            line feed chars, tabs, and most other forms of whitespace are considered
//            spaces.
//
// Arguments: psz - pointer to a string
//
// Returns:   TRUE or FALSE
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL WINAPI CmIsSpaceW(LPWSTR pszwStr)
{
    WORD wType = 0;
    LPWSTR pszwNextChar;
    int iCharCount;

    MYDBGASSERT(pszwStr);

    if (pszwStr)
    {
        pszwNextChar = CharNextU(pszwStr);

        iCharCount = (INT)(pszwNextChar - pszwStr);

        if (0 == GetStringTypeExU(LOCALE_USER_DEFAULT, CT_CTYPE1, pszwStr, iCharCount, &wType))
        {
            CMTRACE3(TEXT("CmIsSpaceW -- GetStringTypeExW failed on %s, iCharCount is %d, GLE=%u"), pszwStr, iCharCount, GetLastError());
            return FALSE;
        }
    }
    
    return (wType & C1_SPACE);
}

//+----------------------------------------------------------------------------
//
// Function:  CmIsDigitA
//
// Synopsis:  Checks to see if the char is a digit.
//
// Arguments: psz - an ansi or dbcs char
//
// Returns:   TRUE or FALSE
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL WINAPI CmIsDigitA(LPSTR psz) 
{
    WORD wType = 0;

    MYDBGASSERT(psz);

    if (psz)
    {
        if (IsDBCSLeadByte(*psz))
        {
            MYVERIFY(GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
        }
        else
        {
            MYVERIFY(GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
        }
    }

    return (wType & C1_DIGIT);
}

//+----------------------------------------------------------------------------
//
// Function:  CmIsDigitW
//
// Synopsis:  Checks to see if the WCHAR is a digit.
//
// Arguments: pszwStr -- WCHAR string
//
// Returns:   TRUE or FALSE
//
//+----------------------------------------------------------------------------
CMUTILAPI BOOL WINAPI CmIsDigitW(LPWSTR pszwStr)
{
    WORD wType = 0;
    LPWSTR pszwNextChar;
    int iCharCount;

    MYDBGASSERT(pszwStr);

    if (pszwStr)
    {
        pszwNextChar = CharNextU(pszwStr);

        iCharCount = (INT)(pszwNextChar - pszwStr);

        if (0 == GetStringTypeExU(LOCALE_USER_DEFAULT, CT_CTYPE1, pszwStr, iCharCount, &wType))
        {
            CMTRACE1(TEXT("CmIsDigitW -- GetStringTypeExU failed, GLE=%u"), GetLastError());
            return FALSE;
        }
    }

    return (wType & C1_DIGIT);
}


//+----------------------------------------------------------------------------
//
// Function:  CmEndOfStrA
//
// Synopsis:  Given a string, returns the ptr to the end of the string(null char).
//
// Arguments: psz - an ansi or dbcs char
//
// Returns:   LPSTR    ptr to null char
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR WINAPI CmEndOfStrA(LPSTR psz) 
{
    MYDBGASSERT(psz);

    if (psz)
    {
        while (*psz)
        {
            psz = CharNextA(psz);
        }
    }

    return psz;
}

//+----------------------------------------------------------------------------
//
// Function:  CmEndOfStrW
//
// Synopsis:  Given a string, returns the ptr to the end of the string(null char).
//
// Arguments: pszwStr - a WCHAR
//
// Returns:   LPWSTR    ptr to null char
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR WINAPI CmEndOfStrW(LPWSTR pszwStr)
{
    MYDBGASSERT(pszwStr);

    if (pszwStr)
    {
        while (*pszwStr)
        {
            pszwStr = CharNextU(pszwStr);
        }
    }

    return pszwStr;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrCpyAllocA
//
// Synopsis:  Copies pszSrc into a newly allocated buffer (using CmMalloc) and
//            returns the buffer to its caller who is responsible for freeing
//            the buffer.
//
// Arguments: LPCSTR pszSrc - source string
//
// Returns:   LPSTR - returns NULL if pszSrc is NULL or the Alloc fails,
//                     otherwise it returns the newly allocated buffer with
//                     a copy of pszSrc in it.
//
// History:   quintinb  Created Header and changed name to include Alloc   4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStrCpyAllocA(LPCSTR pszSrc) 
{
    LPSTR pszBuffer = NULL;

    if (pszSrc)
    {
        pszBuffer = (LPSTR) CmMalloc(lstrlenA(pszSrc) + 1);

        if (pszBuffer) 
        {
            lstrcpyA(pszBuffer, pszSrc);
        }
    }

    return (pszBuffer);
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrCpyAllocW
//
// Synopsis:  Copies pszSrc into a newly allocated buffer (using CmMalloc) and
//            returns the buffer to its caller who is responsible for freeing
//            the buffer.
//
// Arguments: LPCSTR pszSrc - source string
//
// Returns:   LPSTR - returns NULL if pszSrc is NULL or the Alloc fails,
//                    otherwise it returns the newly allocated buffer with
//                    a copy of pszSrc in it.
//
// History:   quintinb  Created Header and changed name to include Alloc   4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrCpyAllocW(LPCWSTR pszSrc) 
{
    LPWSTR pszBuffer = NULL;

    if (pszSrc)
    {
        size_t nLen = lstrlenU(pszSrc) + 1;

        pszBuffer = (LPWSTR) CmMalloc(nLen*sizeof(WCHAR));

        if (pszBuffer) 
        {
            lstrcpyU(pszBuffer, pszSrc);
        }
    }

    return (pszBuffer);
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrCatAllocA
//
// Synopsis:  This function reallocs the passed in string to a size large enough
//            to hold the original data and the concatenates the new string onto
//            the original string.
//
// Arguments: LPSTR *ppszDst - original string
//            LPCSTR pszSrc - new piece of string to concatenate
//
// Returns:   LPSTR - pointer to the concatenated string
//
// History:   quintinb Created Header    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStrCatAllocA(LPSTR *ppszDst, LPCSTR pszSrc) 
{
    if (!ppszDst) 
    {
        return NULL;
    }

    if (pszSrc && *pszSrc) 
    {
        DWORD dwSize = (lstrlenA(*ppszDst) + lstrlenA(pszSrc) + 1);
        LPSTR pszTmp = (LPSTR)CmRealloc((LPVOID)*ppszDst, dwSize);

        if (NULL != pszTmp)
        {
            lstrcatA(pszTmp, pszSrc);
            *ppszDst = pszTmp;
        }
    }

    return (*ppszDst);
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrCatAllocW
//
// Synopsis:  This function reallocs the passed in string to a size large enough
//            to hold the original data and the concatenates the new string onto
//            the original string.
//
// Arguments: LPWSTR *ppszDst - original string
//            LPCWSTR pszSrc - new piece of string to concatenate
//
// Returns:   LPWSTR - pointer to the concatenated string
//
// History:   quintinb Created Header    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrCatAllocW(LPWSTR *ppszDst, LPCWSTR pszSrc) 
{
    if (!ppszDst) 
    {
        return NULL;
    }

    if (pszSrc && *pszSrc) 
    {
        DWORD dwSize = (lstrlenU(*ppszDst) + lstrlenU(pszSrc) + 1)*sizeof(WCHAR);
        LPWSTR pszTmp = (LPWSTR)CmRealloc((LPVOID)*ppszDst, dwSize);

        if (NULL != pszTmp)
        {
            lstrcatU(pszTmp, pszSrc);
            *ppszDst = pszTmp;
        }
    }

    return (*ppszDst);
}


//+----------------------------------------------------------------------------
//
// Function:  CmStrchrA
//
// Synopsis:  This function returns the first occurence of ch in the string pszString.
//
// Arguments: LPCSTR pszString - String to search in
//            CHAR ch - character to look for
//
// Returns:   LPSTR - pointer to the first occurence of the Character ch in pszString
//
// History:   quintinb Created Header    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR WINAPI CmStrchrA(LPCSTR pszString, const char ch)
{
    LPSTR pszTmp = (LPSTR)pszString;

    if (NULL == pszTmp)
    {
        CMASSERTMSG(FALSE, TEXT("CmStrchr - NULL pointer passed"));
        return NULL;
    }

    while (*pszTmp && (*pszTmp != ch))
    {
        pszTmp = CharNextA(pszTmp);
    }

    if (*pszTmp == ch)
    {
        return pszTmp;
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrchrW
//
// Synopsis:  This function returns the first occurence of ch in the string pszString.
//
// Arguments: LPCWSTR pszString - String to search in
//            WCHAR ch - character to look for
//
// Returns:   LPWSTR - pointer to the first occurence of the Character ch in pszString
//
// History:   quintinb Created Header    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR WINAPI CmStrchrW(LPCWSTR pszString, const WCHAR ch)
{
    LPWSTR pszTmp = (LPWSTR)pszString;

    if (NULL == pszTmp)
    {
        CMASSERTMSG(FALSE, TEXT("CmStrchr - NULL pointer passed"));
        return NULL;
    }

    while (*pszTmp && (*pszTmp != ch))
    {
        pszTmp = CharNextU(pszTmp);
    }

    if (*pszTmp == ch)
    {
        return pszTmp;
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrrchrA 
//
// Synopsis:  Find the last occurence of a character in a string
//
// Arguments: LPCSTR pszString - string to search in
//            CHAR ch - character to look for
//
// Returns:   LPSTR - NULL if the char is not found, a pointer to the char in
//                    the string otherwise
//
// History:   quintinb Created Header and cleaned up    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStrrchrA (LPCSTR pszString, const char ch)
{
    LPSTR pszTmp = NULL;
    LPSTR pszCurrent = (LPSTR)pszString;
    
    if (NULL == pszString)
    {
        CMASSERTMSG(FALSE, TEXT("CmStrrchr - NULL pointer passed"));
    }
    else
    {
        while (TEXT('\0') != *pszCurrent)
        {
            if (ch == (*pszCurrent))
            {
                pszTmp = pszCurrent;
            }
            pszCurrent = CharNextA(pszCurrent);
        }    
    }

    return pszTmp;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrrchrW
//
// Synopsis:  Find the last occurence of a character in a string
//
// Arguments: LPCWSTR pszString - string to search in
//            WCHAR ch - character to look for
//
// Returns:   LPWSTR - NULL if the char is not found, a pointer to the char in
//                     the string otherwise
//
// History:   quintinb Created Header and cleaned up    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrrchrW (LPCWSTR pszString, const WCHAR ch)
{
    LPWSTR pszTmp = NULL;
    LPWSTR pszCurrent = (LPWSTR)pszString;

    if (NULL == pszString)
    {
        CMASSERTMSG(FALSE, TEXT("CmStrrchr - NULL pointer passed"));
    }
    else
    {
        while (TEXT('\0') != *pszCurrent)
        {
            if (ch == (*pszCurrent))
            {
                pszTmp = pszCurrent;
            }
            pszCurrent = CharNextU(pszCurrent);
        }    
    }

    return pszTmp;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrtokA
//
// Synopsis:  CM implementation of strtok
//
// Arguments: LPSTR pszStr - string to tokenize or NULL if getting a second token
//            LPCSTR pszControl - set of token chars
//
// Returns:   LPSTR - NULL if no token could be found or a pointer to a token string.
//
// History:   quintinb Created Header and cleaned up for UNICODE conversion    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStrtokA(LPSTR pszStr, LPCSTR pszControl)
{
    LPSTR pszToken;
    LPSTR pszTmpStr;
    LPCSTR pszTmpCtl;
    LPSTR pszTmpDelim;
    

    //
    //  If the pszStr param is NULL, then we need to retrieve the stored string
    //
    if (NULL != pszStr)
    {
        pszTmpStr = pszStr;
    }
    else
    {
        pszTmpStr = (LPSTR)TlsGetValue(g_dwTlsIndex);
    }

    //
    //  Find beginning of token (skip over leading delimiters). Note that
    //  there is no token if this loop sets string to point to the terminal
    //  null (*string == '\0') 
    //
    while (*pszTmpStr)
    {
        for (pszTmpCtl = pszControl; *pszTmpCtl && *pszTmpCtl != *pszTmpStr; 
             pszTmpCtl = CharNextA(pszTmpCtl))
        {
            ; // do nothing
        }

        if (!*pszTmpCtl)
        {
            break;
        }

        pszTmpStr = CharNextA(pszTmpStr);
    }

    pszToken = pszTmpStr;

    //
    //  Find the end of the token. If it is not the end of the string,
    //  put a null there.
    //
    for ( ; *pszTmpStr ; pszTmpStr = CharNextA(pszTmpStr))
    {
        for (pszTmpCtl = pszControl; *pszTmpCtl && *pszTmpCtl != *pszTmpStr; 
             pszTmpCtl = CharNextA(pszTmpCtl))
        {
            ;   // Do nothing
        }

        if (*pszTmpCtl)
        {
            pszTmpDelim = pszTmpStr;
            pszTmpStr = CharNextA(pszTmpStr);
            *pszTmpDelim = '\0';
            break;
        }
    }

    //
    // Update nextoken (or the corresponding field in the per-thread data structure
    //
    TlsSetValue(g_dwTlsIndex, (LPVOID)pszTmpStr);

    //
    // Determine if a token has been found.
    //
    if (pszToken == pszTmpStr)
    {
        return NULL;
    }
    else
    {
        return pszToken;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrtokW
//
// Synopsis:  CM implementation of strtok
//
// Arguments: LPWSTR pszStr - string to tokenize or NULL if getting a second tokey
//            LPCWSTR pszControl - set of token chars
//
// Returns:   LPWSTR - NULL if no token could be found or a pointer to a token string.
//
// History:   quintinb Created Header and cleaned up for UNICODE conversion    4/9/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrtokW(LPWSTR pszStr, LPCWSTR pszControl)
{
    LPWSTR pszToken;
    LPWSTR pszTmpStr;
    LPWSTR pszTmpCtl;
    LPWSTR pszTmpDelim;

    //
    //  If the pszStr param is NULL, then we need to retrieve the stored string
    //
    if (NULL != pszStr)
    {
        pszTmpStr = pszStr;
    }
    else
    {
        pszTmpStr = (LPWSTR)TlsGetValue(g_dwTlsIndex);
    }

    //
    //  Find beginning of token (skip over leading delimiters). Note that
    //  there is no token iff this loop sets string to point to the terminal
    //  null (*string == '\0') 
    //
    while (*pszTmpStr)
    {
        for (pszTmpCtl = (LPWSTR)pszControl; *pszTmpCtl && *pszTmpCtl != *pszTmpStr; 
             pszTmpCtl = CharNextU(pszTmpCtl))
        {
            ; // do nothing
        }

        if (!*pszTmpCtl)
        {
            break;
        }

        pszTmpStr = CharNextU(pszTmpStr);
    }

    pszToken = pszTmpStr;
    
    //
    //  Find the end of the token. If it is not the end of the string,
    //  put a null there.
    //
    for ( ; *pszTmpStr ; pszTmpStr = CharNextU(pszTmpStr))
    {
        for (pszTmpCtl = (LPWSTR)pszControl; *pszTmpCtl && *pszTmpCtl != *pszTmpStr; 
             pszTmpCtl = CharNextU(pszTmpCtl))
        {
            ;   // Do nothing
        }

        if (*pszTmpCtl)
        {
            pszTmpDelim = pszTmpStr;
            pszTmpStr = CharNextU(pszTmpStr);
            *pszTmpDelim = L'\0';
            break;
        }
    }

    //
    // Update nextoken (or the corresponding field in the per-thread data structure
    //
    TlsSetValue(g_dwTlsIndex, (LPVOID)pszTmpStr);

    //
    // Determine if a token has been found.
    //
    if (pszToken == pszTmpStr)
    {
        return NULL;
    }
    else
    {
        return pszToken;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrStrA
//
// Synopsis:  Simple replacement for StrStr from C runtime
//
// Arguments: LPCTSTR pszString - The string to search in
//            LPCTSTR pszSubString - The string to search for
//
// Returns:   LPTSTR - Ptr to the first occurence of pszSubString in pszString. 
//                    NULL if pszSubString does not occur in pszString
//
//
// History:   nickball    Created Header    04/01/98
//            nickball    Added ptr check   02/21/99
//            quintinb    rewrote for unicode conversion 04/08/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPSTR CmStrStrA(LPCSTR pszString, LPCSTR pszSubString)
{
    //
    //  Check the inputs
    //
    MYDBGASSERT(pszString);
    MYDBGASSERT(pszSubString);

    if (NULL == pszSubString || NULL == pszString)
    {
        return NULL;
    }

    //
    //  Check to make sure we have something to look for
    //
    if (TEXT('\0') == pszSubString[0])
    {
        return((LPSTR)pszString);
    }

    //
    //  Okay, start looking for the string
    //
    LPSTR pszCurrent = (LPSTR)pszString;
    LPSTR pszTmp1;
    LPSTR pszTmp2;

    while (*pszCurrent)
    {
        pszTmp1 = pszCurrent;
        pszTmp2 = (LPSTR) pszSubString;

        while (*pszTmp1 && *pszTmp2 && ((*pszTmp1) == (*pszTmp2)))
        {
            pszTmp1 = CharNextA(pszTmp1);
            pszTmp2 = CharNextA(pszTmp2);
        }

        if (TEXT('\0') == *pszTmp2)
        {        
            return pszCurrent;
        }

        pszCurrent = CharNextA(pszCurrent);
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CmStrStrW
//
// Synopsis:  Simple replacement for StrStr from C runtime
//
// Arguments: LPCTSTR pszString - The string to search in
//            LPCTSTR pszSubString - The string to search for
//
// Returns:   LPTSTR - Ptr to the first occurence of pszSubString in pszString. 
//                    NULL if pszSubString does not occur in pszString
//
//
// History:   nickball    Created Header    04/01/98
//            nickball    Added ptr check   02/21/99
//            quintinb    rewrote for unicode conversion 04/08/99
//
//+----------------------------------------------------------------------------
CMUTILAPI LPWSTR CmStrStrW(LPCWSTR pszString, LPCWSTR pszSubString)
{

    //
    //  Check the inputs
    //
    MYDBGASSERT(pszString);
    MYDBGASSERT(pszSubString);

    if (NULL == pszSubString || NULL == pszString)
    {
        return NULL;
    }

    //
    //  Check to make sure we have something to look for
    //
    if (TEXT('\0') == pszSubString[0])
    {
        return((LPWSTR)pszString);
    }

    //
    //  Okay, start looking for the string
    //
    LPWSTR pszCurrent = (LPWSTR)pszString;
    LPWSTR pszTmp1;
    LPWSTR pszTmp2;

    while (*pszCurrent)
    {
        pszTmp1 = pszCurrent;
        pszTmp2 = (LPWSTR) pszSubString;

        while (*pszTmp1 && *pszTmp2 && ((*pszTmp1) == (*pszTmp2)))
        {
            pszTmp1 = CharNextU(pszTmp1);
            pszTmp2 = CharNextU(pszTmp2);
        }

        if (TEXT('\0') == *pszTmp2)
        {        
            return pszCurrent;
        }

        pszCurrent = CharNextU(pszCurrent);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\export.cpp ===
//*******************************************************************
//
//  Copyright (c) 1996-1998 Microsoft Corporation
//
//  FILE: EXPORT.C
//
//  PURPOSE:  Contains external API's for use by signup wizard.
//
//  HISTORY:
//  96/03/05  markdu  Created.
//  96/03/11  markdu  Added InetConfigClient()
//  96/03/11  markdu  Added InetGetAutodial() and InetSetAutodial().
//  96/03/12  markdu  Added UI during file install.
//  96/03/12  markdu  Added ValidateConnectoidData().
//  96/03/12  markdu  Set connectoid for autodial if INETCFG_SETASAUTODIAL
//            is set.  Renamed ValidateConnectoidData to MakeConnectoid.
//  96/03/12  markdu  Added hwnd param to InetConfigClient() and
//            InetConfigSystem().
//  96/03/13  markdu  Added INETCFG_OVERWRITEENTRY.  Create unique neame
//            for connectoid if it already exists and we can't overwrite.
//  96/03/13  markdu  Added InstallTCPAndRNA().
//  96/03/13  markdu  Added LPINETCLIENTINFO param to InetConfigClient()
//  96/03/16  markdu  Added INETCFG_INSTALLMODEM flag.
//  96/03/16  markdu  Use ReInit member function to re-enumerate modems.
//  96/03/19  markdu  Split export.h into export.h and csexport.h
//  96/03/20  markdu  Combined export.h and iclient.h into inetcfg.h
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Replaced lstrcpy with lstrcpyn where appropriate.
//  96/03/25  markdu  Validate lpfNeedsRestart before using.
//  96/03/25  markdu  Clean up some error handling.
//  96/03/26  markdu  Use MAX_ISP_NAME instead of RAS_MaxEntryName 
//            because of bug in RNA.
//  96/03/26  markdu  Implemented UpdateMailSettings().
//  96/03/27  mmaclin InetGetProxy()and InetSetProxy().
//  96/04/04  markdu  NASH BUG 15610  Check for file and printer sharing
//            bound to TCP/IP .
//  96/04/04  markdu  Added phonebook name param to InetConfigClient,
//            MakeConnectoid, SetConnectoidUsername, CreateConnectoid,
//            and ValidateConnectoidName.
//  96/04/05  markdu  Set internet icon on desktop to point to browser.
//  96/04/06  mmaclin Changed InetSetProxy to check for NULL.
//  96/04/06  markdu  NASH BUG 16404 Initialize gpWizardState in
//            UpdateMailSettings.
//  96/04/06  markdu  NASH BUG 16441 If InetSetAutodial is called with NULL
//            as the connection name, the entry is not changed.
//  96/04/18  markdu  NASH BUG 18443 Make exports WINAPI.
//  96/04/19  markdu  NASH BUG 18605 Handle ERROR_FILE_NOT_FOUND return
//            from ValidateConnectoidName.
//  96/04/19  markdu  NASH BUG 17760 Do not show choose profile UI.
//  96/04/22  markdu  NASH BUG 18901 Do not set desktop internet icon to 
//            browser if we are just creating a temp connectoid.
//  96/04/23  markdu  NASH BUG 18719 Make the choose profile dialog TOPMOST.
//  96/04/25  markdu  NASH BUG 19572 Only show choose profile dialog if
//            there is an existing profile.
//  96/04/29  markdu  NASH BUG 20003 Added InetConfigSystemFromPath
//            and removed InstallTCPAndRNA.
//  96/05/01  markdu  NASH BUG 20483 Do not display "installing files" dialog
//            if INETCFG_SUPPRESSINSTALLUI is set.
//  96/05/01  markdu  ICW BUG 8049 Reboot if modem is installed.  This is 
//            required because sometimes the configuration manager does not 
//            set up the modem correctly, and the user will not be able to
//            dial (will get cryptic error message) until reboot.
//  96/05/06  markdu  NASH BUG 21027  If DNS is set globally, clear it out so
//            the per-connectoid settings will be saved.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.
//  96/05/28  markdu  Moved InitConfig and DeInitConfig to DllEntryPoint.
//	96/10/21  valdonb Added CheckConnectionWizard and InetCreateMailNewsAccount
//  99/11/10  nickball Reduced to CM essentials
//
//*******************************************************************

#include "wizard.h"
#include "inetcfg.h"

// structure to pass data back from IDD_NEEDDRIVERS handler
typedef struct tagNEEDDRIVERSDLGINFO
{
  DWORD       dwfOptions;
  LPBOOL      lpfNeedsRestart;
} NEEDDRIVERSDLGINFO, * PNEEDDRIVERSDLGINFO;

// Function prototypes internal to this file
INT_PTR CALLBACK NeedDriversDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL NeedDriversDlgInit(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo);
BOOL NeedDriversDlgOK(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo);
VOID EnableDlg(HWND hDlg,BOOL fEnable);

static DWORD GetOSMajorVersion(void);

// from rnacall.cpp
//
extern void InitTAPILocation(HWND hwndParent);

// Function prototypes external to this file

extern ICFGINSTALLSYSCOMPONENTS     lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS        lpIcfgNeedInetComponents;
extern ICFGGETLASTINSTALLERRORTEXT  lpIcfgGetLastInstallErrorText;

//*******************************************************************
//
//  FUNCTION:   InetConfigSystem
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install exchange and internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/05  markdu  Created.
//
//*******************************************************************

extern "C" HRESULT WINAPI InetConfigSystem(
										   HWND hwndParent,
										   DWORD dwfOptions,
										   LPBOOL lpfNeedsRestart)
{
	DWORD         dwRet = ERROR_SUCCESS;
	BOOL          fNeedsRestart = FALSE;  // Default to no reboot needed
	// 4/2/97 ChrisK	Olympus 209
	HWND          hwndWaitDlg = NULL;
	CHAR szWindowTitle[255];
	BOOL bSleepNeeded = FALSE;
	
	
	DEBUGMSG("export.c::InetConfigSystem()");
	
	// Validate the parent hwnd
	if (hwndParent && !IsWindow(hwndParent))
	{
		return ERROR_INVALID_PARAMETER;
	}
	
	// Set up the install options
	DWORD dwfInstallOptions = 0;
	if (dwfOptions & INETCFG_INSTALLTCP)
	{
		dwfInstallOptions |= ICFG_INSTALLTCP;
	}
	if (dwfOptions & INETCFG_INSTALLRNA)
	{
		dwfInstallOptions |= ICFG_INSTALLRAS;
	}
	if (dwfOptions & INETCFG_INSTALLMAIL)
	{
		dwfInstallOptions |= ICFG_INSTALLMAIL;
	}
	
	// see if we need to install drivers
	BOOL  fNeedSysComponents = FALSE;
    
	// 
	// Kill Modem control panel if it's already running
	// 4/16/97 ChrisK Olympus 239
	// 6/9/97 jmazner moved this functionality from InvokeModemWizard
	szWindowTitle[0] = '\0';
	LoadSz(IDS_MODEM_WIZ_TITLE,szWindowTitle,255);
	HWND hwndModem = FindWindow("#32770",szWindowTitle);
	if (NULL != hwndModem)
	{
		// Close modem installation wizard
		PostMessage(hwndModem, WM_CLOSE, 0, 0);
		bSleepNeeded = TRUE;
	}
	
	// close modem control panel applet
	LoadSz(IDS_MODEM_CPL_TITLE,szWindowTitle,255);
	hwndModem = FindWindow("#32770",szWindowTitle);
	if (NULL != hwndModem)
	{
		PostMessage(hwndModem, WM_SYSCOMMAND,SC_CLOSE, 0);
		bSleepNeeded = TRUE;
	}
	
	if (bSleepNeeded)
	{
		Sleep(1000);
	}
	
	dwRet = lpIcfgNeedInetComponents(dwfInstallOptions, &fNeedSysComponents);
	
	if (ERROR_SUCCESS != dwRet)
	{
		CHAR   szErrorText[MAX_ERROR_TEXT+1]="";
		
		
		// 4/2/97 ChrisK Olympus 209
		// Dismiss busy dialog
		if (NULL != hwndWaitDlg)
		{
			DestroyWindow(hwndWaitDlg);
			hwndWaitDlg = NULL;
		}
		
		//
		// Get the text of the error message and display it.
		//
		if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
		{
			MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
		}
		
		return dwRet;
	}
	
	if (fNeedSysComponents) 
	{
		// 4/2/97 ChrisK Olympus 209
		// if we are going to install something the busy dialog isn't needed
		if (NULL != hwndWaitDlg)
			ShowWindow(hwndWaitDlg,SW_HIDE);
		
		if (dwfOptions & INETCFG_SUPPRESSINSTALLUI)
		{
			dwRet = lpIcfgInstallInetComponents(hwndParent, dwfInstallOptions, &fNeedsRestart);
			//
			// Display error message only if it failed due to something 
			// other than user cancel
			//
			if ((ERROR_SUCCESS != dwRet) && (ERROR_CANCELLED != dwRet))
			{
				CHAR   szErrorText[MAX_ERROR_TEXT+1]="";
				
				// Get the text of the error message and display it.
				if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
				{
					MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
				}
			}
		}
		else
		{
			// structure to pass to dialog to fill out
			NEEDDRIVERSDLGINFO NeedDriversDlgInfo;
			NeedDriversDlgInfo.dwfOptions = dwfInstallOptions;
			NeedDriversDlgInfo.lpfNeedsRestart = &fNeedsRestart;
			
			// Clear out the last error code so we can safely use it.
			SetLastError(ERROR_SUCCESS);
			
			// Display a dialog and allow the user to cancel install
			BOOL fRet = (BOOL)DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_NEEDDRIVERS),hwndParent,
				NeedDriversDlgProc,(LPARAM) &NeedDriversDlgInfo);
			if (FALSE == fRet)
			{
				// user cancelled or an error occurred.
				dwRet = GetLastError();
				if (ERROR_SUCCESS == dwRet)
				{
					// Error occurred, but the error code was not set.
					dwRet = ERROR_INETCFG_UNKNOWN;
				}
			}
		}
	}
	
	if ((ERROR_SUCCESS == dwRet) && 
		(TRUE == IsNT()) && 
		(dwfOptions & INETCFG_INSTALLMODEM))
	{
		BOOL bNeedModem = FALSE;
		
		if (NULL == lpIcfgNeedModem)
		{
			//
			// 4/2/97 ChrisK Olympus 209
			//
			if (NULL != hwndWaitDlg)
				DestroyWindow(hwndWaitDlg);
			hwndWaitDlg = NULL;
			
			return ERROR_GEN_FAILURE;
		}
		
		//
		// 4/2/97 ChrisK Olympus 209
		// Show busy dialog here, this can take a few seconds
		//
		if (NULL != hwndWaitDlg)
			ShowWindow(hwndWaitDlg,SW_SHOW);
		
		dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
		if (ERROR_SUCCESS != dwRet)
		{
			//
			// 4/2/97 ChrisK Olympus 209
			//
			if (NULL != hwndWaitDlg)
				DestroyWindow(hwndWaitDlg);
			hwndWaitDlg = NULL;
			
			return dwRet;
		}
		
		
		if (TRUE == bNeedModem) 
		{
			if (GetOSMajorVersion() != 5)
			{
				//
				// Not NT4 we cannot programmitcally install/configure modem 
				// separately. It has to be done when RAS in installed
				//
				if (NULL != hwndWaitDlg)
					DestroyWindow(hwndWaitDlg);
				hwndWaitDlg = NULL;
				
				MsgBoxParam(hwndParent,IDS_ERRNoDialOutModem,MB_ICONERROR,MB_OK);
				return ERROR_GEN_FAILURE;
			}
			else
			{
				//
				// Attempt to install Modem
				//
				BOOL bNeedToReboot = FALSE;
				
				if (NULL != hwndWaitDlg)
					DestroyWindow(hwndWaitDlg);
				hwndWaitDlg = NULL;

				dwRet = (*lpIcfgInstallModem)(NULL, 0, 	&bNeedToReboot);
				
				if (ERROR_SUCCESS == dwRet)
				{
					ASSERT(!bNeedToReboot);

					//
					// Need to check if user managed to add a modem
					//
					dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
					if (TRUE == bNeedModem)
					{
						//
						// User must have cancelled the modem setup
						//
						return ERROR_CANCELLED;
					}
				}
				else
				{
					return ERROR_GEN_FAILURE;
				}

			}
		}

	}
	
	//
	// 4/2/97 ChrisK Olympus 209
	//
	if (NULL != hwndWaitDlg)
		ShowWindow(hwndWaitDlg,SW_HIDE);

	// 4/2/97 ChrisK Olympus 209
	// Dismiss dialog for good
	if (NULL != hwndWaitDlg)
		DestroyWindow(hwndWaitDlg);
	hwndWaitDlg = NULL;
	
	
	//
	// If not NT then we install the modem after installing RAS
	//
	// See if we are supposed to install a modem
	if ((FALSE == IsNT()) && (ERROR_SUCCESS == dwRet) && 
		(dwfOptions & INETCFG_INSTALLMODEM))
	{
		// Load RNA if not already loaded since ENUM_MODEM needs it.
		dwRet = EnsureRNALoaded();
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}
		
		
		// Enumerate the modems 
		ENUM_MODEM  EnumModem;
		dwRet = EnumModem.GetError();
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}
		
		// If there are no modems, install one if requested.
		if (0 == EnumModem.GetNumDevices())
		{
			
			if (FALSE == IsNT())
			{
				//
				// 5/22/97 jmazner	Olympus #4698
				// On Win95, calling RasEnumDevices launches RNAAP.EXE
				// If RNAAP.EXE is running, any modems you install won't be usable
				// So, nuke RNAAP.EXE before installing the modem.
				//
				CHAR szWindowTitle[255] = "\0nogood";
				
				//
				// Unload the RAS dll's before killing RNAAP, just to be safe
				//
				DeInitRNA();
				
				LoadSz(IDS_RNAAP_TITLE,szWindowTitle,255);
				HWND hwnd = FindWindow(szWindowTitle, NULL);
				if (NULL != hwnd)
				{
					if (!PostMessage(hwnd, WM_CLOSE, 0, 0))
					{
						DEBUGMSG("Trying to kill RNAAP window returned getError %d", GetLastError());
					}
				}
			}
			
			// invoke the modem wizard UI to install the modem
			UINT uRet = InvokeModemWizard(hwndParent);
			
			if (uRet != ERROR_SUCCESS)
			{
				DisplayErrorMessage(hwndParent,IDS_ERRInstallModem,uRet,
					ERRCLS_STANDARD,MB_ICONEXCLAMATION);
				return ERROR_INVALID_PARAMETER;
			}
			
			
			if (FALSE == IsNT())
			{
				// Reload the RAS dlls now that the modem has been safely installed.
				InitRNA(hwndParent);
			}
			
			// Re-numerate the modems to be sure we have the most recent changes  
			dwRet = EnumModem.ReInit();
			if (ERROR_SUCCESS != dwRet)
			{
				return dwRet;
			}
			
			// If there are still no modems, user cancelled
			if (0 == EnumModem.GetNumDevices())
			{
				return ERROR_CANCELLED;
			}
			else
			{
				// removed per GeoffR request 5-2-97
				////  96/05/01  markdu  ICW BUG 8049 Reboot if modem is installed.
				//fNeedsRestart = TRUE;
			}
		}
		else
		{
			//
			// 7/15/97	jmazner	Olympus #6294
			// make sure TAPI location info is valid
			//
			InitTAPILocation(hwndParent);
		}
	}
	
	// tell caller whether we need to reboot or not
	if ((ERROR_SUCCESS == dwRet) && (lpfNeedsRestart))
	{
		*lpfNeedsRestart = fNeedsRestart;
	}
	
	// 4/2/97 ChrisK	Olympus 209											2
	// Sanity check
	if (NULL != hwndWaitDlg)
		DestroyWindow(hwndWaitDlg);
	hwndWaitDlg = NULL;
	
	return dwRet;
}

//*******************************************************************
//
//  FUNCTION:   InetNeedSystemComponents
//
//  PURPOSE:    This function will check is components that are needed
//              for internet access (such as TCP/IP and RNA) are already
//				configured based the state of the options flags.
//
//  PARAMETERS: dwfOptions - a combination of INETCFG_ flags that controls
//								the installation and configuration as follows:
//
//								INETCFG_INSTALLRNA - install RNA (if needed)
//								INETCFG_INSTALLTCP - install TCP/IP (if needed)
//
//              lpfNeedsConfig - On return, this will be 
//									TRUE if system component(s)
//									should be installed
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:	05/02/97  VetriV  Created.
//				05/08/97  ChrisK  Added INSTALLLAN, INSTALLDIALUP, and
//				                  INSTALLTCPONLY
//
//*******************************************************************

extern "C" HRESULT WINAPI InetNeedSystemComponents(DWORD dwfOptions,
													  LPBOOL lpbNeedsConfig)
{
	DWORD	dwRet = ERROR_SUCCESS;


	DEBUGMSG("export.cpp::InetNeedSystemComponents()");

	//
	// Validate parameters
	//
	if (!lpbNeedsConfig)
	{
		return ERROR_INVALID_PARAMETER;
	}

	//
	// Set up the install options
	//
	DWORD dwfInstallOptions = 0;
	if (dwfOptions & INETCFG_INSTALLTCP)
	{
		dwfInstallOptions |= ICFG_INSTALLTCP;
	}
	if (dwfOptions & INETCFG_INSTALLRNA)
	{
		dwfInstallOptions |= ICFG_INSTALLRAS;
	}

	//
	// ChrisK 5/8/97
	//
	if (dwfOptions & INETCFG_INSTALLLAN)
	{
		dwfInstallOptions |= ICFG_INSTALLLAN;
	}
	if (dwfOptions & INETCFG_INSTALLDIALUP)
	{
		dwfInstallOptions |= ICFG_INSTALLDIALUP;
	}
	if (dwfOptions & INETCFG_INSTALLTCPONLY)
	{
		dwfInstallOptions |= ICFG_INSTALLTCPONLY;
	}

  
	//
	// see if we need to install drivers
	//
	BOOL  bNeedSysComponents = FALSE;

	dwRet = lpIcfgNeedInetComponents(dwfInstallOptions, &bNeedSysComponents);

	if (ERROR_SUCCESS != dwRet)
	{
		CHAR   szErrorText[MAX_ERROR_TEXT+1]="";

		//
		// Get the text of the error message and display it.
		//
		if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
		{
			DEBUGMSG(szErrorText);
		}

		return dwRet;
	}

	
	*lpbNeedsConfig = bNeedSysComponents;
	return ERROR_SUCCESS;
}

  

//*******************************************************************
//
//  FUNCTION:   InetNeedModem
//
//  PURPOSE:    This function will check if modem is needed or not
//
//  PARAMETERS: lpfNeedsConfig - On return, this will be 
//									TRUE if modem
//									should be installed
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:	05/02/97  VetriV  Created.
//
//*******************************************************************

extern "C" HRESULT WINAPI InetNeedModem(LPBOOL lpbNeedsModem)
{

	DWORD dwRet = ERROR_SUCCESS;
		
	//
	// Validate parameters
	//
	if (!lpbNeedsModem)
	{
		return ERROR_INVALID_PARAMETER;
	}

	
	if (TRUE == IsNT())
	{
		//
		// On NT call icfgnt.dll to determine if modem is needed
		//
		BOOL bNeedModem = FALSE;
		
		if (NULL == lpIcfgNeedModem)
		{
			return ERROR_GEN_FAILURE;
		}
	

		dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}

		*lpbNeedsModem = bNeedModem;
		return ERROR_SUCCESS;
	}
	else
	{
		//
		// Load RNA if not already loaded since ENUM_MODEM needs it.
		//
		dwRet = EnsureRNALoaded();
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}

		//
		// Enumerate the modems
		//
		ENUM_MODEM  EnumModem;
		dwRet = EnumModem.GetError();
		if (ERROR_SUCCESS != dwRet)
		{
			return dwRet;
		}

		//
		// If there are no modems, we need to install one
		//
		if (0 == EnumModem.GetNumDevices())
		{
			*lpbNeedsModem = TRUE;
		}
		else
		{
			*lpbNeedsModem = FALSE;
		}
		return ERROR_SUCCESS;
	}
}

/*******************************************************************

  NAME:     NeedDriversDlgProc

  SYNOPSIS: Dialog proc for installing drivers

********************************************************************/

INT_PTR CALLBACK NeedDriversDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  switch (uMsg)
  {
    case WM_INITDIALOG:
      // lParam contains pointer to NEEDDRIVERSDLGINFO struct, set it
      // in window data
      ASSERT(lParam);
      SetWindowLongPtr(hDlg,DWLP_USER,lParam);
      return NeedDriversDlgInit(hDlg,(PNEEDDRIVERSDLGINFO) lParam);
      break;

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
         case IDOK:
        {
          // get data pointer from window data
          PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo =
            (PNEEDDRIVERSDLGINFO) GetWindowLongPtr(hDlg, DWLP_USER);
          ASSERT(pNeedDriversDlgInfo);

          // pass the data to the OK handler
          BOOL fRet=NeedDriversDlgOK(hDlg,pNeedDriversDlgInfo);
          EndDialog(hDlg,fRet);
        }
        break;

        case IDCANCEL:
          SetLastError(ERROR_CANCELLED);
          EndDialog(hDlg,FALSE);
          break;                  
      }
      break;
  }

  return FALSE;
}


/*******************************************************************

  NAME:    NeedDriversDlgInit

  SYNOPSIS: proc to handle initialization of dialog for installing files

********************************************************************/

BOOL NeedDriversDlgInit(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo)
{
  ASSERT(pNeedDriversDlgInfo);

  // put the dialog in the center of the screen
  RECT rc;
  GetWindowRect(hDlg, &rc);
  SetWindowPos(hDlg, NULL,
    ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
    ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
    0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

  return TRUE;
}

/*******************************************************************

  NAME:    NeedDriversDlgOK

  SYNOPSIS:  OK handler for dialog for installing files

********************************************************************/

BOOL NeedDriversDlgOK(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo)
{
  ASSERT(pNeedDriversDlgInfo);

  // set the dialog text to "Installing files..." to give feedback to
  // user
  CHAR szMsg[MAX_RES_LEN+1];
  LoadSz(IDS_INSTALLING_FILES,szMsg,sizeof(szMsg));
  SetDlgItemText(hDlg,IDC_TX_STATUS,szMsg);

  // disable buttons & dialog so it can't get focus
  EnableDlg(hDlg, FALSE);

  // install the drivers we need
  DWORD dwRet = lpIcfgInstallInetComponents(hDlg,
    pNeedDriversDlgInfo->dwfOptions,
    pNeedDriversDlgInfo->lpfNeedsRestart);

	if (ERROR_SUCCESS != dwRet)
	{
		//
		// Don't display error message if user cancelled
		//
		if (ERROR_CANCELLED != dwRet)
		{
			CHAR   szErrorText[MAX_ERROR_TEXT+1]="";
    
			// Get the text of the error message and display it.
			if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
			{
			  MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
			}
		}

    // Enable the dialog again
    EnableDlg(hDlg, TRUE);

    SetLastError(dwRet);
    return FALSE;
  }

  // Enable the dialog again
  EnableDlg(hDlg, TRUE);

  return TRUE;
}


/*******************************************************************

  NAME:      EnableDlg

  SYNOPSIS:  Enables or disables the dlg buttons and the dlg
            itself (so it can't receive focus)

********************************************************************/
VOID EnableDlg(HWND hDlg,BOOL fEnable)
{
  // disable/enable ok and cancel buttons
  EnableWindow(GetDlgItem(hDlg,IDOK),fEnable);
  EnableWindow(GetDlgItem(hDlg,IDCANCEL),fEnable);

  // disable/enable dlg
  EnableWindow(hDlg,fEnable);
  UpdateWindow(hDlg);
}

//+----------------------------------------------------------------------------
//	Function	InetStartServices
//
//	Synopsis	This function guarentees that RAS services are running
//
//	Arguments	none
//
//	Return		ERROR_SUCCESS - if the services are enabled and running
//
//	History		10/16/96	ChrisK	Created
//-----------------------------------------------------------------------------
extern "C" HRESULT WINAPI InetStartServices()
{
	ASSERT(lpIcfgStartServices);
	if (NULL == lpIcfgStartServices)
		return ERROR_GEN_FAILURE;
	return (lpIcfgStartServices());
}


#if !defined(WIN16)
// 4/1/97	ChrisK	Olympus 209


//+----------------------------------------------------------------------------
//
//	Function	GetOSMajorVersion
//
//	Synopsis	Get the Major version number of Operating system
//
//	Arguments	None
//
//	Returns		Major version Number of OS
//
//	History		2/19/98		VetriV		Created
//
//-----------------------------------------------------------------------------
DWORD GetOSMajorVersion(void)
{
    static dwMajorVersion = 0;
	OSVERSIONINFO oviVersion;

	if (0 != dwMajorVersion)
	{
		return dwMajorVersion;
	}

	ZeroMemory(&oviVersion,sizeof(oviVersion));
	oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);
	GetVersionEx(&oviVersion);
	dwMajorVersion = oviVersion.dwMajorVersion;
	return dwMajorVersion;
}


#endif //!WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\clsutil.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1999 Microsoft Corporation
//*********************************************************************

//
//  CLSUTIL.C - some small, useful C++ classes to wrap memory allocation,
//        registry access, etc.
//

//  HISTORY:
//
//  12/07/94  jeremys    Borrowed from WNET common library
//

#include "wizard.h"

BOOL BUFFER::Alloc( UINT cbBuffer )
{
  _lpBuffer = (LPSTR)::GlobalAlloc(GPTR,cbBuffer);
  if (_lpBuffer != NULL) {
    _cb = cbBuffer;
    return TRUE;
  }
  return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
  LPVOID lpNew = ::GlobalReAlloc((HGLOBAL)_lpBuffer, cbNew,
    GMEM_MOVEABLE | GMEM_ZEROINIT);
  if (lpNew == NULL)
    return FALSE;

  _lpBuffer = (LPSTR)lpNew;
  _cb = cbNew;
  return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
  _lpBuffer( NULL )
{
  if (cbInitial)
    Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
  if (_lpBuffer != NULL) {
    GlobalFree((HGLOBAL) _lpBuffer);
    _lpBuffer = NULL;
  }
}

BOOL BUFFER::Resize( UINT cbNew )
{
  BOOL fSuccess;

  if (QuerySize() == 0)
    fSuccess = Alloc( cbNew );
  else {
    fSuccess = Realloc( cbNew );
  }
  if (fSuccess)
    _cb = cbNew;
  return fSuccess;
}

RegEntry::RegEntry(const char *pszSubKey, HKEY hkey)
{
  _error = RegCreateKey(hkey, pszSubKey, &_hkey);
  if (_error) {
    bhkeyValid = FALSE;
  }
  else {
    bhkeyValid = TRUE;
  }
}

RegEntry::~RegEntry()
{
    if (bhkeyValid) {
        RegCloseKey(_hkey);
    }
}

long RegEntry::SetValue(const char *pszValue, const char *string)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
            (unsigned char *)string, lstrlen(string)+1);
    }
  return _error;
}

long RegEntry::SetValue(const char *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
            (unsigned char *)&dwNumber, sizeof(dwNumber));
    }
  return _error;
}

long RegEntry::DeleteValue(const char *pszValue)
{
    if (bhkeyValid) {
      _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
  }
  return _error;
}


char *RegEntry::GetString(const char *pszValue, char *string, unsigned long length)
{
  DWORD   dwType = REG_SZ;

    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
            &length);
    }
  if (_error) {
    *string = '\0';
     return NULL;
  }

  return string;
}

long RegEntry::GetNumber(const char *pszValue, long dwDefault)
{
   DWORD   dwType = REG_BINARY;
   long  dwNumber = 0L;
   DWORD  dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
            &dwSize);
  }
  if (_error)
    dwNumber = dwDefault;

  return dwNumber;
}

long RegEntry::MoveToSubKey(const char *pszSubKeyName)
{
    HKEY  _hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKey ( _hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }

  return _error;
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
      _error = RegFlushKey(_hkey);
    }
  return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new CHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

int __cdecl _purecall(void)
{
   return(0);
}

void * _cdecl operator new(size_t size)
{
  return (void *)::GlobalAlloc(GPTR,size);
}

void _cdecl operator delete(void *ptr)
{
  GlobalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\callout.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  CALLOUT.C - Functions to call out to external components to install
//        devices
//

//  HISTORY:
//  
//  11/27/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//

#include "wizard.h"

// global variables 
static const char c_szModemCPL[] = "rundll32.exe Shell32.dll,Control_RunDLL modem.cpl,,add";


/*******************************************************************

  NAME:    InvokeModemWizard

  SYNOPSIS:  Starts the modem install wizard

  ENTRY:    hwndToHide - this window, if non-NULL, will be hidden while
        the modem CPL runs

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    launches RUNDLL32 as a process to run the modem wizard.
        Blocks on the completion of that process before returning.

        hwndToHide is not necessarily the calling window!
        For instance, in a property sheet hwndToHide should not be the
        dialog (hDlg), but GetParent(hDlg) so that we hide the property
        sheet itself instead of just the current page.

********************************************************************/
UINT InvokeModemWizard(HWND hwndToHide)
{
	BOOL bSleepNeeded = FALSE;

	if (TRUE == IsNT())
	{
		BOOL bNeedsStart;
		
		//
		// Call into icfg32 dll
		//
		if (NULL != lpIcfgInstallModem)
		{
			lpIcfgInstallModem(hwndToHide, 0L, &bNeedsStart);
			return ERROR_SUCCESS;
		}
		else
			return ERROR_GEN_FAILURE;

	}
	else
	{
		PROCESS_INFORMATION pi;
		BOOL fRet;
		STARTUPINFO sti;
		UINT err = ERROR_SUCCESS;
		CHAR szWindowTitle[255];

		ZeroMemory(&sti,sizeof(STARTUPINFO));
		sti.cb = sizeof(STARTUPINFO);

		// run the modem wizard
		fRet = CreateProcess(NULL, (LPSTR)c_szModemCPL,
							   NULL, NULL, FALSE, 0, NULL, NULL,
							   &sti, &pi);
		if (fRet) 
		{
			CloseHandle(pi.hThread);

			// wait for the modem wizard process to complete
			MsgWaitForMultipleObjectsLoop(pi.hProcess);
			CloseHandle(pi.hProcess);
		} 
		else
			err = GetLastError();

		// show the parent window again
		if (hwndToHide) 
		{
			ShowWindow(hwndToHide,SW_SHOW);
		}

		return err;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\ids.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

// dialog size
#define MY_CXDLG                      304
#define MY_CYDLG                      163
#define MY_CXBMP                      79
#define MY_CYBMP                      160

// string resource IDs
#define IDS_APPNAME                   1000

#define IDS_WAITCHECKING              1431

#define IDS_MODEM_WIZ_TITLE           1433
#define IDS_MODEM_CPL_TITLE           1434
#define IDS_RNAAP_TITLE				1437
#define IDS_INSTALLING_FILES          1303

#define IDS_ERRInstallModem           1101
#define IDS_ERRNoDialOutModem         1134
#define IDS_ERRLoadConfigDllNT1       1137
#define IDS_ERRLoadConfigDllNT2       1138
#define IDS_ERRLoadConfigDll1         1124
#define IDS_ERRLoadConfigDll2         1125
#define IDS_ERRLoadRNADll1            1106
#define IDS_ERRLoadRNADll2            1107
#define IDS_ERROutOfMemory            1100
#define IDS_ERRFORMAT                 1003


#define IDS_CONFIG95DLL_FILENAME      1031
#define IDS_CONFIGNTDLL_FILENAME      1032
#define IDS_RNADLL_FILENAME           1004
#define IDS_RNAPHDLL_FILENAME         1013
#define IDS_GENERIC_RNA_ERROR         1015
#define IDS_WARN_SERVER_BOUND         1205
#define IDS_WARN_SERVER_BOUND1        1207
#define IDS_REMOVE_SERVER_BOUND       1208
#define IDS_REMOVE_SERVER_BOUND1      1209

#define IDC_UNUSED                    -1
#define IDC_TX_STATUS                 2143

#define IDD_NEEDDRIVERS               2023

/*

#define IDS_QUERYCANCEL               1002
#define IDS_COUNTRY_FMT               1005
#define IDS_SHORT_FMT                 1006
#define IDS_DEFAULT_PROFILE_NAME      1007
#define IDS_MAPIDLL_FILENAME          1008
#define IDS_GENERIC_MAPI_ERROR        1016
#define IDS_HELPFILE_NAME             1022
#define IDS_MSN105_INF_FILE           1026
#define IDS_MSN105_UNINSTALL_SECT     1027
#define IDS_MSN100_INF_FILE           1028
#define IDS_MSN100_UNINSTALL_SECT     1029
#define IDS_SCRIPT_FILE_FILTER        1030

#define IDS_INTERNETMAIL_SERVICENAME  1050
#define IDS_MESSAGESTORE_SERVICENAME  1051
#define IDS_ADDRESSBOOK_SERVICENAME   1052
#define IDS_INTERNETMAIL_DESCRIPTION  1053
#define IDS_MESSAGESTORE_DESCRIPTION  1054
#define IDS_ADDRESSBOOK_DESCRIPTION   1055
#define IDS_PROFILENAME               1056
#define IDS_PROFILENAME1              1057

#define IDS_MESSAGESTORE_FILENAME     1060
#define IDS_MESSAGESTORE_FILENAME1    1061
#define IDS_ADDRESSBOOK_FILENAME      1062
#define IDS_ADDRESSBOOK_FILENAME1     1063

#define IDS_ERRReadConfig             1102
#define IDS_ERRCoInitialize           1103
#define IDS_ERRCreateConnectoid       1109
#define IDS_ERRLoadMAPIDll1           1110
#define IDS_ERRLoadMAPIDll2           1111
#define IDS_ERRInitMAPI               1112
#define IDS_ERRConfigureMail          1114
#define IDS_ERRConnectoidName95       1115
#define IDS_ERRSetPhoneNumber         1116
#define IDS_ERRWriteDNS               1119
#define IDS_ERRUninstallMSN           1120
#define IDS_ERREnumModem              1121
#define IDS_ERRConfigureProxy         1123
#define IDS_ERRCorruptConnection      1126
#define IDS_ERRCorruptAccount         1127
#define IDS_ERRDuplicateConnectoidName	1128
//#define IDS_ERRInvalidAcctName        1130
//#define IDS_ERRMailSetup              1131
//#define IDS_ERRNewsSetup              1132
//#define IDS_ERRIMNConfig              1133
#define IDS_ERRModifyCSLIP            1135
#define IDS_ERRProxyRequired        1136
#define IDS_ERRConnectoidNameNT       1139
//#define	IDS_ERRDirServSetup			  1140


#define IDS_WARN_EMPTY_USERNAME       1200
#define IDS_WARN_EMPTY_DNS            1201
#define IDS_WARN_EMPTY_PASSWORD		  1203
//#define IDS_NEED_ACCOUNT              1210
//#define IDS_NEED_NEWS_ACCOUNT_NAME    1211
//#define	IDS_DUP_ACCTNAME			  1212

#define IDS_WARNWillRemoveMSN         1221

#define IDS_OKTOCHANGECONFIG          1230
#define IDS_ABOUTTOCHANGECONFIG1      1231
#define IDS_ABOUTTOCHANGECONFIG2      1232
#define IDS_DEF_CONNECTION_NAME_1     1233
#define IDS_DEF_CONNECTION_NAME_2     1234
#define IDS_SYSTEM_ALREADY_CONFIGURED 1235
#define IDS_CONFIGAPIFAILED           1236
#define IDS_SERVICEDISABLED           1237

#define IDS_NEED_PHONENUMBER          1250
#define IDS_NEED_IPADDR               1251
#define IDS_NEED_ISPNAME              1252
#define IDS_NEED_PROFILENAME          1253
#define IDS_NEED_AREACODE             1254
#define IDS_DUPLICATE_PROFILENAME     1255
//#define IDS_NEED_ACCTNAME             1256

#define IDS_INVALID_PORTNUM			  1260
//#define IDS_NEED_NEWSSERV			  1261
#define IDS_INVALIDPHONE			  1262
//#define	IDS_NEED_SERVERNAME			  1263

#define IDS_INVALID_IPADDR            1300

#define IDS_MODIFYCONNECTION          1320

// Normandy 11970 ChrisK - we need a different title if launched from
// mail or news configuration
#define IDS_BEGINMANUAL_ALTERNATE     1323

#define	IDS_LOGINSCRIPTINVALID		  1324

#define IDS_HOWTOCONNECT_DESC1		  1400
#define IDS_HOWTOCONNECT_DESC2		  1401
#define	IDS_CONNECTION_DESC1		  1402
#define	IDS_CONNECTION_DESC2		  1403


//#define IDS_EXITFAILED                1429
#define IDS_WANTTOREBOOT              1430
//#define IDS_NEEDTOREBOOT						1428

#define IDS_SBCSONLY				  1435

#define IDS_CONNECTIONTO				  1436


// dialog page IDs
//#define IDD_PAGE_WELCOME              2000
#define IDD_PAGE_HOWTOCONNECT         2001
#define IDD_PAGE_CHOOSEMODEM          2002
#define IDD_PAGE_CONNECTEDOK          2003
#define IDD_PAGE_CONNECTION           2004
#define IDD_PAGE_CONNECTIONNAME       2005
#define IDD_PAGE_MODIFYCONNECTION     2006
#define IDD_PAGE_ADVANCED             2007
#define IDD_PAGE_PHONENUMBER          2008
#define IDD_PAGE_NAMEANDPASSWORD      2009
#define IDD_PAGE_CONNECTIONPROTOCOL   2010
#define IDD_PAGE_LOGINSCRIPT          2011
#define IDD_PAGE_USEPROXY             2012
#define IDD_PAGE_PROXYSERVERS         2013
#define IDD_PAGE_PROXYEXCEPTIONS      2014
#define IDD_PAGE_IPADDRESS            2015
#define IDD_PAGE_DNSADDRESS           2016

#define IDD_NEWPROFILENAME            2020
#define IDD_SECURITY_CHECK            2021
#define IDD_DNS_WARNING               2022
#define IDD_CHOOSEMODEMNAME           2024
#define IDD_CHOOSEPROFILENAME         2025
#define IDD_PAGE_LCPEXTENSIONS        2026

#define IDS_MAPIERROR_BASE            3000

#ifdef IDC_HELP
#undef IDC_HELP
#endif

// dialog control IDs
#define IDC_BMPFRAME                  2100
#define IDC_CONNECT_BY_PHONE          2102
#define IDC_CONNECT_BY_LAN            2103
#define	IDC_CONNECT_MANUAL			  2104
#define IDC_AREACODE                  2108
#define IDC_PHONENUMBER               2109
#define IDC_USERNAME                  2110
#define IDC_PASSWORD                  2111
#define IDC_CONFIRMPASSWORD           2112
#define IDC_MODIFYCONNECTION          2113
#define IDC_NOMODIFYCONNECTION        2114
#define IDC_CONNECTIONNAME            2115
#define IDC_NEWCONNECTION             2116
#define IDC_EXISTINGCONNECTION        2117
#define IDC_LBLMODIFYCONNECTION       2118
#define IDC_MODIFYADVANCED            2119
#define IDC_NOMODIFYADVANCED          2120
#define IDC_ISPNAME                   2121
#define IDC_USE_DHCP                  2123
#define IDC_USE_IP                    2124
#define IDC_IPADDR                    2125
#define IDC_DNSADDR1                  2127
#define IDC_DNSADDR2                  2128
#define IDC_TX_IPADDR                 2129
#define IDC_AUTO_DNS                  2130
#define IDC_STATIC_DNS                2131
#define IDC_TX_DNSADDR1               2132
#define IDC_TX_DNSADDR2               2133
#define IDC_COUNTRYCODE               2136
#define IDC_MODEM                     2137
#define IDC_SETDEFAULT                2149
#define IDC_NEW_PROFILE               2150
#define IDC_PROFILE_LIST              2151
#define IDC_PROFILENAME               2152
#define IDC_DISABLE_CHECK             2153
#define IDC_GRP_SETTINGS              2154
#define IDC_HELP                      2155
#define IDC_DISABLE_WARNING           2156
#define IDC_USEDIALRULES              2157
#define IDC_PROTOCOLPPP               2158
#define IDC_PROTOCOLSLIP              2159
#define IDC_PROTOCOLCSLIP             2160
#define IDC_NOTERMINALAFTERDIAL       2161
#define IDC_TERMINALAFTERDIAL         2162
#define IDC_SCRIPT                    2163
#define IDC_BROWSE                    2164
#define IDC_SCRIPTFILE                2170
#define IDC_TX_PROXYBYPASS            2178
#define IDC_TX_PROXYSERVER            2179
#define IDC_TX_AREACODE               2180
#define IDC_TX_COUNTRYCODE            2181
#define IDC_TX_SEPARATOR              2182
#define IDC_LBLTITLE                  2183
//#define IDC_INSTALLMAIL               2184
//#define IDC_NOMAIL                    2185
//#define IDC_MAILNAME                  2186
//#define IDC_MAILADDRESS               2187
//#define IDC_INCOMINGMAILSERVER                 2188
//#define IDC_SMTPSERVER                2189
//#define IDC_INSTALLNEWS               2190
//#define IDC_NONEWS                    2191
//#define IDC_SERVER                    2192
//#define IDC_NEWSNAME                  2193
//#define IDC_NEWSADDRESS               2194
//#define IDC_LOGONNEWS                 2195
//#define IDC_NEWSACCOUNT               2196
//#define IDC_NEWSSECURE                2197
#define IDC_TX_ACCOUNT                2198
#define IDC_TX_PASSWORD               2199

#define IDC_USEPROXY                  2200
#define IDC_NOUSEPROXY                2201
#define IDC_TX_PROXYTYPE              2202
#define IDC_TX_PROXYADDRESS           2203
#define IDC_TX_PROXYPORT              2204
#define IDC_TX_PROXYHTTP              2205
#define IDC_PROXYHTTP                 2206
#define IDC_PORTHTTP                  2207
#define IDC_TX_PROXYSECURE            2208
#define IDC_PROXYSECURE               2209
#define IDC_PORTSECURE                2210
#define IDC_TX_PROXYFTP               2211
#define IDC_PROXYFTP                  2212
#define IDC_PORTFTP                   2213
#define IDC_TX_PROXYGOPHER            2214
#define IDC_PROXYGOPHER               2215
#define IDC_PORTGOPHER                2216
#define IDC_TX_PROXYSOCKS             2217
#define IDC_PROXYSOCKS                2218
#define IDC_PORTSOCKS                 2219
#define IDC_PROXYSAME                 2220
#define IDC_TX_BYPASSPROXY            2222
#define IDC_BYPASSPROXY               2223
#define IDC_TX_USESEMICOLON           2224
#define IDC_BYPASSLOCAL               2225

#define IDC_INCOMINGMAILTYPE		  2226

#define IDC_NEWACCT                   2230
#define IDC_EXISTINGACCT              2231
#define IDC_ACCTNAME                  2232
#define IDC_ACCTLIST                  2233
#define IDC_LBLMODIFYACCT             2234
#define IDC_MODIFYACCT                2235
#define IDC_NOMODIFYACCT              2236

#define IDC_CANCEL                    2240
#define IDC_DISABLELCP                2241
#define IDC_NODISABLELCP              2242

#define	IDC_DESC					  2250
#define IDC_LOGONPLAIN				  2252
#define IDC_LOGONSICILY				  2253
#define	IDC_LBLUSERNAME				  2254
#define	IDC_LBLPASSWORD				  2255

//#define IDC_INSTALL_DIR_SERV		  2256
//#define	IDC_NO_DIR_SERV				  2257

#define	IDC_NOTE					2258

// bitmap IDs
#define IDB_BMP_WELCOME               2290

// icon IDs
#define IDI_WORLD                     2300
#define IDI_MODEM                     2303

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\icfgcall.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//  HISTORY:
//  
//  96/05/23  markdu  Created.
//  96/05/26  markdu  Update config API.
//  96/05/27  markdu  Added lpIcfgGetLastInstallErrorText.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.

#ifndef _ICFGCALL_H_
#define _ICFGCALL_H_

// function pointer typedefs for RNA apis from rnaph.dll and rasapi32.dll
typedef DWORD   (WINAPI * GETSETUPXERRORTEXT         )  (DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc);
typedef HRESULT (WINAPI * ICFGSETINSTALLSOURCEPATH   )  (LPCSTR lpszSourcePath);
typedef HRESULT (WINAPI * ICFGINSTALLSYSCOMPONENTS   )  (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart);
typedef HRESULT (WINAPI * ICFGNEEDSYSCOMPONENTS      )  (DWORD dwfOptions, LPBOOL lpfNeedComponents);
typedef HRESULT (WINAPI * ICFGISGLOBALDNS            )  (LPBOOL lpfGlobalDNS);
typedef HRESULT (WINAPI * ICFGREMOVEGLOBALDNS        )  (void);
typedef HRESULT (WINAPI * ICFGTURNOFFFILESHARING     )  (DWORD dwfDriverType, HWND hwndParent);
typedef HRESULT (WINAPI * ICFGISFILESHARINGTURNEDON  )  (DWORD dwfDriverType, LPBOOL lpfSharingOn);
typedef DWORD   (WINAPI * ICFGGETLASTINSTALLERRORTEXT)  (LPSTR lpszErrorDesc, DWORD cbErrorDesc);
typedef HRESULT (WINAPI * ICFGSTARTSERVICES          )  (void);

//
// These are available only on the NT icfg32.dll
//
typedef HRESULT (WINAPI * ICFGNEEDMODEM				)	(DWORD dwfOptions, LPBOOL lpfNeedModem);
typedef HRESULT (WINAPI * ICFGINSTALLMODEM			)	(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart);

BOOL InitConfig(HWND hWnd);
VOID DeInitConfig();

//
// global function pointers for Config apis
//
extern ICFGSETINSTALLSOURCEPATH    lpIcfgSetInstallSourcePath;
extern ICFGINSTALLSYSCOMPONENTS    lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS       lpIcfgNeedInetComponents;
extern ICFGISGLOBALDNS             lpIcfgIsGlobalDNS;
extern ICFGREMOVEGLOBALDNS         lpIcfgRemoveGlobalDNS;
extern ICFGTURNOFFFILESHARING      lpIcfgTurnOffFileSharing;
extern ICFGISFILESHARINGTURNEDON   lpIcfgIsFileSharingTurnedOn;
extern ICFGGETLASTINSTALLERRORTEXT lpIcfgGetLastInstallErrorText;
extern ICFGSTARTSERVICES           lpIcfgStartServices;
//
// These two calls are only in NT icfg32.dll
//
extern ICFGNEEDMODEM				lpIcfgNeedModem;
extern ICFGINSTALLMODEM			lpIcfgInstallModem;


#endif // _ICFGCALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\icfgcall.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************
//

//  HISTORY:
//  
//  96/05/23  markdu  Created.
//  96/05/26  markdu  Update config API.
//  96/05/27  markdu  Added lpIcfgGetLastInstallErrorText.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.

#include "wizard.h"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)

// Global variables
HINSTANCE ghInstConfigDll=NULL; // handle to Config dll we load explicitly
DWORD     dwCfgRefCount=0;
BOOL      fCFGLoaded=FALSE; // TRUE if config function addresses have been loaded

// global function pointers for Config apis
GETSETUPXERRORTEXT          lpGetSETUPXErrorText=NULL;
ICFGSETINSTALLSOURCEPATH    lpIcfgSetInstallSourcePath=NULL;
ICFGINSTALLSYSCOMPONENTS    lpIcfgInstallInetComponents=NULL;
ICFGNEEDSYSCOMPONENTS       lpIcfgNeedInetComponents=NULL;
ICFGISGLOBALDNS             lpIcfgIsGlobalDNS=NULL;
ICFGREMOVEGLOBALDNS         lpIcfgRemoveGlobalDNS=NULL;
ICFGTURNOFFFILESHARING      lpIcfgTurnOffFileSharing=NULL;
ICFGISFILESHARINGTURNEDON   lpIcfgIsFileSharingTurnedOn=NULL;
ICFGGETLASTINSTALLERRORTEXT lpIcfgGetLastInstallErrorText=NULL;
ICFGSTARTSERVICES           lpIcfgStartServices=NULL;

//
// These two calls are only in NT icfg32.dll
//
ICFGNEEDMODEM				lpIcfgNeedModem = NULL;
ICFGINSTALLMODEM			lpIcfgInstallModem = NULL;


//////////////////////////////////////////////////////
// Config api function names
//////////////////////////////////////////////////////
//static const CHAR szDoGenInstall[] =                "DoGenInstall";
static const CHAR szGetSETUPXErrorText[] =          "GetSETUPXErrorText";

static const CHAR szIcfgSetInstallSourcePath[] =    "IcfgSetInstallSourcePath";
static const CHAR szIcfgInstallInetComponents[] =   "IcfgInstallInetComponents";
static const CHAR szIcfgNeedInetComponents[] =      "IcfgNeedInetComponents";
static const CHAR szIcfgIsGlobalDNS[] =             "IcfgIsGlobalDNS";
static const CHAR szIcfgRemoveGlobalDNS[] =         "IcfgRemoveGlobalDNS";
static const CHAR szIcfgTurnOffFileSharing[] =      "IcfgTurnOffFileSharing";
static const CHAR szIcfgIsFileSharingTurnedOn[] =   "IcfgIsFileSharingTurnedOn";
static const CHAR szIcfgGetLastInstallErrorText[] = "IcfgGetLastInstallErrorText";
static const CHAR szIcfgStartServices[] =           "IcfgStartServices";
//
// Available only on NT icfg32.dll
//
static const CHAR szIcfgNeedModem[] =				"IcfgNeedModem";
static const CHAR szIcfgInstallModem[] =			"IcfgInstallModem";


// API table for function addresses to fetch
#define NUM_CFGAPI_PROCS   12
APIFCN ConfigApiList[NUM_CFGAPI_PROCS] =
{
  { (PVOID *) &lpGetSETUPXErrorText,          szGetSETUPXErrorText},
  { (PVOID *) &lpIcfgSetInstallSourcePath,    szIcfgSetInstallSourcePath},
  { (PVOID *) &lpIcfgInstallInetComponents,   szIcfgInstallInetComponents},
  { (PVOID *) &lpIcfgNeedInetComponents,      szIcfgNeedInetComponents},
  { (PVOID *) &lpIcfgIsGlobalDNS,             szIcfgIsGlobalDNS},
  { (PVOID *) &lpIcfgRemoveGlobalDNS,         szIcfgRemoveGlobalDNS}, 
  { (PVOID *) &lpIcfgTurnOffFileSharing,      szIcfgTurnOffFileSharing},
  { (PVOID *) &lpIcfgIsFileSharingTurnedOn,   szIcfgIsFileSharingTurnedOn},
  { (PVOID *) &lpIcfgGetLastInstallErrorText, szIcfgGetLastInstallErrorText},
  { (PVOID *) &lpIcfgStartServices,           szIcfgStartServices},
	//
	// These two calls are only in NT icfg32.dll
	//
  { (PVOID *) &lpIcfgNeedModem,		      szIcfgNeedModem},
  { (PVOID *) &lpIcfgInstallModem,	      szIcfgInstallModem}
};

#pragma data_seg(DATASEG_DEFAULT)

extern BOOL GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,
  UINT nApiProcs);

/*******************************************************************

  NAME:    InitConfig

  SYNOPSIS:  Loads the Config dll (ICFG32), gets proc addresses,

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

********************************************************************/
BOOL InitConfig(HWND hWnd)
{
  UINT uiNumCfgApiProcs = 0;

	  
  DEBUGMSG("icfgcall.c::InitConfig()");

  // only actually do init stuff on first call to this function
  // (when reference count is 0), just increase reference count
  // for subsequent calls
  if (dwCfgRefCount == 0) {

    CHAR szConfigDll[SMALL_BUF_LEN];

    DEBUGMSG("Loading Config DLL");

    // set an hourglass cursor
    WAITCURSOR WaitCursor;

	if (TRUE == IsNT())
	{
		//
		// On Windows NT get the filename (ICFGNT.DLL) out of resource
		//
		LoadSz(IDS_CONFIGNTDLL_FILENAME,szConfigDll,sizeof(szConfigDll));
	}
	else
	{
		//
		// On Windows 95 get the filename (ICFG95.DLL) out of resource
		//
		LoadSz(IDS_CONFIG95DLL_FILENAME,szConfigDll,sizeof(szConfigDll));
	}

    // load the Config api dll
    ghInstConfigDll = LoadLibrary(szConfigDll);
    if (!ghInstConfigDll) {
      UINT uErr = GetLastError();
	  // Normandy 11985 - chrisk
	  // filenames changed for Win95 and NT
      if (TRUE == IsNT())
	  {
		  DisplayErrorMessage(hWnd,IDS_ERRLoadConfigDllNT1,uErr,ERRCLS_STANDARD,
			MB_ICONSTOP);
	  }
	  else
	  {
		  DisplayErrorMessage(hWnd,IDS_ERRLoadConfigDll1,uErr,ERRCLS_STANDARD,
			MB_ICONSTOP);
	  }
      return FALSE;
    }

    //
	// Cycle through the API table and get proc addresses for all the APIs we
    // need - on NT icfg32.dll has 2 extra entry points
	//
	if (TRUE == IsNT())
		uiNumCfgApiProcs = NUM_CFGAPI_PROCS;
	else
		uiNumCfgApiProcs = NUM_CFGAPI_PROCS - 2;
	
	if (!GetApiProcAddresses(ghInstConfigDll,ConfigApiList,uiNumCfgApiProcs)) {
	// Normandy 11985 - chrisk
	// filenames changed for Win95 and NT
	  if (TRUE == IsNT())
	  {
	    MsgBox(hWnd,IDS_ERRLoadConfigDllNT2,MB_ICONSTOP,MB_OK);
	  }
	  else
	  {
		MsgBox(hWnd,IDS_ERRLoadConfigDll2,MB_ICONSTOP,MB_OK);
	  }
      DeInitConfig();
      return FALSE;
    }

  }

  fCFGLoaded = TRUE;

  dwCfgRefCount ++;

  return TRUE;
}

/*******************************************************************

  NAME:    DeInitConfig

  SYNOPSIS:  Unloads Config dll.

********************************************************************/
VOID DeInitConfig()
{
  DEBUGMSG("icfgcall.c::DeInitConfig()");

  UINT nIndex;

  // decrement reference count
  if (dwCfgRefCount)
    dwCfgRefCount --;

  // when the reference count hits zero, do real deinitialization stuff
  if (dwCfgRefCount == 0)
  {
    if (fCFGLoaded)
    {
      // set function pointers to NULL
      for (nIndex = 0;nIndex<NUM_CFGAPI_PROCS;nIndex++) 
        *ConfigApiList[nIndex].ppFcnPtr = NULL;

      fCFGLoaded = FALSE;
    }

    // free the Config dll
    if (ghInstConfigDll)
    {
    DEBUGMSG("Unloading Config DLL");
      FreeLibrary(ghInstConfigDll);
      ghInstConfigDll = NULL;
    }

  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\rnacall.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************
//
//  RNACALL.C - functions to call RNA dll to create connectoid
//
//  HISTORY:
//  
//  1/18/95   jeremys Cloned from RNA UI code
//  96/01/31  markdu  Renamed CONNENTDLG to OLDCONNENTDLG to avoid
//            conflicts with RNAP.H.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the implementation of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also eliminated IsValidDevice() and RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the implementation of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/02/26  markdu  Replaced all remaining internal RNA APIs.
//  96/03/07  markdu  Extend ENUM_MODEM class, and use global modem
//            enum object.
//  96/03/08  markdu  Do complete verification of device name and type
//            strings passed in to CreateConnectoid.
//  96/03/09  markdu  Moved generic RASENTRY initialization into
//            its own function (InitRasEntry).  Added a wait cursor
//            during loading of RNA.
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//            Also no longer need GetConnectoidPhoneNumber function.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//  96/03/11  markdu  Moved code to set username and password out of
//            CreateConnectoid into SetConnectoidUsername so it can be reused.
//  96/03/11  markdu  Added some flags in InitRasEntry.
//  96/03/13  markdu  Change ValidateConncectoidName to take LPCSTR.
//  96/03/16  markdu  Added ReInit member function to re-enumerate modems.
//  96/03/21  markdu  Work around RNA bug in ENUM_MODEM::ReInit().
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/24  markdu  Replaced lstrcpy with lstrcpyn where appropriate.
//  96/03/25  markdu  Removed GetIPInfo and SetIPInfo.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid,
//            ValidateConnectoidName, and SetConnectoidUsername.
//  96/04/07  markdu  NASH BUG 15645 Work around RNA bug where area code
//            string is required even though it is not being used.
//  96/04/26  markdu  NASH BUG 18605 Handle ERROR_FILE_NOT_FOUND return
//            from ValidateConnectoidName.
//  96/05/14  markdu  NASH BUG 22730 Work around RNA bug.  Flags for terminal
//            settings are swapped by RasSetEntryproperties.
//  96/05/16  markdu  NASH BUG 21810 Added function for IP address validation.
//  96/06/04  markdu  OSR  BUG 7246 Add RASEO_SwCompression and
//            RASEO_ModemLights to default RASENTRY.
//

#include "wizard.h"
#include "tapi.h"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)

// Global variables
HINSTANCE ghInstRNADll=NULL; // handle to RNA dll we load explicitly
HINSTANCE ghInstRNAPHDll=NULL;  // handle to RNAPH dll we load explicitly
DWORD     dwRefCount=0;
BOOL      fRNALoaded=FALSE; // TRUE if RNA function addresses have been loaded

// global function pointers for RNA apis

RASENUMDEVICES          lpRasEnumDevices=NULL; 
RASENUMENTRIES          lpRasEnumEntries=NULL; 

// API table for function addresses to fetch
#define NUM_RNAAPI_PROCS   2
APIFCN RnaApiList[NUM_RNAAPI_PROCS] =
{
  { (PVOID *) &lpRasEnumDevices,"RasEnumDevicesA"},
  { (PVOID *) &lpRasEnumEntries,"RasEnumEntriesA"}
};

#pragma data_seg(DATASEG_DEFAULT)

ENUM_MODEM *      gpEnumModem=NULL;  // pointer modem enumeration object

BOOL  GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,UINT nApiProcs);

static const CHAR szRegValRNAWizard[] =     "wizard";
static const CHAR szRegPathRNAWizard[] =     REGSTR_PATH_REMOTEACCESS;

/*******************************************************************

  NAME:    InitRNA

  SYNOPSIS:  Loads the RNA dll (RASAPI32), gets proc addresses,
        and loads RNA engine

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

  NOTES:    We load the RNA dll explicitly and get proc addresses
        because these are private APIs and not guaranteed to
        be supported beyond Windows 95.  This way, if the DLL
        isn't there or the entry points we expect aren't there,
        we can display a coherent message instead of the weird
        Windows dialog you get if implicit function addresses
        can't be resolved.

********************************************************************/
BOOL InitRNA(HWND hWnd)
{
  DEBUGMSG("rnacall.c::InitRNA()");

  // only actually do init stuff on first call to this function
  // (when reference count is 0), just increase reference count
  // for subsequent calls
  if (dwRefCount == 0) {

    CHAR szRNADll[SMALL_BUF_LEN];

    DEBUGMSG("Loading RNA DLL");

    // set an hourglass cursor
    WAITCURSOR WaitCursor;

    // get the filename (RASAPI32.DLL) out of resource
    LoadSz(IDS_RNADLL_FILENAME,szRNADll,sizeof(szRNADll));

    // load the RNA api dll
    ghInstRNADll = LoadLibrary(szRNADll);
    if (!ghInstRNADll) {
      UINT uErr = GetLastError();
      DisplayErrorMessage(hWnd,IDS_ERRLoadRNADll1,uErr,ERRCLS_STANDARD,
        MB_ICONSTOP);
      return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    if (!GetApiProcAddresses(ghInstRNADll,RnaApiList,NUM_RNAAPI_PROCS)) {
      MsgBox(hWnd,IDS_ERRLoadRNADll2,MB_ICONSTOP,MB_OK);
      DeInitRNA();
      return FALSE;
    }

  }

  fRNALoaded = TRUE;

  dwRefCount ++;

  return TRUE;
}

/*******************************************************************

  NAME:    DeInitRNA

  SYNOPSIS:  Unloads RNA dll.

********************************************************************/
VOID DeInitRNA()
{
  DEBUGMSG("rnacall.c::DeInitRNA()");

  UINT nIndex;

  // decrement reference count
  if (dwRefCount)
    dwRefCount --;

  // when the reference count hits zero, do real deinitialization stuff
  if (dwRefCount == 0)
  {
    if (fRNALoaded)
    {
      // set function pointers to NULL
      for (nIndex = 0;nIndex<NUM_RNAAPI_PROCS;nIndex++) 
        *RnaApiList[nIndex].ppFcnPtr = NULL;

      fRNALoaded = FALSE;
    }

    // free the RNA dll
    if (ghInstRNADll)
    {
    DEBUGMSG("Unloading RNA DLL");
      FreeLibrary(ghInstRNADll);
      ghInstRNADll = NULL;
    }

    // free the RNAPH dll
    if (ghInstRNAPHDll)
    {
    DEBUGMSG("Unloading RNAPH DLL");
      FreeLibrary(ghInstRNAPHDll);
      ghInstRNAPHDll = NULL;
    }
  }
}

VOID FAR PASCAL LineCallback(DWORD hDevice, DWORD dwMsg, 
    DWORD dwCallbackInstance, DWORD dwParam1, DWORD dwParam2, 
    DWORD dwParam3)
{
	return;
}

/*******************************************************************

  NAME:    EnsureRNALoaded

  SYNOPSIS:  Loads RNA if not already loaded

********************************************************************/
DWORD EnsureRNALoaded(VOID)
{
  DEBUGMSG("rnacall.c::EnsureRNALoaded()");

  DWORD dwRet = ERROR_SUCCESS;

  // load RNA if necessary
  if (!fRNALoaded) {
    if (InitRNA(NULL))
      fRNALoaded = TRUE;
    else return ERROR_FILE_NOT_FOUND;
  }

  return dwRet;
}


/*******************************************************************

  NAME:    ENUM_MODEM::ENUM_MODEM

  SYNOPSIS:  Constructor for class to enumerate modems

  NOTES:    Useful to have a class rather than C functions for
        this, due to how the enumerators function

********************************************************************/
ENUM_MODEM::ENUM_MODEM() :
  m_dwError(ERROR_SUCCESS),m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize = 0;

  // Use the reinit member function to do the work.
  this->ReInit();
}


/*******************************************************************

  NAME:     ENUM_MODEM::ReInit

  SYNOPSIS: Re-enumerate the modems, freeing the old memory.

********************************************************************/
DWORD ENUM_MODEM::ReInit()
{
  DWORD cbSize = 0;

  // Clean up the old list
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
  m_dwNumEntries = 0;
  m_dwIndex = 0;

  // call RasEnumDevices with no buffer to find out required buffer size
  ASSERT(lpRasEnumDevices);
  m_dwError = lpRasEnumDevices(NULL, &cbSize, &m_dwNumEntries);

  // Special case check to work around RNA bug where ERROR_BUFFER_TOO_SMALL
  // is returned even if there are no devices.
  // If there are no devices, we are finished.
  if (0 == m_dwNumEntries)
  {
    m_dwError = ERROR_SUCCESS;
    return m_dwError;
  }

  // Since we were just checking how much mem we needed, we expect
  // a return value of ERROR_BUFFER_TOO_SMALL, or it may just return
  // ERROR_SUCCESS (ChrisK  7/9/96).
  if (ERROR_BUFFER_TOO_SMALL != m_dwError && ERROR_SUCCESS != m_dwError)
  {
    return m_dwError;
  }

  // Allocate the space for the data
  m_lpData = (LPRASDEVINFO) new CHAR[cbSize];
  if (NULL == m_lpData)
  {
    DEBUGTRAP("ENUM_MODEM: Failed to allocate device list buffer");
    m_dwError = ERROR_NOT_ENOUGH_MEMORY;
    return m_dwError;
  }
  m_lpData->dwSize = sizeof(RASDEVINFO);
  m_dwNumEntries = 0;

  // enumerate the modems into buffer
  m_dwError = lpRasEnumDevices(m_lpData, &cbSize,
    &m_dwNumEntries);

  if (ERROR_SUCCESS != m_dwError)
	  return m_dwError;

    //
    // ChrisK Olympus 4560 do not include VPN's in the list
    //
    DWORD dwTempNumEntries;
    DWORD idx;
    LPRASDEVINFO lpNextValidDevice;

    dwTempNumEntries = m_dwNumEntries;
    lpNextValidDevice = m_lpData;

	//
	// Walk through the list of devices and copy non-VPN device to the first
	// available element of the array.
	//
	for (idx = 0;idx < dwTempNumEntries; idx++)
	{
		if (0 != lstrcmpi("VPN",m_lpData[idx].szDeviceType))
		{
			if (lpNextValidDevice != &m_lpData[idx])
			{
				MoveMemory(lpNextValidDevice ,&m_lpData[idx],sizeof(RASDEVINFO));
			}
			lpNextValidDevice++;
		}
		else
		{
			m_dwNumEntries--;
		}
	}
  
  return m_dwError;
}


/*******************************************************************

  NAME:    ENUM_MODEM::~ENUM_MODEM

  SYNOPSIS:  Destructor for class

********************************************************************/
ENUM_MODEM::~ENUM_MODEM()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:     ENUM_MODEM::Next

  SYNOPSIS: Enumerates next modem 

  EXIT:     Returns a pointer to device info structure.  Returns
            NULL if no more modems or error occurred.  Call GetError
            to determine if error occurred.

********************************************************************/
CHAR * ENUM_MODEM::Next()
{
  if (m_dwIndex < m_dwNumEntries)
  {
    return m_lpData[m_dwIndex++].szDeviceName;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::GetDeviceTypeFromName

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device type string for first
            device name that matches.  Returns
            NULL if no device with specified name is found

********************************************************************/

CHAR * ENUM_MODEM::GetDeviceTypeFromName(LPSTR szDeviceName)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return m_lpData[dwIndex].szDeviceType;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::GetDeviceNameFromType

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device name string for first
            device type that matches.  Returns
            NULL if no device with specified Type is found

********************************************************************/

CHAR * ENUM_MODEM::GetDeviceNameFromType(LPSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType))
    {
      return m_lpData[dwIndex].szDeviceName;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     ENUM_MODEM::VerifyDeviceNameAndType

  SYNOPSIS: Determines whether there is a device with the name
            and type given.

  EXIT:     Returns TRUE if the specified device was found, 
            FALSE otherwise.

********************************************************************/

BOOL ENUM_MODEM::VerifyDeviceNameAndType(LPSTR szDeviceName, LPSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType) &&
      !lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return TRUE;
    }
    dwIndex++;
  }

  return FALSE;
}

/*******************************************************************

  NAME:    GetApiProcAddresses

  SYNOPSIS:  Gets proc addresses for a table of functions

  EXIT:    returns TRUE if successful, FALSE if unable to retrieve
        any proc address in table

  HISTORY: 
  96/02/28  markdu  If the api is not found in the module passed in,
            try the backup (RNAPH.DLL)

********************************************************************/
BOOL GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,UINT nApiProcs)
{
  DEBUGMSG("rnacall.c::GetApiProcAddresses()");

  UINT nIndex;
  // cycle through the API table and get proc addresses for all the APIs we
  // need
  for (nIndex = 0;nIndex < nApiProcs;nIndex++)
  {
    if (!(*pApiProcList[nIndex].ppFcnPtr = (PVOID) GetProcAddress(hModDLL,
      pApiProcList[nIndex].pszName)))
    {
      // Try to find the address in RNAPH.DLL.  This is useful in the
      // case that RASAPI32.DLL did not contain the function that we
      // were trying to load.
      if (FALSE == IsNT())
	  {
		  if (!ghInstRNAPHDll)
		  {
			CHAR szRNAPHDll[SMALL_BUF_LEN];

			LoadSz(IDS_RNAPHDLL_FILENAME,szRNAPHDll,sizeof(szRNAPHDll));
			ghInstRNAPHDll = LoadLibrary(szRNAPHDll);
		  }

		  if ((!ghInstRNAPHDll) ||  !(*pApiProcList[nIndex].ppFcnPtr =
			(PVOID) GetProcAddress(ghInstRNAPHDll,pApiProcList[nIndex].pszName)))
		  {
			DEBUGMSG("Unable to get address of function %s",
				pApiProcList[nIndex].pszName);

			for (nIndex = 0;nIndex<nApiProcs;nIndex++)
				*pApiProcList[nIndex].ppFcnPtr = NULL;

			return FALSE;
		  }
		}
	}
  }

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//	Function:	InitTAPILocation
//
//	Synopsis:	Ensure that TAPI location information is configured correctly;
//				if not, prompt user to fill it in.
//
//	Arguments:	hwndParent -- parent window for TAPI dialog to use
//							(_must_ be a valid window HWND, see note below)
//
//	Returns:	void
//
//	Notes:		The docs for lineTranslateDialog lie when they say that the
//				fourth parameter (hwndOwner) can be null.  In fact, if this
//				is null, the call will return with LINEERR_INVALPARAM.
//				
//
//	History:	7/15/97	jmazner	Created for Olympus #6294
//
//-----------------------------------------------------------------------------
void InitTAPILocation(HWND hwndParent)
{
	HLINEAPP hLineApp=NULL;
	char szTempCountryCode[8];
	char szTempCityCode[8];
	DWORD dwTapiErr = 0;
	DWORD cDevices=0;
	DWORD dwCurDevice = 0;


	ASSERT( IsWindow(hwndParent) );

	//
	// see if we can get location info from TAPI
	//
	dwTapiErr = tapiGetLocationInfo(szTempCountryCode,szTempCityCode);
	if( 0 != dwTapiErr )
	{
		// 
		// GetLocation failed.  let's try calling the TAPI mini dialog.  Note
		// that when called in this fashion, the dialog has _no_ cancel option,
		// the user is forced to enter info and hit OK.
		//
		DEBUGMSG("InitTAPILocation, tapiGetLocationInfo failed");
		
		dwTapiErr = lineInitialize(&hLineApp,ghInstance,LineCallback," ",&cDevices);
		if (dwTapiErr == ERROR_SUCCESS)
		{
			//
			// loop through all TAPI devices and try to call lineTranslateDialog
			// The call might fail for VPN devices, thus we want to try every
			// device until we get a success.
			//
			dwTapiErr = LINEERR_INVALPARAM;

			while( (dwTapiErr != 0) && (dwCurDevice < cDevices) )
			{
				dwTapiErr = lineTranslateDialog(hLineApp,dwCurDevice,0x10004,hwndParent,NULL);
				if( 0 != dwTapiErr )
				{
					DEBUGMSG("InitTAPILocation, lineTranslateDialog on device %d failed with err = %d!",
						dwCurDevice, dwTapiErr);
				}
				dwCurDevice++;
			}
		}
		else
		{
			DEBUGMSG("InitTAPILocation, lineInitialize failed with err = %d", dwTapiErr);
		}

		dwTapiErr = tapiGetLocationInfo(szTempCountryCode,szTempCityCode);
		if( 0 != dwTapiErr )
		{
			DEBUGMSG("InitTAPILocation still failed on GetLocationInfo, bummer.");
		}
		else
		{
			DEBUGMSG("InitTAPILocation, TAPI location is initialized now");
		}
	}

	if( hLineApp )
	{
		lineShutdown(hLineApp);
		hLineApp = NULL;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\rnacall.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  RNACALL.H - header file for RNA functions 
//

//  HISTORY:
//  
//  1/20/95   jeremys Created (mostly cloned from RNA UI code)
//  96/01/31  markdu  Renamed CONNENTDLG to OLDCONNENTDLG to avoid
//            conflicts with RNAP.H.
//  96/02/23  markdu  Replaced RNAValidateEntryName with
//            RASValidateEntryName
//  96/02/24  markdu  Re-wrote the definition of ENUM_MODEM to
//            use RASEnumDevices() instead of RNAEnumDevices().
//            Also removed RNAGetDeviceInfo().
//  96/02/24  markdu  Re-wrote the definition of ENUM_CONNECTOID to
//            use RASEnumEntries() instead of RNAEnumConnEntries().
//  96/02/26  markdu  Replaced all remaining internal RNA APIs.
//            Also copied two structures (tagPhoneNum and tapIPData)
//            from rnap.h and tagIAddr from rnaphint.h for internal use only.
//  96/03/07  markdu  Extend ENUM_MODEM class
//  96/03/08  markdu  Added ENUM_MODEM::VerifyDeviceNameAndType
//  96/03/09  markdu  Moved all function prototypes here from wizard.h
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//            Also no longer need GetConnectoidPhoneNumber function.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//            Moved tagPhoneNum to inetapi.h
//  96/03/11  markdu  Moved code to set username and password out of
//            CreateConnectoid into SetConnectoidUsername so it can be reused.
//  96/03/13  markdu  Change ValidateConncectoidName to take LPCSTR.
//  96/03/16  markdu  Added ReInit member function to re-enumerate modems.
//  96/03/25  markdu  Removed GetIPInfo and SetIPInfo.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid,
//            ValidateConnectoidName, and SetConnectoidUsername.
//  96/05/16  markdu  NASH BUG 21810 Added function for IP address validation.
//

#ifndef _RNACALL_H_
#define _RNACALL_H_

// function pointer typedefs for RNA apis from rnaph.dll and rasapi32.dll
typedef DWORD       (WINAPI * RASENUMDEVICES) (LPRASDEVINFO, LPDWORD, LPDWORD);
typedef DWORD       (WINAPI * RASENUMENTRIES) (LPSTR,LPSTR,LPRASENTRYNAME,LPDWORD,LPDWORD);

class ENUM_MODEM
{
private:
  DWORD         m_dwError;
  DWORD         m_dwNumEntries;
  DWORD         m_dwIndex;
  LPRASDEVINFO  m_lpData;
public:
  ENUM_MODEM();
  ~ENUM_MODEM();
  DWORD ReInit();
  CHAR * Next();
  CHAR * GetDeviceTypeFromName(LPSTR szDeviceName);
  CHAR * GetDeviceNameFromType(LPSTR szDeviceType);
  BOOL VerifyDeviceNameAndType(LPSTR szDeviceName, LPSTR szDeviceType);
  DWORD GetNumDevices() { return m_dwNumEntries; }
  DWORD GetError()  { return m_dwError; }
  void  ResetIndex() { m_dwIndex = 0; }
};

// function prototypes

BOOL InitRNA(HWND hWnd);
VOID DeInitRNA();
DWORD EnsureRNALoaded(VOID);

#endif // _RNACALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\wizard.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1999 Microsoft Corporation
//*********************************************************************

//
//  WIZARD.H - central header file for Internet setup/signup wizard
//

//  HISTORY:
//
//  11/20/94  jeremys  Created.
//  96/02/24  markdu  Added RNAPH.H
//  96/02/27  markdu  Replaced internal RNA header files with RAS.H
//  96/03/07  markdu  Added gpEnumModem
//  96/03/09  markdu  Moved all rnacall function prototypes to rnacall.h
//  96/03/09  markdu  Added gpRasEntry
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//  96/04/24  markdu  NASH BUG 19289 Added /NOMSN command line flag
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#ifndef _WIZARD_H_
#define _WIZARD_H_

#define STRICT                      // Use strict handle types
#define _SHELL32_

  #include <windows.h>
  #include <commctrl.h>
  #include <oharestr.h>

  // various RNA header files
#pragma pack(8)
  #include <ras.h>
  #include <ras2.h>
#pragma pack()
  #include <raserror.h>
  #include "rnacall.h"
  #include <wizglob.h>
  #include <wizdebug.h>

#undef DATASEG_READONLY
#define DATASEG_READONLY  ".rdata"

#include "cfgapi.h"
#include "clsutil.h"

#include "icfgcall.h"
#include "ids.h"

// Globals

extern ENUM_MODEM*  gpEnumModem;    // modem enumeration object
extern HINSTANCE    ghInstance;     // global module instance handle

// Defines

#define MAX_REG_LEN			2048	// max length of registry entries
#define MAX_RES_LEN         255 // max length of string resources
#define SMALL_BUF_LEN       48  // convenient size for small text buffers

// error class defines for DisplayErrorMessage
#define ERRCLS_STANDARD 0x0001
#define ERRCLS_SETUPX   0x0002
//#define ERRCLS_RNA      0x0003
//#define ERRCLS_MAPI     0x0004


// functions in TCPCFG.CPP

HRESULT WarnIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart);
HRESULT RemoveIfServerBound(HWND hDlg,DWORD dwCardFlags,BOOL* pfNeedsRestart);

// functions in CALLOUT.C
UINT InvokeModemWizard(HWND hwndToHide);

// functions in UTIL.C
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons);
// jmazner 11/6/96	modified for RISC compatability
//int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...);
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons, LPSTR szParam = NULL);

LPSTR LoadSz(UINT idString,LPSTR lpszBuf,UINT cbBuf);

// modified for RISC compatability
//VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
//  UINT uErrorClass,UINT uIcon,...);
VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,LPSTR szArg = NULL);

VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass);

DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent);

// structure for getting proc addresses of api functions
typedef struct APIFCN {
  PVOID * ppFcnPtr;
  LPCSTR pszName;
} APIFCN;

#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT    DATASEG_SHARED

inline BOOL IsNT(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}

#endif // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\wizdll.cpp ===
/*****************************************************************/
/**          Microsoft Windows for Workgroups        **/
/**          Copyright (c) 1991-1998 Microsoft Corporation
/*****************************************************************/ 

//
//  WIZDLL.C - 32-bit stubs for functions that call into 16-bit DLL
//

//  HISTORY:
//  
//  11/20/94  jeremys  Created.
//  96/03/13  markdu  Added IcfgSetInstallSourcePath().
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/05/28  markdu  InitConfig and DeInitConfig in DllEntryPoint.
//

#include "wizard.h"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
HINSTANCE ghInstance=NULL;
#pragma data_seg(DATASEG_DEFAULT)

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to WIZ16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
  if( fdwReason == DLL_PROCESS_ATTACH )
  {
    ghInstance = hInstDll;

	// load the config dll proc addresses
    BOOL fRet = InitConfig(NULL);
    if (FALSE == fRet)
    {
      // Error message was already displayed in InitConfig.
      return FALSE;
    }
  }

  if( fdwReason == DLL_PROCESS_DETACH )
  {
    DeInitConfig();
  }

  return TRUE;
}


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

void __cdecl main() {};

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\allcmdir.h ===
//+----------------------------------------------------------------------------
//
// File:     allcmdir.h
//
// Module:   CMSTP.EXE and CMCFG32.DLL
//
// Synopsis: Resource IDs for allcmdir.rc
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb  Created    08/05/99
//
//+----------------------------------------------------------------------------
#define	IDS_CMSUBFOLDER	        	500
#define	IDS_APPDATA	        	501
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cnetcfg\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  12/21/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//            Need to keep a modified SetInternetConnectoid to set the
//            MSN backup connectoid.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//

#include "wizard.h"
#if 0
#include "string.h"
#endif

#include "winver.h"

// function prototypes
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,LPSTR szArg);
extern GETSETUPXERRORTEXT lpGetSETUPXErrorText;

/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    CHAR szMsgBuf[MAX_RES_LEN+1];
  CHAR szSmallBuf[SMALL_BUF_LEN+1];

    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    LoadSz(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons)
{
  CHAR szSmallBuf[SMALL_BUF_LEN+1];
  LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

/*******************************************************************

  NAME:    MsgBoxParam

  SYNOPSIS:  Displays a message box with the specified string ID

  NOTES:    //extra parameters are string pointers inserted into nMsgID.
			jmazner 11/6/96 For RISC compatability, we don't want
			to use va_list; since current source code never uses more than
			one string parameter anyways, just change function signature
			to explicitly include that one parameter.

********************************************************************/
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,LPSTR szParam)
{
  BUFFER Msg(3*MAX_RES_LEN+1);  // nice n' big for room for inserts
  BUFFER MsgFmt(MAX_RES_LEN+1);
  //va_list args;

  if (!Msg || !MsgFmt) {
    return MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONSTOP,MB_OK);
  }

    LoadSz(nMsgID,MsgFmt.QueryPtr(),MsgFmt.QuerySize());

  //va_start(args,uButtons);
  //FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
  //  MsgFmt.QueryPtr(),args);
	FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
		MsgFmt.QueryPtr(),szParam);

  return MsgBoxSz(hWnd,Msg.QueryPtr(),uIcon,uButtons);
}

/*******************************************************************

  NAME:    LoadSz

  SYNOPSIS:  Loads specified string resource into buffer

  EXIT:    returns a pointer to the passed-in buffer

  NOTES:    If this function fails (most likely due to low
        memory), the returned buffer will have a leading NULL
        so it is generally safe to use this without checking for
        failure.

********************************************************************/
LPSTR LoadSz(UINT idString,LPSTR lpszBuf,UINT cbBuf)
{
  ASSERT(lpszBuf);

  // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

/*******************************************************************

  NAME:    GetErrorDescription

  SYNOPSIS:  Retrieves the text description for a given error code
        and class of error (standard, setupx)

********************************************************************/
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass)
{
  ASSERT(pszErrorDesc);

  // set a leading null in error description
  *pszErrorDesc = '\0';
  
  switch (uErrorClass) {

    case ERRCLS_STANDARD:

      if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,
        uError,0,pszErrorDesc,cbErrorDesc,NULL)) {
        // if getting system text fails, make a string a la
        // "error <n> occurred"
        CHAR szFmt[SMALL_BUF_LEN+1];
        LoadSz(IDS_ERRFORMAT,szFmt,sizeof(szFmt));
        wsprintf(pszErrorDesc,szFmt,uError);
      }

      break;

    case ERRCLS_SETUPX:

      lpGetSETUPXErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    default:

      DEBUGTRAP("Unknown error class %lu in GetErrorDescription",
        uErrorClass);

  }

}
  
/*******************************************************************

  NAME:    FormatErrorMessage

  SYNOPSIS:  Builds an error message by calling FormatMessage

  NOTES:    Worker function for DisplayErrorMessage

********************************************************************/
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,LPSTR szArg)
{
  ASSERT(pszMsg);
  ASSERT(pszFmt);

  // build the message into the pszMsg buffer
  DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
    pszFmt,0,0,pszMsg,cbMsg,(va_list*) &szArg);
  ASSERT(dwCount > 0);
}

/*******************************************************************

  NAME:    DisplayErrorMessage

  SYNOPSIS:  Displays an error message for given error 

  ENTRY:    hWnd - parent window
        uStrID - ID of string resource with message format.
          Should contain %1 to be replaced by error text,
          additional parameters can be specified as well.
        uError - error code for error to display
        uErrorClass - ERRCLS_xxx ID of class of error that
          uError belongs to (standard, setupx)
        uIcon - icon to display
        //... - additional parameters to be inserted in string
        //  specified by uStrID
		jmazner 11/6/96 change to just one parameter for
		RISC compatability.

********************************************************************/
VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,LPSTR szArg)
{
  // dynamically allocate buffers for messages
  BUFFER ErrorDesc(MAX_RES_LEN+1);
  BUFFER ErrorFmt(MAX_RES_LEN+1);
  BUFFER ErrorMsg(2*MAX_RES_LEN+1);  

  if (!ErrorDesc || !ErrorFmt || !ErrorMsg) {
    // if can't allocate buffers, display out of memory error
    MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
    return;
  }

  // get a text description based on the error code and the class
  // of error it is
  GetErrorDescription(ErrorDesc.QueryPtr(),
    ErrorDesc.QuerySize(),uError,uErrorClass);

  // load the string for the message format
  LoadSz(uStrID,ErrorFmt.QueryPtr(),ErrorFmt.QuerySize());

  //LPSTR args[MAX_MSG_PARAM];
  //args[0] = (LPSTR) ErrorDesc.QueryPtr();
  //memcpy(&args[1],((CHAR *) &uIcon) + sizeof(uIcon),(MAX_MSG_PARAM - 1) * sizeof(LPSTR));

  //FormatErrorMessage(ErrorMsg.QueryPtr(),ErrorMsg.QuerySize(),
  //  ErrorFmt.QueryPtr(),(va_list) &args[0]);
  FormatErrorMessage(ErrorMsg.QueryPtr(),ErrorMsg.QuerySize(),
    ErrorFmt.QueryPtr(),ErrorDesc.QueryPtr());


  // display the message
  MsgBoxSz(hWnd,ErrorMsg.QueryPtr(),uIcon,MB_OK);

}

/*******************************************************************

  NAME:    MsgWaitForMultipleObjectsLoop

  SYNOPSIS:  Blocks until the specified object is signaled, while
        still dispatching messages to the main thread.

********************************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent)
{
    MSG msg;
    DWORD dwObject;
    while (1)
    {
        // NB We need to let the run dialog become active so we have to half handle sent
        // messages but we don't want to handle any input events or we'll swallow the
        // type-ahead.
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE,INFINITE, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
      // got a message, dispatch it and wait again
      while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) {
        DispatchMessage(&msg);
      }
            break;
        }
    }
    // never gets here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\bmpimage.h ===
//+----------------------------------------------------------------------------
//
// File:     bmpimage.h
//
// Module:   CMAK.EXE and CMDIAL32.DLL
//
// Synopsis: Definition of the CM Bitmap display routines.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb/nickball      Created      08/06/98
//
//+----------------------------------------------------------------------------
#ifndef _BMP_IMAGE_H
#define _BMP_IMAGE_H

#include <windows.h>

#include "cmutil.h"
#include "cmdebug.h"

typedef struct tagBmpData
{
	HBITMAP hDIBitmap;	        // bitmap, in device-independent format
	HBITMAP hDDBitmap;		    // bitmap, in device-dependent format
	LPBITMAPINFO pBmi;          // bitmap info for the bitmap, the raw bits
    HPALETTE *phMasterPalette;	// Master Palette, used when displaying any bitmap
    BOOL bForceBackground;      // determines background/foreground mode
} BMPDATA, *LPBMPDATA;


LPBITMAPINFO CmGetBitmapInfo(HBITMAP hbm);
static HPALETTE CmCreateDIBPalette(LPBITMAPINFO pbmi);
void ReleaseBitmapData(LPBMPDATA pBmpData);
BOOL CreateBitmapData(HBITMAP hDIBmp, LPBMPDATA lpBmpData, HWND hwnd, BOOL fCustomPalette);
LRESULT CALLBACK BmpWndProc(HWND hwndBmp, UINT uMsg, WPARAM wParam, LPARAM lParam);
void QueryNewPalette(LPBMPDATA lpBmpData, HWND hwndDlg, int iBmpCtrl);
void PaletteChanged(LPBMPDATA lpBmpData, HWND hwndDlg, int iBmpCtrl);
HBITMAP CmLoadBitmap(HINSTANCE hInst, LPCTSTR pszSpec);


#endif // _BMP_IMAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cfgapi.h ===
//*******************************************************************
//
//  Copyright (c) 1996-1998 Microsoft Corporation
//
//  FILE: CFGAPI.H
//
//  PURPOSE:  Contains API's exported from icfg32.dll and structures
//            required by those functions.
//
//*******************************************************************

#ifndef _CFGAPI_H_
#define _CFGAPI_H_

// Maximum buffer size for error messages.
#define MAX_ERROR_TEXT  512

// Flags for dwfOptions

// install TCP (if needed)
#define ICFG_INSTALLTCP            0x00000001

// install RAS (if needed)
#define ICFG_INSTALLRAS            0x00000002

// install exchange and internet mail
#define ICFG_INSTALLMAIL           0x00000004

//
// ChrisK 5/8/97
// Note: the next three switches are only valid for IcfgNeedInetComponet
// check to see if a LAN adapter with TCP bound is installed
//
#define ICFG_INSTALLLAN            0x00000008

//
// Check to see if a DIALUP adapter with TCP bound is installed
//
#define ICFG_INSTALLDIALUP         0x00000010

//
// Check to see if TCP is installed
//
#define ICFG_INSTALLTCPONLY        0x00000020

// DRIVERTYPE_ defines for TCP/IP configuration apis
#define DRIVERTYPE_NET  0x0001
#define DRIVERTYPE_PPP  0x0002


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//*******************************************************************
//
//  FUNCTION:   IcfgNeedInetComponents
//
//  PURPOSE:    Detects whether the specified system components are
//              installed or not.
//
//  PARAMETERS: dwfOptions - a combination of ICFG_ flags that specify
//              which components to detect as follows:
//
//                ICFG_INSTALLTCP - is TCP/IP needed?
//                ICFG_INSTALLRAS - is RAS needed?
//                ICFG_INSTALLMAIL - is exchange or internet mail needed?
//
//              lpfNeedComponents - TRUE if any specified component needs
//              to be installed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents);
HRESULT IcfgNeedInetComponentsNT4(DWORD dwfOptions, LPBOOL lpfNeedComponents);
HRESULT IcfgNeedInetComponentsNT5(DWORD dwfOptions, LPBOOL lpfNeedComponents);


//*******************************************************************
//
//  FUNCTION:   IcfgInstallInetComponents
//
//  PURPOSE:    Install the specified system components.
//
//  PARAMETERS: hwndParent - Parent window handle.
//              dwfOptions - a combination of ICFG_ flags that controls
//              the installation and configuration as follows:
//
//                ICFG_INSTALLTCP - install TCP/IP (if needed)
//                ICFG_INSTALLRAS - install RAS (if needed)
//                ICFG_INSTALLMAIL - install exchange and internet mail
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart);
HRESULT IcfgInstallInetComponentsNT4(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart);
HRESULT IcfgInstallInetComponentsNT5(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart);


//+----------------------------------------------------------------------------
//
//	Function:	IcfgNeedModem
//
//	Synopsis:	Check system configuration to determine if there is at least
//				one physical modem installed
//
//	Arguments:	dwfOptions - currently not used
//
//	Returns:	HRESULT - S_OK if successfull
//				lpfNeedModem - TRUE if no modems are available
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT IcfgNeedModem(DWORD dwfOptions, LPBOOL lpfNeedModem);
HRESULT IcfgNeedModemNT4(DWORD dwfOptions, LPBOOL lpfNeedModem) ;
HRESULT IcfgNeedModemNT5(DWORD dwfOptions, LPBOOL lpfNeedModem) ;



//+----------------------------------------------------------------------------
//
//	Function:	IcfgNeedModem
//
//	Synopsis:	Check system configuration to determine if there is at least
//				one physical modem installed
//
//	Arguments:	dwfOptions - currently not used
//
//	Returns:	HRESULT - S_OK if successfull
//				lpfNeedModem - TRUE if no modems are available
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT IcfgInstallModem (HWND hwndParent, DWORD dwfOptions, 
							LPBOOL lpfNeedsStart);
HRESULT IcfgInstallModemNT4 (HWND hwndParent, DWORD dwfOptions, 
							LPBOOL lpfNeedsStart);
HRESULT IcfgInstallModemNT5 (HWND hwndParent, DWORD dwfOptions, 
							LPBOOL lpfNeedsStart);




//*******************************************************************
//
//  FUNCTION:   IcfgGetLastInstallErrorText
//
//  PURPOSE:    Get a text string that describes the last installation
//              error that occurred.  The string should be suitable
//              for display in a message box with no further formatting.
//
//  PARAMETERS: lpszErrorDesc - points to buffer to receive the string.
//              cbErrorDesc - size of buffer.
//
//  RETURNS:    The length of the string returned.
//
//*******************************************************************

DWORD IcfgGetLastInstallErrorText(LPSTR lpszErrorDesc, DWORD cbErrorDesc);


//*******************************************************************
//
//  FUNCTION:   IcfgSetInstallSourcePath
//
//  PURPOSE:    Sets the path where windows looks when installing files.
//
//  PARAMETERS: lpszSourcePath - full path of location of files to install.
//              If this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT IcfgSetInstallSourcePath(LPCSTR lpszSourcePath);


//*******************************************************************
//
//  FUNCTION:   IcfgIsGlobalDNS
//
//  PURPOSE:    Determines whether there is Global DNS set.
//
//  PARAMETERS: lpfGlobalDNS - TRUE if global DNS is set, FALSE otherwise.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and
//              should always return ERROR_SUCCESS and set lpfGlobalDNS
//              to FALSE in Windows NT.
//
//*******************************************************************

HRESULT IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS);


//*******************************************************************
//
//  FUNCTION:   IcfgRemoveGlobalDNS
//
//  PURPOSE:    Removes global DNS info from registry.
//
//  PARAMETERS: None.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and
//              should always return ERROR_SUCCESS in Windows NT.
//
//*******************************************************************

HRESULT IcfgRemoveGlobalDNS(void);


//*******************************************************************
//
//  FUNCTION:   IcfgIsFileSharingTurnedOn
//
//  PURPOSE:    Determines if file server (VSERVER) is bound to TCP/IP
//              for specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to check server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//              lpfSharingOn - TRUE if bound once or more, FALSE if not bound
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn);


//*******************************************************************
//
//  FUNCTION:   IcfgTurnOffFileSharing
//
//  PURPOSE:    Unbinds file server (VSERVER) from TCP/IP for
//              specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to remove server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent);
VOID   GetSETUPXErrorText(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc);
UINT DoGenInstall(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect);

//*******************************************************************
//*******************************************************************

HRESULT InetSetAutodial(BOOL fEnable, LPCSTR lpszEntryName);

//*******************************************************************
//*******************************************************************

HRESULT InetGetAutodial(LPBOOL lpfEnable, LPSTR lpszEntryName,
                        DWORD cbEntryName);

//*******************************************************************
//*******************************************************************

HRESULT InetSetAutodialAddress();

//*******************************************************************
//*******************************************************************

HRESULT InetGetSupportedPlatform(LPDWORD pdwPlatform);

//*******************************************************************
//*******************************************************************

HRESULT IcfgStartServices();

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_CFGAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cfilename.h ===
//+----------------------------------------------------------------------------
//
// File:     cfilename.h
//
// Module:   CMUTIL.DLL
//
// Synopsis: Definition of the CFileNameParts class.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#ifndef _CFILENAMEPARTS_H_
#define _CFILENAMEPARTS_H_

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include "cmdebug.h"

class CFileNameParts
{

public:

CFileNameParts(LPCTSTR szFullPath);
~CFileNameParts() {}

public: // Public member variables use them directly
   TCHAR m_szFullPath[MAX_PATH+1];

   TCHAR m_Drive[_MAX_DRIVE+1];
   TCHAR m_Dir[_MAX_DIR+1];
   TCHAR m_FileName[_MAX_FNAME+1];
   TCHAR m_Extension[_MAX_EXT+1];


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmdial.h ===
//+----------------------------------------------------------------------------
//
// File:     cmdial.h
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Header file for Private CM APIs
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   nickball   Created     02/05/98
//
//+----------------------------------------------------------------------------
#ifndef _CMDIAL_INC_
#define _CMDIAL_INC_

//
// Type definitions
//

typedef struct CmDialInfo
{
    WCHAR szPassword[PWLEN + 1];        // Primary/Tunnel Password used for connection
    WCHAR szInetPassword[PWLEN + 1];    // Secondary/ISP password used for connection
    DWORD dwCmFlags;
} CMDIALINFO, * LPCMDIALINFO;

//+----------------------------------------------------------------------------
//
// Function: CmCustomDialDlg
//
// Synopsis:  Our CM specific variation on RasCustomDialDlg.  
//
// Arguments: HWND          hwndParent - The HWND of the parent window.
//            DWORD         dwFlags - Dial flags
//            LPTSTR        lpszPhonebook - Ptr to the full path and filename of the phonebook.
//            LPTSTR        lpszEntry - Ptr to the name of the phone-book entry to dial.
//            LPTSTR        lpszPhoneNumber - Ptr to replacement phone number
//            LPRASDIALDLG  lpRasDialDlg - Ptr to structure for additional RAS parameters 
//            LPRASENTRYDLG lpRasEntryDlg -- Ptr to structure for additional RAS parameters 
//            LPCMDIALINFO  lpCmInfo - Ptr to structure containing CM dial info such as flags.
//            LPVOID lpv    lpv - Ptr to blob passed by RAS during WinLogon on W2K.
//
// Returns:   BOOL WINAPI - TRUE on success
//
//+----------------------------------------------------------------------------
extern "C" BOOL WINAPI CmCustomDialDlg(HWND hwndParent, 
    DWORD dwFlags, 
    LPWSTR lpszPhonebook, 
    LPCWSTR lpszEntry, 
    LPWSTR lpszPhoneNumber, 
    LPRASDIALDLG lpRasDialDlg,
    LPRASENTRYDLGW lpRasEntryDlg,
    LPCMDIALINFO lpCmInfo,
    LPVOID lpvLogonBlob=NULL);

//+----------------------------------------------------------------------------
//
// Function:  CmCustomHangUp
//
// Synopsis:  Our CM specific variation on RasCustomHangUp. Optionally, the entry
//            name may be given instead of the RAS handle.
//
// Arguments: HRASCONN hRasConn - The handle of the connection to be terminated.
//            LPCTSTR pszEntry - Ptr to the name of the entry to be terminated.
//            BOOL fPersist - Preserve the entry and its usage count.
//
// Returns:   DWORD WINAPI - Return code
//
//+----------------------------------------------------------------------------
extern "C" DWORD WINAPI CmCustomHangUp(HRASCONN hRasConn, 
    LPCWSTR pszEntry,
    BOOL fIgnoreRefCount,
    BOOL fPersist);

//+----------------------------------------------------------------------------
//
// Function:  CmReConnect
//
// Synopsis:  Used specificly for CMMON to call upon reconnect
//
// Arguments: LPTSTR        lpszPhonebook - Ptr to the full path and filename of the phonebook.
//            LPTSTR        lpszEntry - Ptr to the name of the phone-book entry to dial.
//            LPCMDIALINFO lpCmInfo - The reconnect information
//
// Returns:   DWORD WINAPI - Return code
//
//+----------------------------------------------------------------------------
extern "C"  
BOOL CmReConnect(    LPTSTR lpszPhonebook, 
    LPWSTR lpszEntry, 
    LPCMDIALINFO lpCmInfo);

#endif _CMDIAL_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmakver.h ===
//+----------------------------------------------------------------------------
//
// File:     cmakver.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Definition of the CmakVersion class.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created     09/14/98
//
//+----------------------------------------------------------------------------

#ifndef __CMAKVER_H
#define __CMAKVER_H

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include "pnpuverp.h"

const int c_Cmak10Version = 613;
const int c_Cmak121Version = 1886;
const int c_CmakUnicodeAware = 2050;
const int c_Win2kRTMBuildNumber = 2195;

const DWORD c_dwCurrentCmakVersionNumber = ((HIBYTE(VER_PRODUCTVERSION_W) << c_iShiftAmount) + (LOBYTE(VER_PRODUCTVERSION_W)));
const DWORD c_dwVersionSevenPointOne = (7 << c_iShiftAmount) + 1;
const DWORD c_dwVersionSeven = (7 << c_iShiftAmount);
const DWORD c_dwVersionSix = (6 << c_iShiftAmount);
const DWORD c_dwCmak10BuildNumber = (c_Cmak10Version << c_iShiftAmount);
const DWORD c_dwFirst121BuildNumber = ((c_Cmak121Version << c_iShiftAmount) + VER_PRODUCTBUILD_QFE);
const DWORD c_dwFirstUnicodeBuildNumber = ((c_CmakUnicodeAware << c_iShiftAmount) + VER_PRODUCTBUILD_QFE);
const DWORD c_dwWin2kRTMBuildNumber = ((c_Win2kRTMBuildNumber << c_iShiftAmount) + VER_PRODUCTBUILD_QFE);

class CmakVersion : public CVersion
{
public:	//	Public Methods
	CmakVersion();
	~CmakVersion();
	BOOL GetInstallLocation	(LPTSTR szStr);
	BOOL Is10Cmak();
	BOOL Is11or12Cmak();
	BOOL Is121Cmak();    
    BOOL Is122Cmak();
    BOOL Is13Cmak();
    DWORD GetNativeCmakLCID();

private:	//	Member Variables

    //
    // this actually contains the install location path, C:\program files\cmak\cmak.exe
    //
    TCHAR m_szCmakPath[MAX_PATH+1];	
};

#endif	// __CMAKVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmglobal.h ===
//+----------------------------------------------------------------------------
//
// File:     cmglobal.h
//
// Module:   CMDIAL32.DLL and CMSETUP.LIB
//
// Synopsis: Definitions global to all of CM.
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball   Created      07/10/97
//
//+----------------------------------------------------------------------------

#ifndef _CM_GLOBAL
#define _CM_GLOBAL

//
// Here is the Profile Version Number.  This number is used in cmak, cmstp, and
// in CM itself.  If you change this number, you must also update it in the template.inf,
// template.pmc (cmp), and the template.smc (cms).
//

const DWORD PROFILEVERSION = 4;

#endif // _CM_GLOBAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmdebug.h ===
//+----------------------------------------------------------------------------
//
// File:     cmdebug.h
//
// Module:   CMDEBUG.LIB
//
// Synopsis: Header file for Internal CM Debugging functions.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header     08/19/99
//
//+----------------------------------------------------------------------------
#ifndef CMDEBUG_H
#define CMDEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

//
// Macros for debugging support.
//
// MYDBGASSERT(x): If (!x) Assert MessageBox which has three option:
//                         Abort to end the application,
//                         Ignore to continue,
//                         Retry to debug
// 
// CMASSERTMSG(exp, msg)  Similar to MYDBGASSERT.  Except the msg is displayed instead of expression
//
// Use CMTRACE(x) for output, where x is a list of printf()-style parameters.  
//     CMTRACEn() is TRACE with n printf arguments
//     For example, CMTRACE2(("This shows how to print stuff, like a string %s, and a number %u.","string",5));
//
// MYDBG is obsolete and equivalent to CMTRACE
//
// Use MYDBGTST(y,x) to output x if y is TRUE.  For example,
//      MYDBGTST(1,("This always prints"));
//
// Use MYDBGSTR(x) for safe-printing of string pointers.  For example,
//      MYDBG(("This would normally, fault - %s.",MYDBGSTR(NULL)));
//
// USE MYVERIFY for expressions executed for both debug and release version

#ifdef DEBUG

    void MyDbgPrintfA(const char *pszFmt, ...);
    void MyDbgPrintfW(const WCHAR *pszFmt, ...);
    void MyDbgAssertA(const char *pszFile, unsigned nLine, const char *pszMsg);
    void MyDbgAssertW(const char *pszFile, unsigned nLine, WCHAR *pszMsg);
    void InvertPercentSAndPercentC(LPSTR pszFormat);
    int WINAPI wvsprintfWtoAWrapper(OUT LPSTR pszAnsiOut, IN LPCWSTR pszwFmt, IN va_list arglist);

    #define MYDBGASSERTA(x)     (void)((x) || (MyDbgAssertA(__FILE__,__LINE__,#x),0))
    #define MYDBGASSERTW(x)     (void)((x) || (MyDbgAssertW(__FILE__,__LINE__,L#x),0))

    #define MYVERIFYA(x) MYDBGASSERTA(x)
    #define MYVERIFYW(x) MYDBGASSERTW(x)

    #define MYDBGTSTA(y,x)      if (y) MyDbgPrintfA x
    #define MYDBGTSTW(y,x)      if (y) MyDbgPrintfW x


    // {MYDBGASSERT(pObj);pObj->AssertValid();} 
    #define ASSERT_VALID(pObj) ((MYDBGASSERT(pObj),1) && ((pObj)->AssertValid(),1))

    #define MYDBGA(x)           MyDbgPrintfA x
    #define MYDBGW(x)           MyDbgPrintfW x

    #define MYDBGSTRA(x)        ((x)?(x):"(null)")
    #define MYDBGSTRW(x)        ((x)?(x):L"(null)")

    #define CMASSERTMSGA(exp, msg)   (void)((exp) || (MyDbgAssertA(__FILE__,__LINE__,msg),0))
    #define CMASSERTMSGW(exp, msg)   (void)((exp) || (MyDbgAssertW(__FILE__,__LINE__,msg),0))

    #define CMTRACEA(pszFmt)                    MyDbgPrintfA(pszFmt)
    #define CMTRACEW(pszFmt)                    MyDbgPrintfW(pszFmt)

    #define CMTRACEHRA(pszFile, hr)             if (hr) MyDbgPrintfA("%s: returns error %x", pszFile, (hr));
    #define CMTRACEHRW(pszFile, hr)             if (hr) MyDbgPrintfW(L"%s: returns error %x", pszFile, (hr));

    #define CMTRACE1A(pszFmt, arg1)             MyDbgPrintfA(pszFmt, arg1)
    #define CMTRACE1W(pszFmt, arg1)             MyDbgPrintfW(pszFmt, arg1)

    #define CMTRACE2A(pszFmt, arg1, arg2)       MyDbgPrintfA(pszFmt, arg1, arg2)
    #define CMTRACE2W(pszFmt, arg1, arg2)       MyDbgPrintfW(pszFmt, arg1, arg2)

    #define CMTRACE3A(pszFmt, arg1, arg2, arg3) MyDbgPrintfA(pszFmt, arg1, arg2, arg3)
    #define CMTRACE3W(pszFmt, arg1, arg2, arg3) MyDbgPrintfW(pszFmt, arg1, arg2, arg3)

    #ifdef UNICODE
        #define MyDbgPrintf MyDbgPrintfW        
        #define MyDbgAssert MyDbgAssertW        
        #define MYDBGTST(y,x) MYDBGTSTW(y,x)
        #define MYDBG(x) MYDBGW(x)
        #define MYDBGSTR(x) MYDBGSTRW(x)
        #define CMASSERTMSG(exp, msg) CMASSERTMSGW(exp, msg)
        #define CMTRACE(pszFmt) CMTRACEW(pszFmt)
        #define CMTRACEHR(pszFile, hr) CMTRACEHRW(pszFile, hr)
        #define CMTRACE1(pszFmt, arg1) CMTRACE1W(pszFmt, arg1)
        #define CMTRACE2(pszFmt, arg1, arg2) CMTRACE2W(pszFmt, arg1, arg2)
        #define CMTRACE3(pszFmt, arg1, arg2, arg3) CMTRACE3W(pszFmt, arg1, arg2, arg3)
        #define MYDBGASSERT MYDBGASSERTW
        #define MYVERIFY MYVERIFYW
    #else
        #define MyDbgPrintf MyDbgPrintfA
        #define MyDbgAssert MyDbgAssertA
        #define MYDBGTST(y,x) MYDBGTSTA(y,x)
        #define MYDBG(x) MYDBGA(x)
        #define MYDBGSTR(x) MYDBGSTRA(x)
        #define CMASSERTMSG(exp, msg) CMASSERTMSGA(exp, msg)
        #define CMTRACE(pszFmt) CMTRACEA(pszFmt)
        #define CMTRACEHR(pszFile, hr) CMTRACEHRA(pszFile, hr)
        #define CMTRACE1(pszFmt, arg1) CMTRACE1A(pszFmt, arg1)
        #define CMTRACE2(pszFmt, arg1, arg2) CMTRACE2A(pszFmt, arg1, arg2)
        #define CMTRACE3(pszFmt, arg1, arg2, arg3) CMTRACE3A(pszFmt, arg1, arg2, arg3)
        #define MYDBGASSERT MYDBGASSERTA
        #define MYVERIFY MYVERIFYA
    #endif

#else // DEBUG

    #define ASSERT_VALID(pObj) 

    #define MYDBG(x)
    #define MYDBGTST(y,x)
    #define MYDBGSTR(x)
    #define MYDBGASSERT(x)

    #define CMASSERTMSG(exp, msg)
    #define MYVERIFY(x) (x)
    #define CMTRACE(pszFmt)
    #define CMTRACEHR(pszFile, hr)
    #define CMTRACE1(pszFmt, arg1)             
    #define CMTRACE2(pszFmt, arg1, arg2)       
    #define CMTRACE3(pszFmt, arg1, arg2, arg3)

    #define MYDBGASSERTA(x)
    #define MYDBGASSERTW(x)

    #define MYVERIFYA(x)
    #define MYVERIFYW(x)

    #define MYDBGTSTA(y,x)
    #define MYDBGTSTW(y,x)

    #define ASSERT_VALID(pObj)

    #define MYDBGA(x)
    #define MYDBGW(x)

    #define MYDBGSTRA(x)
    #define MYDBGSTRW(x)

    #define CMASSERTMSGA(exp, msg)
    #define CMASSERTMSGW(exp, msg)

    #define CMTRACEA(pszFmt)
    #define CMTRACEW(pszFmt)

    #define CMTRACEHRA(pszFile, hr)
    #define CMTRACEHRW(pszFile, hr)

    #define CMTRACE1A(pszFmt, arg1)
    #define CMTRACE1W(pszFmt, arg1)

    #define CMTRACE2A(pszFmt, arg1, arg2)
    #define CMTRACE2W(pszFmt, arg1, arg2)

    #define CMTRACE3A(pszFmt, arg1, arg2, arg3)
    #define CMTRACE3W(pszFmt, arg1, arg2, arg3)
    
#endif // DEBUG

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmlog.h ===
//+----------------------------------------------------------------------------
//
// File:    cmlog.h
//
// Module:  cmutil.dll, cmdial32.dll etc
//
// Synopsis: Connection Manager Logging
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  04-May-2000 SumitC  Created
//
//-----------------------------------------------------------------------------

#ifdef CMLOG_IMPLEMENTATION
    #define CMLOG_CLASS __declspec(dllexport)
#else
    #define CMLOG_CLASS __declspec(dllimport)
#endif

// the following values follow the defaults for RAS/PPP logging (using rtutils.dll)
//
const BOOL    c_fEnableLogging        = TRUE;
const DWORD   c_dwMaxFileSize         = 0x64;           // 100K = 102,400 bytes
const LPTSTR  c_szLogFileDirectory    = TEXT("%Temp%");

//
//  #define constants
//
#define BYTE_ORDER_MARK 0xFEFF

//
//  List of CM/CPS events that can be logged
//

//
//  NOTE that this list must correspond with the s_aCmLogItems array in cmlog.cpp
//

enum _CMLOG_ITEM
{
    UNKNOWN_LOG_ITEM,       // guard item.  DO NOT USE WHEN CALLING CMLOG() !!
    LOGGING_ENABLED_EVENT,
    LOGGING_DISABLED_EVENT,
    PREINIT_EVENT,
    PRECONNECT_EVENT,
    PREDIAL_EVENT,
    PRETUNNEL_EVENT,
    CONNECT_EVENT,
    CUSTOMACTIONDLL,
    CUSTOMACTIONEXE,
    CUSTOMACTION_NOT_ALLOWED,
    CUSTOMACTION_WONT_RUN,
    DISCONNECT_EVENT,
    RECONNECT_EVENT,
    RETRY_AUTH_EVENT,
    CALLBACK_NUMBER_EVENT,
    PASSWORD_EXPIRED_EVENT,
    PASSWORD_RESET_EVENT,
    CUSTOM_BUTTON_EVENT,
    ONCANCEL_EVENT,
    ONERROR_EVENT,
    CLEAR_LOG_EVENT,

    DISCONNECT_EXT,
    DISCONNECT_INT_MANUAL,
    DISCONNECT_INT_AUTO,
    DISCONNECT_EXT_LOST_CONN,

    PB_DOWNLOAD_SUCCESS,
    PB_DOWNLOAD_FAILURE,
    PB_UPDATE_SUCCESS,
    PB_UPDATE_FAILURE_PBS,
    PB_UPDATE_FAILURE_CMPBK,
    PB_ABORTED,
    
    USER_FORMATTED = 99,
};

//
//  Use this macro for all string args that may be null or empty.
//
#define SAFE_LOG_ARG(x) ( (!(x) || !(*(x))) ? TEXT("(none)") : (x) )

// ----------------------------------------------------------------------------
//
//  Implementor's section (from here to end)
//

class CMLOG_CLASS CmLogFile
{
public:
    CmLogFile();
    ~CmLogFile();

    //
    //  Initialization/termination functions
    //
    HRESULT Init(HINSTANCE hInst, BOOL fAllUser, LPCWSTR szLongServiceName);
    HRESULT Init(HINSTANCE hInst, BOOL fAllUser, LPCSTR szLongServiceName);

    HRESULT SetParams(BOOL fEnabled, DWORD dwMaxFileSize, LPCWSTR pszLogFileDir);
    HRESULT SetParams(BOOL fEnabled, DWORD dwMaxFileSize, LPCSTR pszLogFileDir);
    HRESULT Start(BOOL fBanner);
    HRESULT Stop();
    HRESULT DeInit();

    //
    //  Work functions
    //
    void    Banner();
    void    Clear(BOOL fWriteBannerAfterwards = TRUE);
    void    Log(_CMLOG_ITEM eLogItem, ...);

    //
    //  Status inquiries
    //
    BOOL    IsEnabled() { return m_fEnabled; }
    LPCWSTR GetLogFilePath() { return m_pszLogFile; }

private:
    HRESULT OpenFile();
    HRESULT CloseFile();
    void    FormatWrite(_CMLOG_ITEM eItem, LPWSTR szArgs);
    HRESULT Write(LPWSTR sz);

    HANDLE  m_hfile;            // file handle for logfile
    DWORD   m_dwSize;           // current size of log file
    LPWSTR  m_pszServiceName;   // name of connectoid (used as filename)
    WCHAR   m_szModule[13];     // cached module name (13 = 8 + '.' + 3 + null)
    DWORD   m_dwMaxSize;        // max size of log file
    LPWSTR  m_pszLogFileDir;    // log file directory
    BOOL    m_fAllUser;         // is this an All-User profile?

    LPWSTR  m_pszLogFile;       // this is the currently-opened log file (full path)

    // state variables

    BOOL    m_fInitialized;     // set after Init() has been called
    BOOL    m_fEnabled;         // set after GetParams() finds logging is enabled (FROM CMS)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cini.h ===
//+----------------------------------------------------------------------------
//
// File:     cini.h
//
// Module:   CMUTIL.DLL
//
// Synopsis: Definition of the CINIA and CINIW classes
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------
#ifndef _CM_INI_INC
#define _CM_INI_INC


#ifdef UNICODE
    #define CIni CIniW
#else
    #define CIni CIniA
#endif

//
//  Ansi Version
//
class CMUTILAPI_CLASS CIniA {
    public:
        CIniA(HINSTANCE hInst=NULL, LPCSTR pszFile=NULL, LPCSTR pszRegPath = NULL, LPCSTR pszSection=NULL, LPCSTR pszEntry=NULL);
        ~CIniA();
        void Clear();
        void SetHInst(HINSTANCE hInst);
        void SetFile(LPCSTR pszFile);
        void SetEntry(LPCSTR pszEntry);
        void SetEntryFromIdx(DWORD dwEntry);
        void SetPrimaryFile(LPCSTR pszFile);
        void SetSection(LPCSTR pszSection);
        void SetRegPath(LPCSTR pszRegPath);
        void SetPrimaryRegPath(LPCSTR pszPrimaryRegPath);
        void SetICSDataPath(LPCSTR pszICSPath);
        void SetReadICSData(BOOL fValue);
        void SetWriteICSData(BOOL fValue);

        HINSTANCE GetHInst() const;
        LPCSTR GetFile() const;
        LPCSTR GetPrimaryFile() const;
        LPCSTR GetRegPath() const;
        LPCSTR GetPrimaryRegPath() const;

        LPSTR GPPS(LPCSTR pszSection, LPCSTR pszEntry, LPCSTR pszDefault=NULL) const;
        DWORD GPPI(LPCSTR pszSection, LPCSTR pszEntry, DWORD dwDefault=0) const;
        BOOL GPPB(LPCSTR pszSection, LPCSTR pszEntry, BOOL bDefault=0) const;

        void WPPS(LPCSTR pszSection, LPCSTR pszEntry, LPCSTR pszBuffer);
        void WPPI(LPCSTR pszSection, LPCSTR pszEntry, DWORD dwBuffer);
        void WPPB(LPCSTR pszSection, LPCSTR pszEntry, BOOL bBuffer);

        LPSTR LoadSection(LPCSTR pszSection) const;
        LPCSTR GetSection() const;

    protected:

        LPSTR LoadEntry(LPCSTR pszEntry) const;
        static void CIni_SetFile(LPSTR *ppszDest, LPCSTR pszSrc);
        BOOL CIniA_DeleteEntryFromReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry) const;
        LPBYTE CIniA_GetEntryFromReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry, DWORD dwType, DWORD dwSize) const;
        BOOL CIniA_WriteEntryToReg(HKEY hKey, LPCSTR pszRegPathTmp, LPCSTR pszEntry, CONST BYTE *lpData, DWORD dwType, DWORD dwSize) const;

    private:
        HINSTANCE m_hInst;
        LPSTR m_pszFile;
        LPSTR m_pszSection;
        LPSTR m_pszEntry;
        LPSTR m_pszPrimaryFile;
        LPTSTR m_pszRegPath;
        LPTSTR m_pszPrimaryRegPath;
        LPTSTR m_pszICSDataPath;
        BOOL m_fReadICSData;
        BOOL m_fWriteICSData;
};


//
//  UNICODE Version
//
class CMUTILAPI_CLASS CIniW {
    public:

        CIniW(HINSTANCE hInst=NULL, LPCWSTR pszFile=NULL, LPCWSTR pszRegPath = NULL, LPCWSTR pszSection=NULL, LPCWSTR pszEntry=NULL);
        ~CIniW();
        void Clear();
        void SetHInst(HINSTANCE hInst);
        void SetFile(LPCWSTR pszFile);
        void SetEntry(LPCWSTR pszEntry);
        void SetEntryFromIdx(DWORD dwEntry);
        void SetPrimaryFile(LPCWSTR pszFile);
        void SetSection(LPCWSTR pszSection);
        void SetRegPath(LPCWSTR pszRegPath);
        void SetPrimaryRegPath(LPCWSTR pszRegPath);
        void SetICSDataPath(LPCWSTR pszICSPath);
        void SetReadICSData(BOOL fValue);
        void SetWriteICSData(BOOL fValue);

        HINSTANCE GetHInst() const;
        LPCWSTR GetFile() const;
        LPCWSTR GetPrimaryFile() const;
        LPCWSTR GetRegPath() const;
        LPCWSTR GetPrimaryRegPath() const;

        LPWSTR GPPS(LPCWSTR pszSection, LPCWSTR pszEntry, LPCWSTR pszDefault=NULL) const;
        DWORD GPPI(LPCWSTR pszSection, LPCWSTR pszEntry, DWORD dwDefault=0) const;
        BOOL GPPB(LPCWSTR pszSection, LPCWSTR pszEntry, BOOL bDefault=0) const;

        void WPPS(LPCWSTR pszSection, LPCWSTR pszEntry, LPCWSTR pszBuffer);
        void WPPI(LPCWSTR pszSection, LPCWSTR pszEntry, DWORD dwBuffer);
        void WPPB(LPCWSTR pszSection, LPCWSTR pszEntry, BOOL bBuffer);
        LPWSTR LoadSection(UINT nSection) const;
        LPWSTR LoadSection(LPCWSTR pszSection) const;
        LPCWSTR GetSection() const;
        
	protected:

        LPWSTR LoadEntry(LPCWSTR pszEntry) const;
        static void CIni_SetFile(LPWSTR *ppszDest, LPCWSTR pszSrc);
        BOOL CIniW_DeleteEntryFromReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry) const;
        LPBYTE CIniW_GetEntryFromReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry, DWORD dwType, DWORD dwSize) const;
        BOOL CIniW_WriteEntryToReg(HKEY hKey, LPCWSTR pszRegPathTmp, LPCWSTR pszEntry, CONST BYTE *lpData, DWORD dwType, DWORD dwSize) const;

    private:

        HINSTANCE m_hInst;
        LPWSTR m_pszFile;
        LPWSTR m_pszSection;
        LPWSTR m_pszEntry;
        LPWSTR m_pszPrimaryFile;
        LPWSTR m_pszRegPath;
        LPWSTR m_pszPrimaryRegPath;
        LPWSTR m_pszICSDataPath;
        BOOL m_fReadICSData;
        BOOL m_fWriteICSData;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmplat.h ===
//+----------------------------------------------------------------------------
//
// File:     cmplat.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Definition of the CPlatform class.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header     08/19/99
//
//+----------------------------------------------------------------------------

#ifndef __CMPLAT_H
#define __CMPLAT_H

#include <windows.h>

//________________________________________________________________________________
//
// Class:  CPlatform
//
// Synopsis:  .instantiate one of these then query it with any of the member
//              functions.
//              
//          Public Interface Include :
//              IsX86();
//              IsAlpha();
//              IsWin95();
//              IsWin98();
//              IsWin9x();
//              IsNT31();
//              IsNT351();
//              IsNT4();
//              IsNT5();
//              IsNT();
// Notes: m_ClassState enum is very valuable. All new functions should make use of it.
//
// History:   a-anasj Created    2/04/1998
//
//________________________________________________________________________________


class CPlatform
{
public:
    enum e_ClassState{good,bad};
    CPlatform();
    BOOL    IsX86();
    BOOL    IsAlpha();
    BOOL    IsIA64();
    BOOL    IsWin95Gold();  // only build 950
    BOOL    IsWin95();  // any win95 build up one before the memphis builds
    BOOL    IsWin98Gold();
    BOOL    IsWin98Sr();
    BOOL    IsWin98();
    BOOL    IsWin9x();
    BOOL    IsNT31();
    BOOL    IsNT351();
    BOOL    IsNT4();
    BOOL    IsNT5();
    BOOL    IsNT51();
    BOOL    IsAtLeastNT5();
    BOOL    IsAtLeastNT51();
    BOOL    IsNT();
    BOOL    IsNTSrv();
    BOOL    IsNTWks();
private:
    DWORD   ServicePack(int spNum){return 0;};  //Not implemented
    BOOL                IsOS(DWORD OS, DWORD buildNum);
    BOOL                IsOSExact(DWORD OS, DWORD buildNum);
    SYSTEM_INFO         m_SysInfo;
    OSVERSIONINFO       m_OSVer; 
    e_ClassState        m_ClassState;
};

#endif  // __CMPLAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmprdver.h ===
//+----------------------------------------------------------------------------
//
// File:     cmprdver.h
//
// Module:   All CM Resource Scripts
//
// Synopsis: This file contains the Product Name description string for CM
//           components.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   Created Header     08/19/99
//
//+----------------------------------------------------------------------------
#undef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR		"Microsoft(R) Connection Manager"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmras.h ===
//+----------------------------------------------------------------------------
//
// File:     cmras.h
//
// Module:   CMDIAL32.DLL, CMCFG32.DLL, CMMGR32.EXE, CMSTP.EXE, CMUTOA.DLL
//
// Synopsis: The Connection Manager version of the RAS header.  Contains different
//           versions of several RAS structs as well as constants/structs we cannot
//           see when compiling with WinVer == 4.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    08/19/99
//
//+----------------------------------------------------------------------------

#ifndef _CM_RAS_H_
#define _CM_RAS_H_

//
// Make sure we pack on the same alignment as RAS for 64-bit Windows
//

#ifdef _WIN64
#include <pshpack4.h>
#endif

///////////////////////////////////////////////////////////////////////////////////
// define's
///////////////////////////////////////////////////////////////////////////////////

#if (WINVER < 0x401)
    //
    // RASENTRY 'dwDialMode' values.
    //

    #define RASEDM_DialAll                  1
    #define RASEDM_DialAsNeeded             2

#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

//
// RASCREDENTIALS 'dwMask' values.
//

#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

#endif

//
// For global creds support. This is only used on WindowsXP,
// but we can't assume that RAS defined it since we compile with WINVER < WindowsXP
//
#ifndef RASCM_DefaultCreds
#define RASCM_DefaultCreds  0x00000008
#endif
      
//
// This is from the W2K ras.h
//

#ifndef RDEOPT_CustomDial
#define RDEOPT_CustomDial                0x00001000
#endif

#ifndef RDEOPT_UseCustomScripting        
#define RDEOPT_UseCustomScripting        0x00002000
#endif

//
// 5.00 RASEO Options
//

#ifndef RASEO_SecureLocalFiles          
#define RASEO_SecureLocalFiles          0x00010000
#endif

#ifndef RASEO_RequireEAP
#define RASEO_RequireEAP                0x00020000
#endif

#ifndef RASEO_RequirePAP
#define RASEO_RequirePAP                0x00040000
#endif

#ifndef RASEO_RequireSPAP
#define RASEO_RequireSPAP               0x00080000
#endif

#ifndef RASEO_Custom
#define RASEO_Custom                    0x00100000
#endif

#ifndef RASEO_RequireCHAP               
#define RASEO_RequireCHAP               0x08000000
#endif

#ifndef RASEO_RequireMsCHAP
#define RASEO_RequireMsCHAP             0x10000000
#endif


#ifndef RASEO_RequireMsCHAP2
#define RASEO_RequireMsCHAP2            0x20000000
#endif

#ifndef RASEO_RequireW95MSCHAP
#define RASEO_RequireW95MSCHAP          0x40000000
#endif

#ifndef RASEO_CustomScript
#define RASEO_CustomScript              0x80000000
#endif

//
// 5.01 RASEO options for dwfOptions2
//

#ifndef RASEO2_SecureFileAndPrint
#define RASEO2_SecureFileAndPrint       0x00000001
#endif

#ifndef RASEO2_SecureClientForMSNet
#define RASEO2_SecureClientForMSNet     0x00000002
#endif

#ifndef RASEO2_DontNegotiateMultilink
#define RASEO2_DontNegotiateMultilink   0x00000004
#endif

#ifndef RASEO2_DontUseRasCredentials
#define RASEO2_DontUseRasCredentials    0x00000008
#endif

#ifndef RASEO2_UsePreSharedKey
#define RASEO2_UsePreSharedKey          0x00000010
#endif

#ifndef RASEO2_Internet
#define RASEO2_Internet                 0x00000020
#endif

#ifndef RASEO2_DisableNbtOverIP
#define RASEO2_DisableNbtOverIP         0x00000040
#endif

#ifndef RASEO2_UseGlobalDeviceSettings
#define RASEO2_UseGlobalDeviceSettings  0x00000080
#endif

#ifndef RASEO2_ReconnectIfDropped
#define RASEO2_ReconnectIfDropped       0x00000100
#endif

//
//   Encryption Types
//
#define ET_None         0  // No encryption
#define ET_Require      1  // Require Encryption
#define ET_RequireMax   2  // Require max encryption
#define ET_Optional     3  // Do encryption if possible. None Ok.


//
//  RAS Custom Dial (RCD) flags
//  Note: Re-defined here because RAS.H defines them in a WINVER > 0x500 section.
//

#define RCD_SingleUser  0
#define RCD_AllUsers    0x00000001
#define RCD_Eap         0x00000002
#define RCD_Logon       0x00000004

///////////////////////////////////////////////////////////////////////////////////
// typedef's
///////////////////////////////////////////////////////////////////////////////////

//
// From RAS\UI\COMMON\PBK\UTIL.C
//

#ifndef EAP_CUSTOM_DATA

typedef struct _EAP_CUSTOM_DATA
{
    DWORD dwSignature;
    DWORD dwCustomAuthKey;
    DWORD dwSize;
    BYTE  abdata[1];
} EAP_CUSTOM_DATA;

#endif

//
// From RASMAN.H
//

#ifndef EAPLOGONINFO

typedef struct _EAPLOGONINFO
{
    DWORD dwSize;
    DWORD dwLogonInfoSize;
    DWORD dwOffsetLogonInfo;
    DWORD dwPINInfoSize;
    DWORD dwOffsetPINInfo;
    BYTE  abdata[1];
} EAPLOGONINFO, *PEAPLOGONINFO;

#endif

//
//  Private structure for use with DwSetEntryPropertiesPrivate on Win2k
//
typedef struct _tagRASENTRY_EX_0
{
	DWORD dwTcpWindowSize;
} RASENTRY_EX_0;

//
// From raseapif.h
//

#ifndef RAS_EAP_FLAG_NON_INTERACTIVE
#define RAS_EAP_FLAG_NON_INTERACTIVE    0x00000002  // No UI should be displayed
#endif

#ifndef RAS_EAP_FLAG_LOGON
#define RAS_EAP_FLAG_LOGON 0x00000004   // The user data was obtained from Winlogon
#endif

#ifndef RAS_EAP_FLAG_PREVIEW
#define RAS_EAP_FLAG_PREVIEW 0x00000008 // User has checked "Prompt for information"
#endif

#if (WINVER < 0x401)
    //
    // define RASSUBENTRY here since it's only define for 
    // WINVER >= x0401
    //
    
    //
    // A RAS phone book multilinked sub-entry.
    //

    #define RASSUBENTRYA struct tagRASSUBENTRYA
    RASSUBENTRYA
    {
        DWORD       dwSize;
        DWORD       dwfFlags;
        //
        // Device
        //
        CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
        CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
        //
        // Phone numbers
        //
        CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
        DWORD       dwAlternateOffset;   
    };
    
    #define RASSUBENTRYW struct tagRASSUBENTRYW
    RASSUBENTRYW
    {
        DWORD       dwSize;
        DWORD       dwfFlags;
        //
        // Device
        //
        WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
        WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
        //
        // Phone numbers
        //
        WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
        DWORD       dwAlternateOffset;   
    };
    
    #ifdef UNICODE
    #define RASSUBENTRY RASSUBENTRYW
    #else
    #define RASSUBENTRY RASSUBENTRYA
    #endif
    
    #define LPRASSUBENTRYW RASSUBENTRYW*
    #define LPRASSUBENTRYA RASSUBENTRYA*
    #define LPRASSUBENTRY  RASSUBENTRY*
#endif

//
//Describes connection establishment parameters.  (See RasDial)
//

#define RASDIALPARAMSW_V401 struct tagRASDIALPARAMSW_V401
RASDIALPARAMSW_V401
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
};

#define RASDIALPARAMSA_V401 struct tagRASDIALPARAMSA_V401
RASDIALPARAMSA_V401
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
};

#ifdef UNICODE
#define RASDIALPARAMS_V401 RASDIALPARAMSW_V401
#else
#define RASDIALPARAMS_V401 RASDIALPARAMSA_V401
#endif

#define LPRASDIALPARAMSW_V401 RASDIALPARAMSW_V401*
#define LPRASDIALPARAMSA_V401 RASDIALPARAMSA_V401*
#define LPRASDIALPARAMS_V401  RASDIALPARAMS_V401*


//
// A RAS phone book entry. - from ras.h for NT 4.0
//

#define RASENTRYA_V401 struct tagRASENTRYA_V401
RASENTRYA_V401
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
};

#define RASENTRYW_V401 struct tagRASENTRYW_V401
RASENTRYW_V401
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
};

#ifdef UNICODE
#define RASENTRY_V401 RASENTRYW_V401
#else
#define RASENTRY_V401 RASENTRYA_V401
#endif

#define LPRASENTRYW_V401 RASENTRYW_V401*
#define LPRASENTRYA_V401 RASENTRYA_V401*
#define LPRASENTRY_V401  RASENTRY_V401*

//
// A RAS phone book entry. - for NT5
//

#define RASENTRYA_V500 struct tagRASENTRYA_V500
RASENTRYA_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial DLL
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
};

#define RASENTRYW_V500 struct tagRASENTRYW_V500
RASENTRYW_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial DLL
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
};

#ifdef UNICODE
#define RASENTRY_V500 RASENTRYW_V500
#else
#define RASENTRY_V500 RASENTRYA_V500
#endif

#define LPRASENTRYW_V500 RASENTRYW_V500*
#define LPRASENTRYA_V500 RASENTRYA_V500*
#define LPRASENTRY_V500  RASENTRY_V500*

// 
// 501 (whistler)
//
#define RASENTRYA_V501 struct tagRASENTRYA_V501
RASENTRYA_V501
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial DLL
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;

    //
    // More RASEO_* options
    //
    DWORD       dwfOptions2;

    //
    // For future use
    //
    DWORD       dwfOptions3;

    CHAR        szDnsSuffix[RAS_MaxDnsSuffix];

    DWORD       dwTcpWindowSize;
    CHAR        szPrerequisitePbk[MAX_PATH];
    CHAR        szPrerequisiteEntry[RAS_MaxEntryName + 1];

    DWORD       dwRedialCount;

    DWORD       dwRedialPause;

};

#define RASENTRYW_V501 struct tagRASENTRYW_V501
RASENTRYW_V501
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial DLL
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;

    //
    // More RASEO_* options
    //
    DWORD       dwfOptions2;

    //
    // For future use
    //
    DWORD       dwfOptions3;

    WCHAR       szDnsSuffix[RAS_MaxDnsSuffix];

    DWORD       dwTcpWindowSize;
    WCHAR       szPrerequisitePbk[MAX_PATH];
    WCHAR       szPrerequisiteEntry[RAS_MaxEntryName + 1];

    DWORD       dwRedialCount;

    DWORD       dwRedialPause;
};

#ifdef UNICODE
#define RASENTRY_V501 RASENTRYW_V501
#else
#define RASENTRY_V501 RASENTRYA_V501
#endif

#define LPRASENTRYW_V501 RASENTRYW_V501*
#define LPRASENTRYA_V501 RASENTRYA_V501*
#define LPRASENTRY_V501  RASENTRY_V501*

// Describes EAP extended connection establishment option.  For NT5.

#define RASEAPINFO struct tagRASEAPINFO
RASEAPINFO
{
    DWORD dwSizeofEapInfo;
    BYTE  *pbEapInfo;
};

// Describes extended connection establishment options.  For NT5.  (See RasDial)

#define RASDIALEXTENSIONS_V500 struct tagRASDIALEXTENSIONS_V500
RASDIALEXTENSIONS_V500
{
    DWORD dwSize;
    DWORD dwfOptions;
    HWND  hwndParent;
    ULONG_PTR reserved;
    ULONG_PTR reserved1;
    RASEAPINFO RasEapInfo; 
};

#define LPRASDIALEXTENSIONS_V500 RASDIALEXTENSIONS_V500*

//
//  New RAS Entry Name Structs for NT5
//
#define RASENTRYNAMEW_V500 struct tagRASENTRYNAMEW_V500
RASENTRYNAMEW_V500
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];

    //
    // If this flag is RCD_AllUsers then its a
    // system phonebook.
    //
    DWORD dwFlags;
    WCHAR szPhonebookPath[MAX_PATH + 1];

};

#define RASENTRYNAMEA_V500 struct tagRASENTRYNAMEA_V500
RASENTRYNAMEA_V500
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];

    DWORD dwFlags;
    CHAR  szPhonebookPath[MAX_PATH + 1];
};

#ifdef UNICODE
#define RASENTRYNAME_V500 RASENTRYNAMEW_V500
#else
#define RASENTRYNAME_V500 RASENTRYNAMEA_V500
#endif

#define LPRASENTRYNAMEW_V500 RASENTRYNAMEW_V500*
#define LPRASENTRYNAME_V500A RASENTRYNAMEA_V500*
#define LPRASENTRYNAME_V500  RASENTRYNAME_V500*


// RasGetEapUserIdentity structure. - For NT5

#define RASEAPUSERIDENTITYA struct tagRASEAPUSERIDENTITYA
RASEAPUSERIDENTITYA
{
    CHAR        szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#define RASEAPUSERIDENTITYW struct tagRASEAPUSERIDENTITYW
RASEAPUSERIDENTITYW
{
    WCHAR       szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#ifdef UNICODE
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYW
#else
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYA
#endif

#define LPRASEAPUSERIDENTITYW RASEAPUSERIDENTITYW*
#define LPRASEAPUSERIDENTITYA RASEAPUSERIDENTITYA*

#define LPRASEAPUSERIDENTITY RASEAPUSERIDENTITY*

#ifdef _WIN64
#include <poppack.h>
#endif

#endif // _CM_RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmsecure.h ===
//+----------------------------------------------------------------------------
//
// File:     cmsecure.h
//
// Module:   CMSECURE.LIB
//
// Synopsis: This header describes the functionality available in the cmsecure
//           library.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   henryt      Created    05/21/97
//
//+----------------------------------------------------------------------------

#ifndef _CMSECURE_INC_
#define _CMSECURE_INC_

#include <windows.h>


//************************************************************************
// define's
//************************************************************************

//
// the encryption types that cmsecure currently supports
//
#define CMSECURE_ET_NOT_ENCRYPTED       0   // 0x0000
#define CMSECURE_ET_RC2                 1   // 0x0001
#define CMSECURE_ET_STREAM_CIPHER       2   // 0x0002
#define CMSECURE_ET_CBC_CIPHER          3   // 0x0003

//
// Extended codes for UNICODE designation
// Note: The encryption logic will not know anything about these new codes 
// they are designed for book-keeping by the calling modules, which will
// have to do the appropiate conversions based on the calling context/OS
//

#define CMSECURE_ET_NOT_ENCRYPTED_U     128 // 0x0080
#define CMSECURE_ET_RC2_U               129 // 0x0081
#define CMSECURE_ET_STREAM_CIPHER_U     130 // 0x0082
#define CMSECURE_ET_CBC_CIPHER_U        131 // 0x0083


#define CMSECURE_ET_MASK_U              128 // 0x0080 
#define CMSECURE_ET_RANDOM_KEY_MASK     256 // 0x0100   uses a randomly generated key
#define CMSECURE_ET_USE_SECOND_RND_KEY  512 // 0x1000   uses the second blob key

//
// structures, typdef's
//

typedef LPVOID  (*PFN_CMSECUREALLOC)(DWORD);
typedef void    (*PFN_CMSECUREFREE)(LPVOID);

//
// externs
//


//
// function prototypes
//
/*
#ifdef __cplusplus
extern "C" {
#endif
*/
// cmsecure.cpp

BOOL
InitSecure(
    BOOL fFastEncryption = FALSE   // default is more secure 
);

void
DeInitSecure(
    void
);

BOOL
EncryptData(
    IN  LPBYTE          pbData,                 // Data to be encrypted
    IN  DWORD           dwDataLength,           // Length of data in bytes
    OUT LPBYTE          *ppbEncryptedData,      // Encrypted secret key will be stored here(memory will be allocated)
    OUT LPDWORD         pdwEncrytedBufferLen,   // Length of this buffer
    OUT LPDWORD         pEncryptionType,        // type of the encryption used

    IN  PFN_CMSECUREALLOC  pfnAlloc,            // memory allocator(if NULL, then the default is used.
                                                //      Win32 - HeapAlloc(GetProcessHeap(), ...)
    IN  PFN_CMSECUREFREE   pfnFree,             // memory deallocator(if NULL, then the default is used.
                                                //      Win32 - HeapFree(GetProcessHeap(), ...)
    IN  LPSTR           pszUserKey              // Registry key to store encrypted key for passwords
);

BOOL
DecryptData(
    IN  LPBYTE          pbEncryptedData,        // Encrypted data
    IN  DWORD           dwEncrytedDataLen,      // Length of encrypted data
    OUT LPBYTE          *ppbData,               // Decrypted Data will be stored here(memory will be allocated)
    OUT LPDWORD         pdwDataBufferLength,    // Length of the above buffer in bytes
    IN  DWORD           dwEncryptionType,       // encryption type for decryption

    IN  PFN_CMSECUREALLOC  pfnAlloc,            // memory allocator(if NULL, then the default is used.
                                                //      Win32 - HeapAlloc(GetProcessHeap(), ...)
    IN  PFN_CMSECUREFREE   pfnFree,             // memory deallocator(if NULL, then the default is used.
                                                //      Win32 - HeapFree(GetProcessHeap(), ...)
    IN  LPSTR           pszUserKey              // Registry key to store encrypted key for passwords
);


BOOL
EncryptString(
    IN  LPSTR           pszToEncrypt,           // String to be encrypted (Ansi)
    IN  LPSTR           pszUserKey,             // Key to use for Encryption
    OUT LPBYTE *        ppbEncryptedData,       // Encrypted secret key will be stored here(memory will be allocated)
    OUT LPDWORD         pdwEncrytedBufferLen,   // Length of this buffer
    IN  PFN_CMSECUREALLOC  pfnAlloc,            // memory allocator(if NULL, then the default is used.
                                                //      Win32 - HeapAlloc(GetProcessHeap(), ...)
    IN  PFN_CMSECUREFREE   pfnFree              // memory deallocator(if NULL, then the default is used.
                                                //      Win32 - HeapFree(GetProcessHeap(), ...)
);

BOOL
DecryptString(
    IN  LPBYTE          pbEncryptedData,        // Encrypted data
    IN  DWORD           dwEncrytedDataLen,      // Length of encrypted data
    IN  LPSTR           pszUserKey,             // Registry key to store encrypted key for passwords
    OUT LPBYTE *        ppbData,                // Decrypted Data will be stored here
    OUT LPDWORD         pdwDataBufferLength,    // Length of the above buffer in bytes
    IN  PFN_CMSECUREALLOC  pfnAlloc,            // memory allocator(if NULL, then the default is used.
                                                //      Win32 - HeapAlloc(GetProcessHeap(), ...)
    IN  PFN_CMSECUREFREE   pfnFree              // memory deallocator(if NULL, then the default is used.
                                                //      Win32 - HeapFree(GetProcessHeap(), ...)
);


//+---------------------------------------------------------------------------
//
//  Function:   AnsiToUnicodePcs
//
//  Synopsis:   Wrapper to encapsulate translating a standard crypt type value
//              into its equivalent for UNICODE systems. 
//
//  Arguments:  IN DWORD dwCrypt - The code to be converted
//
//  Returns:    Converted code
//
//  History:    nickball    Created     06/02/99
//
//----------------------------------------------------------------------------
inline DWORD AnsiToUnicodePcs(IN DWORD dwCrypt)
{
    return (dwCrypt | CMSECURE_ET_MASK_U);
}

//+---------------------------------------------------------------------------
//
//  Function:   UnicodeToAnsiPcs
//
//  Synopsis:   Wrapper to encapsulate translating a UNICODE crypt type value
//              into its equivalent standard ANSI crypt type. 
//
//  Arguments:  IN DWORD dwCrypt - The code to be converted
//
//  Returns:    Converted code
//
//  History:    nickball    Created     06/02/99
//
//----------------------------------------------------------------------------
inline DWORD UnicodeToAnsiPcs(IN DWORD dwCrypt)
{
    return (dwCrypt & (~CMSECURE_ET_MASK_U));
}

//+---------------------------------------------------------------------------
//
//  Function:   IsUnicodePcs
//
//  Synopsis:   Wrapper to encapsulate determining if a crypt type has UNICODE 
//              designation.
//
//  Arguments:  IN DWORD dwCrypt - The code to be converted
//
//  Returns:    TRUE if UNICODE designation
//
//  History:    nickball    Created     06/02/99
//
//----------------------------------------------------------------------------
inline BOOL IsUnicodePcs(IN DWORD dwCrypt)
{
    return (!!(dwCrypt & CMSECURE_ET_MASK_U)); // !! == (BOOL)
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAnsiPcs
//
//  Synopsis:   Wrapper to encapsulate determining if a crypt type has Ansi 
//              designation.
//
//  Arguments:  IN DWORD dwCrypt - The code to be converted
//
//  Returns:    TRUE if Ansi designation
//
//  History:    nickball    Created     06/02/99
//
//----------------------------------------------------------------------------
inline BOOL IsAnsiPcs(IN DWORD dwCrypt)
{
    return (!(dwCrypt & CMSECURE_ET_MASK_U));
}


/*
#ifdef __cplusplus
}
#endif
*/
#endif // _CMSECURE_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmutil.h ===
//+----------------------------------------------------------------------------
//
// File:     cmutil.h	 
//      
// Module:   CMUTIL.DLL 
//
// Synopsis: Header file for Private CM APIs
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   henryt     Created   03/01/98
//
//+----------------------------------------------------------------------------

#ifndef _CMUTIL_INC_
#define _CMUTIL_INC_

#ifdef  _CMUTIL_MODULE_
#define CMUTILAPI   /*extern "C" __declspec(dllexport)*/
#define CMUTILAPI_CLASS __declspec(dllexport)
#else
#define CMUTILAPI   /*extern "C" __declspec(dllimport)*/
#define CMUTILAPI_CLASS __declspec(dllimport)
#endif

#include "cini.h"

//+----------------------------------------------------------------------------
// defines
//+----------------------------------------------------------------------------

//
// platform ID for WINDOWS98
//
#define VER_PLATFORM_WIN32_WINDOWS98    100 

//
// platform ID for WINDOWS Millennium
//
#define VER_PLATFORM_WIN32_MILLENNIUM   200 

//
// OS version macros
//

#define OS_NT  ((GetOSVersion() == VER_PLATFORM_WIN32_NT))
#define OS_W9X ((GetOSVersion() != VER_PLATFORM_WIN32_NT))

#define OS_NT6 ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSMajorVersion() >= 6))
#define OS_NT51 ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSMajorVersion() >= 5) && (GetOSBuildNumber() > 2195))
#define OS_NT5 ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSMajorVersion() >= 5))
#define OS_NT4 ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSMajorVersion() < 5))

#define OS_W2K ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSBuildNumber() == 2195))

#define OS_MIL ((GetOSVersion() == VER_PLATFORM_WIN32_MILLENNIUM))
#define OS_W98 ((GetOSVersion() == VER_PLATFORM_WIN32_WINDOWS98) || (GetOSVersion() == VER_PLATFORM_WIN32_MILLENNIUM))
#define OS_W95 ((GetOSVersion() == VER_PLATFORM_WIN32_WINDOWS))


#ifdef UNICODE
    #define CmStrTrim                       CmStrTrimW
    #define CmIsSpace                       CmIsSpaceW
    #define CmIsDigit                       CmIsDigitW
    #define CmEndOfStr                      CmEndOfStrW
    #define CmAtol                          CmAtolW
    #define CmStrStr                        CmStrStrW
    #define CmStrchr                        CmStrchrW
    #define CmStrrchr                       CmStrrchrW
    #define CmStrtok                        CmStrtokW
    #define CmStrCpyAlloc                   CmStrCpyAllocW
    #define CmStrCatAlloc                   CmStrCatAllocW
    #define CmLoadString                    CmLoadStringW
    #define CmParsePath                     CmParsePathW
    #define CmConvertRelativePath           CmConvertRelativePathW
    #define CmStripPathAndExt               CmStripPathAndExtW
    #define CmStripFileName                 CmStripFileNameW
    #define CmBuildFullPathFromRelative     CmBuildFullPathFromRelativeW
    #define CmFmtMsg                        CmFmtMsgW
    #define CmLoadImage                     CmLoadImageW
    #define CmLoadIcon                      CmLoadIconW
    #define CmLoadSmallIcon                 CmLoadSmallIconW
#else
    #define CmStrTrim                       CmStrTrimA
    #define CmIsSpace                       CmIsSpaceA
    #define CmIsDigit                       CmIsDigitA
    #define CmEndOfStr                      CmEndOfStrA
    #define CmAtol                          CmAtolA
    #define CmStrStr                        CmStrStrA
    #define CmStrchr                        CmStrchrA
    #define CmStrrchr                       CmStrrchrA
    #define CmStrtok                        CmStrtokA
    #define CmStrCpyAlloc                   CmStrCpyAllocA
    #define CmStrCatAlloc                   CmStrCatAllocA
    #define CmLoadString                    CmLoadStringA
    #define CmParsePath                     CmParsePathA
    #define CmConvertRelativePath           CmConvertRelativePathA
    #define CmStripPathAndExt               CmStripPathAndExtA
    #define CmStripFileName                 CmStripFileNameA
    #define CmBuildFullPathFromRelative     CmBuildFullPathFromRelativeA
    #define CmFmtMsg                        CmFmtMsgA
    #define CmLoadImage                     CmLoadImageA
    #define CmLoadIcon                      CmLoadIconA
    #define CmLoadSmallIcon                 CmLoadSmallIconA
#endif


//+----------------------------------------------------------------------------
// typedefs
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
// declarations
//+----------------------------------------------------------------------------

CMUTILAPI int WzToSz(IN LPCWSTR pszwStrIn, OUT LPSTR pszStrOut, IN int nOutBufferSize);

CMUTILAPI int SzToWz(IN LPCSTR pszInput, OUT LPWSTR pszwOutput, IN int nBufferSize);

CMUTILAPI LPSTR WzToSzWithAlloc(LPCWSTR pszwWideString);

CMUTILAPI LPWSTR SzToWzWithAlloc(LPCSTR pszAnsiString);

CMUTILAPI DWORD WINAPI GetOSVersion(void);

CMUTILAPI DWORD WINAPI GetOSBuildNumber(void);

CMUTILAPI DWORD WINAPI GetOSMajorVersion(void);

CMUTILAPI BOOL WINAPI IsFarEastNonOSR2Win95(void);

CMUTILAPI HRESULT ReleaseBold(HWND hwnd);

CMUTILAPI HRESULT MakeBold (HWND hwnd, BOOL fSize);

CMUTILAPI void UpdateFont(HWND hDlg);

CMUTILAPI int WzToSz(IN LPCWSTR pszwStrIn, OUT LPSTR pszStrOut, IN int nOutBufferSize);

CMUTILAPI int SzToWz(IN LPCSTR pszInput, OUT LPWSTR pszwOutput, IN int nBufferSize);

CMUTILAPI LPSTR WzToSzWithAlloc(LPCWSTR pszwWideString);

CMUTILAPI LPWSTR SzToWzWithAlloc(LPCSTR pszAnsiString);

CMUTILAPI BOOL CmWinHelp(HWND hWndMain, HWND hWndItem, CONST WCHAR *lpszHelp, UINT uCommand, ULONG_PTR dwData);

CMUTILAPI BOOL IsLogonAsSystem();

//
//    Ansi Functions
//

CMUTILAPI LPSTR CmLoadStringA(HINSTANCE hInst, UINT nId);

CMUTILAPI void WINAPI CmStrTrimA(LPSTR);

CMUTILAPI BOOL WINAPI CmIsSpaceA(LPSTR);

CMUTILAPI BOOL WINAPI CmIsDigitA(LPSTR);

CMUTILAPI LPSTR WINAPI CmEndOfStrA(LPSTR);

CMUTILAPI LONG WINAPI CmAtolA(LPCSTR);

CMUTILAPI LPSTR CmStrStrA(LPCSTR, LPCSTR);

CMUTILAPI LPSTR WINAPI CmStrchrA(LPCSTR, CHAR);

CMUTILAPI LPSTR CmStrrchrA(LPCSTR, CHAR);

CMUTILAPI LPSTR CmStrtokA(LPSTR, LPCSTR);

CMUTILAPI LPSTR CmStrCpyAllocA(LPCSTR);

CMUTILAPI LPSTR CmStrCatAllocA(LPSTR *ppszDst, LPCSTR pszSrc);

CMUTILAPI LPSTR CmFmtMsgA(HINSTANCE hInst, DWORD dwMsgId, ...); 

CMUTILAPI HANDLE CmLoadImageA(HINSTANCE hMainInst, LPCSTR pszSpec, UINT nResType, UINT nCX, UINT nCY);

CMUTILAPI HICON CmLoadIconA(HINSTANCE hInst, LPCSTR pszSpec); 

CMUTILAPI HICON CmLoadSmallIconA(HINSTANCE hInst, LPCSTR pszSpec);

CMUTILAPI BOOL CmParsePathA(LPCSTR pszCmdLine, LPCSTR pszServiceFile, LPSTR *ppszCommand, LPSTR *ppszArguments);

CMUTILAPI LPSTR CmConvertRelativePathA(LPCSTR pszServiceFile, LPSTR pszRelative);

CMUTILAPI LPSTR CmStripPathAndExtA(LPCSTR pszFileName);

CMUTILAPI LPSTR CmStripFileNameA(LPCSTR pszFullNameAndPath, BOOL fKeepSlash);

CMUTILAPI LPSTR CmBuildFullPathFromRelativeA(LPCSTR pszFullFileName, LPCSTR pszRelative);

//
//    Unicode Functions
//
CMUTILAPI LPWSTR CmLoadStringW(HINSTANCE hInst, UINT nId);

CMUTILAPI void WINAPI CmStrTrimW(LPWSTR);

CMUTILAPI BOOL WINAPI CmIsSpaceW(LPWSTR);

CMUTILAPI BOOL WINAPI CmIsDigitW(LPWSTR);

CMUTILAPI LPWSTR WINAPI CmEndOfStrW(LPWSTR);

CMUTILAPI LONG WINAPI CmAtolW(LPCWSTR);

CMUTILAPI LPWSTR CmStrStrW(LPCWSTR, LPCWSTR);

CMUTILAPI LPWSTR WINAPI CmStrchrW(LPCWSTR, WCHAR);

CMUTILAPI LPWSTR CmStrrchrW(LPCWSTR, WCHAR);

CMUTILAPI LPWSTR CmStrtokW(LPWSTR, LPCWSTR);

CMUTILAPI LPWSTR CmStrCpyAllocW(LPCWSTR);

CMUTILAPI LPWSTR CmStrCatAllocW(LPWSTR *ppszDst, LPCWSTR pszSrc);

CMUTILAPI LPWSTR CmFmtMsgW(HINSTANCE hInst, DWORD dwMsgId, ...); 

CMUTILAPI HANDLE CmLoadImageW(HINSTANCE hMainInst, LPCWSTR pszSpec, UINT nResType, UINT nCX, UINT nCY);

CMUTILAPI HICON CmLoadIconW(HINSTANCE hInst, LPCWSTR pszSpec); 

CMUTILAPI HICON CmLoadSmallIconW(HINSTANCE hInst, LPCWSTR pszSpec);

CMUTILAPI BOOL CmParsePathW(LPCWSTR pszCmdLine, LPCWSTR pszServiceFile, LPWSTR *ppszCommand, LPWSTR *ppszArguments);

CMUTILAPI LPWSTR CmConvertRelativePathW(LPCWSTR pszServiceFile, LPWSTR pszRelative);

CMUTILAPI LPWSTR CmStripPathAndExtW(LPCWSTR pszFileName);

CMUTILAPI LPWSTR CmStripFileNameW(LPCWSTR pszFullNameAndPath, BOOL fKeepSlash);

CMUTILAPI LPWSTR CmBuildFullPathFromRelativeW(LPCWSTR pszFullFileName, LPCWSTR pszRelative);


//
// If DEBUG_MEM is defined, used a different set of functions
// to track memory
//
#if defined(DEBUG) && defined(DEBUG_MEM)

CMUTILAPI  void* AllocDebugMem(long nSize, const char* lpFileName,int nLine);
CMUTILAPI  BOOL FreeDebugMem(void* lpMem);
CMUTILAPI  void* ReAllocDebugMem(void* lpMem, long nSize, const char* lpFileName,int nLine);
CMUTILAPI  BOOL CheckDebugMem();

#define CmMalloc(nSize) AllocDebugMem(nSize,__FILE__, __LINE__)
#define CmFree(lpMem)  ((void)FreeDebugMem(lpMem))
#define CmRealloc(pvPtr, nSize) ReAllocDebugMem(pvPtr, nSize,__FILE__, __LINE__)

inline void   __cdecl operator delete(void* p) {CmFree(p);}
inline void*  __cdecl operator new(size_t nSize, const char* lpszFileName, int nLine)
{
    return AllocDebugMem(nSize, lpszFileName, nLine);
}


//
// Redefine new to keep trak of the file name and line number
//
#define DEBUG_NEW new(__FILE__, __LINE__)
#define new DEBUG_NEW
 
#else

CMUTILAPI void *CmRealloc(void *pvPtr, size_t nBytes);
CMUTILAPI void *CmMalloc(size_t nBytes);
CMUTILAPI void CmFree(void *pvPtr);
#define CheckDebugMem() (TRUE)

inline void   __cdecl operator delete(void* p) {CmFree(p);}
inline void* __cdecl operator new( size_t cSize ) { return CmMalloc(cSize); }

#endif

//
// for i386
//
#ifdef _M_IX86
CMUTILAPI PVOID WINAPI CmMoveMemory(
    PVOID       dst,
    CONST PVOID src,
    size_t      count
);
#else
//
// alpha has native support
//
#define CmMoveMemory    MoveMemory
#endif //_M_IX86

//+----------------------------------------------------------------------------
// definitions
//+----------------------------------------------------------------------------

//
// Returns a pseudo-random number 0 through 32767.  Taken from the C runtime rand().
//
class CMUTILAPI_CLASS CRandom
{
public:
    CRandom(void) { m_uiSeed = GetTickCount(); }
    CRandom(UINT uiSeed) { m_uiSeed = uiSeed; }
    void Init(DWORD uiSeed) { m_uiSeed = uiSeed; }
    int  Generate(void) { return(((m_uiSeed = m_uiSeed * 214013L + 2531011L) >> 16) & 0x7fff); }

protected:
    UINT m_uiSeed;
};


//
// thread local storage index
//
extern DWORD  g_dwTlsIndex;

#endif _CMUTIL_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmsetup.h ===
//+----------------------------------------------------------------------------
//
// File:     cmsetup.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: This header defines all of the capabilities of the CM setup library.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb      Created Header   08/19/99
//
//+----------------------------------------------------------------------------

//
//	Standard Windows Includes
//
#include <windows.h>
#include <tchar.h>

//
//	Common CM includes
//
#include "cmglobal.h"
#include "cmdebug.h"

//
//	Other source file includes
//	

#include "cmplat.h"
#include "cversion.h"
#include "cmakver.h"
#include "cmver.h"
#include "cfilename.h"
#include "processcmdln.h"
#include "setupmem.h"

HRESULT LaunchInfSection(LPCTSTR szInfFile, LPCTSTR szInfSection, LPCTSTR szTitle, BOOL bQuiet);
HRESULT CallLaunchInfSectionEx(LPCSTR pszInfFile, LPCSTR pszInfSection, DWORD dwFlags);
BOOL CreateLayerDirectory(LPCTSTR str);
BOOL FileExists(LPCTSTR pszFullNameAndPath);
HRESULT GetModuleVersionAndLCID (LPTSTR pszFile, LPDWORD pdwVersion, LPDWORD pdwBuild, LPDWORD pdwLCID);
LONG CmDeleteRegKeyWithoutSubKeys(HKEY hBaseKey, LPCTSTR pszSubKey, BOOL bIgnoreValues);
BOOL CmIsNative();
HRESULT ExtractCmBinsFromExe(LPTSTR pszPathToExtractFrom, LPTSTR pszPathToExtractTo);

//
//	Common Macros
//
#define CELEMS(x) ((sizeof(x))/(sizeof(x[0])))

//
//  Pre-shared key constants
//
const DWORD c_dwMaxPresharedKey = 256;
const DWORD c_dwMinPresharedKeyPIN = 4;
const DWORD c_dwMaxPresharedKeyPIN = 15;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmuufns.h ===
//+----------------------------------------------------------------------------
//
// File:     cmuufns.h
//
// Module:   CMSECURE.LIB
//
// Synopsis: Definitions for CM's UUEncode and UUDecode functions
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb   Created Header    08/18/99
//
//+----------------------------------------------------------------------------


#ifndef _CMUUFNS_INC_
#define _CMUUFNS_INC_

//************************************************************************
// define's
//************************************************************************


//************************************************************************
// structures, typdef's
//************************************************************************



//************************************************************************
// externs
//************************************************************************


//************************************************************************
// function prototypes
//************************************************************************

#ifdef __cplusplus
extern "C" {
#endif

BOOL uudecode(
              const char   * bufcoded,
              CHAR   * pbuffdecoded,
              LPDWORD  pcbDecoded );

              
BOOL uuencode( const BYTE*   bufin,
               DWORD    nbytes,
               CHAR * pbuffEncoded,
               DWORD    outbufmax);

#ifdef __cplusplus
}
#endif


#endif // _CMUUFNS_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmtiming.h ===
//+----------------------------------------------------------------------------
//
// File:     cmtiming.h
//
// Module:   CMDIAL32.DLL and CMMGR32.EXE
//
// Synopsis: Header file for timing functions.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball      Created    04/28/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_TIMING_INC
#define _CM_TIMING_INC

//
// Add the following to the sources file of the target module to activate timing macros.
//
// C_DEFINES = -DCM_TIMING_ON
//
// NOTE: Never check in a sources file with this flag defined
//

#ifdef CM_TIMING_ON // For timing test only

#define CM_SET_TIMING_INTERVAL(x) SetTimingInterval(x)

//
// Defintions
//

#define MAX_TIMING_INTERVALS 50
#define CM_TIMING_TABLE_NAME "CM TIMING TABLE"

//
// Custom types for table
//

typedef struct Cm_Timing_Interval
{
    TCHAR szName[MAX_PATH];      // Name of timing interval
	DWORD dwTicks;              // TickCount
} CM_TIMING_INTERVAL, *LPCM_TIMING_INTERVAL;


typedef struct Cm_Timing_Table
{
	int iNext;                                           // Next available entry
	CM_TIMING_INTERVAL Intervals[MAX_TIMING_INTERVALS];  // a list of intervals
} CM_TIMING_TABLE, * LPCM_TIMING_TABLE;


//+----------------------------------------------------------------------------
//
// Function:  SetTimingInterval
//
// Synopsis:  A simple wrapper to encapsulate the process of updating the 
//            timing table with an interval entry.
//
// Arguments: char *szIntervalName - The optional name of the entry, the entry number is used if NULL
//
// Returns:   void - Nothing
//
// History:   nickball    4/7/98    Created   
//
//+----------------------------------------------------------------------------
inline void SetTimingInterval(char *szIntervalName)    
{    
    HANDLE hMap = OpenFileMapping(FILE_MAP_READ | FILE_MAP_WRITE, FALSE, CM_TIMING_TABLE_NAME);
         
    if (hMap)
    {
        //
        // File mapping opened successfully, map a view of it.
        //

        LPCM_TIMING_TABLE pTable = (LPCM_TIMING_TABLE) MapViewOfFile(hMap,
                                      FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);        
        if (pTable) 
        {
            if (pTable->iNext < MAX_TIMING_INTERVALS)
            {                
                //
                // Update the next available entry
                //

                if (szIntervalName)
                {
                    lstrcpy(pTable->Intervals[pTable->iNext].szName, szIntervalName);
                }
                else
                {
                    wsprintf(pTable->Intervals[pTable->iNext].szName, "(%d)", pTable->iNext);
                }

                pTable->Intervals[pTable->iNext].dwTicks = GetTickCount();                                            
                pTable->iNext++;
            }

            UnmapViewOfFile(pTable);
        }   

        CloseHandle(hMap);
    }   
}

#else // CM_TIMING_ON

#define CM_SET_TIMING_INTERVAL(x) 

#endif

#endif // _CM_TIMING_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmver.h ===
//+----------------------------------------------------------------------------
//
// File:     cmver.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Definition of CmVersion, a utility class that helps in detecting
//           the version of Connection Manager that is installed.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   a-anasj    Created                             02/11/98
//           quintinb   Cleaned Up and removed CRegValue    07/14/98
//           quintinb   Rewrote                             09/14/98
//
//+----------------------------------------------------------------------------

#ifndef __CMVER_H
#define __CMVER_H

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>

const int c_CmMin13Version = 2450;
const int c_CmFirstUnicodeBuild = 2041;

class CmVersion : public CVersion
{
public:	//	Public Methods
	CmVersion();
	~CmVersion();
	BOOL GetInstallLocation	(LPTSTR szStr);

private:	//	Member Variables

    TCHAR m_szCmmgrPath[MAX_PATH+1];	// this actually contains the install location path
};


#endif	// __CMVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cm_def.h ===
//+----------------------------------------------------------------------------
//
// File:     cm_def.h
//
// Module:   CMDIAL32.DLL, CMDL32.EXE, CMMGR32.EXE, CMMON32.EXE, etc.
//
// Synopsis: Header file for all definitions common to the main CM components (CMDIAL, 
//           CMMON, CMDL, etc.)
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   nickball   created                         04/28/97
//           nickball   moved globals to cmglobal.h     07/10/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_DEF
#define _CM_DEF

const TCHAR* const c_pszCmMonReadyEvent = TEXT("CmMon Ready");

const TCHAR* const c_pszCMPhoneBookMutex = TEXT("Connection Manager Phonebook Access");

//
// IDs for data passed from CMDIAL to CMMON via WM_COPYDATA
//

#define CMMON_CONNECTED_INFO 0x0000
#define CMMON_HANGUP_INFO    0x0001

//
// Structure of data passed from CMDIAL to CMMON via WM_COPYDATA
//

#define CMLEN 256

typedef struct tagCmConnectedInfo
{   
    TCHAR szEntryName[CMLEN + 1];       // Name of Ras entry in connection table
    TCHAR szProfilePath[MAX_PATH + 1];  // Path of .CMP for entry
    TCHAR szUserName[CMLEN+1];          // For reconnect 
    TCHAR szPassword[CMLEN + 1];        // For reconnect 
    TCHAR szInetPassword[CMLEN + 1];    // For reconnect 
    TCHAR szRasPhoneBook[MAX_PATH + 1]; // For reconnect
    DWORD dwCmFlags;                    // Cm specific flags
    DWORD dwInitBytesRecv;              // For MSDUN12, read from registry pre-dial
    DWORD dwInitBytesSend;              // initial bytes send
    BOOL fDialup2;                      // Whether the stat is in Dialup-adapter#2 registry key
    HANDLE ahWatchHandles[1];           // (MUST ALWAYS BE LAST MEMBER OF STRUCT) - 
                                        // Array (null terminated) of Process handles 
} CM_CONNECTED_INFO, * LPCM_CONNECTED_INFO;

typedef struct tagCmHangupInfo
{   
  TCHAR szEntryName[CMLEN + 1]; // Name of Ras entry in connection table                
} CM_HANGUP_INFO, * LPCM_HANGUP_INFO;


//
// Cm specific flags 
//

#define FL_PROPERTIES           0x00000001  // settings display only
#define FL_AUTODIAL             0x00000002  // autodialing
#define FL_UNATTENDED           0x00000004  // unattended dial  
#define FL_RECONNECT            0x00000008  // its a reconnect request
#define FL_REMEMBER_DIALAUTO    0x00000010  // dial-auto on reconnect 
#define FL_REMEMBER_PASSWORD    0x00000020  // remember password on reconnect
#define FL_DESKTOP              0x00000040  // instance initiated from desktop
#define FL_GLOBALCREDS          0x00000080  // has global credentials stored

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmutoa.h ===
//+----------------------------------------------------------------------------
//
// File:     cmutoa.h
//
// Module:   CMUTOA.DLL
//
// Synopsis: This header file includes the type definitions and function headers
//           needed to use the CM Unicode to Ansi conversion dll.  This dll contains
//           UA APIs that allow a Unicode App to work on Win9x.  The idea for this 
//           dll was borrowed from F. Avery Bishop's April 1999 MSJ article 
//           "Design a Single Unicode App that Runs on Both Windows 98 and Windows 2000"
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb      Created    4-25-99
//
//+----------------------------------------------------------------------------

#ifndef _CMUTOA
#define _CMUTOA

typedef WINUSERAPI LRESULT (WINAPI *UAPI_CallWindowProc)(WNDPROC, HWND, UINT, WPARAM, LPARAM);
typedef WINUSERAPI LPWSTR (WINAPI *UAPI_CharLower)(LPWSTR);
typedef WINUSERAPI LPWSTR (WINAPI *UAPI_CharNext)(LPCWSTR);
typedef WINUSERAPI LPWSTR (WINAPI *UAPI_CharPrev)(LPCWSTR, LPCWSTR);
typedef WINUSERAPI LPWSTR (WINAPI *UAPI_CharUpper)(LPWSTR);
typedef WINUSERAPI HWND (WINAPI *UAPI_CreateDialogParam)(IN HINSTANCE, IN LPCWSTR, IN HWND, IN DLGPROC, IN LPARAM);
typedef WINBASEAPI BOOL (WINAPI *UAPI_CreateDirectory)(LPCWSTR, LPSECURITY_ATTRIBUTES);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_CreateEvent)(LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPCWSTR);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_CreateFileMapping)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_CreateFile)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_CreateMutex)(LPSECURITY_ATTRIBUTES, BOOL, LPCWSTR);
typedef WINBASEAPI BOOL (WINAPI *UAPI_CreateProcess)(LPCWSTR, LPWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION);
typedef WINUSERAPI HWND (WINAPI *UAPI_CreateWindowEx)(DWORD, LPCWSTR, LPCWSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, LPVOID);
typedef WINUSERAPI LRESULT (WINAPI *UAPI_DefWindowProc)(HWND, UINT, WPARAM, LPARAM);
typedef WINBASEAPI BOOL (WINAPI *UAPI_DeleteFile)(LPCWSTR);
typedef WINUSERAPI INT_PTR (WINAPI *UAPI_DialogBoxParam)(HINSTANCE, LPCWSTR, HWND, DLGPROC, LPARAM);
typedef WINUSERAPI LRESULT (WINAPI *UAPI_DispatchMessage)(CONST MSG*);
typedef WINBASEAPI DWORD (WINAPI *UAPI_ExpandEnvironmentStrings)(LPCWSTR, LPWSTR, DWORD);
typedef WINBASEAPI HRSRC (WINAPI *UAPI_FindResourceEx)(HMODULE, LPCWSTR, LPCWSTR, WORD);
typedef WINUSERAPI HWND (WINAPI *UAPI_FindWindowEx)(HWND, HWND, LPCWSTR, LPCWSTR);
typedef WINUSERAPI DWORD (WINAPI *UAPI_GetClassLong)(HWND, int);
typedef WINBASEAPI int (WINAPI *UAPI_GetDateFormat)(LCID, DWORD, CONST SYSTEMTIME *, LPCWSTR, LPWSTR, int);
typedef WINUSERAPI UINT (WINAPI *UAPI_GetDlgItemText)(HWND, int, LPWSTR, int);
typedef WINBASEAPI DWORD (WINAPI *UAPI_GetFileAttributes)(LPCWSTR);
typedef WINUSERAPI BOOL (WINAPI *UAPI_GetMessage)(LPMSG, HWND, UINT, UINT);
typedef WINBASEAPI DWORD (WINAPI *UAPI_GetModuleFileName)(HMODULE, LPWSTR, DWORD);
typedef WINBASEAPI HMODULE (WINAPI *UAPI_GetModuleHandle)(LPCWSTR);
typedef WINBASEAPI UINT (WINAPI *UAPI_GetPrivateProfileInt)(LPCWSTR, LPCWSTR, INT, LPCWSTR);
typedef WINBASEAPI DWORD (WINAPI *UAPI_GetPrivateProfileString)(LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, DWORD, LPCWSTR);
typedef WINBASEAPI BOOL (WINAPI *UAPI_GetStringTypeEx)(LCID, DWORD, LPCWSTR, int, LPWORD);
typedef WINBASEAPI UINT (WINAPI *UAPI_GetSystemDirectory)(LPWSTR, UINT);
typedef WINBASEAPI UINT (WINAPI *UAPI_GetTempFileName)(LPCWSTR, LPCWSTR, UINT, LPWSTR);
typedef WINBASEAPI DWORD (WINAPI *UAPI_GetTempPath)(DWORD, LPWSTR);
typedef WINBASEAPI int (WINAPI *UAPI_GetTimeFormat)(LCID, DWORD, CONST SYSTEMTIME *, LPCWSTR, LPWSTR, int);
typedef WINADVAPI BOOL (WINAPI *UAPI_GetUserName)(LPWSTR, LPDWORD);
typedef WINBASEAPI BOOL (WINAPI *UAPI_GetVersionEx)(LPOSVERSIONINFOW);
#ifdef _WIN64
typedef WINUSERAPI LONG_PTR (WINAPI *UAPI_GetWindowLong)(HWND, int);
#else
typedef WINUSERAPI LONG (WINAPI *UAPI_GetWindowLong)(HWND, int);
#endif
typedef WINUSERAPI int (WINAPI *UAPI_GetWindowTextLength)(HWND);
typedef WINUSERAPI int (WINAPI *UAPI_GetWindowText)(HWND, LPWSTR, int);
typedef WINUSERAPI BOOL (WINAPI *UAPI_InsertMenu)(HMENU, UINT, UINT, UINT_PTR, LPCWSTR);
typedef WINUSERAPI BOOL (WINAPI *UAPI_IsDialogMessage)(HWND, LPMSG);
typedef WINUSERAPI HCURSOR (WINAPI *UAPI_LoadCursor)(HINSTANCE, LPCWSTR);
typedef WINUSERAPI HICON (WINAPI *UAPI_LoadIcon)(HINSTANCE, LPCWSTR);
typedef WINUSERAPI HANDLE (WINAPI *UAPI_LoadImage)(IN HINSTANCE, IN LPCWSTR, IN UINT, IN int, IN int, IN UINT);
typedef WINBASEAPI HMODULE (WINAPI *UAPI_LoadLibraryEx)(LPCWSTR, HANDLE, DWORD);
typedef WINUSERAPI HMENU (WINAPI *UAPI_LoadMenu)(IN HINSTANCE, IN LPCWSTR);
typedef WINUSERAPI INT (WINAPI *UAPI_LoadString)(HINSTANCE, UINT, LPWSTR, INT);
typedef WINBASEAPI LPWSTR (WINAPI *UAPI_lstrcat)(LPWSTR, LPCWSTR);
typedef WINBASEAPI int (WINAPI *UAPI_lstrcmpi)(LPCWSTR, LPCWSTR);
typedef WINBASEAPI int (WINAPI *UAPI_lstrcmp)(LPCWSTR, LPCWSTR);
typedef WINBASEAPI LPWSTR (WINAPI *UAPI_lstrcpyn)(LPWSTR, LPCWSTR, int);
typedef WINBASEAPI LPWSTR (WINAPI *UAPI_lstrcpy)(LPWSTR, LPCWSTR);
typedef WINBASEAPI int (WINAPI *UAPI_lstrlen)(LPCWSTR);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_OpenEvent)(DWORD, BOOL, LPCWSTR);
typedef WINBASEAPI HANDLE (WINAPI *UAPI_OpenFileMapping)(DWORD, BOOL, LPCWSTR);
typedef WINUSERAPI BOOL (WINAPI *UAPI_PeekMessage)(LPMSG, HWND, UINT, UINT, UINT);
typedef WINUSERAPI BOOL (WINAPI *UAPI_PostMessage)(HWND, UINT, WPARAM, LPARAM);
typedef WINUSERAPI BOOL (WINAPI *UAPI_PostThreadMessage)(IN DWORD, IN UINT, IN WPARAM, IN LPARAM);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegCreateKeyEx)(HKEY, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegDeleteKey)(HKEY, LPCWSTR);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegDeleteValue)(HKEY, LPCWSTR);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegEnumKeyEx)(IN HKEY hKey, IN DWORD dwIndex, OUT LPWSTR lpName, IN OUT LPDWORD lpcbName, IN LPDWORD lpReserved, IN OUT LPWSTR lpClass, IN OUT LPDWORD lpcbClass, OUT PFILETIME lpftLastWriteTime);
typedef WINUSERAPI ATOM (WINAPI *UAPI_RegisterClassEx)(CONST WNDCLASSEXW *);
typedef WINUSERAPI UINT (WINAPI *UAPI_RegisterWindowMessage)(LPCWSTR);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegOpenKeyEx)(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegQueryValueEx)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef WINADVAPI LONG (APIENTRY *UAPI_RegSetValueEx)(HKEY, LPCWSTR, DWORD, DWORD, CONST BYTE*, DWORD);
typedef WINBASEAPI DWORD (WINAPI *UAPI_SearchPath)(IN LPCWSTR, IN LPCWSTR, IN LPCWSTR, IN DWORD, OUT LPWSTR, OUT LPWSTR *);
typedef WINUSERAPI LONG_PTR (WINAPI *UAPI_SendDlgItemMessage)(HWND, INT, UINT, WPARAM, LPARAM);
typedef WINUSERAPI LRESULT (WINAPI *UAPI_SendMessage)(HWND, UINT, WPARAM, LPARAM );
typedef WINBASEAPI BOOL (WINAPI* UAPI_SetCurrentDirectory)(IN LPCWSTR);
typedef WINUSERAPI BOOL (WINAPI *UAPI_SetDlgItemText)(HWND, int, LPCWSTR);
#ifdef _WIN64
typedef WINUSERAPI LONG_PTR (WINAPI *UAPI_SetWindowLong)(HWND, int, LONG_PTR);
#else
typedef WINUSERAPI LONG (WINAPI *UAPI_SetWindowLong)(HWND, int, LONG);
#endif
typedef WINUSERAPI BOOL (WINAPI *UAPI_SetWindowText)(HWND, LPCWSTR);
typedef WINUSERAPI BOOL (WINAPI *UAPI_UnregisterClass)(LPCWSTR, HINSTANCE);
typedef WINUSERAPI BOOL (WINAPI *UAPI_WinHelp)(HWND, LPCWSTR, UINT, ULONG_PTR);
typedef WINBASEAPI BOOL (WINAPI *UAPI_WritePrivateProfileString)(LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR);
typedef WINUSERAPI int (WINAPIV *UAPI_wsprintf)(LPWSTR, LPCWSTR, ...);
typedef WINUSERAPI int (WINAPI *UAPI_wvsprintf)(LPWSTR, LPCWSTR, va_list arglist);

//
//  If a module needs SHGetPathFromIDList it will have to include shlobj.h, which it will need to
//  have the definition of an LPCITEMIDLIST anyway.  This prevents modules that don't need
//  the shell header, from having to include it just to use cmutoa.dll.
//
#ifdef _SHLOBJ_H_
typedef WINSHELLAPI BOOL (WINAPI *UAPI_SHGetPathFromIDList)(LPCITEMIDLIST, LPWSTR);
#endif 

typedef union _tagUAPIInit {
	struct
    {
        UAPI_CallWindowProc             *pCallWindowProcU;
        UAPI_CharLower                  *pCharLowerU;
        UAPI_CharNext                   *pCharNextU;
        UAPI_CharPrev                   *pCharPrevU;
        UAPI_CharUpper                  *pCharUpperU;
        UAPI_CreateDialogParam          *pCreateDialogParamU;
        UAPI_CreateDirectory            *pCreateDirectoryU;
        UAPI_CreateEvent                *pCreateEventU;
        UAPI_CreateFile                 *pCreateFileU;
        UAPI_CreateFileMapping          *pCreateFileMappingU;
        UAPI_CreateMutex                *pCreateMutexU;
        UAPI_CreateProcess              *pCreateProcessU;
        UAPI_CreateWindowEx             *pCreateWindowExU;
        UAPI_DefWindowProc              *pDefWindowProcU;
        UAPI_DeleteFile                 *pDeleteFileU;
        UAPI_DialogBoxParam             *pDialogBoxParamU;
        UAPI_DispatchMessage            *pDispatchMessageU;
        UAPI_ExpandEnvironmentStrings   *pExpandEnvironmentStringsU;
        UAPI_FindResourceEx             *pFindResourceExU;
        UAPI_FindWindowEx               *pFindWindowExU;
        UAPI_GetClassLong               *pGetClassLongU;
        UAPI_GetDateFormat              *pGetDateFormatU;
        UAPI_GetDlgItemText             *pGetDlgItemTextU;
        UAPI_GetFileAttributes          *pGetFileAttributesU;
        UAPI_GetMessage                 *pGetMessageU;
        UAPI_GetModuleFileName          *pGetModuleFileNameU;
        UAPI_GetModuleHandle            *pGetModuleHandleU;
        UAPI_GetPrivateProfileInt       *pGetPrivateProfileIntU;
        UAPI_GetPrivateProfileString    *pGetPrivateProfileStringU;
        UAPI_GetStringTypeEx            *pGetStringTypeExU;
        UAPI_GetSystemDirectory         *pGetSystemDirectoryU;
        UAPI_GetTempFileName            *pGetTempFileNameU;
        UAPI_GetTempPath                *pGetTempPathU;
        UAPI_GetTimeFormat              *pGetTimeFormatU;
        UAPI_GetUserName                *pGetUserNameU;
        UAPI_GetVersionEx               *pGetVersionExU;
        UAPI_GetWindowLong              *pGetWindowLongU;
        UAPI_GetWindowText              *pGetWindowTextU;
        UAPI_GetWindowTextLength        *pGetWindowTextLengthU;
        UAPI_InsertMenu                 *pInsertMenuU;
        UAPI_IsDialogMessage            *pIsDialogMessageU;
        UAPI_LoadCursor                 *pLoadCursorU;
        UAPI_LoadIcon                   *pLoadIconU;
        UAPI_LoadImage                  *pLoadImageU;
        UAPI_LoadLibraryEx              *pLoadLibraryExU;
        UAPI_LoadMenu                   *pLoadMenuU;
        UAPI_LoadString                 *pLoadStringU;
        UAPI_lstrcat                    *plstrcatU;
        UAPI_lstrcmp                    *plstrcmpU;
        UAPI_lstrcmpi                   *plstrcmpiU;
        UAPI_lstrcpy                    *plstrcpyU;
        UAPI_lstrcpyn                   *plstrcpynU;
        UAPI_lstrlen                    *plstrlenU;
        UAPI_OpenEvent                  *pOpenEventU;
        UAPI_OpenFileMapping            *pOpenFileMappingU;
        UAPI_PeekMessage                *pPeekMessageU;
        UAPI_PostMessage                *pPostMessageU;
        UAPI_PostThreadMessage          *pPostThreadMessageU;
        UAPI_RegCreateKeyEx             *pRegCreateKeyExU;
        UAPI_RegDeleteKey               *pRegDeleteKeyU;
        UAPI_RegDeleteValue             *pRegDeleteValueU;
        UAPI_RegEnumKeyEx               *pRegEnumKeyExU;
        UAPI_RegisterClassEx            *pRegisterClassExU;
        UAPI_RegisterWindowMessage      *pRegisterWindowMessageU;
        UAPI_RegOpenKeyEx               *pRegOpenKeyExU;
        UAPI_RegQueryValueEx            *pRegQueryValueExU;
        UAPI_RegSetValueEx              *pRegSetValueExU;
        UAPI_SearchPath                 *pSearchPathU;
        UAPI_SendDlgItemMessage         *pSendDlgItemMessageU;
        UAPI_SendMessage                *pSendMessageU;
        UAPI_SetCurrentDirectory        *pSetCurrentDirectoryU;
        UAPI_SetDlgItemText             *pSetDlgItemTextU;
        UAPI_SetWindowLong              *pSetWindowLongU;
        UAPI_SetWindowText              *pSetWindowTextU;
        UAPI_UnregisterClass            *pUnregisterClassU;
        UAPI_WinHelp                    *pWinHelpU;
        UAPI_WritePrivateProfileString  *pWritePrivateProfileStringU;
        UAPI_wsprintf                   *pwsprintfU;
        UAPI_wvsprintf                  *pwvsprintfU;    
    };

	LPVOID *ppvUapiFun[79];

}UAPIINIT, *PUAPIINIT;




BOOL InitCmUToA(PUAPIINIT);
BOOL InitCmRasUtoA();
void FreeCmRasUtoA();


#endif // _CMUTOA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cm_phbk.h ===
//+----------------------------------------------------------------------------
//
// File:     cm_phbk.h
//
// Module:   CMPBK32.DLL
//
// Synopsis: Description of CM phone book API
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header    08/19/99
//
//+----------------------------------------------------------------------------

#ifndef _CMPHBK_INC
#define _CMPHBK_INC

typedef struct tagPhoneBookFilterStruct {
	DWORD dwCnt;
	struct {
		DWORD dwMask;
		DWORD dwMatch;
	} aData[1];
} PhoneBookFilterStruct, *PPBFS;

#define CM_PHBK_DllExportH extern "C" HRESULT WINAPI 
#define CM_PHBK_DllExportB extern "C" BOOL WINAPI 
#define CM_PHBK_DllExportV extern "C" void WINAPI 
#define CM_PHBK_DllExportP extern "C" PPBFS WINAPI 
#define CM_PHBK_DllExportD extern "C" DWORD WINAPI 

CM_PHBK_DllExportP PhoneBookCopyFilter(PPBFS pFilterIn);
CM_PHBK_DllExportV PhoneBookFreeFilter(PPBFS pFilter);
CM_PHBK_DllExportB PhoneBookMatchFilter(PPBFS pFilter, DWORD dwValue);

typedef BOOL (WINAPI *PhoneBookParseInfoSvcFuncA)(LPCSTR pszSvc, PPBFS pFilter, DWORD_PTR dwParam);
typedef BOOL (WINAPI *PhoneBookParseInfoSvcFuncW)(LPCWSTR pszSvc, PPBFS pFilter, DWORD_PTR dwParam);
typedef BOOL (WINAPI *PhoneBookParseInfoRefFuncA)(LPCSTR pszFile, LPCSTR pszURL, PPBFS pFilterA, PPBFS pFilterB, DWORD_PTR dwParam);
typedef BOOL (WINAPI *PhoneBookParseInfoRefFuncW)(LPCWSTR pszFile, LPCWSTR pszURL, PPBFS pFilterA, PPBFS pFilterB, DWORD_PTR dwParam);

typedef struct tagPhoneBookParseInfoStructA {
	DWORD dwSize;
	LPSTR pszURL;
	DWORD dwURL;
	PPBFS pFilterA;
	PPBFS pFilterB;
	PhoneBookParseInfoSvcFuncA pfnSvc;
	DWORD_PTR dwSvcParam;
	PhoneBookParseInfoRefFuncA pfnRef;
	DWORD_PTR dwRefParam;
} PhoneBookParseInfoStructA;

typedef struct tagPhoneBookParseInfoStructW {
	DWORD dwSize;
	LPWSTR pszURL;
	DWORD dwURL;
	PPBFS pFilterA;
	PPBFS pFilterB;
	PhoneBookParseInfoSvcFuncW pfnSvc;
	DWORD_PTR dwSvcParam;
	PhoneBookParseInfoRefFuncW pfnRef;
	DWORD_PTR dwRefParam;
} PhoneBookParseInfoStructW;


CM_PHBK_DllExportB PhoneBookParseInfoA(LPCSTR pszFile, PhoneBookParseInfoStructA *pInfo);
CM_PHBK_DllExportB PhoneBookParseInfoW(LPCWSTR pszFile, PhoneBookParseInfoStructW *pInfo);


typedef void (WINAPI *PhoneBookCallBack)(unsigned int, DWORD_PTR);


CM_PHBK_DllExportV PhoneBookEnumCountries(DWORD_PTR dwPB, PhoneBookCallBack pfnCountry, PPBFS pFilter, DWORD_PTR dwParam);
CM_PHBK_DllExportB PhoneBookGetCountryNameA(DWORD_PTR dwPB, unsigned int nIdx, LPSTR pszCountryName, DWORD *pdwCountryName);
CM_PHBK_DllExportB PhoneBookGetCountryNameW(DWORD_PTR dwPB, unsigned int nIdx, LPWSTR pszCountryName, DWORD *pdwCountryName);
CM_PHBK_DllExportD PhoneBookGetCountryId(DWORD_PTR dwPB, unsigned int nIdx);
CM_PHBK_DllExportD PhoneBookGetCurrentCountryId();
CM_PHBK_DllExportV PhoneBookEnumRegions(DWORD_PTR dwPB, PhoneBookCallBack pfnRegion, DWORD dwCountryID, PPBFS pFilter, DWORD_PTR dwParam);
CM_PHBK_DllExportB PhoneBookGetRegionNameA(DWORD_PTR dwPB, unsigned int nIdx, LPSTR pszRegionName, DWORD *pdwRegionName);
CM_PHBK_DllExportB PhoneBookGetRegionNameW(DWORD_PTR dwPB, unsigned int nIdx, LPWSTR pszRegionName, DWORD *pdwRegionName);
CM_PHBK_DllExportB PhoneBookGetPhoneCanonicalA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszPhoneNumber, DWORD *pdwPhoneNumber);
CM_PHBK_DllExportB PhoneBookGetPhoneCanonicalW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszPhoneNumber, DWORD *pdwPhoneNumber);
CM_PHBK_DllExportB PhoneBookGetPhoneNonCanonicalA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszPhoneNumber, DWORD *pdwPhoneNumber);
CM_PHBK_DllExportB PhoneBookGetPhoneNonCanonicalW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszPhoneNumber, DWORD *pdwPhoneNumber);
CM_PHBK_DllExportB PhoneBookHasPhoneType(DWORD_PTR dwPB, PPBFS pFilter);
CM_PHBK_DllExportD PhoneBookGetPhoneType(DWORD_PTR dwPB, unsigned int nIdx);
CM_PHBK_DllExportB PhoneBookGetPhoneDUNA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszDUN, DWORD *pdwDUN);
CM_PHBK_DllExportB PhoneBookGetPhoneDUNW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDUN, DWORD *pdwDUN);

CM_PHBK_DllExportV PhoneBookEnumNumbers(DWORD_PTR dwPB, PhoneBookCallBack pfnNumber, DWORD dwCountryID, unsigned int nRegion, 
                                        PPBFS pFilter, DWORD_PTR dwParam);

CM_PHBK_DllExportV PhoneBookEnumNumbersWithRegionsZero(DWORD_PTR dwPB, PhoneBookCallBack pfnNumber, DWORD dwCountryID, 
                                                       PPBFS pFilter, DWORD_PTR dwParam);

CM_PHBK_DllExportB PhoneBookGetPhoneDispA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszDisp, DWORD *pdwDisp);
CM_PHBK_DllExportB PhoneBookGetPhoneDispW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDisp, DWORD *pdwDisp);
CM_PHBK_DllExportB PhoneBookGetPhoneDescA(DWORD_PTR dwPB, DWORD dwIdx, LPSTR pszDesc, DWORD *pdwDesc);
CM_PHBK_DllExportB PhoneBookGetPhoneDescW(DWORD_PTR dwPB, DWORD dwIdx, LPWSTR pszDesc, DWORD *pdwDesc);

#define PhoneBookParseInfoRefFunc	PhoneBookParseInfoRefFuncA
#define PhoneBookParseInfoSvcFunc	PhoneBookParseInfoSvcFuncA
#define PhoneBookParseInfoStruct	PhoneBookParseInfoStructA
#define PhoneBookParseInfo			PhoneBookParseInfoA
#define PhoneBookGetCountryName		PhoneBookGetCountryNameA
#define PhoneBookGetRegionName		PhoneBookGetRegionNameA
#define PhoneBookGetPhoneCanonical	PhoneBookGetPhoneCanonicalA
#define PhoneBookGetPhoneNonCanonical	PhoneBookGetPhoneNonCanonicalA
#define PhoneBookGetPhoneDUN		PhoneBookGetPhoneDUNA
#define PhoneBookGetPhoneDisp		PhoneBookGetPhoneDispA
#define PhoneBookGetPhoneDesc		PhoneBookGetPhoneDescA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cmstpex.h ===
//+----------------------------------------------------------------------------
//
// File:     cmstpex.h
//
// Module:   CMSTP.EXE and CMCFG32.DLL
//
// Synopsis: This header includes the type information and Extension Enumeration
//           for using the CMSTP Extension Proc that enables the user to modify
//           the installation behavior of cmstp.exe.  Use this with caution.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb      Created    05/01/99
//
//+----------------------------------------------------------------------------

typedef enum _EXTENSIONDLLPROCTIMES
{
    PRE,   // Before install, uninstall, etc.
    POST // after the cmstp action has been completed but before cmstp cleanup

} EXTENSIONDLLPROCTIMES;

typedef BOOL (WINAPI *pfnCmstpExtensionProcSpec)(LPDWORD, LPTSTR, HRESULT, EXTENSIONDLLPROCTIMES);

//
//  Modes of Operation
//
// const DWORD c_dwInstall = 0; -- not needed but 0 implies install.
TCHAR c_pszUninstall[] = TEXT("/u");
const DWORD c_dwUninstall = 0x1;
TCHAR c_pszOsMigration[] = TEXT("/m");
const DWORD c_dwOsMigration = 0x2;
TCHAR c_pszUninstallCm[] = TEXT("/x");
const DWORD c_dwUninstallCm = 0x4;
TCHAR c_pszProfileMigration[] = TEXT("/mp");
const DWORD c_dwProfileMigration = 0x8;
TCHAR c_pszHelp[] = TEXT("/?");
const DWORD c_dwHelp = 0x10;

//
//  Install Modifiers
//
TCHAR c_pszNoLegacyIcon[] = TEXT("/ni");
const DWORD c_dwNoLegacyIcon = 0x100;
TCHAR c_pszNoNT5Shortcut[] = TEXT("/ns");
const DWORD c_dwNoNT5Shortcut = 0x200;
TCHAR c_pszNoSupportFiles[] = TEXT("/nf");
const DWORD c_dwNoSupportFiles = 0x400;
TCHAR c_pszSilent[] = TEXT("/s");
const DWORD c_dwSilent = 0x800;
TCHAR c_pszSingleUser[] = TEXT("/su");
const DWORD c_dwSingleUser = 0x1000;

TCHAR c_pszIeakInstall[] = TEXT("/i");
const DWORD c_dwIeakInstall = c_dwSilent | c_dwNoSupportFiles;

TCHAR c_pszSetDefaultCon[] = TEXT("/sd"); // set IE default connection
const DWORD c_dwSetDefaultCon = 0x2000;

const int c_NumArgs = 12;

ArgStruct Args[c_NumArgs] = { 
    {c_pszUninstall, c_dwUninstall},
    {c_pszOsMigration, c_dwOsMigration},
    {c_pszUninstallCm, c_dwUninstallCm},
    {c_pszIeakInstall, c_dwIeakInstall},
    {c_pszProfileMigration, c_dwProfileMigration},
    {c_pszSilent, c_dwSilent},
    {c_pszSingleUser, c_dwSingleUser},
    {c_pszNoLegacyIcon, c_dwNoLegacyIcon},
    {c_pszNoNT5Shortcut, c_dwNoNT5Shortcut},
    {c_pszNoSupportFiles, c_dwNoSupportFiles},
    {c_pszHelp, c_dwHelp},
    {c_pszSetDefaultCon, c_dwSetDefaultCon}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\contable.h ===
//+----------------------------------------------------------------------------
//
// File:     contable.h
//
// Module:   CMCONTBL.LIB
//
// Synopsis: Header file declaring CConnectionTable
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball    Created    02/02/98
//
//+----------------------------------------------------------------------------

#include <ras.h>
#include <raserror.h>  

const int MAX_CM_CONNECTIONS = 32;

//
// Data types used by Connection Table and clients
//

typedef enum _CmConnectState {
       CM_DISCONNECTED,    // unused entry
       CM_DISCONNECTING,   // in the process of disconnecting
       CM_RECONNECTPROMPT, // prompting user to reconnect
       CM_CONNECTING,      // actively connecting 
       CM_CONNECTED,       // fully connected
} CmConnectState;

typedef struct Cm_Connection
{
	DWORD dwUsage;        		            // Reference count
    TCHAR szEntry[RAS_MaxEntryName + 1];    // Name of entry/profile 
    BOOL fAllUser;                          // Is the entry "All user"
	CmConnectState CmState;		            // Current state 
	HRASCONN hDial;		                    // Dial-up RAS handle
	HRASCONN hTunnel;		                // Tunnel RAS handle
} CM_CONNECTION, * LPCM_CONNECTION;

typedef struct Cm_Connection_Table
{
	HWND hwndCmMon;                 // the CMMON32.EXE window handle
	CM_CONNECTION Connections[MAX_CM_CONNECTIONS];  // a list of connections.
} CM_CONNECTION_TABLE, * LPCM_CONNECTION_TABLE;

//
// Class declaration
//

class CConnectionTable
{

private:

    HANDLE m_hMap;                              // Handle of file mapping 
    LPCM_CONNECTION_TABLE m_pConnTable;         // Pointer to mapped view of file
    BOOL m_fLocked;                             // Internal error checking
    HANDLE m_hEvent;                            // Event handle for locking
	
protected:

    HRESULT LockTable();

    HRESULT UnlockTable();
   
    HRESULT FindEntry(LPCTSTR pszEntry, 
        LPINT piID);

    HRESULT FindEntry(HRASCONN hRasConn, 
        LPINT piID);
    
    HRESULT FindUnused(LPINT piID);

public:

    CConnectionTable();                         // ctor

    ~CConnectionTable();                        // dtor
    
    HRESULT Create();                      // creates a new table, fails if existing

    HRESULT Open();                        // opens an existing table
   
    HRESULT Close();                       // closes an existing table
 
    HRESULT AddEntry(LPCTSTR pszEntry, BOOL fAllUser); // adds a connection entry to the table

    HRESULT RemoveEntry(LPCTSTR pszEntry);       // removes a connection entry from the table

    HRESULT GetMonitorWnd(HWND *phWnd);         // fills phWnd with HWND of CMMON in the table

    HRESULT SetMonitorWnd(HWND hwndMonitor);    // assigns the hwnd of CMMON in the table

    HRESULT GetEntry(LPCTSTR pszEntry,           // Fills the specified CM_CONNECTION structure
        LPCM_CONNECTION pConnection);           // with the data for pszEntry

    HRESULT GetEntry(HRASCONN hRasConn,          // Fills the specified CM_CONNECTION structure
        LPCM_CONNECTION pConnection);           // with the data for hRasConn

    HRESULT SetConnected(LPCTSTR pszEntry,       // sets the connection to the connected state, hDial required 
        HRASCONN hDial,
        HRASCONN hTunnel);

    HRESULT SetDisconnecting(LPCTSTR pszEntry);  // sets the connection to the disconnected state

    HRESULT SetPrompting(LPCTSTR pszEntry);      // sets the connection to the prompting state 

    HRESULT ClearEntry(LPCTSTR pszEntry);        // clears the entry regardless of usage count
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\cversion.h ===
//+----------------------------------------------------------------------------
//
// File:     cversion.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Definition of CVersion, a utility class that wraps up the
//           functionality of detecting the version of a given module.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   Created     09/14/98
//
//+----------------------------------------------------------------------------
#ifndef __CVERSION_H
#define __CVERSION_H

#include <windows.h>
#include <tchar.h>

const int c_iShiftAmount = ((sizeof(DWORD)/2) * 8);

class CVersion 
{
public:	//	Public Methods
	CVersion(LPTSTR szFile);
	CVersion();
	~CVersion();

	BOOL IsPresent();
    BOOL GetBuildNumberString(LPTSTR szStr);
	BOOL GetVersionString(LPTSTR szStr);
	BOOL GetFilePath(LPTSTR szStr);

	DWORD GetVersionNumber(); // return Major Version in Hiword, Minor in Loword
    DWORD GetBuildAndQfeNumber(); // return Build number in Hiword, QFE in Loword
    DWORD GetMajorVersionNumber();
    DWORD GetMinorVersionNumber();
    DWORD GetBuildNumber();
    DWORD GetQfeNumber();
    DWORD GetLCID();

protected:

	//
	//	Protected Methods
	//
	void	Init();
    
	//
	//	Member Variables
	//
	TCHAR m_szPath[MAX_PATH+1];
    DWORD m_dwVersion;
    DWORD m_dwBuild;
    DWORD m_dwLCID;
	BOOL  m_bIsPresent;

};

//
//  This function doesn't belong to this class but makes the GetLCID function more useful, thus
//  I have included it here.
//
BOOL ArePrimaryLangIDsEqual(DWORD dwLCID1, DWORD dwLCID2);

#endif	// __CVERSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\conact.h ===
//+----------------------------------------------------------------------------
//
// File:     conact.h
//
// Module:   CMAK.EXE and CMDIAL32.DLL
//
// Synopsis: Header file to describe the custom action execution states.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created                         02/26/00
//
//+----------------------------------------------------------------------------

//
//  Enum to mask ConData.dwFlags
//
const int c_iNumCustomActionExecutionStates = 5;

enum CustomActionExecutionStates {
    ALL_CONNECTIONS = 0x0,
    DIRECT_ONLY = 0x1,
    ALL_DIALUP = 0x2,
    DIALUP_ONLY = 0x4,
    ALL_TUNNEL = 0x8
};
const DWORD c_dwLargestExecutionState = ALL_TUNNEL;

const UINT NONINTERACTIVE = 0x10;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\dynamiclib.h ===
//+----------------------------------------------------------------------------
//
// File:     dynamiclib.h
//
// Module:   Various Connection Manager modules (CMDIAL32.DLL, CMMON32.EXE, etc)
//
// Synopsis: Definition of CDynamicLibrary, a utility class that helps with
//           the dynamic loading of a library and the getting of proc 
//           addresses from that library.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun    Created    02/17/98
//
//+----------------------------------------------------------------------------

#ifndef DYNAMICLIB_H
#define DYNAMICLIB_H

//
// Define A_W as A for ansi and W for unicode
//
#ifdef UNICODE
#define A_W  "W"
#else
#define A_W  "A"
#endif // UNICODE

//
//  Define LoadLibraryExU since not everyone is using the UAPI's yet
//
#ifndef _CMUTOA

#ifdef UNICODE
#define LoadLibraryExU  LoadLibraryExW
#else
#define LoadLibraryExU  LoadLibraryExA
#endif // UNICODE

#endif // _CMUTOA

//+---------------------------------------------------------------------------
//
//	class :	CDynamicLibrary
//
//	Synopsis:	A class that will unload the library on destructor
//
//	History:	fengsun created		2/17/97
//
//----------------------------------------------------------------------------

class CDynamicLibrary
{
public:
    CDynamicLibrary();
    CDynamicLibrary(const TCHAR* lpLibraryName);
    ~CDynamicLibrary();

    BOOL Load(const TCHAR* lpLibraryName);
    void Unload();

    BOOL IsLoaded() const;
    BOOL EnsureLoaded(const TCHAR* lpLibraryName);
    HINSTANCE GetInstance() const;

    FARPROC GetProcAddress(const char* lpProcName) const; 

protected:
    HINSTANCE m_hInst; // The instance handle returned by LoadLibrary
};

//
// Constructor
//
inline CDynamicLibrary::CDynamicLibrary() :m_hInst(NULL) {}

//
// Constructor that calls LoadLibrary
//
inline CDynamicLibrary::CDynamicLibrary(const TCHAR* lpLibraryName)
{
    m_hInst = NULL;
    Load(lpLibraryName);
}


//
// Destructor that automatic FreeLibrary
//
inline CDynamicLibrary::~CDynamicLibrary()
{
    Unload();
}

//
// Call LoadLibrary
//
inline BOOL CDynamicLibrary::Load(const TCHAR* lpLibraryName)
{
    MYDBGASSERT(m_hInst == NULL);
    MYDBGASSERT(lpLibraryName);

	CMTRACE1(TEXT("CDynamicLibrary - Loading library - %s"), lpLibraryName);

    m_hInst = LoadLibraryExU(lpLibraryName, NULL, 0);

#ifdef DEBUG
    if (!m_hInst)
    {
        CMTRACE1(TEXT("CDynamicLibrary - LoadLibrary failed - GetLastError() = %u"), GetLastError());
    }
#endif

    return m_hInst != NULL;
}

//
// Call FreeLibrary
//
inline void CDynamicLibrary::Unload()
{
    if (m_hInst)
    {
        FreeLibrary(m_hInst);
        m_hInst = NULL;
    }
}


//
// Whether the library is successfully loaded
//
inline BOOL CDynamicLibrary::IsLoaded() const
{
    return m_hInst != NULL;
}

//
// Retrieve the instance handle
//
inline HINSTANCE CDynamicLibrary::GetInstance() const
{
    return m_hInst;
}

//
// call ::GetProcAddress on m_hInst
//
inline FARPROC CDynamicLibrary::GetProcAddress(const char* lpProcName) const
{
    MYDBGASSERT(m_hInst);

    if (m_hInst)
    {
        return ::GetProcAddress(m_hInst, lpProcName);
    }

    return NULL;
}

//
// Load the library, if not loaded yet,
// Note, we do not check the consistence of lpLibraryName.  Use caution with this function
//
inline BOOL CDynamicLibrary::EnsureLoaded(const TCHAR* lpLibraryName)
{
    MYDBGASSERT(lpLibraryName);
    if (m_hInst == NULL)
    {
        m_hInst = LoadLibraryEx(lpLibraryName, NULL, 0);
    }

    return m_hInst != NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\gppswithalloc.h ===
//+----------------------------------------------------------------------------
//
// File:     gppswithalloc.h
//
// Module:   CMDIAL32.DLL, CMAK.EXE
//
// Synopsis: GetPrivateProfileStringWithAlloc and AddAllKeysInCurrentSectionToCombo
//           are defined here
//
// Copyright (c) 2000-2001 Microsoft Corporation
//
// Author:   quintinb   Created    11/01/00
//
//+----------------------------------------------------------------------------
LPTSTR GetPrivateProfileStringWithAlloc(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszDefault, LPCTSTR pszFile);
void AddAllKeysInCurrentSectionToCombo(HWND hDlg, UINT uComboId, LPCTSTR pszSection, LPCTSTR pszFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\icwprdver.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1998 Microsoft Corporation
//*********************************************************************
#include "pnpuverp.h"

#undef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR		"Microsoft(R) Connection Manager"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\modaldlg.h ===
//+----------------------------------------------------------------------------
//
// File:     modaldlg.h
//
// Module:   CMDIAL32.DLL and CMMON32.EXE
//
// Synopsis: Definition of the classes CWindowWithHelp, CModalDlg
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun    Created    02/17/98
//
//+----------------------------------------------------------------------------

#ifndef MODALDLG_H
#define MODALDLG_H

#include "CmDebug.h"
//+---------------------------------------------------------------------------
//
//	class CWindowWithHelp
//
//	Description: A general window class that has context help
//
//	History:	fengsun	Created		10/30/97
//
//----------------------------------------------------------------------------

class CWindowWithHelp
{
public:
    CWindowWithHelp(const DWORD* pHelpPairs, const TCHAR* lpszHelpFile = NULL) ;
    ~CWindowWithHelp();
	HWND GetHwnd() const { return m_hWnd;}
    void SetHelpFileName(const TCHAR* lpszHelpFile);

protected:
    HWND m_hWnd;
    const DWORD* m_pHelpPairs; // pairs of <resource ID, help ID>
    LPTSTR m_lpszHelpFile; // the help file name

    void OnHelp(const HELPINFO* pHelpInfo); // WM_HELP
    BOOL OnContextMenu( HWND hWnd, POINT& pos ); // WM_CONTEXTMENU

    BOOL HasContextHelp(HWND hWndCtrl) const;

public:
#ifdef DEBUG
    void AssertValid()
    {
        MYDBGASSERT(m_hWnd == NULL || IsWindow(m_hWnd));
    }
#endif

};

//+---------------------------------------------------------------------------
//
//	class CModalDlg
//
//	Description: A general modal dialog class
//
//	History:	fengsun	Created		10/30/97
//
//----------------------------------------------------------------------------

class CModalDlg :public CWindowWithHelp
{
public:
    CModalDlg(const DWORD* pHelpPairs = NULL, const TCHAR* lpszHelpFile = NULL) 
        : CWindowWithHelp(pHelpPairs, lpszHelpFile){};

    //
    // Create the dialog box
    //
    INT_PTR DoDialogBox(HINSTANCE hInstance, 
                    LPCTSTR lpTemplateName,
                    HWND hWndParent);

    INT_PTR DoDialogBox(HINSTANCE hInstance, 
                    DWORD dwTemplateId,
                    HWND hWndParent);


    virtual BOOL OnInitDialog();  // WM_INITDIALOG
    virtual void OnOK();          // WM_COMMAND, IDOK
    virtual void OnCancel();      // WM_COMMAND, IDCANCEL

    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );
    virtual DWORD OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam );

protected:
    static BOOL CALLBACK ModalDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);
};

//
// Inline functions
//
inline INT_PTR CModalDlg::DoDialogBox(HINSTANCE hInstance, DWORD dwTemplateId, HWND hWndParent)
{
    return DoDialogBox(hInstance, (LPCTSTR)ULongToPtr(dwTemplateId), hWndParent);
}

inline BOOL CModalDlg::OnInitDialog()
{
    //
    // set the default keyboard focus
    //
    return TRUE;
}

inline void CModalDlg::OnOK()
{
	EndDialog(m_hWnd, IDOK);
}

inline void CModalDlg::OnCancel()
{
	EndDialog(m_hWnd, IDCANCEL);
}

inline DWORD CModalDlg::OnOtherCommand(WPARAM , LPARAM  )
{
    return FALSE;
}

inline DWORD CModalDlg::OnOtherMessage(UINT , WPARAM , LPARAM  )
{
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\inetcfg.h ===
//*******************************************************************
//
//  Copyright (c) 1996-1998 Microsoft Corporation
//
//  *** N O T   F O R   E X T E R N A L   R E L E A S E *******
//  This header file is not intended for distribution outside Microsoft.
//
//  FILE: INETCFG.H
//
//  PURPOSE:  Contains API's exported from inetcfg.dll and structures
//            required by those functions. 
//            Note:  Definitions in this header file require RAS.H.
//
//*******************************************************************

#ifndef _INETCFG_H_
#define _INETCFG_H_

#ifndef UNLEN
#include <lmcons.h>
#endif

// Generic HRESULT error code
#define ERROR_INETCFG_UNKNOWN 0x20000000L

#define MAX_EMAIL_NAME          64
#define MAX_EMAIL_ADDRESS       128
#define MAX_LOGON_NAME          UNLEN
#define MAX_LOGON_PASSWORD      PWLEN
#define MAX_SERVER_NAME         64  // max length of DNS name per RFC 1035 +1

// Flags for dwfOptions

// install Internet mail
#define INETCFG_INSTALLMAIL           0x00000001
// Invoke InstallModem wizard if NO MODEM IS INSTALLED
#define INETCFG_INSTALLMODEM          0x00000002
// install RNA (if needed)
#define INETCFG_INSTALLRNA            0x00000004
// install TCP (if needed)
#define INETCFG_INSTALLTCP            0x00000008
// connecting with LAN (vs modem)
#define INETCFG_CONNECTOVERLAN        0x00000010
// Set the phone book entry for autodial
#define INETCFG_SETASAUTODIAL         0x00000020
// Overwrite the phone book entry if it exists
// Note: if this flag is not set, and the entry exists, a unique name will
// be created for the entry.
#define INETCFG_OVERWRITEENTRY        0x00000040
// Do not show the dialog that tells the user that files are about to be installed,
// with OK/Cancel buttons.
#define INETCFG_SUPPRESSINSTALLUI     0x00000080
// Check if TCP/IP file sharing is turned on, and warn user to turn it off.
// Reboot is required if the user turns it off.
//#define INETCFG_WARNIFSHARINGBOUND    0x00000100
// Check if TCP/IP file sharing is turned on, and force user to turn it off.
// If user does not want to turn it off, return will be ERROR_CANCELLED
// Reboot is required if the user turns it off.
//#define INETCFG_REMOVEIFSHARINGBOUND  0x00000200
// Indicates that this is a temporary phone book entry
// In Win3.1 an icon will not be created
#define INETCFG_TEMPPHONEBOOKENTRY    0x00000400
// Show the busy dialog while checking system configuration
//#define INETCFG_SHOWBUSYANIMATION     0x00000800

//
// Chrisk 5/8/97
// Note: the next three switches are only valid for InetNeedSystemComponents
// Check if LAN adapter is installed and bound to TCP
//
#define INETCFG_INSTALLLAN            0x00001000

//
// Check if DIALUP adapter is installed and bound to TCP
//
#define INETCFG_INSTALLDIALUP         0x00002000

//
// Check to see if TCP is installed requardless of binding
//
#define INETCFG_INSTALLTCPONLY        0x00004000

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

// constants for INETCLIENTINFO.dwFlags

#define INETC_LOGONMAIL     0x00000001
#define INETC_LOGONNEWS     0x00000002
#define INETC_LOGONDIRSERV  0x00000004

// Struct INETCLIENTINFO
//
// This structure is used when getting and setting the internet
// client parameters
//
// The members are as follows:
//
//  dwSize
//    size of this structure, for future versioning
//    this member should be set before passing the structure to the DLL
//  dwFlags
//    miscellaneous flags
//    see definitions above
//  szEMailName
//    user's internet email name
//  szEMailAddress
//    user's internet email address
//	***Note: the following three fields are outdated, and should only be used by old legacy code.
//  ***      new code should use szIncomingMail* and iIncomingProtocol fields.
//  szPOPLogonName
//    user's internet mail server logon name 
//  szPOPLogonPassword
//    user's internet mail server logon password
//  szPOPServer
//    user's internet mail POP3 server
//  szSMTPServer
//    user's internet mail SMTP server
//  szNNTPLogonName
//    user's news server logon name
//  szNNTPLogonPassword
//    user's news server logon password
//  szNNTPServer
//    user's news server
//  ** End of original 1.0 structure.
//	??/??/96 ValdonB
//  szNNTPName
//    user's friendly name to include in NNTP posts.(?? Valdon?)
//  szNNTPAddress
//    user's reply-to email address for NNTP posts.(?? Valdon?)
//  11/23/96  jmazner Normandy #8504
//  iIncomingProtocol
//	  user's choice of POP3 or IMAP4 protocol for incoming mail
//	  Holds the enum values defined in ACCTTYPE from imact.h//
//  szIncomingMailLogonName
//    user's internet mail server logon name 
//  szIncomingMailLogonPassword
//    user's internet mail server logon password
//  szIncomingMailServer
//    user's internet mail POP3 server
//  12/15/96	jmazner	
//  fMailLogonSPA
//	  Use Sicily/SPA/DPA for the incoming mail server
//  fNewsLogonSPA
//	  Use Sicily/SPA/DPA for the news server
//	2/4/96 jmazner -- LDAP functionality
//	szLDAPLogonName
//	szLDAPLogonPassword
//	szLDAPServer
//	fLDAPLogonSPA
//	fLDAPResolve

  typedef struct tagINETCLIENTINFO
  {
    DWORD   dwSize;
    DWORD   dwFlags;
    CHAR    szEMailName[MAX_EMAIL_NAME + 1];
    CHAR    szEMailAddress[MAX_EMAIL_ADDRESS + 1];
    CHAR    szPOPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szPOPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szPOPServer[MAX_SERVER_NAME + 1];
    CHAR    szSMTPServer[MAX_SERVER_NAME + 1];
    CHAR    szNNTPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szNNTPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szNNTPServer[MAX_SERVER_NAME + 1];
	// end of version 1.0 structure;
	// extended 1.1 structure includes the following fields:
    CHAR    szNNTPName[MAX_EMAIL_NAME + 1];
    CHAR    szNNTPAddress[MAX_EMAIL_ADDRESS + 1];
	int		iIncomingProtocol;
    CHAR    szIncomingMailLogonName[MAX_LOGON_NAME + 1];
    CHAR    szIncomingMailLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szIncomingMailServer[MAX_SERVER_NAME + 1];
	BOOL	fMailLogonSPA;
	BOOL	fNewsLogonSPA;
    CHAR    szLDAPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szLDAPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szLDAPServer[MAX_SERVER_NAME + 1];
	BOOL	fLDAPLogonSPA;
	BOOL	fLDAPResolve;

  } INETCLIENTINFO, *PINETCLIENTINFO, FAR *LPINETCLIENTINFO;


// Function prototypes

//*******************************************************************
//
//  FUNCTION:   InetGetClientInfo
//
//  PURPOSE:    This function will get the internet client params
//              from the registry
//
//  PARAMETERS: lpClientInfo - on return, this structure will contain
//              the internet client params as set in the registry.
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetGetClientInfo(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo);


//*******************************************************************
//
//  FUNCTION:   InetSetClientInfo
//
//  PURPOSE:    This function will set the internet client params
//
//  PARAMETERS: lpClientInfo - pointer to struct with info to set
//              in the registry.
//              lpszProfileName - Name of client info profile to
//              modify.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetSetClientInfo(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo);


//*******************************************************************
//
//  FUNCTION:   InetConfigSystem
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigSystem(
  HWND    hwndParent,          
  DWORD   dwfOptions,         
  LPBOOL  lpfNeedsRestart);  


//*******************************************************************
//
//  FUNCTION:   InetConfigSystemFromPath
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags and from the given [ath.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//              lpszSourcePath - full path of location of files to install.  If
//              this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigSystemFromPath(
  HWND hwndParent,
  DWORD dwfOptions,
  LPBOOL lpfNeedsRestart,
  LPCSTR lpszSourcePath);


//*******************************************************************
//
//  FUNCTION:   InetConfigClient
//
//  PURPOSE:    This function requires a valid phone book entry name
//              (unless it is being used just to set the client info).
//              If lpRasEntry points to a valid RASENTRY struct, the phone
//              book entry will be created (or updated if it already exists)
//              with the data in the struct.
//              If username and password are given, these
//              will be set as the dial params for the phone book entry.
//              If a client info struct is given, that data will be set.
//              Any files (ie TCP and RNA) that are needed will be
//              installed by calling InetConfigSystem().
//              This function will also perform verification on the device
//              specified in the RASENTRY struct.  If no device is specified,
//              the user will be prompted to install one if there are none
//              installed, or they will be prompted to choose one if there
//              is more than one installed.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              lpszPhonebook - name of phone book to store the entry in
//              lpszEntryName - name of phone book entry to be
//              created or modified
//              lpRasEntry - specifies a RASENTRY struct that contains
//              the phone book entry data for the entry lpszEntryName
//              lpszUsername - username to associate with the phone book entry
//              lpszPassword - password to associate with the phone book entry
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//              lpINetClientInfo - client information
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.  Note that if
//                                       no modem is installed and this flag
//                                       is not set, the function will fail
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_SETASAUTODIAL - Set the phone book entry for autodial
//                INETCFG_OVERWRITEENTRY - Overwrite the phone book entry if it
//                                         exists.  Note: if this flag is not
//                                         set, and the entry exists, a unique
//                                         name will be created for the entry.
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigClient(
  HWND              hwndParent,         
  LPCSTR            lpszPhonebook,
  LPCSTR            lpszEntryName,
  LPRASENTRY        lpRasEntry,         
  LPCSTR            lpszUsername,       
  LPCSTR            lpszPassword,       
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFO  lpINetClientInfo,   
  DWORD             dwfOptions,                     
  LPBOOL            lpfNeedsRestart);              


//*******************************************************************
//
//  FUNCTION:   InetGetAutodial
//
//  PURPOSE:    This function will get the autodial settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if autodial
//              is enabled
//              lpszEntryName - on return, this buffer will contain the 
//              name of the phone book entry that is set for autodial
//              cbEntryNameSize - size of buffer for phone book entry name
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetGetAutodial(
  LPBOOL  lpfEnable,     
  LPSTR   lpszEntryName,  
  DWORD   cbEntryNameSize);


//*******************************************************************
//
//  FUNCTION:   InetSetAutodial
//
//  PURPOSE:    This function will set the autodial settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, autodial will be enabled.
//                        If set to FALSE, autodial will be disabled.
//              lpszEntryName - name of the phone book entry to set
//                              for autodial.  If this is "", the
//                              entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetSetAutodial(
  BOOL    fEnable,       
  LPCSTR  lpszEntryName); 


//*******************************************************************
//
//  FUNCTION:   InetSetProxy
//
//  PURPOSE:    This function will set the proxy settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//              lpszServer - name of the proxy server.  If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//              lpszOverride - proxy override. If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetSetProxy(
  BOOL    fEnable,
  LPCSTR  lpszServer,
  LPCSTR  lpszOverride);

//*******************************************************************
//
//  FUNCTION:   InetGetProxy
//
//  PURPOSE:    This function will get the proxy settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if proxy
//              is enabled
//              lpszServer - on return, this buffer will contain the 
//              name of the proxy server
//              cbServer - size of buffer for proxy server name
//              lpszOverride - on return, this buffer will contain the 
//              name of the proxy server
//              cbOverride - size of buffer for proxy override
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetGetProxy(
  LPBOOL  lpfEnable,
  LPSTR   lpszServer,
  DWORD   cbServer,
  LPSTR   lpszOverride,
  DWORD   cbszOverride);

//*******************************************************************
//
//	FUNCTION:	InetStartServices
//
//	PURPOSE:	This function guarentees that RAS services are running
//
//	PARAMETERS:	none
//
//	RETURNS		ERROR_SUCCESS - if the services are enabled and running
//
//*******************************************************************
HRESULT WINAPI  InetStartServices();

//*******************************************************************
//
//	Function:	IsSmartStart
//
//	Synopsis:	This function will determine if the ICW should be run.  The
//				decision is made based on the current state of the user's machine.
//				
//	Arguments:	none
//
//	Returns:	TRUE - run ICW; FALSE - quit now
//
//	History:	5/8/97	ChrisK	Created
//
//*******************************************************************
DWORD WINAPI IsSmartStart();

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_INETCFG_H_#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\mutex.h ===
//+----------------------------------------------------------------------------
//
// File:     mutex.h
//
// Module:   CMSETUP.LIB, CMDIAL32.DLL, CMDL32.EXE
//
// Synopsis: Definition of the class CNamedMutex
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun    Created    02/26/98
//
//+----------------------------------------------------------------------------


#ifndef __CM_MUTEXT_H
#define __CM_MUTEXT_H

#include <windows.h>
#include "cmdebug.h"

//+---------------------------------------------------------------------------
//
//	class CNamedMutex
//
//	Description: A class to lock/unlock a named mutex
//               The destructor releases the mutex.
//
//	History:	fengsun	Created		2/19/98
//
//----------------------------------------------------------------------------

class CNamedMutex
{
public:
    CNamedMutex() {m_hMutex = NULL; m_fOwn = FALSE;}
    ~CNamedMutex() {Unlock();}

    BOOL Lock(LPCTSTR lpName, BOOL fWait = FALSE, DWORD dwMilliseconds = INFINITE, BOOL fNoAbandon = FALSE);
    void Unlock();
protected:
    HANDLE m_hMutex; // the handle of the mutex
    BOOL m_fOwn;     // whther we own the mutex
};

#endif //__CM_MUTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\oharestr.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//	OHARESTR.H - string defines for O'Hare components
//			
//

//	HISTORY:
//	
//	3/10/95		jeremys		Created.
//


#ifndef _OHARESTR_H_
#define _OHARESTR_H_

// path to RNA values (under HKEY_CURRENT_USER)
#define REGSTR_PATH_REMOTEACCESS	"RemoteAccess"

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_INTERNETPROFILE	"InternetProfile"
#define REGSTR_VAL_BKUPINTERNETPROFILE	"BackupInternetProfile"

// path to global internet settings (also under HKEY_CURRENT_USER)
#define REGSTR_PATH_INTERNET_SETTINGS REGSTR_PATH_SETUP "\\Internet Settings"

// values under HKCY\REGSTR_PATH_INTERNET_SETTINGS

// 4-byte REG_BINARY, autodialing is enabled if this value is present and
// non-zero, disabled otherwise
#define REGSTR_VAL_ENABLEAUTODIAL 		"EnableAutodial"
#define REGSTR_VAL_ENABLEAUTODISCONNECT	"EnableAutodisconnect"
#define REGSTR_VAL_ENABLESECURITYCHECK	"EnableSecurityCheck"

// 4-byte REG_BINARY containing number of minutes of idle time to allow
// before autodisconnect.  Autodisconnect is disabled if this value is zero
// or not present.
#define REGSTR_VAL_DISCONNECTIDLETIME	"DisconnectIdleTime"

// class name for window to receive Winsock activity messages
#define AUTODIAL_MONITOR_CLASS_NAME	"MS_AutodialMonitor"

// name of connectoid-specific autodial handler dll and function
#define REGSTR_VAL_AUTODIALDLLNAME		"AutodialDllName"
#define REGSTR_VAL_AUTODIALFCNNAME		"AutodialFcnName"

// proxy settings
#define REGSTR_VAL_PROXYENABLE          "ProxyEnable"
#define REGSTR_VAL_PROXYSERVER          "ProxyServer"
#define REGSTR_VAL_PROXYOVERRIDE        "ProxyOverride"

// access medium (modem, LAN, [etc?])
#define REGSTR_VAL_ACCESSMEDIUM			"AccessMedium"

// access type (MSN, other)
#define REGSTR_VAL_ACCESSTYPE			"AccessType"

#endif // _OHARESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\linkdll.h ===
//+----------------------------------------------------------------------------
//
// File:     linkdll.h
//
// Module:   CMCFG32.DLL, CMDIAL32.DLL, CMSECURE.LIB, AND MIGRATE.DLL
//
// Synopsis: Header for linkage functions LinkToDll and BindLinkage.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------
BOOL LinkToDll(HINSTANCE *phInst, LPCSTR pszDll, LPCSTR *ppszPfn, void **ppvPfn);
BOOL BindLinkage(HINSTANCE hInstDll, LPCSTR *ppszPfn, void **ppvPfn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\processcmdln.h ===
//+----------------------------------------------------------------------------
//
// File:     processcmdln.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Definition of the CProcessCmdLn class.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------

#ifndef _CM_PROCESSCMDLN_H_
#define _CM_PROCESSCMDLN_H_

#include <windows.h>
#include "cfilename.h"
#include "mutex.h"

//
//  Command Line struct for storing cmd line flags
//

typedef struct _ArgStruct
{
	TCHAR* pszArgString;
	DWORD dwFlagModifier;
} ArgStruct;

//
//  Command Line State enumeration taken from Icm.h
//

typedef enum _CMDLN_STATE
{
    CS_END_SPACE,   // done handling a space
    CS_BEGIN_QUOTE, // we've encountered a begin quote
    CS_END_QUOTE,   // we've encountered a end quote
    CS_CHAR,        // we're scanning chars
    CS_DONE
} CMDLN_STATE;

class CProcessCmdLn
{

public:
    CProcessCmdLn(UINT NumSwitches, ArgStruct* pArrayOfArgStructs, BOOL bSkipFirstToken, BOOL bBlankCmdLnOkay);
    ~CProcessCmdLn();

    BOOL GetCmdLineArgs(IN LPTSTR pszCmdln, OUT LPDWORD pdwFlags, OUT LPTSTR pszPath, UINT uPathStrLimit);

private:    
    UINT m_NumSwitches;
    BOOL m_bSkipFirstToken;
    BOOL m_bBlankCmdLnOkay;
    ArgStruct* m_CommandLineSwitches;

    BOOL IsValidSwitch(LPCTSTR pszSwitch, LPDWORD pdwFlags);
    BOOL IsValidFilePath(LPCTSTR pszFile);
    BOOL EnsureFullFilePath(LPTSTR pszFile, UINT uNumChars);
    BOOL CheckIfValidSwitchOrPath(LPCTSTR pszToken, LPDWORD pdwFlags, 
                                  BOOL* pbFoundPath, LPTSTR pszPath);
};


#endif  //_CM_PROCESSCMDLN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\modelessdlg.h ===
//+----------------------------------------------------------------------------
//
// File:     modlessdlg.h
//
// Module:   CMDIAL32.DLL and CMMON32.EXE
//
// Synopsis: Definition of the class CModelessDlg
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:   nickball    Created file   03/22/00
//
//+----------------------------------------------------------------------------

#ifndef MODELESSDLG_H
#define MODELESSDLG_H

#include "modaldlg.h"

//+---------------------------------------------------------------------------
//
//	class CModelessDlg
//
//	Description: A general modeless dialog, call create to CreateDialog
//
//	History:	fengsun	        Created		    10/30/97
//              nickball        Added Flash     03/22/00
//
//----------------------------------------------------------------------------
class CModelessDlg :public CModalDlg
{
public:
    CModelessDlg(const DWORD* pHelpPairs = NULL, const TCHAR* lpszHelpFile = NULL)
        : CModalDlg(pHelpPairs, lpszHelpFile){};

    //
    // Create the dialog box
    //
    HWND Create(HINSTANCE hInstance, 
                LPCTSTR lpTemplateName,
                HWND hWndParent);

    HWND Create(HINSTANCE hInstance, 
                DWORD dwTemplateId,
                HWND hWndParent);
protected:
    virtual void OnOK() {DestroyWindow(m_hWnd);}          // WM_COMMAND, IDOK
    virtual void OnCancel(){DestroyWindow(m_hWnd);}      // WM_COMMAND, IDCANCEL
    void Flash();
};

inline HWND CModelessDlg::Create(HINSTANCE hInstance, DWORD dwTemplateId, HWND hWndParent)
{
    return Create(hInstance, (LPCTSTR)ULongToPtr(dwTemplateId), hWndParent);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\pwutil.h ===
//+----------------------------------------------------------------------------
//
// File:     pwutil.h
//
// Module:   CMDIAL32.DLL, CMCFG32.DLL, AND MIGRATE.DLL
//
// Synopsis: Header for pwutil functions
//           Simple encryption functions borrowed from RAS
//
// Copyright (c) 1994-1999 Microsoft Corporation
//
// Author:   nickball    Created    08/03/99
//
//+----------------------------------------------------------------------------

#ifndef CM_PWUTIL_H_
#define CM_PWUTIL_H_

VOID
CmDecodePasswordA(
    CHAR* pszPassword
    );

VOID
CmDecodePasswordW(
    WCHAR* pszPassword
    );

VOID
CmEncodePasswordA(
    CHAR* pszPassword
    );

VOID
CmEncodePasswordW(
    WCHAR* pszPassword
    );

VOID
CmWipePasswordA(
    CHAR* pszPassword
    );

VOID
CmWipePasswordW(
    WCHAR* pszPassword
    );

#ifdef UNICODE
#define CmDecodePassword  CmDecodePasswordW
#define CmEncodePassword  CmEncodePasswordW
#define CmWipePassword    CmWipePasswordW
#else
#define CmDecodePassword  CmDecodePasswordA
#define CmEncodePassword  CmEncodePasswordA
#define CmWipePassword    CmWipePasswordA
#endif

#endif // CM_PWUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\setupmem.h ===
//+----------------------------------------------------------------------------
//
// File:     setupmem.h
//
// Module:   CMSETUP.LIB
//
// Synopsis: Memory utility functions taken from cmutil.  Bare minimum of functionality
//           used in Cmutil, but gives a simple Heapalloc wrapper.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb Created	10-6-98
//
//+----------------------------------------------------------------------------

#ifndef __SETUPMEM_H
#define __SETUPMEM_H
//+----------------------------------------------------------------------------
// definitions
//+----------------------------------------------------------------------------
#ifdef DEBUG
extern LONG    g_lMallocCnt;
#endif

void *CmRealloc(void *pvPtr, size_t nBytes);
void *CmMalloc(size_t nBytes);
void CmFree(void *pvPtr);
void EndDebugMemory();

#endif //__SETUPMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\raslink.h ===
//+----------------------------------------------------------------------------
//
// File:     raslink.h
//
// Module:   CMDIAL32.DLL and CMUTOA.DLL
//
// Synopsis: Structures and function types for RAS Linkage.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb   Created     05/05/99
//
//+----------------------------------------------------------------------------
//
//  If you modify any of the functions below (add/remove/whatever), you may need to modify the
//  constant string arrays in common\source\raslink.cpp
//

//
//  Ansi prototypes
//
typedef DWORD (WINAPI *pfnRasDeleteEntryA)(LPCSTR, LPCSTR);
typedef DWORD (WINAPI *pfnRasGetEntryPropertiesA)(LPCSTR, LPCSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD (WINAPI *pfnRasSetEntryPropertiesA)(LPCSTR, LPCSTR, LPRASENTRYA, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI *pfnRasGetEntryDialParamsA)(LPCSTR, LPRASDIALPARAMSA,  LPBOOL);
typedef DWORD (WINAPI *pfnRasSetEntryDialParamsA)(LPCSTR, LPRASDIALPARAMSA,  BOOL);
typedef DWORD (WINAPI *pfnRasEnumDevicesA)(LPRASDEVINFOA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI *pfnRasDialA)(LPRASDIALEXTENSIONS,LPCSTR,LPRASDIALPARAMSA,DWORD,LPVOID,LPHRASCONN);
typedef DWORD (WINAPI *pfnRasGetErrorStringA)(UINT, LPSTR, DWORD);
typedef DWORD (WINAPI *pfnRasGetConnectStatusA)(HRASCONN, LPRASCONNSTATUSA);

//  These are never used on win9x but we need a prototype for the struct
typedef DWORD (WINAPI *pfnRasSetSubEntryPropertiesA)(LPCSTR, LPCSTR, DWORD, LPRASSUBENTRYA, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI *pfnRasSetCustomAuthDataA)(LPCSTR, LPCSTR, BYTE *, DWORD);  

typedef DWORD (WINAPI *pfnRasGetEapUserIdentityA)(LPCSTR, LPCSTR, DWORD, HWND, LPRASEAPUSERIDENTITYA*);
typedef VOID  (WINAPI *pfnRasFreeEapUserIdentityA)(LPRASEAPUSERIDENTITYA);
typedef DWORD (WINAPI *pfnRasDeleteSubEntryA)(LPCSTR, LPCSTR, DWORD);
typedef DWORD (WINAPI *pfnRasGetCredentialsA)(LPCSTR, LPCSTR, LPRASCREDENTIALSA);
typedef DWORD (WINAPI *pfnRasSetCredentialsA)(LPCSTR, LPCSTR, LPRASCREDENTIALSA, BOOL);

//
//  Unicode Prototypes
//
typedef DWORD (WINAPI *pfnRasDeleteEntryW)(LPCWSTR, LPCWSTR);
typedef DWORD (WINAPI *pfnRasGetEntryPropertiesW)(LPCWSTR, LPCWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD (WINAPI *pfnRasSetEntryPropertiesW)(LPCWSTR, LPCWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI *pfnRasGetEntryDialParamsW)(LPCWSTR, LPRASDIALPARAMSW,  LPBOOL);
typedef DWORD (WINAPI *pfnRasSetEntryDialParamsW)(LPCWSTR, LPRASDIALPARAMSW,  BOOL);
typedef DWORD (WINAPI *pfnRasEnumDevicesW)(LPRASDEVINFOW, LPDWORD, LPDWORD);
typedef DWORD (WINAPI *pfnRasDialW)(LPRASDIALEXTENSIONS,LPCWSTR,LPRASDIALPARAMSW,DWORD,LPVOID,LPHRASCONN);
typedef DWORD (WINAPI *pfnRasGetErrorStringW)(UINT, LPWSTR, DWORD);
typedef DWORD (WINAPI *pfnRasGetConnectStatusW)(HRASCONN, LPRASCONNSTATUSW);
typedef DWORD (WINAPI *pfnRasSetSubEntryPropertiesW)(LPCWSTR, LPCWSTR, DWORD, LPRASSUBENTRYW, DWORD, LPBYTE, DWORD);
typedef DWORD (WINAPI *pfnRasSetCustomAuthDataW)(LPCWSTR, LPCWSTR, BYTE *, DWORD);  
typedef DWORD (WINAPI *pfnRasDeleteSubEntryW)(LPCWSTR, LPCWSTR, DWORD);

typedef DWORD (WINAPI *pfnRasGetEapUserIdentityW)(LPCWSTR, LPCWSTR, DWORD, HWND, LPRASEAPUSERIDENTITYW*);
typedef VOID  (WINAPI *pfnRasFreeEapUserIdentityW)(LPRASEAPUSERIDENTITYW);
typedef DWORD (WINAPI *pfnRasGetCredentialsW)(LPCWSTR, LPCWSTR, LPRASCREDENTIALSW);
typedef DWORD (WINAPI *pfnRasSetCredentialsW)(LPCWSTR, LPCWSTR, LPRASCREDENTIALSW, BOOL);

//
// Char size independent prototypes
//

typedef DWORD (WINAPI *pfnRasInvokeEapUI) (HRASCONN, DWORD, LPRASDIALEXTENSIONS, HWND);
typedef DWORD (WINAPI *pfnRasHangUp)(HRASCONN);


//
// Structure used to describe the linkage to RAS.  NOTE:  Changes to this structure
// will probably require changes to LinkToRas() and UnlinkFromRas() as well as the
// win9x UtoA code in cmutoa.cpp.
//
typedef struct _RasLinkageStructA {

    HINSTANCE hInstRas;
    HINSTANCE hInstRnaph;
    union {
        struct {
            pfnRasDeleteEntryA pfnDeleteEntry;
            pfnRasGetEntryPropertiesA pfnGetEntryProperties;
            pfnRasSetEntryPropertiesA pfnSetEntryProperties;
            pfnRasGetEntryDialParamsA pfnGetEntryDialParams;
            pfnRasSetEntryDialParamsA pfnSetEntryDialParams;
            pfnRasEnumDevicesA pfnEnumDevices;
            pfnRasDialA pfnDial;
            pfnRasHangUp pfnHangUp;
            pfnRasGetErrorStringA pfnGetErrorString;
            pfnRasGetConnectStatusA pfnGetConnectStatus;
            pfnRasSetSubEntryPropertiesA pfnSetSubEntryProperties;
            pfnRasDeleteSubEntryA pfnDeleteSubEntry;
            pfnRasSetCustomAuthDataA pfnSetCustomAuthData;
            pfnRasGetEapUserIdentityA pfnGetEapUserIdentity;
            pfnRasFreeEapUserIdentityA pfnFreeEapUserIdentity;
            pfnRasInvokeEapUI pfnInvokeEapUI;
            pfnRasGetCredentialsA pfnGetCredentials;
            pfnRasSetCredentialsA pfnSetCredentials;

        };
        void *apvPfnRas[19];  // This was from the old hacking code. The size of 
                              // apvPfnRas[] should always be 1 size bigger than
                              // the number of functions. 
                              // Refer to apszRas[] in 'ras.cpp'. The size of 
                              // apszRas[] is equal to sizeof(apvPfnRas[]).
    };
} RasLinkageStructA ;


typedef struct _RasLinkageStructW {

    HINSTANCE hInstRas;
    union {
        struct {
            pfnRasDeleteEntryW pfnDeleteEntry;
            pfnRasGetEntryPropertiesW pfnGetEntryProperties;
            pfnRasSetEntryPropertiesW pfnSetEntryProperties;
            pfnRasGetEntryDialParamsW pfnGetEntryDialParams;
            pfnRasSetEntryDialParamsW pfnSetEntryDialParams;
            pfnRasEnumDevicesW pfnEnumDevices;
            pfnRasDialW pfnDial;
            pfnRasHangUp pfnHangUp;
            pfnRasGetErrorStringW pfnGetErrorString;
            pfnRasGetConnectStatusW pfnGetConnectStatus;
            pfnRasSetSubEntryPropertiesW pfnSetSubEntryProperties;
            pfnRasDeleteSubEntryW pfnDeleteSubEntry;
            pfnRasSetCustomAuthDataW pfnSetCustomAuthData;
            pfnRasGetEapUserIdentityW pfnGetEapUserIdentity;
            pfnRasFreeEapUserIdentityW pfnFreeEapUserIdentity;
            pfnRasInvokeEapUI pfnInvokeEapUI;
            pfnRasGetCredentialsW pfnGetCredentials;
            pfnRasSetCredentialsW pfnSetCredentials;

        };
        void *apvPfnRas[19];  // This was from the old hacking code. The size of 
                              // apvPfnRas[] should always be 1 size bigger than
                              // the number of functions. 
                              // Refer to apszRas[] in 'ras.cpp'. The size of 
                              // apszRas[] is equal to sizeof(apvPfnRas[]).
    };
} RasLinkageStructW ;


#ifdef UNICODE
#define RasLinkageStruct RasLinkageStructW
#else
#define RasLinkageStruct RasLinkageStructA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\setacl.h ===
//+----------------------------------------------------------------------------
//
// File:    setacl.h
//
// Module:  CMCONTBL.LIB
//
// Synopsis: Security/SID/ACL stuff for CM
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  09-Mar-2000 SumitC  Created
//
//-----------------------------------------------------------------------------

BOOL SetAclPerms(PACL * pAcl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\shelldll.h ===
//+----------------------------------------------------------------------------
//
// File:     shelldll.h
//
// Module:   CMMON32.EXE and CMDIAL32.DLL
//
// Synopsis: Definition of CShellDll, a shell32.dll wrapper.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun   Created    01/12/98
//
//+----------------------------------------------------------------------------
#ifndef SHELLDLL_H
#define SHELLDLL_H

#include <windows.h>
#include <shlobj.h>

//
// the following is to circumvent the NT 5.0 windows.h
//
#ifdef  WIN32_LEAN_AND_MEAN
#include <shellapi.h>
#endif

//+---------------------------------------------------------------------------
//
//	class CShellDll
//
//	Description: A class to dynamic load/unload shell32.dll to reduce the 
//               workingset under win95
//
//	History:	fengsun	Created		1/12/98
//
//----------------------------------------------------------------------------
class CShellDll
{
public:
    CShellDll(BOOL fKeepDllLoaded = FALSE);
    ~CShellDll();

    BOOL Load(); // can call even if loaded
    void Unload(); // can call even if not loaded
    BOOL IsLoaded();

    // For ShellExecuteEx
    BOOL ExecuteEx(LPSHELLEXECUTEINFO lpExecInfo);

    // For ShellNotifyIcon
    BOOL NotifyIcon(DWORD dwMessage, PNOTIFYICONDATA pnid ); 

    HRESULT ShellGetSpecialFolderLocation(HWND, int, LPITEMIDLIST *);
    BOOL ShellGetPathFromIDList(LPCITEMIDLIST, LPTSTR);
    HRESULT ShellGetMalloc(LPMALLOC * ppMalloc);

    //
    //  These three types and the associated function pointers were made public
    //  so that they could be passed to GetUsersApplicationDataDir.  Because of
    //  name decoration, passing the classes wrappers doesn't work.
    //
    typedef HRESULT (WINAPI* SHGetSpecialFolderLocationSpec)(HWND, int, LPITEMIDLIST *);
    typedef BOOL (WINAPI* SHGetPathFromIDListSpec)(LPCITEMIDLIST, LPTSTR);
    typedef HRESULT (WINAPI* SHGetMallocSpec)(LPMALLOC * ppMalloc);

    SHGetSpecialFolderLocationSpec m_pfnSHGetSpecialFolderLocation;
    SHGetPathFromIDListSpec m_pfnSHGetPathFromIDList;
    SHGetMallocSpec m_pfnSHGetMalloc;

protected:
    typedef BOOL  (WINAPI *SHELLEXECUTEEXPROC)(LPSHELLEXECUTEINFOW lpExecInfo);
    typedef BOOL (WINAPI *SHELL_NOTIFYICONPROC)(DWORD dwMessage, PNOTIFYICONDATAW pnid ); 

    HINSTANCE m_hInstShell;
    BOOL m_KeepDllLoaded;

    SHELLEXECUTEEXPROC m_fnShellExecuteEx;
    SHELL_NOTIFYICONPROC m_fnShell_NotifyIcon;
};

inline BOOL CShellDll::ExecuteEx(LPSHELLEXECUTEINFOW lpExecInfo)
{
    if (!Load())
    {
        return FALSE;
    }

    return m_fnShellExecuteEx(lpExecInfo);
}

inline BOOL CShellDll::NotifyIcon(DWORD dwMessage, PNOTIFYICONDATAW pnid )
{
    if (!Load())
    {
        return FALSE;
    }

    BOOL fRet = m_fnShell_NotifyIcon(dwMessage,pnid);

    return fRet;
}

inline BOOL CShellDll::IsLoaded()
{
    return m_hInstShell != NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\ras2.h ===
/* Copyright (c) 1992-1998 Microsoft Corporation
**
** ras.h
** Remote Access external API
** Public header for external API clients
**
** WINVER values in this file:
**      WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
**      WINVER = 0x400 = Windows 95, Windows NT SUR (default)
**      WINVER > 0x400 = Windows NT SUR enhancements
*/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#include <pshpack4.h>

/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4


DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );


#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
					  
#ifdef __cplusplus
}
#endif

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\struct.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
// STRUCT.H - global data structures that need to go through thunk layers
//

//	HISTORY:
//	
//	11/20/94	jeremys		Created.
//  96/03/11  markdu    Added fDisallowTCPInstall and fDisallowRNAInstall.
//            These are used to prevent installing the components, and
//            since we want to allow the installation by default, setting
//            the structure to zeros gives default behaviour with these flags.
//  96/03/12  markdu    Removed nModems since we enumerate modems
//            with RNA now.
//

// Note: this structure is separated out from the main global inc file
// because #define's and other valid C syntax aren't valid for the thunk
// compiler, which just needs the structure.

// structure to hold information about client software configuration
typedef struct tagCLIENTCONFIG {
	BOOL fTcpip;			// TCP/IP currently installed

	BOOL fNetcard;			// net card installed
	BOOL fNetcardBoundTCP;	// TCP/IP bound to net card

	BOOL fPPPDriver;		// PPP driver installed
	BOOL fPPPBoundTCP;		// TCP/IP bound to PPP driver

	BOOL fMailInstalled;	// microsoft mail (exchange) files installed
	BOOL fRNAInstalled;		// RNA (remote access) files installed
	BOOL fMSNInstalled;		// Microsoft network files installed
	BOOL fMSN105Installed;	// MSN 1.05 (Rome) files installed
	BOOL fInetMailInstalled;	// Internet mail (rt. 66) files installed
  BOOL fDisallowTCPInstall; // Do not allow TCP/IP to be installed
  BOOL fDisallowRNAInstall; // Do not allow RNA to be installed
} CLIENTCONFIG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\tapi.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

The  Telephony  API  is jointly copyrighted by Intel and Microsoft.  You are
granted  a royalty free worldwide, unlimited license to make copies, and use
the   API/SPI  for  making  applications/drivers  that  interface  with  the
specification provided that this paragraph and the Intel/Microsoft copyright
statement is maintained as is in the text and source code files.

Copyright 1995-96 Microsoft, all rights reserved.
Portions copyright 1992, 1993 Intel/Microsoft, all rights reserved.

Module Name:

    tapi.h

Notes:

    Additions to the Telephony Application Programming Interface (TAPI) since
    version 1.0 are noted by version number (e.g. "TAPI v1.4").

--*/

#ifndef TAPI_H
#define TAPI_H



//
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//
// To build  a TAPI 1.4 application put a define as below in your source
// file before you include TAPI.H:
//
// #define TAPI_CURRENT_VERSION 0x00010004
//
//
#ifndef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00020000
#endif

#include <windows.h>

#pragma pack(1)
// Type definitions of the data types used in tapi

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//
// TAPI type definitions
//

#define DECLARE_OPAQUE32(name)  struct name##__ { int unused; }; \
                typedef const struct name##__ FAR* name

DECLARE_OPAQUE32(HCALL);
typedef HCALL FAR * LPHCALL;

DECLARE_OPAQUE32(HLINE);
typedef HLINE FAR * LPHLINE;

DECLARE_OPAQUE32(HPHONE);
typedef HPHONE FAR * LPHPHONE;

DECLARE_OPAQUE32(HLINEAPP);
typedef HLINEAPP FAR * LPHLINEAPP;

DECLARE_OPAQUE32(HPHONEAPP);
typedef HPHONEAPP FAR * LPHPHONEAPP;

typedef HICON FAR * LPHICON;

typedef void (CALLBACK * LINECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD               dwInstance,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );

typedef void (CALLBACK * PHONECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD               dwInstance,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );


// Messages for Phones and Lines

#define LINE_ADDRESSSTATE                       0L
#define LINE_CALLINFO                           1L
#define LINE_CALLSTATE                          2L
#define LINE_CLOSE                              3L
#define LINE_DEVSPECIFIC                        4L
#define LINE_DEVSPECIFICFEATURE                 5L
#define LINE_GATHERDIGITS                       6L
#define LINE_GENERATE                           7L
#define LINE_LINEDEVSTATE                       8L
#define LINE_MONITORDIGITS                      9L
#define LINE_MONITORMEDIA                       10L
#define LINE_MONITORTONE                        11L
#define LINE_REPLY                              12L
#define LINE_REQUEST                            13L
#define PHONE_BUTTON                            14L
#define PHONE_CLOSE                             15L
#define PHONE_DEVSPECIFIC                       16L
#define PHONE_REPLY                             17L
#define PHONE_STATE                             18L
#define LINE_CREATE                             19L             // TAPI v1.4
#define PHONE_CREATE                            20L             // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINE_AGENTSPECIFIC                      21L             // TAPI v2.0
#define LINE_AGENTSTATUS                        22L             // TAPI v2.0
#define LINE_APPNEWCALL                         23L             // TAPI v2.0
#define LINE_PROXYREQUEST                       24L             // TAPI v2.0
#define LINE_REMOVE                             25L             // TAPI v2.0
#define PHONE_REMOVE                            26L             // TAPI v2.0
#endif


#define INITIALIZE_NEGOTIATION                  0xFFFFFFFFL

#define LINEADDRCAPFLAGS_FWDNUMRINGS            0x00000001
#define LINEADDRCAPFLAGS_PICKUPGROUPID          0x00000002
#define LINEADDRCAPFLAGS_SECURE                 0x00000004
#define LINEADDRCAPFLAGS_BLOCKIDDEFAULT         0x00000008
#define LINEADDRCAPFLAGS_BLOCKIDOVERRIDE        0x00000010
#define LINEADDRCAPFLAGS_DIALED                 0x00000020
#define LINEADDRCAPFLAGS_ORIGOFFHOOK            0x00000040
#define LINEADDRCAPFLAGS_DESTOFFHOOK            0x00000080
#define LINEADDRCAPFLAGS_FWDCONSULT             0x00000100
#define LINEADDRCAPFLAGS_SETUPCONFNULL          0x00000200
#define LINEADDRCAPFLAGS_AUTORECONNECT          0x00000400
#define LINEADDRCAPFLAGS_COMPLETIONID           0x00000800
#define LINEADDRCAPFLAGS_TRANSFERHELD           0x00001000
#define LINEADDRCAPFLAGS_TRANSFERMAKE           0x00002000
#define LINEADDRCAPFLAGS_CONFERENCEHELD         0x00004000
#define LINEADDRCAPFLAGS_CONFERENCEMAKE         0x00008000
#define LINEADDRCAPFLAGS_PARTIALDIAL            0x00010000
#define LINEADDRCAPFLAGS_FWDSTATUSVALID         0x00020000
#define LINEADDRCAPFLAGS_FWDINTEXTADDR          0x00040000
#define LINEADDRCAPFLAGS_FWDBUSYNAADDR          0x00080000
#define LINEADDRCAPFLAGS_ACCEPTTOALERT          0x00100000
#define LINEADDRCAPFLAGS_CONFDROP               0x00200000
#define LINEADDRCAPFLAGS_PICKUPCALLWAIT         0x00400000
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRCAPFLAGS_PREDICTIVEDIALER       0x00800000      // TAPI v2.0
#define LINEADDRCAPFLAGS_QUEUE                  0x01000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_ROUTEPOINT             0x02000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_HOLDMAKESNEW           0x04000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOINTERNALCALLS        0x08000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOEXTERNALCALLS        0x10000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_SETCALLINGID           0x20000000      // TAPI v2.0
#endif

#define LINEADDRESSMODE_ADDRESSID               0x00000001
#define LINEADDRESSMODE_DIALABLEADDR            0x00000002

#define LINEADDRESSSHARING_PRIVATE              0x00000001
#define LINEADDRESSSHARING_BRIDGEDEXCL          0x00000002
#define LINEADDRESSSHARING_BRIDGEDNEW           0x00000004
#define LINEADDRESSSHARING_BRIDGEDSHARED        0x00000008
#define LINEADDRESSSHARING_MONITORED            0x00000010

#define LINEADDRESSSTATE_OTHER                  0x00000001
#define LINEADDRESSSTATE_DEVSPECIFIC            0x00000002
#define LINEADDRESSSTATE_INUSEZERO              0x00000004
#define LINEADDRESSSTATE_INUSEONE               0x00000008
#define LINEADDRESSSTATE_INUSEMANY              0x00000010
#define LINEADDRESSSTATE_NUMCALLS               0x00000020
#define LINEADDRESSSTATE_FORWARD                0x00000040
#define LINEADDRESSSTATE_TERMINALS              0x00000080
#define LINEADDRESSSTATE_CAPSCHANGE             0x00000100      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRESSSTATE_AGENT                  0x00000200      // TAPI v2.0
#define LINEADDRESSSTATE_AGENTSTATE             0x00000400      // TAPI v2.0
#define LINEADDRESSSTATE_AGENTACTIVITY          0x00000800      // TAPI v2.0
#endif

#define LINEADDRFEATURE_FORWARD                 0x00000001
#define LINEADDRFEATURE_MAKECALL                0x00000002
#define LINEADDRFEATURE_PICKUP                  0x00000004
#define LINEADDRFEATURE_SETMEDIACONTROL         0x00000008
#define LINEADDRFEATURE_SETTERMINAL             0x00000010
#define LINEADDRFEATURE_SETUPCONF               0x00000020
#define LINEADDRFEATURE_UNCOMPLETECALL          0x00000040
#define LINEADDRFEATURE_UNPARK                  0x00000080
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRFEATURE_PICKUPHELD              0x00000100      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPGROUP             0x00000200      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPDIRECT            0x00000400      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPWAITING           0x00000800      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDFWD              0x00001000      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDDND              0x00002000      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEAGENTFEATURE_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTACTIVITY       0x00000004      // TAPI v2.0
#define LINEAGENTFEATURE_AGENTSPECIFIC          0x00000008      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTACTIVITYLIST   0x00000010      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTGROUP          0x00000020      // TAPI v2.0

#define LINEAGENTSTATE_LOGGEDOFF                0x00000001      // TAPI v2.0
#define LINEAGENTSTATE_NOTREADY                 0x00000002      // TAPI v2.0
#define LINEAGENTSTATE_READY                    0x00000004      // TAPI v2.0
#define LINEAGENTSTATE_BUSYACD                  0x00000008      // TAPI v2.0
#define LINEAGENTSTATE_BUSYINCOMING             0x00000010      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOUTBOUND             0x00000020      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOTHER                0x00000040      // TAPI v2.0
#define LINEAGENTSTATE_WORKINGAFTERCALL         0x00000080      // TAPI v2.0
#define LINEAGENTSTATE_UNKNOWN                  0x00000100      // TAPI v2.0
#define LINEAGENTSTATE_UNAVAIL                  0x00000200      // TAPI v2.0

#define LINEAGENTSTATUS_GROUP                   0x00000001      // TAPI v2.0
#define LINEAGENTSTATUS_STATE                   0x00000002      // TAPI v2.0
#define LINEAGENTSTATUS_NEXTSTATE               0x00000004      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITY                0x00000008      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITYLIST            0x00000010      // TAPI v2.0
#define LINEAGENTSTATUS_GROUPLIST               0x00000020      // TAPI v2.0
#define LINEAGENTSTATUS_CAPSCHANGE              0x00000040      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDSTATES             0x00000080      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDNEXTSTATES         0x00000100      // TAPI v2.0
#endif


#define LINEANSWERMODE_NONE                     0x00000001
#define LINEANSWERMODE_DROP                     0x00000002
#define LINEANSWERMODE_HOLD                     0x00000004

#define LINEBEARERMODE_VOICE                    0x00000001
#define LINEBEARERMODE_SPEECH                   0x00000002
#define LINEBEARERMODE_MULTIUSE                 0x00000004
#define LINEBEARERMODE_DATA                     0x00000008
#define LINEBEARERMODE_ALTSPEECHDATA            0x00000010
#define LINEBEARERMODE_NONCALLSIGNALING         0x00000020
#define LINEBEARERMODE_PASSTHROUGH              0x00000040      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEBEARERMODE_RESTRICTEDDATA           0x00000080      // TAPI v2.0
#endif

#define LINEBUSYMODE_STATION                    0x00000001
#define LINEBUSYMODE_TRUNK                      0x00000002
#define LINEBUSYMODE_UNKNOWN                    0x00000004
#define LINEBUSYMODE_UNAVAIL                    0x00000008

#define LINECALLCOMPLCOND_BUSY                  0x00000001
#define LINECALLCOMPLCOND_NOANSWER              0x00000002

#define LINECALLCOMPLMODE_CAMPON                0x00000001
#define LINECALLCOMPLMODE_CALLBACK              0x00000002
#define LINECALLCOMPLMODE_INTRUDE               0x00000004
#define LINECALLCOMPLMODE_MESSAGE               0x00000008

#define LINECALLFEATURE_ACCEPT                  0x00000001
#define LINECALLFEATURE_ADDTOCONF               0x00000002
#define LINECALLFEATURE_ANSWER                  0x00000004
#define LINECALLFEATURE_BLINDTRANSFER           0x00000008
#define LINECALLFEATURE_COMPLETECALL            0x00000010
#define LINECALLFEATURE_COMPLETETRANSF          0x00000020
#define LINECALLFEATURE_DIAL                    0x00000040
#define LINECALLFEATURE_DROP                    0x00000080
#define LINECALLFEATURE_GATHERDIGITS            0x00000100
#define LINECALLFEATURE_GENERATEDIGITS          0x00000200
#define LINECALLFEATURE_GENERATETONE            0x00000400
#define LINECALLFEATURE_HOLD                    0x00000800
#define LINECALLFEATURE_MONITORDIGITS           0x00001000
#define LINECALLFEATURE_MONITORMEDIA            0x00002000
#define LINECALLFEATURE_MONITORTONES            0x00004000
#define LINECALLFEATURE_PARK                    0x00008000
#define LINECALLFEATURE_PREPAREADDCONF          0x00010000
#define LINECALLFEATURE_REDIRECT                0x00020000
#define LINECALLFEATURE_REMOVEFROMCONF          0x00040000
#define LINECALLFEATURE_SECURECALL              0x00080000
#define LINECALLFEATURE_SENDUSERUSER            0x00100000
#define LINECALLFEATURE_SETCALLPARAMS           0x00200000
#define LINECALLFEATURE_SETMEDIACONTROL         0x00400000
#define LINECALLFEATURE_SETTERMINAL             0x00800000
#define LINECALLFEATURE_SETUPCONF               0x01000000
#define LINECALLFEATURE_SETUPTRANSFER           0x02000000
#define LINECALLFEATURE_SWAPHOLD                0x04000000
#define LINECALLFEATURE_UNHOLD                  0x08000000
#define LINECALLFEATURE_RELEASEUSERUSERINFO     0x10000000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE_SETTREATMENT            0x20000000      // TAPI v2.0
#define LINECALLFEATURE_SETQOS                  0x40000000      // TAPI v2.0
#define LINECALLFEATURE_SETCALLDATA             0x80000000      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE2_NOHOLDCONFERENCE       0x00000001      // TAPI v2.0
#define LINECALLFEATURE2_ONESTEPTRANSFER        0x00000002      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCAMPON            0x00000004      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCALLBACK          0x00000008      // TAPI v2.0
#define LINECALLFEATURE2_COMPLINTRUDE           0x00000010      // TAPI v2.0
#define LINECALLFEATURE2_COMPLMESSAGE           0x00000020      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERNORM           0x00000040      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERCONF           0x00000080      // TAPI v2.0
#define LINECALLFEATURE2_PARKDIRECT             0x00000100      // TAPI v2.0
#define LINECALLFEATURE2_PARKNONDIRECT          0x00000200      // TAPI v2.0
#endif

#define LINECALLINFOSTATE_OTHER                 0x00000001
#define LINECALLINFOSTATE_DEVSPECIFIC           0x00000002
#define LINECALLINFOSTATE_BEARERMODE            0x00000004
#define LINECALLINFOSTATE_RATE                  0x00000008
#define LINECALLINFOSTATE_MEDIAMODE             0x00000010
#define LINECALLINFOSTATE_APPSPECIFIC           0x00000020
#define LINECALLINFOSTATE_CALLID                0x00000040
#define LINECALLINFOSTATE_RELATEDCALLID         0x00000080
#define LINECALLINFOSTATE_ORIGIN                0x00000100
#define LINECALLINFOSTATE_REASON                0x00000200
#define LINECALLINFOSTATE_COMPLETIONID          0x00000400
#define LINECALLINFOSTATE_NUMOWNERINCR          0x00000800
#define LINECALLINFOSTATE_NUMOWNERDECR          0x00001000
#define LINECALLINFOSTATE_NUMMONITORS           0x00002000
#define LINECALLINFOSTATE_TRUNK                 0x00004000
#define LINECALLINFOSTATE_CALLERID              0x00008000
#define LINECALLINFOSTATE_CALLEDID              0x00010000
#define LINECALLINFOSTATE_CONNECTEDID           0x00020000
#define LINECALLINFOSTATE_REDIRECTIONID         0x00040000
#define LINECALLINFOSTATE_REDIRECTINGID         0x00080000
#define LINECALLINFOSTATE_DISPLAY               0x00100000
#define LINECALLINFOSTATE_USERUSERINFO          0x00200000
#define LINECALLINFOSTATE_HIGHLEVELCOMP         0x00400000
#define LINECALLINFOSTATE_LOWLEVELCOMP          0x00800000
#define LINECALLINFOSTATE_CHARGINGINFO          0x01000000
#define LINECALLINFOSTATE_TERMINAL              0x02000000
#define LINECALLINFOSTATE_DIALPARAMS            0x04000000
#define LINECALLINFOSTATE_MONITORMODES          0x08000000
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLINFOSTATE_TREATMENT             0x10000000      // TAPI v2.0
#define LINECALLINFOSTATE_QOS                   0x20000000      // TAPI v2.0
#define LINECALLINFOSTATE_CALLDATA              0x40000000      // TAPI v2.0
#endif

#define LINECALLORIGIN_OUTBOUND                 0x00000001
#define LINECALLORIGIN_INTERNAL                 0x00000002
#define LINECALLORIGIN_EXTERNAL                 0x00000004
#define LINECALLORIGIN_UNKNOWN                  0x00000010
#define LINECALLORIGIN_UNAVAIL                  0x00000020
#define LINECALLORIGIN_CONFERENCE               0x00000040
#define LINECALLORIGIN_INBOUND                  0x00000080      // TAPI v1.4

#define LINECALLPARAMFLAGS_SECURE               0x00000001
#define LINECALLPARAMFLAGS_IDLE                 0x00000002
#define LINECALLPARAMFLAGS_BLOCKID              0x00000004
#define LINECALLPARAMFLAGS_ORIGOFFHOOK          0x00000008
#define LINECALLPARAMFLAGS_DESTOFFHOOK          0x00000010
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLPARAMFLAGS_NOHOLDCONFERENCE     0x00000020      // TAPI v2.0
#define LINECALLPARAMFLAGS_PREDICTIVEDIAL       0x00000040      // TAPI v2.0
#define LINECALLPARAMFLAGS_ONESTEPTRANSFER      0x00000080      // TAPI v2.0
#endif

#define LINECALLPARTYID_BLOCKED                 0x00000001
#define LINECALLPARTYID_OUTOFAREA               0x00000002
#define LINECALLPARTYID_NAME                    0x00000004
#define LINECALLPARTYID_ADDRESS                 0x00000008
#define LINECALLPARTYID_PARTIAL                 0x00000010
#define LINECALLPARTYID_UNKNOWN                 0x00000020
#define LINECALLPARTYID_UNAVAIL                 0x00000040

#define LINECALLPRIVILEGE_NONE                  0x00000001
#define LINECALLPRIVILEGE_MONITOR               0x00000002
#define LINECALLPRIVILEGE_OWNER                 0x00000004

#define LINECALLREASON_DIRECT                   0x00000001
#define LINECALLREASON_FWDBUSY                  0x00000002
#define LINECALLREASON_FWDNOANSWER              0x00000004
#define LINECALLREASON_FWDUNCOND                0x00000008
#define LINECALLREASON_PICKUP                   0x00000010
#define LINECALLREASON_UNPARK                   0x00000020
#define LINECALLREASON_REDIRECT                 0x00000040
#define LINECALLREASON_CALLCOMPLETION           0x00000080
#define LINECALLREASON_TRANSFER                 0x00000100
#define LINECALLREASON_REMINDER                 0x00000200
#define LINECALLREASON_UNKNOWN                  0x00000400
#define LINECALLREASON_UNAVAIL                  0x00000800
#define LINECALLREASON_INTRUDE                  0x00001000      // TAPI v1.4
#define LINECALLREASON_PARKED                   0x00002000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLREASON_CAMPEDON                 0x00004000      // TAPI v2.0
#define LINECALLREASON_ROUTEREQUEST             0x00008000      // TAPI v2.0
#endif

#define LINECALLSELECT_LINE                     0x00000001
#define LINECALLSELECT_ADDRESS                  0x00000002
#define LINECALLSELECT_CALL                     0x00000004

#define LINECALLSTATE_IDLE                      0x00000001
#define LINECALLSTATE_OFFERING                  0x00000002
#define LINECALLSTATE_ACCEPTED                  0x00000004
#define LINECALLSTATE_DIALTONE                  0x00000008
#define LINECALLSTATE_DIALING                   0x00000010
#define LINECALLSTATE_RINGBACK                  0x00000020
#define LINECALLSTATE_BUSY                      0x00000040
#define LINECALLSTATE_SPECIALINFO               0x00000080
#define LINECALLSTATE_CONNECTED                 0x00000100
#define LINECALLSTATE_PROCEEDING                0x00000200
#define LINECALLSTATE_ONHOLD                    0x00000400
#define LINECALLSTATE_CONFERENCED               0x00000800
#define LINECALLSTATE_ONHOLDPENDCONF            0x00001000
#define LINECALLSTATE_ONHOLDPENDTRANSFER        0x00002000
#define LINECALLSTATE_DISCONNECTED              0x00004000
#define LINECALLSTATE_UNKNOWN                   0x00008000

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLTREATMENT_SILENCE               0x00000001      // TAPI v2.0
#define LINECALLTREATMENT_RINGBACK              0x00000002      // TAPI v2.0
#define LINECALLTREATMENT_BUSY                  0x00000003      // TAPI v2.0
#define LINECALLTREATMENT_MUSIC                 0x00000004      // TAPI v2.0
#endif

#define LINECARDOPTION_PREDEFINED               0x00000001      // TAPI v1.4
#define LINECARDOPTION_HIDDEN                   0x00000002      // TAPI v1.4

#define LINECONNECTEDMODE_ACTIVE                0x00000001      // TAPI v1.4
#define LINECONNECTEDMODE_INACTIVE              0x00000002      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECONNECTEDMODE_ACTIVEHELD            0x00000004      // TAPI v2.0
#define LINECONNECTEDMODE_INACTIVEHELD          0x00000008      // TAPI v2.0
#define LINECONNECTEDMODE_CONFIRMED             0x00000010      // TAPI v2.0
#endif

#define LINEDEVCAPFLAGS_CROSSADDRCONF           0x00000001
#define LINEDEVCAPFLAGS_HIGHLEVCOMP             0x00000002
#define LINEDEVCAPFLAGS_LOWLEVCOMP              0x00000004
#define LINEDEVCAPFLAGS_MEDIACONTROL            0x00000008
#define LINEDEVCAPFLAGS_MULTIPLEADDR            0x00000010
#define LINEDEVCAPFLAGS_CLOSEDROP               0x00000020
#define LINEDEVCAPFLAGS_DIALBILLING             0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET               0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE            0x00000100

#define LINEDEVSTATE_OTHER                      0x00000001
#define LINEDEVSTATE_RINGING                    0x00000002
#define LINEDEVSTATE_CONNECTED                  0x00000004
#define LINEDEVSTATE_DISCONNECTED               0x00000008
#define LINEDEVSTATE_MSGWAITON                  0x00000010
#define LINEDEVSTATE_MSGWAITOFF                 0x00000020
#define LINEDEVSTATE_INSERVICE                  0x00000040
#define LINEDEVSTATE_OUTOFSERVICE               0x00000080
#define LINEDEVSTATE_MAINTENANCE                0x00000100
#define LINEDEVSTATE_OPEN                       0x00000200
#define LINEDEVSTATE_CLOSE                      0x00000400
#define LINEDEVSTATE_NUMCALLS                   0x00000800
#define LINEDEVSTATE_NUMCOMPLETIONS             0x00001000
#define LINEDEVSTATE_TERMINALS                  0x00002000
#define LINEDEVSTATE_ROAMMODE                   0x00004000
#define LINEDEVSTATE_BATTERY                    0x00008000
#define LINEDEVSTATE_SIGNAL                     0x00010000
#define LINEDEVSTATE_DEVSPECIFIC                0x00020000
#define LINEDEVSTATE_REINIT                     0x00040000
#define LINEDEVSTATE_LOCK                       0x00080000
#define LINEDEVSTATE_CAPSCHANGE                 0x00100000      // TAPI v1.4
#define LINEDEVSTATE_CONFIGCHANGE               0x00200000      // TAPI v1.4
#define LINEDEVSTATE_TRANSLATECHANGE            0x00400000      // TAPI v1.4
#define LINEDEVSTATE_COMPLCANCEL                0x00800000      // TAPI v1.4
#define LINEDEVSTATE_REMOVED                    0x01000000      // TAPI v1.4

#define LINEDEVSTATUSFLAGS_CONNECTED            0x00000001
#define LINEDEVSTATUSFLAGS_MSGWAIT              0x00000002
#define LINEDEVSTATUSFLAGS_INSERVICE            0x00000004
#define LINEDEVSTATUSFLAGS_LOCKED               0x00000008

#define LINEDIALTONEMODE_NORMAL                 0x00000001
#define LINEDIALTONEMODE_SPECIAL                0x00000002
#define LINEDIALTONEMODE_INTERNAL               0x00000004
#define LINEDIALTONEMODE_EXTERNAL               0x00000008
#define LINEDIALTONEMODE_UNKNOWN                0x00000010
#define LINEDIALTONEMODE_UNAVAIL                0x00000020
    
#define LINEDIGITMODE_PULSE                     0x00000001
#define LINEDIGITMODE_DTMF                      0x00000002
#define LINEDIGITMODE_DTMFEND                   0x00000004
    
#define LINEDISCONNECTMODE_NORMAL               0x00000001
#define LINEDISCONNECTMODE_UNKNOWN              0x00000002
#define LINEDISCONNECTMODE_REJECT               0x00000004
#define LINEDISCONNECTMODE_PICKUP               0x00000008
#define LINEDISCONNECTMODE_FORWARDED            0x00000010
#define LINEDISCONNECTMODE_BUSY                 0x00000020
#define LINEDISCONNECTMODE_NOANSWER             0x00000040
#define LINEDISCONNECTMODE_BADADDRESS           0x00000080
#define LINEDISCONNECTMODE_UNREACHABLE          0x00000100
#define LINEDISCONNECTMODE_CONGESTION           0x00000200
#define LINEDISCONNECTMODE_INCOMPATIBLE         0x00000400
#define LINEDISCONNECTMODE_UNAVAIL              0x00000800
#define LINEDISCONNECTMODE_NODIALTONE           0x00001000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEDISCONNECTMODE_NUMBERCHANGED        0x00002000      // TAPI v2.0
#define LINEDISCONNECTMODE_OUTOFORDER           0x00004000      // TAPI v2.0
#define LINEDISCONNECTMODE_TEMPFAILURE          0x00008000      // TAPI v2.0
#define LINEDISCONNECTMODE_QOSUNAVAIL           0x00010000      // TAPI v2.0
#define LINEDISCONNECTMODE_BLOCKED              0x00020000      // TAPI v2.0
#define LINEDISCONNECTMODE_DONOTDISTURB         0x00040000      // TAPI v2.0
#endif

#define LINEERR_ALLOCATED                       0x80000001
#define LINEERR_BADDEVICEID                     0x80000002
#define LINEERR_BEARERMODEUNAVAIL               0x80000003
#define LINEERR_CALLUNAVAIL                     0x80000005
#define LINEERR_COMPLETIONOVERRUN               0x80000006
#define LINEERR_CONFERENCEFULL                  0x80000007
#define LINEERR_DIALBILLING                     0x80000008
#define LINEERR_DIALDIALTONE                    0x80000009
#define LINEERR_DIALPROMPT                      0x8000000A
#define LINEERR_DIALQUIET                       0x8000000B
#define LINEERR_INCOMPATIBLEAPIVERSION          0x8000000C
#define LINEERR_INCOMPATIBLEEXTVERSION          0x8000000D
#define LINEERR_INIFILECORRUPT                  0x8000000E
#define LINEERR_INUSE                           0x8000000F
#define LINEERR_INVALADDRESS                    0x80000010
#define LINEERR_INVALADDRESSID                  0x80000011
#define LINEERR_INVALADDRESSMODE                0x80000012
#define LINEERR_INVALADDRESSSTATE               0x80000013
#define LINEERR_INVALAPPHANDLE                  0x80000014
#define LINEERR_INVALAPPNAME                    0x80000015
#define LINEERR_INVALBEARERMODE                 0x80000016
#define LINEERR_INVALCALLCOMPLMODE              0x80000017
#define LINEERR_INVALCALLHANDLE                 0x80000018
#define LINEERR_INVALCALLPARAMS                 0x80000019
#define LINEERR_INVALCALLPRIVILEGE              0x8000001A
#define LINEERR_INVALCALLSELECT                 0x8000001B
#define LINEERR_INVALCALLSTATE                  0x8000001C
#define LINEERR_INVALCALLSTATELIST              0x8000001D
#define LINEERR_INVALCARD                       0x8000001E
#define LINEERR_INVALCOMPLETIONID               0x8000001F
#define LINEERR_INVALCONFCALLHANDLE             0x80000020
#define LINEERR_INVALCONSULTCALLHANDLE          0x80000021
#define LINEERR_INVALCOUNTRYCODE                0x80000022
#define LINEERR_INVALDEVICECLASS                0x80000023
#define LINEERR_INVALDEVICEHANDLE               0x80000024
#define LINEERR_INVALDIALPARAMS                 0x80000025
#define LINEERR_INVALDIGITLIST                  0x80000026
#define LINEERR_INVALDIGITMODE                  0x80000027
#define LINEERR_INVALDIGITS                     0x80000028
#define LINEERR_INVALEXTVERSION                 0x80000029
#define LINEERR_INVALGROUPID                    0x8000002A
#define LINEERR_INVALLINEHANDLE                 0x8000002B
#define LINEERR_INVALLINESTATE                  0x8000002C
#define LINEERR_INVALLOCATION                   0x8000002D
#define LINEERR_INVALMEDIALIST                  0x8000002E
#define LINEERR_INVALMEDIAMODE                  0x8000002F
#define LINEERR_INVALMESSAGEID                  0x80000030
#define LINEERR_INVALPARAM                      0x80000032
#define LINEERR_INVALPARKID                     0x80000033
#define LINEERR_INVALPARKMODE                   0x80000034
#define LINEERR_INVALPOINTER                    0x80000035
#define LINEERR_INVALPRIVSELECT                 0x80000036
#define LINEERR_INVALRATE                       0x80000037
#define LINEERR_INVALREQUESTMODE                0x80000038
#define LINEERR_INVALTERMINALID                 0x80000039
#define LINEERR_INVALTERMINALMODE               0x8000003A
#define LINEERR_INVALTIMEOUT                    0x8000003B
#define LINEERR_INVALTONE                       0x8000003C
#define LINEERR_INVALTONELIST                   0x8000003D
#define LINEERR_INVALTONEMODE                   0x8000003E
#define LINEERR_INVALTRANSFERMODE               0x8000003F
#define LINEERR_LINEMAPPERFAILED                0x80000040
#define LINEERR_NOCONFERENCE                    0x80000041
#define LINEERR_NODEVICE                        0x80000042
#define LINEERR_NODRIVER                        0x80000043
#define LINEERR_NOMEM                           0x80000044
#define LINEERR_NOREQUEST                       0x80000045
#define LINEERR_NOTOWNER                        0x80000046
#define LINEERR_NOTREGISTERED                   0x80000047
#define LINEERR_OPERATIONFAILED                 0x80000048
#define LINEERR_OPERATIONUNAVAIL                0x80000049
#define LINEERR_RATEUNAVAIL                     0x8000004A
#define LINEERR_RESOURCEUNAVAIL                 0x8000004B
#define LINEERR_REQUESTOVERRUN                  0x8000004C
#define LINEERR_STRUCTURETOOSMALL               0x8000004D
#define LINEERR_TARGETNOTFOUND                  0x8000004E
#define LINEERR_TARGETSELF                      0x8000004F
#define LINEERR_UNINITIALIZED                   0x80000050
#define LINEERR_USERUSERINFOTOOBIG              0x80000051
#define LINEERR_REINIT                          0x80000052
#define LINEERR_ADDRESSBLOCKED                  0x80000053
#define LINEERR_BILLINGREJECTED                 0x80000054
#define LINEERR_INVALFEATURE                    0x80000055
#define LINEERR_NOMULTIPLEINSTANCE              0x80000056
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEERR_INVALAGENTID                    0x80000057      // TAPI v2.0
#define LINEERR_INVALAGENTGROUP                 0x80000058      // TAPI v2.0
#define LINEERR_INVALPASSWORD                   0x80000059      // TAPI v2.0
#define LINEERR_INVALAGENTSTATE                 0x8000005A      // TAPI v2.0
#define LINEERR_INVALAGENTACTIVITY              0x8000005B      // TAPI v2.0
#define LINEERR_DIALVOICEDETECT                 0x8000005C      // TAPI v2.0
#endif

#define LINEFEATURE_DEVSPECIFIC                 0x00000001
#define LINEFEATURE_DEVSPECIFICFEAT             0x00000002
#define LINEFEATURE_FORWARD                     0x00000004
#define LINEFEATURE_MAKECALL                    0x00000008
#define LINEFEATURE_SETMEDIACONTROL             0x00000010
#define LINEFEATURE_SETTERMINAL                 0x00000020
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEFEATURE_SETDEVSTATUS                0x00000040      // TAPI v2.0
#define LINEFEATURE_FORWARDFWD                  0x00000080      // TAPI v2.0
#define LINEFEATURE_FORWARDDND                  0x00000100      // TAPI v2.0
#endif

#define LINEFORWARDMODE_UNCOND                  0x00000001
#define LINEFORWARDMODE_UNCONDINTERNAL          0x00000002
#define LINEFORWARDMODE_UNCONDEXTERNAL          0x00000004
#define LINEFORWARDMODE_UNCONDSPECIFIC          0x00000008
#define LINEFORWARDMODE_BUSY                    0x00000010
#define LINEFORWARDMODE_BUSYINTERNAL            0x00000020
#define LINEFORWARDMODE_BUSYEXTERNAL            0x00000040
#define LINEFORWARDMODE_BUSYSPECIFIC            0x00000080
#define LINEFORWARDMODE_NOANSW                  0x00000100
#define LINEFORWARDMODE_NOANSWINTERNAL          0x00000200
#define LINEFORWARDMODE_NOANSWEXTERNAL          0x00000400
#define LINEFORWARDMODE_NOANSWSPECIFIC          0x00000800
#define LINEFORWARDMODE_BUSYNA                  0x00001000
#define LINEFORWARDMODE_BUSYNAINTERNAL          0x00002000
#define LINEFORWARDMODE_BUSYNAEXTERNAL          0x00004000
#define LINEFORWARDMODE_BUSYNASPECIFIC          0x00008000
#define LINEFORWARDMODE_UNKNOWN                 0x00010000      // TAPI v1.4
#define LINEFORWARDMODE_UNAVAIL                 0x00020000      // TAPI v1.4

#define LINEGATHERTERM_BUFFERFULL               0x00000001
#define LINEGATHERTERM_TERMDIGIT                0x00000002
#define LINEGATHERTERM_FIRSTTIMEOUT             0x00000004
#define LINEGATHERTERM_INTERTIMEOUT             0x00000008
#define LINEGATHERTERM_CANCEL                   0x00000010

#define LINEGENERATETERM_DONE                   0x00000001
#define LINEGENERATETERM_CANCEL                 0x00000002

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEINITIALIZEEXOPTION_USEHIDDENWINDOW      0x00000001  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USEEVENT             0x00000002  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USECOMPLETIONPORT    0x00000004  // TAPI v2.0
#endif

#define LINELOCATIONOPTION_PULSEDIAL            0x00000001      // TAPI v1.4

#define LINEMAPPER                              0xFFFFFFFF

#define LINEMEDIACONTROL_NONE                   0x00000001
#define LINEMEDIACONTROL_START                  0x00000002
#define LINEMEDIACONTROL_RESET                  0x00000004
#define LINEMEDIACONTROL_PAUSE                  0x00000008
#define LINEMEDIACONTROL_RESUME                 0x00000010
#define LINEMEDIACONTROL_RATEUP                 0x00000020
#define LINEMEDIACONTROL_RATEDOWN               0x00000040
#define LINEMEDIACONTROL_RATENORMAL             0x00000080
#define LINEMEDIACONTROL_VOLUMEUP               0x00000100
#define LINEMEDIACONTROL_VOLUMEDOWN             0x00000200
#define LINEMEDIACONTROL_VOLUMENORMAL           0x00000400

#define LINEMEDIAMODE_UNKNOWN                   0x00000002
#define LINEMEDIAMODE_INTERACTIVEVOICE          0x00000004
#define LINEMEDIAMODE_AUTOMATEDVOICE            0x00000008
#define LINEMEDIAMODE_DATAMODEM                 0x00000010
#define LINEMEDIAMODE_G3FAX                     0x00000020
#define LINEMEDIAMODE_TDD                       0x00000040
#define LINEMEDIAMODE_G4FAX                     0x00000080
#define LINEMEDIAMODE_DIGITALDATA               0x00000100
#define LINEMEDIAMODE_TELETEX                   0x00000200
#define LINEMEDIAMODE_VIDEOTEX                  0x00000400
#define LINEMEDIAMODE_TELEX                     0x00000800
#define LINEMEDIAMODE_MIXED                     0x00001000
#define LINEMEDIAMODE_ADSI                      0x00002000
#define LINEMEDIAMODE_VOICEVIEW                 0x00004000      // TAPI v1.4
#define LAST_LINEMEDIAMODE                      0x00004000

#define LINEOFFERINGMODE_ACTIVE                 0x00000001      // TAPI v1.4
#define LINEOFFERINGMODE_INACTIVE               0x00000002      // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEOPENOPTION_SINGLEADDRESS            0x80000000      // TAPI v2.0
#define LINEOPENOPTION_PROXY                    0x40000000      // TAPI v2.0
#endif

#define LINEPARKMODE_DIRECTED                   0x00000001
#define LINEPARKMODE_NONDIRECTED                0x00000002

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEPROXYREQUEST_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTACTIVITY       0x00000003      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTCAPS           0x00000004      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTSTATUS         0x00000005      // TAPI v2.0
#define LINEPROXYREQUEST_AGENTSPECIFIC          0x00000006      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTACTIVITYLIST   0x00000007      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTGROUPLIST      0x00000008      // TAPI v2.0
#endif

#define LINEREMOVEFROMCONF_NONE                 0x00000001
#define LINEREMOVEFROMCONF_LAST                 0x00000002
#define LINEREMOVEFROMCONF_ANY                  0x00000003

#define LINEREQUESTMODE_MAKECALL                0x00000001
#define LINEREQUESTMODE_MEDIACALL               0x00000002
#define LINEREQUESTMODE_DROP                    0x00000004
#define LAST_LINEREQUESTMODE                    LINEREQUESTMODE_MEDIACALL

#define LINEROAMMODE_UNKNOWN                    0x00000001
#define LINEROAMMODE_UNAVAIL                    0x00000002
#define LINEROAMMODE_HOME                       0x00000004
#define LINEROAMMODE_ROAMA                      0x00000008
#define LINEROAMMODE_ROAMB                      0x00000010

#define LINESPECIALINFO_NOCIRCUIT               0x00000001
#define LINESPECIALINFO_CUSTIRREG               0x00000002
#define LINESPECIALINFO_REORDER                 0x00000004
#define LINESPECIALINFO_UNKNOWN                 0x00000008
#define LINESPECIALINFO_UNAVAIL                 0x00000010

#define LINETERMDEV_PHONE                       0x00000001
#define LINETERMDEV_HEADSET                     0x00000002
#define LINETERMDEV_SPEAKER                     0x00000004

#define LINETERMMODE_BUTTONS                    0x00000001
#define LINETERMMODE_LAMPS                      0x00000002
#define LINETERMMODE_DISPLAY                    0x00000004
#define LINETERMMODE_RINGER                     0x00000008
#define LINETERMMODE_HOOKSWITCH                 0x00000010
#define LINETERMMODE_MEDIATOLINE                0x00000020
#define LINETERMMODE_MEDIAFROMLINE              0x00000040
#define LINETERMMODE_MEDIABIDIRECT              0x00000080

#define LINETERMSHARING_PRIVATE                 0x00000001
#define LINETERMSHARING_SHAREDEXCL              0x00000002
#define LINETERMSHARING_SHAREDCONF              0x00000004

#define LINETOLLLISTOPTION_ADD                  0x00000001
#define LINETOLLLISTOPTION_REMOVE               0x00000002

#define LINETONEMODE_CUSTOM                     0x00000001
#define LINETONEMODE_RINGBACK                   0x00000002
#define LINETONEMODE_BUSY                       0x00000004
#define LINETONEMODE_BEEP                       0x00000008
#define LINETONEMODE_BILLING                    0x00000010

#define LINETRANSFERMODE_TRANSFER               0x00000001
#define LINETRANSFERMODE_CONFERENCE             0x00000002

#define LINETRANSLATEOPTION_CARDOVERRIDE        0x00000001
#define LINETRANSLATEOPTION_CANCELCALLWAITING   0x00000002      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELOCAL          0x00000004      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELD             0x00000008      // TAPI v1.4

#define LINETRANSLATERESULT_CANONICAL           0x00000001
#define LINETRANSLATERESULT_INTERNATIONAL       0x00000002
#define LINETRANSLATERESULT_LONGDISTANCE        0x00000004
#define LINETRANSLATERESULT_LOCAL               0x00000008
#define LINETRANSLATERESULT_INTOLLLIST          0x00000010
#define LINETRANSLATERESULT_NOTINTOLLLIST       0x00000020
#define LINETRANSLATERESULT_DIALBILLING         0x00000040
#define LINETRANSLATERESULT_DIALQUIET           0x00000080
#define LINETRANSLATERESULT_DIALDIALTONE        0x00000100
#define LINETRANSLATERESULT_DIALPROMPT          0x00000200
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINETRANSLATERESULT_VOICEDETECT         0x00000400      // TAPI v2.0
#endif

#define PHONEBUTTONFUNCTION_UNKNOWN             0x00000000
#define PHONEBUTTONFUNCTION_CONFERENCE          0x00000001
#define PHONEBUTTONFUNCTION_TRANSFER            0x00000002
#define PHONEBUTTONFUNCTION_DROP                0x00000003
#define PHONEBUTTONFUNCTION_HOLD                0x00000004
#define PHONEBUTTONFUNCTION_RECALL              0x00000005
#define PHONEBUTTONFUNCTION_DISCONNECT          0x00000006
#define PHONEBUTTONFUNCTION_CONNECT             0x00000007
#define PHONEBUTTONFUNCTION_MSGWAITON           0x00000008
#define PHONEBUTTONFUNCTION_MSGWAITOFF          0x00000009
#define PHONEBUTTONFUNCTION_SELECTRING          0x0000000A
#define PHONEBUTTONFUNCTION_ABBREVDIAL          0x0000000B
#define PHONEBUTTONFUNCTION_FORWARD             0x0000000C
#define PHONEBUTTONFUNCTION_PICKUP              0x0000000D
#define PHONEBUTTONFUNCTION_RINGAGAIN           0x0000000E
#define PHONEBUTTONFUNCTION_PARK                0x0000000F
#define PHONEBUTTONFUNCTION_REJECT              0x00000010
#define PHONEBUTTONFUNCTION_REDIRECT            0x00000011
#define PHONEBUTTONFUNCTION_MUTE                0x00000012
#define PHONEBUTTONFUNCTION_VOLUMEUP            0x00000013
#define PHONEBUTTONFUNCTION_VOLUMEDOWN          0x00000014
#define PHONEBUTTONFUNCTION_SPEAKERON           0x00000015
#define PHONEBUTTONFUNCTION_SPEAKEROFF          0x00000016
#define PHONEBUTTONFUNCTION_FLASH               0x00000017
#define PHONEBUTTONFUNCTION_DATAON              0x00000018
#define PHONEBUTTONFUNCTION_DATAOFF             0x00000019
#define PHONEBUTTONFUNCTION_DONOTDISTURB        0x0000001A
#define PHONEBUTTONFUNCTION_INTERCOM            0x0000001B
#define PHONEBUTTONFUNCTION_BRIDGEDAPP          0x0000001C
#define PHONEBUTTONFUNCTION_BUSY                0x0000001D
#define PHONEBUTTONFUNCTION_CALLAPP             0x0000001E
#define PHONEBUTTONFUNCTION_DATETIME            0x0000001F
#define PHONEBUTTONFUNCTION_DIRECTORY           0x00000020
#define PHONEBUTTONFUNCTION_COVER               0x00000021
#define PHONEBUTTONFUNCTION_CALLID              0x00000022
#define PHONEBUTTONFUNCTION_LASTNUM             0x00000023
#define PHONEBUTTONFUNCTION_NIGHTSRV            0x00000024
#define PHONEBUTTONFUNCTION_SENDCALLS           0x00000025
#define PHONEBUTTONFUNCTION_MSGINDICATOR        0x00000026
#define PHONEBUTTONFUNCTION_REPDIAL             0x00000027
#define PHONEBUTTONFUNCTION_SETREPDIAL          0x00000028
#define PHONEBUTTONFUNCTION_SYSTEMSPEED         0x00000029
#define PHONEBUTTONFUNCTION_STATIONSPEED        0x0000002A
#define PHONEBUTTONFUNCTION_CAMPON              0x0000002B
#define PHONEBUTTONFUNCTION_SAVEREPEAT          0x0000002C
#define PHONEBUTTONFUNCTION_QUEUECALL           0x0000002D
#define PHONEBUTTONFUNCTION_NONE                0x0000002E

#define PHONEBUTTONMODE_DUMMY                   0x00000001
#define PHONEBUTTONMODE_CALL                    0x00000002
#define PHONEBUTTONMODE_FEATURE                 0x00000004
#define PHONEBUTTONMODE_KEYPAD                  0x00000008
#define PHONEBUTTONMODE_LOCAL                   0x00000010
#define PHONEBUTTONMODE_DISPLAY                 0x00000020

#define PHONEBUTTONSTATE_UP                     0x00000001
#define PHONEBUTTONSTATE_DOWN                   0x00000002
#define PHONEBUTTONSTATE_UNKNOWN                0x00000004      // TAPI v1.4
#define PHONEBUTTONSTATE_UNAVAIL                0x00000008      // TAPI v1.4

#define PHONEERR_ALLOCATED                      0x90000001
#define PHONEERR_BADDEVICEID                    0x90000002
#define PHONEERR_INCOMPATIBLEAPIVERSION         0x90000003
#define PHONEERR_INCOMPATIBLEEXTVERSION         0x90000004
#define PHONEERR_INIFILECORRUPT                 0x90000005
#define PHONEERR_INUSE                          0x90000006
#define PHONEERR_INVALAPPHANDLE                 0x90000007
#define PHONEERR_INVALAPPNAME                   0x90000008
#define PHONEERR_INVALBUTTONLAMPID              0x90000009
#define PHONEERR_INVALBUTTONMODE                0x9000000A
#define PHONEERR_INVALBUTTONSTATE               0x9000000B
#define PHONEERR_INVALDATAID                    0x9000000C
#define PHONEERR_INVALDEVICECLASS               0x9000000D
#define PHONEERR_INVALEXTVERSION                0x9000000E
#define PHONEERR_INVALHOOKSWITCHDEV             0x9000000F
#define PHONEERR_INVALHOOKSWITCHMODE            0x90000010
#define PHONEERR_INVALLAMPMODE                  0x90000011
#define PHONEERR_INVALPARAM                     0x90000012
#define PHONEERR_INVALPHONEHANDLE               0x90000013
#define PHONEERR_INVALPHONESTATE                0x90000014
#define PHONEERR_INVALPOINTER                   0x90000015
#define PHONEERR_INVALPRIVILEGE                 0x90000016
#define PHONEERR_INVALRINGMODE                  0x90000017
#define PHONEERR_NODEVICE                       0x90000018
#define PHONEERR_NODRIVER                       0x90000019
#define PHONEERR_NOMEM                          0x9000001A
#define PHONEERR_NOTOWNER                       0x9000001B
#define PHONEERR_OPERATIONFAILED                0x9000001C
#define PHONEERR_OPERATIONUNAVAIL               0x9000001D
#define PHONEERR_RESOURCEUNAVAIL                0x9000001F
#define PHONEERR_REQUESTOVERRUN                 0x90000020
#define PHONEERR_STRUCTURETOOSMALL              0x90000021
#define PHONEERR_UNINITIALIZED                  0x90000022
#define PHONEERR_REINIT                         0x90000023

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define PHONEFEATURE_GETBUTTONINFO              0x00000001      // TAPI v2.0
#define PHONEFEATURE_GETDATA                    0x00000002      // TAPI v2.0
#define PHONEFEATURE_GETDISPLAY                 0x00000004      // TAPI v2.0
#define PHONEFEATURE_GETGAINHANDSET             0x00000008      // TAPI v2.0
#define PHONEFEATURE_GETGAINSPEAKER             0x00000010      // TAPI v2.0
#define PHONEFEATURE_GETGAINHEADSET             0x00000020      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHANDSET       0x00000040      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHSPEAKER       0x00000080      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHEADSET       0x00000100      // TAPI v2.0
#define PHONEFEATURE_GETLAMP                    0x00000200      // TAPI v2.0
#define PHONEFEATURE_GETRING                    0x00000400      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHANDSET           0x00000800      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMESPEAKER           0x00001000      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHEADSET           0x00002000      // TAPI v2.0
#define PHONEFEATURE_SETBUTTONINFO              0x00004000      // TAPI v2.0
#define PHONEFEATURE_SETDATA                    0x00008000      // TAPI v2.0
#define PHONEFEATURE_SETDISPLAY                 0x00010000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHANDSET             0x00020000      // TAPI v2.0
#define PHONEFEATURE_SETGAINSPEAKER             0x00040000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHEADSET             0x00080000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHANDSET       0x00100000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHSPEAKER       0x00200000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHEADSET       0x00400000      // TAPI v2.0
#define PHONEFEATURE_SETLAMP                    0x00800000      // TAPI v2.0
#define PHONEFEATURE_SETRING                    0x01000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHANDSET           0x02000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMESPEAKER           0x04000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHEADSET           0x08000000      // TAPI v2.0
#endif

#define PHONEHOOKSWITCHDEV_HANDSET              0x00000001
#define PHONEHOOKSWITCHDEV_SPEAKER              0x00000002
#define PHONEHOOKSWITCHDEV_HEADSET              0x00000004

#define PHONEHOOKSWITCHMODE_ONHOOK              0x00000001
#define PHONEHOOKSWITCHMODE_MIC                 0x00000002
#define PHONEHOOKSWITCHMODE_SPEAKER             0x00000004
#define PHONEHOOKSWITCHMODE_MICSPEAKER          0x00000008
#define PHONEHOOKSWITCHMODE_UNKNOWN             0x00000010

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW     0x00000001  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USEEVENT            0x00000002  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT   0x00000004  // TAPI v2.0
#endif

#define PHONELAMPMODE_DUMMY                     0x00000001
#define PHONELAMPMODE_OFF                       0x00000002
#define PHONELAMPMODE_STEADY                    0x00000004
#define PHONELAMPMODE_WINK                      0x00000008
#define PHONELAMPMODE_FLASH                     0x00000010
#define PHONELAMPMODE_FLUTTER                   0x00000020
#define PHONELAMPMODE_BROKENFLUTTER             0x00000040
#define PHONELAMPMODE_UNKNOWN                   0x00000080

#define PHONEPRIVILEGE_MONITOR                  0x00000001
#define PHONEPRIVILEGE_OWNER                    0x00000002

#define PHONESTATE_OTHER                        0x00000001
#define PHONESTATE_CONNECTED                    0x00000002
#define PHONESTATE_DISCONNECTED                 0x00000004
#define PHONESTATE_OWNER                        0x00000008
#define PHONESTATE_MONITORS                     0x00000010
#define PHONESTATE_DISPLAY                      0x00000020
#define PHONESTATE_LAMP                         0x00000040
#define PHONESTATE_RINGMODE                     0x00000080
#define PHONESTATE_RINGVOLUME                   0x00000100
#define PHONESTATE_HANDSETHOOKSWITCH            0x00000200
#define PHONESTATE_HANDSETVOLUME                0x00000400
#define PHONESTATE_HANDSETGAIN                  0x00000800
#define PHONESTATE_SPEAKERHOOKSWITCH            0x00001000
#define PHONESTATE_SPEAKERVOLUME                0x00002000
#define PHONESTATE_SPEAKERGAIN                  0x00004000
#define PHONESTATE_HEADSETHOOKSWITCH            0x00008000
#define PHONESTATE_HEADSETVOLUME                0x00010000
#define PHONESTATE_HEADSETGAIN                  0x00020000
#define PHONESTATE_SUSPEND                      0x00040000
#define PHONESTATE_RESUME                       0x00080000
#define PHONESTATE_DEVSPECIFIC                  0x00100000
#define PHONESTATE_REINIT                       0x00200000
#define PHONESTATE_CAPSCHANGE                   0x00400000      // TAPI v1.4
#define PHONESTATE_REMOVED                      0x00800000      // TAPI v1.4

#define PHONESTATUSFLAGS_CONNECTED              0x00000001
#define PHONESTATUSFLAGS_SUSPENDED              0x00000002

#define STRINGFORMAT_ASCII                      0x00000001
#define STRINGFORMAT_DBCS                       0x00000002
#define STRINGFORMAT_UNICODE                    0x00000003
#define STRINGFORMAT_BINARY                     0x00000004

#define TAPI_REPLY                              WM_USER + 99

#define TAPIERR_CONNECTED                       0L
#define TAPIERR_DROPPED                         -1L
#define TAPIERR_NOREQUESTRECIPIENT              -2L
#define TAPIERR_REQUESTQUEUEFULL                -3L
#define TAPIERR_INVALDESTADDRESS                -4L
#define TAPIERR_INVALWINDOWHANDLE               -5L
#define TAPIERR_INVALDEVICECLASS                -6L
#define TAPIERR_INVALDEVICEID                   -7L
#define TAPIERR_DEVICECLASSUNAVAIL              -8L
#define TAPIERR_DEVICEIDUNAVAIL                 -9L
#define TAPIERR_DEVICEINUSE                     -10L
#define TAPIERR_DESTBUSY                        -11L
#define TAPIERR_DESTNOANSWER                    -12L
#define TAPIERR_DESTUNAVAIL                     -13L
#define TAPIERR_UNKNOWNWINHANDLE                -14L
#define TAPIERR_UNKNOWNREQUESTID                -15L
#define TAPIERR_REQUESTFAILED                   -16L
#define TAPIERR_REQUESTCANCELLED                -17L
#define TAPIERR_INVALPOINTER                    -18L

#define TAPIMAXDESTADDRESSSIZE                  80L
#define TAPIMAXAPPNAMESIZE                      40L
#define TAPIMAXCALLEDPARTYSIZE                  40L
#define TAPIMAXCOMMENTSIZE                      80L
#define TAPIMAXDEVICECLASSSIZE                  40L
#define TAPIMAXDEVICEIDSIZE                     40L



typedef struct lineaddresscaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressSize;
    DWORD       dwAddressOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;
    DWORD       dwAddressSharing;
    DWORD       dwAddressStates;
    DWORD       dwCallInfoStates;
    DWORD       dwCallerIDFlags;
    DWORD       dwCalledIDFlags;
    DWORD       dwConnectedIDFlags;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwCallStates;
    DWORD       dwDialToneModes;
    DWORD       dwBusyModes;
    DWORD       dwSpecialInfo;
    DWORD       dwDisconnectModes;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwMaxNumOnHoldCalls;
    DWORD       dwMaxNumOnHoldPendingCalls;
    DWORD       dwMaxNumConference;
    DWORD       dwMaxNumTransConf;
    DWORD       dwAddrCapFlags;
    DWORD       dwCallFeatures;
    DWORD       dwRemoveFromConfCaps;
    DWORD       dwRemoveFromConfState;
    DWORD       dwTransferModes;
    DWORD       dwParkModes;
    DWORD       dwForwardModes;
    DWORD       dwMaxForwardEntries;
    DWORD       dwMaxSpecificEntries;
    DWORD       dwMinFwdNumRings;
    DWORD       dwMaxFwdNumRings;
    DWORD       dwMaxCallCompletions;
    DWORD       dwCallCompletionConds;
    DWORD       dwCallCompletionModes;
    DWORD       dwNumCompletionMessages;
    DWORD       dwCompletionMsgTextEntrySize;
    DWORD       dwCompletionMsgTextSize;
    DWORD       dwCompletionMsgTextOffset;

    DWORD       dwAddressFeatures;                              // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwNumCallTreatments;                            // TAPI v2.0
    DWORD       dwCallTreatmentListSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentListOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwMaxCallDataSize;                              // TAPI v2.0
    DWORD       dwCallFeatures2;                                // TAPI v2.0
    DWORD       dwMaxNoAnswerTimeout;                           // TAPI v2.0
    DWORD       dwConnectedModes;                               // TAPI v2.0
    DWORD       dwOfferingModes;                                // TAPI v2.0
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
#endif

} LINEADDRESSCAPS, FAR *LPLINEADDRESSCAPS;

typedef struct lineaddressstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumInUse;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwAddressFeatures;
    DWORD       dwNumRingsNoAnswer;
    DWORD       dwForwardNumEntries;
    DWORD       dwForwardSize;
    DWORD       dwForwardOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

} LINEADDRESSSTATUS, FAR *LPLINEADDRESSSTATUS;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineagentactivityentry_tag
{
    DWORD       dwID;                                           // TAPI v2.0
    DWORD       dwNameSize;                                     // TAPI v2.0
    DWORD       dwNameOffset;                                   // TAPI v2.0

} LINEAGENTACTIVITYENTRY, *LPLINEAGENTACTIVITYENTRY;

typedef struct lineagentactivitylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwListSize;                                     // TAPI v2.0
    DWORD       dwListOffset;                                   // TAPI v2.0

} LINEAGENTACTIVITYLIST, *LPLINEAGENTACTIVITYLIST;

typedef struct lineagentcaps_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwAgentHandlerInfoSize;                         // TAPI v2.0
    DWORD       dwAgentHandlerInfoOffset;                       // TAPI v2.0
    DWORD       dwCapsVersion;                                  // TAPI v2.0
    DWORD       dwFeatures;                                     // TAPI v2.0
    DWORD       dwStates;                                       // TAPI v2.0
    DWORD       dwNextStates;                                   // TAPI v2.0
    DWORD       dwMaxNumGroupEntries;                           // TAPI v2.0
    DWORD       dwAgentStatusMessages;                          // TAPI v2.0
    DWORD       dwNumAgentExtensionIDs;                         // TAPI v2.0
    DWORD       dwAgentExtensionIDListSize;                     // TAPI v2.0
    DWORD       dwAgentExtensionIDListOffset;                   // TAPI v2.0

} LINEAGENTCAPS, *LPLINEAGENTCAPS;

typedef struct lineagentgroupentry_tag
{
    struct
    {
        DWORD   dwGroupID1;                                     // TAPI v2.0
        DWORD   dwGroupID2;                                     // TAPI v2.0
        DWORD   dwGroupID3;                                     // TAPI v2.0
        DWORD   dwGroupID4;                                     // TAPI v2.0

    } GroupID;

    DWORD       dwNameSize;                                     // TAPI v2.0
    DWORD       dwNameOffset;                                   // TAPI v2.0

} LINEAGENTGROUPENTRY, *LPLINEAGENTGROUPENTRY;

typedef struct lineagentgrouplist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwListSize;                                     // TAPI v2.0
    DWORD       dwListOffset;                                   // TAPI v2.0

} LINEAGENTGROUPLIST, *LPLINEAGENTGROUPLIST;

typedef struct lineagentstatus_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwGroupListSize;                                // TAPI v2.0
    DWORD       dwGroupListOffset;                              // TAPI v2.0
    DWORD       dwState;                                        // TAPI v2.0
    DWORD       dwNextState;                                    // TAPI v2.0
    DWORD       dwActivityID;                                   // TAPI v2.0
    DWORD       dwActivitySize;                                 // TAPI v2.0
    DWORD       dwActivityOffset;                               // TAPI v2.0
    DWORD       dwAgentFeatures;                                // TAPI v2.0
    DWORD       dwValidStates;                                  // TAPI v2.0
    DWORD       dwValidNextStates;                              // TAPI v2.0

} LINEAGENTSTATUS, *LPLINEAGENTSTATUS;

typedef struct lineappinfo_tag
{
    DWORD       dwMachineNameSize;                              // TAPI v2.0
    DWORD       dwMachineNameOffset;                            // TAPI v2.0
    DWORD       dwUserNameSize;                                 // TAPI v2.0
    DWORD       dwUserNameOffset;                               // TAPI v2.0
    DWORD       dwModuleFilenameSize;                           // TAPI v2.0
    DWORD       dwModuleFilenameOffset;                         // TAPI v2.0
    DWORD       dwFriendlyNameSize;                             // TAPI v2.0
    DWORD       dwFriendlyNameOffset;                           // TAPI v2.0
    DWORD       dwMediaModes;                                   // TAPI v2.0
    DWORD       dwAddressID;                                    // TAPI v2.0

} LINEAPPINFO, *LPLINEAPPINFO;
#endif


typedef struct linedialparams_tag
{
    DWORD       dwDialPause;
    DWORD       dwDialSpeed;
    DWORD       dwDigitDuration;
    DWORD       dwWaitForDialtone;

} LINEDIALPARAMS, FAR *LPLINEDIALPARAMS;

typedef struct linecallinfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    HLINE       hLine;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressID;
    DWORD       dwBearerMode;
    DWORD       dwRate;
    DWORD       dwMediaMode;
    DWORD       dwAppSpecific;
    DWORD       dwCallID;
    DWORD       dwRelatedCallID;
    DWORD       dwCallParamFlags;
    DWORD       dwCallStates;
    DWORD       dwMonitorDigitModes;
    DWORD       dwMonitorMediaModes;
    LINEDIALPARAMS  DialParams;
    DWORD       dwOrigin;
    DWORD       dwReason;
    DWORD       dwCompletionID;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwCountryCode;
    DWORD       dwTrunk;
    DWORD       dwCallerIDFlags;
    DWORD       dwCallerIDSize;
    DWORD       dwCallerIDOffset;
    DWORD       dwCallerIDNameSize;
    DWORD       dwCallerIDNameOffset;
    DWORD       dwCalledIDFlags;
    DWORD       dwCalledIDSize;
    DWORD       dwCalledIDOffset;
    DWORD       dwCalledIDNameSize;
    DWORD       dwCalledIDNameOffset;
    DWORD       dwConnectedIDFlags;
    DWORD       dwConnectedIDSize;
    DWORD       dwConnectedIDOffset;
    DWORD       dwConnectedIDNameSize;
    DWORD       dwConnectedIDNameOffset;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectionIDSize;
    DWORD       dwRedirectionIDOffset;
    DWORD       dwRedirectionIDNameSize;
    DWORD       dwRedirectionIDNameOffset;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwRedirectingIDSize;
    DWORD       dwRedirectingIDOffset;
    DWORD       dwRedirectingIDNameSize;
    DWORD       dwRedirectingIDNameOffset;
    DWORD       dwAppNameSize;
    DWORD       dwAppNameOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;
    DWORD       dwCommentOffset;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwUserUserInfoSize;
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;
    DWORD       dwLowLevelCompOffset;
    DWORD       dwChargingInfoSize;
    DWORD       dwChargingInfoOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwCallTreatment;                                // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
#endif

} LINECALLINFO, FAR *LPLINECALLINFO;

typedef struct linecalllist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallsNumEntries;
    DWORD       dwCallsSize;
    DWORD       dwCallsOffset;

} LINECALLLIST, FAR *LPLINECALLLIST;

typedef struct linecallparams_tag               // Defaults:
{
    DWORD       dwTotalSize;                    // ---------
    DWORD       dwBearerMode;                   // voice
    DWORD       dwMinRate;                      // (3.1kHz)
    DWORD       dwMaxRate;                      // (3.1kHz)
    DWORD       dwMediaMode;                    // interactiveVoice
    DWORD       dwCallParamFlags;               // 0
    DWORD       dwAddressMode;                  // addressID
    DWORD       dwAddressID;                    // (any available)
    LINEDIALPARAMS  DialParams;                 // (0, 0, 0, 0)
    DWORD       dwOrigAddressSize;              // 0
    DWORD       dwOrigAddressOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;              // 0
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;                  // 0
    DWORD       dwCommentOffset;
    DWORD       dwUserUserInfoSize;             // 0
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;            // 0
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;             // 0
    DWORD       dwLowLevelCompOffset;
    DWORD       dwDevSpecificSize;              // 0
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwTargetAddressSize;                            // TAPI v2.0
    DWORD       dwTargetAddressOffset;                          // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassSize;                              // TAPI v2.0
    DWORD       dwDeviceClassOffset;                            // TAPI v2.0
    DWORD       dwDeviceConfigSize;                             // TAPI v2.0
    DWORD       dwDeviceConfigOffset;                           // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwNoAnswerTimeout;                              // TAPI v2.0
    DWORD       dwCallingPartyIDSize;                           // TAPI v2.0
    DWORD       dwCallingPartyIDOffset;                         // TAPI v2.0
#endif

} LINECALLPARAMS, FAR *LPLINECALLPARAMS;

typedef struct linecallstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallState;
    DWORD       dwCallStateMode;
    DWORD       dwCallPrivilege;
    DWORD       dwCallFeatures;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwCallFeatures2;                                // TAPI v2.0
#if WIN32
    SYSTEMTIME  tStateEntryTime;                                // TAPI v2.0
#else
    WORD        tStateEntryTime[8];                             // TAPI v2.0
#endif
#endif

} LINECALLSTATUS, FAR *LPLINECALLSTATUS;


#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linecalltreatmententry_tag
{
    DWORD       dwCallTreatmentID;                              // TAPI v2.0
    DWORD       dwCallTreatmentNameSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentNameOffset;                      // TAPI v2.0

} LINECALLTREATMENTENTRY, FAR *LPLINECALLTREATMENTENTRY;
#endif


typedef struct linecardentry_tag
{
    DWORD       dwPermanentCardID;
    DWORD       dwCardNameSize;
    DWORD       dwCardNameOffset;
    DWORD       dwCardNumberDigits;                             // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4

} LINECARDENTRY, FAR *LPLINECARDENTRY;

typedef struct linecountryentry_tag
{
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwCountryCode;                                  // TAPI v1.4
    DWORD       dwNextCountryID;                                // TAPI v1.4
    DWORD       dwCountryNameSize;                              // TAPI v1.4
    DWORD       dwCountryNameOffset;                            // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4

} LINECOUNTRYENTRY, FAR *LPLINECOUNTRYENTRY;

typedef struct linecountrylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumCountries;                                 // TAPI v1.4
    DWORD       dwCountryListSize;                              // TAPI v1.4
    DWORD       dwCountryListOffset;                            // TAPI v1.4

} LINECOUNTRYLIST, FAR *LPLINECOUNTRYLIST;

typedef struct linedevcaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwSwitchInfoSize;
    DWORD       dwSwitchInfoOffset;
    DWORD       dwPermanentLineID;
    DWORD       dwLineNameSize;
    DWORD       dwLineNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwAddressModes;
    DWORD       dwNumAddresses;
    DWORD       dwBearerModes;
    DWORD       dwMaxRate;
    DWORD       dwMediaModes;
    DWORD       dwGenerateToneModes;
    DWORD       dwGenerateToneMaxNumFreq;
    DWORD       dwGenerateDigitModes;
    DWORD       dwMonitorToneMaxNumFreq;
    DWORD       dwMonitorToneMaxNumEntries;
    DWORD       dwMonitorDigitModes;
    DWORD       dwGatherDigitsMinTimeout;
    DWORD       dwGatherDigitsMaxTimeout;
    DWORD       dwMedCtlDigitMaxListSize;
    DWORD       dwMedCtlMediaMaxListSize;
    DWORD       dwMedCtlToneMaxListSize;
    DWORD       dwMedCtlCallStateMaxListSize;
    DWORD       dwDevCapFlags;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwAnswerMode;
    DWORD       dwRingModes;
    DWORD       dwLineStates;
    DWORD       dwUUIAcceptSize;
    DWORD       dwUUIAnswerSize;
    DWORD       dwUUIMakeCallSize;
    DWORD       dwUUIDropSize;
    DWORD       dwUUISendUserUserInfoSize;
    DWORD       dwUUICallInfoSize;
    LINEDIALPARAMS  MinDialParams;
    LINEDIALPARAMS  MaxDialParams;
    LINEDIALPARAMS  DefaultDialParams;
    DWORD       dwNumTerminals;
    DWORD       dwTerminalCapsSize;
    DWORD       dwTerminalCapsOffset;
    DWORD       dwTerminalTextEntrySize;
    DWORD       dwTerminalTextSize;
    DWORD       dwTerminalTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwLineFeatures;                                 // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwSettableDevStatus;                            // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
#endif

} LINEDEVCAPS, FAR *LPLINEDEVCAPS;
    
typedef struct linedevstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumOpens;
    DWORD       dwOpenMediaModes;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwLineFeatures;
    DWORD       dwNumCallCompletions;
    DWORD       dwRingMode;
    DWORD       dwSignalLevel;
    DWORD       dwBatteryLevel;
    DWORD       dwRoamMode;
    DWORD       dwDevStatusFlags;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
    DWORD       dwAppInfoSize;                                  // TAPI v2.0
    DWORD       dwAppInfoOffset;                                // TAPI v2.0
#endif

} LINEDEVSTATUS, FAR *LPLINEDEVSTATUS;

typedef struct lineextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} LINEEXTENSIONID, FAR *LPLINEEXTENSIONID;

typedef struct lineforward_tag
{
    DWORD       dwForwardMode;
    DWORD       dwCallerAddressSize;
    DWORD       dwCallerAddressOffset;
    DWORD       dwDestCountryCode;
    DWORD       dwDestAddressSize;
    DWORD       dwDestAddressOffset;

} LINEFORWARD, FAR *LPLINEFORWARD;

typedef struct lineforwardlist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNumEntries;
    LINEFORWARD ForwardList[1];

} LINEFORWARDLIST, FAR *LPLINEFORWARDLIST;

typedef struct linegeneratetone_tag
{
    DWORD       dwFrequency;
    DWORD       dwCadenceOn;
    DWORD       dwCadenceOff;
    DWORD       dwVolume;

} LINEGENERATETONE, FAR *LPLINEGENERATETONE;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} LINEINITIALIZEEXPARAMS, FAR *LPLINEINITIALIZEEXPARAMS;
#endif

typedef struct linelocationentry_tag
{
    DWORD       dwPermanentLocationID;
    DWORD       dwLocationNameSize;
    DWORD       dwLocationNameOffset;
    DWORD       dwCountryCode;
    DWORD       dwCityCodeSize;
    DWORD       dwCityCodeOffset;
    DWORD       dwPreferredCardID;

    DWORD       dwLocalAccessCodeSize;                          // TAPI v1.4
    DWORD       dwLocalAccessCodeOffset;                        // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeSize;                   // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeOffset;                 // TAPI v1.4
    DWORD       dwTollPrefixListSize;                           // TAPI v1.4
    DWORD       dwTollPrefixListOffset;                         // TAPI v1.4
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4
    DWORD       dwCancelCallWaitingSize;                        // TAPI v1.4
    DWORD       dwCancelCallWaitingOffset;                      // TAPI v1.4

} LINELOCATIONENTRY, FAR *LPLINELOCATIONENTRY;

typedef struct linemediacontrolcallstate_tag
{
    DWORD       dwCallStates;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLCALLSTATE, FAR *LPLINEMEDIACONTROLCALLSTATE;

typedef struct linemediacontroldigit_tag
{
    DWORD       dwDigit;
    DWORD       dwDigitModes;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLDIGIT, FAR *LPLINEMEDIACONTROLDIGIT;

typedef struct linemediacontrolmedia_tag
{
    DWORD       dwMediaModes;
    DWORD       dwDuration;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLMEDIA, FAR *LPLINEMEDIACONTROLMEDIA;

typedef struct linemediacontroltone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLTONE, FAR *LPLINEMEDIACONTROLTONE;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD       dwCallbackInstance;                             // TAPI v2.0
    DWORD       dwParam1;                                       // TAPI v2.0
    DWORD       dwParam2;                                       // TAPI v2.0
    DWORD       dwParam3;                                       // TAPI v2.0

} LINEMESSAGE, FAR *LPLINEMESSAGE;
#endif

typedef struct linemonitortone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;

} LINEMONITORTONE, FAR *LPLINEMONITORTONE;

typedef struct lineproviderentry_tag
{
    DWORD       dwPermanentProviderID;                          // TAPI v1.4
    DWORD       dwProviderFilenameSize;                         // TAPI v1.4
    DWORD       dwProviderFilenameOffset;                       // TAPI v1.4

} LINEPROVIDERENTRY, FAR *LPLINEPROVIDERENTRY;

typedef struct lineproviderlist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumProviders;                                 // TAPI v1.4
    DWORD       dwProviderListSize;                             // TAPI v1.4
    DWORD       dwProviderListOffset;                           // TAPI v1.4

} LINEPROVIDERLIST, FAR *LPLINEPROVIDERLIST;


#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineproxyrequest_tag
{
    DWORD       dwSize;                                         // TAPI v2.0
    DWORD       dwClientMachineNameSize;                        // TAPI v2.0
    DWORD       dwClientMachineNameOffset;                      // TAPI v2.0
    DWORD       dwClientUserNameSize;                           // TAPI v2.0
    DWORD       dwClientUserNameOffset;                         // TAPI v2.0
    DWORD       dwClientAppAPIVersion;                          // TAPI v2.0
    DWORD       dwRequestType;                                  // TAPI v2.0

    union
    {
    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.0

    } SetAgentGroup;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwAgentState;                   // TAPI v2.0
        DWORD                   dwNextAgentState;               // TAPI v2.0

    } SetAgentState;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwActivityID;                   // TAPI v2.0

    } SetAgentActivity;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTCAPS           AgentCaps;                      // TAPI v2.0

    } GetAgentCaps;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTSTATUS         AgentStatus;                    // TAPI v2.0

    } GetAgentStatus;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwAgentExtensionIDIndex;        // TAPI v2.0
        DWORD                   dwSize;                         // TAPI v2.0
        BYTE                    Params[1];                      // TAPI v2.0

    } AgentSpecific;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTACTIVITYLIST   ActivityList;                   // TAPI v2.0

    } GetAgentActivityList;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.0

    } GetAgentGroupList;
    }; //ProxyRequestType;

} LINEPROXYREQUEST, *LPLINEPROXYREQUEST;
#endif


typedef struct linereqmakecall_tag
{
    char        szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char        szAppName[TAPIMAXAPPNAMESIZE];
    char        szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char        szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMAKECALL, FAR *LPLINEREQMAKECALL;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linereqmakecallW_tag
{
    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    WCHAR       szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMAKECALLW, FAR *LPLINEREQMAKECALLW;
#endif

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define LINEREQMAKECALL LINEREQMAKECALLW
#endif
#endif

typedef struct linereqmediacall_tag
{
    HWND        hWnd;
    WPARAM      wRequestID;
    char        szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD       dwSize;
    DWORD       dwSecure;
    char        szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char        szAppName[TAPIMAXAPPNAMESIZE];
    char        szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char        szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMEDIACALL, FAR *LPLINEREQMEDIACALL;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linereqmediacallW_tag
{
    HWND        hWnd;
    WPARAM      wRequestID;
    WCHAR       szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD       dwSize;
    DWORD       dwSecure;
    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    WCHAR       szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMEDIACALLW, FAR *LPLINEREQMEDIACALLW;
#endif

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define LINEREQMEDIACALL LINEREQMEDIACALLW
#endif
#endif


typedef struct linetermcaps_tag
{
    DWORD       dwTermDev;
    DWORD       dwTermModes;
    DWORD       dwTermSharing;

} LINETERMCAPS, FAR *LPLINETERMCAPS;

typedef struct linetranslatecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumLocations;
    DWORD       dwLocationListSize;
    DWORD       dwLocationListOffset;
    DWORD       dwCurrentLocationID;
    DWORD       dwNumCards;
    DWORD       dwCardListSize;
    DWORD       dwCardListOffset;
    DWORD       dwCurrentPreferredCardID;

} LINETRANSLATECAPS, FAR *LPLINETRANSLATECAPS;

typedef struct linetranslateoutput_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwDialableStringSize;
    DWORD       dwDialableStringOffset;
    DWORD       dwDisplayableStringSize;
    DWORD       dwDisplayableStringOffset;
    DWORD       dwCurrentCountry;
    DWORD       dwDestCountry;
    DWORD       dwTranslateResults;

} LINETRANSLATEOUTPUT, FAR *LPLINETRANSLATEOUTPUT;

typedef struct phonebuttoninfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwButtonMode;
    DWORD       dwButtonFunction;
    DWORD       dwButtonTextSize;
    DWORD       dwButtonTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwButtonState;                                  // TAPI v1.4

} PHONEBUTTONINFO, FAR *LPPHONEBUTTONINFO;

typedef struct phonecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwPhoneInfoSize;
    DWORD       dwPhoneInfoOffset;
    DWORD       dwPermanentPhoneID;
    DWORD       dwPhoneNameSize;
    DWORD       dwPhoneNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwPhoneStates;
    DWORD       dwHookSwitchDevs;
    DWORD       dwHandsetHookSwitchModes;
    DWORD       dwSpeakerHookSwitchModes;
    DWORD       dwHeadsetHookSwitchModes;
    DWORD       dwVolumeFlags;
    DWORD       dwGainFlags;
    DWORD       dwDisplayNumRows;
    DWORD       dwDisplayNumColumns;
    DWORD       dwNumRingModes;
    DWORD       dwNumButtonLamps;
    DWORD       dwButtonModesSize;
    DWORD       dwButtonModesOffset;
    DWORD       dwButtonFunctionsSize;
    DWORD       dwButtonFunctionsOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwNumSetData;
    DWORD       dwSetDataSize;
    DWORD       dwSetDataOffset;
    DWORD       dwNumGetData;
    DWORD       dwGetDataSize;
    DWORD       dwGetDataOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
    DWORD       dwSettableHandsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableSpeakerHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableHeadsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwMonitoredHandsetHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredSpeakerHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredHeadsetHookSwitchModes;              // TAPI v2.0
#endif

} PHONECAPS, FAR *LPPHONECAPS;

typedef struct phoneextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} PHONEEXTENSIONID, FAR *LPPHONEEXTENSIONID;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct phoneinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} PHONEINITIALIZEEXPARAMS, FAR *LPPHONEINITIALIZEEXPARAMS;

typedef struct phonemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD       dwCallbackInstance;                             // TAPI v2.0
    DWORD       dwParam1;                                       // TAPI v2.0
    DWORD       dwParam2;                                       // TAPI v2.0
    DWORD       dwParam3;                                       // TAPI v2.0

} PHONEMESSAGE, FAR *LPPHONEMESSAGE;
#endif

typedef struct phonestatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStatusFlags;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwRingMode;
    DWORD       dwRingVolume;
    DWORD       dwHandsetHookSwitchMode;
    DWORD       dwHandsetVolume;
    DWORD       dwHandsetGain;
    DWORD       dwSpeakerHookSwitchMode;
    DWORD       dwSpeakerVolume;
    DWORD       dwSpeakerGain;
    DWORD       dwHeadsetHookSwitchMode;
    DWORD       dwHeadsetVolume;
    DWORD       dwHeadsetGain;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwOwnerNameSize;
    DWORD       dwOwnerNameOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
#endif

} PHONESTATUS, FAR *LPPHONESTATUS;

typedef struct varstring_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStringFormat;
    DWORD       dwStringSize;
    DWORD       dwStringOffset;

} VARSTRING, FAR *LPVARSTRING;



LONG
WINAPI
lineAccept(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineAddProvider(                                                // TAPI v1.4
    LPCSTR              lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

#if WIN32
LONG
WINAPI
lineAddProviderW(
    LPCSTR            lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineAddProvider lineAddProviderW
#endif

#define lineAddProviderA lineAddProvider
#endif
#endif


LONG
WINAPI
lineAddToConference(
    HCALL               hConfCall,
    HCALL               hConsultCall
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineAgentSpecific(                                              // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentExtensionIDIndex,
    LPVOID              lpParams,
    DWORD               dwSize
    );
#endif

LONG
WINAPI
lineAnswer(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineBlindTransfer(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineBlindTransferW(
    HCALL               hCall,
    LPCSTR            lpszDestAddressW,
    DWORD               dwCountryCode
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineBlindTransfer lineBlineTransferW
#endif

#define lineBlindTransferA lineBlineTransfer
#endif
#endif


LONG
WINAPI
lineClose(
    HLINE               hLine
    );

LONG
WINAPI
lineCompleteCall(
    HCALL               hCall,
    LPDWORD             lpdwCompletionID,
    DWORD               dwCompletionMode,
    DWORD               dwMessageID
    );

LONG
WINAPI
lineCompleteTransfer(
    HCALL               hCall,
    HCALL               hConsultCall,
    LPHCALL             lphConfCall,
    DWORD               dwTransferMode
    );

LONG
WINAPI
lineConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineConfigDialog lineConfigDialogW
#endif

#define lineConfigDialogA lineConfigDialog
#endif
#endif


LONG
WINAPI
lineConfigDialogEdit(                                           // TAPI v1.4
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

#if WIN32
LONG
WINAPI
lineConfigDialogEditW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR            lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineConfigDialogEdit lineConfigDialogEditW
#endif

#define lineConfigDialogEditA lineConfigDialogEdit
#endif
#endif

LONG
WINAPI
lineConfigProvider(                                             // TAPI v1.4
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
WINAPI
lineDeallocateCall(
    HCALL               hCall
    );

LONG
WINAPI
lineDevSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDevSpecificFeature(
    HLINE               hLine,
    DWORD               dwFeature,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDial(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineDialW(
    HCALL               hCall,
    LPCSTR            lpszDestAddress,
    DWORD               dwCountryCode
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineDial lineDialW
#endif

#define lineDialA lineDial
#endif
#endif

LONG
WINAPI
lineDrop(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineForward(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineForwardW(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineForward lineForwardW
#endif

#define lineForwardA lineForward
#endif
#endif

LONG
WINAPI
lineGatherDigits(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPSTR               lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR              lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

#if WIN32
LONG
WINAPI
lineGatherDigitsW(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPWSTR              lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR            lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGatherDigits lineGatherDigitsW
#endif

#define lineGatherDigitsW lineGatherDigits
#endif
#endif

LONG
WINAPI
lineGenerateDigits(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR              lpszDigits,
    DWORD               dwDuration
    );

#if WIN32
LONG
WINAPI
lineGenerateDigitsW(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR            lpszDigits,
    DWORD               dwDuration
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGenerateDigits lineGenerateDigitsW
#endif

#define lineGenerateDigitsA lineGenerateDigits
#endif
#endif

LONG
WINAPI
lineGenerateTone(
    HCALL               hCall,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    );

LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

#if WIN32
LONG
WINAPI
lineGetAddressCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetAddressCaps lineGetAddressCapsW
#endif

#define lineGetAddressCapsA lineGetAddressCaps
#endif
#endif

LONG
WINAPI
lineGetAddressID(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR              lpsAddress,
    DWORD               dwSize
    );

#if WIN32
LONG
WINAPI
lineGetAddressIDW(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR            lpsAddress,
    DWORD               dwSize
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetAddressID lineGetAddressIDW
#endif

#define lineGetAddressIDA lineGetAddressID
#endif
#endif

LONG
WINAPI
lineGetAddressStatus(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

#if WIN32
LONG
WINAPI
lineGetAddressStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetAddressStatus lineGetAddressStatusW
#endif

#define lineGetAddressStatusA lineGetAddressStatus
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetAgentActivityList(                                       // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    );

LONG
WINAPI
lineGetAgentActivityListW(                                       // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetAgentActivityList lineGetAgentActivityListW
#endif

#define lineGetAgentActivityListA lineGetAgentActivityList
#endif

LONG
WINAPI
lineGetAgentCaps(                                               // TAPI v2.0
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    );

LONG
WINAPI
lineGetAgentGroupList(                                          // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

LONG
WINAPI
lineGetAgentStatus(                                             // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    );
#endif

LONG
WINAPI
lineGetAppPriority(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

#if WIN32
LONG
WINAPI
lineGetAppPriorityW(                                             // TAPI v1.4
    LPCSTR            lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetAppPriority lineGetAppPriorityW
#endif

#define lineGetAppPriorityA lineGetAppPriority
#endif
#endif

LONG
WINAPI
lineGetCallInfo(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

#if WIN32
LONG
WINAPI
lineGetCallInfoW(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetCallInfo lineGetCallInfoW
#endif

#define lineGetCallInfoA lineGetCallInfo
#endif
#endif

LONG
WINAPI
lineGetCallStatus(
    HCALL               hCall,
    LPLINECALLSTATUS    lpCallStatus
    );

LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL               hCall,
    LPLINECALLLIST      lpCallList
    );
    
LONG
WINAPI
lineGetCountry(                                                 // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

#if WIN32
LONG
WINAPI
lineGetCountryW(                                                // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetCountry lineGetCountryW
#endif

#define lineGetCountryA lineGetCountry
#endif
#endif


LONG
WINAPI
lineGetDevCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

#if WIN32
LONG
WINAPI
lineGetDevCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetDevCaps lineGetDevCapsW
#endif

#define lineGetDevCapsA lineGetDevCaps
#endif
#endif

LONG
WINAPI
lineGetDevConfig(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineGetDevConfigW(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetDevConfig lineGetDevConfigW
#endif

#define lineGetDevConfigA lineGetDevConfig
#endif
#endif

LONG
WINAPI
lineGetNewCalls(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwSelect,
    LPLINECALLLIST      lpCallList
    );

LONG
WINAPI
lineGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

#if WIN32
LONG
WINAPI
lineGetIconW(
    DWORD               dwDeviceID,
    LPCSTR            lpszDeviceClass,
    LPHICON             lphIcon
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetIcon lineGetIconW
#endif

#define lineGetIconA lineGetIcon
#endif
#endif
    
LONG
WINAPI
lineGetID(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineGetIDW(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetID lineGetIDW
#endif

#define lineGetIDA lineGetID
#endif
#endif

LONG
WINAPI
lineGetLineDevStatus(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

#if WIN32
LONG
WINAPI
lineGetLineDevStatusW(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetDevStatus lineGetDevStatusW
#endif

#define lineGetDevStatusA lineGetDevStatus
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetMessage(                                                 // TAPI v2.0
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   lpMessage,
    DWORD           dwTimeout
    );
#endif

LONG
WINAPI
lineGetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPDWORD             lpdwNumRings
    );

LONG
WINAPI
lineGetProviderList(                                            // TAPI v1.4
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

#if WIN32
LONG
WINAPI
lineGetProviderListW(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetProviderList lineGetProviderListW
#endif

#define lineGetProviderListA lineGetProviderList
#endif
#endif

LONG
WINAPI
lineGetRequest(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

#if WIN32
LONG
WINAPI
lineGetRequestW(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetRequest lineGetRequestW
#endif

#define lineGetRequestA lineGetRequest
#endif
#endif

LONG
WINAPI
lineGetStatusMessages(
    HLINE               hLine,
    LPDWORD             lpdwLineStates,
    LPDWORD             lpdwAddressStates
    );

LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

#if WIN32
LONG
WINAPI
lineGetTranslateCapsW(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineGetTranslateCaps lineGetTranslateCapsW
#endif

#define lineGetTranslateCapsA lineGetTranslateCaps
#endif
#endif


LONG
WINAPI
lineHandoff(
    HCALL               hCall,
    LPCSTR              lpszFileName,
    DWORD               dwMediaMode
    );

#if WIN32
LONG
WINAPI
lineHandoffW(
    HCALL               hCall,
    LPCSTR            lpszFileName,
    DWORD               dwMediaMode
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineHandoff lineHandoffW
#endif

#define lineHandoffA lineHandoff
#endif
#endif

LONG
WINAPI
lineHold(
    HCALL               hCall
    );

LONG
WINAPI
lineInitialize(
    LPHLINEAPP          lphLineApp,
    HINSTANCE           hInstance,
    LINECALLBACK        lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    );

#if WIN32
LONG
WINAPI
lineInitializeW(
    LPHLINEAPP          lphLineApp,
    HINSTANCE           hInstance,
    LINECALLBACK        lpfnCallback,
    LPCSTR            lpszAppNameW,
    LPDWORD             lpdwNumDevs
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineInitialize lineInitializeW
#endif

#define lineInitializeA lineInitialize
#endif
#endif


#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineInitializeEx(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

LONG
WINAPI
lineInitializeExW(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                    lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

#ifdef UNICODE
#define lineInitializeEx lineInitializeExW
#endif

#define lineInitializeExA lineInitializeEx
#endif


LONG
WINAPI
lineMakeCall(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineMakeCallW(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR            lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineMakeCall lineMakeCallW
#endif

#define lineMakeCallA lineMakeCall
#endif
#endif

LONG
WINAPI
lineMonitorDigits(
    HCALL               hCall,
    DWORD               dwDigitModes
    );

LONG
WINAPI
lineMonitorMedia(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineMonitorTones(
    HCALL               hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    );

LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    );

LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
lineOpen(
    HLINEAPP hLineApp, 
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineOpenW(
    HLINEAPP hLineApp, 
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineOpen lineOpenW
#endif

#define lineOpenA lineOpen
#endif
#endif

LONG
WINAPI
linePark(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR              lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

#if WIN32
LONG
WINAPI
lineParkW(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR            lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define linePark lineParkW
#endif

#define lineParkA linePark
#endif
#endif

LONG
WINAPI
linePickup(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszGroupID
    );

#if WIN32
LONG
WINAPI
linePickupW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR            lpszDestAddress,
    LPCSTR            lpszGroupID
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define linePickup linePickupW
#endif

#define linePickupA linePickup
#endif
#endif

LONG
WINAPI
linePrepareAddToConference(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
linePrepareAddToConferenceW(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define linePrepareAddToConference linePrepareAddToConferenceW
#endif

#define linePrepareAddToConferenceA linePrepareAddToConference
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineProxyMessage(                                               // TAPI v2.0
    HLINE               hLine,
    HCALL               hCall,
    DWORD               dwMsg,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );

LONG
WINAPI
lineProxyResponse(                                              // TAPI v2.0
    HLINE               hLine,
    LPLINEPROXYREQUEST  lpProxyRequest,
    DWORD               dwResult
    );
#endif

LONG
WINAPI
lineRedirect(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineRedirectW(
    HCALL               hCall,
    LPCSTR            lpszDestAddress,
    DWORD               dwCountryCode
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineRedirect lineRedirectW
#endif

#define lineRedirectA lineRedirect
#endif
#endif

LONG
WINAPI
lineRegisterRequestRecipient(
    HLINEAPP            hLineApp,
    DWORD               dwRegistrationInstance,
    DWORD               dwRequestMode,
    DWORD               bEnable
    );

LONG
WINAPI
lineReleaseUserUserInfo(                                        // TAPI v1.4
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveFromConference(
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveProvider(                                             // TAPI v1.4
    DWORD               dwPermanentProviderID,
    HWND                hwndOwner
    );

LONG
WINAPI
lineSecureCall(
    HCALL               hCall
    );

LONG
WINAPI
lineSendUserUserInfo(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetAgentActivity(                                           // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwActivityID
    );

LONG
WINAPI
lineSetAgentGroup(                                              // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

LONG
WINAPI
lineSetAgentState(                                              // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    );
#endif

LONG
WINAPI
lineSetAppPriority(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    );

#if WIN32
LONG
WINAPI
lineSetAppPriorityW(                                             // TAPI v1.4
    LPCSTR            lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR            lpszExtensionName,
    DWORD               dwPriority
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineSetAppPriority lineSetAppPriorityW
#endif

#define lineSetAppPriorityA lineSetAppPriority
#endif
#endif

LONG
WINAPI
lineSetAppSpecific(
    HCALL               hCall,
    DWORD               dwAppSpecific
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetCallData(                                                // TAPI v2.0
    HCALL               hCall,
    LPVOID              lpCallData,
    DWORD               dwSize
    );
#endif

LONG
WINAPI
lineSetCallParams(
    HCALL               hCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    );

LONG
WINAPI
lineSetCallPrivilege(
    HCALL               hCall,
    DWORD               dwCallPrivilege
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetCallQualityOfService(                                    // TAPI v2.0
    HCALL               hCall,
    LPVOID              lpSendingFlowspec,
    DWORD               dwSendingFlowspecSize,
    LPVOID              lpReceivingFlowspec,
    DWORD               dwReceivingFlowspecSize
    );

LONG
WINAPI
lineSetCallTreatment(                                           // TAPI v2.0
    HCALL               hCall,
    DWORD               dwTreatment
    );
#endif

LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP            hLineApp,
    DWORD               dwLocation
    );

LONG
WINAPI
lineSetDevConfig(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineSetDevConfigW(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineSetDevConfig lineSetDevConfigW
#endif

#define lineSetDevConfigA lineSetDevConfig
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetLineDevStatus(                                           // TAPI v2.0
    HLINE               hLine,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    );
#endif

LONG
WINAPI
lineSetMediaControl(
    HLINE                       hLine,
    DWORD                       dwAddressID,
    HCALL                       hCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList, 
    DWORD                       dwCallStateNumEntries
    );

LONG
WINAPI
lineSetMediaMode(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineSetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwNumRings
    );

LONG
WINAPI
lineSetStatusMessages(
    HLINE               hLine,
    DWORD               dwLineStates,
    DWORD               dwAddressStates
    );

LONG
WINAPI
lineSetTerminal(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    DWORD               bEnable
    );

LONG
WINAPI
lineSetTollList(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR              lpszAddressIn,
    DWORD               dwTollListOption
    );

#if WIN32
LONG
WINAPI
lineSetTollListW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR            lpszAddressInW,
    DWORD               dwTollListOption
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineSetTollList lineSetTollListW
#endif

#define lineSetTollListA lineSetTollList
#endif
#endif


LONG
WINAPI
lineSetupConference(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineSetupConferenceW(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineSetupConference lineSetupConferenceW
#endif

#define lineSetupConferenceA lineSetupConference
#endif
#endif

LONG
WINAPI
lineSetupTransfer(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineSetupTransferW(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineSetupTransfer lineSetupTransferW
#endif

#define lineSetupTransferA lineSetupTransfer
#endif
#endif

LONG
WINAPI
lineShutdown(
    HLINEAPP            hLineApp
    );

LONG
WINAPI
lineSwapHold(
    HCALL               hActiveCall,
    HCALL               hHeldCall
    );

LONG
WINAPI
lineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

#if WIN32
LONG
WINAPI
lineTranslateAddressW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineTranslateAddress lineTranslateAddressW
#endif

#define lineTranslateAddressA  lineTranslateAddress
#endif
#endif

LONG
WINAPI
lineTranslateDialog(                                            // TAPI v1.4
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR              lpszAddressIn
    );

#if WIN32
LONG
WINAPI
lineTranslateDialogW(                                            // TAPI v2.0
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR            lpszAddressIn
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineTranslateDialog lineTranslateDialogW
#endif

#define lineTranslateDialogA  lineTranslateDialog
#endif
#endif

LONG
WINAPI
lineUncompleteCall(
    HLINE               hLine,
    DWORD               dwCompletionID
    );

LONG
WINAPI
lineUnhold(
    HCALL               hCall
    );

LONG
WINAPI
lineUnpark(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress
    );

#if WIN32
LONG
WINAPI
lineUnparkW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR            lpszDestAddress
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define lineUnpark lineUnparkW
#endif

#define lineUnparkA lineUnpark
#endif
#endif



LONG
WINAPI
phoneClose(
    HPHONE              hPhone
    );

LONG
WINAPI
phoneConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
phoneConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneConfigDialog phoneConfigDialogW
#endif

#define phoneConfigDialogA phoneConfigDialog
#endif
#endif

LONG
WINAPI
phoneDevSpecific(
    HPHONE              hPhone,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
phoneGetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

#if WIN32
LONG
WINAPI
phoneGetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneGetButtonInfo phoneGetButtonInfoW
#endif

#define phoneGetButtonInfoA phoneGetButtonInfo
#endif
#endif

LONG
WINAPI
phoneGetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              lpData,
    DWORD               dwSize
    );

LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

#if WIN32
LONG
WINAPI
phoneGetDevCapsW(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneGetDevCaps phoneGetDevCapsW
#endif

#define phoneGetDevCapsA phoneGetDevCaps
#endif
#endif

LONG
WINAPI
phoneGetDisplay(
    HPHONE              hPhone,
    LPVARSTRING         lpDisplay
    );

LONG
WINAPI
phoneGetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    );

LONG
WINAPI
phoneGetHookSwitch(
    HPHONE              hPhone,
    LPDWORD             lpdwHookSwitchDevs
    );

LONG
WINAPI
phoneGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

#if WIN32
LONG
WINAPI
phoneGetIconW(
    DWORD               dwDeviceID,
    LPCSTR            lpszDeviceClass,
    LPHICON             lphIcon
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneGetIcon phoneGetIconW
#endif

#define phoneGetIconA phoneGetIcon
#endif
#endif

LONG
WINAPI
phoneGetID(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
phoneGetIDW(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR            lpszDeviceClass
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneGetID phoneGetIDW
#endif

#define phoneGetIDA phoneGetID
#endif
#endif

LONG
WINAPI
phoneGetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPDWORD             lpdwLampMode
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
phoneGetMessage(                                                // TAPI v2.0
    HPHONEAPP       hPhoneApp,
    LPPHONEMESSAGE  lpMessage,
    DWORD           dwTimeout
    );
#endif

LONG
WINAPI
phoneGetRing(
    HPHONE              hPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneGetStatus(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );

#if WIN32
LONG
WINAPI
phoneGetStatusW(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );


#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneGetStatus phoneGetStatusW
#endif

#define phoneGetStatusA phoneGetStatus
#endif
#endif

LONG
WINAPI
phoneGetStatusMessages(
    HPHONE              hPhone,
    LPDWORD             lpdwPhoneStates,
    LPDWORD             lpdwButtonModes,
    LPDWORD             lpdwButtonStates
    );

LONG
WINAPI
phoneGetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneInitialize(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    );

#if WIN32
LONG
WINAPI
phoneInitializeW(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCSTR            lpszAppNameW,
    LPDWORD             lpdwNumDevs
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneInitialize phoneInitializeW
#endif

#define phoneInitializeA phoneInitialize
#endif
#endif


#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
phoneInitializeEx(                                              // TAPI v2.0
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

LONG
WINAPI
phoneInitializeExW(                                              // TAPI v2.0
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                    lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

#ifdef UNICODE
#define phoneInitializeEx phoneInitializeExW
#endif

#define phoneInitializeExA phoneInitializeEx
#endif

LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    );

LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
phoneOpen(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    LPHPHONE            lphPhone,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivilege
    );

LONG
WINAPI
phoneSetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

#if WIN32
LONG
WINAPI
phoneSetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define phoneSetButtonInfo phoneSetButtonInfoW
#endif

#define phoneSetButtonInfoA phoneSetButtonInfo
#endif
#endif

LONG
WINAPI
phoneSetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              const lpData,
    DWORD               dwSize
    );

LONG
WINAPI
phoneSetDisplay(
    HPHONE              hPhone,
    DWORD               dwRow,
    DWORD               dwColumn,
    LPCSTR              lpsDisplay,
    DWORD               dwSize
    );

LONG
WINAPI
phoneSetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    );

LONG
WINAPI
phoneSetHookSwitch(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    );

LONG
WINAPI
phoneSetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    DWORD               dwLampMode
    );

LONG
WINAPI
phoneSetRing(
    HPHONE              hPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneSetStatusMessages(
    HPHONE              hPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    );

LONG
WINAPI
phoneSetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneShutdown(
    HPHONEAPP           hPhoneApp
    );



LONG
WINAPI
tapiGetLocationInfo(
    LPSTR               lpszCountryCode,
    LPSTR               lpszCityCode
    );
    
#if WIN32
LONG
WINAPI
tapiGetLocationInfoW(
    LPWSTR               lpszCountryCodeW,
    LPWSTR               lpszCityCodeW
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define tapiGetLocationInfo tapiGetLocationInfoW
#endif

#define tapiGetLocationInfoA tapiGetLocationInfo
#endif
#endif
    

LONG
WINAPI
tapiRequestDrop(
    HWND                hwnd,
    WPARAM              wRequestID
    );

LONG
WINAPI
tapiRequestMakeCall(
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

#if WIN32
LONG
WINAPI
tapiRequestMakeCallW(
    LPCSTR             lpszDestAddress,
    LPCSTR             lpszAppName,
    LPCSTR             lpszCalledParty,
    LPCSTR             lpszComment
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define tapiRequestMakeCall tapiRequestMakeCallW
#endif

#define tapiRequestMakeCallA tapiRequestMakeCall
#endif
#endif
    
LONG
WINAPI
tapiRequestMediaCall(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR              lpszDeviceClass,
    LPCSTR              lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

#if WIN32
LONG
WINAPI
tapiRequestMediaCallW(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR            lpszDeviceClass,
    LPCSTR            lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR            lpszDestAddress,
    LPCSTR            lpszAppName,
    LPCSTR            lpszCalledParty,
    LPCSTR            lpszComment
    );

#ifdef REALLY_USE_UNICODE
#ifdef UNICODE
#define tapiRequestMediaCall tapiRequestMediaCallW
#endif

#define tapiRequestMediaCallA tapiRequestMediaCall
#endif
#endif
    



#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#pragma pack()

#endif // TAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\userinfo.h ===
//+----------------------------------------------------------------------------
//
// File:     userinfo.h
//
// Module:   CMCFG32.DLL and CMDIAL32.DLL
//
// Synopsis: UserInfo constants
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb/nickball      Created      08/06/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_USERINFO_H_
#define _CM_USERINFO_H_


///////////////////////////////////////////////////////////////////////////////////
// define's
///////////////////////////////////////////////////////////////////////////////////

// UserInfo Identifiers 

#define UD_ID_USERNAME                  0x00000001
#define UD_ID_INET_USERNAME             0x00000002
#define UD_ID_DOMAIN                    0x00000004
#define UD_ID_PASSWORD                  0x00000008
#define UD_ID_INET_PASSWORD             0x00000010
#define UD_ID_NOPROMPT                  0x00000020
#define UD_ID_REMEMBER_PWD              0x00000040
#define UD_ID_REMEMBER_INET_PASSWORD    0x00000080
#define UD_ID_PCS                       0x00000100
#define UD_ID_ACCESSPOINTENABLED        0x00000200
#define UD_ID_CURRENTACCESSPOINT        0x00000400


//
//  Tells CM what kind of upgrade is needed.  See NeedToUpgradeUserInfo and 
//  UpgradeUserInfo below for more details
//
const int c_iNoUpgradeRequired = 0;
const int c_iUpgradeFromCmp = 1;
const int c_iUpgradeFromRegToRas = 2;

#endif // _CM_USERINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\wizglob.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
// WIZGLOB.H - 	global data structures and defines for all wizard components
// 				(32-bit exe, 32-bit dll, 16-bit dll)

//	HISTORY:
//	
//	11/20/94	jeremys		Created.
//

#ifndef _WIZGLOB_H_
#define _WIZGLOB_H_

#ifndef SETUPX_INC
typedef UINT RETERR;             // setupx Return Error code type.
#endif	// SETUPX_INC

// structure to hold information about client software configuration
#include <struct.h> // separated out so thunk compiler can get at

typedef CLIENTCONFIG FAR * LPCLIENTCONFIG;
typedef char CHAR;
typedef BOOL FAR * LPBOOL;

// component defines for InstallComponent

#define IC_PPPMAC			0x0001		// install PPPMAC
#define IC_TCPIP			0x0002		// install TCP/IP
#define IC_INSTALLFILES		0x0003		// install files, etc from INF

// dwParam bits for IC_INSTALLFILES
#define ICIF_MAIL			0x0001		// install mail files
#define ICIF_RNA			0x0002		// install RNA files
#define ICIF_MSN			0x0004		// install Microsoft Network files
#define ICIF_MSN105			0x0008		// install MSN 1.05 (Rome) files
#define ICIF_INET_MAIL		0x0010		// install Internet mail files

// INSTANCE_ defines for TCP/IP configuration apis
#define INSTANCE_NETDRIVER		0x0001
#define INSTANCE_PPPDRIVER		0x0002
#define INSTANCE_ALL	   		(INSTANCE_NETDRIVER | INSTANCE_PPPDRIVER)

// PROT_ defines for protocol types
#define PROT_TCPIP				0x0001
#define PROT_IPX				0x0002
#define PROT_NETBEUI			0x0004

#define NEED_RESTART			((WORD) -1)

#endif // _WIZGLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\uapi.h ===
//+----------------------------------------------------------------------------
//
// File:     uapi.h
//
// Module:   UAPIINIT.LIB
//
// Synopsis: This header file contains the extern declarations of all the UAPI
//           function pointers declared in the uapiinit.lib.  The idea for this 
//           dll was borrowed from F. Avery Bishop's April 1999 MSJ article 
//           "Design a Single Unicode App that Runs on Both Windows 98 and Windows 2000"
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb      Created    04/25/99
//
//+----------------------------------------------------------------------------

#ifndef _UAPIH


// Uncomment this line to emmulate Windows 98 behavior when developing on
// Windows NT
//#define EMULATE9X

#include "cmutoa.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

extern UAPI_CallWindowProc CallWindowProcU;
extern UAPI_CharLower CharLowerU;
extern UAPI_CharPrev CharPrevU;
extern UAPI_CharNext CharNextU;
extern UAPI_CharUpper CharUpperU;
extern UAPI_CreateDialogParam CreateDialogParamU;
extern UAPI_CreateDirectory CreateDirectoryU;
extern UAPI_CreateEvent CreateEventU;
extern UAPI_CreateFile CreateFileU;
extern UAPI_CreateFileMapping CreateFileMappingU;
extern UAPI_CreateMutex CreateMutexU;
extern UAPI_CreateProcess CreateProcessU;
extern UAPI_CreateWindowEx CreateWindowExU;
extern UAPI_DefWindowProc DefWindowProcU;
extern UAPI_DeleteFile DeleteFileU;
extern UAPI_DialogBoxParam DialogBoxParamU;
extern UAPI_DispatchMessage DispatchMessageU;
extern UAPI_ExpandEnvironmentStrings ExpandEnvironmentStringsU;
extern UAPI_FindResourceEx FindResourceExU;
extern UAPI_FindWindowEx FindWindowExU;
extern UAPI_GetClassLong GetClassLongU;
extern UAPI_GetDateFormat GetDateFormatU;
extern UAPI_GetDlgItemText GetDlgItemTextU;
extern UAPI_GetFileAttributes GetFileAttributesU;
extern UAPI_GetMessage GetMessageU;
extern UAPI_GetModuleFileName GetModuleFileNameU;
extern UAPI_GetModuleHandle GetModuleHandleU;
extern UAPI_GetPrivateProfileInt GetPrivateProfileIntU;
extern UAPI_GetPrivateProfileString GetPrivateProfileStringU;
extern UAPI_GetStringTypeEx GetStringTypeExU;
extern UAPI_GetSystemDirectory GetSystemDirectoryU;
extern UAPI_GetTempFileName GetTempFileNameU;
extern UAPI_GetTempPath GetTempPathU;
extern UAPI_GetTimeFormat GetTimeFormatU;
extern UAPI_GetUserName GetUserNameU;
extern UAPI_GetVersionEx GetVersionExU;
extern UAPI_GetWindowLong GetWindowLongU;
extern UAPI_GetWindowText GetWindowTextU;
extern UAPI_GetWindowTextLength GetWindowTextLengthU;
extern UAPI_InsertMenu InsertMenuU;
extern UAPI_IsDialogMessage IsDialogMessageU;
extern UAPI_LoadCursor LoadCursorU;
extern UAPI_LoadIcon LoadIconU;
extern UAPI_LoadImage LoadImageU;
extern UAPI_LoadLibraryEx LoadLibraryExU;
extern UAPI_LoadMenu LoadMenuU;
extern UAPI_LoadString LoadStringU;
extern UAPI_lstrcat lstrcatU;
extern UAPI_lstrcmp lstrcmpU;
extern UAPI_lstrcmpi lstrcmpiU;
extern UAPI_lstrcpy lstrcpyU;
extern UAPI_lstrcpyn lstrcpynU;
extern UAPI_lstrlen lstrlenU;
extern UAPI_OpenEvent OpenEventU;
extern UAPI_OpenFileMapping OpenFileMappingU;
extern UAPI_PeekMessage PeekMessageU;
extern UAPI_PostMessage PostMessageU;
extern UAPI_PostThreadMessage PostThreadMessageU;
extern UAPI_RegCreateKeyEx RegCreateKeyExU;
extern UAPI_RegDeleteKey RegDeleteKeyU;
extern UAPI_RegDeleteValue RegDeleteValueU;
extern UAPI_RegEnumKeyEx RegEnumKeyExU;
extern UAPI_RegisterClassEx RegisterClassExU;
extern UAPI_RegisterWindowMessage RegisterWindowMessageU;
extern UAPI_RegOpenKeyEx RegOpenKeyExU;
extern UAPI_RegQueryValueEx RegQueryValueExU;
extern UAPI_RegSetValueEx RegSetValueExU;
extern UAPI_SearchPath SearchPathU;
extern UAPI_SendDlgItemMessage SendDlgItemMessageU;
extern UAPI_SendMessage SendMessageU;
extern UAPI_SetCurrentDirectory SetCurrentDirectoryU;
extern UAPI_SetDlgItemText SetDlgItemTextU;
extern UAPI_SetWindowLong SetWindowLongU;
extern UAPI_SetWindowText SetWindowTextU;
extern UAPI_UnregisterClass UnregisterClassU;
extern UAPI_WinHelp WinHelpU;
extern UAPI_wsprintf wsprintfU;
extern UAPI_WritePrivateProfileString WritePrivateProfileStringU;
extern UAPI_wvsprintf wvsprintfU;

// Implemented as a macro, just as DialogBoxW is on Windows NT
#define DialogBoxU(hInstance, lpTemplate, hWndParent, lpDialogFunc    ) \
   DialogBoxParamU(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)

//
// External function prototypes. The client of the Unicode API calls this to 
// set the pointer functions as appropriate
//
BOOL   InitUnicodeAPI(); 
BOOL   UnInitUnicodeAPI();

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#define _UAPIH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\bmpimage.cpp ===
//+----------------------------------------------------------------------------
//
// File:     image.cpp
//
// Module:   CMDIAL and CMAK
//
// Synopsis: CMDIAL/CMAK specific imaging support routines
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created Header          03/30/98
//           quintinb   moved to common\source  08/06/98
//
//+----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Function:   CmGetBitmapInfo
//
//  Synopsis:   Helper function to retrieve the contents of a bitmap from an HBITMAP 
//                          
//  Arguments:  hbm - Hanhdle of the target bitmap
//
//  Returns:    A pointer to a LPBITMAPINFO that contains the INFOHEADER, 
//              ColorTable and bits for the bitmap.
//
//  Note:       When accessing this value, or passing it on to other BITMAP APIs
//              it is recommended that the value be cast as an (LPBYTE). 
//
//  History:    a-nichb - Cleaned-up and commented  - 3/21/97
//
//----------------------------------------------------------------------------

LPBITMAPINFO CmGetBitmapInfo(HBITMAP hbm) 
{
    LPBITMAPINFO pbmi = NULL;
    HDC hDC = NULL;
    int nNumColors = 0;
    int iRes;
    LPBITMAPINFO lpbmih = NULL;
    DWORD dwInfoSize = 0;
    WORD wbiBits = 0;

    if (!hbm) 
    {
        return NULL;
    }
    
    // Get the basic bmp object info 
    
    BITMAP BitMap;
    
    if (!GetObjectA(hbm, sizeof(BITMAP), &BitMap))
    {
        goto Cleanup;
    }

    // Calc the color bits and num colors
    
    wbiBits = BitMap.bmPlanes * BitMap.bmBitsPixel;

    if (wbiBits <= 8) 
    {
        nNumColors = 1 << wbiBits;
    }
        
    // Allocate a BITMAPINFO structure large enough to hold header + color palette
        
    dwInfoSize = sizeof(BITMAPINFOHEADER) + (nNumColors * sizeof(RGBQUAD));
     
    lpbmih = (LPBITMAPINFO) CmMalloc(dwInfoSize); 

    if (!lpbmih)
    {
        goto Cleanup;
    }
    
    // Pre-fill the info that we have about the bmp

    lpbmih->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    lpbmih->bmiHeader.biWidth = BitMap.bmWidth;
    lpbmih->bmiHeader.biHeight = BitMap.bmHeight;
    lpbmih->bmiHeader.biPlanes = 1; 
    lpbmih->bmiHeader.biBitCount = wbiBits;
        
    // Call GetDiBits() w/ 5th Param to NULL, this is treated by the system as
    // a query in which case it validates the lpbmih contents and fills in the
    // biSizeImage member of the structure
    
    hDC = GetDC(NULL);
    if (!hDC)
    {
        goto Cleanup;
    }

    iRes = GetDIBits(hDC,hbm,0,BitMap.bmHeight,NULL,(LPBITMAPINFO) lpbmih,DIB_RGB_COLORS);

#ifdef DEBUG
    if (!iRes)
    {
        CMTRACE(TEXT("CmGetBitmapInfo() GetDIBits() failed."));
    }
#endif

    if (iRes)
    {
        DWORD dwFullSize = dwInfoSize;
        
        // Create a complete DIB structure with room for bits and fill it

        if (lpbmih->bmiHeader.biSizeImage) 
        {
            dwFullSize += lpbmih->bmiHeader.biSizeImage;
        } 
        else 
        {
            dwFullSize += (((WORD) (lpbmih->bmiHeader.biWidth * lpbmih->bmiHeader.biBitCount) / 8) * (WORD) BitMap.bmHeight); 
        }
    
        pbmi = (LPBITMAPINFO) CmMalloc(dwFullSize + sizeof(DWORD));

#ifdef DEBUG
        *((DWORD *) (((PBYTE) pbmi)+dwFullSize)) = 0x12345678;
        *((DWORD *) (((PBYTE) pbmi)+dwFullSize-sizeof(DWORD))) = 0x23456789;
#endif

        if (pbmi)
        {
            // Load the new larger LPBITMAPINFO struct with existing info, 
            // and get the data bits. Release the existing LPBITMAPINFO.
            
            CopyMemory(pbmi, lpbmih, dwInfoSize);
             
            //
            // We have a handle, we want the exact bits.
            // 

            iRes = GetDIBits(hDC,
                             hbm,
                             0,
                             BitMap.bmHeight,
                             ((LPBYTE) pbmi) + dwInfoSize,
                             pbmi,
                             DIB_RGB_COLORS);

#ifdef DEBUG
            if (*((DWORD *) (((PBYTE) pbmi) + dwFullSize)) != 0x12345678)
            {
                CMTRACE(TEXT("CmGetBitmapInfo() GetDIBits() copied too much."));
            }

            if (*((DWORD *) (((PBYTE) pbmi) + dwFullSize - sizeof(DWORD))) == 0x23456789)
            {
                CMTRACE(TEXT("CmGetBitmapInfo() GetDIBits() didn't copy enough."));
            }
#endif    
            // If GetDiBits() failed, free the BITMAPINFO buffer
            
            if (!iRes) 
            {
                CmFree(pbmi);
                pbmi = NULL;
            }
        }
    }
          
    // Cleanup

Cleanup:
    if (lpbmih)
    {
        CmFree(lpbmih);
    }
    if (hDC)
    {
        ReleaseDC(NULL, hDC);       
    }
    
    return pbmi;
}

static HPALETTE CmCreateDIBPalette(LPBITMAPINFO pbmi) 
{
    WORD wNumColors = 0;
    HPALETTE hRes = NULL;

    if (!pbmi) 
    {
        return (NULL);
    }
    
    // Get num colors according to color depth
    // Note: 24-bit bitmaps have no color table

    if (pbmi->bmiHeader.biBitCount <= 8) 
    {
        wNumColors = 1 << pbmi->bmiHeader.biBitCount;
    } 

    // Fill logical palette based upon color table

    if (wNumColors) 
    {
        LPLOGPALETTE pLogPal;
        int idx;

        pLogPal = (LPLOGPALETTE) CmMalloc(sizeof(LOGPALETTE)+sizeof(PALETTEENTRY)*wNumColors);
        if (pLogPal)
        {
            pLogPal->palVersion = 0x300;
            pLogPal->palNumEntries = wNumColors;
            for (idx=0;idx<wNumColors;idx++) 
            {
                pLogPal->palPalEntry[idx].peRed = pbmi->bmiColors[idx].rgbRed;
                pLogPal->palPalEntry[idx].peGreen = pbmi->bmiColors[idx].rgbGreen;
                pLogPal->palPalEntry[idx].peBlue = pbmi->bmiColors[idx].rgbBlue;
                pLogPal->palPalEntry[idx].peFlags = 0;
            }
        
            // Create a new palette

            hRes = CreatePalette(pLogPal);

#ifdef DEBUG
            if (!hRes)
            {
                CMTRACE1(TEXT("CmCreateDIBPalette() CreatePalette() failed, GLE=%u."), GetLastError());
            }
#endif

            CmFree(pLogPal);
        }
    }
    return hRes;
}

HBITMAP CmLoadBitmap(HINSTANCE hInst, LPCTSTR pszSpec) 
{
    return ((HBITMAP) CmLoadImage(hInst, pszSpec, IMAGE_BITMAP, 0, 0));
}

//+----------------------------------------------------------------------------
//
// Function:  ReleaseBitmapData
//
// Synopsis:  Releases resources and memory acquired during CreateBitmapData.  Note
//            that if you are using this with the BmpWndProc function below, that you
//            should call an STM_SETIMAGE with a NULL image pointer param in order to
//            clear out the window procedures window long.  Otherwise, it could get
//            a WM_PAINT message and try to use the freed memory before you can
//            clear it out or have the window destroyed by the dialog manager.
//
// Arguments: LPBMPDATA pBmpData - Ptr to the BmpData to be released
//
// Returns:   Nothing
//
// History:   nickball    Created    3/27/98
//
//+----------------------------------------------------------------------------
void ReleaseBitmapData(LPBMPDATA pBmpData)
{  
    MYDBGASSERT(pBmpData);

    if (NULL == pBmpData)
    {
        return;
    }

    if (pBmpData->hDIBitmap) 
    {
        DeleteObject(pBmpData->hDIBitmap);
        pBmpData->hDIBitmap = NULL;
    }
    
    if (pBmpData->hDDBitmap) 
    {
        DeleteObject(pBmpData->hDDBitmap);
        pBmpData->hDDBitmap = NULL;
    }

    if (pBmpData->pBmi)
    {
        CmFree(pBmpData->pBmi);
        pBmpData->pBmi = NULL;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CreateBitmapData
//
// Synopsis:  Fills a BMPDATA struct with all data necessary to display a bitmap. 
//
// Arguments: HBITMAP hBmp - Handle of the source bitmap
//            LPBMPDATA lpBmpData - Ptr to the BmpData struct to be filled
//            HWND hwnd - The hwnd that the bitmap will be displayed in.
//            BOOL fCustomPalette - Indicates that the DDB should be created with a palette specific to the bitmap.
//
// Returns:   BOOL - TRUE on succes 
//
// History:   nickball    Created    3/27/98
//
//+----------------------------------------------------------------------------
BOOL CreateBitmapData(HBITMAP hDIBmp,
    LPBMPDATA lpBmpData,
    HWND hwnd,
    BOOL fCustomPalette)
{   
    MYDBGASSERT(hDIBmp);
    MYDBGASSERT(lpBmpData);
    MYDBGASSERT(lpBmpData->phMasterPalette);

    if (NULL == hDIBmp || NULL == lpBmpData)
    {
        return NULL;
    }

    //
    // Params look good, get busy
    //

    HPALETTE hPaletteNew = NULL;
    LPBITMAPINFO pBmi = NULL;
    HBITMAP hDDBmp = NULL;
    HDC hDC;
    int iRes = 0;

    //
    // If we already have a pBmi value, we will assume it is up to date, as 
    // both it and the DIB do not change throughout the life of the BMP.
    // Note: If BmpData is not zero initialized, you will have problems.
    //

    if (lpBmpData->pBmi)
    {
        pBmi = lpBmpData->pBmi;
    }
    else
    {   
        //
        // Use the bitmap handle to retrieve a BITMAPINFO ptr complete w/ data
        //
        
        pBmi = CmGetBitmapInfo(lpBmpData->hDIBitmap);
        
        if (NULL == pBmi) 
        {
            return FALSE;
        }
    }
    
    //
    // we need a DC
    //
    
    hDC = GetDC(hwnd);

    if (!hDC)
    {
        CMTRACE(TEXT("MyCreateDDBitmap() GetDC() failed."));
        return FALSE;
    }

    //
    //  If CM is localized so that it is RTL (Right to Left => arabic and Hebrew),
    //  then we need to call SetLayout on the hDC from above.  If we don't
    //  set the layout back to LTR, the bitmap will show up as all black instead of as
    //  an image.
    //
    HMODULE hLib = LoadLibrary(TEXT("gdi32.dll"));
    
    if (hLib)
    {
        #ifndef LAYOUT_RTL
        #define LAYOUT_RTL                         0x00000001 // Right to left
        #endif

        DWORD dwLayout;
        typedef DWORD (WINAPI* pfnSetLayoutType)(HDC, DWORD);
        typedef DWORD (WINAPI* pfnGetLayoutType)(HDC);

        pfnSetLayoutType pfnSetLayout = (pfnSetLayoutType)GetProcAddress(hLib, "SetLayout");
        pfnGetLayoutType pfnGetLayout = (pfnGetLayoutType)GetProcAddress(hLib, "GetLayout");

        if (pfnSetLayout && pfnGetLayout)
        {
            DWORD dwLayout = pfnGetLayout(hDC);
    
            if (LAYOUT_RTL & dwLayout)
            {
                dwLayout ^= LAYOUT_RTL; // toggle LAYOUT_RTL off
                pfnSetLayout(hDC, dwLayout);
                CMTRACE(TEXT("CreateBitmapData -- Toggling off LAYOUT_RTL on the device context"));
            }
        }

        FreeLibrary(hLib);
    }

    //
    // If fCustomPalette is set then create a palette based on our bits
    // and realize it in the current DC.
    //

    if (fCustomPalette) 
    {
        hPaletteNew = CmCreateDIBPalette(pBmi);
        
        if (hPaletteNew) 
        {                           
            //
            // Select and realize the new palette so that the DDB is created with it below
            //

            HPALETTE hPalettePrev = SelectPalette(hDC, 
                hPaletteNew, lpBmpData->bForceBackground); // FALSE == Foreground app behavior);
                                                               // TRUE == Background app behavior);

            if (hPalettePrev) 
            {
                iRes = RealizePalette(hDC);
#ifdef DEBUG
                if (GDI_ERROR == iRes)
                {
                    CMTRACE1(TEXT("MyCreateDDBitmap() RealizePalette() failed, GLE=%u."), GetLastError());                    
                }
            }
            else
            {
                CMTRACE1(TEXT("MyCreateDDBitmap() SelectPalette() failed, GLE=%u."), GetLastError());
#endif
            }

        }
    }

    //
    // Determine number of color entries based upon color depth
    //

    int nNumColors = 0;
    
    if (pBmi->bmiHeader.biBitCount <= 8)
    {
        nNumColors = (1 << pBmi->bmiHeader.biBitCount);
    }

    //
    // Create the DDB from the bits 
    //

    hDDBmp = CreateDIBitmap(hDC,
                          &pBmi->bmiHeader,                        
                          CBM_INIT,
                          ((LPBYTE) pBmi) + sizeof(BITMAPINFOHEADER) + (nNumColors * sizeof(RGBQUAD)), //dib.dsBm.bmBits,
                          pBmi,
                          DIB_RGB_COLORS);

#ifdef DEBUG
    if (!hDDBmp)
    {
        CMTRACE(TEXT("MyCreateDDBitmap() CreateDIBitmap() failed."));
    }
#endif

    ReleaseDC(NULL, hDC);

    //
    // Fill in the bitmap data
    //

    if (hDDBmp)
    {
        lpBmpData->hDIBitmap = hDIBmp;       
        lpBmpData->pBmi = pBmi;

        //
        // Delete existing DDB, if any
        //

        if (lpBmpData->hDDBitmap) 
        {
            DeleteObject(lpBmpData->hDDBitmap);
        } 

        lpBmpData->hDDBitmap = hDDBmp;

        if (hPaletteNew)
        {
            //
            // Delete existing Palette, if any
            //

            if (*lpBmpData->phMasterPalette)
            {
                DeleteObject(*lpBmpData->phMasterPalette);
            }

            *lpBmpData->phMasterPalette = hPaletteNew;
        }

        return TRUE;
    }

    //
    // Something went wrong, cleanup
    //

    CmFree(pBmi);

    return FALSE;
}

//
// Bitmap window procedure
//

LRESULT CALLBACK BmpWndProc(HWND hwndBmp, 
                            UINT uMsg, 
                            WPARAM wParam, 
                            LPARAM lParam) 
{
    LPBMPDATA pBmpData = (LPBMPDATA) GetWindowLongU(hwndBmp,0);   
    BOOL bRes;

    switch (uMsg) 
    {
        case WM_CREATE:
        {
            return FALSE;
        }

        case WM_DESTROY:
            SetWindowLongU(hwndBmp,sizeof(LPBMPDATA),(LONG_PTR) NULL);      
            break;

        case WM_PAINT:
            if (pBmpData && pBmpData->pBmi) 
            {
                LPBITMAPINFO pBmi = pBmpData->pBmi;

                RECT rWnd;
                RECT rSrc = {0,0,(int)pBmpData->pBmi->bmiHeader.biWidth,
                                 (int)pBmpData->pBmi->bmiHeader.biHeight};
                PAINTSTRUCT ps;
                HDC hdcBmp;
                HBITMAP hbmpPrev;
                int iPrevStretchMode;
                
                //
                // Start  painting
                //

                HDC hdc = BeginPaint(hwndBmp,&ps);

                if (hdc)
                {
                    //
                    // Select and realize our current palette in the current DC
                    //

                    //UnrealizeObject(*pBmpData->phMasterPalette);
                    SelectPalette(hdc, *pBmpData->phMasterPalette, pBmpData->bForceBackground);
                    RealizePalette(hdc);

                    //
                    // Create a compatible DC, we'll create the BMP here then BLT it to the real DC
                    //

                    hdcBmp = CreateCompatibleDC(hdc);

                    if (hdcBmp)
                    {
                        //
                        // Select and realize our current palette in the compatible DC
                        //

                        SelectPalette(hdcBmp, *pBmpData->phMasterPalette, pBmpData->bForceBackground);
                        RealizePalette(hdcBmp);

                        if (!hdcBmp)
                        {
                            CMTRACE(TEXT("BmpWndProc() CreateCompatibleDC() failed."));
                        }

                        if (!pBmpData->hDDBitmap)
                        {
                            CMTRACE(TEXT("BmpWndProc() - WM_PAINT - hDDBitmap is NULL."));
                        }

                        //
                        // Select the bitmap into the compatible DC
                        //

                        hbmpPrev = (HBITMAP) SelectObject(hdcBmp,pBmpData->hDDBitmap);
                        bRes = GetWindowRect(hwndBmp,&rWnd);

                        if (!bRes)
                        {
                            CMTRACE1(TEXT("BmpWndProc() GetWindowRect() failed, GLE=%u."), GetLastError());
                        }       

                        //
                        // Now set the mode, and StretchBlt the bitmap from the compatible DC to the active DC
                        //

                        CMTRACE(TEXT("BmpWndProc() : Changing stretch mode"));
                        iPrevStretchMode = SetStretchBltMode(hdc, STRETCH_DELETESCANS);

                        bRes = StretchBlt(hdc,
                                          rWnd.left-rWnd.left,
                                          rWnd.top-rWnd.top,
                                          rWnd.right-rWnd.left,
                                          rWnd.bottom-rWnd.top,
                                          hdcBmp,
                                          rSrc.left-rSrc.left,
                                          rSrc.top-rSrc.top,
                                          rSrc.right-rSrc.left,
                                          rSrc.bottom-rSrc.top,
                                          SRCCOPY);
                        if (!bRes)
                        {
                            CMTRACE1(TEXT("BmpWndProc() StretchBlt() failed, GLE=%u."), GetLastError());
                        }

                        //
                        // Restore the mode in the active DC
                        //
                        CMTRACE(TEXT("BmpWndProc() Restoring stretch mode"));
                        iPrevStretchMode = SetStretchBltMode(hdc, iPrevStretchMode);

                        //
                        // Restore the compatible DC and release it
                        //

                        SelectObject(hdcBmp,hbmpPrev);          
                        DeleteDC(hdcBmp);

                    }
                    else
                    {
                        CMTRACE1(TEXT("BmpWndProc() CreateCompatibleDC() failed, GLE=%u."), GetLastError());
                    }


                    bRes = EndPaint(hwndBmp,&ps);

                    if (!bRes)
                    {
                        CMTRACE(TEXT("BmpWndProc() EndPaint() failed."));
                    }
                }
                else
                {
                    CMTRACE1(TEXT("BmpWndProc() BeginPaint() failed, GLE=%u."), GetLastError());
                }

            }
            break;

        case STM_SETIMAGE:
            if (wParam == IMAGE_BITMAP) 
            {
                CMTRACE2(TEXT("STM_SETIMAGE: wParam=%u, lParam=%u"), wParam, lParam);

                //
                // lParam contains a handle to the bitmap data, store it in extra bytes
                // 

                SetWindowLongU(hwndBmp,0, lParam); // pBmpData

                CMTRACE2(TEXT("SetWindowLongU called with hwndBmp = %u, lParam=%u"), hwndBmp, lParam);

                //
                // Force a repaint
                //

                bRes = InvalidateRect(hwndBmp,NULL,TRUE);

                CMTRACE2(TEXT("InvalidateRect called with hwndBmp = %u, lParam=%u"), hwndBmp, lParam);

#ifdef DEBUG
                if (!bRes)
                {
                    CMTRACE(TEXT("BmpWndProc() InvalidateRect() failed."));
                }
#endif              
                if (pBmpData && pBmpData->hDDBitmap) 
                {
                    return ((LRESULT) pBmpData->hDDBitmap);
                }
                else
                {
                    return NULL;
                }
            }
            break;
    }
    return (DefWindowProcU(hwndBmp,uMsg,wParam,lParam));
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryNewPalette
//
//  Synopsis:   Helper function to encapsulate handling of WM_QUERYNEWPALETTE
//                          
//  Arguments:  hwndDlg     - Handle of the dialog receiving the message
//              lpBmpData   - Struct containing handles for bmp to display
//              iBmpCtrl    - Bitmap control ID
//
//  Returns:    Nothing
//
//  History:    a-nichb - Created - 7/14/97
//
//----------------------------------------------------------------------------
void QueryNewPalette(LPBMPDATA lpBmpData, HWND hwndDlg, int iBmpCtrl)
{
    MYDBGASSERT(lpBmpData);

    if (lpBmpData)
    {
        //
        // We just handle this as a standard palette change because we
        // want to ensure that we create a new DDB using a palette based
        // upon our bitmap.
        //
                
        PaletteChanged(lpBmpData, hwndDlg, iBmpCtrl);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   PaletteChanged
//
//  Synopsis:   Helper function to encapsulate handling of WM_PALETTECHANGED
//                          
//  Arguments:  hwndDlg     - Handle of the dialog receiving the message
//              lpBmpData   - Struct containing handles for bmp to display
//              iBmpCtrl    - Bitmap control ID
//
//  Returns:    Nothing
//
//  History:    a-nichb - Created - 7/14/97
//
//----------------------------------------------------------------------------
void PaletteChanged(LPBMPDATA lpBmpData, HWND hwndDlg, int iBmpCtrl)
{   
    MYDBGASSERT(lpBmpData);

    if (NULL == lpBmpData || NULL == lpBmpData->phMasterPalette)
    {
        return;
    }

    //
    // Unrealize the master palette if it exists
    //
       
    if (*lpBmpData->phMasterPalette)
    {
        UnrealizeObject(*lpBmpData->phMasterPalette);
    }

    //
    // Create a device dependent bitmap and appropriate palette
    //

    if (CreateBitmapData(lpBmpData->hDIBitmap, lpBmpData, hwndDlg, TRUE))
    {        
        //
        // SetImage to update handles for painting and force draw
        //

        HBITMAP hbmpTmp = (HBITMAP) SendDlgItemMessageA(hwndDlg, iBmpCtrl, STM_SETIMAGE,
                                               IMAGE_BITMAP,(LPARAM) lpBmpData);
#ifdef DEBUUG
                if (!hbmpTmp)
                {
                    CMTRACE(TEXT("PaletteChanged().WM_PALETTECHANGED - STM_SETIMAGE returned NULL."));
                }
#endif

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\inc\wizdebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME
#endif  // SZ_COMPNAME

static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
	if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
	    break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  
    va_list args;

    va_start(args,pszMsg);
    wvsprintf(ach, pszMsg, args);
    //wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
	DebugBreak();
	//_asm {int 3};
}

//#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  DebugBreak(); } }
//#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  DebugBreak(); } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP       _DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\cmexitwin.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmexitwin.cpp
//
// Module:   Common Code
//
// Synopsis: Implements the function MyExitWindowsEx.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb    Created Heaser   08/19/99
//
//+----------------------------------------------------------------------------
#include <windows.h>

BOOL MyExitWindowsEx(UINT uFlags, 
                     DWORD dwRsvd) 
{
    BOOL bRes;

    //
    // If platform is NT, we will have to adjust privileges before rebooting
    //
    if (OS_NT)
    {
        HANDLE hToken;              // handle to process token 
        TOKEN_PRIVILEGES tkp;       // ptr. to token structure 
 

        //
        // Get the current process token handle 
        // so we can get shutdown privilege. 
        // 
        if (!OpenProcessToken(GetCurrentProcess(), 
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                                &hToken)) 
        {
            CMTRACE1(TEXT("MyExitWindowsEx() OpenThreadToken() failed, GLE=%u."), GetLastError());
            return FALSE;
        }
 
    
        //
        // Get the LUID for shutdown privilege
        //
        bRes = LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
                                    &tkp.Privileges[0].Luid);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("MyExitWindowsEx() LookupPrivilegeValue() failed, GLE=%u."), GetLastError());
        }
#endif
        tkp.PrivilegeCount = 1;  
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
 
        
        //
        //  Get shutdown privilege for this process
        //
        AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
                                        (PTOKEN_PRIVILEGES) NULL, 0); 
 
        //
        // Cannot reliably test the return value of AdjustTokenPrivileges
        //
        if (GetLastError() != ERROR_SUCCESS)
        {
            CMTRACE1(TEXT("MyExitWindowsEx() AdjustTokenPrivileges() failed, GLE=%u."), GetLastError());

            CloseHandle(hToken);
            return FALSE;
        }
        
        CloseHandle(hToken);
    }
    
    bRes = ExitWindowsEx(uFlags,dwRsvd);
#ifdef DEBUG
    if (!bRes)
    {
        CMTRACE1(TEXT("MyExitWindowsEx() ExitWindowsEx() failed, GLE=%u."), GetLastError());
    }
#endif

    return (bRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\dumpsecinfo.cpp ===
//+----------------------------------------------------------------------------
//
// File:     DumpSecInfo.cpp
//
// Module:   as required
//
// Synopsis: Functions to help figure out Permissions issues.  To fix "NULL DACL"
//           security issues, or try and figure out permissions bugs, this module
//           may be useful.  Entry point is DumpAclInfo.
//
// Copyright (c) 1998-2001 Microsoft Corporation
//
// Author:   SumitC     Created     18-Dec-2000
//
//+----------------------------------------------------------------------------

#include "winbase.h"
#include "sddl.h"

//
//  support for dynamically loading Advapi32 Security functions
//

HMODULE g_hAdvapi32 = NULL;

typedef BOOL (WINAPI *pfnLookupAccountSid) (LPCWSTR, PSID, LPWSTR, LPDWORD, LPWSTR, LPDWORD, PSID_NAME_USE);
typedef BOOL (WINAPI *pfnGetUserObjectSecurity) (HANDLE, PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, LPDWORD);
typedef BOOL (WINAPI *pfnConvertSidToStringSid) (PSID, LPWSTR*);
typedef BOOL (WINAPI *pfnGetSecurityDescriptorOwner) (PSECURITY_DESCRIPTOR, PSID *, LPBOOL);
typedef BOOL (WINAPI *pfnGetSecurityDescriptorSacl) (PSECURITY_DESCRIPTOR, LPBOOL, PACL *, LPBOOL);
typedef BOOL (WINAPI *pfnGetSecurityDescriptorDacl) (PSECURITY_DESCRIPTOR, LPBOOL, PACL *, LPBOOL);
typedef BOOL (WINAPI *pfnGetAce) (PACL, DWORD, LPVOID *);

pfnLookupAccountSid             g_pfnLookupAccountSid = NULL;
pfnGetUserObjectSecurity        g_pfnGetUserObjectSecurity = NULL;
pfnConvertSidToStringSid        g_pfnConvertSidToStringSid = NULL;
pfnGetSecurityDescriptorOwner   g_pfnGetSecurityDescriptorOwner = NULL;
pfnGetSecurityDescriptorSacl    g_pfnGetSecurityDescriptorSacl = NULL;
pfnGetSecurityDescriptorDacl    g_pfnGetSecurityDescriptorDacl = NULL;
pfnGetAce                       g_pfnGetAce = NULL;

//+----------------------------------------------------------------------------
//
// Function:  GetSidType
//
// Synopsis:  Returns the string corresponding to a given SID type
//
// Arguments: [i] -- index representing the SID
//
// Returns:   LPTSTR - static string containing a displayable Sid type
//
// Notes:
//
//-----------------------------------------------------------------------------
LPTSTR GetSidType(int i)
{
    static LPTSTR szMap[] =
        {
            TEXT("User"),
            TEXT("Group"),
            TEXT("Domain"),
            TEXT("Alias"),
            TEXT("WellKnownGroup"),
            TEXT("DeletedAccount"),
            TEXT("Invalid"),
            TEXT("Unknown"),
            TEXT("Computer")
        };

    if (i >= 1 && i <= 9)
    {
        return szMap[i - 1];
    }
    else
    {
        return TEXT("");
    }

}


//+----------------------------------------------------------------------------
//
// Function:  DumpSid
//
// Synopsis:  returns information for a give SID
//
// Arguments: [psid]      -- ptr to SecurityID
//            [pszBuffer] -- where to return SID string (caller must free)
//
// Returns:   LPTSTR - ptr to pszBuffer if success, NULL if failure
//
// Notes:
//
//-----------------------------------------------------------------------------
LPTSTR DumpSid(PSID psid, LPTSTR pszBuffer)
{
    LPTSTR          pszSID = NULL;
    TCHAR           szName[MAX_PATH + 1];
    DWORD           cbName = MAX_PATH;
    TCHAR           szDomain[MAX_PATH + 1];
    DWORD           cbDomain = MAX_PATH;
    SID_NAME_USE    snu;
    BOOL            fDone = FALSE;

    CMASSERTMSG(pszBuffer, TEXT("DumpSid - pszBuffer must be allocated by caller"));

    if (g_pfnConvertSidToStringSid(psid, &pszSID) &&
        g_pfnLookupAccountSid(NULL, psid, szName, &cbName, szDomain, &cbDomain, &snu))
    {
        wsprintf(pszBuffer, TEXT("%s\\%s %s %s"), szDomain, szName, GetSidType(snu), pszSID);
        // looks like NTDEV\sumitc User xxxx-xxx-xxx-xxx
        fDone = TRUE;
    }

    if (pszSID)
    {
        LocalFree(pszSID);
    }

    return fDone ? pszBuffer : NULL;
}


//+----------------------------------------------------------------------------
//
// Function:  DumpAclInfo
//
// Synopsis:  Dumps out all ACL info for a given object
//
// Arguments: [h] -- handle to object about which info is needed
//
// Returns:   (void)
//
// Notes:
//
//-----------------------------------------------------------------------------
void DumpAclInfo(HANDLE h)
{
    if (!OS_NT)
    {
        CMTRACE(TEXT("DumpAclInfo will not work on 9x systems"));
        return;
    }

    TCHAR szBuf[MAX_PATH];
    SECURITY_INFORMATION si = 0;

    //
    //  dynamically pick up the DLLs we need
    //
    g_hAdvapi32 = LoadLibrary(TEXT("ADVAPI32.DLL"));

    if (NULL == g_hAdvapi32)
    {
        CMTRACE(TEXT("DumpAclInfo: failed to load advapi32.dll"));
        return;
    }

    g_pfnLookupAccountSid =             (pfnLookupAccountSid) GetProcAddress(g_hAdvapi32, "LookupAccountSidW");
    g_pfnGetUserObjectSecurity =        (pfnGetUserObjectSecurity) GetProcAddress(g_hAdvapi32, "GetUserObjectSecurity");
    g_pfnConvertSidToStringSid =        (pfnConvertSidToStringSid) GetProcAddress(g_hAdvapi32, "ConvertSidToStringSidW");
    g_pfnGetSecurityDescriptorOwner =   (pfnGetSecurityDescriptorOwner) GetProcAddress(g_hAdvapi32, "GetSecurityDescriptorOwner");
    g_pfnGetSecurityDescriptorSacl =    (pfnGetSecurityDescriptorSacl) GetProcAddress(g_hAdvapi32, "GetSecurityDescriptorSacl");
    g_pfnGetSecurityDescriptorDacl =    (pfnGetSecurityDescriptorDacl) GetProcAddress(g_hAdvapi32, "GetSecurityDescriptorDacl");
    g_pfnGetAce =                       (pfnGetAce) GetProcAddress(g_hAdvapi32, "GetAce");
    
    if (!(g_pfnLookupAccountSid && g_pfnGetUserObjectSecurity &&
          g_pfnConvertSidToStringSid && g_pfnGetSecurityDescriptorOwner &&
          g_pfnGetSecurityDescriptorSacl && g_pfnGetSecurityDescriptorDacl &&
          g_pfnGetAce))
    {
        CMTRACE(TEXT("DumpAclInfo: failed to load required functions in advapi32.dll"));
        goto Cleanup;        
    }

    //
    // dump information on the ACL
    //
    DWORD dw;

    si |= OWNER_SECURITY_INFORMATION;
    si |= DACL_SECURITY_INFORMATION;

    if (!g_pfnGetUserObjectSecurity(h, &si, NULL, 0, &dw) &&
        ERROR_INSUFFICIENT_BUFFER == GetLastError())
    {
        PSECURITY_DESCRIPTOR pSD = NULL;

        pSD = (PSECURITY_DESCRIPTOR) CmMalloc(dw);

        if (g_pfnGetUserObjectSecurity(h, &si, pSD, dw, &dw))
        {
            // get the owner
            PSID psidOwner;
            BOOL fDefaulted;

            if (g_pfnGetSecurityDescriptorOwner(pSD, &psidOwner, &fDefaulted))
            {
                CMTRACE1(TEXT("SIDINFO: Owner is: %s"), DumpSid(psidOwner, szBuf));
            }

            PACL pacl;
            BOOL fPresent;
            int i;

            g_pfnGetSecurityDescriptorSacl(pSD, &fPresent, &pacl, &fDefaulted);
            CMTRACE1(TEXT("sacl gle=%d"), GetLastError());
            if (fPresent)
            {
                CMTRACE(TEXT("SIDINFO: found a SACL"));
                // has a SACL
                void * pv;
                for (i = 0 ; i < 15; ++i)
                {
                    if (g_pfnGetAce(pacl, i, &pv))
                    {
                        // try access allowed ace
                        //
                        ACCESS_ALLOWED_ACE * pACE = (ACCESS_ALLOWED_ACE *)pv;
                        if (pACE->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
                        {
                            CMTRACE1(TEXT("SIDINFO: allowed is: %s"), DumpSid(&(pACE->SidStart), szBuf));
                        }
                        else
                        {
                            ACCESS_DENIED_ACE * pACE = (ACCESS_DENIED_ACE *)pv;
                            if (pACE->Header.AceType == ACCESS_DENIED_ACE_TYPE)
                            {
                                CMTRACE1(TEXT("SIDINFO: denied is: %s"), DumpSid(&(pACE->SidStart), szBuf));
                            }
                        }
                    }
                }
            }

            g_pfnGetSecurityDescriptorDacl(pSD, &fPresent, &pacl, &fDefaulted);
            CMTRACE1(TEXT("dacl gle=%d"), GetLastError());
            if (fPresent)
            {
                CMTRACE(TEXT("SIDINFO: found a DACL"));
                // has a DACL
                void * pv;
                for (i = 0 ; i < 15; ++i)
                {
                    if (g_pfnGetAce(pacl, i, &pv))
                    {
                        // try access allowed ace
                        //
                        ACCESS_ALLOWED_ACE * pACE = (ACCESS_ALLOWED_ACE *)pv;
                        if (pACE->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
                        {
                            CMTRACE1(TEXT("SIDINFO: allowed is: %s"), DumpSid(&(pACE->SidStart), szBuf));
                        }
                        else
                        {
                            ACCESS_DENIED_ACE * pACE = (ACCESS_DENIED_ACE *)pv;
                            if (pACE->Header.AceType == ACCESS_DENIED_ACE_TYPE)
                            {
                                CMTRACE1(TEXT("SIDINFO: denied is: %s"), DumpSid(&(pACE->SidStart), szBuf));
                            }
                        }
                    }
                }
            }
        }
        CmFree(pSD);
    }

Cleanup:

    if (g_hAdvapi32)
    {
        FreeLibrary(g_hAdvapi32);
        g_hAdvapi32 = NULL;
        
        g_pfnLookupAccountSid = NULL;
        g_pfnGetUserObjectSecurity = NULL;
        g_pfnConvertSidToStringSid = NULL;
        g_pfnGetSecurityDescriptorOwner = NULL;
        g_pfnGetSecurityDescriptorSacl = NULL;
        g_pfnGetSecurityDescriptorDacl = NULL;
        g_pfnGetAce = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\getmodulever.cpp ===
//+----------------------------------------------------------------------------
//
// File:     getmodulever.cpp
//
// Module:   CMSETUP.LIB, CMUTIL.DLL
//
// Synopsis: Implementation of the GetModuleVersionAndLCID function.
//
// Copyright (c) 1998-2001 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------

#include "cmutil.h"

//+----------------------------------------------------------------------------
//
// Function:  GetModuleVersionAndLCID
//
// Synopsis:  Gets the version information and LCID from the specified module
//
// Arguments: LPTSTR pszFile - Full path to the file to get the version number of
//            LPDWORD pdwVersion - version number (Hiword Major, Loword Minor)
//            LPDWORD pdwBuild - build number (Hiword Major, Loword Minor)
//            LPDWORD pdwLCID - returns the Locale ID that the module was localized too
//
// Returns:   HRESULT -- S_OK if successful, an error code otherwise
//
// History:   quintinb -- Code borrowed from Yoshifumi "Vogue" Inoue 
//                        from (private\admin\wsh\host\verutil.cpp).
//                        Rewritten to match our coding style.      9/14/98
//            17-Oct-2000 SumitC    cleanup, fixed leaks, moved to common\source
//
// Notes:     There are 2 versions of this function, which take ANSI and Unicode
//            versions of the pszFile argument.
//
//+----------------------------------------------------------------------------
HRESULT GetModuleVersionAndLCID (LPSTR pszFile, LPDWORD pdwVersion, LPDWORD pdwBuild, LPDWORD pdwLCID)
{
    HRESULT hr = S_OK;
    HANDLE  hHeap = NULL;
    LPVOID  pData = NULL;
    DWORD   dwHandle;
    DWORD   dwLen;
    
    if ((NULL == pdwVersion) || (NULL == pdwBuild) || (NULL == pdwLCID) ||
        (NULL == pszFile) || (TEXT('\0') == pszFile))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pdwVersion = 0;
    *pdwBuild = 0;
    *pdwLCID = 0;

    dwLen = GetFileVersionInfoSizeA(pszFile, &dwHandle);
    if (0 == dwLen)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    
    hHeap = GetProcessHeap();
    if (NULL == hHeap)
    {
        hr = E_POINTER;
        CMASSERTMSG(FALSE, TEXT("GetModuleVersionAndLCID -- couldn't get a handle to the process heap."));
        goto Cleanup;
    }
    
    pData = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwLen);   

    if (!pData)
    {
        hr = E_OUTOFMEMORY;
        CMASSERTMSG(FALSE, TEXT("GetModuleVersionAndLCID -- couldn't alloc on the process heap."));
        goto Cleanup;
    }

    if (!GetFileVersionInfoA(pszFile, dwHandle, dwLen, pData))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    VS_FIXEDFILEINFO* pVerInfo;
    LPVOID pInfo;
    UINT nLen;

    if (!VerQueryValueA(pData, "\\", &pInfo, &nLen))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pVerInfo = (VS_FIXEDFILEINFO*) pInfo;

    *pdwVersion = pVerInfo->dwProductVersionMS;
    *pdwBuild = pVerInfo->dwProductVersionLS;

    //
    //  Now get the language the binary was compiled for
    //
    typedef struct _LANGANDCODEPAGE
    {
      WORD wLanguage;
      WORD wCodePage;
    } LangAndCodePage;

    nLen = 0;
    LangAndCodePage* pTranslate = NULL;

    if (!VerQueryValueA(pData, "\\VarFileInfo\\Translation", (PVOID*)&pTranslate, &nLen))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    //  Let's assert that we only got one LangAndCodePage struct back.  We technically
    //  could get more than one back but we certainly aren't expecting more than one.  If we
    //  get more than one, use the first one as the language of the dll.
    //
    MYDBGASSERT(1 == (nLen/sizeof(LangAndCodePage)));

    if ((nLen/sizeof(LangAndCodePage)) >= 1)
    {
        *pdwLCID = pTranslate[0].wLanguage;
    }

Cleanup:
    if (hHeap)
    {
        HeapFree(hHeap, 0, pData);
    }

    return hr;
}


//+----------------------------------------------------------------------------
//  This is the Unicode version of GetModuleVersionAndLCID (the first arg is LPWSTR)
//  and it just calls the Ansi version above.
//+----------------------------------------------------------------------------
HRESULT GetModuleVersionAndLCID (LPWSTR pszFile, LPDWORD pdwVersion, LPDWORD pdwBuild, LPDWORD pdwLCID)
{
    CHAR pszAnsiFileName[MAX_PATH + 1];

    if (WideCharToMultiByte(CP_ACP, 0, pszFile, -1, pszAnsiFileName, MAX_PATH, NULL, NULL))
    {
        return GetModuleVersionAndLCID(pszAnsiFileName, pdwVersion, pdwBuild, pdwLCID);
    }

    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\getpbk.cpp ===
//+----------------------------------------------------------------------------
//
// File:     getpbk.cpp
//
// Module:   Common Code
//
// Synopsis: Implements the function GetPhoneBookPath.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb    Created Heaser   08/19/99
//
//+----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function:  AllocateSecurityDescriptorAllowAccessToWorld
//
// Synopsis:  This function allocates a security descriptor for all users.
//            This function was taken directly from RAS when they create their
//            phonebook. This has to be before GetPhoneBookPath otherwise it 
//            causes compile errors in other components since we don't have a
//            function prototype anywhere and cmcfg just includes this (getpbk.cpp)
//            file. This function is also in cmdial\ras.cpp
//
// Arguments: PSECURITY_DESCRIPTOR *ppSd - Pointer to a pointer to the SD struct
//
// Returns:   DWORD - returns ERROR_SUCCESS if successfull
//
// History:   06/27/2001    tomkel  Taken from RAS ui\common\pbk\file.c
//
//+----------------------------------------------------------------------------
#define SIZE_ALIGNED_FOR_TYPE(_size, _type) \
    (((_size) + sizeof(_type)-1) & ~(sizeof(_type)-1))

DWORD AllocateSecurityDescriptorAllowAccessToWorld(PSECURITY_DESCRIPTOR *ppSd)
{
    PSECURITY_DESCRIPTOR    pSd;
    PSID                    pSid;
    PACL                    pDacl;
    DWORD                   dwErr = ERROR_SUCCESS;
    DWORD                   dwAlignSdSize;
    DWORD                   dwAlignDaclSize;
    DWORD                   dwSidSize;
    PVOID                   pvBuffer;
    DWORD                   dwAcls = 0;

    // Here is the buffer we are building.
    //
    //   |<- a ->|<- b ->|<- c ->|
    //   +-------+--------+------+
    //   |      p|      p|       |
    //   | SD   a| DACL a| SID   |
    //   |      d|      d|       |
    //   +-------+-------+-------+
    //   ^       ^       ^
    //   |       |       |
    //   |       |       +--pSid
    //   |       |
    //   |       +--pDacl
    //   |
    //   +--pSd (this is returned via *ppSd)
    //
    //   pad is so that pDacl and pSid are aligned properly.
    //
    //   a = dwAlignSdSize
    //   b = dwAlignDaclSize
    //   c = dwSidSize
    //

    if (NULL == ppSd)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize output parameter.
    //
    *ppSd = NULL;

    // Compute the size of the SID.  The SID is the well-known SID for World
    // (S-1-1-0).
    //
    dwSidSize = GetSidLengthRequired(1);

    // Compute the size of the DACL.  It has an inherent copy of SID within
    // it so add enough room for it.  It also must sized properly so that
    // a pointer to a SID structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignDaclSize = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(ACCESS_ALLOWED_ACE) + sizeof(ACL) + dwSidSize,
                        PSID);

    // Compute the size of the SD.  It must be sized propertly so that a
    // pointer to a DACL structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignSdSize   = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(SECURITY_DESCRIPTOR),
                        PACL);

    // Allocate the buffer big enough for all.
    //
    dwErr = ERROR_OUTOFMEMORY;
    pvBuffer = CmMalloc(dwSidSize + dwAlignDaclSize + dwAlignSdSize);
    if (pvBuffer)
    {
        SID_IDENTIFIER_AUTHORITY SidIdentifierWorldAuth
                                    = SECURITY_WORLD_SID_AUTHORITY;
        PULONG  pSubAuthority;

        dwErr = NOERROR;

        // Setup the pointers into the buffer.
        //
        pSd   = pvBuffer;
        pDacl = (PACL)((PBYTE)pvBuffer + dwAlignSdSize);
        pSid  = (PSID)((PBYTE)pDacl + dwAlignDaclSize);

        // Initialize pSid as S-1-1-0.
        //
        if (!InitializeSid(
                pSid,
                &SidIdentifierWorldAuth,
                1))  // 1 sub-authority
        {
            dwErr = GetLastError();
            goto finish;
        }

        pSubAuthority = GetSidSubAuthority(pSid, 0);
        *pSubAuthority = SECURITY_WORLD_RID;

        // Initialize pDacl.
        //
        if (!InitializeAcl(
                pDacl,
                dwAlignDaclSize,
                ACL_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        dwAcls = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;

        dwAcls &= ~(WRITE_DAC | WRITE_OWNER);
        
        if(!AddAccessAllowedAce(
                pDacl,
                ACL_REVISION,
                dwAcls,
                pSid))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Initialize pSd.
        //
        if (!InitializeSecurityDescriptor(
                pSd,
                SECURITY_DESCRIPTOR_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set pSd to use pDacl.
        //
        if (!SetSecurityDescriptorDacl(
                pSd,
                TRUE,
                pDacl,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the owner for pSd.
        //
        if (!SetSecurityDescriptorOwner(
                pSd,
                NULL,
                TRUE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the group for pSd.
        //
        if (!SetSecurityDescriptorGroup(
                pSd,
                NULL,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

finish:
        if (!dwErr)
        {
            *ppSd = pSd;
        }
        else
        {
            CmFree(pvBuffer);
        }
    }

    return dwErr;
}


//+----------------------------------------------------------------------------
//
// Function:  GetPhoneBookPath
//
// Synopsis:  This function will return the proper path to the phonebook.  If
//            used on a legacy platform this is NULL.  On NT5, the function
//            depends on the proper Install Directory being inputted so that
//            the function can use this as a base to determine the phonebook path.
//            If the inputted pointer to a string buffer is filled with a path,
//            then the directory path will be created as will the pbk file itself.
//            The caller should always call CmFree on the pointer passed into this
//            API when done with the path, because it will either free the memory 
//            or do nothing (NULL case).
//
// Arguments: LPCTSTR pszInstallDir - path to the CM profile dir
//            LPTSTR* ppszPhoneBook - pointer to accept a newly allocated and filled pbk string
//            BOOL fAllUser         - TRUE if this an All-User profile
//
// Returns:   BOOL - returns TRUE if successful
//
// History:   quintinb Created    11/12/98
//            tomkel   06/28/2001   Changed the ACLs when the phonebook gets 
//                                  createdfor an All-User profile
//
//+----------------------------------------------------------------------------
BOOL GetPhoneBookPath(LPCTSTR pszInstallDir, LPTSTR* ppszPhonebook, BOOL fAllUser)
{

    if (NULL == ppszPhonebook)
    {
        CMASSERTMSG(FALSE, TEXT("GetPhoneBookPath -- Invalid Parameter"));
        return FALSE;
    }

    CPlatform plat;

    if (plat.IsAtLeastNT5())
    {
        if ((NULL == pszInstallDir) || (TEXT('\0') == pszInstallDir[0]))
        {
            CMASSERTMSG(FALSE, TEXT("GetPhoneBookPath -- Invalid Install Dir parameter."));
            return FALSE;
        }

        //
        //  Now Create the path to the phonebook.
        //
        LPTSTR pszPhonebook;
        TCHAR szInstallDir[MAX_PATH+1];
        ZeroMemory(szInstallDir, CELEMS(szInstallDir));

        if (TEXT('\\') == pszInstallDir[lstrlen(pszInstallDir) - 1])
        {
            //
            //  Then the path ends in a backslash.  Thus we won't properly
            //  remove CM from the path.  Remove the backslash.
            //
            
            lstrcpyn(szInstallDir, pszInstallDir, lstrlen(pszInstallDir));
        }
        else
        {
            lstrcpy(szInstallDir, pszInstallDir);
        }

        CFileNameParts InstallDirPath(szInstallDir);

        pszPhonebook = (LPTSTR)CmMalloc(lstrlen(InstallDirPath.m_Drive) + 
                                        lstrlen(InstallDirPath.m_Dir) + 
                                        lstrlen(c_pszPbk) + lstrlen(c_pszRasPhonePbk) + 1);

        if (NULL != pszPhonebook)
        {
            wsprintf(pszPhonebook, TEXT("%s%s%s"), InstallDirPath.m_Drive, 
                InstallDirPath.m_Dir, c_pszPbk);

            //
            //  Use CreateLayerDirectory to recursively create the directory structure as
            //  necessary (will create all the directories in a full path if necessary).
            //

            MYVERIFY(FALSE != CreateLayerDirectory(pszPhonebook));

            MYVERIFY(NULL != lstrcat(pszPhonebook, c_pszRasPhonePbk));
            
            HANDLE hPbk = INVALID_HANDLE_VALUE;

            SECURITY_ATTRIBUTES sa = {0};
            PSECURITY_ATTRIBUTES pSA = NULL;
            PSECURITY_DESCRIPTOR pSd = NULL;

            if (fAllUser)
            {
                //
                // For an All-User profile be sure to create it with a 
                // security descriptor that  allows it to be read by any authenticated 
                // user.  If we don't it may  prevent other users from being able to 
                // read it. We didn't want to change the old behavior downlevel so this 
                // fix is just for Whistler+.
                //
                DWORD dwErr = AllocateSecurityDescriptorAllowAccessToWorld(&pSd);
                if ((ERROR_SUCCESS == dwErr) && pSd)
                {
                    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
                    sa.lpSecurityDescriptor = pSd;
                    sa.bInheritHandle = TRUE;
                    pSA = &sa;
                }
            }

            hPbk = CreateFile(pszPhonebook, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, pSA, CREATE_NEW,
                              FILE_ATTRIBUTE_NORMAL, NULL);

            CmFree(pSd);

            if (hPbk != INVALID_HANDLE_VALUE)
            {
                MYVERIFY(0 != CloseHandle(hPbk));
            }

            *ppszPhonebook = pszPhonebook;
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("CmMalloc returned NULL"));
            return FALSE;
        }    
    }
    else
    {
        *ppszPhonebook = NULL;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\allcmdir.cpp ===
//+----------------------------------------------------------------------------
//
// File:     allcmdir.cpp
//
// Module:   CMCFG32.DLL and CMSTP.EXE
//
// Synopsis: Implementation of GetAllUsersCmDir
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------



//+----------------------------------------------------------------------------
//
// Function:  GetAllUsersCmDir
//
// Synopsis:  This function fills in the string passed in with the path to the
//            path where CM should be installed.  For instance, it should return
//            c:\Documents and Settings\All Users\Application Data\Microsoft\Network\Connections\Cm
//
// Arguments: LPTSTR  pszDir - String to the Users Connection Manager Directory
//
// Returns:   LPTSTR - String to the Users Connection Manager Directory
//
// History:   quintinb Created Header    2/19/98
//
//+----------------------------------------------------------------------------
BOOL GetAllUsersCmDir(LPTSTR  pszDir, HINSTANCE hInstance)
{
    MYDBGASSERT(pszDir);
    pszDir[0] = TEXT('\0');

    LPMALLOC pMalloc;
    HRESULT hr = SHGetMalloc(&pMalloc);
    if (FAILED (hr))
    {
        CMASSERTMSG(FALSE, TEXT("Failed to get a Shell Malloc Pointer."));
        return FALSE;
    }

    TCHAR szCmSubFolder[MAX_PATH+1];
    TCHAR szAppData[MAX_PATH+1];
    TCHAR szDesktop[MAX_PATH+1];
    LPITEMIDLIST pidl;
    BOOL bReturn = FALSE;

    //
    //  We really want the Common App Data dir, but this CSIDL value is only supported on
    //  NT5 so far.  If this succeeds, we only need to append the path to it.
    //
    hr = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_APPDATA, &pidl);
    if (SUCCEEDED(hr))
    {
        if (!SHGetPathFromIDList(pidl, pszDir))
        {
            CMASSERTMSG(FALSE, TEXT("GetAllUsersCmDir -- SHGetPathFromIDList Failed to retrieve CSIDL_COMMON_APPDATA"));
            goto exit;
        }
        
        pMalloc->Free(pidl);
        pidl = NULL;
    }
    else
    {
        //
        //  Of course, things aren't always that easy, lets try getting the regular
        //  Application Data dir.  We can hopefully combine the returns from two
        //  CSIDL's like CSIDL_APPDATA and CSIDL_COMMON_DESKTOPDIRECTORY to acheive the
        //  same affect on older machines.
        //

        hr = SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidl);
        if (SUCCEEDED(hr))
        {
            if (!SHGetPathFromIDList(pidl, szAppData))
            {
                goto exit;
            }

            pMalloc->Free(pidl);
            pidl = NULL;
        }
        else
        {
            //
            //  CSIDL_APPDATA isn't even supported on win95 gold
            //
            MYVERIFY(0 != LoadString(hInstance, IDS_APPDATA, szAppData, MAX_PATH));
        }

        //
        //  Now lets try to get the Common Desktop Directory to combine the two
        //
        BOOL bCommonFound = FALSE;

        hr = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &pidl);
        if (SUCCEEDED(hr))
        {
            if (SHGetPathFromIDList(pidl, szDesktop))
            {
                bCommonFound = TRUE;
            }

            pMalloc->Free(pidl);
            pidl = NULL;
        }

        if (!bCommonFound)
        {
            //
            //  Okay, next lets try the Reg Key for the common desktop directory.
            //  (Win98 gold with profiling contains the reg key but the CSIDL fails)
            //
            const TCHAR* const c_pszRegShellFolders = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
            const TCHAR* const c_pszRegCommonDesktop = TEXT("Common Desktop");
            HKEY hKey;

            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegShellFolders, 
                0, KEY_READ, &hKey))
            {
                DWORD dwSize = MAX_PATH;
                DWORD dwType = REG_SZ;

                if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_pszRegCommonDesktop, 
                                                     NULL, &dwType, (LPBYTE)szDesktop, 
                                                     &dwSize))
                {
                    bCommonFound = TRUE;
                }
                RegCloseKey(hKey);
            }
        }

        if (!bCommonFound)
        {
            //
            //  As a fall back lets try the windows directory, NTRAID 374912
            //
            if (GetWindowsDirectory(szDesktop, MAX_PATH))
            {
                //
                //  Then we have the windows directory, but we need to append
                //  \\Desktop so that the parsing logic which follows parses
                //  this correctly.  It is expecting the path to the desktop dir
                //  not a path to the windows dir (if we didn't we would end up with
                //  c:\Application Data instead of c:\windows\Application data as we
                //  want and expect).  Note that there is no need to worry about 
                //  localization of Desktop because we are going to remove it anyway.
                //
                lstrcat(szDesktop, TEXT("\\Desktop"));
            }
        }

        CFileNameParts AppData(szAppData);
        CFileNameParts CommonDesktop(szDesktop);

        wsprintf(pszDir, TEXT("%s%s%s"), CommonDesktop.m_Drive, CommonDesktop.m_Dir, 
            AppData.m_FileName, AppData.m_Extension);
    }

    //
    //  Now append the CM sub directory structure
    //
    if (!LoadString(hInstance, IDS_CMSUBFOLDER, szCmSubFolder, MAX_PATH))
    {
        goto exit;
    }

    MYVERIFY(NULL != lstrcat(pszDir, szCmSubFolder));    

    bReturn = TRUE;

exit:
    //
    //  Free the allocated pidl if necessary
    //
    if (pidl)
    {
        pMalloc->Free(pidl);
    }

    //
    // release the shell's IMalloc ptr
    //
    pMalloc->Release();

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\gppswithalloc.cpp ===
//+----------------------------------------------------------------------------
//
// File:     gppswithalloc.cpp
//
// Module:   CMDIAL32.DLL, CMAK.EXE
//
// Synopsis: GetPrivateProfileStringWithAlloc and AddAllKeysInCurrentSectionToCombo
//           are implemented here
//
// Copyright (c) 2000-2001 Microsoft Corporation
//
// Author:   quintinb   Created    11/01/00
//
//+----------------------------------------------------------------------------

#ifndef _CMUTOA

#ifndef GetPrivateProfileStringU
    #ifdef UNICODE
    #define GetPrivateProfileStringU GetPrivateProfileStringW
    #else
    #define GetPrivateProfileStringU GetPrivateProfileStringA
    #endif
#endif

#ifndef lstrlenU
    #ifdef UNICODE
    #define lstrlenU lstrlenW
    #else
    #define lstrlenU lstrlenA
    #endif
#endif

#ifndef SendDlgItemMessageU
    #ifdef UNICODE
    #define SendDlgItemMessageU SendDlgItemMessageW
    #else
    #define SendDlgItemMessageU SendDlgItemMessageA
    #endif
#endif

#endif
//+---------------------------------------------------------------------------
//
//  Function:   GetPrivateProfileStringWithAlloc
//
//  Synopsis:   A wrapper function to encapsulate calling GetPrivateProfileString
//              with string allocation code so the caller doesn't have to worry
//              about buffer sizing.
//
//  Arguments:  LPCTSTR pszSection - section to retrieve the key from
//              LPCTSTR pszKey - keyname to retrieve the value of
//              LPCTSTR pszDefault - default value to use if the key isn't there
//              LPCTSTR pszFile - file to get the data from
//
//  Returns:    LPTSTR - string retrieved from the file or NULL on failure
//
//  History:    quintinb - Created - 11/01/00
//----------------------------------------------------------------------------
LPTSTR GetPrivateProfileStringWithAlloc(LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszDefault, LPCTSTR pszFile)
{
    if ((NULL == pszDefault) || (NULL == pszFile))
    {
        CMASSERTMSG(FALSE, TEXT("GetPrivateProfileStringWithAlloc -- null default or pszFile passed"));
        return NULL;
    }

    BOOL bExitLoop = FALSE;
    DWORD dwSize = MAX_PATH;
    DWORD dwReturnedSize;
    LPTSTR pszStringToReturn = NULL;

    pszStringToReturn = (TCHAR*)CmMalloc(dwSize*sizeof(TCHAR));

    do
    {
        MYDBGASSERT(pszStringToReturn);

        if (pszStringToReturn)
        {
            dwReturnedSize = GetPrivateProfileStringU(pszSection, pszKey, pszDefault, pszStringToReturn, 
                                                     dwSize, pszFile);

            if (((dwReturnedSize == (dwSize - 2)) && ((NULL == pszSection) || (NULL == pszKey))) ||
                ((dwReturnedSize == (dwSize - 1)) && ((NULL != pszSection) && (NULL != pszKey))))
            {
                //
                //  The buffer is too small, lets allocate a bigger one
                //
                dwSize = 2*dwSize;
                if (dwSize > 1024*1024)
                {
                    CMASSERTMSG(FALSE, TEXT("GetPrivateProfileStringWithAlloc -- Allocation above 1MB, bailing out."));
                    goto exit;
                }

                pszStringToReturn = (TCHAR*)CmRealloc(pszStringToReturn, dwSize*sizeof(TCHAR));

            }
            else if (0 == dwReturnedSize)
            {
                //
                //  Either we got an error, or more likely there was no data to get
                //
                CmFree(pszStringToReturn);
                pszStringToReturn = NULL;
                goto exit;
            }
            else
            {
                bExitLoop = TRUE;
            }
        }
        else
        {
           goto exit; 
        }

    } while (!bExitLoop);

exit:
    return pszStringToReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddAllKeysInCurrentSectionToCombo
//
//  Synopsis:   This function reads in all the keynames from the given section
//              and file name and populates them into the combo box specified
//              by the hDlg and uComboId params.
//
//  Arguments:  HWND hDlg - window handle of the dialog containing the combobox
//              UINT uComboId - control ID of the combobox
//              LPCTSTR pszSection - section to get the key names from
//              LPCTSTR pszFile - file to pull the key names from
//
//  Returns:    Nothing
//
//  History:    quintinb - Created - 11/01/00
//----------------------------------------------------------------------------
void AddAllKeysInCurrentSectionToCombo(HWND hDlg, UINT uComboId, LPCTSTR pszSection, LPCTSTR pszFile)
{
    if ((NULL == hDlg) || (0 == uComboId) || (NULL == pszFile))
    {
        CMASSERTMSG(FALSE, TEXT("AddAllKeysInCurrentSectionToCombo -- Invalid Parameter passed."));
        return;
    }

    //
    //  Reset the combobox contents
    //
    SendDlgItemMessageU(hDlg, uComboId, CB_RESETCONTENT, 0, 0); //lint !e534 CB_RESETCONTENT doesn't return anything useful

    //
    //  If the section is NULL, just reset the combobox contents and exit
    //
    if (NULL != pszSection)
    {
        //
        //  Lets get all of the keys in the current section
        //
        LPTSTR pszAllKeysInCurrentSection = GetPrivateProfileStringWithAlloc(pszSection, NULL, TEXT(""), pszFile);

        //
        //  Now process all of the keys in the current section
        //
        LPTSTR pszCurrentKey = pszAllKeysInCurrentSection;

        while (pszCurrentKey && TEXT('\0') != pszCurrentKey[0])
        {
            //
            //  Okay, lets add all of the keys that we found
            //

            MYVERIFY(CB_ERR!= SendDlgItemMessageU(hDlg, uComboId, CB_ADDSTRING, 0, (LPARAM)pszCurrentKey));

            //
            //  Advance to the next key in pszAllKeysInCurrentSection
            //
            pszCurrentKey = pszCurrentKey + lstrlenU(pszCurrentKey) + 1;
        }

        CmFree(pszAllKeysInCurrentSection);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\hasfileaccess.cpp ===
//+----------------------------------------------------------------------------
//
// Function:  HasSpecifiedAccessToFileOrDir
//
// Synopsis:  This function checks to see if the current user (or any of the groups
//            that the user belongs to) has the requested access to the given 
//            file or directory  object.  If the user has access then the function 
//            returns TRUE, otherwise FALSE.
//
// Arguments: LPTSTR pszFile - full path to the file or dir to check permissions for 
//            DWORD dwDesiredAccess - the desired access to check for
//
// Returns:   BOOL - TRUE if access is granted, FALSE otherwise
//
// History:   quintinb Created                                  7/21/99
//            quintinb Rewrote to use AccessCheck (389246)      08/18/99
//            quintinb made common to cmak and cmdial           03/03/00
//            quintinb Rewrote using CreateFile                 05/19/00
//
//+----------------------------------------------------------------------------
BOOL HasSpecifiedAccessToFileOrDir(LPTSTR pszFile, DWORD dwDesiredAccess)
{
    BOOL bReturn = FALSE;

    if (pszFile && (TEXT('\0') != pszFile[0]))
    {
        if (OS_NT)
        {
            //
            //  Use FILE_FLAG_BACKUP_SEMANTICS so that we can open directories as well as files.
            //
            HANDLE hFileOrDir = CreateFileU(pszFile, dwDesiredAccess, 
                                            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                                            OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
        
            if (INVALID_HANDLE_VALUE != hFileOrDir)
            {
                bReturn = TRUE;
                CloseHandle(hFileOrDir);
            }
        }
        else
        {
            //
            //  There is no NTFS on win9x and thus all users will have access.  Furthermore, FILE_FLAG_BACKUP_SEMANTICS
            //  isn't supported on win9x and thus CreateFile will return INVALID_HANDLE_VALUE.
            //

            LPSTR pszAnsiFile = WzToSzWithAlloc(pszFile);

            if (pszAnsiFile)
            {
                DWORD dwAttrib = GetFileAttributesA(pszAnsiFile);

                //
                //  Note that we are only checking for failure of the API (-1) and that the
                //  file is not marked Read only (+r).  I checked +s, +h, etc.  and found that
                //  only the read only attribute prevented CM from writing to the cmp.
                //
                bReturn = ((-1 != dwAttrib) && (0 == (FILE_ATTRIBUTE_READONLY & dwAttrib)));
            
                CmFree(pszAnsiFile);
            }
        }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\modelessdlg.cpp ===
//+----------------------------------------------------------------------------
//
// File:     modlessdlg.cpp
//
// Module:   CMDIAL32.DLL and CMMON32.EXE
//
// Synopsis: Implementation of the class CModelessDlg
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:   nickball    Created    03/22/00
//
//+----------------------------------------------------------------------------

#include "CmDebug.h"
#include "modelessdlg.h"

//
// Flash info.
//

typedef struct {
    UINT  cbSize;
    HWND  hwnd;
    DWORD dwFlags;
    UINT  uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;

#define FLASHW_STOP         0
#define FLASHW_CAPTION      0x00000001
#define FLASHW_TRAY         0x00000002
#define FLASHW_ALL          (FLASHW_CAPTION | FLASHW_TRAY)
#define FLASHW_TIMER        0x00000004
#define FLASHW_TIMERNOFG    0x0000000C

//+----------------------------------------------------------------------------
//
// Function:  CModelessDlg::Flash
//
// Synopsis:  Helper method to flash the modeless dialog. Currently 
//            hardwired to flash taskbar until window is in foreground.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball      Created     03/22/00
//
//+----------------------------------------------------------------------------
void CModelessDlg::Flash()
{
    //
    // Do the flash window thing, because SetForeGround window has 
    // been emasculated. We want the user to know something is up.
    //

    if (OS_NT5 || OS_W98) // no support on NT4 and 95
    {
        HINSTANCE hInst = LoadLibrary(TEXT("USER32"));

        if (hInst)
        {
            typedef BOOL (WINAPI* FlashWindowExFUNC) (PFLASHWINFO pfwi);
            
            FlashWindowExFUNC pfnFlashWindowEx = 
                (FlashWindowExFUNC) GetProcAddress(hInst, "FlashWindowEx");

            MYDBGASSERT(pfnFlashWindowEx);

            if (pfnFlashWindowEx)
            {
                FLASHWINFO fi;

                fi.cbSize = sizeof(fi);
                fi.hwnd   = m_hWnd;
                fi.dwFlags = FLASHW_TRAY | FLASHW_TIMERNOFG;
                fi.uCount  = -1;
                fi.dwTimeout = 0;

                pfnFlashWindowEx(&fi);
            }
            
            FreeLibrary(hInst);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CModelessDlg::Create
//
// Synopsis:  Same as CreateDialog
//
// Arguments: HINSTANCE hInstance - Same as CreateDialog
//            LPCTSTR lpTemplateName - 
//            HWND hWndParent - 
//
// Returns:   HWND - Same as CreateDialog
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
HWND CModelessDlg::Create(HINSTANCE hInstance, 
                    LPCTSTR lpTemplateName,
                    HWND hWndParent)
{
    m_hWnd = ::CreateDialogParamU(hInstance, lpTemplateName, hWndParent, 
                                  (DLGPROC)ModalDialogProc, (LPARAM)this);

#ifdef DEBUG
    if (!m_hWnd)
    {
        CMTRACE1(TEXT("CreateDialogParam failed. LastError %d"), GetLastError());
    }
#endif
    MYDBGASSERT(m_hWnd);

    return m_hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\mutex.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mutex.cpp
//
// Module:   Common Code
//
// Synopsis: Implementation of the class CNamedMutex
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created    02/26/98
//
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
// Function:  CNamedMutex::Lock
//
// Synopsis:  
//
// Arguments: LPCTSTR lpName - Name of the mutex
//            BOOL fWait - Whether caller want to wait, if mutex is not available
//                         Default is FALSE
//            DWORD dwMilliseconds - Timeout for wait, default is INFINITE
//            BOOL fNoAbandon - Don't acquire an abandoned mutex
//
// Returns:   BOOL - Whether the mutex is acquired, if TRUE, caller should call
//                   Unlock to release the lock.  Otherwise, the lock will be
//                   released in destructor
//
// History:   fengsun   Created Header    02/26/98
//            nickball  Added fNoAbandon  03/32/99
//
//+----------------------------------------------------------------------------
BOOL CNamedMutex::Lock(LPCTSTR lpName, BOOL fWait, DWORD dwMilliseconds, BOOL fNoAbandon)
{
    MYDBGASSERT(m_hMutex == NULL);
    MYDBGASSERT(lpName);

    m_fOwn = FALSE;

    CMTRACE1(TEXT("CNamedMutex::Lock() - Attempting to acquire mutex - %s"), lpName);

    m_hMutex = CreateMutexU(NULL,TRUE,lpName);
    MYDBGASSERT(m_hMutex);

    if (m_hMutex == NULL)
    {
        return FALSE;
    }

    DWORD dwRet = GetLastError();
    if (dwRet != ERROR_ALREADY_EXISTS) 
    {
        //
        // We got the mutex
        //
        m_fOwn = TRUE;
        return TRUE;
    }

    CMTRACE1(TEXT("CNamedMutex::Lock() - Mutex already exists - %s"), lpName);

    //
    // Someone else own the mutex
    //
    if (!fWait)  // caller does not want to wait
    {       
        CMTRACE1(TEXT("CNamedMutex::Lock() - Not waiting for mutex - %s"), lpName);
        CloseHandle(m_hMutex);
        m_hMutex = NULL;
        return FALSE;
    }

    //
    // Caller want to wait until the mutex is released
    //

    CMTRACE(TEXT("CNamedMutex::Lock() - Entering Mutex wait"));

    dwRet = WaitForSingleObject(m_hMutex, dwMilliseconds);

    switch (dwRet)
    {
        case WAIT_ABANDONED:
        
            CMTRACE1(TEXT("CNamedMutex::Lock() - Mutex was abandoned by previous owner - %s"), lpName);
            
            //
            // If the thread that owns a mutex is blown away, the wait will 
            // release with a return of WAIT_ABANDON. This typically happens
            // if the thread is dumped from memory, or someone doesn't clean 
            // up before terminating. Either way, the caller may not want to 
            // acquire an abandoned mutex, so just release it if that is what 
            // the caller specified and the wait returned.
            //

            if (fNoAbandon)
            {
                CMTRACE1(TEXT("CNamedMutex::Lock() - Releasing abandoned mutex- %s"), lpName);
                ReleaseMutex(m_hMutex);
                break;
            }
            
            //
            // Fall through to standard mutex acquisition
            //

        case WAIT_OBJECT_0:
    
            //
            // We get the mutex
            //

            m_fOwn = TRUE;
            CMTRACE1(TEXT("CNamedMutex::Lock() - Mutex acquired - %s"), lpName);
            return TRUE;
   
        default:       
            CMTRACE1(TEXT("CNamedMutex::Lock() - Mutex wait timed out - %s"), lpName);
            break;
    }

    CloseHandle(m_hMutex);
    m_hMutex = NULL;

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CNamedMutex::Unlock
//
// Synopsis:  Release the mutex
//
// Arguments: 
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/19/98
//
//+----------------------------------------------------------------------------
void CNamedMutex::Unlock()
{
    if (m_hMutex != NULL)
    {
        if (m_fOwn)
        {
	        ReleaseMutex(m_hMutex);
            m_fOwn = FALSE;
        }
    
        CloseHandle(m_hMutex);
        m_hMutex = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\modaldlg.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ModalDlg.cpp	 
//
// Module:   Connection manager
//
// Synopsis: Implementation of the classes CWindowWithHelp, CModalDlg
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created    02/17/98
//
//+----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::CWindowWithHelp
//
// Synopsis:  Constructor
//
// Arguments: const DWORD* pHelpPairs - The pairs of control-ID/Help-ID
//            const TCHAR* lpszHelpFile - The help file name, default is NULL
//                 Call also call SetHelpFileName() to provide help file
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
CWindowWithHelp::CWindowWithHelp(const DWORD* pHelpPairs, const TCHAR* lpszHelpFile) 
{
    m_lpszHelpFile = NULL;
    m_hWnd = NULL;
    m_pHelpPairs = pHelpPairs; 
    
    if (lpszHelpFile)
    {
        SetHelpFileName(lpszHelpFile);
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::~CWindowWithHelp
//
// Synopsis:  Destructor
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/20/98
//
//+----------------------------------------------------------------------------
CWindowWithHelp::~CWindowWithHelp()
{
    CmFree(m_lpszHelpFile);
}



//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::SetHelpFileName
//
// Synopsis:  Set the help file name of the window
//
// Arguments: const TCHAR* lpszHelpFile - the help file name to set
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
void CWindowWithHelp::SetHelpFileName(const TCHAR* lpszHelpFile)
{
    MYDBGASSERT(m_lpszHelpFile == NULL);
    MYDBGASSERT(lpszHelpFile);

    CmFree(m_lpszHelpFile);
    m_lpszHelpFile = NULL;

    if (lpszHelpFile && lpszHelpFile[0])
    {
        m_lpszHelpFile = CmStrCpyAlloc(lpszHelpFile);
        MYDBGASSERT(m_lpszHelpFile);
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::HasContextHelp
//
// Synopsis:  Whether a control has context help
//
// Arguments: HWND hWndCtrl - The window handle of the control
//
// Returns:   BOOL - TRUE , if the control has context help
//
// History:   fengsun Created Header    2/20/98
//
//+----------------------------------------------------------------------------
BOOL CWindowWithHelp::HasContextHelp(HWND hWndCtrl) const
{
    if (hWndCtrl == NULL || m_pHelpPairs == NULL)
    {
        return FALSE;
    }

    //
    // looks through the help pairs for the control 
    //
    for (int i=0; m_pHelpPairs[i]!=0; i+=2)
    {
        if (m_pHelpPairs[i] == (DWORD)GetDlgCtrlID(hWndCtrl))
        {
            CMTRACE3(TEXT("HasContextHelp() - hwndCtrl %d has Ctrl ID %d and context help ID %d"), hWndCtrl, m_pHelpPairs[i], m_pHelpPairs[i+1]);
            return TRUE;
        }
    }

    CMTRACE1(TEXT("HasContextHelp() - hwndCtrl %d has no context help"), hWndCtrl);

    return FALSE;
}


//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::OnHelp
//
// Synopsis:  Call on WM_HELP message. Which means F1 is pressed
//
// Arguments: const HELPINFO* pHelpInfo - lParam of WM_HELP
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
void CWindowWithHelp::OnHelp(const HELPINFO* pHelpInfo)
{
    //
    // If help file exist and the help id exist WinHelp
    //
    if (m_lpszHelpFile && m_lpszHelpFile[0] && HasContextHelp((HWND) pHelpInfo->hItemHandle))
    {
		CmWinHelp((HWND)pHelpInfo->hItemHandle, (HWND)pHelpInfo->hItemHandle, m_lpszHelpFile, HELP_WM_HELP, 
                (ULONG_PTR)(LPSTR)m_pHelpPairs);
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CWindowWithHelp::OnContextMenu
//
// Synopsis:  called upon WM_CONTEXTMENU message (Right click or '?')
//
// Arguments:  HWND hWnd - Handle to the window in which the user right clicked 
//                          the mouse 
//            POINT& pos - position of the cursor 
//
// Returns:   BOOL, TRUE if the message is processed
//
// History:   fengsun Created Header    2/17/98
//
//+----------------------------------------------------------------------------
BOOL CWindowWithHelp::OnContextMenu( HWND hWnd, POINT& pos )
{
    HWND    hWndChild;
    
    ScreenToClient(m_hWnd, &pos);

    //
    // If more than one child window contains the specified point, ChildWindowFromPoint() 
    // returns a handle to the first window in the list that contains the point. 
    // This becomes a problem if we have controls inside groupbox
    //
    if (m_lpszHelpFile && m_lpszHelpFile[0] && 
        HasContextHelp((hWndChild = ChildWindowFromPointEx(m_hWnd, pos,CWP_SKIPINVISIBLE))) )
    {
        CMTRACE2(TEXT("OnContextMenu() - Calling WinHelp hWnd is %d, m_hWnd is %d"), hWnd, m_hWnd);
        CmWinHelp(hWnd,hWndChild,m_lpszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)m_pHelpPairs);
        return TRUE;
    }

    return FALSE; // Return FALSE, DefaultWindowProc will handle this message then.
}

//+----------------------------------------------------------------------------
//
// Function:  CModalDlg::DoDialogBox
//
// Synopsis:  Same as DialogBox
//
// Arguments: HINSTANCE hInstance - Same as ::DialogBox
//            LPCTSTR lpTemplateName - 
//            HWND hWndParent - 
//
// Returns:   int - Same as DialogBox
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
INT_PTR CModalDlg::DoDialogBox(HINSTANCE hInstance, 
                    LPCTSTR lpTemplateName,
                    HWND hWndParent)
{
    INT_PTR iRet = ::DialogBoxParamU(hInstance, lpTemplateName, hWndParent, 
        (DLGPROC)ModalDialogProc, (LPARAM)this);

    m_hWnd = NULL;

    return iRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CModalDlg::ModalDialogProc
//
// Synopsis:  The dialog window procedure for all dialogbox derived
//
// Arguments: HWND hwndDlg - 
//            UINT uMsg - 
//            WPARAM wParam - 
//            LPARAM lParam - 
//
// Returns:   BOOL CALLBACK - 
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
BOOL CALLBACK CModalDlg::ModalDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    CModalDlg* pDlg;

    //
    // Save the object pointer on  WM_INITDIALOG
    // lParam is the pointer
    //
    if (uMsg == WM_INITDIALOG)
    {
        pDlg = (CModalDlg*) lParam;

        MYDBGASSERT(lParam);
        MYDBGASSERT(((CModalDlg*)lParam)->m_hWnd == NULL);

        //
        // Save the object pointer, this is implementation detail
        // The user of this class should not be aware of this
        //
        ::SetWindowLongU(hwndDlg, DWLP_USER, (LONG_PTR)lParam);

        pDlg->m_hWnd = hwndDlg;
    }
    else
    {
        pDlg = (CModalDlg*)GetWindowLongU(hwndDlg, DWLP_USER);

        //
        // some msgs can come before WM_INITDIALOG
        //
        if (pDlg == NULL)
        {
            return FALSE;
        }

    }

    MYDBGASSERT(pDlg->m_hWnd == hwndDlg);
    ASSERT_VALID(pDlg);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        return pDlg->OnInitDialog();

    case WM_HELP:
        pDlg->OnHelp((LPHELPINFO)lParam);
        return TRUE;

	case WM_CONTEXTMENU:
        {
            POINT   pos = {LOWORD(lParam), HIWORD(lParam)};
            return pDlg->OnContextMenu((HWND) wParam, pos);
        }

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            pDlg->OnOK();
            return FALSE;

        case IDCANCEL:
            pDlg->OnCancel();
            return FALSE;

        default:
            return pDlg->OnOtherCommand(wParam,lParam);
        }

     default:
         return pDlg->OnOtherMessage(uMsg, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\needsmig.cpp ===
//+----------------------------------------------------------------------------
//
// File:     needsmig.cpp
//
// Module:   CMCFG32.DLL AND CMSTP.EXE
//
// Synopsis: Implementation of the ProfileNeedsMigration function.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function:  ProfileNeedsMigration
//
// Synopsis:  This function determines if we need to migrate a profile or not.
//            Profiles that have the current Profile version format or greater
//            are not migrated.  Profiles that have an older version format that
//            have already been migrated (we look to see if the GUID is missing on
//            NT5 or if the Delete Entry exists on Down Level) don't need to
//            be migrated.
//
// Arguments: LPCTSTR pszPathToCmp - full path to the CMP file
//
// Returns:   BOOL - TRUE if the profile should be migrated or not
//
// History:   quintinb Created    11/20/98
//
//+----------------------------------------------------------------------------
BOOL ProfileNeedsMigration(LPCTSTR pszServiceName, LPCTSTR pszPathToCmp)
{
	//
	//	Open the CMP and check the version number.  If the profile format version
	//  is old then we need to migrate it.  
	//

	if ((NULL == pszServiceName) || (NULL == pszPathToCmp) || 
		(TEXT('\0') == pszServiceName[0]) || (TEXT('\0') == pszPathToCmp[0]))
	{
		return FALSE;
	}

	CPlatform plat;
	CFileNameParts FileParts(pszPathToCmp);

	int iCurrentCmpVersion = GetPrivateProfileInt(c_pszCmSectionProfileFormat, c_pszVersion, 
		0, pszPathToCmp);
	
	if (PROFILEVERSION > iCurrentCmpVersion)
	{
		//
		//  Now construct the path to the INF file (1.0 and 1.1 profiles kept the infs in 
		//  the system dir)
		//
		TCHAR szTemp[MAX_PATH+1];
		TCHAR szInfFile[MAX_PATH+1];
		TCHAR szGUID[MAX_PATH+1];
		HKEY hKey;

		MYVERIFY(0 != GetSystemDirectory(szTemp, MAX_PATH));

		MYVERIFY(CELEMS(szInfFile) > (UINT)wsprintf(szInfFile, TEXT("%s\\%s%s"), szTemp, 
			FileParts.m_FileName, TEXT(".inf")));

		if (!FileExists(szInfFile))
		{
			return FALSE;
		}

		//
		//  Get the GUID from the inf file.
		//
		ZeroMemory(szGUID, sizeof(szGUID));
		MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszDesktopGuid, TEXT(""), szGUID, 
			MAX_PATH, szInfFile));

		if (0 != szGUID[0])
		{
			MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, 
				TEXT("CLSID\\%s"), szGUID));

			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp, 0, 
				KEY_READ, &hKey))
			{
				//
				//	If this is NT5, then we need to migrate.  On Legacy we need to try to
				//  open the delete subkey.
				//
				RegCloseKey(hKey);
				if (plat.IsAtLeastNT5())
				{
					return TRUE;
				}
				else
				{
					MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, 
						TEXT("CLSID\\%s\\Shell\\Delete"), szGUID));
				
					if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szTemp, 0, 
						KEY_READ, &hKey))
					{
						//
						//	Already been migrated
						//
						RegCloseKey(hKey);
						return FALSE;
					}
					else
					{
						//
						//	Must Migrate the profile.
						//
						return TRUE;
					}
				}			
			}
			else
			{
				return FALSE;
			}
		}
		else
		{
			//
			//	This affects MSN, as long as we have true here their 1.0 stuff will
			//  get migrated.  If we don't want it to, change this.
			//
			return TRUE;
		}
	}
	else
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\pwutil.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pwutil.cpp
//
// Module:   Common Source
//
// Synopsis: Simple encryption funcs - borrowed from RAS
//
// Copyright (c) 1994-1999 Microsoft Corporation
//
// Author:   nickball    Created    08/03/99
//
//+----------------------------------------------------------------------------

#define PASSWORDMAGIC 0xA5

VOID
ReverseSzA(
    CHAR* psz )

    /* Reverses order of characters in 'psz'.
    */
{
    CHAR* pszBegin;
    CHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + lstrlenA( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        CHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}


VOID
ReverseSzW(
    WCHAR* psz )

    /* Reverses order of characters in 'psz'.
    */
{
    WCHAR* pszBegin;
    WCHAR* pszEnd;

    for (pszBegin = psz, pszEnd = psz + lstrlenW( psz ) - 1;
         pszBegin < pszEnd;
         ++pszBegin, --pszEnd)
    {
        WCHAR ch = *pszBegin;
        *pszBegin = *pszEnd;
        *pszEnd = ch;
    }
}


VOID
CmDecodePasswordA(
    IN OUT CHAR* pszPassword )

    /* Un-obfuscate 'pszPassword' in place.
    **
    ** Returns Nothing
    */
{
    CmEncodePasswordA( pszPassword );
}


VOID
CmDecodePasswordW(
    IN OUT WCHAR* pszPassword )

    /* Un-obfuscate 'pszPassword' in place.
    **
    ** Returns the address of 'pszPassword'.
    */
{
    CmEncodePasswordW( pszPassword );
}


VOID
CmEncodePasswordA(
    IN OUT CHAR* pszPassword )

    /* Obfuscate 'pszPassword' in place to foil memory scans for passwords.
    **
    ** Returns Nothing
    */
{
    if (pszPassword)
    {
        CHAR* psz;

        ReverseSzA( pszPassword );

        for (psz = pszPassword; *psz != '\0'; ++psz)
        {
            if (*psz != PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
        }
    }
}


VOID
CmEncodePasswordW(
    IN OUT WCHAR* pszPassword )

    /* Obfuscate 'pszPassword' in place to foil memory scans for passwords.
    **
    ** Returns Nothing
    */
{
    if (pszPassword)
    {
        WCHAR* psz;

        ReverseSzW( pszPassword );

        for (psz = pszPassword; *psz != L'\0'; ++psz)
        {
            if (*psz != PASSWORDMAGIC)
                *psz ^= PASSWORDMAGIC;
        }
    }
}


VOID
CmWipePasswordA(
    IN OUT CHAR* pszPassword )

    /* Zero out the memory occupied by a password.
    **
    ** Returns Nothing
    */
{
    if (pszPassword)
    {
        CHAR* psz = pszPassword;

        while (*psz != '\0')
            *psz++ = '\0';
    }
}


VOID
CmWipePasswordW(
    IN OUT WCHAR* pszPassword )

    /* Zero out the memory occupied by a password.
    **
    ** Returns Nothing
    */
{
    if (pszPassword)
    {
        WCHAR* psz = pszPassword;

        while (*psz != L'\0')
            *psz++ = L'\0';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\parseca.cpp ===
//
//  Profwiz.cpp doesn't use cmutoa but does include this function.  Thus we want the W versions instead of the
//  U versions for profwiz.
//
#ifndef _CMUTOA
#define CharNextU CharNextW
#define CharPrevU CharPrevW
#define lstrlenU lstrlenW
#define lstrcpyU lstrcpyW
#define lstrcpynU lstrcpynW
#endif

/*
//+----------------------------------------------------------------------------
//
// Function:  HrParseCustomActionString
//
// Synopsis:  This function takes a custom action string retrieved from a 
//            cms file and parses it into the various parts of a custom
//            action (program, parameters, function name)
//
// Arguments: LPTSTR pszStringToParse - custom action buffer to be parsed into
//                                      the various parts of a custom action
//            LPTSTR pszProgram - output buffer to hold the program string
//            LPTSTR pszParameters - output buffer to hold the parameters string
//            LPTSTR pszFunctionName - output buffer to hold the function name, if any
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT HrParseCustomActionString(LPTSTR pszStringToParse, LPTSTR pszProgram, LPTSTR pszParameters, LPTSTR pszFunctionName)
{
    if ((NULL == pszStringToParse) || (TEXT('\0') == pszStringToParse[0]) || (NULL == pszProgram) || 
        (NULL == pszParameters) || (NULL == pszFunctionName))
    {
        return E_INVALIDARG;
    }

    //
    //  Make sure the strings are blank in case we don't touch them (szFunctionName and szParameters especially)
    //
    pszProgram[0] = TEXT('\0');
    pszParameters[0] = TEXT('\0');
    pszFunctionName[0] = TEXT('\0');

    //
    // Here are the cases we need to handle:
    // 1) +longfilename+
    // 2) +longfilename+ params
    // 3) +longfilename+,dllfuncname
    // 4) +longfilename+,dllfuncname params
    // 5) filename
    // 6) filename params
    // 7) filename,dllfuncname
    // 8) filename,dllfuncname params

    //
    //  Walk the string to find the seperator chars
    //
    LPTSTR pszCurrent = pszStringToParse;
    LPTSTR pszFirstPlus = NULL;
    LPTSTR pszSecondPlus = NULL;
    LPTSTR pszFirstSpace = NULL;
    LPTSTR pszFirstComma = NULL;

    while (pszCurrent && (TEXT('\0') != *pszCurrent))
    {
        if ((TEXT('+') == *pszCurrent) && (NULL == pszFirstComma) && (NULL == pszFirstSpace))
        {
            //
            //  Keep track of the plus signs, unless we have already seen a space
            //  or a comma.  In which case these chars are in the parameters and
            //  meaningless to us.
            //
            if (NULL == pszFirstPlus)
            {
                pszFirstPlus = pszCurrent;
            }
            else if (NULL == pszSecondPlus)
            {
                pszSecondPlus = pszCurrent;
            }
        }
        else if ((TEXT(',') == *pszCurrent) && (NULL == pszFirstSpace))
        {
            //
            //  If we have already seen a space, then the comma is part of
            //  the parameters and meaningless to us.
            //
            pszFirstComma = pszCurrent;

        }
        else if ((TEXT(' ') == *pszCurrent))
        {
            if ((NULL == pszFirstPlus) && (NULL == pszFirstSpace))
            {
                //
                //  Then we have no plus signs and no previous space, save the space as
                //  it is the start of the parameters.
                //
                pszFirstSpace = pszCurrent;
            }
            else if (pszFirstPlus && pszSecondPlus && (NULL == pszFirstSpace))
            {
                //
                //  Then we have both plus signs but no space yet, grab it
                //  because this is the start of the parameters
                //
                pszFirstSpace = pszCurrent;
            }
        }
        pszCurrent = CharNextU(pszCurrent);

    }

    //
    //  From the markers we have, figure out the beginning and end of the program string
    //
    
    LPTSTR pszStartOfProgram = NULL;
    LPTSTR pszEndOfProgram = NULL;

    if (pszFirstPlus)
    {
        if (pszSecondPlus)
        {
            pszStartOfProgram = CharNextU(pszFirstPlus);
            pszEndOfProgram = CharPrevU(pszStringToParse, pszSecondPlus);
        }
        else
        {
            //
            //  We have a string with the first char as a plus sign but no second +.
            //  The format isn't correct.
            //
            CMASSERTMSG(FALSE, TEXT("CustomActionList::ParseCustomActionString - Incorrect format in the passed in string to parse, missing + sign."));
            return E_UNEXPECTED;
        }
    }
    else
    {
        pszStartOfProgram = pszStringToParse;

        if (pszFirstComma)
        {
            pszEndOfProgram = CharPrevU(pszStringToParse, pszFirstComma);
        }
        else if (pszFirstSpace)
        {
            pszEndOfProgram = CharPrevU(pszStringToParse, pszFirstSpace);
        }
        else
        {
            //
            //  Nothing in the string but the program
            //
            pszEndOfProgram = pszStringToParse + lstrlenU(pszStringToParse) - 1;
        }
    }

    //
    //  Now copy out the necessary parts
    //
 
    int iSize = (int)(pszEndOfProgram - pszStartOfProgram + 2);

    lstrcpynU(pszProgram, pszStartOfProgram, iSize);

    if (pszFirstComma)
    {
        if (pszFirstSpace)
        {
            iSize = (int)(pszFirstSpace - pszFirstComma);
            lstrcpynU(pszFunctionName, CharNextU(pszFirstComma), iSize);
        }
        else
        {
            lstrcpyU(pszFunctionName, CharNextU(pszFirstComma));
        }
    }
    
    if (pszFirstSpace)
    {
        lstrcpyU(pszParameters, CharNextU(pszFirstSpace));
    }

    return S_OK;
}
*/

//+----------------------------------------------------------------------------
//
// Function:  HrParseCustomActionString
//
// Synopsis:  This function takes a custom action string retrieved from a 
//            cms file and parses it into the various parts of a custom
//            action (program, parameters, function name)
//
// Arguments: LPTSTR pszStringToParse - custom action buffer to be parsed into
//                                      the various parts of a custom action
//            LPTSTR pszProgram - output buffer to hold the program string
//            LPTSTR pszParameters - output buffer to hold the parameters string
//            LPTSTR pszFunctionName - output buffer to hold the function name, if any
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT HrParseCustomActionString(LPTSTR pszStringToParse, LPTSTR* ppszProgram, LPTSTR* ppszParameters, LPTSTR* ppszFunctionName)
{
    if ((NULL == pszStringToParse) || (TEXT('\0') == pszStringToParse[0]) || (NULL == ppszProgram) || 
        (NULL == ppszParameters) || (NULL == ppszFunctionName))
    {
        return E_INVALIDARG;
    }

    //
    //  NULL out the string pointers to start with
    //
    *ppszProgram = NULL;
    *ppszParameters = NULL;
    *ppszFunctionName = NULL;

    //
    // Here are the cases we need to handle:
    // 1) +longfilename+
    // 2) +longfilename+ params
    // 3) +longfilename+,dllfuncname
    // 4) +longfilename+,dllfuncname params
    // 5) filename
    // 6) filename params
    // 7) filename,dllfuncname
    // 8) filename,dllfuncname params

    //
    //  Walk the string to find the seperator chars
    //
    LPTSTR pszCurrent = pszStringToParse;
    LPTSTR pszFirstPlus = NULL;
    LPTSTR pszSecondPlus = NULL;
    LPTSTR pszFirstSpace = NULL;
    LPTSTR pszFirstComma = NULL;

    while (pszCurrent && (TEXT('\0') != *pszCurrent))
    {
        if ((TEXT('+') == *pszCurrent) && (NULL == pszFirstComma) && (NULL == pszFirstSpace))
        {
            //
            //  Keep track of the plus signs, unless we have already seen a space
            //  or a comma.  In which case these chars are in the parameters and
            //  meaningless to us.
            //
            if (NULL == pszFirstPlus)
            {
                pszFirstPlus = pszCurrent;
            }
            else if (NULL == pszSecondPlus)
            {
                pszSecondPlus = pszCurrent;
            }
        }
        else if ((TEXT(',') == *pszCurrent) && (NULL == pszFirstSpace))
        {
            //
            //  If we have already seen a space, then the comma is part of
            //  the parameters and meaningless to us.
            //
            pszFirstComma = pszCurrent;

        }
        else if ((TEXT(' ') == *pszCurrent))
        {
            if ((NULL == pszFirstPlus) && (NULL == pszFirstSpace))
            {
                //
                //  Then we have no plus signs and no previous space, save the space as
                //  it is the start of the parameters.
                //
                pszFirstSpace = pszCurrent;
            }
            else if (pszFirstPlus && pszSecondPlus && (NULL == pszFirstSpace))
            {
                //
                //  Then we have both plus signs but no space yet, grab it
                //  because this is the start of the parameters
                //
                pszFirstSpace = pszCurrent;
            }
        }
        pszCurrent = CharNextU(pszCurrent);

    }

    //
    //  From the markers we have, figure out the beginning and end of the program string
    //
    
    LPTSTR pszStartOfProgram = NULL;
    LPTSTR pszEndOfProgram = NULL;

    if (pszFirstPlus)
    {
        if (pszSecondPlus)
        {
            pszStartOfProgram = CharNextU(pszFirstPlus);
            pszEndOfProgram = CharPrevU(pszStringToParse, pszSecondPlus);
        }
        else
        {
            //
            //  We have a string with the first char as a plus sign but no second +.
            //  The format isn't correct.
            //
            CMASSERTMSG(FALSE, TEXT("CustomActionList::ParseCustomActionString - Incorrect format in the passed in string to parse, missing + sign."));
            return E_UNEXPECTED;
        }
    }
    else
    {
        pszStartOfProgram = pszStringToParse;

        if (pszFirstComma)
        {
            pszEndOfProgram = CharPrevU(pszStringToParse, pszFirstComma);
        }
        else if (pszFirstSpace)
        {
            pszEndOfProgram = CharPrevU(pszStringToParse, pszFirstSpace);
        }
        else
        {
            //
            //  Nothing in the string but the program
            //
            pszEndOfProgram = pszStringToParse + lstrlenU(pszStringToParse) - 1;
        }
    }

    //
    //  Now copy out the necessary parts
    //
    HRESULT hr = E_OUTOFMEMORY; 
    int iSize = (int)(pszEndOfProgram - pszStartOfProgram + 2);

    *ppszProgram = (LPTSTR)CmMalloc(sizeof(TCHAR)*iSize);

    if (*ppszProgram)
    {
        lstrcpynU(*ppszProgram, pszStartOfProgram, iSize);

        if (pszFirstComma)
        {
            if (pszFirstSpace)
            {
                iSize = (int)(pszFirstSpace - pszFirstComma);
                *ppszFunctionName = (LPTSTR)CmMalloc(sizeof(TCHAR)*iSize);

                if (*ppszFunctionName)
                {
                    lstrcpynU(*ppszFunctionName, CharNextU(pszFirstComma), iSize);
                }
                else
                {
                    goto exit;
                }
            }
            else
            {
                iSize = lstrlen(CharNextU(pszFirstComma)) + 1;
                *ppszFunctionName = (LPTSTR)CmMalloc(sizeof(TCHAR)*iSize);

                if (*ppszFunctionName)
                {
                    lstrcpyU(*ppszFunctionName, CharNextU(pszFirstComma));
                }
                else
                {
                    goto exit;
                }
            }
        }
        else
        {
            *ppszFunctionName = CmStrCpyAlloc(TEXT(""));
        }
    
        if (pszFirstSpace)
        {
            iSize = lstrlen(CharNextU(pszFirstSpace)) + 1;
            *ppszParameters = (LPTSTR)CmMalloc(sizeof(TCHAR)*iSize);

            if (*ppszParameters)
            {
                lstrcpyU(*ppszParameters, CharNextU(pszFirstSpace));
            }
            else
            {
                goto exit;
            }
        }
        else
        {
            *ppszParameters = CmStrCpyAlloc(TEXT(""));
        }

        if (*ppszParameters && *ppszFunctionName && *ppszProgram)
        {
            hr = S_OK;
        }
    }
    else
    {
        goto exit;
    }

exit:
    MYDBGASSERT(SUCCEEDED(hr));

    if (FAILED(hr))
    {
        CMTRACE1(TEXT("HrParseCustomActionString failed, hr = 0x%x"), hr);
        CmFree(*ppszFunctionName);
        CmFree(*ppszProgram);
        CmFree(*ppszParameters);
        *ppszProgram = NULL;
        *ppszParameters = NULL;
        *ppszFunctionName = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\linkdll.cpp ===
//+----------------------------------------------------------------------------
//
// File:     linkdll.cpp
//
// Module:   Common Code
//
// Synopsis: Implementation of linkage functions LinkToDll and BindLinkage
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       created header      08/19/99
//
//+----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function:  LinkToDll
//
// Synopsis:  Helper function to manage the process of linking to a DLL and 
//            settings up a function table for later use.
//
// Arguments: HINSTANCE *phInst - A ptr to an hInst to be filled with the hInst of the DLL to be linked.
//            LPCTSTR pszDll - Ptr to the name of the DLL to be linked.
//            LPCSTR *ppszPfn - Ptr to a table of function names to be retrieved.
//            void **ppvPfn - Ptr to table for storage of pointers to DLL functions used.
//
// Returns:   BOOL - TRUE if fully loaded and linked.
//
// History:   nickball    Created Header    1/5/98
//
//+----------------------------------------------------------------------------
BOOL LinkToDll(HINSTANCE *phInst, LPCSTR pszDll, LPCSTR *ppszPfn, void **ppvPfn) 
{
    MYDBGASSERT(phInst);
    MYDBGASSERT(pszDll);
    MYDBGASSERT(ppszPfn);
    MYDBGASSERT(ppvPfn);

    CMTRACE1A("LinkToDll - Loading library - %s", pszDll);

    *phInst = LoadLibraryExA(pszDll, NULL, 0);

    if (!*phInst)
    {
        CMTRACE3A("LinkToDll[phInst=%p, *pszDll=%s, ppszPfn=%p,", phInst, MYDBGSTRA(pszDll), ppszPfn);
        CMTRACE1A("\tppvPfn=%p] LoadLibrary() failed.", ppvPfn);
        return FALSE;
    }

    //
    // Link succeeded now setup function addresses
    //
    
    return BindLinkage(*phInst, ppszPfn, ppvPfn);
} 

//+----------------------------------------------------------------------------
//
// Function:  BindLinkage
//
// Synopsis:  Helper function to fill in the given function pointer table with 
//            the addresses of the functions specified in the given string table.
//            Function addresses are retrieved from the DLL specified by hInst.
//
// Arguments: HINSTANCE hInstDll - The hInst of the DLL.
//            LPCSTR *ppszPfn   - Ptr to a table of function names.
//            void **ppvPfn      - Ptr to a table of function pointers to be filled in.
//
// Returns:   BOOL - TRUE if all addresses were successfully retrieved.
//
// History:   nickball    Created    1/5/98
//
//+----------------------------------------------------------------------------
BOOL BindLinkage(HINSTANCE hInstDll, LPCSTR *ppszPfn, void **ppvPfn) 
{   
    MYDBGASSERT(ppszPfn);
    MYDBGASSERT(ppvPfn);

    UINT nIdxPfn;
	BOOL bAllLoaded = TRUE;

    for (nIdxPfn=0;ppszPfn[nIdxPfn];nIdxPfn++) 
    {
	if (!ppvPfn[nIdxPfn]) 
        {
            ppvPfn[nIdxPfn] = GetProcAddress(hInstDll, ppszPfn[nIdxPfn]);

            if (!ppvPfn[nIdxPfn]) 
            {
                CMTRACE3(TEXT("BindLinkage(hInstDll=%d,ppszPfn=%p,ppvPfn=%p)"), hInstDll, ppszPfn, ppvPfn);
                CMTRACE3(TEXT("\tGetProcAddress(hInstDll=%d,*pszProc=%S) failed, GLE=%u."), hInstDll, ppszPfn[nIdxPfn], GetLastError()); 

                bAllLoaded = FALSE;
 	    }
        }
    }
	
    return (bAllLoaded);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\base_str.h ===
//+----------------------------------------------------------------------------
//
// File:     base_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for basic string constants used throughout such as 
//               "Connection Manager"
//           
// NOTE:     This header should be kept as lightweight as possible because it 
//           is included some very lightweight classes. Its purpose is to 
//           eliminate excessive repetition of key identifiers such 
//           as "Connection Manager"
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created         10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_BASE_STR
#define _CM_BASE_STR

//
// c_pszCmSection defines the application section in the .CMS file.
//

const TCHAR* const c_pszCmSection   = TEXT("Connection Manager");
const TCHAR* const c_pszVersion     = TEXT("Version");
const TCHAR* const c_pszPbk         = TEXT("PBK");

#endif // _CM_BASE_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\raslink.cpp ===
//+----------------------------------------------------------------------------
//
// File:     raslink.cpp
//
// Module:   CMDIAL32.DLL AND CMUTOA.DLL
//
// Synopsis: Declaration of the function name lists that are used for RAS
//           linkage.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------

// The RAS linkage system in CM is somewhat complicated.  Unfortunately, RAS is different
// on pretty much every version of the OS we have ever shipped.  There are APIs on the NT
// family that don't exist on the Win9x side and vice versa.  In order for CM to dynamically
// allocate the correct functions without too much work, we have created the following
// arrays of function names used by LinkToRas.  To further complicate matters, we have
// the ANSI versus Unicode problem.  Thus you will notice that we have three sets of
// function lists.  The c_ArrayOfRasFuncsA is actually used by Cmutoa.dll to load the
// real ANSI RAS functions that it calls after converting the parameters from Unicode to
// ANSI in its UA functions, which is why we have the c_ArrayOfRasFuncsUA list.  These
// functions are the wrappers exported by cmutoa.dll that cmdial32.dll links to on Win9x
// instead of the W APIs located in c_ArrayOfRasFuncsW that it uses on NT.  Please look
// at LinkToRas in cmdial\ras.cpp and InitCmRasUtoA in uapi\cmutoa.cpp.  If you change
// anything here you will probably have to change the structs in raslink.h and probably
// even the code in the two functions above.  Changer Beware!

#ifdef _CMUTOA_MODULE
    static LPCSTR c_ArrayOfRasFuncsA[] = {    "RasDeleteEntryA",
                                                "RasGetEntryPropertiesA",
                                                "RasSetEntryPropertiesA",
                                                "RasGetEntryDialParamsA",
                                                "RasSetEntryDialParamsA",
                                                "RasEnumDevicesA",
                                                "RasDialA",
                                                "RasHangUpA",
                                                "RasGetErrorStringA",
                                                "RasGetConnectStatusA",
                                                "RasSetSubEntryPropertiesA",
                                                "RasDeleteSubEntryA",
                                                NULL, //"RasSetCustomAuthDataA",
                                                NULL, //"RasGetEapUserIdentityA",
                                                NULL, //"RasFreeEapUserIdentityA",
                                                NULL, //"RasInvokeEapUI",
                                                NULL, //"RasGetCredentials",
                                                NULL, //"RasSetCredentials",
                                                NULL
    };

#else
    static LPCSTR c_ArrayOfRasFuncsUA[] = {   "RasDeleteEntryUA",
                                                "RasGetEntryPropertiesUA",
                                                "RasSetEntryPropertiesUA",
                                                "RasGetEntryDialParamsUA",
                                                "RasSetEntryDialParamsUA",
                                                "RasEnumDevicesUA",
                                                "RasDialUA",
                                                "RasHangUpUA",
                                                "RasGetErrorStringUA",
                                                "RasGetConnectStatusUA",
                                                "RasSetSubEntryPropertiesUA",  
                                                "RasDeleteSubEntryUA",
                                                NULL, //"RasSetCustomAuthDataUA",
                                                NULL, //"RasGetEapUserIdentityUA",
                                                NULL, //"RasFreeEapUserIdentityUA",
                                                NULL, //"RasInvokeEapUI",
                                                NULL, //"RasGetCredentials",
                                                NULL, //"RasSetCredentials",
                                                NULL
    };

    static LPCSTR c_ArrayOfRasFuncsW[] = {    "RasDeleteEntryW",
                                                "RasGetEntryPropertiesW",
                                                "RasSetEntryPropertiesW",
                                                "RasGetEntryDialParamsW",
                                                "RasSetEntryDialParamsW",
                                                "RasEnumDevicesW",
                                                "RasDialW",
                                                "RasHangUpW",
                                                "RasGetErrorStringW",
                                                "RasGetConnectStatusW",
                                                "RasSetSubEntryPropertiesW",  
                                                "RasDeleteSubEntryW",
                                                "RasSetCustomAuthDataW",
                                                "RasGetEapUserIdentityW",
                                                "RasFreeEapUserIdentityW",
                                                "RasInvokeEapUI",
                                                "RasGetCredentialsW",
                                                "RasSetCredentialsW",
                                                NULL
    };
#endif

// Regarding DwDeleteSubEntry and RasDeleteSubEntry - NT5 shipped first
// with DwDeleteSubEntry, a private API.  Millennium shipped next, by
// which time it looked like this was going to have to be made public,
// so it was prefixed with Ras.  NT5.1 made the corresponding name change
// on the NT side, which we handle within LinkToRas (along with all other such
// cases).
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\conact_str.h ===
//+----------------------------------------------------------------------------
//
// File:     conact_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS and .CMP flags.  Contents of this header 
//           should be limited to shared Connect Action flags.
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/15/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_CONACT_STR
#define _CM_CONACT_STR

const TCHAR* const c_pszCmSectionPreConnect     = TEXT("Pre-Connect Actions"); 
const TCHAR* const c_pszCmSectionOnConnect      = TEXT("Connect Actions");
const TCHAR* const c_pszCmSectionOnDisconnect   = TEXT("Disconnect Actions"); 
const TCHAR* const c_pszCmSectionPreTunnel      = TEXT("Pre-Tunnel Actions"); 
const TCHAR* const c_pszCmSectionPreDial        = TEXT("Pre-Dial Actions");
const TCHAR* const c_pszCmSectionOnCancel       = TEXT("On-Cancel Actions");
const TCHAR* const c_pszCmSectionOnError        = TEXT("On-Error Actions");
const TCHAR* const c_pszCmSectionCustom         = TEXT("CustomButton Actions");
const TCHAR* const c_pszCmSectionPreInit         = TEXT("Pre-Init Actions");
const TCHAR* const c_pszCmSectionOnIntConnect   = TEXT("Auto Applications");

const TCHAR* const c_pszCmEntryConactFlags      = TEXT("%u&Flags");       
const TCHAR* const c_pszCmEntryConactDesc       = TEXT("%u&Description"); 

#endif // _CM_CONACT_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\source\shelldll.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ShellDll.cpp
//
// Module:   Common Code
//
// Synopsis: Implements the class CShellDll, a shell32.dll wrapper.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   fengsun    Created    01/12/98
//
//+----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function:  CShellDll::CShellDll
//
// Synopsis:  Constructor
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
CShellDll::CShellDll(BOOL fKeepDllLoaded)
{
    m_hInstShell = NULL;
    m_fnShellExecuteEx = NULL;
    m_fnShell_NotifyIcon = NULL;
    m_pfnSHGetSpecialFolderLocation = NULL;
    m_pfnSHGetPathFromIDList = NULL;
    m_pfnSHGetMalloc = NULL;   
    m_KeepDllLoaded = fKeepDllLoaded;
}

//+----------------------------------------------------------------------------
//
// Function:  CShellDll::~CShellDl
//
// Synopsis:  Destructor
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/17/98
//
//+----------------------------------------------------------------------------
CShellDll::~CShellDll()
{
    Unload();
}


//+----------------------------------------------------------------------------
//
// Function:  CShellDll::Load
//
// Synopsis:  Load shell32.dll
//            It works even if the dll is already loaded, but we do not keep a referrence
//            count here, any unload call will unload the dll
//
// Arguments: None
//
// Returns:   BOOL - Whether the dll is successfully loaded
//
// History:   fengsun Created Header    1/12/98
//
//+----------------------------------------------------------------------------
BOOL CShellDll::Load()
{
    //
    // Simply return, if already loaded
    //
    LPSTR pszShellExecuteEx;
    LPSTR pszShellNotifyIcon;
    LPSTR pszSHGetPathFromIDList;
    LPSTR pszSHGetSpecialFolderLocation;
    LPSTR pszSHGetMalloc;

    if (m_hInstShell == NULL)
    {
        if (OS_NT)
        {
            m_hInstShell = LoadLibraryExA("Shell32.dll", NULL, 0);
            pszShellExecuteEx = "ShellExecuteExW";
            pszShellNotifyIcon = "Shell_NotifyIconW";
            pszSHGetPathFromIDList = "SHGetPathFromIDListW";
            pszSHGetSpecialFolderLocation = "SHGetSpecialFolderLocation"; // no A or W version
            pszSHGetMalloc = "SHGetMalloc"; // no A or W version
        }
        else
        {
            m_hInstShell = LoadLibraryExA("cmutoa.dll", NULL, 0);
            pszShellExecuteEx = "ShellExecuteExUA";
            pszShellNotifyIcon = "Shell_NotifyIconUA"; 
            pszSHGetPathFromIDList = "SHGetPathFromIDListUA";
            pszSHGetSpecialFolderLocation = "SHGetSpecialFolderLocationUA"; // no actual A or W version
            pszSHGetMalloc = "SHGetMallocUA";                               // but this class only 
                                                                            // allows one dll       
        }

        if (m_hInstShell == NULL)
        {
            return FALSE;
        }

        m_pfnSHGetMalloc = (SHGetMallocSpec)GetProcAddress(m_hInstShell, pszSHGetMalloc);
        m_pfnSHGetSpecialFolderLocation = (SHGetSpecialFolderLocationSpec)GetProcAddress(m_hInstShell, pszSHGetSpecialFolderLocation);
        m_pfnSHGetPathFromIDList = (SHGetPathFromIDListSpec)GetProcAddress(m_hInstShell, pszSHGetPathFromIDList);
        m_fnShellExecuteEx = (SHELLEXECUTEEXPROC)GetProcAddress(m_hInstShell, pszShellExecuteEx);
        m_fnShell_NotifyIcon = (SHELL_NOTIFYICONPROC)GetProcAddress(m_hInstShell, pszShellNotifyIcon);

        if (NULL == m_fnShellExecuteEx || NULL == m_fnShell_NotifyIcon || 
            NULL == m_pfnSHGetSpecialFolderLocation || NULL == m_pfnSHGetPathFromIDList ||
            NULL == m_pfnSHGetMalloc)
        {
            FreeLibrary(m_hInstShell);
            m_hInstShell = NULL;
            return FALSE;
        }
    }

    return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  CShellDll::Unload
//
// Synopsis:  Unload the shell32.dll
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/12/98
//
//+----------------------------------------------------------------------------
void CShellDll::Unload()
{
    if (m_hInstShell == NULL)
    {
        return;
    }
   
    //
    // Don't release library because of shell bug #289463 + #371836
    // ShellExecute fires a thread which wakes up after the release 
    // of the library and crashes us. Ugly but real, we have no choice 
    // but to stay linked to the Shell DLL.
    //

    if (!m_KeepDllLoaded)
    {
        FreeLibrary(m_hInstShell);
        m_hInstShell = NULL;
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CShellDll::ShellGetSpecialFolderLocation
//
// Synopsis:  Wrapper function for SHGetSpecialFolderLocation.  Please note the
//            returned pidl must be freed with the Shell's Malloc pointer (use SHGetMalloc).
//
// Arguments: Please see the api definition for SHGetSpecialFolderLocation
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created    5/21/99
//
//+----------------------------------------------------------------------------
HRESULT CShellDll::ShellGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl)
{
    if (!Load())
    {
        return E_FAIL;
    }

    return m_pfnSHGetSpecialFolderLocation(hwnd, csidl, ppidl);
}

//+----------------------------------------------------------------------------
//
// Function:  CShellDll::ShellGetPathFromIDList
//
// Synopsis:  Wrapper function for SHGetPathFromIDList.
//
// Arguments: Please see the api definition for SHGetPathFromIDList
//
// Returns:   BOOL - TRUE on success
//
// History:   quintinb Created    5/21/99
//
//+----------------------------------------------------------------------------
BOOL CShellDll::ShellGetPathFromIDList(LPCITEMIDLIST pidl, LPTSTR pszPath)
{
    if (!Load())
    {
        return FALSE;
    }

    return m_pfnSHGetPathFromIDList(pidl, pszPath);
}

//+----------------------------------------------------------------------------
//
// Function:  CShellDll::ShellGetMalloc
//
// Synopsis:  Wrapper function for SHGetMalloc.
//
// Arguments: Please see the api definition for SHGetMalloc
//
// Returns:   HRESULT - Standard COM Error Codes
//
// History:   quintinb Created    5/21/99
//
//+----------------------------------------------------------------------------
HRESULT CShellDll::ShellGetMalloc(LPMALLOC * ppMalloc)
{
    if (!Load())
    {
        return E_FAIL;
    }

    return m_pfnSHGetMalloc(ppMalloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\dl_str.h ===
//+----------------------------------------------------------------------------
//
// File:     dl_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS and .CMP flags.  Contents of this header 
//           should be optimized for CMDL usage.
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_DL_STR
#define _CM_DL_STR

const TCHAR* const c_pszCmEntryBigIcon   = TEXT("Icon");
const TCHAR* const c_pszCmEntrySmallIcon = TEXT("SmallIcon");

#endif // _CM_DL_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\inf_str.h ===
//+----------------------------------------------------------------------------
//
// File:     inf_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file INF flags used by CM and CMAK
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------
#ifndef _CM_INF_STR
#define _CM_INF_STR

const TCHAR* const c_pszDesktopGuid         = TEXT("DesktopGUID");
const TCHAR* const c_pszInfSectionStrings   = TEXT("Strings");
const TCHAR* const c_pszShortSvcName        = TEXT("ShortSvcName"); 
const TCHAR* const c_pszCmakStatus          = TEXT("CMAK Status");

#endif // _CM_INF_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\cmakreg.h ===
//+----------------------------------------------------------------------------
//
// File:     cmakreg.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMAK related Registry keys and values.
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------

const TCHAR* const c_pszRegCmak             = TEXT("Software\\Microsoft\\Connection Manager Administration Kit");
const TCHAR* const c_pszCmakAppPath         = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMAK.EXE");
const TCHAR* const c_pszRegOutput           = TEXT("Output");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\log_str.h ===
//+----------------------------------------------------------------------------
//
// File:     log_str.h
//
// Module:   Strings for logging modules to utilize
//
// Synopsis: Header file containing common strings optimized for cmlog.
//			 
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   sumitc         Created       25/07/2000
//
//+----------------------------------------------------------------------------

#ifndef _CM_LOG_STR
#define _CM_LOG_STR

const TCHAR* const c_pszCmEntryEnableLogging    = TEXT("EnableLogging");
const TCHAR* const c_pszCmSectionLogging        = TEXT("Logging");
const TCHAR* const c_pszCmEntryMaxLogFileSize   = TEXT("MaxFileSize");
const TCHAR* const c_pszCmEntryLogFileDirectory = TEXT("FileDirectory");

#endif // _CM_LOG_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\dun_str.h ===
//+----------------------------------------------------------------------------
//
// File:     dun_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Shard .CMS Dun flags
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_DUN_STR
#define _CM_DUN_STR

const TCHAR* const c_pszCmSectionDunTcpIp                           = TEXT("TCP/IP");
const TCHAR* const c_pszCmEntryDunTcpIpSpecifyIpAddress	            = TEXT("Specify_IP_Address");
const TCHAR* const c_pszCmEntryDunTcpIpIpAddress                    = TEXT("IP_Address");
const TCHAR* const c_pszCmEntryDunTcpIpSpecifyServerAddress         = TEXT("Specify_Server_Address");
const TCHAR* const c_pszCmEntryDunTcpIpDnsAddress                   = TEXT("DNS_Address");
const TCHAR* const c_pszCmEntryDunTcpIpDnsAltAddress                = TEXT("DNS_Alt_Address");
const TCHAR* const c_pszCmEntryDunTcpIpWinsAddress                  = TEXT("WINS_Address");
const TCHAR* const c_pszCmEntryDunTcpIpWinsAltAddress               = TEXT("WINS_Alt_Address");
const TCHAR* const c_pszCmEntryDunTcpIpIpHeaderCompress             = TEXT("IP_Header_Compress");
const TCHAR* const c_pszCmEntryDunTcpIpGatewayOnRemote              = TEXT("Gateway_On_Remote");
const TCHAR* const c_pszCmEntryDunTcpIpDnsSuffix                    = TEXT("DnsSuffix");
const TCHAR* const c_pszCmEntryDunTcpIpTcpWindowSize	            = TEXT("TcpWindowSize");

const TCHAR* const c_pszCmEntryDunScriptingUseRasCustomScriptDll    = TEXT("UseRasCustomScriptDll");
const TCHAR* const c_pszCmEntryDunScriptingUseTerminalWindow        = TEXT("UseTerminalWindow");
const TCHAR* const c_pszCmEntryDunScriptingName                     = TEXT("Name");
const TCHAR* const c_pszCmSectionDunScripting                       = TEXT("Scripting");

const TCHAR* const c_pszCmSectionDunServer                          = TEXT("Server");
const TCHAR* const c_pszCmEntryDunServerNetworkLogon                = TEXT("NetworkLogon");
const TCHAR* const c_pszCmEntryDunServerSwCompress                  = TEXT("SW_Compress");
const TCHAR* const c_pszCmEntryDunServerDisableLcp                  = TEXT("Disable_LCP");
const TCHAR* const c_pszCmEntryDunServerDisableNbtOverIP            = TEXT("DisableNbtOverIP");
const TCHAR* const c_pszCmEntryDunPrependDialupDomain               = TEXT("PrependDialupDomain");

const TCHAR* const c_pszCmEntryDunServerNegotiateTcpIp              = TEXT("Negotiate_TCP/IP");
const TCHAR* const c_pszCmEntryDunServerNegotiateIpx                = TEXT("Negotiate_IPX");
const TCHAR* const c_pszCmEntryDunServerNegotiateNetBeui            = TEXT("Negotiate_Netbeui");

const TCHAR* const c_pszCmEntryDunServerPwEncryptMs                 = TEXT("PW_EncryptMS");
const TCHAR* const c_pszCmEntryDunServerPwEncrypt                   = TEXT("PW_Encrypt");
const TCHAR* const c_pszCmEntryDunServerRequirePap                  = TEXT("Require_PAP");
const TCHAR* const c_pszCmEntryDunServerRequireSpap                 = TEXT("Require_SPAP");
const TCHAR* const c_pszCmEntryDunServerRequireEap                  = TEXT("Require_EAP");
const TCHAR* const c_pszCmEntryDunServerRequireChap                 = TEXT("Require_CHAP");
const TCHAR* const c_pszCmEntryDunServerRequireMsChap               = TEXT("Require_MSCHAP");
const TCHAR* const c_pszCmEntryDunServerRequireMsChap2              = TEXT("Require_MSCHAP2");
const TCHAR* const c_pszCmEntryDunServerRequireW95MsChap            = TEXT("Require_W95MSCHAP");
const TCHAR* const c_pszCmEntryDunServerCustomSecurity              = TEXT("Custom_Security");
const TCHAR* const c_pszCmEntryDunServerEncryptionType              = TEXT("EncryptionType");
const TCHAR* const c_pszCmEntryDunServerDataEncrypt                 = TEXT("DataEncrypt");
const TCHAR* const c_pszCmEntryDunServerCustomAuthKey               = TEXT("CustomAuthKey");
const TCHAR* const c_pszCmEntryDunServerSecureLocalFiles            = TEXT("SecureLocalFiles");
const TCHAR* const c_pszCmEntryDunServerType                        = TEXT("Type");
const TCHAR* const c_pszDunPpp                                      = TEXT("ppp");
const TCHAR* const c_pszDunSlip                                     = TEXT("slip");
const TCHAR* const c_pszDunCslip                                    = TEXT("cslip");

const TCHAR* const c_pszCmSectionDunNetworking                      = TEXT("Networking");
const TCHAR* const c_pszCmEntryDunNetworkingVpnStrategy             = TEXT("VpnStrategy");
const TCHAR* const c_pszCmEntryDunNetworkingVpnEntry                = TEXT("VpnEntry");
const TCHAR* const c_pszCmEntryDunNetworkingUsePreSharedKey         = TEXT("UsePreSharedKey");

const TCHAR* const c_pszCmEntryDunNetworkingSecureClientForMSNet    = TEXT("SecureClientForMSNet");
const TCHAR* const c_pszCmEntryDunNetworkingSecureFileAndPrint      = TEXT("SecureFileAndPrint");
const TCHAR* const c_pszCmEntryDunNetworkingDontNegotiateMultilink  = TEXT("DontNegotiateMultilink");
const TCHAR* const c_pszCmEntryDunNetworkingDontUseRasCredentials   = TEXT("DontUseRasCredentials");

const TCHAR* const c_pszCmEntryDunServerEnforceCustomSecurity       = TEXT("EnforceCustomSecurity");

//
//  These constants are explicitly CHAR consts
//
const CHAR* const c_pszCmEntryDunServerCustomAuthData       = "CustomAuthData";


#endif //  _CM_DUN_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\mgr_str.h ===
//+----------------------------------------------------------------------------
//
// File:     mgr_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS flags, optimized for CMMGR32.EXE
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_MGR_STR
#define _CM_MGR_STR

const TCHAR* const c_pszCmEntryCmsFile      = TEXT("CMSFile");
const TCHAR* const c_pszCmEntryServiceName  = TEXT("ServiceName");

#endif // _CM_MGR_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\pbk_str.h ===
//+----------------------------------------------------------------------------
//
// File:     pbk_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS flags, optimized for use by CMPBK32.DLL
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_PBK_STR
#define _CM_PBK_STR

const TCHAR* const c_pszCmSectionIsp            = TEXT("ISP");
const TCHAR* const c_pszCmEntryIspUrl           = TEXT("PBURL");
const TCHAR* const c_pszCmEntryIspFilterA       = TEXT("FilterA&");
const TCHAR* const c_pszCmEntryIspFilterB       = TEXT("FilterB&");
const TCHAR* const c_pszCmEntryIspReferences    = TEXT("References");
const TCHAR* const c_pszCmEntryIspCmsFile       = TEXT("CMSFile&");
const TCHAR* const c_pszCmEntryIspPbFile        = TEXT("PBFile");
const TCHAR* const c_pszCmEntryIspRegionFile    = TEXT("RegionFile");

#endif // _CM_PBK_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\mon_str.h ===
//+----------------------------------------------------------------------------
//
// File:     mon_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS flags, optimized for use by CMMON32.EXE
//				 		 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_MON_STR
#define _CM_MON_STR

const TCHAR* const c_pszCmEntryHelpFile         = TEXT("HelpFile");
const TCHAR* const c_pszCmSectionMenuOptions    = TEXT("Menu Options");
const TCHAR* const c_pszCmEntryIdleTimeout      = TEXT("IdleTimeout");
const TCHAR* const c_pszCmEntryAutoReconnect     = TEXT("AutoReconnect");
const TCHAR* const c_pszCmEntryTrayIcon         = TEXT("TrayIcon");
const TCHAR* const c_pszDefaultHelpFile         = TEXT("cmmgr32.hlp");

#endif // _CM_MON_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\perf_str.h ===
//+----------------------------------------------------------------------------
//
// File:     perf_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for DUN 1.2 perf stat strings.  Note that the 
//           contents of this header should be specific to perf stats.
//			 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/14/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_PERF_STR
#define _CM_PERF_STR

//
// the following reg key and values are where Dialup 1.2 store the perfmon data
// for Windows 95/98Dial-Up Networking
// Win9x support upto two PPP/PPTP sessions, the reg key is first come first serve
//
const TCHAR* const c_pszDialupPerfKey           = TEXT("PerfStats\\StatData");
const TCHAR* const c_pszDialupTotalBytesRcvd    = TEXT("\\TotalBytesRecvd");
const TCHAR* const c_pszDialupTotalBytesXmit    = TEXT("\\TotalBytesXmit");
const TCHAR* const c_pszDialupConnectSpeed 	    = TEXT("\\ConnectSpeed");
const TCHAR* const c_pszDialup_2_TotalBytesRcvd = TEXT(" #2\\TotalBytesRecvd");
const TCHAR* const c_pszDialup_2_TotalBytesXmit = TEXT(" #2\\TotalBytesXmit");
const TCHAR* const c_pszDialup_2_ConnectSpeed 	= TEXT(" #2\\ConnectSpeed");

#endif // _CM_PERF_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\ras_str.h ===
//+----------------------------------------------------------------------------
//
// File:     ras_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for shared ras strings.  Note that the contents 
//           of this file should be limited to ras specific string constants.
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball       Created       10/14/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_RAS_STR
#define _CM_RAS_STR

const TCHAR* const c_pszRasDirRas = TEXT("\\RAS");
const TCHAR* const c_pszRasPhonePbk = TEXT("\\rasphone.pbk");
const TCHAR* const c_pszInetDialHandler = TEXT("InetDialHandler");
const TCHAR* const c_pszCmDialPath = TEXT("%windir%\\system32\\cmdial32.dll");

#endif // _CM_RAS_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\profile_str.h ===
//+----------------------------------------------------------------------------
//
// File:     profile_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS and .CMP flags shared between cmdial and profwiz.
//           Note that the contents of this header should be limited to .CMS 
//           and .CMP flags.
//			 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_PROFILE_STR
#define _CM_PROFILE_STR

const TCHAR* const c_pszCmEntryPbMessage         = TEXT("PBMessage");    
const TCHAR* const c_pszCmEntryPbLogo            = TEXT("PBLogo");                    
const TCHAR* const c_pszCmEntryLogo              = TEXT("Logo");                      

const TCHAR* const c_pszCmEntryHideDomain        = TEXT("HideDomain");    

        
const TCHAR* const c_pszCmEntryServiceMessage    = TEXT("ServiceMessage");        
const TCHAR* const c_pszCmEntryUserPrefix        = TEXT("UserNamePrefix");           
const TCHAR* const c_pszCmEntryUserSuffix        = TEXT("UserNameSuffix");           
        
const TCHAR* const c_pszCmEntryTapiLocation      = TEXT("TapiLocation");

const TCHAR* const c_pszRegKeyAccessPoints       = TEXT("Access Points");

const TCHAR* const c_pszCmEntryEnableICF         = TEXT("EnableICF");
const TCHAR* const c_pszCmEntryDisableICS        = TEXT("DisableICS");
const TCHAR* const c_pszCmEntryUseWinLogonCredentials   = TEXT("UseWinLogonCredentials");

#endif // _CM_PROFILE_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\pwd_str.h ===
//+----------------------------------------------------------------------------
//
// File:     pwd_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS flags used in password management
//           Note that the contents of this header should be 
//           limited to password related CMS/CMP flags that are shared by
//           the modules that include this file.
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_PWD_STR
#define _CM_PWD_STR

const TCHAR* const c_pszCmEntryRememberPwd      = TEXT("RememberPassword");
const TCHAR* const c_pszCmEntryRememberInetPwd  = TEXT("RememberInternetPassword");
const TCHAR* const c_pszCmEntryPcs              = TEXT("PCS");
const TCHAR* const c_pszCmEntryPassword         = TEXT("Password");
const TCHAR* const c_pszCmEntryInetPassword     = TEXT("InternetPassword");

const TCHAR* const c_pszRegCmEncryptOption      = TEXT("EncryptOption");

const TCHAR* const c_pszCmEntryUseSameUserName  = TEXT("UseSameUserName");  

//
// Password token. Used for comparison in order not to re-save the password
//

const TCHAR* const c_pszSavedPasswordToken = TEXT("****************");

#endif // _CM_PWD_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\reg_str.h ===
//+----------------------------------------------------------------------------
//
// File:     reg_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for shared reg strings.  Note that the contents 
//           of this file should be limited to reg specific string constants.
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball       Created       10/16/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_REG_STR
#define _CM_REG_STR

//
// Commonly used reg key constants
//

const TCHAR* const c_pszRegCmRoot = TEXT("SOFTWARE\\Microsoft\\Connection Manager\\");
const TCHAR* const c_pszRegCmAppPaths = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMMGR32.EXE");
const TCHAR* const c_pszRegCmMappings = TEXT("SOFTWARE\\Microsoft\\Connection Manager\\Mappings");
const TCHAR* const c_pszRegPath = TEXT("Path"); 

#endif // _CM_REG_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\stp_str.h ===
//+----------------------------------------------------------------------------
//
// File:     stp_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file containing common strings optimized for cmstp. 
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball       Created       10/09/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_STP_STR
#define _CM_STP_STR

const TCHAR* const c_pszCmSectionProfileFormat  = TEXT("Profile Format");
const TCHAR* const c_pszCmEntryDun          	= TEXT("DUN");
const TCHAR* const c_pszCmEntryDialup           = TEXT("Dialup");
const TCHAR* const c_pszCmEntryDirect           = TEXT("Direct");
const TCHAR* const c_pszCmEntryConnectionType   = TEXT("ConnectionType");
const TCHAR* const c_pszCmpExt                  = TEXT(".cmp");

#endif // _CM_STP_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\ver_str.h ===
//+----------------------------------------------------------------------------
//
// File:     ver_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for Profile Versioning Inf Values/Keys
//				 		 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/19/99
//
//+----------------------------------------------------------------------------
const TCHAR* const c_pszSectionCmDial32 = TEXT("CmDial32.Dll");
const TCHAR* const c_pszVerBuild = TEXT("Build");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\tunl_str.h ===
//+----------------------------------------------------------------------------
//
// File:     tunl_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Header file for CMS tunnel flags.  Note that the contents 
//           of this header should be limited to .CMS tunnel flags.
//                       
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball       Created       10/15/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_TUNL_STR
#define _CM_TUNL_STR

const TCHAR* const c_pszCmEntryTunnelPrimary    = TEXT("Tunnel");           
const TCHAR* const c_pszCmEntryTunnelReferences = TEXT("TunnelReferences"); 
const TCHAR* const c_pszCmEntryTunnelAddress    = TEXT("TunnelAddress");        
const TCHAR* const c_pszCmEntryTunnelDun        = TEXT("TunnelDUN");
const TCHAR* const c_pszCmEntryTunnelFile       = TEXT("TunnelFile");
const TCHAR* const c_pszCmEntryTunnelDesc       = TEXT("TunnelDesc");
const TCHAR* const c_pszCmEntryPresharedKey     = TEXT("PresharedKey");
const TCHAR* const c_pszCmEntryKeyIsEncrypted   = TEXT("PresharedKeyIsEncrypted");

const TCHAR* const c_pszCmSectionVpnServers     = TEXT("VPN Servers");
const TCHAR* const c_pszCmSectionSettings       = TEXT("Settings");
const TCHAR* const c_pszCmEntryVpnDefault       = TEXT("Default");
const TCHAR* const c_pszCmEntryVpnUpdateUrl     = TEXT("UpdateUrl");
const TCHAR* const c_pszCmEntryVpnMessage       = TEXT("Message");

#endif // _CM_TUNL_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmproxy\pch.h ===
//+----------------------------------------------------------------------------
//
// File:     pch.h
//      
// Module:   CMPROXY.DLL (TOOL)
//
// Synopsis: Precompiled header for IE proxy setting connect action.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb   Created   10/27/99
//
//+----------------------------------------------------------------------------

#include <windows.h>
#include <shlwapi.h>
#include <wininet.h>
#include <ras.h>
#include "cmutil.h"
#include "cmdebug.h"

//
//  Function Headers from util.cpp
//

HRESULT GetBrowserVersion(DLLVERSIONINFO* pDllVersionInfo);
LPTSTR *GetCmArgV(LPTSTR pszCmdLine);
BOOL UseVpnName(LPSTR pszAltName);
void GetString (LPCSTR pszSection, LPCSTR pszKey, LPSTR* ppString, LPCSTR pszFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmproxy\cmproxy.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmproxy.cpp
//      
// Module:   CMPROXY.DLL (TOOL)
//
// Synopsis: Main source for IE proxy setting connect action
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb   Created   10/27/99
//
//+----------------------------------------------------------------------------
#include "pch.h"

const CHAR* const c_pszInternetSettingsPath = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings";
const CHAR* const c_pszProxyEnable = "ProxyEnable";
const CHAR* const c_pszProxyServer = "ProxyServer";
const CHAR* const c_pszProxyOverride = "ProxyOverride";
const CHAR* const c_pszManualProxySection = "Manual Proxy";
const CHAR* const c_pszAutoProxySection = "Automatic Proxy";
const CHAR* const c_pszAutoConfigScript = "AutoConfigScript";
const CHAR* const c_pszAutoProxyEnable = "AutoProxyEnable";
const CHAR* const c_pszAutoConfigScriptEnable = "AutoConfigScriptEnable";
const CHAR* const c_pszUseVpnName = "UseVpnName";
const CHAR* const c_pszEmpty = "";

//
//  Typedefs and Function Pointers for the Wininet APIs that we use.
//

typedef BOOL (WINAPI* pfnInternetQueryOptionSpec)(HINTERNET, DWORD, LPVOID, LPDWORD);
typedef BOOL (WINAPI* pfnInternetSetOptionSpec)(HINTERNET, DWORD, LPVOID, DWORD);
pfnInternetQueryOptionSpec g_pfnInternetQueryOption = NULL;
pfnInternetSetOptionSpec g_pfnInternetSetOption = NULL;

//+----------------------------------------------------------------------------
//
// Function:  SetIE5ProxySettings
//
// Synopsis:  This function sets the IE5, per connection proxy settings using
//            the given connection, enabled value, proxy server, and override
//            settings.
//
// Arguments: LPSTR pszConnection - Connection name to set the proxy settings for
//            BOOL bManualProxy - whether the manual proxy is enabled or not
//            BOOL bAutomaticProxy  - whether the auto proxy detection is enabled
//            BOOL bAutoConfigScript - whether an auto config script should be used
//            LPSTR pszProxyServer - proxy server name in the proxyserver:port format
//            LPSTR pszProxyOverride - a semi-colon seperated list of 
//                                     realms to bypass the proxy for
//            LPSTR pszAutoConfigScript - auto config URL
//
// Returns:   HRESULT  - Standard COM return codes
//
// History:   quintinb Created  10/27/99
//
//+----------------------------------------------------------------------------
HRESULT SetIE5ProxySettings(LPSTR pszConnection, BOOL bManualProxy, BOOL bAutomaticProxy, BOOL bAutoConfigScript,
                            LPSTR pszProxyServer, LPSTR pszProxyOverride, LPSTR pszAutoConfigScript)
{
    //
    //  Check Inputs, note allow pszConnection to be NULL (to set the LAN connection)
    //
    if ((NULL == g_pfnInternetSetOption) || (NULL == pszProxyServer) || 
        (NULL == pszProxyOverride) || (NULL == pszAutoConfigScript))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;    
    INTERNET_PER_CONN_OPTION_LIST PerConnOptionList;
    DWORD dwSize = sizeof(PerConnOptionList);

    PerConnOptionList.dwSize = sizeof(PerConnOptionList);
    PerConnOptionList.pszConnection = pszConnection;
    PerConnOptionList.dwOptionCount = 4;
    PerConnOptionList.dwOptionError = 0;    

    PerConnOptionList.pOptions = (INTERNET_PER_CONN_OPTION*)CmMalloc(4*sizeof(INTERNET_PER_CONN_OPTION));
    if(NULL == PerConnOptionList.pOptions)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // set flags
    //
    PerConnOptionList.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    PerConnOptionList.pOptions[0].Value.dwValue = PROXY_TYPE_DIRECT;

    if (bManualProxy)
    {
        PerConnOptionList.pOptions[0].Value.dwValue |= PROXY_TYPE_PROXY;
    }

    if (bAutomaticProxy)
    {
        PerConnOptionList.pOptions[0].Value.dwValue |= PROXY_TYPE_AUTO_DETECT;
    }

    if (bAutoConfigScript)
    {
        PerConnOptionList.pOptions[0].Value.dwValue |= PROXY_TYPE_AUTO_PROXY_URL;
    }

    //
    // set proxy name
    //
    PerConnOptionList.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    PerConnOptionList.pOptions[1].Value.pszValue = pszProxyServer;

    //
    // set proxy override
    //
    PerConnOptionList.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    PerConnOptionList.pOptions[2].Value.pszValue = pszProxyOverride;

    //
    // set auto config URL
    //
    PerConnOptionList.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
    PerConnOptionList.pOptions[3].Value.pszValue = pszAutoConfigScript;

    //
    // tell wininet
    //
    if (!g_pfnInternetSetOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &PerConnOptionList, dwSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    CmFree(PerConnOptionList.pOptions);

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  SetIE4ProxySettings
//
// Synopsis:  This function sets the IE4 proxy settings (global to a machine) using
//            the given connection, enabled value, proxy server, and override
//            settings.
//
// Arguments: LPSTR pszConnection - ignored (exists to have same prototype as IE5 version)
//            BOOL bManualProxy - whether the manual proxy is enabled or not
//            BOOL bAutomaticProxy  - ignored (exists to have same prototype as IE5 version)
//            BOOL bAutoConfigScript - ignored (exists to have same prototype as IE5 version)
//            LPSTR pszProxyServer - proxy server name in the proxyserver:port format
//            LPSTR pszProxyOverride - a semi-colon seperated list of 
//                                     realms to bypass the proxy for
//            LPSTR pszAutoConfigScript - ignored (exists to have same prototype as IE5 version)
//
// Returns:   HRESULT  - Standard COM return codes
//
// History:   quintinb Created  10/27/99
//
//+----------------------------------------------------------------------------
HRESULT SetIE4ProxySettings(LPSTR pszConnection, BOOL bManualProxy, BOOL bAutomaticProxy, BOOL bAutoConfigScript,
                            LPSTR pszProxyServer, LPSTR pszProxyOverride, LPSTR pszAutoConfigScript)
{
    //
    //  Check Inputs, note that we don't allow the strings to be NULL but they could
    //  be empty.  Also note that pszConnection is ignored because IE4 proxy settings are global.
    //
    if ((NULL == pszProxyServer) || (NULL == pszProxyOverride))
    {
        return E_INVALIDARG;
    }

    DWORD dwTemp;
    HKEY hKey = NULL;
    HRESULT hr = S_OK;

    //
    //  Now Create/Open the Internet Settings key
    //
    LONG lResult = RegCreateKeyEx(HKEY_CURRENT_USER, c_pszInternetSettingsPath, 0, NULL, 
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwTemp);

    hr = HRESULT_FROM_WIN32(lResult);

    if (SUCCEEDED(hr))
    {
        //
        //  Set the proxy values
        //
        dwTemp = bManualProxy ? 1 : 0; // use a true 1 or 0 value.
        lResult = RegSetValueEx(hKey, c_pszProxyEnable, 0, REG_DWORD, (CONST BYTE*)&dwTemp, sizeof(DWORD));
        hr = HRESULT_FROM_WIN32(lResult);
        
        if (SUCCEEDED(hr))
        {            
            lResult = RegSetValueEx(hKey, c_pszProxyServer, 0, REG_SZ, (CONST BYTE*)pszProxyServer, lstrlen(pszProxyServer)+1);
            hr = HRESULT_FROM_WIN32(lResult);
        
            if (SUCCEEDED(hr))
            {            
                lResult = RegSetValueEx(hKey, c_pszProxyOverride, 0, REG_SZ, (CONST BYTE*)pszProxyOverride, lstrlen(pszProxyOverride)+1);
                hr = HRESULT_FROM_WIN32(lResult);
            }            
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetIE5ProxySettings
//
// Synopsis:  Gets the IE5, per connection, proxy settings for the given connection.
//            Please note that the strings allocated for the proxy server and the
//            proxy override values must be freed by the caller.
//
// Arguments: LPSTR pszConnection - connection name to get the proxy settings for
//            LPBOOL pbManualProxy - bool pointer to hold whether the manual 
//                                   proxy is enabled or not
//            LPBOOL pbAutomaticProxy - bool pointer to hold whether automatic 
//                                      proxy detection is enabled or not
//            LPBOOL pbAutoConfigScript - bool pointer to hold whether an auto
//                                        config script should be used or not
//            LPSTR* ppszProxyServer - string pointer to hold the retrieved 
//                                     proxy server string
//            LPSTR* ppszProxyOverride - string pointer to hold the retrieved
//                                       proxy server string
//            LPSTR* ppszAutoConfigScript - string pointer to hold the retrieved
//                                          auto config script
//
// Returns:   HRESULT - Standard COM return codes
//
// History:   quintinb  Created    10/27/99
//
//+----------------------------------------------------------------------------
HRESULT GetIE5ProxySettings(LPSTR pszConnection, LPBOOL pbManualProxy, LPBOOL pbAutomaticProxy, LPBOOL pbAutoConfigScript,
                            LPSTR* ppszProxyServer, LPSTR* ppszProxyOverride, LPSTR* ppszAutoConfigScript)
{

    //
    //  Check Inputs, note that pszConnection can be NULL.  It will set the LAN connection in that case.
    //
    if ((NULL == pbManualProxy) || (NULL == pbAutomaticProxy) || (NULL == pbAutoConfigScript) || 
        (NULL == ppszProxyServer) || (NULL == ppszProxyOverride) || (NULL == ppszAutoConfigScript) ||
        (NULL == g_pfnInternetQueryOption))
    {
        return E_INVALIDARG;
    }

    //
    //  Zero the output params
    //
    *pbManualProxy = FALSE;
    *pbAutomaticProxy = FALSE;
    *pbAutoConfigScript = FALSE;
    *ppszProxyServer = CmStrCpyAlloc(c_pszEmpty);
    *ppszProxyOverride = CmStrCpyAlloc(c_pszEmpty);
    *ppszAutoConfigScript = CmStrCpyAlloc(c_pszEmpty);
    //
    //  Setup the Option List Struct
    //
    HRESULT hr = S_OK;

    INTERNET_PER_CONN_OPTION_LIST PerConnOptionList;
    PerConnOptionList.dwSize = sizeof(PerConnOptionList);
    PerConnOptionList.pszConnection = pszConnection;
    PerConnOptionList.dwOptionError = 0;
    PerConnOptionList.dwOptionCount = 4;

    PerConnOptionList.pOptions = (INTERNET_PER_CONN_OPTION*)CmMalloc(4*sizeof(INTERNET_PER_CONN_OPTION));
    if(NULL == PerConnOptionList.pOptions)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // set flags we want info about
    //
    PerConnOptionList.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    PerConnOptionList.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    PerConnOptionList.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    PerConnOptionList.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

    
    DWORD dwSize = sizeof(PerConnOptionList);
    
    //
    //  Get the Options
    //
    if (!g_pfnInternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &PerConnOptionList, &dwSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (SUCCEEDED(hr))
    {
        //
        //  Parse the returned options to find the options we are interested in
        //

        for (DWORD dwIndex=0; dwIndex < PerConnOptionList.dwOptionCount; dwIndex++)
        {
            switch(PerConnOptionList.pOptions[dwIndex].dwOption)
            {
            case INTERNET_PER_CONN_FLAGS:
                if (PROXY_TYPE_PROXY & PerConnOptionList.pOptions[dwIndex].Value.dwValue)
                {
                    *pbManualProxy = TRUE;
                }

                if (PROXY_TYPE_AUTO_PROXY_URL & PerConnOptionList.pOptions[dwIndex].Value.dwValue)
                {
                    *pbAutoConfigScript = TRUE;
                }

                if (PROXY_TYPE_AUTO_DETECT & PerConnOptionList.pOptions[dwIndex].Value.dwValue)
                {
                    *pbAutomaticProxy = TRUE;
                }

                break;

            case INTERNET_PER_CONN_PROXY_SERVER:
                if (NULL != PerConnOptionList.pOptions[dwIndex].Value.pszValue)
                {
                    CmFree(*ppszProxyServer);
                    *ppszProxyServer = CmStrCpyAlloc(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                    LocalFree(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                }
                break;

            case INTERNET_PER_CONN_PROXY_BYPASS:
                if (NULL != PerConnOptionList.pOptions[dwIndex].Value.pszValue)
                {
                    CmFree(*ppszProxyOverride);
                    *ppszProxyOverride = CmStrCpyAlloc(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                    LocalFree(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                }
                break;

            case INTERNET_PER_CONN_AUTOCONFIG_URL:
                if (NULL != PerConnOptionList.pOptions[dwIndex].Value.pszValue)
                {
                    CmFree(*ppszAutoConfigScript);
                    *ppszAutoConfigScript = CmStrCpyAlloc(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                    LocalFree(PerConnOptionList.pOptions[dwIndex].Value.pszValue);
                }
                break;

            default:
                break;
            }
        }
        CmFree(PerConnOptionList.pOptions);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetIE4ProxySettings
//
// Synopsis:  Gets the IE4, per machine, proxy settings.
//            Please note that the strings allocated for the proxy server and the
//            proxy override values must be freed by the caller.
//
// Arguments: LPSTR pszConnection - ignored (exists for prototype consistency with the IE5 version)
//            LPBOOL pbManualProxy - bool pointer to hold whether the manual 
//                                   proxy is enabled or not
//            LPBOOL pbAutomaticProxy - ignored (not supported by IE4)
//            LPBOOL pbAutoConfigScript - ignored (not supported by IE4)
//            LPSTR* ppszProxyServer - string pointer to hold the retrieved 
//                                     proxy server string
//            LPSTR* ppszProxyOverride - string pointer to hold the retrieved
//                                       proxy server string
//            LPSTR* ppszAutoConfigScript - ignored (not supported by IE4)
//
// Returns:   HRESULT - Standard COM return codes
//
// History:   quintinb  Created    10/27/99
//
//+----------------------------------------------------------------------------
HRESULT GetIE4ProxySettings(LPSTR pszConnection, LPBOOL pbManualProxy, LPBOOL pbAutomaticProxy, LPBOOL pbAutoConfigScript,
                            LPSTR* ppszProxyServer, LPSTR* ppszProxyOverride, LPSTR* ppszAutoConfigScript)
{
    //
    //  Check Inputs, note that we don't allow the pointers to be NULL but they could
    //  be empty.    Also note that pszConnection is ignored because IE4 proxy settings are global.
    //
    if ((NULL == pbManualProxy) || (NULL == ppszProxyServer) || (NULL == ppszProxyOverride))
    {
        return E_INVALIDARG;
    }

    DWORD dwTemp;
    DWORD dwSize;
    DWORD dwType;
    HKEY hKey = NULL;
    HRESULT hr = S_OK;

    //
    //  Zero the output params
    //
    *pbManualProxy = FALSE;
    *pbAutomaticProxy = FALSE;
    *pbAutoConfigScript = FALSE;
    *ppszProxyServer = CmStrCpyAlloc(c_pszEmpty);
    *ppszProxyOverride = CmStrCpyAlloc(c_pszEmpty);
    *ppszAutoConfigScript = CmStrCpyAlloc(c_pszEmpty);

    //
    //  Now Create/Open the Internet Settings key
    //
    LONG lResult = RegOpenKeyEx(HKEY_CURRENT_USER, c_pszInternetSettingsPath, 0, KEY_READ, &hKey);
    
    hr = HRESULT_FROM_WIN32(lResult);

    if (SUCCEEDED(hr))
    {
        //
        //  get whether the proxy is enabled or not
        //
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hKey, c_pszProxyEnable, 0, &dwType, (LPBYTE)pbManualProxy, &dwSize);
        hr = HRESULT_FROM_WIN32(lResult);
        
        if (SUCCEEDED(hr))
        {   
            //
            //  get the proxy server value
            //

            lResult = ERROR_INSUFFICIENT_BUFFER;
            dwSize = MAX_PATH;

            do 
            {
                //
                //  Alloc a Buffer
                //
                CmFree(*ppszProxyServer);
                *ppszProxyServer = (CHAR*)CmMalloc(dwSize);

                if (*ppszProxyServer)
                {
                    lResult = RegQueryValueEx(hKey, c_pszProxyServer, 0, &dwType, 
                                          (LPBYTE)*ppszProxyServer, &dwSize);
                }
                else
                {
                    lResult = ERROR_NOT_ENOUGH_MEMORY;    
                }

                hr = HRESULT_FROM_WIN32(lResult);
                dwSize = 2*dwSize;

            } while ((ERROR_INSUFFICIENT_BUFFER == lResult) && (dwSize < 1024*1024));
        
            if (SUCCEEDED(hr))
            {
                //
                //  get the proxy override value
                //
                
                lResult = ERROR_INSUFFICIENT_BUFFER;
                dwSize = MAX_PATH;

                do 
                {
                    //
                    //  Alloc a Buffer
                    //
                    CmFree(*ppszProxyOverride);
                    *ppszProxyOverride = (CHAR*)CmMalloc(dwSize);

                    if (*ppszProxyOverride)
                    {
                        lResult = RegQueryValueEx(hKey, c_pszProxyOverride, 0, &dwType, 
                                              (LPBYTE)*ppszProxyOverride, &dwSize);
                    }
                    else
                    {
                        lResult = ERROR_NOT_ENOUGH_MEMORY;    
                    }

                    hr = HRESULT_FROM_WIN32(lResult);
                    dwSize = 2*dwSize;

                } while ((ERROR_INSUFFICIENT_BUFFER == lResult) && (dwSize < 1024*1024));
            }
        }
    }
    else
    {
        if (ERROR_FILE_NOT_FOUND == lResult)
        {
            //
            //  No Proxy settings to get.
            //
            hr = S_FALSE;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadProxySettingsFromFile
//
// Synopsis:  Reads the proxy settings from the given proxy file and stores them
//            in the provided pointers.  Please note that the buffers allocated
//            by GetString and stored in ppszProxyOverride, ppszProxyServer, and
//            ppszAutoConfigScript must be freed by the caller.  Please see the above
//            format guide for specifics.
//
// Arguments: LPCSTR pszSourceFile - file to read the proxy settings from.
//            LPBOOL pbManualProxy - determines if the manual proxy is enabled or not
//            LPBOOL pbAutomaticProxy - determines if automatic proxy detection is enabled or not
//            LPBOOL pbAutoConfigScript - determines if an automatic config script should be used
//            LPSTR* ppszProxyServer - string pointer to hold the Proxy server value 
//                                     (in server:port format)
//            LPSTR* ppszProxyOverride - string pointer to hold the Proxy override values
//                                     (a semi-colon seperated list)
//            LPSTR* ppszAutoConfigScript - URL for an automatic config script
//            LPBOOL pbUseVpnName - whether the alternate connectoid name should 
//                                  be used (the VPN connectoid name)
//
// Returns:   BOOL - TRUE if the settings were successfully read
//
// History:   quintinb   Created    10/27/99
//
//+----------------------------------------------------------------------------
BOOL ReadProxySettingsFromFile(LPCSTR pszSourceFile, LPBOOL pbManualProxy, LPBOOL pbAutomaticProxy, LPBOOL pbAutoConfigScript,
                               LPSTR* ppszProxyServer, LPSTR* ppszProxyOverride, LPSTR* ppszAutoConfigScript, LPBOOL pbUseVpnName)
{
    //
    //  Check input params
    //
    if ((NULL == ppszProxyOverride) || (NULL == ppszProxyServer) || (NULL == ppszAutoConfigScript) ||
        (NULL == pbAutomaticProxy) || (NULL == pbAutoConfigScript) || (NULL == pbManualProxy) ||
        (NULL == pbUseVpnName) || (NULL == pszSourceFile) || ('\0' == pszSourceFile[0]))
    {
        return FALSE;
    }

    //
    //  Get the Manual proxy settings
    //
    *pbManualProxy = GetPrivateProfileInt(c_pszManualProxySection, c_pszProxyEnable, 0, pszSourceFile);

    GetString(c_pszManualProxySection, c_pszProxyServer, ppszProxyServer, pszSourceFile);

    if (NULL == *ppszProxyServer)
    {
        return FALSE;
    }

    GetString(c_pszManualProxySection, c_pszProxyOverride, ppszProxyOverride, pszSourceFile);

    if (NULL == *ppszProxyOverride)
    {
        return FALSE;
    }

    //
    //  If this is a backup file, we will have the UseVpnName flag to tell us which connectoid name
    //  is appropriate.  Lets look it up.  Note that we default to using the standard connectoid.
    //
    *pbUseVpnName = GetPrivateProfileInt(c_pszManualProxySection, c_pszUseVpnName, 0, pszSourceFile);


    //
    //  Get the Auto proxy settings
    //

    *pbAutomaticProxy = GetPrivateProfileInt(c_pszAutoProxySection, c_pszAutoProxyEnable, 0, pszSourceFile); //"Automatically detect settings" checkbox

    *pbAutoConfigScript = GetPrivateProfileInt(c_pszAutoProxySection, c_pszAutoConfigScriptEnable, 0, pszSourceFile);//"Use automatic configuration script" checkbox

    GetString(c_pszAutoProxySection, c_pszAutoConfigScript, ppszAutoConfigScript, pszSourceFile);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteProxySettingsToFile
//
// Synopsis:  Writes the specified settings to the given backup proxy filename.
//            Please see the above format guide for specifics.
//
// Arguments: LPCSTR pszBackupFile - backup file to write the current settings to
//            BOOL bManualProxy -- bool to tell if the manual proxy is enabled.
//            BOOL bAutomaticProxy -- bool to tell if auto proxy detection is enabled.
//            BOOL bAutoConfigScript -- bool to tell if an auto config 
//                                      script should be used.
//            LPSTR pszProxyServer - proxy server string in server:port format
//            LPSTR pszProxyOverride - semi-colon seperated list of realms for
//                                     which the proxy server should be bypassed.
//            BOOL bUseVpnName - value to write to the UseVpnName file, see format doc above.
//
// Returns:   BOOL - TRUE if the values were written successfully
//
// History:   quintinb      Created    10/27/99
//
//+----------------------------------------------------------------------------
BOOL WriteProxySettingsToFile(LPCSTR pszBackupFile, BOOL bManualProxy, BOOL bAutomaticProxy, BOOL bAutoConfigScript,
                              LPSTR pszProxyServer, LPSTR pszProxyOverride, LPSTR pszAutoConfigScript, BOOL bUseVpnName)
{
    //
    //  Check inputs
    //
    if ((NULL == pszBackupFile) || ('\0' == pszBackupFile[0]) || (NULL == pszProxyServer) || 
        (NULL == pszProxyOverride) || (NULL == pszAutoConfigScript))
    {
        return FALSE;
    }

    BOOL bReturn = TRUE;
    CHAR szTemp[MAX_PATH];

    //
    //  Write the Manual Proxy Settings
    //
    wsprintf(szTemp, "%d", bManualProxy);
    if (!WritePrivateProfileString(c_pszManualProxySection, c_pszProxyEnable, szTemp, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    if (!WritePrivateProfileString(c_pszManualProxySection, c_pszProxyServer, pszProxyServer, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    if (!WritePrivateProfileString(c_pszManualProxySection, c_pszProxyOverride, pszProxyOverride, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    wsprintf(szTemp, "%d", bUseVpnName);
    if (!WritePrivateProfileString(c_pszManualProxySection, c_pszUseVpnName, szTemp, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    //
    //  Write the Automatic Proxy Settings
    //
    wsprintf(szTemp, "%d", bAutomaticProxy);
    if (!WritePrivateProfileString(c_pszAutoProxySection, c_pszAutoProxyEnable, szTemp, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    wsprintf(szTemp, "%d", bAutoConfigScript);
    if (!WritePrivateProfileString(c_pszAutoProxySection, c_pszAutoConfigScriptEnable, szTemp, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    if (!WritePrivateProfileString(c_pszAutoProxySection, c_pszAutoConfigScript, pszAutoConfigScript, pszBackupFile))
    {
        CMTRACE1("CmProxy -- WriteProxySettingsToFile failed, GLE %d", GetLastError());
        bReturn = FALSE;
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  SetProxy
//
// Synopsis:  Proxy entry point for setting the IE4 and IE5 style proxies.  Since
//            this is a Connection Manager connect action it uses the CM connect
//            action format (see CMAK docs for more info).  Thus the parameters
//            to the dll are passed via a string which contains parameters (see the
//            cmproxy spec for a list of the parameter values).
//
// Arguments: HWND hWnd         - Window handle of caller
//            HINSTANCE hInst   - Instance handle of caller
//            LPSTR pszArgs     - Argument string
//            int nShow         - Unused
//
// Returns:   DWORD WINAPI - Error code
//
// History:   quintinb    Created    10/27/99
//
//+----------------------------------------------------------------------------
HRESULT WINAPI SetProxy(HWND hWnd, HINSTANCE hInst, LPSTR pszArgs, int nShow)
{

    //
    //  First figure out if we have IE4 or IE5 available.
    //
    typedef HRESULT (WINAPI *pfnSetProxySettings)(LPSTR, BOOL, BOOL, BOOL, LPSTR, LPSTR, LPSTR);
    typedef HRESULT (WINAPI *pfnGetProxySettings)(LPSTR, LPBOOL, LPBOOL, LPBOOL, LPSTR*, LPSTR*, LPSTR*);
    pfnSetProxySettings SetProxySettings = NULL;
    pfnGetProxySettings GetProxySettings = NULL;

    BOOL bIE5 = FALSE;
    BOOL bManualProxy;
    BOOL bAutomaticProxy;
    BOOL bAutoConfigScript;
    BOOL bUseVpnName = FALSE;
    DLLVERSIONINFO VersionInfo;
    HINSTANCE hWinInet = NULL;
    LPSTR pszProxyServer = NULL;
    LPSTR pszProxyOverride = NULL;
    LPSTR pszAutoConfigScript = NULL;
    LPSTR pszSourceFile = NULL;
    LPSTR pszBackupFile = NULL;
    LPSTR pszConnectionName = NULL;
    LPSTR pszProfileDirPath = NULL;
    LPSTR pszAltName = NULL;
    LPSTR* CmArgV = NULL;

    if (SUCCEEDED(GetBrowserVersion(&VersionInfo)))
    {
        if (5 <= VersionInfo.dwMajorVersion)
        {
            //
            //  Set the function pointers to use the IE5 versions of the functions
            //
            SetProxySettings = SetIE5ProxySettings;
            GetProxySettings = GetIE5ProxySettings;
            bIE5 = TRUE;
        }
        else if ((4 == VersionInfo.dwMajorVersion) && 
            ((71 == VersionInfo.dwMinorVersion) || (72 == VersionInfo.dwMinorVersion)))
        {
            //
            //  Use the IE4 version of the proxy functions
            //
            SetProxySettings = SetIE4ProxySettings;
            GetProxySettings = GetIE4ProxySettings;
        }
        else
        {
            //
            //  We don't work with IE versions less than 4 so lets return right here
            //  without setting anything.
            //
            CMTRACE("CMPROXY--Unable to set the proxy settings because of insufficient IE version.");
            return TRUE;
        }

        //
        //  If we have IE5, then we need to load wininet.dll.
        //
        if (bIE5)
        {
            hWinInet = LoadLibrary("wininet.dll");

            if (hWinInet)
            {
                //
                //  Okay, lets get the procedure addresses for InternetSetOption and InternetQueryOption
                //
                g_pfnInternetQueryOption = (pfnInternetQueryOptionSpec)GetProcAddress(hWinInet, "InternetQueryOptionA");
                g_pfnInternetSetOption = (pfnInternetSetOptionSpec)GetProcAddress(hWinInet, "InternetSetOptionA");

                if ((NULL == g_pfnInternetQueryOption) || (NULL == g_pfnInternetSetOption))
                {
                    FreeLibrary(hWinInet);
                    return FALSE;
                }
            }
        }

        //
        //  Parse out the command line parameters
        //  
        //  command line is of the form: /profile %PROFILE% /DialRasEntry %DIALRASENTRY% /TunnelRasEntry %TUNNELRASENTRYNAME% /source_filename Proxy.txt /backup_filename backup.txt

        CmArgV = GetCmArgV(pszArgs);
        int i = 0;

        if (!CmArgV)
        {
            goto exit;
        }

        while (CmArgV[i])
        {
            if (0 == lstrcmpi(CmArgV[i], "/source_filename") && CmArgV[i+1])
            {
                pszSourceFile = CmStrCpyAlloc(CmArgV[i+1]);
                i = i+2;
            }
            else if (0 == lstrcmpi(CmArgV[i], "/backup_filename") && CmArgV[i+1])
            {
                pszBackupFile = CmStrCpyAlloc(CmArgV[i+1]);
                i = i+2;            
            }
            else if (0 == lstrcmpi(CmArgV[i], "/DialRasEntry") && CmArgV[i+1])
            {
                pszConnectionName = (CmArgV[i+1]);
                i = i+2;            
            }
            else if (0 == lstrcmpi(CmArgV[i], "/TunnelRasEntry") && CmArgV[i+1])
            {
                pszAltName = (CmArgV[i+1]);
                i = i+2;            
            }
            else if (0 == lstrcmpi(CmArgV[i], "/profile") && CmArgV[i+1])
            {
                pszProfileDirPath = (CmArgV[i+1]);
                i = i+2;            
            }
            else
            {
                //
                //  Unknown option.  Lets trace it out and try to continue.  We will do param
                //  verification next so if we don't have enough info to operate correctly we will work there.
                //
                CMTRACE1("Unknown option: %s", CmArgV[i]);
                i++;
            }
        }

        //
        //  Verify that we have at least a source file and a name.
        //
        if ((pszSourceFile) && (pszConnectionName))
        {
            //
            //  Lets parse the cmp path into the profile dir and append it to the filename.
            //
            if (pszProfileDirPath)
            {
                LPSTR pszTemp = CmStrrchr(pszProfileDirPath, '.');
                if (pszTemp)
                {
                    *pszTemp = '\\';
                    *(pszTemp+1) = '\0';
                    
                    pszTemp = CmStrCpyAlloc(pszProfileDirPath);
                    CmStrCatAlloc(&pszTemp, pszSourceFile);
                    CmFree(pszSourceFile);
                    pszSourceFile = pszTemp;

                    if (pszBackupFile)
                    {
                        pszTemp = CmStrCpyAlloc(pszProfileDirPath);
                        CmStrCatAlloc(&pszTemp, pszBackupFile);
                        CmFree(pszBackupFile);
                        pszBackupFile = pszTemp;
                    }
                }
            }

            //
            //  If we have a direct connection or if this is a double dial connection on Win9x then we
            //  will want to use pszAltName instead of pszConnectionName.  This is because in the Win9x case,
            //  the tunnel connectoid has "Tunnel" appended to it since all of the connectoids are stored in
            //  the registry and we cannot have two connectoids with the same name.  If this is a direct
            //  connection this is also important because pszConnectoid will come through as "NULL" and the
            //  Tunnel connectoid name will be the important one. Also, in these cases we need to set 
            //  bWriteOutUseVpnName to TRUE in order to write this flag out for the disconnect action.
            //
            BOOL bWriteOutUseVpnName = FALSE;
            if (pszConnectionName && pszAltName && bIE5)
            {
                if ((0 == lstrcmpi(pszConnectionName, TEXT("NULL"))) || OS_W9X)
                {
                    //
                    //  Then we have a direct connection or a double dial connection on 9x
                    //
                    if (UseVpnName(pszAltName))
                    {
                        pszConnectionName = pszAltName;
                        pszAltName = NULL;
                        bWriteOutUseVpnName = TRUE;
                    }
                }
            }

            //
            //  If we have a backup filename specified then we need to read the current Proxy settings
            //  and save them out to the given filename.
            //
            if (NULL != pszBackupFile)
            {
                if (SUCCEEDED(GetProxySettings(pszConnectionName, &bManualProxy, &bAutomaticProxy, &bAutoConfigScript,
                                               &pszProxyServer, &pszProxyOverride, &pszAutoConfigScript)))
                {
                    BOOL bSuccess = WriteProxySettingsToFile(pszBackupFile, bManualProxy, bAutomaticProxy, bAutoConfigScript, 
                                                             pszProxyServer, pszProxyOverride, pszAutoConfigScript,
                                                             bWriteOutUseVpnName);
                    if (!bSuccess)
                    {
                        CMTRACE("Unable to save settings to backup file, exiting!");
                        goto exit;
                    }

                    CmFree(pszProxyServer); pszProxyServer = NULL;
                    CmFree(pszProxyOverride);  pszProxyOverride = NULL;
                    CmFree(pszAutoConfigScript); pszAutoConfigScript = NULL;
                }            
            }

            //
            //  Now we need to read the proxy settings to apply out of the given file 
            //
            if (ReadProxySettingsFromFile(pszSourceFile, &bManualProxy, &bAutomaticProxy, &bAutoConfigScript, &pszProxyServer, 
                                          &pszProxyOverride, &pszAutoConfigScript, &bUseVpnName))
            {
                //
                //  Finally write the proxy settings.
                //
                if (SUCCEEDED(SetProxySettings(pszConnectionName, bManualProxy, bAutomaticProxy, bAutoConfigScript, 
                                               pszProxyServer, pszProxyOverride, pszAutoConfigScript)))
                {
                    CMTRACE1("CmProxy -- Set proxy settings successfully for %s.", pszConnectionName);
                }
            }            
        }
    }

exit:    

    CmFree(pszProxyServer);
    CmFree(pszProxyOverride);
    CmFree(pszAutoConfigScript);

    CmFree(pszSourceFile);
    CmFree(pszBackupFile);
    CmFree(CmArgV);

    if (hWinInet)
    {
        FreeLibrary(hWinInet);
    }

    //
    //  Always return S_OK because failing to set the proxy shouldn't stop the connection
    //  process.
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\uninstcm_str.h ===
//+----------------------------------------------------------------------------
//
// File:     uninstcm_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Cm Uninstall Reg Key location
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------

const TCHAR* const c_pszRegCmUninstallKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Connection Manager");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmproxy\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//      
// Module:   CMPROXY.DLL (TOOL)
//
// Synopsis: Main entry point for cmproxy.dll
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb   Created   10/27/99
//
//+----------------------------------------------------------------------------

#include "pch.h"

extern "C" BOOL WINAPI DllMain(
    HINSTANCE   hinstDLL,	    // handle to DLL module 
    DWORD       fdwReason,		// reason for calling function 
    LPVOID      lpvReserved 	// reserved 
)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        MYVERIFY(DisableThreadLibraryCalls(hinstDLL));
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\common\strings\userinfo_str.h ===
//+----------------------------------------------------------------------------
//
// File:     userinfo_str.h
//
// Module:   Common Strings for all Modules to Utilize
//
// Synopsis: Reg keys for user info
//			 
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/19/99
//
//+----------------------------------------------------------------------------

const TCHAR* const c_pszRegCmUserInfo = TEXT("SOFTWARE\\Microsoft\\Connection Manager\\UserInfo\\");
const TCHAR* const c_pszRegCmSingleUserInfo = TEXT("SOFTWARE\\Microsoft\\Connection Manager\\SingleUserInfo\\");

const TCHAR* const c_pszCmEntryUserName     = TEXT("UserName");      
const TCHAR* const c_pszCmEntryInetUserName = TEXT("InternetUserName"); 
const TCHAR* const c_pszCmEntryDomain       = TEXT("Domain");        
const TCHAR* const c_pszCmEntryNoPrompt     = TEXT("DialAutomatically"); 
const TCHAR* const c_pszCmEntryCurrentAccessPoint = TEXT("CurrentAccessPoint");
const TCHAR* const c_pszCmEntryAccessPointsEnabled = TEXT("AccessPointsEnabled");
const TCHAR* const c_pszCmEntryBalloonTipsDisplayed = TEXT("BalloonTipsDisplayed");

//
// Used to store the encrypted random key for password encryption and decryption
// UserBlob - main password, UserBlob2 - Internet password
//
const TCHAR* const c_pszCmRegKeyEncryptedPasswordKey              = TEXT("UserBlob");
const TCHAR* const c_pszCmRegKeyEncryptedInternetPasswordKey      = TEXT("UserBlob2");

//
// Reg key used to store ICS user setting
//
const TCHAR* const c_pszCmRegKeyICSDataKey      = TEXT("ICSData");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmproxy\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:     util.cpp
//      
// Module:   CMPROXY.DLL (TOOL)
//
// Synopsis: Utility functions for IE proxy setting connect action.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   quintinb   Created   10/27/99
//
//+----------------------------------------------------------------------------

#include "pch.h"


//+----------------------------------------------------------------------------
//
// Function:  GetBrowserVersion
//
// Synopsis:  This function returns the version of IE currently installed by
//            using the DllGetVersion function of shdocvw.dll.  This is the
//            IE team recommended way of determining the current version of
//            Internet Explorer.
//
// Arguments: DLLVERSIONINFO* pDllVersionInfo - structure for determining the
//                            version of shdocvw.dll.
//
// Returns:   HRESULT - Standard COM error codes
//
// History:   quintinb  Created    10/27/99
//
//+----------------------------------------------------------------------------
HRESULT GetBrowserVersion(DLLVERSIONINFO* pDllVersionInfo)
{
    HINSTANCE   hBrowser;
    HRESULT hr = E_FAIL;
    
    //
    //  Load the DLL
    //

    hBrowser = LoadLibrary("shdocvw.dll");
    
    if (hBrowser)   
    {
        DLLGETVERSIONPROC pDllGetVersion;      
        
        //
        //  Load the version proc
        //

        pDllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hBrowser, "DllGetVersion");
        
        if (pDllGetVersion)      
        {      
            ZeroMemory(pDllVersionInfo, sizeof(DLLVERSIONINFO));      
            pDllVersionInfo->cbSize = sizeof(DLLVERSIONINFO); 
            hr = (*pDllGetVersion)(pDllVersionInfo);            
        }   

        FreeLibrary(hBrowser);
    }

    return hr;
}

//
//  Borrowed from cmdl32.exe
//

#define MAX_CMD_ARGS            15

typedef enum _CMDLN_STATE
{
    CS_END_SPACE,   // done handling a space
    CS_BEGIN_QUOTE, // we've encountered a begin quote
    CS_END_QUOTE,   // we've encountered a end quote
    CS_CHAR,        // we're scanning chars
    CS_DONE
} CMDLN_STATE;

//+----------------------------------------------------------------------------
//
// Function:  GetCmArgV
//
// Synopsis:  Simulates ArgV using GetCommandLine
//
// Arguments: LPTSTR pszCmdLine - Ptr to a copy of the command line to be processed
//
// Returns:   LPTSTR * - Ptr to a ptr array containing the arguments. Caller is
//                       responsible for releasing memory.
//
// History:   nickball    Created     4/9/98
//
//+----------------------------------------------------------------------------
LPTSTR *GetCmArgV(LPTSTR pszCmdLine)
{   
    MYDBGASSERT(pszCmdLine);

    if (NULL == pszCmdLine || NULL == pszCmdLine[0])
    {
        return NULL;
    }

    //
    // Allocate Ptr array, up to MAX_CMD_ARGS ptrs
    //
    
    LPTSTR *ppCmArgV = (LPTSTR *) CmMalloc(sizeof(LPTSTR) * MAX_CMD_ARGS);

    if (NULL == ppCmArgV)
    {
        return NULL;
    }

    //
    // Declare locals
    //

    LPTSTR pszCurr;
    LPTSTR pszNext;
    LPTSTR pszToken;
    CMDLN_STATE state;
    state = CS_CHAR;
    int ndx = 0;  

    //
    // Parse out pszCmdLine and store pointers in ppCmArgV
    //

    pszCurr = pszToken = pszCmdLine;

    do
    {
        switch (*pszCurr)
        {
            case TEXT(' '):
                if (state == CS_CHAR)
                {
                    //
                    // We found a token                
                    //

                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    ppCmArgV[ndx] = pszToken;
                    ndx++;

                    pszCurr = pszToken = pszNext;
                    state = CS_END_SPACE;
                    continue;
                }
				else 
                {
                    if (state == CS_END_SPACE || state == CS_END_QUOTE)
				    {
					    pszToken = CharNext(pszToken);
				    }
                }
                
                break;

            case TEXT('\"'):
                if (state == CS_BEGIN_QUOTE)
                {
                    //
                    // We found a token
                    //
                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    //
                    // skip the opening quote
                    //
                    pszToken = CharNext(pszToken);
                    
                    ppCmArgV[ndx] = pszToken;
                    ndx++;
                    
                    pszCurr = pszToken = pszNext;
                    
                    state = CS_END_QUOTE;
                    continue;
                }
                else
                {
                    state = CS_BEGIN_QUOTE;
                }
                break;

            case TEXT('\0'):
                if (state != CS_END_QUOTE)
                {
                    //
                    // End of the line, set last token
                    //

                    ppCmArgV[ndx] = pszToken;
                }
                state = CS_DONE;
                break;

            default:
                if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    state = CS_CHAR;
                }
                break;
        }

        pszCurr = CharNext(pszCurr);
    } while (state != CS_DONE);

    return ppCmArgV;
}



//+----------------------------------------------------------------------------
//
// Function:  UseVpnName
//
// Synopsis:  This function loads rasapi32.dll and enumerates the active
//            RAS connections using RasEnumConnections to see if the given
//            connectoid name is found.  If it is then it returns TRUE, implying
//            that the alternate name passed in should be used instead of the
//            regular connectoid name (ie.  the tunnel connectoid name exists,
//            therefore you are tunneling).
//
// Arguments: LPSTR pszAltName - 
//
// Returns:   BOOL - return TRUE if the VPN connectoid should be used instead
//                   of the regular dialup connectoid.
//
// History:   quintinb  Created    10/28/99
//
//+----------------------------------------------------------------------------
BOOL UseVpnName(LPSTR pszAltName)
{
    BOOL bReturn = FALSE;

    //
    //  Load RAS
    //
    HINSTANCE hRas = LoadLibrary("rasapi32.dll");

    if (hRas)
    {

        //
        //  Load RasEnumConnections
        //
        typedef DWORD (WINAPI* pfnRasEnumConnectionsSpec)(LPRASCONNA, LPDWORD, LPDWORD);

        pfnRasEnumConnectionsSpec pfnRasEnumConnections = NULL;
        pfnRasEnumConnections = (pfnRasEnumConnectionsSpec)GetProcAddress(hRas, "RasEnumConnectionsA");

        if (pfnRasEnumConnections)
        {
            LPRASCONN pRasConn = NULL;
            DWORD dwSize = 2*sizeof(RASCONN);
            DWORD dwNum = 0;
            DWORD dwResult = 0;

            //
            //  Get a list of Active Connections
            //
            do
            {
                CmFree(pRasConn);
                pRasConn = (LPRASCONN)CmMalloc(dwSize);

                if (pRasConn)
                {
                    pRasConn[0].dwSize = sizeof(RASCONN);
                    dwResult = (pfnRasEnumConnections)(pRasConn, &dwSize, &dwNum);
                }

            } while (ERROR_INSUFFICIENT_BUFFER == dwResult);

            //
            //  Search for the name passed in
            //
            if (ERROR_SUCCESS == dwResult)
            {
                for (DWORD dwIndex = 0; dwIndex < dwNum; dwIndex++)
                {
                    if (0 == lstrcmpi(pszAltName, pRasConn[dwIndex].szEntryName))
                    {
                        //
                        //  Then the Tunnel Name is active and that should be used for
                        //  the proxy
                        //
                        bReturn = TRUE;
                        break;
                    }
                }
            }

            CmFree(pRasConn);
        }

        FreeLibrary (hRas);
    }

    return bReturn;
}



//+----------------------------------------------------------------------------
//
// Function:  GetString
//
// Synopsis:  Wrapper for GetPrivateProfileString that takes care of allocating
//            memory (using CmMalloc) correctly.  GetString will max sure to 
//            allocate enough memory for the string (1MB is used as a sanity
//            check, no string should be that large and GetString will stop
//            trying to allocate memory at that point).  Please note that it is
//            the callers responsibility to free the allocated memory.
//
// Arguments: LPCSTR pszSection - Section name
//            LPCSTR pszKey - Key name
//            LPSTR* ppString - string pointer to fill with the memory 
//                              containing the requested string
//            LPCSTR pszFile - File to retrieve info from
//
// Returns:   Nothing
//
// History:   quintinb  Created    10/28/99
//
//+----------------------------------------------------------------------------
void GetString(LPCSTR pszSection, LPCSTR pszKey, LPSTR* ppString, LPCSTR pszFile)
{
    DWORD dwTemp;
    DWORD dwSize = MAX_PATH;
    BOOL bExit = FALSE;

    do
    {
        CmFree(*ppString);
        *ppString = (CHAR*)CmMalloc(dwSize);

        if (*ppString)
        {
            dwTemp = GetPrivateProfileString(pszSection, pszKey, "", 
                                            *ppString, dwSize, pszFile);
            
            if (((dwSize - 1) == dwTemp) && (1024*1024 > dwSize))
            {
                //
                //  Buffer too small, lets try again.
                //
                dwSize = 2*dwSize;
            }
            else
            {
                bExit = TRUE;
            }
        }
        else
        {
            bExit = TRUE;
        }

    } while (!bExit);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmsample\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//      
// Module:   CMSAMPLE.DLL 
//
// Synopsis: Main entry point for cmsample.dll 
//
// Copyright (c) 2000 Microsoft Corporation
//
//+----------------------------------------------------------------------------

#include <windows.h>

extern "C" BOOL WINAPI DllMain(
    HINSTANCE   hinstDLL,	    // handle to DLL module 
    DWORD       fdwReason,		// reason for calling function 
    LPVOID      lpvReserved 	// reserved 
)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
		//
		// Disable the DLL_THREAD_ATTACH notification calls.
		//
        if (DisableThreadLibraryCalls(hinstDLL) == 0)
		{
			return FALSE;
		}
    }

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmroute\pch.h ===
//+----------------------------------------------------------------------------
//
// File:     PCH.H
//
// Module:   CMROUTE.EXE
//
// Synopsis: Precompiled header
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:	 anbrad   created   02/24/99
//
//+----------------------------------------------------------------------------

#include "windows.h"
#include "winsock.h"
#include "wininet.h"
#include "tchar.h"

#include "iphlpapi.h"   // random IP helper functions

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmroute\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     MAIN.CPP
//
// Module:   CMROUTE.DLL
//
// Synopsis: Start of CMROUTE.DLL
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:       anbrad   created   02/24/99
//
//+----------------------------------------------------------------------------
#include "pch.h"
#include "cmdebug.h"

extern "C" BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    if (DLL_PROCESS_ATTACH == fdwReason)
    {
        MYVERIFY(DisableThreadLibraryCalls(hinstDLL));
    }

    // NOTE: Do we need to disable double loading?  We aren't using Thread local
    //       storage, just static variables.

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmroute\cmroute.cpp ===
//+----------------------------------------------------------------------------
//
// File:    cmroute.cpp
//
// Module:  CMROUTE.DLL
//
// Synopsis: Route Plumbing implementation for CM, as a post-connect action
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  12-Mar-2000 SumitC  Created
//
// Note:
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "iphlpapi.h"
#include "cmdebug.h"

//
//  Function declarations  
//


HRESULT ParseArgs(LPSTR pszArgList,
                  BOOL * pfUseFile,
                  LPSTR pszRoutesFile,
                  BOOL * pfUseURL,
                  LPSTR pszRoutesURL,
                  BOOL * pfProfile,
                  LPSTR pszProfile,
                  BOOL * pfURLNotFoundIgnorable,
                  BOOL * pfKeepTempFiles);
#if 0
// see note below
HRESULT CheckIPForwarding();
#endif
HRESULT Initialize(PMIB_IPFORWARDTABLE * pRouteTable, PMIB_IPFORWARDROW * pGateway);
HRESULT GetRoutesFromFile(LPSTR pszFileName,
                          LPSTR pszProfile,
                          LPSTR * ppszRouteInfo,
                          DWORD * pcbRouteInfo);
HRESULT GetRoutesFromURL(LPSTR pszURL,
                         BOOL fKeepTempFiles,
                         LPSTR * ppszRouteInfo,
                         DWORD * pcbRouteInfo);
HRESULT ProcessRouteInfo(const LPSTR pszNewRouteInfo,
                         DWORD cbNewRouteInfo,
                         PMIB_IPFORWARDTABLE pmibRouteTable,
                         PMIB_IPFORWARDROW pGateway,
                         BOOL * pfDeleteDefaultGateway);
HRESULT DeleteDefaultGateway(PMIB_IPFORWARDROW pGateway);

//
//  Route Table functions
//
HRESULT GetRouteTable(PMIB_IPFORWARDTABLE * pTable);
DWORD GetIf(const MIB_IPFORWARDROW& route, const MIB_IPFORWARDTABLE& RouteTable);
PMIB_IPFORWARDROW GetDefaultGateway(PMIB_IPFORWARDTABLE pRouteTable);

//
//  Helper functions
//
BOOL ConvertSzToIP(LPSTR sz, DWORD& dwIP);
LPTSTR IPtoTsz(DWORD dw);
LPSTR IPtosz(DWORD dwIP, char *psz);
LPSTR StrCpyWithoutQuotes(LPSTR pszDest, LPCSTR pszSrc);
BOOL VerifyProfileAndGetServiceDir(LPSTR pszProfile);

//
//  IP Helper function prototypes
//
typedef DWORD (WINAPI *pfnCreateIpForwardEntrySpec)(PMIB_IPFORWARDROW);
typedef DWORD (WINAPI *pfnDeleteIpForwardEntrySpec)(PMIB_IPFORWARDROW);
typedef DWORD (WINAPI *pfnGetIpForwardTableSpec)(PMIB_IPFORWARDTABLE, PULONG, BOOL);

pfnCreateIpForwardEntrySpec g_pfnCreateIpForwardEntry = NULL;
pfnDeleteIpForwardEntrySpec g_pfnDeleteIpForwardEntry = NULL;
pfnGetIpForwardTableSpec g_pfnGetIpForwardTable = NULL;
HMODULE g_hIpHlpApi = NULL;

#if DBG
void PrintRouteTable();
#endif

//+----------------------------------------------------------------------------
//
// Func:    FreeIpHlpApis
//
// Desc:    This function frees the instance of iphlpapi.dll loaded through
//          LoadIpHelpApis.  Note that it also sets the module handle and all
//          of the function pointers loaded from this module to NULL.
//
// Args:    None
//
// Return:  Nothing
//
// Notes:   
//
// History: 14-Dec-2000   quintinb      Created
//
//-----------------------------------------------------------------------------
void FreeIpHlpApis(void)
{
    if (g_hIpHlpApi)
    {
        FreeLibrary(g_hIpHlpApi);
        g_hIpHlpApi = NULL;
        g_pfnCreateIpForwardEntry = NULL;
        g_pfnDeleteIpForwardEntry = NULL;
        g_pfnGetIpForwardTable = NULL;
    }
}

//+----------------------------------------------------------------------------
//
// Func:    LoadIpHelpApis
//
// Desc:    This functions loads a copy of the iphlpapi.dll and then retrieves
//          function pointers for CreateIpForwardEntry, DeleteIpForwardEntry,
//          and GetIpForwardTable.  The module handle and the function pointers
//          are stored in globals vars.
//
// Args:    None
//
// Return:  HRESULT - S_OK on success, S_FALSE on failure.  This prevents cmroute
//                    from returning an error value (which would stop the connection)
//                    but allows cmroute to exit cleanly.
//
// Notes:   
//
// History: 14-Dec-2000   quintinb      Created
//
//-----------------------------------------------------------------------------
HRESULT LoadIpHelpApis(void)
{
    HRESULT hr = S_FALSE; // we want the connection to continue but cmroute to not do anything...
    g_hIpHlpApi = LoadLibrary(TEXT("IPHLPAPI.DLL"));

    if (g_hIpHlpApi)
    {
        g_pfnCreateIpForwardEntry = (pfnCreateIpForwardEntrySpec)GetProcAddress(g_hIpHlpApi, "CreateIpForwardEntry");
        g_pfnDeleteIpForwardEntry = (pfnDeleteIpForwardEntrySpec)GetProcAddress(g_hIpHlpApi, "DeleteIpForwardEntry");
        g_pfnGetIpForwardTable = (pfnGetIpForwardTableSpec)GetProcAddress(g_hIpHlpApi, "GetIpForwardTable");

        if (g_pfnCreateIpForwardEntry && g_pfnDeleteIpForwardEntry && g_pfnGetIpForwardTable)
        {
            hr = S_OK;
        }
        else
        {
            FreeIpHlpApis();
        }
    }

    CMTRACEHR("LoadIpHelpApis", hr);
    return hr;
}

//+----------------------------------------------------------------------------
//
// Func:    SetRoutes
//
// Desc:    The entry point for handling route munging for VPN connections.
//          This is a Connection Manager connect action and uses the CM connect
//          action format (see CMAK docs for more info).  Thus the parameters
//          to the dll are passed via a string which contains parameters (see the
//          cmproxy spec for a list of the parameter values).
//
// Args:    [hWnd]    - window handle of caller
//          [hInst]   - instance handle of caller
//          [pszArgs] - argument string for connect action
//          [nShow]   - unused
//
// Return:  HRESULT
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------

HRESULT WINAPI SetRoutes(HWND hWnd, HINSTANCE hInst, LPSTR pszArgs, int nShow)
{
    HRESULT             hr = S_OK;
    PMIB_IPFORWARDTABLE pRouteTable        = NULL;
    PMIB_IPFORWARDROW   pGateway           = NULL;
    LPSTR               pszRoutesFromFile  = NULL;
    DWORD               cbRoutesFromFile   = 0;
    LPSTR               pszRoutesFromURL   = NULL;
    DWORD               cbRoutesFromURL    = 0;
    // results of parsing the commandline
    BOOL                fUseFile = FALSE;
    BOOL                fUseURL = FALSE;
    BOOL                fProfile = FALSE;
    BOOL                fURLNotFoundIsNotFatal = FALSE;
    BOOL                fDeleteDefaultGatewayViaFile = FALSE;
    BOOL                fDeleteDefaultGatewayViaURL = FALSE;
    BOOL                fKeepTempFiles = FALSE;
    char                szRoutesFile[MAX_PATH + 1];
    char                szRoutesURL[MAX_PATH + 1];
    char                szProfile[MAX_PATH + 1];

#if 0
/*
    // start security check to block unauthorized users
    // REVIEW: remove before shipping!

    //
    // Quick and dirty security test. See if we can open hard-coded file first.
    // If file is not available, then bail out completely.
    // 
    
    lstrcpy(szRoutesFile, "\\\\sherpa\\route-plumb\\msroutes.txt");

    HANDLE hFile = CreateFile(szRoutesFile,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
        CMTRACE1("Unable to access file %s\n", szRoutesFile);
        MessageBox(NULL, "You are not authorized to use this tool.",
                   "CMROUTE.DLL Custom Action", MB_OK);
        CloseHandle(hFile);
        return E_ACCESSDENIED;
    }
    
    CloseHandle(hFile);

    // end security check
*/
#endif

    //
    //  See if we can get the function pointers we need in IP helper?
    //

    hr = LoadIpHelpApis();

    if (S_OK != hr)
    {
        goto Cleanup;
    }

    //
    //  parse args
    //
    hr = ParseArgs(pszArgs,
                   &fUseFile,
                   szRoutesFile,
                   &fUseURL,
                   szRoutesURL,
                   &fProfile,
                   szProfile,
                   &fURLNotFoundIsNotFatal,
                   &fKeepTempFiles);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

#if 0
// see note below
    hr = CheckIPForwarding();
    if (S_FALSE == hr)
    {
        CMTRACE("SetRoutes: IP forwarding is enabled - cmroute won't do anything");
        hr = S_OK;
        goto Cleanup;
    }
    if (S_OK != hr)
    {
        goto Cleanup;
    }
#endif

#if DBG
    PrintRouteTable();
#endif

    //
    //  Get the routetable and default gateway
    //
    hr = Initialize(&pRouteTable, &pGateway);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    //
    //  Get the routes out of the file if asked
    //
    if (fUseFile)
    {
        hr = GetRoutesFromFile(szRoutesFile,
                               (fProfile ? szProfile : NULL),
                               &pszRoutesFromFile,
                               &cbRoutesFromFile);
        if (S_OK != hr)
        {
            goto Cleanup;
        }

#if DBG
        OutputDebugString(pszRoutesFromFile);
#endif
    }

    //
    //  Get the routes out of the URL if asked
    //
    if (fUseURL)
    {
        hr = GetRoutesFromURL(szRoutesURL,
                              fKeepTempFiles,
                              &pszRoutesFromURL,
                              &cbRoutesFromURL);
        if (S_OK != hr)
        {
            //
            //  It might have been worth adding a clause below to restrict this
            //  to "failures to access the URL", but this list of errorcodes is
            //  likely to be large (and if the system is really hosed, we'll find
            //  out soon enough).  So, bypass *all* errors if /DONT_REQUIRE_URL
            //  is set.
            //
            if (fURLNotFoundIsNotFatal)
            {
                //
                //  If URL_Access_Failure_Not_Fatal is set, don't return an error.
                //  However, we unset the flag so that we stop processing the URL.
                //
                CMTRACE("SetRoutes: dont_require_url is set, bypassing error");
                fUseURL = FALSE;
                hr = S_OK;
            }
            else
            {
                goto Cleanup;
            }
        }
        
#if DBG
        OutputDebugString(pszRoutesFromURL);
#endif
    }

    //
    //  Now set the routes
    //
    MYDBGASSERT(S_OK == hr);
    if (fUseFile)
    {
        hr = ProcessRouteInfo(pszRoutesFromFile, cbRoutesFromFile, pRouteTable, pGateway, &fDeleteDefaultGatewayViaFile);
        if (S_OK != hr)
        {
            CMTRACE1("SetRoutes: adding routes from FILE failed with %x", hr);
            goto Cleanup;
        }
    }

    MYDBGASSERT(S_OK == hr);
    if (fUseURL)
    {
        hr = ProcessRouteInfo(pszRoutesFromURL, cbRoutesFromURL, pRouteTable, pGateway, &fDeleteDefaultGatewayViaURL);
        if (S_OK != hr)
        {
            if ((E_UNEXPECTED == hr) && fURLNotFoundIsNotFatal)
            {
                // we use E_UNEXPECTED to indicate that the URL points to a .htm file
                // instead of the file containing just routes which is what we're
                // expecting.  In this case, we ignore this error.
                //
                CMTRACE("html string found error ignored because Dont_Require_URL is set");
                hr = S_OK;
            }
            else
            {
                CMTRACE1("SetRoutes: adding routes from URL failed with %x", hr);
                goto Cleanup;
            }
        }
    }

    //
    //  Delete default gateway
    //
    MYDBGASSERT(S_OK == hr);
    if (fDeleteDefaultGatewayViaFile || fDeleteDefaultGatewayViaURL)
    {
        hr = DeleteDefaultGateway(pGateway);
    }

Cleanup:
    //
    //  cleanup and leave
    //
    if (pRouteTable)
    {
        VirtualFree(pRouteTable, 0, MEM_RELEASE);
    }

    FreeIpHlpApis();

    CMTRACEHR("SetRoutes", hr);
    return hr;
}

//+----------------------------------------------------------------------------
//
// Func:    GetNextToken
//
// Desc:    utility function for parsing the argument string.  Goes past leading
//          whitespace and extracts a string
//
// Args:    [pszStart] - IN  the argument string
//          [ppszEnd]  - OUT where parsing for this arg ended
//          [pszOut]   - INOUT array of size MAX_PATH to hold arg if found
//
// Return:  BOOL, TRUE if another arg found, FALSE if not
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
GetNextToken(LPSTR pszStart, LPSTR * ppszEnd, LPSTR pszOut)
{
    MYDBGASSERT(pszStart);
    MYDBGASSERT(ppszEnd);

    LPSTR pszEnd = NULL;

    // clear leading white space
    while (isspace(*pszStart))
    {
        pszStart++;
    }

    if (NULL == *pszStart)
    {
        // just white space, no arg
        return FALSE;
    }

    //
    //  If this character is ", this is probably a quoted string, containing spaces.
    //  In this case, the termination character is another ".  Otherwise, assume
    //  it is a regular string terminated by a space.
    //
    if ('"' == *pszStart)
    {
        // may be a string containing spaces.
        pszEnd = strchr(pszStart + 1, '"');
    }

    if (NULL == pszEnd)
    {
        //
        //  Either it's a regular string, or we couldn't find a terminating " char
        //  so we fall back on space-delimited handling.
        //
        pszEnd = pszStart + 1;
        while (*pszEnd && !isspace(*pszEnd))
        {
            pszEnd++;
        }
        pszEnd--;
    }

    UINT cLen = (UINT)(pszEnd - pszStart + 1);

    if (cLen + 1 > MAX_PATH)
    {
        return FALSE;
    }
    else
    {
        lstrcpyn(pszOut, pszStart, cLen + 1);
        *ppszEnd = ++pszEnd;
        return TRUE;
    }
}


//+----------------------------------------------------------------------------
//
// Func:    Initialize
//
// Desc:    Initialization function, gets the route table and default gateway
//
// Args:    [ppmibRouteTable] - return location for route table
//          [ppGateway] - return location for default gateway
//
// Return:  HRESULT
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
Initialize(
    OUT PMIB_IPFORWARDTABLE * ppmibRouteTable,
    OUT PMIB_IPFORWARDROW * ppGateway)
{
    HRESULT hr = S_OK;

    MYDBGASSERT(ppmibRouteTable);
    MYDBGASSERT(ppGateway);

    if (NULL == ppmibRouteTable || NULL == ppGateway)
    {
        return E_INVALIDARG;
    }

    hr = GetRouteTable(ppmibRouteTable);

    if (S_OK == hr)
    {
        MYDBGASSERT(*ppmibRouteTable);
        *ppGateway = GetDefaultGateway(*ppmibRouteTable);
    }

    CMTRACEHR("Initialize", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    ParseArgs
//
// Desc:    convert the argument list into flags for our use.
//
// Args:    [pszArgList] - IN, the argument list
//          [the rest]   - OUT, all the arg values returned
//
// Return:  HRESULT
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
ParseArgs(
    LPSTR pszArgList,
    BOOL * pfUseFile,
    LPSTR pszRoutesFile,
    BOOL * pfUseURL,
    LPSTR pszRoutesURL,
    BOOL * pfProfile,
    LPSTR pszProfile,
    BOOL * pfURLNotFoundIgnorable,
    BOOL * pfKeepTempFiles)
{
    HRESULT hr = S_OK;
    char    szArg[MAX_PATH];

    //
    //  verify arguments
    //
    if (NULL == pszArgList || 0 == lstrlen(pszArgList) ||
        !pfUseFile || !pszRoutesFile || !pfUseURL || !pszRoutesURL ||
        !pfProfile || !pszProfile ||
        !pfURLNotFoundIgnorable ||
        !pfKeepTempFiles)

    {
        return E_INVALIDARG;
    }

    CMTRACE1("ParseArgs: arg list is %s", pszArgList);

    //
    //  set the defaults
    //
    *pfUseFile = *pfUseURL = *pfProfile = *pfURLNotFoundIgnorable = FALSE;

    //
    //  process the Arglist
    //
    while (GetNextToken(pszArgList, &pszArgList, szArg))
    {
        if (0 == lstrcmpi("/Static_File_Name", szArg))
        {
            *pfUseFile = TRUE;

            if (!GetNextToken(pszArgList, &pszArgList, szArg))
            {
                return E_INVALIDARG;
            }

            if (lstrlen(szArg) > MAX_PATH)
            {
                CMTRACE("ParseArgs: file name is bigger than MAX_PATH!!");
                return E_INVALIDARG;
            }

            StrCpyWithoutQuotes(pszRoutesFile, szArg);
        }
        else if (0 == lstrcmpi("/Dont_Require_URL", szArg))
        {
            *pfURLNotFoundIgnorable = TRUE;
        }
        else if (0 == lstrcmpi("/URL_Update_Path", szArg))
        {
            *pfUseURL = TRUE;

            if (!GetNextToken(pszArgList, &pszArgList, szArg))
            {
                return E_INVALIDARG;
            }
            if (lstrlen(szArg) > MAX_PATH)
            {
                CMTRACE("ParseArgs: URL name is bigger than MAX_PATH!!");
                return E_INVALIDARG;
            }

            lstrcpy(pszRoutesURL, szArg);
        }
        else if (0 == lstrcmpi("/Profile", szArg))
        {
            *pfProfile = TRUE;

            if (!GetNextToken(pszArgList, &pszArgList, szArg))
            {
                return E_INVALIDARG;
            }
            if (lstrlen(szArg) > MAX_PATH)
            {
                CMTRACE("ParseArgs: Profile filename is bigger than MAX_PATH!!");
                return E_INVALIDARG;
            }

            StrCpyWithoutQuotes(pszProfile, szArg);
        }
        else if (0 == lstrcmpi("/No_Delete", szArg))
        {
            *pfKeepTempFiles = TRUE;
        }
        else
        {
            CMTRACE1("Cmroute: unrecognized parameter - %s", szArg);
            MYDBGASSERT("Cmroute - unrecognized parameter!!");
        }
    }

    CMTRACEHR("ParseArgs", hr);
    return hr;
}


#if 0

//  2000/11/28 SumitC
//  It wasn't clear what the required action should be when IP forwarding was
//  detected (should the connection be dropped or not) and it is a little late
//  to add UI to Whistler.  The 'Check IP forwarding' feature is thus removed.
//
// see Windows Db bug # 216558 for more details.

//+----------------------------------------------------------------------------
//
// Func:    CheckIPForwarding
//
// Desc:    checks to see if anything is enabled on the client machine that would
//          make us want to have cmroute not do anything
//
// Args:    none
//
// Return:  HRESULT
//
// Notes:   
//
// History: 01-Nov-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
CheckIPForwarding()
{
    HRESULT     hr = S_OK;
    MIB_IPSTATS stats;

    if (NO_ERROR != GetIpStatistics(&stats))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        if (stats.dwForwarding)
        {
            hr = S_FALSE;
        }
    }

    CMTRACEHR("CheckIPForwarding", hr);
    return hr;
}
#endif

//+----------------------------------------------------------------------------
//
// Func:    GetRoutesFromFile
//
// Desc:    extracts the contents of the given file
//
// Args:    [pszFileName]          - IN, filename
//          [pszProfile]           - IN, profile if available
//          [ppszRouteInfo]        - OUT, the route table bytes
//          [pcbRouteInfo]         - OUT, the route table size
//
// Return:  HRESULT
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
GetRoutesFromFile(
    LPSTR pszFileName,
    LPSTR pszProfile,
    LPSTR * ppszRouteInfo,
    DWORD * pcbRouteInfo)
{
    HRESULT hr = S_OK;
    HANDLE  hFile = NULL;
    LPSTR   psz = NULL;
    DWORD   cb = 0;
    BOOL    fRet;
    BY_HANDLE_FILE_INFORMATION info;

    MYDBGASSERT(pszFileName);
    MYDBGASSERT(ppszRouteInfo);
    MYDBGASSERT(pcbRouteInfo);

    if (NULL == pszFileName || NULL == ppszRouteInfo || NULL == pcbRouteInfo)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    CMTRACE1("GetRoutesFromFile: filename is %s", pszFileName);

    //
    //  open the file, and read its contents into a buffer
    //
    hFile = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        //
        //  perhaps the full pathname for the routes file wasn't specified.  If
        //  a Profile was passed in, we extract the ServiceDir and try again,
        //  using the ServiceDir as the path.
        //
        if (VerifyProfileAndGetServiceDir(pszProfile))
        {
            char sz[2 * MAX_PATH + 1];

            lstrcpy(sz, pszProfile);
            lstrcat(sz, pszFileName);

            CMTRACE1("GetRoutesFromFile: retrying with %s", sz);

            hFile = CreateFile(sz, GENERIC_READ, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        }

        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
    }

    if (FALSE == GetFileInformationByHandle(hFile, &info))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (0 == info.nFileSizeLow)
    {
        CMTRACE("Routes file is EMPTY!!");
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto Cleanup;
    }

    psz = (LPSTR) VirtualAlloc(NULL, info.nFileSizeLow, MEM_COMMIT, PAGE_READWRITE);
    if (NULL == psz)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    fRet = ReadFile(hFile, psz, info.nFileSizeLow, &cb, NULL);
    if (FALSE == fRet)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // success

    *ppszRouteInfo = psz;
    *pcbRouteInfo = cb;

Cleanup:
    if (hFile)
    {
        CloseHandle(hFile);
    }
    if (S_OK != hr)
    {
        VirtualFree(psz, 0, MEM_RELEASE);
    }

    CMTRACEHR("GetRoutesFromFile", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    GetRoutesFromURL
//
// Desc:    extracts the contents of the given URL
//
// Args:    [pszURL]               - IN, the URL
//          [fKeepTempFiles]       - IN, do not delete temp buffer file(s)
//          [ppszRouteInfo]        - OUT, the route table bytes
//          [pcbRouteInfo]         - OUT, the route table size
//
// Return:  HRESULT
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
GetRoutesFromURL(
    LPSTR pszURL,
    BOOL fKeepTempFiles,
    LPSTR * ppszRouteInfo,
    DWORD * pcbRouteInfo)
{
    HRESULT     hr = S_OK;
    HINTERNET   hInternet = NULL;
    HINTERNET   hPage = NULL;
    LPBYTE      pb = NULL;
    DWORD       cb = 0;
    TCHAR       szLocalBufferFile[MAX_PATH + 1];
    DWORD       cchLocalBuffer = 0;
    LPTSTR      pszLocalBuffer = NULL;
    FILE *      fp = NULL;
    BYTE        Buffer[1024];
    DWORD       dwRead;

    MYDBGASSERT(pszURL);
    MYDBGASSERT(ppszRouteInfo);
    MYDBGASSERT(pcbRouteInfo);

    if (NULL == pszURL || NULL == ppszRouteInfo || NULL == pcbRouteInfo)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    CMTRACE1("GetRoutesFromURL: URL is %s", pszURL);

    //
    //  Get the path to the temp dir, if there is one.
    //
    cchLocalBuffer = GetTempPath(0, NULL);
    if (0 == cchLocalBuffer)
    {
        DWORD dwErr = GetLastError();
        CMTRACE1(TEXT("GetTempPath failed, using current dir, GLE=%d"), dwErr);
    }
    else
    {
        cchLocalBuffer += (lstrlen(TEXT("\\")) + lstrlen(szLocalBufferFile) + 1);

        pszLocalBuffer = (LPTSTR) VirtualAlloc(NULL,
                                               cchLocalBuffer * sizeof(TCHAR),
                                               MEM_COMMIT,
                                               PAGE_READWRITE);
        if (NULL == pszLocalBuffer)
        {
            hr = E_OUTOFMEMORY;
            CMTRACE(TEXT("GetRoutesFromURL - VirtualAlloc failed"));
            goto Cleanup;
        }

        if (0 == GetTempPath(cchLocalBuffer, pszLocalBuffer))
        {
            DWORD dwErr = GetLastError();
            CMTRACE1(TEXT("GetTempPath 2nd call failed, GLE=%d"), GetLastError());
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Cleanup;
        }
    }

    //
    //  Get a name for the temp file (using the temp path if there is one)
    //
    if (0 == GetTempFileName(pszLocalBuffer ? pszLocalBuffer : TEXT("."),
                             TEXT("CMR"),
                             0,
                             szLocalBufferFile))
    {
        DWORD dwErr = GetLastError();
        CMTRACE1(TEXT("GetTempFileName failed, GLE=%d"), dwErr);
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Cleanup;
    }

    //
    //  Open the temp file, and proceed.
    //
    fp = fopen(szLocalBufferFile, "w+b");
    if (NULL == fp)
    {
        CMTRACE1(TEXT("fopen failed(%s)"), szLocalBufferFile);
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Initialize WININET
    //
    hInternet = InternetOpen(TEXT("RouteMan"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (NULL == hInternet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CMTRACE1(TEXT("InternetOpen failed with 0x%x"), hr);
        goto Cleanup;
    }

    //
    //  Open the URL
    //
    hPage = InternetOpenUrl(hInternet, pszURL, NULL, 0, 0, 0);

    if (NULL == hPage)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CMTRACE1(TEXT("InternetOpenUrl failed with 0x%x"), hr);
        goto Cleanup;
    }

    //
    //  Read the entire URL contents into the tempfile
    //
    do
    {
        if (!InternetReadFile(hPage, Buffer, sizeof(Buffer), &dwRead))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CMTRACE1(TEXT("InternetReadFile failed with 0x%x"), hr);
            goto Cleanup;
        }

        if (fwrite(Buffer, sizeof(BYTE), dwRead, fp) != dwRead)
        {
            CMTRACE1(TEXT("write failed to %s"), pszLocalBuffer);
            hr = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            goto Cleanup;
        }

        cb += dwRead;

#if 0
        // ISSUE-2000/07/21-SumitC Code seems strange but might need it later
        //
        // Vijay/Andrew's original code has this, but is this correct?
        // The doc for InternetReadFile says this is just an EOF, if we
        // are to handle this case at all, we should just break;
        if (!dwRead)
            goto Cleanup;
#endif        
    }
    while (dwRead == 1024);

    hr = S_OK;

    if (fseek(fp, SEEK_SET, 0) != 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pb = (LPBYTE) VirtualAlloc(NULL, cb, MEM_COMMIT, PAGE_READWRITE);
    if (NULL == pb)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (fread(pb, sizeof(BYTE), cb, fp) != cb)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // success

    *ppszRouteInfo = (LPSTR) pb;
    *pcbRouteInfo = cb;

Cleanup:

    if (fp)
    {
        fclose(fp);
    }
    if (FALSE == fKeepTempFiles)
    {
        remove(szLocalBufferFile);
    }

    if (pszLocalBuffer && cchLocalBuffer)
    {
        VirtualFree(pszLocalBuffer, 0, MEM_RELEASE);
    }

    if (hPage)
    {
        InternetCloseHandle(hPage);
    }
    
    if (hInternet)
    {
        InternetCloseHandle(hInternet);
    }

    if (S_OK != hr)
    {
        VirtualFree(pb, 0, MEM_RELEASE);
    }

    CMTRACEHR("GetRoutesFromURL", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    ProcessRouteInfo
//
// Desc:    Parses the given route table and modifies the real routetable accordingly
//
// Args:    [pszNewRouteInfo] - IN, bytes of route table to parse and add to the real one
//          [cbNewRouteInfo]  - IN, size of routetable
//          [pmibRouteTable]  - IN, real route table
//          [pGateway]        - IN, default gateway
//          [pfDeleteGateway] - OUT, does the route file say to delete default gateway?
//
// Return:  HRESULT (E_INVALIDARG, E_UNEXPECTED - for html file, etc)
//
// Notes:   
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
ProcessRouteInfo(
    const LPSTR pszNewRouteInfo,
    DWORD cbNewRouteInfo,
    PMIB_IPFORWARDTABLE pmibRouteTable,
    PMIB_IPFORWARDROW pGateway,
    BOOL * pfDeleteDefaultGateway)
{
    HRESULT hr = S_OK;
    DWORD   cLines = 0;
    char    szBuf[MAX_PATH];
    LPSTR   pszNextLineToProcess;

    MYDBGASSERT(pszNewRouteInfo);
    MYDBGASSERT(cbNewRouteInfo);
    MYDBGASSERT(pmibRouteTable);
    MYDBGASSERT(pGateway);
    MYDBGASSERT(pfDeleteDefaultGateway);

    if (!pszNewRouteInfo || !cbNewRouteInfo || !pmibRouteTable || !pGateway || !pfDeleteDefaultGateway)
    {
        return E_INVALIDARG;
    }

    if ((NULL == g_pfnCreateIpForwardEntry) || (NULL == g_pfnDeleteIpForwardEntry))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
    }

    *pfDeleteDefaultGateway = FALSE;

    // Make sure WININET zero terminates this....
    pszNewRouteInfo[cbNewRouteInfo] = '\0';

    //
    //  Convert string to lower
    //
    CharLowerA(pszNewRouteInfo);

    //
    //  sanity checks (in the URL case, if the route file isn't found the server
    //  is likely to return an HTML file to indicate 404 - file not found.)
    //
    if (strstr(pszNewRouteInfo, "<html"))
    {
        CMTRACE("html string found - invalid route file\n");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    //  for each line
    //
    for (;;)
    {
        DWORD               ipDest, ipMask, ipGateway, ipMetric;
        DWORD               dwIf = -1;
        DWORD               dwParam;
        LPSTR               psz;        // temp var to hold each line as we process it
        MIB_IPFORWARDROW    route;

        enum { VERB_ADD, VERB_DELETE } eVerb;

        //
        //  Per strtok syntax, use pszNewRouteInfo the first time, and NULL thereafter
        //
        psz = strtok(((0 == cLines) ? pszNewRouteInfo : NULL), "\n\0");
        if (NULL == psz)
            break;

        ++cLines;

        //
        //  All errors within the for statement are due to bad data within the file
        //
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

        //
        //  PART 1 : add/delete, followed by the IP address, or remove_gateway
        //
        if (FALSE == GetNextToken(psz, &psz, szBuf))
        {
            CMTRACE1("ProcessRouteInfo [%d] didn't find add/delete which is required", cLines);
            goto Cleanup;
        }

        if (0 == lstrcmpi(szBuf, "add"))
        {
            eVerb = VERB_ADD;
        }
        else if (0 == lstrcmpi(szBuf, "delete"))
        {
            eVerb = VERB_DELETE;
        }
        else if (0 == lstrcmpi(szBuf, "remove_gateway"))
        {
            *pfDeleteDefaultGateway = TRUE;
            hr = S_OK;
            // ignore the rest of the line
            continue;
        }
        else
        {
            CMTRACE2("ProcessRouteInfo [%d] found unexpected string %s instead of add/delete/remove_gateway", cLines, szBuf);
            goto Cleanup;
        }

        if (FALSE == GetNextToken(psz, &psz, szBuf))
        {
            CMTRACE1("ProcessRouteInfo [%d] dest ip required for add/delete, and is missing", cLines);
            goto Cleanup;
        }
        
        if (FALSE == ConvertSzToIP(szBuf, ipDest))
        {
            CMTRACE2("ProcessRouteInfo [%d] required ip address/mask %s has bad format", cLines, szBuf);
            goto Cleanup;
        }

        //
        //  PART 2 : mask, followed by the IP address (NOT REQUIRED)
        //
        if (FALSE == GetNextToken(psz, &psz, szBuf))
        {
            CMTRACE1("ProcessRouteInfo [%d] ends too early after add/delete", cLines);
            goto Cleanup;
        }

        if (0 == lstrcmpi(szBuf, "mask"))
        {
            if (FALSE == GetNextToken(psz, &psz, szBuf))
            {
                CMTRACE1("ProcessRouteInfo [%d] ip required for mask, and is missing", cLines);
                goto Cleanup;
            }

            if (FALSE == ConvertSzToIP(szBuf, ipMask))
            {
                CMTRACE2("ProcessRouteInfo [%d] required ip address/mask %s has bad format", cLines, szBuf);
                goto Cleanup;
            }

            if (FALSE == GetNextToken(psz, &psz, szBuf))
            {
                CMTRACE1("ProcessRouteInfo [%d] ends too early after mask", cLines);
                goto Cleanup;
            }
        }
        else
        {
            CMTRACE1("ProcessRouteInfo [%d] didn't find \"mask\", that's ok, continuing", cLines);
            ipMask = (DWORD)-1;
        }

        //
        //  PART 3 : gateway (or "default")
        //
        if (0 == lstrcmpi(szBuf, "default"))
        {
            ipGateway = pGateway->dwForwardNextHop;
        }
        else
        {
            if (FALSE == ConvertSzToIP(szBuf, ipGateway))
            {
                CMTRACE2("ProcessRouteInfo [%d] bad format for gateway %s", cLines, szBuf);
                goto Cleanup;
            }
        }

        //
        //  PART 4 : metric, followed by a number (REQUIRED)
        //
        if (FALSE == GetNextToken(psz, &psz, szBuf))
        {
            CMTRACE1("ProcessRouteInfo [%d] didn't find \"metric\" which is required", cLines);
            goto Cleanup;
        }

        if (0 == lstrcmpi(szBuf, "metric"))
        {
            if (FALSE == GetNextToken(psz, &psz, szBuf))
            {
                CMTRACE1("ProcessRouteInfo [%d] number value after \"metric\" missing", cLines);
                goto Cleanup;
            }

            if (0 == lstrcmpi(szBuf, "default"))
            {
                ipMetric = pGateway->dwForwardMetric1;
            }
            else
            {
                if (FALSE == ConvertSzToIP(szBuf, ipMetric))
                {
                    CMTRACE2("ProcessRouteInfo [%d] required ip metric %s has bad format", cLines, szBuf);
                    goto Cleanup;
                }

/*
#if 0
                dwParam = sscanf(szBuf, "%d", &ipMetric);
                if (0 == dwParam)
                {
                    CMTRACE2("ProcessRouteInfo [%d] bad format for metric value - %s", cLines, szBuf);
                    goto Cleanup;
                }
#endif
*/
            }
        }
        else
        {
            CMTRACE2("ProcessRouteInfo [%d] found unexpected string %s instead of \"metric\"", cLines, szBuf);
            goto Cleanup;
        }

        //
        //  PART 5 : if (the interface), followed by a number (REQUIRED)
        //
        if (FALSE == GetNextToken(psz, &psz, szBuf))
        {
            CMTRACE1("ProcessRouteInfo [%d] didn't find \"if\" which is required", cLines);
            goto Cleanup;
        }

        if (0 == lstrcmpi(szBuf, "if"))
        {
            if (FALSE == GetNextToken(psz, &psz, szBuf))
            {
                CMTRACE1("ProcessRouteInfo [%d] number value after \"if\" missing", cLines);
                goto Cleanup;
            }

            if (0 == lstrcmpi(szBuf, "default"))
            {
                dwIf = pGateway->dwForwardIfIndex;
            }
            else
            {
                dwParam = sscanf(szBuf, "%d", &dwIf);
                if (0 == dwParam)
                {
                    CMTRACE2("ProcessRouteInfo [%d] bad format for if value - %s", cLines, szBuf);
                    goto Cleanup;
                }
            }
        }
        else
        {
            CMTRACE2("ProcessRouteInfo [%d] found unexpected string %s instead of \"if\"", cLines, szBuf);
            goto Cleanup;
        }

        //
        //  Run the verb (add or delete)
        //
        ZeroMemory(&route, sizeof(route));

        route.dwForwardDest      = ipDest;
        route.dwForwardIfIndex   = dwIf;
        route.dwForwardMask      = ipMask;
        route.dwForwardMetric1   = ipMetric;
        route.dwForwardNextHop   = ipGateway;

        route.dwForwardPolicy    = 0;
        route.dwForwardNextHopAS = 0;
        route.dwForwardType      = 3;
        route.dwForwardProto     = 3;
        route.dwForwardAge       = INFINITE;
        route.dwForwardMetric2   = 0xFFFFFFFF;
        route.dwForwardMetric3   = 0xFFFFFFFF;
        route.dwForwardMetric4   = 0xFFFFFFFF;
        route.dwForwardMetric5   = 0xFFFFFFFF;

        // ISSUE-2000/07/21-SumitC Can we ever really get here in the code with dwIf == -1 ?
        //
        // Check that the interface was specified
        if (-1 == dwIf)
        {
            // Nope, lets go pick one
            dwIf = GetIf(route, *pmibRouteTable);
        }

        DWORD dwRet = 0;

        switch (eVerb)
        {
        case VERB_ADD:
            dwRet = g_pfnCreateIpForwardEntry(&route);
            if (ERROR_SUCCESS != dwRet)
            {
                CMTRACE2("ProcessRouteInfo [%d] CreateIpForwardEntry failed with %d", cLines, dwRet);
                hr = HRESULT_FROM_WIN32(dwRet);
                goto Cleanup;
            }
            hr = S_OK;
            break;
        case VERB_DELETE:
            dwRet = g_pfnDeleteIpForwardEntry(&route);
            if (ERROR_SUCCESS != dwRet)
            {
                CMTRACE2("ProcessRouteInfo [%d] DeleteIpForwardEntry failed with %d", cLines, dwRet);
                hr = HRESULT_FROM_WIN32(dwRet);
                goto Cleanup;
            }
            hr = S_OK;
            break;
        default:
            CMTRACE("ProcessRouteInfo [%d] Unsupported route command, add or delete only");
            MYDBGASSERT(0);
            hr = E_FAIL;
            break;
        }
    }

Cleanup:

    CMTRACEHR("ProcessRouteInfo", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    DeleteDefaultGateway
//
// Desc:    Deletes the default routing gateway for this system
//
// Args:    [pGateway] - the gateway
//
// Return:  HRESULT
//
// Notes:   This should be the last function called within CMroute, and is called
//          only if all other processing succeeded.
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
HRESULT
DeleteDefaultGateway(PMIB_IPFORWARDROW pGateway)
{
    CMTRACE("DeleteDefaultGateway: entering");

    HRESULT hr = S_OK;
    DWORD dwErr = 0;

    if (NULL == g_pfnDeleteIpForwardEntry)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        goto Cleanup;    
    }

    dwErr = g_pfnDeleteIpForwardEntry(pGateway);

    if (NO_ERROR != dwErr)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        CMTRACE1("DeleteDefaultGateway failed with error %x", dwErr);
    }

Cleanup:
    CMTRACEHR("DeleteDefaultGateway", hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
// Func:    IsValidIPAddress
//
// Desc:    Checks to see if given string can be a valid IP address
//
// Args:    [sz] - IN, the string
//
// Return:  BOOL, FALSE means invalid chars were found
//
// History: 20-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
IsValidIPAddress(LPSTR sz)
{
    MYDBGASSERT(sz);

    while ((*sz) && (!isspace(*sz)))
    {
        if ((*sz >= '0') && (*sz <= '9'))
            ;
        else if ((*sz == '.') || (*sz == '*') || (*sz == '?'))
            ;
        else
        {
            CMTRACE1(TEXT("IsValidIPAddress failed on %s\n"), sz);
            MYDBGASSERT("IsValidIPAddress");
            return FALSE;
        }
        ++sz;
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Func:    ConvertSzToIP
//
// Desc:    Converts the given string into a DWORD representing an IP address
//
// Args:    [sz]   - IN, string to convert
//          [dwIP] - OUT BYREF, dword for IP address
//
// Return:  BOOL, FALSE if conversion failed (usually means bad format)
//
// History: 12-Mar-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
ConvertSzToIP(LPSTR sz, DWORD& dwIP)
{
    DWORD dwParams, d1, d2, d3, d4;

    if (FALSE == IsValidIPAddress(sz))
    {
        return FALSE;
    }

    dwParams = sscanf(sz, "%d.%d.%d.%d", &d1, &d2, &d3, &d4);

    if (0 == dwParams)
    {
        MYDBGASSERT("ConvertSzToIP - bad format for IP address");
        return FALSE;
    }
    else if (1 == dwParams)
    {
        dwIP = d1 | 0xffffff00;
    }
    else if (2 == dwParams)
    {
        dwIP = d1 | (d2 << 8) | 0xffff0000;
    }
    else if (3 == dwParams)
    {
        dwIP = d1 | (d2 << 8) | (d3 << 16) | 0xff000000;
    }
    else
    {
        dwIP = d1 | (d2 << 8) | (d3 << 16) | (d4 << 24);
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Func:    GetRouteTable
//
// Desc:    Same as GetIpForwardTable but alloc's the table for you.
//          VirtualFree() the buffer returned.
//
// Args:    [ppTable] - OUT, returned route table
//
// Return:  HRESULT
//
// Notes:   ppTable should be VirtualFree'd by caller.
//
// History: 24-Feb-1999   AnBrad      Created
//          22-Mar-2000   SumitC      Rewrote
//
//-----------------------------------------------------------------------------
HRESULT
GetRouteTable(PMIB_IPFORWARDTABLE * ppTable)
{
    DWORD               dwErr = NO_ERROR;
    DWORD               cbbuf = 0;
    PMIB_IPFORWARDTABLE p = NULL;
    HRESULT             hr = S_OK;

    MYDBGASSERT(ppTable);

    //
    //  Make sure we have a function pointer for GetIpForwardTable
    //
    if (NULL == g_pfnGetIpForwardTable)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        goto Cleanup;
    }

    //
    //  Get the route table
    //
    dwErr = g_pfnGetIpForwardTable(NULL, &cbbuf, FALSE);

    if (ERROR_INSUFFICIENT_BUFFER != dwErr)
    {
        // hmm, a real error
        hr = HRESULT_FROM_WIN32(ERROR_UNEXP_NET_ERR);
        goto Cleanup;
    }
    else
    {
        p = (PMIB_IPFORWARDTABLE) VirtualAlloc(NULL, cbbuf, MEM_COMMIT, PAGE_READWRITE);

        if (!p)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (g_pfnGetIpForwardTable(p, &cbbuf, TRUE))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        *ppTable = p;
    }    

Cleanup:
    if (S_OK != hr)
    {
        if (p)
        {
            VirtualFree(p, 0, MEM_RELEASE);
        }
    }

    CMTRACEHR("GetRouteTable", hr);
    return hr;
}

//+----------------------------------------------------------------------------
//
// Func:    GetIf
//
// Desc:    Find the interface for a route
//
// Args:    [route]      - IN, route for which we need the Interface
//          [RouteTable] - IN, route table
//
// Return:  DWORD which is the IF
//
// Notes:   Logic stolen from \nt\private\net\sockets\strmtcp\route
//
// History: 24-Feb-1999   AnBrad      Created
//          22-Mar-2000   SumitC      Cleaned up
//
//-----------------------------------------------------------------------------
DWORD
GetIf(const MIB_IPFORWARDROW& route, const MIB_IPFORWARDTABLE& RouteTable)
{
    for(DWORD dwIndex = 0; dwIndex < RouteTable.dwNumEntries; dwIndex++)
    {
        const MIB_IPFORWARDROW& Row = RouteTable.table[dwIndex];
        
        if (Row.dwForwardMask && 
            (Row.dwForwardDest & Row.dwForwardMask) == 
            (route.dwForwardNextHop & Row.dwForwardMask))
        {
            return Row.dwForwardIfIndex;
        }         
    }

    return 0;
}


//+----------------------------------------------------------------------------
//
// Func:    GetDefaultGateway
//
// Desc:    Find the default gateway
//
// Args:    [pRouteTable] - IN, the route table (IP forward table)
//
// Return:  PMIB_IPFORWARDROW the row of the gateway (a ptr within pRouteTable)
//
// Notes:   Do not free returned value
//
// History: 24-Feb-1999   AnBrad      Created
//          22-Mar-2000   SumitC      Cleaned up
//
//-----------------------------------------------------------------------------
PMIB_IPFORWARDROW
GetDefaultGateway(PMIB_IPFORWARDTABLE pRouteTable)
{
    PMIB_IPFORWARDROW pRow, pDefGateway;

    // Cycle thru the entire table & find the gateway with the least metric
    pDefGateway = NULL;
    for(pRow = pRouteTable->table; pRow != pRouteTable->table + pRouteTable->dwNumEntries; ++pRow)
    {
        if (pRow->dwForwardDest == 0)
        {
            if (pDefGateway == NULL)
            {
                pDefGateway = pRow;
            }
            else
            {
                if (pRow->dwForwardMetric1 == pDefGateway->dwForwardMetric1 &&
                    pRow->dwForwardAge >= pDefGateway->dwForwardAge)
                {
                    pDefGateway = pRow;
                }
                
                if (pRow->dwForwardMetric1 < pDefGateway->dwForwardMetric1)
                {
                    pDefGateway = pRow;
                }
            }
        }
    }
    
    return pDefGateway;
}


//+----------------------------------------------------------------------------
//
// Func:    StrCpyWithoutQuotes
//
// Desc:    Wrapper for lstrcpy, which removes surrounding double quotes if necessary
//
// Args:    [pszDest] - OUT, destination for the copy
//          [pszSrc]  - OUT, source for the copy
//
// Return:  a ptr to pszDest, or NULL if failure.
//
// Notes:   
//
// History: 12-Apr-1999   SumitC    Created
//
//-----------------------------------------------------------------------------
LPSTR
StrCpyWithoutQuotes(LPSTR pszDest, LPCSTR pszSrc)
{
    MYDBGASSERT(pszDest);
    MYDBGASSERT(pszSrc);

    int len = lstrlen(pszSrc);

    if ((len > 2) && ('"' == pszSrc[0]) && ('"' == pszSrc[len - 1]))
    {
        return lstrcpyn(pszDest, &pszSrc[1], len - 1);
    }
    else
    {
        return lstrcpy(pszDest, pszSrc);
    }
}


//+----------------------------------------------------------------------------
//
// Func:    VerifyProfileAndGetServiceDir
//
// Desc:    Checks the given profile, and modifies it to produce the ServiceDir
//
// Args:    [pszProfile] - IN OUT, profile name, modified IN PLACE
//
// Return:  TRUE if modified pszProfile is now the ServiceDir, or FALSE if failure.
//
// Notes:   pszProfile is MODIFIED IN PLACE.
//
// History: 12-Apr-1999   SumitC    Created
//
//-----------------------------------------------------------------------------
BOOL
VerifyProfileAndGetServiceDir(IN OUT LPSTR pszProfile)
{
    HANDLE hFile = NULL;

    MYDBGASSERT(pszProfile);
    MYDBGASSERT(lstrlen(pszProfile));

    if ((NULL == pszProfile) || (lstrlen(pszProfile) < 4))
    {
        return FALSE;
    }

    //
    //  The profile string may be surrounded by double-quotes, if so remove them.
    //

    //
    //  First check to see if the profile really exists.  This also serves as
    //  verification for the existence of the directory.
    //
    hFile = CreateFile(pszProfile, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        return FALSE;
    }
    else
    {
        CloseHandle(hFile);
    }

    //
    //  Now check to see that the file does indeed end in .CMP
    //

    LPSTR psz = pszProfile + lstrlen(pszProfile) - lstrlen(".CMP");

    if (0 != lstrcmpi(psz, ".CMP"))
    {
        return FALSE;
    }

    //
    //  The profile name is the same as the ServiceDir name, so we just terminate
    //  the string at the '.' and append a '\'
    //

    *psz = '\\';
    psz++;
    *psz = '\0';

    return TRUE;
}


#if DBG

LPWSTR wszType[] = {L"Other", 
                    L"Invalid",
                    L"Direct",
                    L"Indirect"};

LPWSTR wszProto[] ={L"Other",                           // MIB_IPPROTO_OTHER    1
                    L"Local",                           // MIB_IPPROTO_LOCAL    2
                    L"SNMP",                            // MIB_IPPROTO_NETMGMT  3
                    L"ICMP",                            // MIB_IPPROTO_ICMP     4
                    L"Exterior Gateway Protocol",       // MIB_IPPROTO_EGP      5
                    L"GGP",                             // MIB_IPPROTO_GGP      6
                    L"Hello",                           // MIB_IPPROTO_HELLO    7
                    L"Routing Information Protocol",    // MIB_IPPROTO_RIP      8
                    L"IS IS",                           // MIB_IPPROTO_IS_IS    9
                    L"ES IS",                           // MIB_IPPROTO_ES_IS    10
                    L"Cicso",                           // MIB_IPPROTO_CISCO    11
                    L"BBN",                             // MIB_IPPROTO_BBN      12
                    L"Open Shortest Path First",        // MIB_IPPROTO_OSPF     13
                    L"Border Gateway Protocol"};        // MIB_IPPROTO_BGP      14


//+----------------------------------------------------------------------
//
//  Function:   PrintRoute
//
//  Purpose:    Prints out a route from the IP forward table
//
//  Arguments:
//      pRow    [in]    the route
//
//  Returns:    zip
//
//  Author:     anbrad   24 Feb 1999
//
//  Notes:      
//
//-----------------------------------------------------------------------
void PrintRoute(PMIB_IPFORWARDROW pRow)
{
    TCHAR sz[MAX_PATH];

    wsprintf(sz, "dwDest = %s\n", IPtoTsz(pRow->dwForwardDest)); // IP addr of destination
    OutputDebugString(sz);
    wsprintf(sz, "dwMask = %s\n", IPtoTsz(pRow->dwForwardMask)); // subnetwork mask of destination
    OutputDebugString(sz);
    
    wsprintf(sz, "dwPolicy = %d\n"
            "dwNextHop = %s\n"
            "dwIfIndex = %d\n"
            "dwType = %s\n"
            "dwProto = %s\n"
            "dwAge = %d\n"
            "dwNextHopAS = %d\n",

    pRow->dwForwardPolicy,              // conditions for multi-path route
    IPtoTsz(pRow->dwForwardNextHop),    // IP address of next hop
    pRow->dwForwardIfIndex,             // index of interface
    wszType[pRow->dwForwardType-1],     // route type
    wszProto[pRow->dwForwardProto-1],   // protocol that generated route
    pRow->dwForwardAge,                 // age of route
    pRow->dwForwardNextHopAS);          // autonomous system number 
                                        // of next hop
    OutputDebugString(sz);

    if (MIB_IPROUTE_METRIC_UNUSED != pRow->dwForwardMetric1)
    {
        wsprintf(sz, "dwMetric1 = %d\n", pRow->dwForwardMetric1);
        OutputDebugString(sz);
    }

    if (MIB_IPROUTE_METRIC_UNUSED != pRow->dwForwardMetric2)
    {
        wsprintf(sz, "dwMetric2 = %d\n", pRow->dwForwardMetric2);
        OutputDebugString(sz);
    }

    if (MIB_IPROUTE_METRIC_UNUSED != pRow->dwForwardMetric3)
    {
        wsprintf(sz, "dwMetric3 = %d\n", pRow->dwForwardMetric3);
        OutputDebugString(sz);
    }

    if (MIB_IPROUTE_METRIC_UNUSED != pRow->dwForwardMetric4)
    {
        wsprintf(sz, "dwMetric4 = %d\n", pRow->dwForwardMetric4);
        OutputDebugString(sz);
    }

    if (MIB_IPROUTE_METRIC_UNUSED != pRow->dwForwardMetric5)
    {
        wsprintf(sz, "dwMetric5 = %d\n", pRow->dwForwardMetric5);
        OutputDebugString(sz);
    }

    wsprintf(sz, "\n");
    OutputDebugString(sz);
}


#if DBG
//+----------------------------------------------------------------------
//
//  Function:   PrintRouteTable
//
//  Purpose:    Does a "ROUTE PRINT" using the iphlpapi's
//
//  Arguments:  none
//
//  Returns:    zip
//
//  Author:     anbrad   24 Feb 1999
//
//  Notes:      
//
//-----------------------------------------------------------------------
void PrintRouteTable()
{
#define PAGE 4096
    
    BYTE        buf[PAGE];
    DWORD       cbbuf = sizeof(buf);
    TCHAR       sz[MAX_PATH];

    if (g_pfnGetIpForwardTable)
    {
        PMIB_IPFORWARDTABLE table = (PMIB_IPFORWARDTABLE)&buf;
    
        if (g_pfnGetIpForwardTable(table, &cbbuf, TRUE))
            return;

        wsprintf(sz, "\n\nFound %d routes\n", table->dwNumEntries);
        OutputDebugString(sz);

        for (DWORD d=0; d < table->dwNumEntries; ++d)
        {
            PrintRoute(table->table+d);
        }
    }
}
#endif


//+----------------------------------------------------------------------
//
//  Function:   IPtoTsz
//
//  Purpose:    Changes a dword to a "dotted string" notation
//
//  Arguments:
//      dw       [in]   IP address
//
//  Returns:    LPTSTR which is a static string
//
//  Author:     anbrad   24 Feb 1999
//
//  Notes:      Global makes this NOT thread safe, and it is not needed 
//              for cmroute.exe
//
//-----------------------------------------------------------------------

TCHAR tsz[20];


LPTSTR IPtoTsz(DWORD dw)
{
    wsprintf(tsz, TEXT("%03d.%03d.%03d.%03d"), 
                   (DWORD)LOBYTE(LOWORD(dw)),
                   (DWORD)HIBYTE(LOWORD(dw)),
                   (DWORD)LOBYTE(HIWORD(dw)),
                   (DWORD)HIBYTE(HIWORD(dw)));
    
    return tsz;
}

LPSTR IPtosz(DWORD dwIP, char *psz)
{
    wsprintfA(psz, ("%d.%d.%d.%d"), 
                   (DWORD)LOBYTE(LOWORD(dwIP)),
                   (DWORD)HIBYTE(LOWORD(dwIP)),
                   (DWORD)LOBYTE(HIWORD(dwIP)),
                   (DWORD)HIBYTE(HIWORD(dwIP)));
    
    return psz;
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmsample\cmsample.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmsample.cpp 
//      
// Module:   CMSAMPLE.DLL 
//
// Synopsis: Main source for changing proxy file setting using a Tunnel Address
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   tomkel   Created   11/02/2000
//
//+----------------------------------------------------------------------------
#include <windows.h>

//
// Function prototypes
//
LPSTR *GetArgV(LPTSTR pszCmdLine);
BOOL ReadProxyServerByTunnelAddressFromFile(LPCSTR pszSourceFile, LPSTR pszTunnelAddress, LPSTR *ppszProxyServer);
BOOL WriteProxyServerSettingToFile(LPCSTR pszSourceFile, LPSTR pszProxyServer);
HRESULT WINAPI SetProxyUsingTunnelAddress(HWND hWnd, HINSTANCE hInst, LPSTR pszArgs, int nShow);


#define CMSAMPLE_STARTING_BUF_SIZE 256	// Starting size of the string buffer

const CHAR* const c_pszManualProxySection = "Manual Proxy";	// Section to update
const CHAR* const c_pszProxyServer = "ProxyServer";		// Key to update
const CHAR* const c_pszTunnelAddressSection = "Tunnel Address";	// Section to read


//+----------------------------------------------------------------------------
//
// Function:  SetProxyUsingTunnelAddress
//
// Synopsis:  Entry point for changing the proxy file settings using a tunnel
//            address. The parameters to the dll are passed via a string which 
//			  contains parameters.
//
// Arguments: HWND hWnd         - Window handle of caller
//            HINSTANCE hInst   - Instance handle of caller
//            LPSTR pszArgs     - Argument string
//            int nShow         - Unused
//
// Returns:   DWORD WINAPI - Error code
//
// History:   tomkel    Created    11/02/2000
//
//+----------------------------------------------------------------------------
HRESULT WINAPI SetProxyUsingTunnelAddress(HWND hWnd, HINSTANCE hInst, LPSTR pszArgs, int nShow)
{
    HRESULT hr = S_FALSE;		
    LPSTR* ArgV = NULL;
    LPSTR pszServiceDir = NULL;
    LPSTR pszTunnelAddress = NULL;
    LPSTR pszProxyFile = NULL;
    LPSTR pszTunnelFile = NULL;
    LPSTR pszTunnelSettingFilePath = NULL;
    LPSTR pszProxyFilePath = NULL;
    LPSTR pszProxyServer = NULL;
    DWORD dwTunnelPathLen = 0;
    DWORD dwProxyPathLen = 0;
    DWORD dwProxyServerLen = 0;
    HANDLE hCurrentHeap = GetProcessHeap();
    int i = 0;

    //
    //  Parse out the command line parameters
    //  
    //  command line is of the form: /ServiceDir %SERVICEDIR% /TunnelServerAddress %TUNNELSERVERADDRESS% /ProxyFile <PROXYFILE> /TunnelFile <TUNNELFILE>

    //
    // Check if we have any arguments
    //
    if (!pszArgs)
    {
        goto exit;
    }

    // 
    // Separate each argument in the string by '\0' and return a list of pointers
    // to each argument
    //
    ArgV = GetArgV(pszArgs);

    //
    // Check if we have any valid parsed arguments
    //

    if (!ArgV)
    {
        goto exit;
    }

    // 
    // Search the command line arguments for the following switches and their
    // corresponding values
    //
    while (ArgV[i])
    {
        if (0 == lstrcmpi(ArgV[i], "/ServiceDir") && ArgV[i+1])
        {
            pszServiceDir = (ArgV[i+1]);
            i = i+2;
        }
        else if (0 == lstrcmpi(ArgV[i], "/TunnelServerAddress") && ArgV[i+1])
        {
            pszTunnelAddress = ArgV[i+1];
            i = i+2;            
        }
        else if (0 == lstrcmpi(ArgV[i], "/ProxyFile") && ArgV[i+1])
        {
            pszProxyFile = ArgV[i+1];
            i = i+2;            
        }
        else if (0 == lstrcmpi(ArgV[i], "/TunnelFile") && ArgV[i+1])
        {
            pszTunnelFile = ArgV[i+1];
            i = i+2;            
        }
        else
        {
            //
            //  Unknown option.  
            //
            i++;
        }
    }

    //
    // Make sure we have values for the arguments
    //
    if (!pszServiceDir || !pszTunnelAddress || !pszProxyFile || !pszTunnelFile)
    {
        goto exit;
    }

    //
    // Check to see if we got zero length string values from the command line arguments.
    // Exit if that is the case
    //
    if (!(*pszServiceDir) || !(*pszTunnelAddress) ||	
        !(*pszProxyFile) || !(*pszTunnelFile))
    {
        goto exit;
    }

    //
    // Calculate the string size for the two paths that need to be created
    //
    dwTunnelPathLen = lstrlen(pszServiceDir) +  lstrlen(pszTunnelFile) + 2; // 1 space for NULL, 1 for backslash
    dwProxyPathLen = lstrlen(pszServiceDir) +  lstrlen(pszProxyFile) + 2; // 1 space for NULL, 1 for backslash

    //
    // Allocate the memory
    //
    pszTunnelSettingFilePath = (LPSTR)HeapAlloc(hCurrentHeap, HEAP_ZERO_MEMORY, dwTunnelPathLen); // ANSI - char == byte
    if (!pszTunnelSettingFilePath)
    {
        goto exit;
    }

    pszProxyFilePath = (LPSTR)HeapAlloc(hCurrentHeap, HEAP_ZERO_MEMORY, dwProxyPathLen); // ANSI - char == byte
    if (!pszProxyFilePath)
    {
        goto exit;
    }

    //
    // Create the full path to the Tunnel Address file 
    //

    if ( wsprintf(pszTunnelSettingFilePath, "%s\\%s", pszServiceDir, pszTunnelFile) < (int)(dwTunnelPathLen - 1))
    {
        goto exit;
    }

    //
    // Create the full path to the Proxy file
    //

    if (wsprintf(pszProxyFilePath, "%s\\%s", pszServiceDir, pszProxyFile) < (int)(dwProxyPathLen - 1))
    {
        goto exit;
    }

    if (ReadProxyServerByTunnelAddressFromFile(pszTunnelSettingFilePath, pszTunnelAddress, &pszProxyServer))
    {
        //
        // Call WriteProxyServerSettingToFile - the function checks for empty strings
        //
        if(WriteProxyServerSettingToFile(pszProxyFilePath, pszProxyServer))
        {
            hr = S_OK;
        }
    }

	
exit:
    //
    // Clean up allocated memory
    // Delete the argument pointers, Tunnel Server path, Proxy file path and ProxyServer name pointers
    //
    if (ArgV)
    {
        HeapFree(hCurrentHeap, 0, ArgV);
    }

    if (pszTunnelSettingFilePath)
    {
        HeapFree(hCurrentHeap, 0, pszTunnelSettingFilePath);
    }
    
    if (pszProxyFilePath)
    {
        HeapFree(hCurrentHeap, 0, pszProxyFilePath);
    }

    if (pszProxyServer)
    {
        HeapFree(hCurrentHeap, 0, pszProxyServer);
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
// Function:  ReadProxyServerByTunnelAddressFromFile
//
// Synopsis:  Reads the proxy settings from the given proxy file and stores them
//            in the provided pointers.  Please note that the buffers allocated
//            here and stored in ppszProxyServer must be freed by the caller.  
//			  If the TunnelAddress doesn't exist in the pszSourceFile this
//			  function still allocates memory and returns an empty string.
//
// Arguments: LPCSTR pszSourceFile - file to read the proxy settings from.
//            LPSTR  pszTunnelAddress - string containing the TunnelAddress used 
//										to look up the ProxyServer value
//            LPSTR  *ppszProxyServer - string pointer that will have the Proxy server value 
//                                     (in server:port format)
//
// Returns:   BOOL - TRUE if the settings were successfully read
//
//+----------------------------------------------------------------------------
BOOL ReadProxyServerByTunnelAddressFromFile(LPCSTR pszSourceFile, LPSTR pszTunnelAddress, LPSTR *ppszProxyServer)
{
    BOOL bReturn = FALSE;
    BOOL bExit = FALSE;
    DWORD dwReturnedSize = 0;
    DWORD dwSize = CMSAMPLE_STARTING_BUF_SIZE;		

    //
    //  Check input parameters
    //
    if ((NULL == ppszProxyServer) || (NULL == pszSourceFile) || (NULL == pszTunnelAddress))
    {
        return FALSE;
    }

    //
    // Check for empty strings
    //
    if (!(*pszSourceFile) || !(*pszTunnelAddress) || !(*c_pszTunnelAddressSection))
    {
        return FALSE;
    }

    // 
    // Set the incoming pointer to NULL
    //
    *ppszProxyServer = NULL;

    //
    // In case the original buffer size is too small, the loop will try to allocate 
    // more buffer space and try to read the value until. The loop will exist if the 
    // value properly fits into the buffer or the size exceeds 1024*1024. 
    //
    do
    {
        //
        // Free allocated memory
        //

        if (*ppszProxyServer)
        {
            HeapFree(GetProcessHeap(), 0, *ppszProxyServer);
            *ppszProxyServer = NULL;
        }

        //
        // Allocate space for the ProxyServer name
        //

        *ppszProxyServer = (LPSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize); //ANSI - char == byte

        if (*ppszProxyServer)
        {
            // Since memory allocation succeeded, read the value from the settings file
            dwReturnedSize = GetPrivateProfileString(c_pszTunnelAddressSection, pszTunnelAddress, "", *ppszProxyServer, dwSize, pszSourceFile);

            //
            // Check if the value fits into the buffer
            //
            if ((dwReturnedSize == (dwSize - 2))  || (dwReturnedSize == (dwSize - 1)))
            {
                //
                //  The buffer is too small, lets allocate a bigger one
                //
                dwSize = 2*dwSize;
                if (dwSize > 1024*1024)
                {
                    //
                    // Allocation above 1MB, need to exit
                    //
                    if (*ppszProxyServer)
                    {
                        HeapFree(GetProcessHeap(), 0, *ppszProxyServer);
                        *ppszProxyServer = NULL;
                    }
                    goto exit;
                }
            }
            else if (0 == dwReturnedSize)
            {
                //
                //  Either we got an error, or more likely there was no data to get
                //
                if (*ppszProxyServer)
                {
                    HeapFree(GetProcessHeap(), 0, *ppszProxyServer);
                    *ppszProxyServer = NULL;
                }
                goto exit;
            }
            else
            {
                //
                // The function read in the data correctly
                //
                bExit = TRUE;
                bReturn = TRUE;
            }
        }
        else
        {
            bExit = TRUE;
        }

    } while (!bExit);

exit:
    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteProxyServerSettingToFile
//
// Synopsis:  Writes the specified settings to the given backup proxy filename.
//            Please see the above format guide for specifics.
//
// Arguments: LPCSTR pszSourceFile - file to write the current settings to
//            LPSTR pszProxyServer - proxy server string in server:port format
//
// Returns:   BOOL - TRUE if the values were written successfully
//
// History:   tomkel      Created    11/02/2000
//
//+----------------------------------------------------------------------------
BOOL WriteProxyServerSettingToFile(LPCSTR pszSourceFile, LPSTR pszProxyServer)
{
    BOOL bReturn = FALSE;

    //
    //  Check input params
    //
    if ( (NULL == pszSourceFile) || (NULL == pszProxyServer))
    {
        return bReturn;
    }

    //
    // Check for empty strings
    //
    if (!(*pszSourceFile) || !(*pszProxyServer))
    {
        return bReturn;
    }

    //
    //  Save the Proxy Server name to the Proxy setting file
    //
    if (WritePrivateProfileString(c_pszManualProxySection, c_pszProxyServer, pszProxyServer, pszSourceFile))
    {
        bReturn = TRUE;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmsample\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:     util.cpp
//      
// Module:   CMSAMPLE.DLL 
//
// Synopsis: Utility functions for parsing command line arguments
//
// Copyright (c) 2000 Microsoft Corporation
//
//+----------------------------------------------------------------------------

#include <windows.h>

#define MAX_CMD_ARGS        15	// Maximum number of arguments expected

//
// Enumerations to keep pointer state for parsing command line arguments
//
typedef enum _CMDLN_STATE
{
    CS_END_SPACE,   // done handling a space
    CS_BEGIN_QUOTE, // we've encountered a begin quote
    CS_END_QUOTE,   // we've encountered a end quote
    CS_CHAR,        // we're scanning chars
    CS_DONE
} CMDLN_STATE;

//+----------------------------------------------------------------------------
//
// Function:  GetArgV
//
// Synopsis:  Simulates ArgV using GetCommandLine
//
// Arguments: LPSTR pszCmdLine - Ptr to a copy of the command line to be processed
//
// Returns:   LPSTR * - Ptr to a ptr array containing the arguments. Caller is
//                       responsible for releasing memory.
//
//				
//+----------------------------------------------------------------------------
LPSTR *GetArgV(LPSTR pszCmdLine)
{   
    if (NULL == pszCmdLine || NULL == pszCmdLine[0])
    {
        return NULL;
    }

    //
    // Allocate Ptr array, up to MAX_CMD_ARGS ptrs
    //
    
	LPSTR *ppArgV = (LPSTR *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LPSTR) * MAX_CMD_ARGS);

    if (NULL == ppArgV)
    {
        return NULL;
    }

    //
    // Declare locals
    //

    LPSTR pszCurr;
    LPSTR pszNext;
    LPSTR pszToken;
    CMDLN_STATE state;
    state = CS_CHAR;
    int ndx = 0;  

    //
    // Parse out pszCmdLine and store pointers in ppArgV
    //

    pszCurr = pszToken = pszCmdLine;

    do
    {
        switch (*pszCurr)
        {
            case TEXT(' '):
                if (state == CS_CHAR)
                {
                    //
                    // We found a token                
                    //

                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    ppArgV[ndx] = pszToken;
                    ndx++;

                    pszCurr = pszToken = pszNext;
                    state = CS_END_SPACE;
                    continue;
                }
				else 
                {
                    if (state == CS_END_SPACE || state == CS_END_QUOTE)
				    {
					    pszToken = CharNext(pszToken);
				    }
                }
                
                break;

            case TEXT('\"'):
                if (state == CS_BEGIN_QUOTE)
                {
                    //
                    // We found a token
                    //
                    pszNext = CharNext(pszCurr);
                    *pszCurr = TEXT('\0');

                    //
                    // skip the opening quote
                    //
                    pszToken = CharNext(pszToken);
                    
                    ppArgV[ndx] = pszToken;
                    ndx++;
                    
                    pszCurr = pszToken = pszNext;
                    
                    state = CS_END_QUOTE;
                    continue;
                }
                else
                {
                    state = CS_BEGIN_QUOTE;
                }
                break;

            case TEXT('\0'):
                if (state != CS_END_QUOTE)
                {
                    //
                    // End of the line, set last token
                    //

                    ppArgV[ndx] = pszToken;
                }
                state = CS_DONE;
                break;

            default:
                if (state == CS_END_SPACE || state == CS_END_QUOTE)
                {
                    state = CS_CHAR;
                }
                break;
        }

        pszCurr = CharNext(pszCurr);
    } while (state != CS_DONE);

    return ppArgV;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\migrate\makefile.inc ===
$(O)\msg.mc: $(BASE_INC_PATH)\vendinfo.mc
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\migrate\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//      
// Module:   MIGRATE.DLL 
//
// Synopsis: Main entry point for Migrate.DLL
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   created     08/21/98
//
//+----------------------------------------------------------------------------

#include "migrate.h"

#include "linkdll.h" // LinkToDll and BindLinkage for cmsecure.lib
#include "linkdll.cpp" // LinkToDll and BindLinkage for cmsecure.lib

const int c_NumFiles = 28;
char OriginalNames[c_NumFiles][MAX_PATH+1] = {
    "\\showicon.exe",
    "\\swflash.ocx",
    "\\urlmon.dll",
    "\\iexpress.exe",
    "\\oleaut32.dll",
    "\\wextract.exe",
    "\\cm32\\enu\\advapi32.dll",
    "\\cm32\\enu\\advpack.dll",
    "\\cm32\\enu\\cmdial32.dll",
    "\\cm32\\enu\\cmdl32.exe",
    "\\cm32\\enu\\cmmgr32.exe",
    "\\cm32\\enu\\cmmgr32.hlp",
    "\\cm32\\enu\\cmpbk32.dll",
    "\\cm32\\enu\\cmstats.dll",
    "\\cm32\\enu\\comctl32.dll",
    "\\cm32\\enu\\ccfg95.dll",
    "\\cm32\\enu\\ccfgnt.dll",
    "\\cm32\\enu\\icwscrpt.exe",
    "\\cm32\\enu\\cnet16.dll",
    "\\cm32\\enu\\cnetcfg.dll",
    "\\cm32\\enu\\mbslgn32.dll",
    "\\cm32\\enu\\readme.txt",
    "\\cm32\\enu\\rnaph.dll",
    "\\cm32\\enu\\w95inf16.dll",
    "\\cm32\\enu\\w95inf32.dll",
    "\\cm32\\enu\\wininet.dll",
    "\\cm32\\enu\\wintrust.dll",
    "\\cm32\\enu\\cmcfg32.dll",
};

char TempNames[c_NumFiles][MAX_PATH+1] = {
    "\\showicon.tmp",
    "\\swflash.tmp",
    "\\urlmon.tmp",
    "\\iexpress.tmp",
    "\\oleaut32.tmp",
    "\\wextract.tmp",
    "\\advapi32.tmp",
    "\\advpack.tmp",
    "\\cmdial32.tmp",
    "\\cmdl32.tmp",
    "\\cmmgr32.001",
    "\\cmmgr32.002",
    "\\cmpbk32.tmp",
    "\\cmstats.tmp",
    "\\comctl32.tmp",
    "\\ccfg95.tmp",
    "\\ccfgnt.tmp",
    "\\icwscrpt.tmp",
    "\\cnet16.tmp",
    "\\cnetcfg.tmp",
    "\\mbslgn32.tmp",
    "\\readme.tmp",
    "\\rnaph.tmp",
    "\\w95inf16.tmp",
    "\\w95inf32.tmp",
    "\\wininet.tmp",
    "\\wintrust.tmp",
    "\\cmcfg32.tmp",
};

//
//  Global Vars
//
BOOL g_bMigrateCmak10;
BOOL g_bMigrateCmak121;
BOOL g_bMigrateCm;
BOOL g_fInitSecureCalled;
DWORD g_dwNumValues;
DWORD  g_dwTlsIndex; // thread local storage index
HINSTANCE g_hInstance;
TCHAR g_szWorkingDir[MAX_PATH+1];
TCHAR g_szCmakPath[MAX_PATH+1];
VENDORINFO g_VendorInfo;
           
//+---------------------------------------------------------------------------
//
//	Function:	DllMain
//
//	Synopsis:	Main initialization function for this dll.  Called whenever
//              a new instance of this dll is loaded or a new thread created.
//
//	Arguments:	HINSTANCE hinstDLL - handle to DLL module 
//              DWORD fdwReason - reason for calling function 
//              LPVOID lpvReserved - reserved 
//
//	Returns:	BOOL - TRUE if initialization was successful, FALSE otherwise
//
//	History:	quintinb    Created Header      01/13/2000
//
//----------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	if (fdwReason == DLL_PROCESS_ATTACH)
    {
        //
        //  Init Globals
        //

        g_hInstance = hinstDLL;
        g_fInitSecureCalled = FALSE;
		g_bMigrateCmak10 = FALSE;
		g_bMigrateCmak121 = FALSE;

        ZeroMemory(g_szCmakPath, sizeof(g_szCmakPath));

        //
        // alloc tls index
        //
        g_dwTlsIndex = TlsAlloc();
        if (g_dwTlsIndex == TLS_OUT_OF_INDEXES)
        {
            return FALSE;
        }

        MYVERIFY(DisableThreadLibraryCalls(hinstDLL));
    }

    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        //
        // free the tls index
        //
        if (g_dwTlsIndex != TLS_OUT_OF_INDEXES)
        {
            TlsFree(g_dwTlsIndex);
        }
    }

	return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  QueryVersion
//
// Synopsis:  Supplies the Dll's version and identification information.
//
// Arguments: OUT LPCSTR  *ProductID - buffer to hold a string that uniquely 
//                                     identifies the migration dll
//            OUT LPUINT DllVersion - Pointer to an Integer to hold the version 
//                                    number of the migration DLL
//            OUT LPINT *CodePageArray - pointer to an array of code pages that
//                                       the migration dll supports
//            OUT LPCSTR  *ExeNamesBuf - a pointer to a multi-sz string.  The
//                                       buffer contains a null separated list
//                                       of executable file names that the
//                                       migration engine should search for.
//                                       Full paths to all occurences of these
//                                       executables will be copied to the
//                                       [Migration Paths] section of migrate.inf.
//            OUT PVENDORINFO  *VendorInfo - pointer to a VENDORINFO structure
//
// Returns:   LONG -  ERROR_NOT_INSTALLED if the component that this dll is to 
//                    migrate isn't installed.  The migration dll won't be called
//                    in any of the other stages if this is the return value.
//                    ERROR_SUCCESS if the component that this dll is to migrate
//                    is installed and requires migration.  This will allow the
//                    migration dll to be called again for further migration.
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG CALLBACK QueryVersion(OUT LPCSTR  *ProductID, OUT LPUINT DllVersion, 
                               OUT LPINT *CodePageArray, OUT LPCSTR  *ExeNamesBuf, 
                               OUT PVENDORINFO  *VendorInfo)
{
    //
    //  Record our version information.
    //
    if (NULL != ProductID)
    {
        *ProductID = c_pszProductIdString;
    }

    if (NULL != DllVersion)
    {
        *DllVersion = uCmMigrationVersion;
    }    

    if (NULL != CodePageArray)
    {
        *CodePageArray = NULL; // no code page dependencies, language neutral
    }

    if (NULL != ExeNamesBuf)
    {
        *ExeNamesBuf = NULL; // 
    }

    if (NULL != VendorInfo)
    {
        *VendorInfo= &g_VendorInfo;
        ZeroMemory(&g_VendorInfo, sizeof(VENDORINFO));

        //
        //  Use the standard MS vendor info from vendinfo.mc
        //
        FormatMessage( 
            FORMAT_MESSAGE_FROM_HMODULE,
            g_hInstance,
            MSG_VI_COMPANY_NAME,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            &g_VendorInfo.CompanyName[0],
            sizeof(g_VendorInfo.CompanyName),
            NULL
            );
    
        FormatMessage( 
            FORMAT_MESSAGE_FROM_HMODULE,
            g_hInstance,
            MSG_VI_SUPPORT_NUMBER,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            &g_VendorInfo.SupportNumber[0],
            sizeof(g_VendorInfo.SupportNumber),
            NULL
            );
    
        FormatMessage( 
            FORMAT_MESSAGE_FROM_HMODULE,
            g_hInstance,
            MSG_VI_SUPPORT_URL,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            &g_VendorInfo.SupportUrl[0],
            sizeof(g_VendorInfo.SupportUrl),
            NULL
            );
    
        FormatMessage( 
            FORMAT_MESSAGE_FROM_HMODULE,
            g_hInstance,
            MSG_VI_INSTRUCTIONS,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            &g_VendorInfo.InstructionsToUser[0],
            sizeof(g_VendorInfo.InstructionsToUser),
            NULL
            );
    }
        
    //
    //  Now try to detect if CMAK or CM are installed.  If they are and the versions
    //  are such that they need to be migrated, then return ERROR_SUCCESS.  Otherwise
    //  we don't need to do any migration, so return ERROR_NOT_INSTALLED.
    //

    LONG lReturnValue = ERROR_NOT_INSTALLED;
	CmVersion CmVer;
    if (CmVer.IsPresent())
    {
        lReturnValue = ERROR_SUCCESS;
    }
    else
    {
		CmakVersion CmakVer;
        //
        //  Okay, CM wasn't installed so look for CMAK.
        //
        if (CmakVer.IsPresent())
        {
            //
            //  Okay, CMAK exists
            //
            lReturnValue = ERROR_SUCCESS;
        }
    }

    return lReturnValue;
}

//+----------------------------------------------------------------------------
//
// Function:  Initialize9x
//
// Synopsis:  This function is called so that the migration dll can initialize
//            itself on the Win9x side of the migration.  The migration dll
//            should not make any modifications to the system in this call, as
//            it is only for initialization and searching to see if your component
//            is installed.
//
// Arguments: IN LPCSTR WorkingDirectory - path of the temporary storage dir for
//                                         the migration dll.
//            IN LPCSTR SourceDirectories - a multi-sz list of the Win2k source
//                                          directory or directories
//            IN LPCSTR MediaDirectory - specifies the path to the original media
//                                       directory
//
// Returns:   LONG -  ERROR_NOT_INSTALLED if the component that this dll is to 
//                    migrate isn't installed.  The migration dll won't be called
//                    in any of the other stages if this is the return value.
//                    ERROR_SUCCESS if the component that this dll is to migrate
//                    is installed and requires migration.  This will allow the
//                    migration dll to be called again for further migration.
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG CALLBACK Initialize9x(IN LPCSTR WorkingDirectory, IN LPCSTR SourceDirectories, 
                           IN LPCSTR MediaDirectory)
{
    HKEY hKey;
    //
    //  Check to see if we need to Migrate CMAK
    //

	CmakVersion CmakVer;

	lstrcpy(g_szWorkingDir, WorkingDirectory);

	if (CmakVer.IsPresent())
	{
		if (CmakVer.GetInstallLocation(g_szCmakPath))
		{
                        //
                        //  Then we have a CMAK path.  Write this to the handled key so that
                        //  they won't mess with our files.
                        //

			TCHAR szTemp[MAX_PATH+1];
                        wsprintf(szTemp, "%s\\migrate.inf", WorkingDirectory);
                        MYVERIFY(0 != WritePrivateProfileString(c_pszSectionHandled, g_szCmakPath, 
                        c_pszDirectory, szTemp));

			//
			//	Now try to figure out what version of CMAK we have to see if we need
			//  to run the migration DLL or not.  If the CMAK.exe version is 6.00.613.0 (1.0)
			//  then we should migrate it.  If it is higher than that, 1.1 or 1.2 it is 
			//  beta and we shouldn't support the upgrade anyway (I purposely am not
			//  going to run the migration on it).  If it is IE5 IEAK CMAK, then it should
			//  survive upgrade without a problem.
			//
			
			if (CmakVer.Is10Cmak())
			{
				g_bMigrateCmak10 = TRUE;
			}
			else if (CmakVer.Is121Cmak())
			{
				g_bMigrateCmak121 = TRUE;
			}
		}	
	}

    //
    //  Check to see if we need to migrate CM Profiles
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
        KEY_READ, &hKey))
    {
        if ((ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, 
            &g_dwNumValues, NULL, NULL, NULL, NULL)) && (g_dwNumValues > 0))
        {
            //
            //  Then we have mappings values, so we need to migrate them.
            //
            g_bMigrateCm = TRUE;

        }
        RegCloseKey(hKey);
    }

    if (g_bMigrateCmak10 || g_bMigrateCmak121 || g_bMigrateCm)
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_INSTALLED;
    }
}



//+----------------------------------------------------------------------------
//
// Function:  MigrateUser9x
//
// Synopsis:  Called once for each Win9x user being migrated.  Its purpose is to
//            allow migration of per user settings.
//
// Arguments: IN HWND ParentWnd - Window handle of the parent window, used if
//                                the migration dll needs to display UI.  If NULL,
//                                running in unattended mode and no UI should be
//                                displayed.
//            IN LPCSTR AnswerFile - Supplies the path to the answer file.
//            IN HKEY UserRegKey - reg key for the HKEY_CURRENT_USER key of the
//                                 user currently being migrated.
//            IN LPCSTR UserName - username of the user being migrated
//            LPVOID Reserved - reserved
//
// Returns:   LONG - ERROR_NOT_INSTALLED - if no per user processing is required.
//                   ERROR_CANCELLED - if the user wants to exit setup
//                   ERROR_SUCCESS - the migration dll processed this user successfully
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG
CALLBACK MigrateUser9x(IN HWND ParentWnd, IN LPCSTR AnswerFile, 
                           IN HKEY UserRegKey, IN LPCSTR UserName, LPVOID Reserved)
{
    return ERROR_NOT_INSTALLED; 
}


//+----------------------------------------------------------------------------
//
// Function:  MigrateSystem9x
//
// Synopsis:  Allows migration of system wide settings on the Windows 9x side.
//
// Arguments: IN HWND ParentWnd - parent window handle for the display of UI, 
//                                NULL if in unattended mode
//            IN LPCSTR AnswerFile - full path to the answer file
//            LPVOID Reserved - reserved
//
// Returns:   LONG -  ERROR_NOT_INSTALLED if the component that this dll is to 
//                    migrate isn't installed.  The migration dll won't be called
//                    in any of the other stages if this is the return value.
//                    ERROR_SUCCESS if the component that this dll is to migrate
//                    is installed and requires migration.  This will allow the
//                    migration dll to be called again for further migration.
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG
CALLBACK MigrateSystem9x(IN HWND ParentWnd, IN LPCSTR AnswerFile, LPVOID Reserved)
{
    LONG lReturn = ERROR_NOT_INSTALLED;
	TCHAR szSystemDir[MAX_PATH+1];

	GetSystemDirectory(szSystemDir, MAX_PATH);

	//
	//	Setup deletes a bunch of the files that 1.0 CMAK or IEAK5 CMAK need to function.
	//  Since we currently don't support NT5 CMAK on WKS, we need to copy these files
	//  to the setup provided working directory, so that we can copy them bak once
	//  we boot into NT.
	//
    if (g_bMigrateCmak10 && (TEXT('\0') != g_szCmakPath[0]) && (TEXT('\0') != g_szWorkingDir[0]))
    {
        TCHAR szDest[MAX_PATH+1];
        TCHAR szSrc[MAX_PATH+1];
        for (int i=0; i < c_NumFiles; i++)
        {
            MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s%s"), g_szCmakPath, OriginalNames[i]));
            MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s%s"), g_szWorkingDir, TempNames[i]));
            if (FileExists(szSrc))
            {
                MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
            }
        }

        lReturn &= ERROR_SUCCESS;    
    }
	else if (g_bMigrateCmak121 && (TEXT('\0') != szSystemDir[0]) && 
		     (TEXT('\0') != g_szWorkingDir[0]))
	{
        TCHAR szDest[MAX_PATH+1];
        TCHAR szSrc[MAX_PATH+1];

		//
		//	Copy w95inf16.dll to the working directory and rename it w95inf16.tmp
		//
        MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s\\%s%s"), szSystemDir, c_pszW95Inf16, c_pszDll));
        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s%s"), g_szWorkingDir, c_pszW95Inf16, c_pszTmp));
        if (FileExists(szSrc))
        {
            MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
        }

		//
		//	Copy w95inf32.dll to the working directory and rename it w95inf32.tmp
		//
        MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s\\%s%s"), szSystemDir, c_pszW95Inf32, c_pszDll));
        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s%s"), g_szWorkingDir, c_pszW95Inf32, c_pszTmp));
        if (FileExists(szSrc))
        {
            MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
        }

        lReturn &= ERROR_SUCCESS;	
	}

    if (g_bMigrateCm)
    {
        //
        //  Enumerate all the installed profiles on the machine.  For each profile check
        //  for a UserInfo\<CurrentServiceNameKey>.  If this key exists, then go to the next
        //  profile or user.  If it doesn't exist, then read the data from the cmp file.  If
        //  the cmp has data marked as being stored then we need to save the password.  If
        //  the password isn't in the cmp then it is in the wnet cache.  We must then
        //  retrieve it.
        //
        HKEY hKey;
        HKEY hTempKey;
        TCHAR szTemp[MAX_PATH+1];
        TCHAR szLongServiceName[MAX_PATH+1];
        TCHAR szCmpPath[MAX_PATH+1];

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, KEY_READ, 
        &hKey))
        {
            DWORD dwIndex = 0;
            DWORD dwValueSize = MAX_PATH;
            DWORD dwDataSize = MAX_PATH;
            DWORD dwType;
                
            while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szLongServiceName, 
                &dwValueSize, NULL, &dwType, (LPBYTE)szCmpPath, &dwDataSize))
            {
                if (REG_SZ == dwType)
                {
                    MYDBGASSERT(TEXT('\0') != szLongServiceName[0]);
                    MYDBGASSERT(TEXT('\0') != szCmpPath[0]);

                    //
                    //  If the user saved their password or their Internet password,
                    //  then we must make sure that it exists in the cmp (in encrypted form)
                    //  so that when the user runs CM on the NT5 side of the migration,
                    //  CM will move the settings to the new format.  Note, that if the 
                    //  cmp doesn't specify that the password(s) be saved, then this
                    //  function just returns as there is no password to ensure is in the
                    //  cmp.
                    MYVERIFY(EnsureEncryptedPasswordInCmpIfSaved(szLongServiceName, szCmpPath));
                }

                dwValueSize = MAX_PATH;
                dwDataSize = MAX_PATH;
                dwIndex++;
            
                if (dwIndex == g_dwNumValues)
                {
                    break;
                }
            }
            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
        }

        lReturn &= ERROR_SUCCESS;    
    }

    return lReturn;
}



//+----------------------------------------------------------------------------
//
// Function:  InitializeNT
//
// Synopsis:  First function called on the Win2k side of the migration, used to
//            setup the Win2k migration.  Similar to Initialize9x but on the Win2k
//            side.  No changes to the system should be made in this function.
//
// Arguments: IN LPCWSTR WorkingDirectory - temporary storage, same as path given
//                                          on the Win9x side
//            IN LPCWSTR SourceDirectories - a multi-sz list of the Win2k source
//                                           directory or directories
//            LPVOID Reserved - reserved
//
// Returns:   LONG - ERROR_SUCCESS unless an init error occurs.
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG
CALLBACK InitializeNT(IN LPCWSTR WorkingDirectory, IN LPCWSTR SourceDirectories, LPVOID Reserved)
{
    HKEY hKey;
	//
	//	Convert the WorkingDirectory to MultiByte
	//
	MYVERIFY (0 != WideCharToMultiByte(CP_THREAD_ACP, WC_COMPOSITECHECK, WorkingDirectory, -1, 
		g_szWorkingDir, MAX_PATH, NULL, NULL));

    //
    //  Check to see if we need to Migrate CMAK
    //
	CmakVersion CmakVer;

	if (CmakVer.IsPresent())
	{
		if (CmakVer.GetInstallLocation(g_szCmakPath))
		{
			//
			//	Now try to figure out what version of CMAK we have to see if we need
			//  to run the migration DLL or not.  If the CMAK.exe version is 6.00.613.0 (1.0)
			//  then we should migrate it.  If it is higher than that, 1.1 or 1.2 it is 
			//  beta and we shouldn't support the upgrade anyway (I purposely am not
			//  going to run the migration on it).  If it is IE5 IEAK CMAK, then it should
			//  survive upgrade without a problem.
			//
			
			if (CmakVer.Is10Cmak())
			{
				g_bMigrateCmak10 = TRUE;
			}
			else if (CmakVer.Is121Cmak())
			{
				g_bMigrateCmak121 = TRUE;
			}
		}	
	}

    //
    //  Check to see if we need to migrate CM Profiles
    //
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, 
        KEY_READ, &hKey))
    {
        if ((ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, 
            &g_dwNumValues, NULL, NULL, NULL, NULL)) && (g_dwNumValues > 0))
        {
            //
            //  Then we have mappings values, so we need to migrate them.
            //
            g_bMigrateCm = TRUE;

        }
        RegCloseKey(hKey);
    }

    if (g_bMigrateCmak10 || g_bMigrateCmak121 || g_bMigrateCm)
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_INSTALLED;
    }
}



//+----------------------------------------------------------------------------
//
// Function:  MigrateUserNT
//
// Synopsis:  Called once per migrated user on win2k.  Used to migrated any
//            per user settings saved from MigrateUser9x.
//
// Arguments: IN HINF UnattendInfHandle - valid inf handle to unattend.txt, 
//                                        for use with the setup API's
//            IN HKEY UserRegHandle - HKEY_CURRENT_USER of the user currently
//                                    being migrated
//            IN LPCWSTR UserName - username of the user currently being migrated
//            LPVOID Reserved - reserved
//
// Returns:   LONG - ERROR_SUCCESS or a win32 error code (will abort migration dll
//                   processing)
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG
CALLBACK MigrateUserNT(IN HINF UnattendInfHandle, IN HKEY UserRegHandle, 
                            IN LPCWSTR UserName, LPVOID Reserved)
{
    return ERROR_SUCCESS;
}



//+----------------------------------------------------------------------------
//
// Function:  MigrateSystemNT
//
// Synopsis:  Called to allow system wide migration changes to be made on the
//            Win2k side.
//
// Arguments: IN HINF UnattendInfHandle - handle to the unattend.txt file
//            LPVOID Reserved - reserved
//
// Returns:   LONG - ERROR_SUCCESS or a win32 error code (will abort migration dll
//                   processing)
//
// History:   quintinb  Created Header    8/27/98
//
//+----------------------------------------------------------------------------
LONG
CALLBACK MigrateSystemNT(IN HINF UnattendInfHandle, LPVOID Reserved)
{

    LONG lReturn = ERROR_NOT_INSTALLED;
    DWORD dwDisposition;
	TCHAR szSystemDir[MAX_PATH+1];

	GetSystemDirectory(szSystemDir, MAX_PATH);

    const TCHAR* const c_pszSystemFmt = TEXT("%s\\system\\%s.inf");
    const TCHAR* const c_pszValueString = TEXT("Connection Manager Profiles Upgrade");
    const TCHAR* const c_pszRegRunKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
    const TCHAR* const c_pszCmdLine = TEXT("cmstp.exe /m");

    if (g_bMigrateCmak10 && (TEXT('\0') != g_szCmakPath[0]) && (TEXT('\0') != g_szWorkingDir[0]))
    {
        TCHAR szDest[MAX_PATH+1];
        TCHAR szSrc[MAX_PATH+1];
        for (int i=0; i < c_NumFiles; i++)
        {
            MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s%s"), g_szCmakPath, 
				OriginalNames[i]));

            MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s%s"), g_szWorkingDir, 
				TempNames[i]));

            if (FileExists(szSrc))
            {
                MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
            }
        }

        lReturn &= ERROR_SUCCESS;    
    }
	else if (g_bMigrateCmak121 && (TEXT('\0') != g_szCmakPath[0]) && 
		     (TEXT('\0') != szSystemDir[0]))
	{
        TCHAR szDest[MAX_PATH+1];
        TCHAR szSrc[MAX_PATH+1];

		//
		//	Copy w95inf16.tmp in the working dir back to the systemdir and rename it .dll
		//
        MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s\\%s%s"), g_szWorkingDir, 
			c_pszW95Inf16, c_pszTmp));

        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s%s"), szSystemDir, 
			c_pszW95Inf16, c_pszDll));

        if (FileExists(szSrc))
        {
            MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
        }

		//
		//	Copy w95inf32.tmp in the working dir back to the systemdir and rename it .dll
		//
        MYVERIFY(CELEMS(szSrc) > (UINT)wsprintf(szSrc, TEXT("%s\\%s%s"), g_szWorkingDir, 
			c_pszW95Inf32, c_pszTmp));

        MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s%s"), szSystemDir, 
			c_pszW95Inf32, c_pszDll));

        if (FileExists(szSrc))
        {
            MYVERIFY(FALSE != CopyFile(szSrc, szDest, FALSE));
        }

        lReturn &= ERROR_SUCCESS;	
	}


    if (g_bMigrateCm)
    {
        //
        //  Enumerate all the installed profiles on the machine.  For each profile check to
        //  see if the profile inf is located in the system (that's system not system32) dir.
        //  If it is, then we need to move it to system32 so that our code will know where to
        //  find it.
        //
        HKEY hKey;
        HKEY hTempKey;
        TCHAR szSource[MAX_PATH+1];
        TCHAR szDest[MAX_PATH+1];
        TCHAR szLongServiceName[MAX_PATH+1];
        TCHAR szWindowsDir[MAX_PATH+1];
        TCHAR szSystemDir[MAX_PATH+1];
        TCHAR szCmpPath[MAX_PATH+1];

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 
            0, KEY_READ, &hKey))
        {
            DWORD dwIndex = 0;
            DWORD dwValueSize = MAX_PATH;
            DWORD dwDataSize = MAX_PATH;
            DWORD dwType;
                
            while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szLongServiceName, 
                &dwValueSize, NULL, &dwType, (LPBYTE)szCmpPath, &dwDataSize))
            {
                if (REG_SZ == dwType)
                {
                    MYDBGASSERT(TEXT('\0') != szLongServiceName[0]);
                    MYDBGASSERT(TEXT('\0') != szCmpPath[0]);
                    CFileNameParts CmpPath(szCmpPath);

                    GetWindowsDirectory(szWindowsDir, MAX_PATH);
                    MYDBGASSERT(TEXT('\0') != szWindowsDir[0]);

                    GetSystemDirectory(szSystemDir, MAX_PATH);
                    MYDBGASSERT(TEXT('\0') != szSystemDir[0]);

                    MYVERIFY(CELEMS(szSource) > (UINT)wsprintf(szSource, c_pszSystemFmt, szWindowsDir, CmpPath.m_FileName));
                    MYVERIFY(CELEMS(szDest) > (UINT)wsprintf(szDest, TEXT("%s\\%s.inf"), szSystemDir, CmpPath.m_FileName));

                    if (CopyFile(szSource, szDest, FALSE))
                    {
                        DeleteFile(szSource);
                    }
                }

                dwValueSize = MAX_PATH;
                dwDataSize = MAX_PATH;
                dwIndex++;
            
                if (dwIndex == g_dwNumValues)
                {
                    break;
                }
            }
            MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
        }

        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_pszRegRunKey, 0, NULL,
            REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL, &hKey, &dwDisposition))
        {
            RegSetValueEx(hKey, c_pszValueString, 0, REG_SZ, (CONST BYTE*)c_pszCmdLine, 
                sizeof(TCHAR)*(lstrlen(c_pszCmdLine)+1));

            RegCloseKey(hKey);
        }

        lReturn &= ERROR_SUCCESS;    
    }

    return lReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  EnsureEncryptedPasswordInCmpIfSaved
//
// Synopsis:  This function is called on the Win9x side of the migration so
//            that if a password is in the Win9x password cache (which only
//            happens if the user has profiling enabled), it will be retrieved,
//            encrypted, and written to the cmp.  This enables CM to populate
//            a users registry with the starting password whenever they first
//            launch the CM profile.  This no functionality is lost from the
//            shared password feature that win9x had.
//
// Arguments: szLongServiceName - Service name of the profile to retrieve 
//                                the password for
//            szCmpPath - full path to the cmp to write the password too
//
// Returns:   BOOL - returns TRUE if successful
//
// History:   quintinb      Created             08/27/98
//            nickball      CmWipePassword      08/04/99
//
//+----------------------------------------------------------------------------
BOOL EnsureEncryptedPasswordInCmpIfSaved(LPCTSTR pszLongServiceName, LPCTSTR pszCmpPath)
{
    TCHAR szPassword[MAX_PATH+1] = TEXT("");
    TCHAR szCacheEntryName[MAX_PATH+1];
    TCHAR szEncryptedPassword[MAX_PATH+1];
    DWORD dwSize;
    DWORD dwCryptType = 0;
    GetCachedPassword pfnGetCachedPassword = NULL;
    int iTemp=0;

    CDynamicLibrary MprDll(TEXT("mpr.dll"));
   
    iTemp = GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryRememberPwd, 0, pszCmpPath);
    if (iTemp)
    {
        GetPrivateProfileString(c_pszCmSection, c_pszCmEntryPassword, TEXT(""), szPassword, MAX_PATH, pszCmpPath);

        if (TEXT('\0') == szPassword[0])
        {
            //
            //  The string must be in the password cache.  Build the key string
            //  for the cache.
            //
            MYVERIFY(CELEMS(szCacheEntryName) > (UINT)wsprintf(szCacheEntryName, 
            TEXT("%s - Sign-In (Connection Manager)"), pszLongServiceName));
            
            pfnGetCachedPassword = (GetCachedPassword)MprDll.GetProcAddress(TEXT("WNetGetCachedPassword"));

            if (NULL == pfnGetCachedPassword)
            {
                CmWipePassword(szPassword);
                return FALSE;
            }
            else
            {
                WORD wStr = (WORD)256;

                if (ERROR_SUCCESS == pfnGetCachedPassword(szCacheEntryName, 
                    (WORD)lstrlen(szCacheEntryName), szPassword, &wStr, 80))
                {
                    //
                    //  Okay, we retrived the password, now lets encrypt it and write it 
                    //  to the cmp
                    //

                    if (EncryptPassword(szPassword, szEncryptedPassword, &dwSize, &dwCryptType))
                    {
                        //
                        //  Write the encrypted password
                        //
                        WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPassword, szEncryptedPassword, 
                            pszCmpPath);

                        //
                        //  Write the encryption type
                        //
                        wsprintf(szPassword, TEXT("%u"), dwCryptType);
                        WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPcs, szPassword, 
                            pszCmpPath);
                    }
                }
                
            }
           
        }
    }

    //
    //  Now do the same for the Internet Password
    //
    
    iTemp = GetPrivateProfileInt(c_pszCmSection, c_pszCmEntryRememberInetPwd, 0, pszCmpPath);

    if (iTemp)
    {
        GetPrivateProfileString(c_pszCmSection, c_pszCmEntryInetPassword, TEXT(""), szPassword, MAX_PATH, pszCmpPath);

        if (TEXT('\0') == szPassword[0])
        {
            //
            //  The string must be in the password cache.  Build the key string
            //  for the cache.
            //
            MYVERIFY(CELEMS(szCacheEntryName) > (UINT)wsprintf(szCacheEntryName, 
            TEXT("%s - Sign-In (Connection Manager)-tunnel"), pszLongServiceName));
            
            pfnGetCachedPassword = (GetCachedPassword)MprDll.GetProcAddress(TEXT("WNetGetCachedPassword"));

            if (NULL == pfnGetCachedPassword)
            {
                CmWipePassword(szPassword);
                return FALSE;
            }
            else
            {
                WORD wStr = (WORD)256;

                if (ERROR_SUCCESS == pfnGetCachedPassword(szCacheEntryName, 
                    (WORD)lstrlen(szCacheEntryName), szPassword, &wStr, 80))
                {
                    //
                    //  Okay, we retrived the password, now lets encrypt it and write it 
                    //  to the cmp
                    //
                    
                    dwCryptType = 0;

                    if (EncryptPassword(szPassword, szEncryptedPassword, &dwSize, &dwCryptType))
                    {
                        //
                        //  Write the encrypted password
                        //
                        WritePrivateProfileString(c_pszCmSection, c_pszCmEntryInetPassword, szEncryptedPassword, 
                            pszCmpPath);

                        //
                        //  Write the encryption type
                        //
                        wsprintf(szPassword, TEXT("%u"), dwCryptType);
                        WritePrivateProfileString(c_pszCmSection, c_pszCmEntryPcs, szPassword, 
                            pszCmpPath);
                    }
                }
                
            }
           
        }
    }
    
    CmWipePassword(szPassword);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  EncryptPassword
//
// Synopsis:  
//
// Arguments: IN LPCTSTR pszPassword - 
//            OUT LPTSTR pszEncryptedPassword - 
//            OUT LPDWORD lpdwBufSize - 
//            OUT LPDWORD lpdwCryptType - 
//
// Returns:   BOOL - 
//
// History:   quintinb      Created Header      8/27/98
//            nickball      CmWipePassword      08/04/99
//
//+----------------------------------------------------------------------------
BOOL EncryptPassword(IN LPCTSTR pszPassword, OUT LPTSTR pszEncryptedPassword, OUT LPDWORD lpdwBufSize, OUT LPDWORD lpdwCryptType)
{
    MYDBGASSERT(pszPassword);
    MYDBGASSERT(pszEncryptedPassword);
    MYDBGASSERT(lpdwBufSize);

    MYDBGASSERT(lpdwCryptType);
    DWORD dwEncryptedBufferLen;
    DWORD dwSize = 0;

    LPTSTR pszEncryptedData = NULL;

    TCHAR szSourceData[PWLEN + sizeof(TCHAR)];

    if ((NULL == pszPassword) || (NULL == pszEncryptedPassword) || (NULL == lpdwBufSize))
    { 
        return NULL;
    }

    //
    // Standard encryption, copy the password
    //

    lstrcpy(szSourceData, pszPassword);
   
    //
    // It is not safe to call InitSecure more than once
    //
    if (!g_fInitSecureCalled)
    {
        BOOL bFastEncryption = FALSE;
        MYVERIFY(FALSE != ReadEncryptionOption(&bFastEncryption));
        InitSecure(bFastEncryption);
        g_fInitSecureCalled = TRUE;
    }

    //
    // Encrypt the provided password
    //

    if (EncryptData((LPBYTE)szSourceData, (lstrlen(szSourceData)+1) * sizeof(TCHAR),
            (LPBYTE*)&pszEncryptedData, &dwEncryptedBufferLen, lpdwCryptType, NULL, NULL, NULL))
    {
        if (lpdwBufSize)
        {
            *lpdwBufSize = dwEncryptedBufferLen;
        }

        if (pszEncryptedData)
        {
            _tcscpy(pszEncryptedPassword, pszEncryptedData);
            HeapFree(GetProcessHeap(), 0, pszEncryptedData);
            pszEncryptedData = NULL;
            CmWipePassword(szSourceData);
            return TRUE;
        }        
    }
    
    CmWipePassword(szSourceData);
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadEncryptionOption
//
// Synopsis:  
//
// Arguments: BOOL* pfFastEncryption - boolean to fill in with fast encryption flag
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb  Created Header    8/27/98
//            copied from the version written by Fengsun in cmdial\connect.cpp
//
//+----------------------------------------------------------------------------
BOOL ReadEncryptionOption(BOOL* pfFastEncryption)
{
    HKEY hKeyCm;
    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    MYDBGASSERT(pfFastEncryption != NULL);

    *pfFastEncryption = FALSE;

	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmRoot, 0, 
        KEY_QUERY_VALUE ,&hKeyCm))
    {
        RegQueryValueEx(hKeyCm, c_pszRegCmEncryptOption, NULL, &dwType, 
            (BYTE*)pfFastEncryption, &dwSize);

        RegCloseKey(hKeyCm);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\migrate\pwfuncs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pwfuncs.cpp
//      
// Module:   MIGRATE.DLL 
//
// Synopsis: Simple password encryption routines
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   nickball   created     08/04/99
//
//+----------------------------------------------------------------------------
#include "migrate.h"

//
//	Please see pnpu\cm\common\source for the actual source here.
//

#include "pwutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\migrate\migrate.h ===
//+----------------------------------------------------------------------------
//
// File:     migrate.h
//      
// Module:   MIGRATE.DLL 
//
// Synopsis: Definitions for the Connection Manager Win9x Migration Dll
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb   created     08/20/98
//
//+----------------------------------------------------------------------------
#define _MBCS // for dbcs compatibility
#ifndef _CM_MIGRATE_H
#define _CM_MIGRATE_H

#include <windows.h>
#include <setupapi.h>
#include <stdlib.h>
#include <tchar.h>
#include <lmcons.h>

#include "cmdebug.h"
#include "cmakreg.h"
#include "cmsetup.h"
#include "cmsecure.h"
#include "dynamiclib.h"
#include "pwutil.h"

#include "base_str.h"
#include "pwd_str.h"
#include "reg_str.h"
#include "uninstcm_str.h"

#include "msg.h"

//
//  Constants
//

const TCHAR* const c_pszProductIdString = "Microsoft Connection Manager";
const TCHAR* const c_pszDirectory = "Directory";
const TCHAR* const c_pszSectionHandled = "Handled";
const TCHAR* const c_pszW95Inf16 = "w95inf16";
const TCHAR* const c_pszW95Inf32 = "w95inf32";
const TCHAR* const c_pszDll = ".dll";
const TCHAR* const c_pszTmp = ".tmp";

const UINT uCmMigrationVersion = 1;


//
//  Types
//
typedef struct {
    CHAR CompanyName[256];
    CHAR SupportNumber[256];
    CHAR SupportUrl[256];
    CHAR InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO; 

typedef WORD (WINAPI *GetCachedPassword)(LPSTR, WORD, LPSTR, LPWORD, BYTE);

//
//  Utility Function Headers
//

BOOL ReadEncryptionOption(BOOL* pfFastEncryption);
BOOL EncryptPassword(IN LPCTSTR pszPassword, OUT LPTSTR pszEncryptedPassword, 
                     OUT LPDWORD lpdwBufSize, OUT LPDWORD lpdwCryptType);
BOOL EnsureEncryptedPasswordInCmpIfSaved(LPCTSTR pszLongServiceName, LPCTSTR szCmpPath);

//
//  Migration Dll Function Headers
//
LONG
CALLBACK 
QueryVersion (
	OUT LPCSTR  *ProductID,
	OUT LPUINT DllVersion,
	OUT LPINT *CodePageArray,	//OPTIONAL
	OUT LPCSTR  *ExeNamesBuf,	//OPTIONAL
	OUT PVENDORINFO  *VendorInfo
	);

LONG
CALLBACK 
Initialize9x (
	IN LPCSTR WorkingDirectory,
	IN LPCSTR SourceDirectories,
	IN LPCSTR MediaDirectory
	);

LONG
CALLBACK 
MigrateUser9x (
	IN HWND ParentWnd, 
	IN LPCSTR AnswerFile,
	IN HKEY UserRegKey, 
	IN LPCSTR UserName, 
	LPVOID Reserved
	);

LONG
CALLBACK 
MigrateSystem9x (
	IN HWND ParentWnd, 
	IN LPCSTR AnswerFile,
	LPVOID Reserved
	);

LONG
CALLBACK 
InitializeNT (
	IN LPCWSTR WorkingDirectory,
	IN LPCWSTR SourceDirectories,
	LPVOID Reserved
	);

LONG
CALLBACK 
MigrateUserNT (
	IN HINF UnattendInfHandle,
	IN HKEY UserRegHandle,
	IN LPCWSTR UserName,
	LPVOID Reserved 
	);

LONG
CALLBACK 
MigrateSystemNT (
	IN HINF UnattendInfHandle,
	LPVOID Reserved
	);

#endif //_CM_MIGRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\cmakui.h ===
//+----------------------------------------------------------------------------
//
// File:     cmakui.h
//
// Module:   CMAK.EXE
//
// Synopsis: This header file contains the help ID's for html help button on
//		     each wizard page.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   a-lwells   Updated so code and docs match      06/29/99
//
//+----------------------------------------------------------------------------
 
#define IDH_WELCOME		3010
#define IDH_STARTCUST   3020
#define IDH_NAMES		3030
#define IDH_MERGE		3040
#define IDH_SUPPINFO    3050
#define IDH_REALM		3060
#define IDH_DENTRY 		3070
#define IDH_SECURE		3080
#define IDH_CONNECT		3090
#define IDH_AUTOAPP		3100
#define IDH_BITMAPS		3110
#define IDH_PHONEBK		3120
#define IDH_ICONS		3130
#define IDH_MENU		3140
#define IDH_CMHELP		3150
#define IDH_CMSW		3160
#define IDH_PRESHARED   3170
#define IDH_LICENSE		3180
#define IDH_ADDITION    3190
#define IDH_CREATE		3200
#define IDH_FINISH 		3210
#define IDH_ADVANCED    3220
#define IDH_APCONFIG    3230
#define IDH_RTPLUMB     3240
#define IDH_VENTRY      3250
#define IDH_LCID_POPUP  3260
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//
// Module:   CMAK.EXE
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/24/99
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include "profwiz.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\image.cpp ===
//+----------------------------------------------------------------------------
//
// File:     image.cpp
//
// Module:   CMAK.EXE
//
// Synopsis: Image support routines for displaying the custom graphics
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created Header      03/30/98
//           quintinb   copied from cmdial  08/04/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#ifndef UNICODE
#define GetWindowLongU GetWindowLongPtrA
#define SetWindowLongU SetWindowLongPtrA
#define DefWindowProcU DefWindowProcA
#else
#define GetWindowLongU GetWindowLongPtrW
#define SetWindowLongU SetWindowLongPtrW
#define DefWindowProcU DefWindowProcW
#endif

const TCHAR* const c_pszCmakBmpClass = TEXT("Connection Manager Administration Kit Bitmap Window Class");

//
//  Include the shared bitmap handling code.
//
#include "bmpimage.cpp"

//+----------------------------------------------------------------------------
//
// Function:  RegisterBitmapClass
//
// Synopsis:  Helper function to encapsulate registration of our bitmap class
//
// Arguments: HINSTANCE hInst - HINSTANCE to associate registration with
//
// Returns:   DWORD - error code 
//
// History:   nickball    Created Header    2/9/98
//
//+----------------------------------------------------------------------------
DWORD RegisterBitmapClass(HINSTANCE hInst) 
{
    //
    // Register Bitmap class
    //

    WNDCLASS wcClass;

	ZeroMemory(&wcClass,sizeof(wcClass));
	wcClass.lpfnWndProc = BmpWndProc;
	wcClass.cbWndExtra = sizeof(HBITMAP) + sizeof(LPBITMAPINFO);
	wcClass.hInstance = hInst;
    wcClass.lpszClassName = c_pszCmakBmpClass;
	
    if (!RegisterClass(&wcClass)) 
	{
        DWORD dwError = GetLastError();

        CMTRACE1(TEXT("RegisterBitmapClass() RegisterClass() failed, GLE=%u."), dwError);
        //
        // Only fail if the class does not already exist
        //

        if (ERROR_CLASS_ALREADY_EXISTS != dwError)
        {
            return dwError;
        }
	}      

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\customaction.cpp ===
//+----------------------------------------------------------------------------
//
// File:     customaction.cpp
//
// Module:   CMAK.EXE
//
// Synopsis: Implemenation of the CustomActionList and CustomActionListEnumerator
//           classes used by CMAK to handle its custom actions.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Author:   quintinb   Created                         02/26/00
//
//+----------------------------------------------------------------------------

#include <cmmaster.h>

//
//  Include the shared custom action parsing code between CM and CMAK
//
#include "parseca.cpp"

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::CustomActionList
//
// Synopsis:  Constructor for the CustomActionList class.  Initializes the
//            m_ActionSectionStrings array with all of the section strings and
//            zeros all of the other parameters of the class.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
CustomActionList::CustomActionList()
{

    //
    //  First set the m_ActionSectionStrings so that we can read the actions
    //  from the appropriate sections in the cms file.
    //    
    m_ActionSectionStrings[PREINIT] = (TCHAR*)c_pszCmSectionPreInit;
    m_ActionSectionStrings[PRECONNECT] = (TCHAR*)c_pszCmSectionPreConnect;
    m_ActionSectionStrings[PREDIAL] = (TCHAR*)c_pszCmSectionPreDial;
    m_ActionSectionStrings[PRETUNNEL] = (TCHAR*)c_pszCmSectionPreTunnel;
    m_ActionSectionStrings[ONCONNECT] = (TCHAR*)c_pszCmSectionOnConnect;
    m_ActionSectionStrings[ONINTCONNECT] = (TCHAR*)c_pszCmSectionOnIntConnect;
    m_ActionSectionStrings[ONDISCONNECT] = (TCHAR*)c_pszCmSectionOnDisconnect;
    m_ActionSectionStrings[ONCANCEL] = (TCHAR*)c_pszCmSectionOnCancel;
    m_ActionSectionStrings[ONERROR] = (TCHAR*)c_pszCmSectionOnError;

    //
    //  Zero m_CustomActionHash
    //
    ZeroMemory(&m_CustomActionHash, c_iNumCustomActionTypes*sizeof(CustomActionListItem*));

    //
    //  Zero the Display strings array
    //
    ZeroMemory(&m_ActionTypeStrings, (c_iNumCustomActionTypes)*sizeof(TCHAR*));
    m_pszAllTypeString = NULL;

    //
    //  Zero the Execution Strings
    //
    ZeroMemory(&m_ExecutionStrings, (c_iNumCustomActionExecutionStates)*sizeof(TCHAR*));
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::~CustomActionList
//
// Synopsis:  Destructor for the CustomActionList class.  Frees all memory
//            allocated by the class including the CustomActionListItem
//            structures stored in the array of linked lists (the true data
//            of the class).
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
CustomActionList::~CustomActionList()
{
    //
    //  Free the memory we allocated
    //

    for (int i = 0; i < c_iNumCustomActionTypes; i++)
    {
        //
        //  Free each CustomAction List
        //
        CustomActionListItem* pCurrent = m_CustomActionHash[i];

        while (NULL != pCurrent)
        {
            CustomActionListItem* pNext = pCurrent->Next;

            CmFree(pCurrent->pszParameters);
            CmFree(pCurrent);
            
            pCurrent = pNext;
        }

        //
        //  Free the Action Type display strings
        //
        CmFree(m_ActionTypeStrings[i]);
    }

    //
    //  Free the All Action display string
    //
    CmFree(m_pszAllTypeString);

    //
    //  Free the execution strings
    //
    for (int i = 0; i < c_iNumCustomActionExecutionStates; i++)
    {
        CmFree(m_ExecutionStrings[i]);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::ReadCustomActionsFromCms
//
// Synopsis:  Reads all custom actions in from the given cms file and stores
//            them in the classes custom action hash table by the type of
//            custom action.  This function relies on ParseCustomActionString
//            to do the actual parsing of the custom action string.  Given the
//            current architecture of CM this function should really only be 
//            called once per class object as there is no way to reset the class object
//            (other than explicitly calling the destructor).  However, there is
//            no code to prevent the caller from pulling connect actions from more than
//            one source.  Thus let the caller beware.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            TCHAR* pszCmsFile - full path to the cms file to get
//                                the custom actions from
//            TCHAR* pszShortServiceName - short service name of the profile
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::ReadCustomActionsFromCms(HINSTANCE hInstance, TCHAR* pszCmsFile, TCHAR* pszShortServiceName)
{
    MYDBGASSERT(hInstance);
    MYDBGASSERT(pszCmsFile);
    MYDBGASSERT(pszShortServiceName);

    if ((NULL == hInstance) || (NULL == pszCmsFile) || (NULL == pszShortServiceName))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    int iFileNum = 0;

    for (int i = 0; i < c_iNumCustomActionTypes; i++)
    {
        TCHAR szNum[MAX_PATH+1];
        LPTSTR pszTemp = NULL;
        CustomActionListItem CustomAction;
        iFileNum = 0;

        do
        {
            CmFree(pszTemp);

            MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, TEXT("%d"), iFileNum));

            pszTemp = GetPrivateProfileStringWithAlloc(m_ActionSectionStrings[i], szNum, TEXT(""), pszCmsFile);

            if (pszTemp)
            {
                MYDBGASSERT(pszTemp[0]);

                hr = ParseCustomActionString(pszTemp, &CustomAction, pszShortServiceName);

                if (SUCCEEDED(hr))
                {
                    //
                    //  We have parsed the string, now we need to get the Flags and the description
                    //
                    CustomAction.Type = (CustomActionTypes)i;
                    MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, c_pszCmEntryConactDesc, iFileNum));

                    GetPrivateProfileString(m_ActionSectionStrings[i], szNum, TEXT(""), CustomAction.szDescription, CELEMS(CustomAction.szDescription), pszCmsFile); //lint !e534
                    
                    MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, c_pszCmEntryConactFlags, iFileNum));

                    CustomAction.dwFlags = (DWORD)GetPrivateProfileInt(m_ActionSectionStrings[i], szNum, 0, pszCmsFile);

                    hr = Add(hInstance, &CustomAction, pszShortServiceName);

                    if (FAILED(hr))
                    {
                        CMASSERTMSG(FALSE, TEXT("CustomActionList::ReadCustomActionsFromCms -- Unable to add a custom action to the list, Add failed."));
                    }

                    CmFree(CustomAction.pszParameters);
                    CustomAction.pszParameters = NULL;
                }
                else
                {
                    CMTRACE2(TEXT("ReadCustomActionsFromCms -- Unable to parse %s, hr=%d"), pszTemp, hr);
                }
            }

            iFileNum++;

        } while(pszTemp);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::ParseCustomActionString
//
// Synopsis:  This function takes a custom action string retrieved from a 
//            cms file and parses it into the various parts of a custom
//            action (program, parameters, function name, etc.)
//
// Arguments: LPTSTR pszStringToParse - custom action buffer to be parsed into
//                                      the various parts of a custom action
//            CustomActionListItem* pCustomAction - pointer to a custom action
//                                                  structure to be filled in
//            TCHAR* pszShortServiceName - short service name of the profile
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::ParseCustomActionString(LPTSTR pszStringToParse, CustomActionListItem* pCustomAction, TCHAR* pszShortServiceName)
{
    MYDBGASSERT(pszStringToParse);
    MYDBGASSERT(TEXT('\0') != pszStringToParse[0]);
    MYDBGASSERT(pCustomAction);
    MYDBGASSERT(pszShortServiceName);

    if ((NULL == pszStringToParse) || (TEXT('\0') == pszStringToParse[0]) || 
        (NULL == pCustomAction) || (NULL == pszShortServiceName))
    {
        return E_INVALIDARG;
    }    

    //
    //  Zero the CustomAction struct
    //
    ZeroMemory(pCustomAction, sizeof(CustomActionListItem));
    CmStrTrim(pszStringToParse);    

    LPTSTR pszProgram = NULL;
    LPTSTR pszFunctionName = NULL;

    HRESULT hr = HrParseCustomActionString(pszStringToParse, &pszProgram,
                                           &(pCustomAction->pszParameters), &pszFunctionName);

    if (SUCCEEDED(hr))
    {
        lstrcpyn(pCustomAction->szProgram, pszProgram, CELEMS(pCustomAction->szProgram));
        lstrcpyn(pCustomAction->szFunctionName, pszFunctionName, CELEMS(pCustomAction->szFunctionName));

        //
        //  Now we have the filename string, but we need to check to see if
        //  it includes the relative path.  If so, then we need to set 
        //  bIncludeBinary to TRUE;
        //
        TCHAR szTemp[MAX_PATH+1];

        if (MAX_PATH >= (lstrlen(g_szOsdir) + lstrlen(pCustomAction->szProgram)))
        {
            MYVERIFY(CELEMS(szTemp) > (UINT)wsprintf(szTemp, TEXT("%s%s"), g_szOsdir, pCustomAction->szProgram));

            pCustomAction->bIncludeBinary = FileExists(szTemp);
        }
        else
        {
            pCustomAction->bIncludeBinary = FALSE;
        }
    }

    CmFree(pszProgram);
    CmFree(pszFunctionName);

    return hr;
}
//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::WriteCustomActionsToCms
//
// Synopsis:  This function takes a custom action string retrieved from a 
//            cms file and parses it into the various parts of a custom
//            action (program, parameters, function name, etc.)
//
// Arguments: TCHAR* pszCmsFile - Cms file to write the custom action to
//            TCHAR* pszShortServiceName - short service name of the profile
//            BOOL bUseTunneling - whether this a tunneling profile or not,
//                                 controls whether Pre-Tunnel actions should be
//                                 written and whether the Flags parameter for
//                                 each action should be written (since they are
//                                 only needed if tunneling is an option).
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
/*
HRESULT CustomActionList::WriteCustomActionsToCms(TCHAR* pszCmsFile, TCHAR* pszShortServiceName, BOOL bUseTunneling)
{
    HRESULT hr = S_OK;

    for (int i = 0; i < c_iNumCustomActionTypes; i++)
    {
        //
        //  Clear out the section
        //
        MYVERIFY(0 != WritePrivateProfileSection(m_ActionSectionStrings[i], TEXT("\0\0"), pszCmsFile));

        //
        //  Make sure that we have a linked list of actions to process and that if we
        //  are writing PRETUNNEL actions that we are actually tunneling.
        //
        if (m_CustomActionHash[i] && (i != PRETUNNEL || (i == PRETUNNEL && bUseTunneling)))
        {
            int iFileNum = 0;

            CustomActionListItem* pItem = m_CustomActionHash[i];

            while (pItem)
            {
                if (pItem->szProgram[0] && pItem->pszParameters)
                {
                    //
                    //  Note that since we may or may not need a plus sign, a comma, or a
                    //  space, I use a little trick with wsprintf to make the logic simpler.
                    //  If an empty string ("") is passed into wsprintf for a %s then the
                    //  %s is replaced by nothing.  Thus I can use szSpace to print a space
                    //  into the string or print nothing into the string by just giving it
                    //  a space in the first char or leaving it the null character ('\0').
                    //
                    TCHAR szPlus[2] = {0};
                    TCHAR szComma[2] = {0};
                    TCHAR szSpace[2] = {0};
                    TCHAR szRelativePath[10] = {0};
                    TCHAR szName[MAX_PATH+1];
                    TCHAR szBuffer[2*MAX_PATH+1];
                    TCHAR szNum[MAX_PATH+1];
                    TCHAR* pszFileName;
                    BOOL bLongName;

                    //
                    //  Get just the filename of the program
                    //
                    GetFileName(pItem->szProgram, szName);

                    //
                    //  If we are including the program in the CM package, then we have to
                    //  add the relative path from the directory where the cmp resides.
                    //  We also need to use just the filename itself, instead of the full path.
                    //
                    MYDBGASSERT(9 > lstrlen(pszShortServiceName));

                    if (pItem->bIncludeBinary && (9 > lstrlen(pszShortServiceName)))
                    {
                        wsprintf(szRelativePath, TEXT("%s\\"), pszShortServiceName);                        
                        pszFileName = szName;                        
                        bLongName = !IsFile8dot3(szName);
                    }
                    else
                    {
                        pszFileName = pItem->szProgram;

                        //
                        //  Here we are more concerned if the item has spaces in it than if it is a long
                        //  file name.
                        //
                        LPTSTR pszSpace = CmStrchr(pszFileName, TEXT(' '));
                        bLongName = (NULL != pszSpace);
                    }

                    //
                    //  If this is a long filename, then surrond the filename with plus signs (+)
                    //
                    if (bLongName)
                    {
                        szPlus[0] = TEXT('+');
                    }

                    //
                    //  If we have a dll, then deal with the dll function name
                    //
                    if (pItem->szFunctionName[0])
                    {
                        szComma[0] = TEXT(',');                        
                    }

                    if (pItem->pszParameters[0])
                    {
                        szSpace[0] = TEXT(' ');                    
                    }

                    //
                    //  Now build the string using wsprintf, notice that empty parameters ("") will write 
                    //  nothing into the string
                    //
                
                    wsprintf(szBuffer, TEXT("%s%s%s%s%s%s%s%s"), szPlus, szRelativePath, pszFileName, szPlus, szComma, 
                             pItem->szFunctionName, szSpace, pItem->pszParameters);

                    //
                    //  Now write the buffer string out to the cms file
                    //

                    MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, TEXT("%d"), iFileNum));

                    if (0 != WritePrivateProfileString(m_ActionSectionStrings[i], szNum, szBuffer, pszCmsFile))
                    {
                        //
                        //  if dwFlags == 0 or bUseTunneling is FALSE then delete the flags line instead
                        //  of setting it.  We only need the flags to tell us when to run a connect action
                        //  if we have the option of tunneling.
                        //
                        LPTSTR pszFlagsValue = NULL;

                        if (0 != pItem->dwFlags && bUseTunneling)
                        {
                            MYVERIFY(CELEMS(szBuffer) > (UINT)wsprintf(szBuffer, TEXT("%u"), pItem->dwFlags));
                            pszFlagsValue = szBuffer;
                        }

                        MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, c_pszCmEntryConactFlags, iFileNum));

                        if (0 == WritePrivateProfileString(m_ActionSectionStrings[i], szNum, pszFlagsValue, pszCmsFile))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            CMTRACE1(TEXT("CustomActionList::WriteCustomActionsToCms -- unable to write flags, hr is 0x%x"), hr);
                        }

                        //
                        //  If description parameter is null or is only a temporary description, then delete the
                        //  description instead of writing it.
                        //
                        LPTSTR pszDescValue = NULL;

                        if (pItem->szDescription[0]  && !pItem->bTempDescription)
                        {
                            pszDescValue = pItem->szDescription;
                        }

                        MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, c_pszCmEntryConactDesc, iFileNum));

                        if (0 == WritePrivateProfileString(m_ActionSectionStrings[i], szNum, pszDescValue, pszCmsFile))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            CMTRACE1(TEXT("CustomActionList::WriteCustomActionsToCms -- unable to write description, hr is 0x%x"), hr);
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        CMTRACE1(TEXT("CustomActionList::WriteCustomActionsToCms -- unable to write connect action, hr is 0x%x"), hr);
                    }
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("WriteCustomActionsToCms -- custom action with empty program field!"));
                }

                pItem = pItem->Next;
                iFileNum++;
            }
        }
    }

    return hr;
}
*/
HRESULT CustomActionList::WriteCustomActionsToCms(TCHAR* pszCmsFile, TCHAR* pszShortServiceName, BOOL bUseTunneling)
{
    HRESULT hr = S_OK;

    for (int i = 0; i < c_iNumCustomActionTypes; i++)
    {
        //
        //  Clear out the section
        //
        MYVERIFY(0 != WritePrivateProfileSection(m_ActionSectionStrings[i], TEXT("\0\0"), pszCmsFile));

        //
        //  Make sure that we have a linked list of actions to process and that if we
        //  are writing PRETUNNEL actions that we are actually tunneling.
        //
        if (m_CustomActionHash[i] && (i != PRETUNNEL || (i == PRETUNNEL && bUseTunneling)))
        {
            int iFileNum = 0;

            CustomActionListItem* pItem = m_CustomActionHash[i];

            while (pItem)
            {
                if (pItem->szProgram[0])
                {
                    //
                    //  Get just the filename of the program
                    //
                    TCHAR szName[MAX_PATH+1];
                    if (pItem->bIncludeBinary)
                    {
                        wsprintf(szName, TEXT("%s\\%s"), pszShortServiceName, GetName(pItem->szProgram));
                    }
                    else
                    {                    
                        lstrcpyn(szName, pItem->szProgram, CELEMS(szName));
                    }

                    UINT uSizeNeeded = lstrlen(szName);

                    LPTSTR pszSpace = CmStrchr(szName, TEXT(' '));
                    BOOL bLongName = (NULL != pszSpace);

                    if (bLongName)
                    {
                        uSizeNeeded = uSizeNeeded + 2; // for the two plus signs
                    }

                    if (pItem->szFunctionName[0])
                    {
                        uSizeNeeded = uSizeNeeded + lstrlen(pItem->szFunctionName) + 1;// add one for the comma
                    }

                    if (pItem->pszParameters && pItem->pszParameters[0])
                    {
                        uSizeNeeded = uSizeNeeded + lstrlen(pItem->pszParameters) + 1;// add one for the space
                    }

                    uSizeNeeded = (uSizeNeeded + 1) * sizeof(TCHAR);

                    LPTSTR pszBuffer = (LPTSTR)CmMalloc(uSizeNeeded);

                    if (pszBuffer)
                    {
                        if (bLongName)
                        {
                            pszBuffer[0] = TEXT('+');
                        }

                        lstrcat(pszBuffer, szName);

                        if (bLongName)
                        {
                            lstrcat(pszBuffer, TEXT("+"));
                        }

                        if (pItem->szFunctionName[0])
                        {
                            lstrcat(pszBuffer, TEXT(","));
                            lstrcat(pszBuffer, pItem->szFunctionName);
                        }

                        if (pItem->pszParameters && pItem->pszParameters[0])
                        {
                            lstrcat(pszBuffer, TEXT(" "));
                            lstrcat(pszBuffer, pItem->pszParameters);
                        }
                        //
                        //  Now write the buffer string out to the cms file
                        //
                        TCHAR szNum[MAX_PATH+1];
                        MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, TEXT("%d"), iFileNum));

                        if (0 != WritePrivateProfileString(m_ActionSectionStrings[i], szNum, pszBuffer, pszCmsFile))
                        {
                            //
                            //  if dwFlags == 0 or bUseTunneling is FALSE then delete the flags line instead
                            //  of setting it.  We only need the flags to tell us when to run a connect action
                            //  if we have the option of tunneling.
                            //
                            LPTSTR pszFlagsValue = NULL;

                            if (0 != pItem->dwFlags && bUseTunneling)
                            {
                                MYVERIFY(CELEMS(szName) > (UINT)wsprintf(szName, TEXT("%u"), pItem->dwFlags));
                                pszFlagsValue = szName;
                            }

                            MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, c_pszCmEntryConactFlags, iFileNum));

                            if (0 == WritePrivateProfileString(m_ActionSectionStrings[i], szNum, pszFlagsValue, pszCmsFile))
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                                CMTRACE1(TEXT("CustomActionList::WriteCustomActionsToCms -- unable to write flags, hr is 0x%x"), hr);
                            }

                            //
                            //  If description parameter is null or is only a temporary description, then delete the
                            //  description instead of writing it.
                            //
                            LPTSTR pszDescValue = NULL;

                            if (pItem->szDescription[0]  && !pItem->bTempDescription)
                            {
                                pszDescValue = pItem->szDescription;
                            }

                            MYVERIFY(CELEMS(szNum) > (UINT)wsprintf(szNum, c_pszCmEntryConactDesc, iFileNum));

                            if (0 == WritePrivateProfileString(m_ActionSectionStrings[i], szNum, pszDescValue, pszCmsFile))
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                                CMTRACE1(TEXT("CustomActionList::WriteCustomActionsToCms -- unable to write description, hr is 0x%x"), hr);
                            }
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            CMTRACE1(TEXT("CustomActionList::WriteCustomActionsToCms -- unable to write connect action, hr is 0x%x"), hr);
                        }

                        CmFree(pszBuffer);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("CustomActionList::WriteCustomActionsToCms -- Unable to allocate pszBuffer!"));
                    }
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("WriteCustomActionsToCms -- custom action with empty program field!"));
                }

                pItem = pItem->Next;
                iFileNum++;
            }
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::AddOrRemoveCmdl
//
// Synopsis:  This function is designed ensure that the builtin custom action
//            cmdl is either in the custom action list or is removed from the
//            custom action list depending on the bAddCmdl flag.  Thus if the
//            Flag is TRUE the connect action is added if it doesn't exist
//            already.  If the bAddCmdl flag is FALSE then the custom action is
//            removed from the list.  Also note that there is now two cmdl
//            variations that could exist in a profile.  One for downloading
//            VPN updates and one for PBK updates.  Thus we also have the 
//            bForVpn flag that controls which version of the custom action
//            we are adding or removing.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            BOOL bAddCmdl - whether cmdl should be added or deleted
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::AddOrRemoveCmdl(HINSTANCE hInstance, BOOL bAddCmdl, BOOL bForVpn)
{

    HRESULT hr;
    CustomActionListItem* pItem = NULL;
    CustomActionListItem* pCurrent;
    CustomActionListItem* pFollower;

    if ((NULL == hInstance))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    //
    //  cmdl32.exe
    //
    pItem = (CustomActionListItem*)CmMalloc(sizeof(CustomActionListItem));

    MYDBGASSERT(pItem);
    if (pItem)
    {
        UINT uDescId;

        if (bForVpn)
        {
            uDescId = IDS_CMDL_VPN_DESC;
            pItem->pszParameters = CmStrCpyAlloc(TEXT("/VPN %PROFILE%"));
        }
        else
        {
            uDescId = IDS_CMDL_DESC;
            pItem->pszParameters = CmStrCpyAlloc(TEXT("%PROFILE%"));
        }

        MYVERIFY(LoadString(hInstance, uDescId, pItem->szDescription, CELEMS(pItem->szDescription)));
        lstrcpy(pItem->szProgram, TEXT("cmdl32.exe"));

        pItem->Type = ONCONNECT;
        pItem->bBuiltInAction = TRUE;
        pItem->bTempDescription = TRUE;

        MYDBGASSERT(pItem->pszParameters);

        if (pItem->pszParameters)
        {
            hr = Find(hInstance, pItem->szDescription, pItem->Type, &pCurrent, &pFollower);

            if (FAILED(hr))
            {
                //
                //  No cmdl32.exe.  If bAddCmdl is TRUE then we need to add it, otherwise our job here is done.
                //  If we are going to add it, lets make it the first in the list.  The user can move it later
                //  if they wish.
                //
                if (bAddCmdl)
                {
                    pItem->Next = m_CustomActionHash[pItem->Type];
                    m_CustomActionHash[pItem->Type] = pItem;
                    pItem = NULL; // don't free pItem
                }

                hr = S_OK;
            }
            else
            {
                //
                //  cmdl32.exe already exists and bAddCmdl is TRUE, nothing to do.  If bAddCmdl is FALSE
                //  and it already exists then we need to delete it.
                //
                if (bAddCmdl)
                {
                    hr = S_FALSE;                
                }
                else
                {
                    hr = Delete(hInstance, pItem->szDescription, pItem->Type);
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto exit;        
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

exit:

    if (pItem)
    {
        CmFree(pItem->pszParameters);
        CmFree(pItem);
    }

    return hr;
}

HRESULT DuplicateCustomActionListItem(CustomActionListItem* pCustomAction, CustomActionListItem** ppNewItem)
{
    HRESULT hr = S_OK;

    if (pCustomAction && ppNewItem)
    {
        *ppNewItem = (CustomActionListItem*)CmMalloc(sizeof(CustomActionListItem));

        if (*ppNewItem)
        {
            //
            //  Duplicate the existing item
            //
            CopyMemory(*ppNewItem, pCustomAction, sizeof(CustomActionListItem));

            //
            //  NULL out the Next pointer
            //
            (*ppNewItem)->Next = NULL;

            //
            //  If we have a param string, that must also be duplicated since
            //  it is an allocated string.
            //
            if (pCustomAction->pszParameters)
            {
                (*ppNewItem)->pszParameters = CmStrCpyAlloc(pCustomAction->pszParameters);

                if (NULL == (*ppNewItem)->pszParameters)
                {
                    hr = E_OUTOFMEMORY;
                    CmFree(*ppNewItem);
                    *ppNewItem = NULL;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        *ppNewItem = NULL;
        CMASSERTMSG(FALSE, TEXT("DuplicateCustomActionListItem"));
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::Add
//
// Synopsis:  This function adds the given custom action to the custom action
//            hash table.  Note that add is for new items and returns an error
//            if an existing custom action of the same description and type
//            already exists.  Also note that the CustomActionListItem passed in
//            is not just added to the hash table.  Add creates its own memory
//            for the custom action objects and the caller should not expect
//            add to free the past in memory.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            CustomActionListItem* pCustomAction - custom action structure to
//                                                  add to the list of existing
//                                                  custom actions
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::Add(HINSTANCE hInstance, CustomActionListItem* pCustomAction, LPCTSTR pszShortServiceName)
{
    HRESULT hr = S_OK;

    MYDBGASSERT(hInstance);
    MYDBGASSERT(pCustomAction);
    MYDBGASSERT(pCustomAction->szProgram[0]);

    if ((NULL == hInstance) || (NULL == pCustomAction) || (TEXT('\0') == pCustomAction->szProgram[0]))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    //
    //  First make sure that we have a description parameter because the description
    //  and the Type uniquely identify a custom action
    //

    TCHAR szCmProxy[MAX_PATH+1];
    TCHAR szCmRoute[MAX_PATH+1];

    wsprintf(szCmRoute, TEXT("%s\\cmroute.dll"), pszShortServiceName);
    wsprintf(szCmProxy, TEXT("%s\\cmproxy.dll"), pszShortServiceName);

    if (TEXT('\0') == pCustomAction->szDescription[0])
    {
        if (IsCmDl(pCustomAction))
        {
            //
            //  Cmdl32.exe as a post built-in custom action normally gets added through  
            //  AddOrRemoveCmdl.  However, to allow the user to move the custom actions
            //  around in the list, we want to add it here.  Note, that we must distinguish
            //  between the VPN download and the PBK download so that we get the description correct on each.
            //
            LPTSTR pszVpnSwitch = CmStrStr(pCustomAction->pszParameters, TEXT("/v"));
            UINT uDescStringId;

            if (NULL == pszVpnSwitch)
            {
                pszVpnSwitch = CmStrStr(pCustomAction->pszParameters, TEXT("/V"));
            }

            if (pszVpnSwitch)
            {
                uDescStringId = IDS_CMDL_VPN_DESC;
            }
            else
            {
                uDescStringId = IDS_CMDL_DESC;
            }

            pCustomAction->bBuiltInAction = TRUE;
            pCustomAction->bTempDescription = TRUE;
            MYVERIFY(LoadString(hInstance, uDescStringId, pCustomAction->szDescription, CELEMS(pCustomAction->szDescription)));
        }
        else
        {
            hr = FillInTempDescription(pCustomAction);
            MYDBGASSERT(SUCCEEDED(hr));
        }
    }
    else if (0 == lstrcmpi(pCustomAction->szProgram, szCmProxy))
    {
        if (ONCONNECT == pCustomAction->Type)
        {
            pCustomAction->bBuiltInAction = TRUE;
            MYVERIFY(LoadString(hInstance, IDS_CMPROXY_CON_DESC, pCustomAction->szDescription, CELEMS(pCustomAction->szDescription)));
        }
        else if (ONDISCONNECT == pCustomAction->Type)
        {
            pCustomAction->bBuiltInAction = TRUE;
            MYVERIFY(LoadString(hInstance, IDS_CMPROXY_DIS_DESC, pCustomAction->szDescription, CELEMS(pCustomAction->szDescription)));
        }
    }
    else if (0 == lstrcmpi(pCustomAction->szProgram, szCmRoute))
    {
        if (ONCONNECT == pCustomAction->Type)
        {
            pCustomAction->bBuiltInAction = TRUE;
            MYVERIFY(LoadString(hInstance, IDS_CMROUTE_DESC, pCustomAction->szDescription, CELEMS(pCustomAction->szDescription)));
        }    
    }

    //
    //  First figure out if we already have a list of connect actions for
    //  the type specified.  If not, then create one.
    //
    if (NULL == m_CustomActionHash[pCustomAction->Type])
    {
        hr = DuplicateCustomActionListItem(pCustomAction, &(m_CustomActionHash[pCustomAction->Type]));
        goto exit;
    }
    else
    {
        CustomActionListItem* pCurrent = NULL;
        CustomActionListItem* pFollower = NULL;

        //
        //  Search for an existing record with the same description.  If one exists return
        //  an error that it already exists.
        //
        hr = Find(hInstance, pCustomAction->szDescription, pCustomAction->Type, &pCurrent, &pFollower);

        if (SUCCEEDED(hr))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);

            goto exit;        
        }

        //
        //  If we got here, then we have a list but we don't have a matching entry.  Thus
        //  we must add a new entry to the end of the list
        //
        if (pFollower && (NULL == pFollower->Next))
        {
            hr = DuplicateCustomActionListItem(pCustomAction, &(pFollower->Next));
            goto exit;
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("CustomActionList::Add -- couldn't find place to add the new element!"));
            hr = E_UNEXPECTED;
            goto exit;
        }
    }

exit:
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CustomActionList::Edit
//
// Synopsis:  This function is used to edit an existing action.  The function
//            tries to replace the old action with the new one, keeping the
//            same place in the respective custom action list.  However, since
//            the new item could be of a different type than the old item, this
//            isn't always possible.  When the item changes type, it is deleted
//            from the old list and appended to the new custom action type list.
//            Also note, that when the caller is attempting to rename or re-type
//            an item, the function checks for collisions with existing items
//            of that name/type.  If the caller tries to rename an item
//            to the same name/type as another existing item then the function returns
//            an error.
//
// Arguments: HINSTANCE hInstance - instance handle to load string resources
//            CustomActionListItem* pOldCustomAction - a custom action struct
//                                                     containing at least the 
//                                                     description and type of
//                                                     the item that is to be
//                                                     editted.
//            CustomActionListItem* pNewCustomAction - the new data for the 
//                                                     custom action.
//
// Returns:   HRESULT - standard COM error codes
//
// History:   quintinb Created Header    02/26/00
//
//+----------------------------------------------------------------------------
HRESULT CustomActionList::Edit(HINSTANCE hInstance, CustomActionListItem* pOldCustomAction, CustomActionListItem* pNewCustomAction, LPCTSTR pszShortServiceName)
{
    MYDBGASSERT(hInstance);
    MYDBGASSERT(pOldCustomAction);
    MYDBGASSERT(pNewCustomAction);
    MYDBGASSERT(pNewCustomAction->szDescription[0]);
    MYDBGASSERT(pOldCustomAction->szDescription[0]);

    if ((NULL == hInstance) || (NULL == pOldCustomAction) || (NULL == pNewCustomAction) || 
        (TEXT('\0') == pOldCustomAction->szDescription[0]) || (TEXT('\0') == pNewCustomAction->szDescription[0]))
    {
        return E_INVALIDARG;
    }

    //
    //  First try to find the old custom action
    //
    CustomActionListItem* pTemp = NULL;
    CustomActionListItem* pTempFollower = NULL;
    CustomActionListItem* pExistingItem = NULL;
    CustomActionListItem* pFollower = NULL;
    CustomActionListItem** ppPointerToFillIn = NULL;

    HRESULT hr = Find (hInstance, pOldCustomAction->szDescription, pOldCustomAction->Type, &pExistingItem, &pFollower);

    if (SUCCEEDED(hr))
    {
        //
        //  Okay, we found the old custom action.  If the type and desc are the same between the two actions, 
        //  then all we need to do is copy over the data and be done with it.  However, if the user changed 
        //  the type or description then we need to double check that an action with the description and type
        //  of the new action doesn't already exist (editting action XYZ of type Post-Connect
        //  into action XYZ of type Pre-Connect when there already exists XYZ of type Pre-Connect).
        //
        if ((pOldCustomAction->Type == pNewCustomAction->Type) &&
            (0 == lstrcmpi(pExistingItem->szDescription, pNewCustomAction->szDescription)))
        {
      