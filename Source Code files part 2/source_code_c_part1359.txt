wWord, LCID lcid, PWORD_PRONS_BUFFER pProns);
   	STDMETHODIMP GetWordInformation (const WCHAR *pwWord, LCID lcid, DWORD dwTypes, DWORD dwLex, PWORD_INFO_BUFFER pInfo, PINDEXES_BUFFER pIndexes, DWORD *pdwLexTypeFound, GUID *pGuidLexFound);
   	STDMETHODIMP GetWordPronunciations (const WCHAR *pwWord, LCID lcid, DWORD dwLex, PWORD_PRONS_BUFFER pProns, PINDEXES_BUFFER pIndexes, DWORD *pdwLexTypeFound, GUID *pGuidLexFound);
   	STDMETHODIMP SetAppLexicon (WCHAR *pwPathFileName);
   	STDMETHODIMP SetUser (WCHAR *pwUserName, DWORD cLcids, LCID *pLcid);
   	STDMETHODIMP GetUser (WCHAR **ppwUserName);
      STDMETHODIMP InvokeLexiconUI (void);
      
      // ILxWalkStates members
      STDMETHODIMP GetLexCount(DWORD *dwNumUserLex, DWORD *dwNumAppLex, DWORD *dwNumVendorLex);
   	STDMETHODIMP GetSibling(DWORD dwNumSearchStates, SEARCH_STATE *pState);
      STDMETHODIMP GetChild(DWORD dwNumSearchStates, SEARCH_STATE *pState);
      STDMETHODIMP FindSibling(DWORD dwNumSearchStates, WCHAR wNodeChar, SEARCH_STATE *pState);
   
      // ILxAdvanced members
      STDMETHODIMP AddWordProbabilities(WCHAR *pwWord, DWORD dwNumChars, float *pflProb);
      STDMETHODIMP GetWordInString(WCHAR *pwString, DWORD dwMinLen, DWORD *pdwStartChar);
      STDMETHODIMP GetWordToken(DWORD dwLex, WCHAR *pwWord, WORD_TOKEN *pWordToken);
      STDMETHODIMP GetWordFromToken(WORD_TOKEN *pWordToken, WCHAR **ppwWord);
      STDMETHODIMP GetBestPath(BYTE *pLattice, BYTE *pBestPath);

      //ILxNotifySource members
      STDMETHODIMP SetNotifySink(ILxNotifySink *pNotifySink, ILxAuthenticateSink *pAuthenticateSink, ILxCustomUISink *pCustomUISink);

      // ILxSynchWithLexicon members
      STDMETHODIMP GetAppLexiconID(GUID *ID);
      STDMETHODIMP GetAppLexicon(LCID Lcid, GUID AppId, WORD_SYNCH_BUFFER *pWordSynchBuffer);
      STDMETHODIMP GetChangedUserWords(LCID Lcid, DWORD dwAddGenerationId, DWORD dwDelGenerationId,
                                       DWORD *pdwNewAddGenerationId, DWORD *pdwNewDelGenerationId, WORD_SYNCH_BUFFER *pWordSynchBuffer);

      // ILxHookLexiconObject members
      STDMETHODIMP SetHook(ILxLexiconObject *pLexiconObject, BOOL fTopVendor);

      //ILxLexiconUI members
      //STDMETHODIMP InvokeLexiconUI(void);

   private:
      HRESULT _ReleaseUserVendorLexs(void);
      void    _ReleaseAppLex(void);

   private:
      CAPIManager *m_pMgr;
      LONG m_cRef;
      CRITICAL_SECTION m_cs;
      PWSTR m_pwUserLexFile;
      PCDICT m_pUserLex;
      PWSTR m_pwUserName;
      PWSTR m_pwAppLexFile;
      PCDICT m_pAppLex;
      VENDORLEXID m_pVendorId[MAX_VENDOR_LEXICONS];
      PILXLEXICONOBJECT *m_pVendorLexs;
      DWORD m_nVendorLexs;
      HANDLE m_hSetUserMutex;
      ILxNotifySink *m_pNotifySink;
      ILxAuthenticateSink *m_pAuthenticateSink;
      ILxCustomUISink *m_pCustomUISink;
      ILxLexiconObject *m_pHookLexiconObject;
      bool m_fHookPosition;
};
   
//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\clookup.cpp ===
/*****************************************************************************
*  Clookup.cpp
*     Implements the vendor lexicon object for SR and TTS lookup lexicons
*
*  Owner: YunusM
*
*  Copyright 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#include "PreCompiled.h"
#include "MSGenLex.h"

static const PCSTR pLkupMutexName = "8FA68BB0-EE1B-11d2-9C23-00C04F8EF87C";
static const PCSTR pLkupMapName = "992C78C4-D8D7-11d2-9C1F-00C04F8EF87C";
static const PCSTR pRefCntMapName = "82309534-F6C7-11d2-9C24-00C04F8EF87C";


/*****************************************************************************
* _Constructor *
*--------------*
*
*  The real constructor.
*  Return: 
**********************************************************************YUNUSM*/
void CLookup::_Constructor(CVendorManager *pMgr)
{
   m_fInit        = false;
   
   *m_wszLkupFile = 0;

   m_pMgr         = pMgr;

   m_fAuthenticated = true;
   m_pLkupLexInfo = NULL;
   m_hLkupFile    = NULL;
   m_hLkupMap     = NULL;
   m_hInitMutex   = NULL;
   m_pLkup        = NULL;
   m_pWordHash    = NULL;
   m_pCmpBlock    = NULL;
   m_pRefCount    = NULL;
   m_hRefMapping  = NULL;

   m_pWordsDecoder = NULL;
   m_pPronsDecoder = NULL;
   m_pPosDecoder = NULL;

   m_pLts         = NULL;

} // void CLookup::_Constructor (void)


/*****************************************************************************
* CLookup *
*---------*
*
*  Constructor
*  Return: 
**********************************************************************YUNUSM*/
CLookup::CLookup(CVendorManager *pMgr)
{
   _Constructor(pMgr);

} // CLookup::CLookup ()


/*****************************************************************************
* _Destructor *
*-------------*
*
*  The real destructor.
*  Return: 
**********************************************************************YUNUSM*/
void CLookup::_Destructor (void)
{
   delete m_pLts;
   delete m_pWordsDecoder;
   delete m_pPronsDecoder;
   delete m_pPosDecoder;

   m_pLts = NULL;
   m_pWordsDecoder = NULL;
   m_pPronsDecoder = NULL;
   m_pPosDecoder = NULL;

   UnmapViewOfFile (m_pLkup);
   CloseHandle (m_hLkupMap);
   CloseHandle (m_hLkupFile);

   m_pLkup = NULL;
   m_hLkupFile = NULL;
   m_hLkupMap = NULL;

   UnmapViewOfFile (m_pRefCount);
   CloseHandle (m_hRefMapping);

   m_pRefCount = NULL;
   m_hRefMapping = NULL;

} // CLookup::_Destructor (void)


/*****************************************************************************
* ~CLookup *
*----------*
*
*  Destructor
*  Return: 
**********************************************************************YUNUSM*/
CLookup::~CLookup ()
{
   _Destructor ();

   CloseHandle (m_hInitMutex);

   m_hInitMutex = NULL;

} // CLookup::~CLookup ()


/*****************************************************************************
* _Init *
*-------*
*
*  Initializes the CLookup object with a lookup lexicon and a LTS lexicon. The
*  LTS lexicon is used to compress the lookup lexicon by storing the indexes
*  of the pronunciations in LTS lexion that also occur in the lookup lexicon.
*  
*  Return: S_OK E_FAIL, Win32 errors
**********************************************************************YUNUSM*/
HRESULT CLookup::_Init(PCWSTR pwszLkupFile,  // Lookup lexicon file
                       PCWSTR pwszLtsFile    // Lts lexicon file
                       )
{
   HRESULT hRes = S_OK;
   
   char szLkupFile[MAX_PATH];

   // We limit the fully qualified name length to a max of MAX_PATH
   if (!WideCharToMultiByte (CP_ACP, 0, pwszLkupFile, -1, szLkupFile, MAX_PATH, NULL, NULL))
   {
      hRes = E_FAIL;
      goto ErrorInit;
   }

   wcscpy (m_wszLkupFile, pwszLkupFile);
   wcscpy (m_wszLtsFile, pwszLtsFile);

   // Map the lookup lexicon
   m_hLkupFile = CreateFile (szLkupFile, GENERIC_READ, FILE_SHARE_READ, 
                             NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, 
                             NULL);
   if (m_hLkupFile == INVALID_HANDLE_VALUE)
   {
      hRes = HRESULT_FROM_WIN32 (GetLastError()); // bad input
      goto ErrorInit;
   }
  
   m_hLkupMap = CreateFileMapping (m_hLkupFile, NULL, PAGE_READONLY | SEC_COMMIT, 0 , 0, pLkupMapName);
   if (!m_hLkupMap) 
   {
      hRes = HRESULT_FROM_WIN32 (GetLastError());
      goto ErrorInit;
   }
  
   m_pLkup = (PBYTE) MapViewOfFile (m_hLkupMap, FILE_MAP_READ, 0, 0, 0);
   if (!m_pLkup) 
   {
      hRes = HRESULT_FROM_WIN32 (GetLastError()); // We or the OS did something wrong - cant return GetLastError()
      goto ErrorInit;
   }

   PBYTE p;
   p = m_pLkup;

   // Header
   m_pLkupLexInfo = (PLKUPLEXINFO)p;
   p += sizeof (LKUPLEXINFO);

   // Words Codebook
   PBYTE pWordCB;
   pWordCB = p;
   p += m_pLkupLexInfo->nWordCBSize;

   // Prons Codebook
   PBYTE pPronCB;
   pPronCB = p;
   p += m_pLkupLexInfo->nPronCBSize;
   
   // Pos Codebook
   PBYTE pPosCB;
   pPosCB = p;
   p += m_pLkupLexInfo->nPosCBSize;

   // Word hash table holding offsets into the compressed block
   m_pWordHash = p;
   p += (((m_pLkupLexInfo->nBitsPerHashEntry * m_pLkupLexInfo->nLengthHashTable) + 0x7) & (~0x7)) / 8;

   m_pCmpBlock = (PDWORD)p;

   m_pLts = new CLTS (NULL);
   if (!m_pLts)
   {
      hRes = E_OUTOFMEMORY;
      goto ErrorInit;
   }

   if (FAILED (hRes = m_pLts->Init(pwszLtsFile, NULL)))
   {
      goto ErrorInit;
   }

   m_pWordsDecoder = new CHuffDecoder(pWordCB);
   if (!m_pWordsDecoder)
   {
      hRes = E_OUTOFMEMORY;
      goto ErrorInit;
   }

   m_pPronsDecoder = new CHuffDecoder(pPronCB);
   if (!m_pPronsDecoder)
   {
      hRes = E_OUTOFMEMORY;
      goto ErrorInit;
   }

   m_pPosDecoder = new CHuffDecoder(pPosCB);
   if (!m_pPosDecoder)
   {
      hRes = E_OUTOFMEMORY;
      goto ErrorInit;
   }

   // Init the Read-write lex
   hRes = m_RWLex.Init (m_pLkupLexInfo);
   if (FAILED (hRes))
   {
      goto ErrorInit;
   }

   // Create the shared memory to store the number of clients to the lookup file
   m_hRefMapping =  CreateFileMapping ((HANDLE)0xffffffff, // use the system paging file
                                        NULL, PAGE_READWRITE, 0, sizeof (DWORD), pRefCntMapName);
   if (!m_hRefMapping)
   {
      hRes = HRESULT_FROM_WIN32 (GetLastError ());
      goto ErrorInit;
   }

   bool fMapCreated;

   (ERROR_ALREADY_EXISTS == GetLastError ()) ? fMapCreated = false : fMapCreated = true;

   m_pRefCount = (PINT) MapViewOfFile (m_hRefMapping, FILE_MAP_WRITE, 0, 0, 0);
   if (!m_pRefCount)
   {
      hRes = HRESULT_FROM_WIN32 (GetLastError ());
      goto ErrorInit;
   }

   // Increment the ref count at the end of init when everything has succeeded
   if (fMapCreated)
   {
      *m_pRefCount = 1;
   }
   else
   {
      (*m_pRefCount)++;
   }
   
   goto ReturnInit;

ErrorInit:

   _Destructor ();

ReturnInit:

   return hRes;

} // HRESULT CLookup::_Init (PWSTR pwszLkupFile)


/*****************************************************************************
* Init *
*------*
*
*  Initializes the CLookup object with a lookup lexicon and a LTS lexicon. The
*  LTS lexicon is used to compress the lookup lexicon by storing the indexes
*  of the pronunciations in LTS lexion that also occur in the lookup lexicon.
*  
*  Return: S_OK E_FAIL, Win32 errors
**********************************************************************YUNUSM*/
HRESULT CLookup::Init(PCWSTR pwszLkupFile, // Lookup lexicon file 
                      PCWSTR pwszLtsFile)  // Lts lexicon file   
{
   if (LexIsBadStringPtr(pwszLkupFile) ||
       LexIsBadStringPtr(pwszLtsFile))
      return E_INVALIDARG;

   // Do not allow multiple inits
   if (true == m_fInit)
   {
      return HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);
   }

   HRESULT hRes = S_OK;
   
   // We don't ask for ownership of the mutex because more than
   // one thread could be executing here

   m_hInitMutex = CreateMutex (NULL, FALSE, pLkupMutexName);
   if (!m_hInitMutex)
   {
      return HRESULT_FROM_WIN32 (GetLastError());
   }

   WaitForSingleObject (m_hInitMutex, INFINITE);
   
   hRes = _Init (pwszLkupFile, pwszLtsFile);

   m_fInit = true;

   ReleaseMutex (m_hInitMutex);

   return hRes;

} // HRESULT CLookup::Init (PWSTR pwzLkupPath)


/**********************************************************
Hash function for the Word hash tables
**********************************************************/

__inline DWORD GetWordHashValue (PCWSTR pwszWord, DWORD nLengthHash)
{
   DWORD dHash = *pwszWord++;
   
   WCHAR c;
   WCHAR cPrev = (WCHAR)dHash;

   for (; *pwszWord; pwszWord++)
   {
      c = *pwszWord;

      //dHash += ((*pszWord + *(pszWord - 1)) << (char)(*pszWord)); // 79k
      //dHash += (((*pszWord) << (char)(*pszWord)) + ((*(pszWord - 1)) << (char)(*(pszWord - 1)))); // 73k
      //dHash += (((*pszWord) << (char)(*(pszWord+1))) + ((*(pszWord - 1)) << (char)(*(pszWord)))); // 71k
      //dHash += ((*pszWord) << (char)(*(pszWord+1))); // 72k
      //dHash += (((*pszWord) << (char)(*(pszWord+1))) + ((*(pszWord)) << (char)(*(pszWord-1)))); // 71k
      //dHash += (((*pszWord) << (char)(*(pszWord))) + ((*(pszWord-1)) << (char)(*(pszWord+1)))); // 73k
      //dHash += (((*pszWord) << (char)(*(pszWord-1))) + ((*(pszWord-1)) << (char)(*(pszWord+1)))); // 70.5k
      dHash += ((c << cPrev) + (cPrev << c)); // 70.3k

      cPrev = c;
   }

   return (((dHash << 16) - dHash) % nLengthHash);

} // __inline DWORD GetWordHashValue (PCWSTR pwszWord, DWORD nLengthHash)


/**********************************************************
Stub hash function for the Word hash tables
Called by the tools (outside the lib) since the GetWordHashValue
is inlined in 'release' build and cannot be called
**********************************************************/

DWORD GetWordHashValueStub (PWSTR pwszWord, DWORD nLengthHash)
{
   return GetWordHashValue (pwszWord, nLengthHash);
}


/**********************************************************
Get the entry in hash table at index dHash
**********************************************************/

__inline DWORD CLookup::GetCmpHashEntry (DWORD dHash)
{
   DWORD d = 0;

   DWORD dBitStart = dHash * m_pLkupLexInfo->nBitsPerHashEntry;

   _ASSERTE (m_pLkupLexInfo->nBitsPerHashEntry < 8 * sizeof (d));

   for (DWORD i = 0; i < m_pLkupLexInfo->nBitsPerHashEntry; i++)
   {
      d <<= 1; // No change the first time since d is 0
      d |= ((m_pWordHash[dBitStart >> 3] >> (7 ^ (dBitStart & 7))) & 1);
      dBitStart++;
   }

   return d;

} // DWORD CLookup::GetCmpHashEntry (DWORD dhash)


/**********************************************************
Do a compare over the valid bit range
**********************************************************/

__inline bool CLookup::CompareHashValue (DWORD dHash, DWORD d)
{
   return (dHash == (d & ~(-1 << m_pLkupLexInfo->nBitsPerHashEntry)));

} // bool CLookup::CompareHashValue (DWORD dhash, DWORD d)


/**********************************************************
Copy nBits from pSource at dSourceOffset bit to pDest
**********************************************************/

__inline void CLookup::CopyBitsAsDWORDs (PDWORD pDest, PDWORD pSource, 
                                         DWORD dSourceOffset, DWORD nBits)
{
   DWORD sDWORDs = dSourceOffset >> 5;
   DWORD sBit = dSourceOffset & 0x1f;

   // Figure out how many DWORDs dSourceOffset - dSourceOffset + nBits straddles

   DWORD nDWORDs = nBits ? 1 : 0;
   DWORD nNextDWORDBoundary = ((dSourceOffset + 0x1f) & ~0x1f);

   if (!nNextDWORDBoundary)
      nNextDWORDBoundary = 32;

   while (nNextDWORDBoundary < (dSourceOffset + nBits))
   {
      nDWORDs++;
      nNextDWORDBoundary += 32;
   }

   CopyMemory (pDest, pSource + sDWORDs, nDWORDs * sizeof (DWORD));

   if (sBit)
   {
      for (DWORD i = 0; i < nDWORDs; i++)
      {
         pDest[i] >>= sBit;

         if (i < nDWORDs - 1)
            pDest[i] |= (pDest[i+1] << (32 - sBit));
         else
            pDest[i] &= ~(-1 << (32 - sBit));
      }
   }

} // void CLookup::CopyBitsAsDWORDs (PDWORD pDest, PDWORD pSource,


/**********************************************************
Read the (compressed) word at the dOffset bit and return 
the word and the new offset
**********************************************************/

__inline HRESULT CLookup::ReadWord (DWORD *dOffset, PWSTR pwWord)
{
   // Get the length of the entire compressed block in bytes
   
   DWORD nCmpBlockLen;
   if (m_pLkupLexInfo->nLengthCmpBlockBits % 8)
      nCmpBlockLen = (m_pLkupLexInfo->nLengthCmpBlockBits / 8) + 1;
   else
      nCmpBlockLen = m_pLkupLexInfo->nLengthCmpBlockBits / 8;

   // Get the amount of compressed block after *dOffset in bytes
   // We include the byte in which *dOffset bit occurs if *dOffset
   // is not a byte boundary
   
   DWORD nLenDecode = nCmpBlockLen - ((*dOffset) / 8);
   if (nLenDecode > 2*MAX_STRING_LEN)
      nLenDecode = 2*MAX_STRING_LEN;

   // We dont know the length of the word. Just keep decoding and 
   // stop when you encounter a NULL. Since we allow words of maximum
   // length MAX_STRING_LEN chars and the compressed word *can* theoretically be
   // longer than the word itself, a buffer of length 2*MAX_STRING_LEN is used.

   BYTE BufToDecode[2*MAX_STRING_LEN];

   CopyBitsAsDWORDs ((DWORD*)BufToDecode, m_pCmpBlock, *dOffset, nLenDecode * 8);

   PWSTR pw = pwWord;

   /*
   ZeroMemory (BufToDecode,sizeof (BufToDecode));

   BufToDecode [0] = 0xff;
   BufToDecode [1] = 0x5d;
   BufToDecode [2] = 0x1f;
   BufToDecode [3] = 0xeb;
   BufToDecode [4] = 0xed;
   BufToDecode [5] = 0x10;
   BufToDecode [6] = 0x71;
   BufToDecode [7] = 0x8a;
   BufToDecode [8] = 0x02;
   //BufToDecode [9] = 0x10;
   BufToDecode [9] = 0x02;
   */
   //m_pWordsDecoder->SetBase (BufToDecode);

   int iBit = (int)*dOffset;
   HUFFKEY k = 0;

   while (SUCCEEDED(m_pWordsDecoder->Next (m_pCmpBlock, &iBit, &k)))
   {
      *pw++ = k;
      if (!k)
         break;
   }

   _ASSERTE (!k && iBit);

   *dOffset = iBit;

   if (pw == pwWord)
   {
      _ASSERTE (0);
      return E_FAIL;
   }

   return NOERROR;

} // __inline HRESULT CLookup::ReadWord (DWORD *dOffset, PWSTR pwWord)


/**********************************************************
Reads word information of type 'Type' at offset *dOffset
and returns the info in *ppInfo and also updates *dOffset
**********************************************************/

STDMETHODIMP CLookup::GetWordInformation(const WCHAR *pwWord, LCID lcid, DWORD dwInfoTypeFlags, DWORD dwLex,
                                         PWORD_INFO_BUFFER pInfo, PINDEXES_BUFFER pIndexes,
                                         DWORD *pdwLexTypeFound, GUID *pGuidLexFound)
{
   // Not validating args since this is an internal call

   HRESULT hr = S_OK;

   WCHAR wlWord [MAX_STRING_LEN];

   wcscpy (wlWord, pwWord);
   towcslower (wlWord);

   PWSTR pwlWord = wlWord;

   if (dwLex == LEXTYPE_GUESS)
   {
      hr = m_pLts->GetWordInformation (pwWord, lcid, dwInfoTypeFlags, dwLex, pInfo, pIndexes, pdwLexTypeFound, pGuidLexFound);
      goto ReturnLkupGetPronunciations;
   }

   if (!(dwLex & LEXTYPE_VENDOR))
   {
      hr = LEXERR_NOTINLEX;
      goto ReturnLkupGetPronunciations;
   }

   DWORD dHash;
   dHash = GetWordHashValue (pwlWord, m_pLkupLexInfo->nLengthHashTable);

   // Cannot just index into hash table since each element in hash table is 
   // m_pLkupLexInfo->nBitsPerHashEntry long

   WCHAR wszWord[MAX_STRING_LEN];

   DWORD dOffset;
   dOffset = 0;

   for (;;)
   {
      dOffset = GetCmpHashEntry (dHash);

      if (CompareHashValue (dOffset, (DWORD)-1))
      {
         // BUGBUG: Activate this check when appropriate
         //if (dwLex & LEXTYPE_GUESS)
         //{
            hr = m_pLts->GetWordInformation (pwWord, lcid, dwInfoTypeFlags, dwLex, pInfo, pIndexes, pdwLexTypeFound, pGuidLexFound);

            goto ReturnLkupGetPronunciations;
         //}
         //else
         //{
         //   hRes = LEXERR_NOTINLEX;
         //   goto ReturnLkupGetPronunciations;
         //}

      }

      hr = ReadWord (&dOffset, wszWord);
      if (FAILED(hr))
         goto ReturnLkupGetPronunciations;

      if (wcsicmp (pwlWord, wszWord))
      {
         dHash++;

         if (dHash == m_pLkupLexInfo->nLengthHashTable)
            dHash = 0;

         continue;
      } else
         break;
   } // for (;;)

   DWORD dwInfoBytesNeeded;
   DWORD dwNumInfoBlocks;
   dwInfoBytesNeeded = 0;
   dwNumInfoBlocks = 0;

   // we figure we won't need a return buffer bigger than this
   BYTE InfoReturned[MAXINFOBUFLEN];
   PLEX_WORD_INFO pWordInfoReturned;
   pWordInfoReturned = (PLEX_WORD_INFO)InfoReturned;

   //char sz[256];
   //sprintf (sz, "*dOffset = %d\n", *dOffset);
   //OutputDebugString (sz);
   
   bool fLast;
   fLast = false;
   WCHAR LTSProns [MAX_PRON_LEN * MAX_OUTPUT_STRINGS];
   *LTSProns = 0;
      
   //OutputDebugString ("In ReadWordInfo\n");

   while (false == fLast)
   {
      // Read the control block (CBSIZE bits)
      // Length is 2 because of the way CopyBitsAsDWORDs works when the bits
      // to be copied straddle across DWORDs
      DWORD cb[4];
      cb[0] = 0;

      _ASSERTE (CBSIZE <= 8);
      
      CopyBitsAsDWORDs (cb, m_pCmpBlock, dOffset, CBSIZE);
      dOffset += CBSIZE;
      
      if (cb[0] & (1 << (CBSIZE - 1)))
      {
         fLast = true;
      }

      int CBType = cb[0] & ~(-1 << (CBSIZE -1));

      switch (CBType)
      {
      case I_LKUPLTSPRON:
         {
            // Read the index of LTS pron which takes LTSINDEXSIZE bits
            _ASSERTE (LTSINDEXSIZE <= 8);
      
            // Length is 2 because of the way CopyBitsAsDWORDs works when the bits
            // to be copied straddle across DWORDs
            DWORD iLTS[4];
            iLTS[0] = 0;

            CopyBitsAsDWORDs (iLTS, m_pCmpBlock, dOffset, LTSINDEXSIZE);
            iLTS[0] &= ~(-1 << (LTSINDEXSIZE -1));

            dOffset += LTSINDEXSIZE;
      
            if (!(dwInfoTypeFlags & PRON))
            {
               continue;
            }

            pWordInfoReturned->Type = PRON;

            WORD_INFO_BUFFER WI;
            INDEXES_BUFFER IB;

            ZeroMemory(&WI, sizeof(WI));
            ZeroMemory(&IB, sizeof(IB));

            // Get the iLTSth LTS pronunciation
            if (!*LTSProns)
            {
               hr = m_pLts->GetWordInformation(pwWord, lcid, PRON, LEXTYPE_GUESS, &WI, &IB, pdwLexTypeFound, pGuidLexFound);
               if (FAILED(hr))
               {
                  goto ReturnLkupGetPronunciations;
               }
            }
      
            wcscpy (pWordInfoReturned->wPronunciation, (((LEX_WORD_INFO*)(WI.pInfo))[IB.pwIndex[iLTS[0]]]).wPronunciation);

            CoTaskMemFree(WI.pInfo);
            CoTaskMemFree(IB.pwIndex);

            DWORD d = (wcslen (pWordInfoReturned->wPronunciation) + 1) * sizeof (WCHAR);
            if (d > sizeof (LEX_WORD_INFO_UNION))
               d -= sizeof (LEX_WORD_INFO_UNION);
            else
               d = 0;

            d += sizeof (LEX_WORD_INFO);

            dwNumInfoBlocks++;
            dwInfoBytesNeeded += d;

            pWordInfoReturned = (PLEX_WORD_INFO)((PBYTE)pWordInfoReturned + d);
      
            break;
         
         } // case LTSPRON:
      
      case I_LKUPLKUPPRON:
         {
            //OutputDebugString ("lkup pron\n");

            /*
            // Read the length of Lookup pron which takes LKUPLENSIZE bits
            _ASSERTE (LKUPLENSIZE <= 8);
      
            // Length is 2 because of the way CopyBitsAsDWORDs works when the bits
            // to be copied straddle across DWORDs
            DWORD nLkupLen[2];
            nLkupLen[0] = 0;

            CopyBitsAsDWORDs (nLkupLen, m_pCmpBlock, *dOffset, LKUPLENSIZE);
            nLkupLen[0] &= ~(-1 << (LKUPLENSIZE -1));

            *dOffset += LKUPLENSIZE;
      
            _ASSERTE (nLkupLen[0]);
            */

            DWORD dOffsetSave = dOffset;
      
            DWORD CmpLkupPron[MAX_PRON_LEN];
      
            DWORD nCmpBlockLen;
            if (m_pLkupLexInfo->nLengthCmpBlockBits & 0x7)
            {
               nCmpBlockLen = (m_pLkupLexInfo->nLengthCmpBlockBits >> 3) + 1;
            }
            else
            {
               nCmpBlockLen = m_pLkupLexInfo->nLengthCmpBlockBits >> 3;
            }
            
            // Get the amount of compressed block after *dOffset in bytes
            // We include the byte in which *dOffset bit occurs if *dOffset
            // is not a byte boundary
            
            DWORD nLenDecode = nCmpBlockLen - (dOffsetSave >> 3);
            if (nLenDecode > MAX_STRING_LEN)
            {
               nLenDecode = MAX_STRING_LEN;
            }
      
            CopyBitsAsDWORDs (CmpLkupPron, m_pCmpBlock, dOffsetSave, (nLenDecode << 3));
      
            // Decode the pronunciation
      
            //m_pPronsDecoder->SetBase ((PBYTE)CmpLkupPron);
      
            int iBit = (int)dOffset;
      
            WCHAR LkupPron[MAX_PRON_LEN];
            PWSTR p = LkupPron;
      
            /*
            for (DWORD i = 0; i < nLkupLen[0]; i++)
            {
               *p++ = m_pPronsDecoder->Next (&iBit);
            }
            */

            HUFFKEY k = 0;
            while (SUCCEEDED(m_pPronsDecoder->Next (m_pCmpBlock, &iBit, &k)))
            {
               //if (k)
               //   sprintf (sz, "k = %x\n", k);
               //else
               //   sprintf (sz, "NULL k\n");

               //OutputDebugString (sz);

               *p++ = k;
               if (!k)
               {
                  break;
               }
            }
      
            _ASSERTE (!k && iBit);

            // Increase the offset past the encoded pronunciation
            dOffset = iBit;
      
            if (! (dwInfoTypeFlags & PRON))
            {
               continue;
            }
      
            // Increase the *pdwInfoBytesNeeded so that it is a multiple of sizeof (LEX_WORD_INFO);
            // Note: WordInfos are made to be start LEX_WORD_INFO multiple boundaries only in
            // the buffer that is returned.

            pWordInfoReturned->Type = PRON;

            *p = NULL;
      
            wcscpy (pWordInfoReturned->wPronunciation, LkupPron);
            
            DWORD d = (wcslen (pWordInfoReturned->wPronunciation) + 1) * sizeof (WCHAR);
            if (d > sizeof (LEX_WORD_INFO_UNION))
               d -= sizeof (LEX_WORD_INFO_UNION);
            else
               d = 0;

            d += sizeof (LEX_WORD_INFO);

            dwNumInfoBlocks++;
            dwInfoBytesNeeded += d;

            pWordInfoReturned = (PLEX_WORD_INFO)((PBYTE)pWordInfoReturned + d);
      
            break;
         
         } // case LKUPPRON:

      case I_POS:
         {
            DWORD CmpPos[4];
            CopyBitsAsDWORDs (CmpPos, m_pCmpBlock, dOffset, POSSIZE);

            int iBit = (int)dOffset;
            HUFFKEY k = 0;
            if (FAILED(m_pPosDecoder->Next (m_pCmpBlock, &iBit, &k)))
            {
               goto ReturnLkupGetPronunciations;
            }

            // Increase the offset past the encoded pronunciation
            dOffset = iBit;

            if (! (dwInfoTypeFlags & POS))
            {
               continue;
            }

            pWordInfoReturned->Type = POS;

            pWordInfoReturned->POS = (unsigned short)k;
            
            dwNumInfoBlocks++;

            DWORD d = sizeof (LEX_WORD_INFO);
            dwInfoBytesNeeded += d;
            pWordInfoReturned = (PLEX_WORD_INFO)((PBYTE)pWordInfoReturned + d);
      
            break;
         
         } // case I_POS:

      default:
         {
            // Not supported yet
      
            _ASSERTE (0);
         }
      } // switch (CBType)
      
   } // while (false == fLast)

   //sprintf (sz, "nInfoUse = %d\n", nInfoUse);
   //OutputDebugString (sz);

   hr = _ReallocWordInfoBuffer(pInfo, dwInfoBytesNeeded + sizeof(LEX_WORD_INFO) * dwNumInfoBlocks);
   if (FAILED(hr))
      goto ReturnLkupGetPronunciations;

   hr = _ReallocIndexesBuffer(pIndexes, dwNumInfoBlocks);
   if (FAILED(hr))
      goto ReturnLkupGetPronunciations;

   _AlignWordInfo((LEX_WORD_INFO*)InfoReturned, dwNumInfoBlocks, dwInfoTypeFlags, pInfo, pIndexes);

   //sprintf (sz, "hRes returned from ReadWordInfo = %x\n", hRes);
   //OutputDebugString (sz);

   if (pdwLexTypeFound)
      *pdwLexTypeFound = LEXTYPE_VENDOR;

   if (pGuidLexFound)
      *pGuidLexFound = m_pLkupLexInfo->gLexiconID;

ReturnLkupGetPronunciations:

   return hr;
} // STDMETHODIMP CLookup::GetWordInformation()


HRESULT CLookup::Shutdown (bool fSerialize)
{
   WaitForSingleObject (m_hInitMutex, INFINITE);

   m_RWLex.Lock (true); // lock the r/w lex in read-only mode
   
   HRESULT hRes = NOERROR;

   FILE * fp = NULL;
   FILE *fprw = NULL;

   // BUGBUG: The intermediate file should be hidden

   // temp text file to dump the r/w lex 
   char szTempRWFile[MAX_PATH * 2];
   WCHAR wszTempRWFile[MAX_PATH * 2];

   wcscpy (wszTempRWFile, m_wszLkupFile);
   wcscat (wszTempRWFile, L".rw.txt");

   (*m_pRefCount)--;
   _ASSERTE ((*m_pRefCount) >= 0);

   if ((fSerialize == false) || (*m_pRefCount > 0) || (true == m_RWLex.IsEmpty ()))
   {
      // nothing to do
      goto ReturnSerialize;
   }

   WideCharToMultiByte (CP_ACP, 0, wszTempRWFile, -1, szTempRWFile, MAX_PATH, NULL, NULL);

   hRes = m_RWLex.FlushAscii (m_pLkupLexInfo->Lcid, wszTempRWFile);
   if (FAILED (hRes))
   {
      goto ReturnSerialize;
   }

   fprw = fopen (szTempRWFile, "r");
   if (!fprw)
   {
      hRes = E_FAIL;
      goto ReturnSerialize;
   }

   // temp text file to dump the word and word-info to
   char szTempLkupFile [MAX_PATH * 2];

   WideCharToMultiByte (CP_ACP, 0, m_wszLkupFile, -1, szTempLkupFile, MAX_PATH, NULL, NULL);
   strcat (szTempLkupFile, ".interm.txt");

   fp = fopen (szTempLkupFile, "w");
   if (!fp)
   {
      hRes = E_FAIL;
      goto ReturnSerialize;
   }

   WORD_INFO_BUFFER WI;
   INDEXES_BUFFER IB;

   ZeroMemory(&WI, sizeof(WI));
   ZeroMemory(&IB, sizeof(IB));

   // walk the words in the lookup file and check if they occur in dict file
   DWORD dHash;
   for (dHash = 0; dHash < m_pLkupLexInfo->nLengthHashTable; dHash++)
   {
      DWORD dOffset = GetCmpHashEntry (dHash);

      if (CompareHashValue (dOffset, (DWORD)-1))
      {
         continue;
      }

      WCHAR wszWord[MAX_STRING_LEN];
      
      hRes = ReadWord (&dOffset, wszWord);
      if (FAILED(hRes))
      {
         goto ReturnSerialize;
      }
      
      // query the dict file for this word

      hRes = m_RWLex.GetWordInformation(wszWord, m_pLkupLexInfo->Lcid, PRON|POS, &WI, &IB, NULL, NULL);
      if (FAILED (hRes))
      {
         if (hRes != LEXERR_NOTINLEX)
         {
            goto ReturnSerialize;
         }

         DWORD dwLexTypeFound;

         hRes = GetWordInformation (wszWord, m_pLkupLexInfo->Lcid, PRON|POS, LEXTYPE_VENDOR,
                                         &WI, &IB, &dwLexTypeFound, NULL);

         if (LEXTYPE_VENDOR != dwLexTypeFound)
         {
            goto ReturnSerialize;
         }
      } 
      else
      {
         continue; // ignore the entry in lookup lexicon
      }

      char sz[MAX_PRON_LEN * 10];
      
      // Write the word
      strcpy (sz, "Word ");
      WideCharToMultiByte (CP_ACP, 0, wszWord, -1, sz + strlen (sz), MAX_STRING_LEN, NULL, NULL);
      fprintf (fp, "%s\n", sz);
         
      // Write the word-information
      DWORD iPron;
      DWORD iPOS;
      iPron = 0;
      iPOS = 0;
   
      PLEX_WORD_INFO pInfo;
      pInfo = (PLEX_WORD_INFO)(WI.pInfo);
   
      DWORD i;
      for (i = 0; i < WI.cInfoBlocks; i++)
      {
         WORD Type = pInfo[IB.pwIndex[i]].Type;
   
         switch (Type)
         {
         case PRON:
            strcpy (sz, "Pronunciation");
            itoa (iPron, sz + strlen (sz), 10);
            strcat (sz, " ");
         
            itoah (pInfo[IB.pwIndex[i]].wPronunciation, sz + strlen (sz));
         
            fprintf (fp, "%s\n", sz);

            iPron++;
            break;
         
         case POS:
            strcpy (sz, "POS");
            itoa (iPOS, sz + strlen (sz), 10);
            strcat (sz, " ");
         
            itoa (pInfo[IB.pwIndex[i]].POS, sz + strlen (sz), 10);
         
            fprintf (fp, "%s\n", sz);

            iPOS++;
            break;

         default:
            _ASSERTE (0);
            goto ReturnSerialize;
         } // switch (Type)
      } // for (i = 0; i < dwNumInfoBlocks; i++)
   } // for (DWORD dHash = 0; dHash < m_pLkupLexInfo->nLengthHashTable; dHash++)

   CoTaskMemFree(WI.pInfo);
   CoTaskMemFree(IB.pwIndex);

   // append the entries of the rw lex to the llokup text file
   char sz[MAX_PRON_LEN * 10];

   while (fgets (sz, MAX_PRON_LEN * 10, fprw))
   {
      fprintf (fp, sz);
   }

   fclose (fp);
   fclose (fprw);
   fp = NULL;
   fprw = NULL;

   // Build a lookup lex file out of szTempLkupFile

   // temp lex file
   char szTempLexFile [MAX_PATH * 2];
   WCHAR wszTempLexFile [MAX_PATH * 2];
   WCHAR wszTempLkupFile [MAX_PATH * 2];
   char szLkupFile [MAX_PATH * 2];

   wcscpy (wszTempLexFile, m_wszLkupFile);
   wcscat (wszTempLexFile, L".interm.lex");

   MultiByteToWideChar(CP_ACP, MB_COMPOSITE, szTempLkupFile, -1, wszTempLkupFile, MAX_PATH);

   hRes = BuildLookup(m_pLkupLexInfo->Lcid, m_pLkupLexInfo->gLexiconID, wszTempLkupFile, wszTempLexFile, 
                      m_wszLtsFile, true, false);
   if (FAILED (hRes))
   {
      goto ReturnSerialize;
   }

   WideCharToMultiByte (CP_ACP, 0, m_wszLkupFile, -1, szLkupFile, MAX_PATH, NULL, NULL);

   // release the current object and reinit it
   _Destructor ();
   
   // delete the existing lookup file
   if (!DeleteFile (szLkupFile))
   {
      hRes = HRESULT_FROM_WIN32 (GetLastError ());
      goto ReturnSerialize;
   }

   WideCharToMultiByte (CP_ACP, 0, wszTempLexFile, -1, szTempLexFile, MAX_PATH, NULL, NULL);

   // would like to use MoveFileEx with MOVEFILE_WRITE_THROUGH flag
   // but it is not supported in Win95
   if (!MoveFile(szTempLexFile, szLkupFile))
   {
      hRes = HRESULT_FROM_WIN32 (GetLastError ());
      goto ReturnSerialize;
   }

   WCHAR wszLkupFile [MAX_PATH], wszLtsFile[MAX_PATH];
   wcscpy (wszLkupFile, m_wszLkupFile);
   wcscpy (wszLtsFile, m_wszLtsFile);

   hRes = _Init (wszLkupFile, wszLtsFile);
   if (FAILED (hRes))
   {
      goto ReturnSerialize;
   }

ReturnSerialize:

   DeleteFile (szTempLkupFile);
   DeleteFile (szTempRWFile);

   if (fp)
   {
      fclose (fp);
   }

   if (fprw)
   {
      fclose (fprw);
   }

   m_RWLex.UnLock (true);

   ReleaseMutex (m_hInitMutex);

   return hRes;

} // HRESULT CLookup::Shutdown (bool fSerialize)


STDMETHODIMP_ (ULONG) CLookup::AddRef()
{
   m_pMgr->AddRef();
   return ++m_cRef;
}
   
STDMETHODIMP_ (ULONG) CLookup::Release()
{
   ULONG i = --m_cRef;
   m_pMgr->Release();
   return i;
}

STDMETHODIMP CLookup::QueryInterface(REFIID riid, LPVOID *ppv)
{
   return m_pMgr->QueryInterface(riid, ppv);
}

STDMETHODIMP CLookup::GetHeader(LEX_HDR *pLexHdr)
{
   if (!pLexHdr)
   {
      return E_POINTER;
   }

   if (IsBadWritePtr(pLexHdr, sizeof(LEX_HDR)))
   {
      return E_INVALIDARG;
   }

	return E_NOTIMPL;
}

STDMETHODIMP CLookup::Authenticate(GUID, GUID *pLexId)
{
   if (!pLexId)
      return E_POINTER;

   if (IsBadWritePtr(pLexId, sizeof(GUID)))
      return E_INVALIDARG;
   
   *pLexId = m_pLkupLexInfo->gLexiconID;

	return S_OK;
}

STDMETHODIMP CLookup::IsAuthenticated(BOOL *pfAuthenticated)
{
	if (!pfAuthenticated)
   {
      return E_POINTER;
   }

   if (IsBadWritePtr(pfAuthenticated, sizeof(BOOL)))
   {
      return E_INVALIDARG;
   }

   *pfAuthenticated = m_fAuthenticated;   

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\cf.h ===
/*****************************************************************************
*  CF.h
*     Declares the class factories
*
*  Owner: YunusM
*
*  Copyright 1999 Microsoft Corporation All Rights Reserved.
******************************************************************************/

#pragma once

//--- Forward and External Declarations --------------------------------------

typedef void (*PFOBJECTDESTROYED)();

/*****************************************************************************
* ClassFactory to create instances of the LexAPI object.
**********************************************************************YUNUSM*/
class CAPIClassFactory : public IClassFactory 
{
   public:
      CAPIClassFactory(void);
      ~CAPIClassFactory(void);
   
      STDMETHODIMP         QueryInterface (REFIID, void**);
      STDMETHODIMP_(ULONG) AddRef(void);
      STDMETHODIMP_(ULONG) Release(void);
   
      STDMETHODIMP         CreateInstance (LPUNKNOWN, REFIID, void**);
      STDMETHODIMP         LockServer (BOOL);
   
   protected:
      ULONG          m_cRef;  // Reference count on class object
};


/*****************************************************************************
* ClassFactory to create instances of the SR vendor lexicon object
**********************************************************************YUNUSM*/
class CVendorClassFactory : public IClassFactory 
{
   friend HRESULT BuildLookup (LCID lid, const WCHAR * pwLookupTextFile, const WCHAR * pwLookupLexFile, 
                   BYTE * pLtsDat, DWORD nLtsDat, BOOL fUseLtsCode, BOOL fSupIsRealWord);
public:
   CVendorClassFactory(CLSID);
   ~CVendorClassFactory(void);

   STDMETHODIMP         QueryInterface (REFIID, LPVOID FAR *);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   STDMETHODIMP         CreateInstance (LPUNKNOWN, REFIID, LPVOID FAR *);
   STDMETHODIMP         LockServer (BOOL);

private:
   LONG m_cRef;
   CLSID m_Clsid;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\bldbackup.cpp ===
/*****************************************************************************
*  BldBackup.cpp
*     Functions to build the lookup and lts vendor lexicons. This file was
*     written to be a part of internal too. This has to be changed to a class
*     and all the globals should be eliminated. The functionality however stays
*     the same.
*
*  Owner: YunusM
*
*  Copyright 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#include "PreCompiled.h"

// GLOBALS

static PSTR pMutexName     = "630B4350-E0EE-11d2-8F22-000000000000";

PLTS  pLts                 = NULL;// LTS Object
//int   nLtsSize             = 0;   // size of the Lts data
//PBYTE pLtsData             = NULL;// Lts Data
DWORD nTotalWords          = 0;   // Total number of words
DWORD nTotalProns          = 0;   // Total number of pronunciations
DWORD nWordsOnlyLTSProns   = 0;   // Count of words such that all prons of the word exist in LTS (subset of nTotalWords)
DWORD nTotalPronsinLTS     = 0;   // Total number of prons which are in LTS (subset of nTotalProns)
DWORD nLkupWords           = 0;   // Number of words stored in lookup file (subset of nTotalWords)
DWORD nLkupProns           = 0;   // Number of prons stored in lookup file (subset of nTotalProns)
DWORD nLkupLTSProns        = 0;   // Number of prons in lookup file which are in LTS (subset of nLkupProns)
DWORD nLkupPOSs            = 0;   // Number of parts-of-speechs stored in lookup file

DWORD nBlockLen            = 0;   // Length of block containing words and pronunciations
DWORD nBlockUseDWORDs      = 0;   // Amount of block in use in DWORDs
DWORD nBlockUseBits        = 0;   // Amount of block in use in bits
DWORD *pBlock              = NULL;// The block containing the compressed words + CBs + prons

DWORD *pHash               = NULL;// Hash table of words to hold offsets into pBlock
DWORD nHashLen             = 0;   // Length of the hash table
DWORD nBitsPerHash         = 0;   // Number of bits used to store a hash entry
DWORD nCollisions          = 0;   // Number of collisions when building the hash table

PBYTE pCmpHash             = NULL;// Hash table (with just enough number of bits)
                                  // of words to hold offsets into pBlock
DWORD nCmpHashBytes        = 0;   // Size of pCmpHash rounded to next byte

CHuffEncoder *WordsEncoder = NULL;// Huffman encoder to encode words
CHuffEncoder *PronsEncoder = NULL;// Huffman encoder to encode prons
CHuffEncoder *PosEncoder   = NULL;// Huffman encoder to encode POSs

LCID Lcid                  = (LCID)-1;  // LCID of the lexicon being built
GUID gLexGuid;                    // Lookup lexicon GUID

char szTempPath[2*MAX_PATH];      // The path to the temporary directory
char szLookupTextFile[MAX_PATH];     // Input file
char szTextLexFileIn[MAX_PATH];   // The actual input file after removing the LTS-prons-only words
char szTextLexFileOut[MAX_PATH];  // The file generated out of binary lookup lex to check
char szLookupLexFile[MAX_PATH];   // Output file
WCHAR wszLtsLexFile[MAX_PATH];    // Lts lex file

BOOL fSupportIsRealWord = FALSE;  // Store word in the lkup even if all pronunciations of a word exist in Lts
BOOL fUseLtsToCode = FALSE;       // Encode the prons in Lkup if they occur in Lts

char WordCBFile [MAX_PATH * 2];   // Words code book file
char PronCBFile [MAX_PATH * 2];   // Prons code book file
char PosCBFile [MAX_PATH * 2];    // POS code book file


// Set the 'iBit' bit of 'p' to 1
void SetBit (PBYTE p, DWORD iBit)
{
   DWORD dByte = iBit / 8;
   DWORD dBitinByte = iBit % 8;

   p[dByte] |= (1 << (7 - dBitinByte));
}


// Set the 'iBit' bit of 'p' to 1
void SetBitInDWORD (PDWORD p, DWORD iBit)
{
   DWORD dDWORD = iBit / 32;
   DWORD dBitinDWORD = iBit % 32;

   p[dDWORD] |= 1 << dBitinDWORD;
}


typedef struct
{
   PHONEID PhoneId;
   BYTE nType;
} PID;

PID *pIntPhoneIPAId;

int ComparePhoneIndex (const void* p1, const void* p2)
{
   return (stricmp (pIntPhoneIPAId[*((PBYTE)p1)].PhoneId.szPhone, 
                    pIntPhoneIPAId[*((PBYTE)p2)].PhoneId.szPhone));

} // int ComparePhoneIndex (const void* p1, const void* p2)


int CompareIPAIndex (const void* p1, const void* p2)
{
   if (pIntPhoneIPAId[*((PBYTE)p1)].PhoneId.ipaPhone >
       pIntPhoneIPAId[*((PBYTE)p2)].PhoneId.ipaPhone)
      return 1;
   else if (pIntPhoneIPAId[*((PBYTE)p1)].PhoneId.ipaPhone <
       pIntPhoneIPAId[*((PBYTE)p2)].PhoneId.ipaPhone)
      return -1;
   else
      return 0;

} // int CompareIPAIndex (const void* p1, const void* p2)


// Build the lts lexicon
HRESULT BuildLts (LCID Lcid, GUID LexGuid, PCWSTR pwszLtsRulesFile, PCWSTR pwszPhoneMapFile, PCWSTR pwszLtsLexFile)
{
   if (IsBadReadPtr (pwszLtsRulesFile, sizeof (WCHAR) * 2) ||
       IsBadReadPtr (pwszPhoneMapFile, sizeof (WCHAR) * 2) ||
       IsBadReadPtr (pwszLtsLexFile, sizeof (WCHAR) * 2))
      return E_INVALIDARG;

   HRESULT hRes = NOERROR;

   char szLtsRulesFile [MAX_PATH * 2];
   char szPhoneMapFile [MAX_PATH * 2];
   char szLtsLexFile [MAX_PATH * 2];
   FILE *frules = NULL;
   FILE *fmap = NULL;
   FILE *flts = NULL;

   int nPhones = 0;
   int nEnginePhones = 0;
   int nLtsPhones = 0;

   PBYTE pLtsPhoneIPAIndex = NULL;
   PBYTE pEnginePhoneIPAIndex = NULL;
   PBYTE pIPAEnginePhoneIndex = NULL;
   PBYTE pRules = NULL;

   WideCharToMultiByte (CP_ACP, 0, pwszLtsRulesFile, -1, szLtsRulesFile, MAX_PATH * 2, NULL, NULL);
   WideCharToMultiByte (CP_ACP, 0, pwszPhoneMapFile, -1, szPhoneMapFile, MAX_PATH * 2, NULL, NULL);
   WideCharToMultiByte (CP_ACP, 0, pwszLtsLexFile, -1, szLtsLexFile, MAX_PATH * 2, NULL, NULL);

   frules = fopen (szLtsRulesFile, "rb");
   if (!frules)
   {
      hRes = E_FAIL;
      goto ReturnBuildLts;
   }

   fmap = fopen (szPhoneMapFile, "r");
   if (!fmap)
   {
      hRes = E_FAIL;
      goto ReturnBuildLts;
   }

   flts = fopen (szLtsLexFile, "wb");
   if (!flts)
   {
      hRes = E_FAIL;
      goto ReturnBuildLts;
   }

   // Header
   LTSLEXINFO ltsLexInfo;

   ltsLexInfo.gLexiconID = LexGuid;
   ltsLexInfo.Lcid = Lcid;
   fwrite (&ltsLexInfo, sizeof (LTSLEXINFO), 1, flts);

   // Map file
   char szBuf[256];

   // We're being inefficient reading the file twice
   // Remember - this is a tool

   while (fgets (szBuf, 256, fmap))
   {
      PSTR p = strchr (szBuf, ' ');
      p = strchr (p, ' ');
      p++;
      p = strchr (p, ' ');
      p++;

      if (p == strchr (p, '1'))
      {
         nEnginePhones++;
         nLtsPhones++;
      }
      else if (p == strchr (p, '2'))
      {
         nEnginePhones++;
      }
      else if (p == strchr (p, '0'))
      {
         nLtsPhones++;
      }

      nPhones++;
   }

   fseek (fmap, 0, SEEK_SET);

   // internal phone to IPA table
   pIntPhoneIPAId = (PID*) calloc (nPhones, sizeof(PID));
   if (!pIntPhoneIPAId) 
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLts;
   } 

   // index on the above table sorted on Lts phones
   pLtsPhoneIPAIndex = (PBYTE) malloc (nLtsPhones);
   if (!pLtsPhoneIPAIndex)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLts;
   } 

   // index on the above table sorted on Engine phones
   pEnginePhoneIPAIndex = (PBYTE) malloc (nEnginePhones);
   if (!pEnginePhoneIPAIndex)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLts;
   } 

   // index on the above table sorted on IPA to access engine phones
   pIPAEnginePhoneIndex = (PBYTE) malloc (nEnginePhones);
   if (!pIPAEnginePhoneIndex)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLts;
   } 

   int k;
   for (k = 0; k < nPhones; k++) 
   {
      fgets (szBuf, 256, fmap);
      PSTR p = strchr (szBuf, ' ');
      *p++ = NULL;

      _ASSERTE (strlen (szBuf) < sizeof (pIntPhoneIPAId[k].PhoneId.szPhone));

      strcpy (pIntPhoneIPAId[k].PhoneId.szPhone, szBuf);

      PSTR p1 = strchr (p, ' ');
      *p1++ = NULL;

      DWORD nLenId = strlen (p);

      _ASSERTE (!(nLenId % 4) && ((nLenId / 2) < sizeof (pIntPhoneIPAId[k].PhoneId.ipaPhone)));

      // convert the szId to __uint64

      char szIdWSpaces[128];
      PSTR pszIPA = szIdWSpaces;

      for (DWORD i = 0; i <= nLenId; i++)
      {
         *pszIPA++ = p[i];

         if (p[i + 1] && (0 == ((i + 1) & 0x3)))
         {
            *pszIPA++ = ' ';
         }
      }

      ahtoi (szIdWSpaces, (PWSTR)(&(pIntPhoneIPAId[k].PhoneId.ipaPhone)), NULL);

      pIntPhoneIPAId[k].nType = (unsigned char)atoi (p1);
   
   } // for (int k = 0; k < nPhones; k++) 
             
   // build the pLtsPhoneIPAIndex
   int n1;
   n1 = 0;
   for (k = 0; k < nPhones; k++)
   {
      if (pIntPhoneIPAId[k].nType > 1)
         continue;

      pLtsPhoneIPAIndex[n1++] = (unsigned char)k;
   }

   _ASSERTE (n1 == nLtsPhones);
   _ASSERTE (n1 < 256);

   qsort (pLtsPhoneIPAIndex, nLtsPhones, sizeof (BYTE), ComparePhoneIndex);

   // build the pEnginePhoneIPAIndex
   n1 = 0;
   for (k = 0; k < nPhones; k++)
   {
      if (pIntPhoneIPAId[k].nType < 1)
         continue;

      pEnginePhoneIPAIndex[n1++] = (unsigned char)k;
   }

   _ASSERTE (n1 == nEnginePhones);
   _ASSERTE (n1 < 256);

   qsort (pEnginePhoneIPAIndex, nEnginePhones, sizeof (BYTE), ComparePhoneIndex);

   // build the pIPAEnginePhoneIndex
   n1 = 0;
   for (k = 0; k < nPhones; k++)
   {
      if (pIntPhoneIPAId[k].nType < 1)
         continue;

      pIPAEnginePhoneIndex[n1++] = (unsigned char)k;
   }

   _ASSERTE (n1 == nEnginePhones);
   _ASSERTE (n1 < 256);

   qsort (pIPAEnginePhoneIndex, nEnginePhones, sizeof (BYTE), CompareIPAIndex);

   // write the counts

   fwrite (&nPhones, sizeof (nPhones), 1, flts);
   fwrite (&nLtsPhones, sizeof (nLtsPhones), 1, flts);
   fwrite (&nEnginePhones, sizeof (nEnginePhones), 1, flts);

   // write the map

   for (k = 0; k < nPhones; k++)
   {
      fwrite (&(pIntPhoneIPAId[k].PhoneId), sizeof (PHONEID), 1, flts);
   }

   // write the indicies

   fwrite (pLtsPhoneIPAIndex, sizeof (BYTE), nLtsPhones, flts);
   fwrite (pEnginePhoneIPAIndex, sizeof (BYTE), nEnginePhones, flts);
   fwrite (pIPAEnginePhoneIndex, sizeof (BYTE), nEnginePhones, flts);

   // Lts rules

   fseek (frules, 0, SEEK_END);
   k = ftell (frules);
   fseek (frules, 0, SEEK_SET);

   pRules = (PBYTE) malloc (k);
   if (!pRules)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLts;
   }

   fread (pRules, 1, k, frules);

   fwrite (pRules, 1, k, flts);

ReturnBuildLts:

   fclose (flts);
   fclose (fmap);
   fclose (frules);

   free (pIntPhoneIPAId);
   free (pLtsPhoneIPAIndex);
   free (pEnginePhoneIPAIndex);
   free (pIPAEnginePhoneIndex);

   free (pRules);

   _ASSERTE (_CrtCheckMemory ());

   _CrtDumpMemoryLeaks();

   return hRes;

}  // int BuildLts (void)


// Add a buffer of so many bits long to the big block
void AddToBlock (DWORD *pBuffer, DWORD nBits)
{
   DWORD nDWORDs = ((nBits + 0x1f) & (~0x1f)) >> 5;

   CopyMemory (pBlock + nBlockUseDWORDs, pBuffer, nDWORDs * sizeof (DWORD));

   if (nBlockUseDWORDs * 32 - nBlockUseBits)
   {
      for (DWORD i = 0; i < nDWORDs; i++)
      {
         pBlock[nBlockUseDWORDs + i - 1] &= ~(-1 << (32 - (nBlockUseDWORDs * 32 - nBlockUseBits)));

         pBlock[nBlockUseDWORDs + i - 1] |= 
            pBlock[nBlockUseDWORDs + i] << (32 - (nBlockUseDWORDs * 32 - nBlockUseBits));

         pBlock[nBlockUseDWORDs + i] >>= nBlockUseDWORDs * 32 - nBlockUseBits;
      }
   }

   nBlockUseBits += nBits;

   nBlockUseDWORDs = ((nBlockUseBits + 0x1f) & (~0x1f)) >> 5;
} // void AddToBlock (PBYTE pBuffer, DWORD nBits)


// Build the code books for the encoding of words and pronunciations
HRESULT ConstructWordsPronsCode (void)
{
   HRESULT hRes = NOERROR;
   
   FILE *fpWordsCode = NULL;
   FILE *fpPronsCode = NULL;
   FILE *fpPossCode = NULL;

   FILE *fp = fopen (szTextLexFileIn, "r");
   if (!fp)
   {
      hRes = E_FAIL;
      goto ReturnConstructCode;
   }

   //WordsEncoder->FInit (0xffff);
   //PronsEncoder->FInit (0xffff);
   //PosEncoder->FInit (0xffff);

   // Build the code books

   char sz[1024];
   while (fgets (sz, 1024, fp))
   {
      WCHAR wsz[1024];

      MultiByteToWideChar (CP_ACP, MB_COMPOSITE, sz, -1, wsz, 1024);

      PWSTR pw = wcschr (wsz, L' ');
      _ASSERTE (pw);
      if (!pw)
         continue;

      *pw++ = 0;

      PSTR p = strchr (sz, ' ');
      
      *p++ = 0;

      if (pw[wcslen(pw) - 1] == L'\n')
         pw[wcslen(pw) - 1] = 0;

      if (p[strlen(p) - 1] == L'\n')
         p[strlen(p) - 1] = 0;

      if (wsz == wcsstr (wsz, L"Word"))
      {
         //PSTR p1 = p;

         //for (DWORD nGram = 1; nGram <= 1; nGram++)
         //{
           towcslower (pw);

           do
            {
               WORD w = *pw;

               if (FAILED(WordsEncoder->Count (w)))
               {
                  _ASSERTE (0);
                  break;
               }
            } while (*pw++); // encode the terminating null too

          //  p = p1;
         //}
      }
      else if (wsz == wcsstr (wsz, L"Pronunciation"))
      {
         WCHAR wPron[1024];
         DWORD d;

         ahtoi (p, wPron, &d);

         //for (DWORD nGram = 1; nGram <= 3; nGram++)
         //{
            for (DWORD i = 0; i <= d; i++) // encode the terminating null too
            {
               if (FAILED(PronsEncoder->Count (wPron[i])))
               {
                  _ASSERTE(0);
                  break;
               }
            }
         //}
      }
      else if (wsz == wcsstr (wsz, L"POS"))
      {
         PART_OF_SPEECH pos;

         pos = (PART_OF_SPEECH)atoi (p);

         if (FAILED(PosEncoder->Count ((HUFFKEY)pos)))
         {
            _ASSERTE(0);
            break;
         }
      }
      else
      {
         _ASSERTE (0);
      }
   }

   // The huffman encoder needs atleast two keys to work properly
   if (1 == WordsEncoder->GetNumKeys ())
   {
      WordsEncoder->Count ((HUFFKEY)-1);
      WordsEncoder->Count ((HUFFKEY)-2);
   }

   if (1 == PronsEncoder->GetNumKeys ())
   {
      PronsEncoder->Count ((HUFFKEY)-1);
      PronsEncoder->Count ((HUFFKEY)-2);
   }

   if (1 == PosEncoder->GetNumKeys ())
   {
      PosEncoder->Count ((HUFFKEY)-1);
      PosEncoder->Count ((HUFFKEY)-2);
   }
   
   // Write out the code books
   
   fpWordsCode = fopen (WordCBFile, "wb");
   fpPronsCode = fopen (PronCBFile, "wb");
   fpPossCode = fopen (PosCBFile, "wb");
   
   if (!fpWordsCode || !fpPronsCode || !fpPossCode)
   {
      hRes = E_FAIL;
      goto ReturnConstructCode;
   }

   if ((FAILED(WordsEncoder->ConstructCode (fpWordsCode))) || 
       (FAILED(PronsEncoder->ConstructCode (fpPronsCode))) ||
       (FAILED(PosEncoder->ConstructCode (fpPossCode))))
   {
      hRes = E_FAIL;
      goto ReturnConstructCode;
   }

ReturnConstructCode:

   fclose (fpWordsCode);
   fclose (fpPronsCode);
   fclose (fpPossCode);

   fclose (fp);

   return hRes;

} // int ConstructWordsPronsCode (void)


HRESULT CountWordsProns (void)
{
   nLkupWords = 0;
   nLkupProns = 0;
   nLkupLTSProns = 0;
   nLkupPOSs = 0;
   nWordsOnlyLTSProns = 0;

   FILE * fpLookupTextFile = fopen (szLookupTextFile, "r");
   if (!fpLookupTextFile)
      return E_FAIL;

   char sz[MAX_PRON_LEN * 5];

   while (fgets (sz, MAX_PRON_LEN * 5, fpLookupTextFile))
   {
      if (sz == strstr (sz, "Word"))
      {
         nLkupWords++;
         nTotalWords++;
      }
      else if (sz == strstr(sz, "Pronunciation"))
      {
         nLkupProns++;
         nTotalProns++;
      }
      else if (sz == strstr(sz, "POS"))
         nLkupPOSs++;
   }

   fclose (fpLookupTextFile);

   return NOERROR;
} // HRESULT CountWordsProns (void)


// Figure out the words with only LTS prons
HRESULT ScrubLexForLTS (void)
{
   nLkupWords = 0;
   nLkupProns = 0;
   nLkupLTSProns = 0;
   nWordsOnlyLTSProns = 0;
   nLkupPOSs = 0;

   FILE * fpLookupTextFile = fopen (szLookupTextFile, "r");
   if (!fpLookupTextFile)
      return E_FAIL;

   FILE *fpin = fopen (szTextLexFileIn, "w");
   if (!fpin)
   {
      _ASSERTE (0);
      return E_FAIL;
   }

   WORD_INFO_BUFFER WI;
   INDEXES_BUFFER IB;

   ZeroMemory(&WI, sizeof(WI));
   ZeroMemory(&IB, sizeof(IB));

#ifdef _DEBUG
   char szWordsOnlyLts[2*MAX_PATH];

   strcpy (szWordsOnlyLts, szTempPath);
   strcat (szWordsOnlyLts, "WordsOnlyLts.txt"); 

   FILE *fpdelta = fopen (szWordsOnlyLts, "w");
   if (!fpdelta)
   {
      _ASSERTE (0);
      return E_FAIL;
   }
#endif

   HRESULT hRes;

   //WCHAR LTSProns[MAX_INFO_RETURNED_SIZE/sizeof(WCHAR)];
   //WORD wPronIndex[MAX_NUM_LEXINFO];
   //DWORD nLTSProns = 0;                // Number of LTS prons for this word

   bool fOnlyLTSProns         = false; // used to detect words all of whose prons exist in LTS

   DWORD nLkups               = 0;     // Number of Lkup prons for the current word
   DWORD nLTSs                = 0;     // Number of Lkup prons for this word which also ocur in LTS
   DWORD nPoss                = 0;     // Number of POSs for this word
   
   char sz[MAX_PRON_LEN * 10];

   char szWordPrev[MAX_STRING_LEN];
   BYTE szInfoPrev[MAX_NUM_LEXINFO][MAX_PRON_LEN * 10];
   WORD wTypePrev[MAX_NUM_LEXINFO];

   *szWordPrev = 0;

   while (fgets (sz, MAX_PRON_LEN * 5, fpLookupTextFile))
   {
      PSTR p = strchr (sz, ' ');
      _ASSERTE (p);
      if (!p)
         continue;

      *p++ = 0;

      if (p[strlen(p) - 1] == '\n')
         p[strlen(p) - 1] = 0;

      if (sz == strstr (sz, "Word"))
      {
         nTotalWords++;

         if (TRUE == fOnlyLTSProns && FALSE == fSupportIsRealWord && !nPoss)
         {
            nWordsOnlyLTSProns++;

#ifdef _DEBUG
            if (*szWordPrev)
            {
               fprintf (fpdelta, "Word %s\n", szWordPrev);

               DWORD iPron = 0;
               DWORD iPos = 0;

               for (DWORD i = 0; i < (nLkups + nLTSs + nPoss); i++)
               {
                  switch (wTypePrev[i])
                  {
                  case PRON:
                     fprintf (fpdelta, "Pronunciation%d %s\n", iPron++, (PSTR)(szInfoPrev[i]));
                     break;

                  case POS:
                     fprintf (fpdelta, "POS%d %s\n", iPos++, szInfoPrev[i][0]);
                     break;

                  default:
                     _ASSERTE (0);
                     break;
                  }
               }
            }
#endif
         }
         else
         {
            nLkupProns += (nLkups + nLTSs);
            nLkupLTSProns += nLTSs;
            nLkupPOSs += nPoss;

            fOnlyLTSProns = true;

            if (*szWordPrev)
            {
               fprintf (fpin, "Word %s\n", szWordPrev);

               DWORD iPron = 0;
               DWORD iPos = 0;

               for (DWORD i = 0; i < (nPoss + nLkups + nLTSs); i++)
               {
                  switch (wTypePrev[i])
                  {
                  case PRON:
                     fprintf (fpin, "Pronunciation%d %s\n", iPron++, (PSTR)(szInfoPrev[i]));
                     break;

                  case POS:
                     fprintf (fpin, "POS%d %d\n", iPos++, szInfoPrev[i]);
                     break;
                  }
               }

               _ASSERTE (iPron + iPos == nPoss + nLkups + nLTSs);
            }
         }

         strcpy (szWordPrev, p);
         
         nLkups = 0;
         nLTSs = 0;
         nPoss = 0;

         //DWORD dReq;

         WCHAR wsz[MAX_STRING_LEN];

         MultiByteToWideChar (CP_ACP, MB_COMPOSITE, p, -1, wsz, MAX_STRING_LEN);

         towcslower (wsz);

         //DWORD dReqIndex;

         // Get the Lts pronunciations of the word
         hRes = pLts->GetWordInformation(wsz, Lcid, PRON, LEXTYPE_GUESS, &WI, &IB, NULL, NULL);
         //hRes = pLts->GetWordPronunciations (wsz, LTSProns, wPronIndex, MAX_INFO_RETURNED_SIZE, 
         //                                    MAX_INDEX_RETURNED_SIZE, &dReq, &dReqIndex, &nLTSProns, NULL, NULL);
         _ASSERTE (SUCCEEDED(hRes));
         if (FAILED(hRes))
            continue;
      }
      else if (sz == strstr (sz, "Pronunciation"))
      {
         nTotalProns++;

         if ((nLkups + nLTSs + nPoss) >= MAX_NUM_LEXINFO)
         {
            _ASSERTE (0);
            char szError [256];
            sprintf (szError, "Word %s has more than MAX_NUM_LEXINFO info blocks. Ignoring extra info blocks.\n", szWordPrev);
            OutputDebugString (szError);

            continue;
         }

         wTypePrev [nLkups + nLTSs + nPoss] = PRON;
         strcpy ((PSTR) szInfoPrev [nLkups + nLTSs + nPoss], p);

         // convert the pron to WCHARs
         WCHAR wPron [1024];

         ahtoi (p, wPron);

         // check if wpron is identical to a LTS pron
         DWORD iLTSPron = 0;

         for (iLTSPron = 0; iLTSPron < WI.cInfoBlocks; iLTSPron++)
         {
            if (!wcscmp (wPron, (((LEX_WORD_INFO*)(WI.pInfo))[IB.pwIndex[iLTSPron]]).wPronunciation))
               break;
         }

         if (iLTSPron == WI.cInfoBlocks || iLTSPron > MAXLTSPRONMATCHED)
         {
            iLTSPron = (DWORD)-1;
         }

         if ((DWORD)-1 != iLTSPron)
         {
            nTotalPronsinLTS++;
            nLTSs++;
         }
         else
         {
            fOnlyLTSProns = false;
            nLkups++;
         }
      }
      else if (sz == strstr (sz, "POS"))
      {
         if ((nLkups + nLTSs + nPoss) >= MAX_NUM_LEXINFO)
         {
            _ASSERTE (0);
            char szError [256];
            sprintf (szError, "Word %s has more than MAX_NUM_LEXINFO info blocks. Ignoring extra info blocks.\n", szWordPrev);
            OutputDebugString (szError);

            continue;
         }

         // takes only a byte to store the POS
         wTypePrev [nLkups + nLTSs + nPoss] = POS;
         szInfoPrev [nLkups + nLTSs + nPoss][0] = (unsigned char)atoi (p);

         nPoss++;
      }
      else
      {
         _ASSERTE (0);
      }
   }

   // For the last word

   if (TRUE == fOnlyLTSProns && FALSE == fSupportIsRealWord && !nPoss)
   {
      nWordsOnlyLTSProns++;

#ifdef _DEBUG
      if (*szWordPrev)
      {
         fprintf (fpdelta, "Word %s\n", szWordPrev);

         DWORD iPron = 0;
         DWORD iPos = 0;

         for (DWORD i = 0; i < (nLkups + nLTSs + nPoss); i++)
         {
            switch (wTypePrev[i])
            {
            case PRON:
               fprintf (fpdelta, "Pronunciation%d %s\n", iPron++, (PSTR)(szInfoPrev[i]));
               break;

            case POS:
               fprintf (fpdelta, "POS%d %s\n", iPos++, szInfoPrev[i][0]);
               break;

            default:
               _ASSERTE (0);
               break;
            }
         }
      }
#endif
   }
   else
   {
      if (*szWordPrev)
      {
         nLkupProns += (nLkups + nLTSs);
         nLkupLTSProns += nLTSs;
         nLkupPOSs += nPoss;
         
         fprintf (fpin, "Word %s\n", szWordPrev);
         
         DWORD iPron = 0;
         DWORD iPos = 0;

         for (DWORD i = 0; i < (nPoss + nLkups + nLTSs); i++)
         {
            switch (wTypePrev[i])
            {
            case PRON:
               fprintf (fpin, "Pronunciation%d %s\n", iPron++, (PSTR)(szInfoPrev[i]));
               break;

            case POS:
               fprintf (fpin, "POS%d %d\n", iPos++, szInfoPrev[i][0]);
               break;
            }
         }

         _ASSERTE (iPron + iPos == nPoss + nLkups + nLTSs);
      }
   }

   nLkupWords = nTotalWords - nWordsOnlyLTSProns;

#ifdef _DEBUG
   fclose (fpdelta);
#endif

   CoTaskMemFree(WI.pInfo);
   CoTaskMemFree(IB.pwIndex);

   fclose (fpLookupTextFile);
   fclose (fpin);

   return NOERROR;

} //int ScrubLexForLTS (void)


// Encode the words and prons and write them to the big block along with
// the control blocks (CBs)
HRESULT EncodeWordsProns (void)
{
   FILE *fp = fopen (szTextLexFileIn, "r");
   if (!fp)
   {
      _ASSERTE (0);
      return E_FAIL;
   }

   HRESULT hRes;

   WORD_INFO_BUFFER WI;
   INDEXES_BUFFER IB;

   ZeroMemory(&WI, sizeof(WI));
   ZeroMemory(&IB, sizeof(IB));

   // Allocate the hash table to hold the offsets into the words + CB + prons block
   nHashLen = (DWORD)(1.5 * nLkupWords) + 1;

   // Chose a prime in between the two powers of 2
   if (nHashLen >= 0x10000 && nHashLen < 0x20000)
      nHashLen = 88471;
   else if (nHashLen >= 0x20000 && nHashLen < 0x40000)
      nHashLen = 182821;

   pHash = (DWORD *) malloc (nHashLen * sizeof (DWORD));
   if (!pHash)
   {
      _ASSERTE (0);
      return E_OUTOFMEMORY;
   }

   FillMemory (pHash, nHashLen * sizeof (DWORD), 0xFF);

   DWORD iCBBitToSet = 0;

   nBlockLen = (nLkupWords + nLkupProns) * 20; // arbitrary!
   pBlock = (PDWORD) malloc (nBlockLen);
   if (!pBlock)
   {
      _ASSERTE (0);
      return E_OUTOFMEMORY;
   }

   //WCHAR LTSProns[MAX_PRON_LEN * MAX_OUTPUT_STRINGS];
   //WORD wPronIndex[MAX_NUM_LEXINFO];
   //DWORD nLTSProns = 0;                // Number of LTS prons for this word

   char sz[MAX_PRON_LEN * 5];

   while (fgets (sz, MAX_PRON_LEN * 5, fp))
   {
      WCHAR wsz[MAX_PRON_LEN * 5];

      MultiByteToWideChar (CP_ACP, MB_COMPOSITE, sz, -1, wsz, 1024);

      PWSTR pw = wcschr (wsz, L' ');
      _ASSERTE (pw);
      if (!pw)
         continue;

      *pw++ = 0;

      while (*pw == ' ')
      {
         pw++;
      }

      PSTR p = strchr (sz, ' ');

      *p++ = 0;

      while (*p == ' ')
      {
         p++;
      }

      if (pw[wcslen(pw) - 1] == L'\n')
         pw[wcslen(pw) - 1] = 0;

      if (p[strlen(p) - 1] == '\n')
         p[strlen(p) - 1] = 0;

      if (wsz == wcsstr (wsz, L"Word"))
      {
         // limit the length of the word
         pw [MAX_STRING_LEN - 1] = 0;

         WCHAR wszWord[MAX_STRING_LEN];

         wcscpy(wszWord, pw);

         //char szErr [256];
         //sprintf (szErr, "nBlockUseBits = %d\n", nBlockUseBits);
         //OutputDebugString (szErr);
         //DebugBreak();

         // New word - set the fLast bit in previous word's last CB block
         if (iCBBitToSet) // Dont set the first time we are here
            SetBitInDWORD (pBlock, iCBBitToSet);

         towcslower (pw);

         // Hash the word
         DWORD dHash = GetWordHashValueStub (pw, nHashLen);

         while (pHash [dHash] != (DWORD)-1)
         {
            nCollisions++;
            dHash++;

            if (dHash == nHashLen)
               dHash = 0;
         }

         pHash [dHash] = nBlockUseBits;
         
         // Encode the word
         DWORD d = wcslen (pw);
         for (DWORD i = 0; i <= d; i++) 
         { 
            // pass in null too
            if (FAILED(WordsEncoder->Encode ((HUFFKEY)pw[i])))
            {
               _ASSERTE (0);
               continue;
            }
         }
   
         _ASSERTE (i == d + 1);

         DWORD nBits = 0;
         DWORD bBuffer[MAX_STRING_LEN * 3];

         ZeroMemory (bBuffer, sizeof (bBuffer));
         WordsEncoder->Flush (bBuffer, (int*)&nBits);
         _ASSERTE (nBits);

         //sprintf (szErr, "nWordBits = %d\n", nBits);
         //OutputDebugString (szErr);
         //DebugBreak();

#ifdef _DEBUG
         DWORD dSave = nBlockUseBits;
#endif
         AddToBlock (bBuffer, nBits);
         _ASSERTE (nBlockUseBits ==  dSave + nBits);

         if (TRUE == fUseLtsToCode)
         {
            //DWORD dReq, dReqIndex;

            // Caution: Preserve the case of the word when calling LTS
            // Get the Lts pronunciations of the word
            hRes = pLts->GetWordInformation(wszWord, Lcid, PRON, LEXTYPE_GUESS, &WI, &IB, NULL, NULL);
            //hRes = pLts->GetWordPronunciations (pw, LTSProns, wPronIndex, MAX_INFO_RETURNED_SIZE, 
            //                                 MAX_INDEX_RETURNED_SIZE, &dReq, &dReqIndex, &nLTSProns, NULL, NULL);
            _ASSERTE (SUCCEEDED(hRes));
            if (FAILED(hRes))
               continue;
         }
      }
      else if (sz == strstr (sz, "Pronunciation"))
      {
         // convert the pron to WCHARs
         WCHAR wPron [MAX_PRON_LEN * 3];

         ahtoi (p, wPron);

         // limit the length of the pron
         wPron [MAX_PRON_LEN - 1] = 0;

         // check if wpron is identical to a LTS pron
         DWORD iLTSPron = 0;

         if (TRUE == fUseLtsToCode)
         {
            for (iLTSPron = 0; iLTSPron < WI.cInfoBlocks; iLTSPron++)
            {
               if (!wcscmp (wPron, (((LEX_WORD_INFO*)(WI.pInfo))[IB.pwIndex[iLTSPron]]).wPronunciation))
                  break;
            }

            if (iLTSPron == WI.cInfoBlocks || iLTSPron > MAXLTSPRONMATCHED)
               iLTSPron = (DWORD)-1;
         }
         else
         {
            iLTSPron = (DWORD)-1;
         }

         // Store a control block
         DWORD cb = 0;

         _ASSERTE ((8 *sizeof (cb)) > MAXTOTALCBSIZE);

         // Save the first bit position of cb in pBlock so that
         // we can set it to 1 in case this is the last pron
         iCBBitToSet = nBlockUseBits + CBSIZE - 1;

         ZeroMemory (&cb, sizeof (cb));

         if ((DWORD)-1 != iLTSPron)
         {
            cb = I_LKUPLTSPRON;
            AddToBlock (&cb, CBSIZE);

            cb = iLTSPron;
            AddToBlock (&cb, LTSINDEXSIZE);
         }
         else
         {
            cb = I_LKUPLKUPPRON;
            AddToBlock (&cb, CBSIZE);

            /*
            if (wcslen (wPron) < pow (2, LKUPLENSIZE))
               cb = wcslen (wPron);
            else
            {
               _ASSERTE (0);
               cb = (WORD)(pow (2, LKUPLENSIZE) - 1);
            }

            AddToBlock (&cb, LKUPLENSIZE);
            */

            // Encode the pronunciation
            DWORD d = wcslen (wPron);

            for (DWORD i = 0; i <= d; i++) 
            { 
               // Encode the terminated NULL too
               if (FAILED(PronsEncoder->Encode (wPron[i])))
               {
                  _ASSERTE (0);
                  continue;
               }
            }

            DWORD nBits = 0;
            DWORD bBuffer[MAX_PRON_LEN * 3];
         
            ZeroMemory (bBuffer, sizeof (bBuffer));
            PronsEncoder->Flush (bBuffer, (int*)&nBits);
            _ASSERTE (nBits);

#ifdef _DEBUG
            DWORD dSave = nBlockUseBits;
#endif
            AddToBlock (bBuffer, nBits);
            _ASSERTE (nBlockUseBits ==  dSave + nBits);
         }
      }
      else if (sz == strstr (sz, "POS"))
      {
         PART_OF_SPEECH pos = (PART_OF_SPEECH)atoi (p);

         if (pos < NOUN || pos > DEL)
         {
            // unsupported pos
            continue;
         }

         // Store a control block
         DWORD cb = 0;

         _ASSERTE ((8 *sizeof (cb)) > MAXTOTALCBSIZE);

         // Save the first bit position of cb in pBlock so that
         // we can set it to 1 in case this is the last pron
         iCBBitToSet = nBlockUseBits + CBSIZE - 1;

         ZeroMemory (&cb, sizeof (cb));

         cb = I_POS;
         AddToBlock (&cb, CBSIZE);

         if (FAILED(PosEncoder->Encode ((HUFFKEY)pos)))
         {
            _ASSERTE (0);
            continue;
         }

         DWORD nBits = 0;
         DWORD bBuffer[MAX_PRON_LEN];

         ZeroMemory (bBuffer, sizeof (bBuffer));
         PosEncoder->Flush (bBuffer, (int*)&nBits);
         _ASSERTE (nBits);

#ifdef _DEBUG
         DWORD dSave = nBlockUseBits;
#endif
         AddToBlock (bBuffer, nBits);
         _ASSERTE (nBlockUseBits ==  dSave + nBits);
      }
   } // while (fgets (sz, MAX_PRON_LEN * 5, fp))

   fclose(fp);

   // For the last word
   if (iCBBitToSet)
      SetBitInDWORD (pBlock, iCBBitToSet);

   // Convert the hash table to its shortest bit length form

   double fnBits = log (nBlockUseBits) / log (2);
   nBitsPerHash = (int)fnBits;

   if (fnBits > (double)((int)(fnBits)))
      nBitsPerHash += 1;
   
   nCmpHashBytes = (((nBitsPerHash * nHashLen) + 0x7) & (~0x7)) / 8;

   pCmpHash = (PBYTE) calloc (1, nCmpHashBytes);
   if (!pCmpHash)
   {
      _ASSERTE (0);
      return E_OUTOFMEMORY;
   }

   for (DWORD i = 0; i < nHashLen; i++)
   {
      for (DWORD j = 0; j < nBitsPerHash; j++)
      {
         if (pHash [i] & (1 <<( nBitsPerHash - j - 1)))
            SetBit (pCmpHash, i * nBitsPerHash + j);
      }
   }

   // pad atleast MAXELEMENTSIZE at the end so that we dont't have to worry about
   // overshooting the end of block while decoding because of variable-length codes
   nBlockUseDWORDs += ((MAXELEMENTSIZE + 32) >> 5);

   CoTaskMemFree(WI.pInfo);
   CoTaskMemFree(IB.pwIndex);

   return NOERROR;

} // int EncodeWordsProns (void)


HRESULT WriteLookupLexFile (void)
{
   FILE *fp = fopen (szLookupLexFile, "wb");
   FILE *fpwcb = fopen (WordCBFile, "rb");
   FILE *fppcb = fopen (PronCBFile, "rb");
   FILE *fpposcb = fopen (PosCBFile, "rb");

   if (!fp || !fpwcb || !fppcb || !fpposcb)
   {
      _ASSERTE (0);
      return E_FAIL;
   }

   fseek (fpwcb, 0, SEEK_END);
   fseek (fppcb, 0, SEEK_END);
   fseek (fpposcb, 0, SEEK_END);

   // Build LKUPLEXINFO

   LKUPLEXINFO lkupLexInfo;

   lkupLexInfo.gLexiconID = gLexGuid;

   lkupLexInfo.RWLockInfo.gLockMapName = GUID_RWLOCK_MAPNAME;
   lkupLexInfo.RWLockInfo.gLockInitMutexName = GUID_RWLOCK_INITMUTEXNAME;
   lkupLexInfo.RWLockInfo.gLockReaderEventName = GUID_RWLOCK_READEREVENTNAME;
   lkupLexInfo.RWLockInfo.gLockGlobalMutexName = GUID_RWLOCK_GLOBALMUTEXNAME;
   lkupLexInfo.RWLockInfo.gLockWriterMutexName = GUID_RWLOCK_WRITERMUTEXNAME;

   lkupLexInfo.gDictMapName = GUID_RWLEX_MAPNAME;

   lkupLexInfo.Lcid = Lcid;
   lkupLexInfo.nNumberWords = nLkupWords;
   lkupLexInfo.nNumberProns = nLkupProns;
   lkupLexInfo.nLengthHashTable = nHashLen;
   lkupLexInfo.nLengthCmpBlockBits = nBlockUseBits;
   lkupLexInfo.nWordCBSize = ftell (fpwcb);
   lkupLexInfo.nPronCBSize = ftell (fppcb);
   lkupLexInfo.nPosCBSize = ftell (fpposcb);
   lkupLexInfo.nBitsPerHashEntry = nBitsPerHash;

   // Write the header
   fwrite (&lkupLexInfo, sizeof (LKUPLEXINFO), 1, fp);

   // Write the Words Codebook
   DWORD dwCBSize;

   if (lkupLexInfo.nWordCBSize > lkupLexInfo.nPronCBSize)
   {
      dwCBSize = lkupLexInfo.nWordCBSize;
   }
   else
   {
      dwCBSize = lkupLexInfo.nPronCBSize;
   }

   if (dwCBSize < lkupLexInfo.nPosCBSize)
   {
      dwCBSize = lkupLexInfo.nPosCBSize;
   }

   PBYTE pCB = (PBYTE) malloc (dwCBSize);
   if (!pCB)
   {
      _ASSERTE (0);
      return E_OUTOFMEMORY;
   }

   // Write the words codebook
   fseek (fpwcb, 0, SEEK_SET);
   fread (pCB, 1, lkupLexInfo.nWordCBSize, fpwcb);
   fwrite (pCB, 1, lkupLexInfo.nWordCBSize, fp);

   // Write the prons codebook
   fseek (fppcb, 0, SEEK_SET);
   fread (pCB, 1, lkupLexInfo.nPronCBSize, fppcb);
   fwrite (pCB, 1, lkupLexInfo.nPronCBSize, fp);

   // Write the pos codebook
   fseek (fpposcb, 0, SEEK_SET);
   fread (pCB, 1, lkupLexInfo.nPosCBSize, fpposcb);
   fwrite (pCB, 1, lkupLexInfo.nPosCBSize, fp);

   // Write the hash table
   fwrite (pCmpHash, 1, nCmpHashBytes, fp);

   // Write the words + CBs + prons + Poss block
   fwrite (pBlock, sizeof (DWORD), nBlockUseDWORDs, fp);

   free (pCB);

   lkupLexInfo.nLTSFileOffset = (DWORD)-1;
   lkupLexInfo.nLTSFileSize = 0;

   // Append the Lts file to the lookup file
   //fwrite (pLtsData, 1, nLtsSize, fp);
   
#ifdef _DEBUG
   int nLkupSize = ftell (fp);
#endif

   // Go back to the start of the file and write the lexheader again
   fseek (fp, 0, SEEK_SET);
   fwrite (&lkupLexInfo, sizeof (LKUPLEXINFO), 1, fp);

   fclose (fpwcb);
   fclose (fppcb);
   fclose (fpposcb);
   fclose (fp);

#ifdef _DEBUG

   char szMessage[256];

   sprintf (szMessage, "\n******** Lookup Lexicon Stats ********\n");
   OutputDebugString (szMessage);
   sprintf (szMessage, "Total number of words = %d\n", nTotalWords);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Total number of prons = %d\n", nTotalProns);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Total number of prons in LTS = %d\n", nTotalPronsinLTS);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Number of words whose all prons exist in LTS = %d\n", nWordsOnlyLTSProns);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Number of words written to the lookup file = %d\n", nLkupWords);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Number of prons (including LTS prons) written to the lookup file = %d\n", nLkupProns);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Number of LTS prons written to the lookup file = %d\n", nLkupLTSProns);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Number of POSs written to the lookup file = %d\n", nLkupPOSs);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Size of block the compressed block in DWORDs = %d\n", nBlockUseDWORDs);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Size of Hash table = %d\n", (nHashLen * nBitsPerHash)/8);
   OutputDebugString (szMessage);
   //sprintf (szMessage, "Size of the Lts data = %d\n", nLtsSize);
   //OutputDebugString (szMessage);
   sprintf (szMessage, "Total Size of the Lkup file = %d\n", nLkupSize);
   OutputDebugString (szMessage);
   sprintf (szMessage, "**************************************\n\n");
   OutputDebugString (szMessage);

#endif

   return NOERROR;

} // HRESULT WriteLookupLexFile (void)


// Reads the text lookup lexicon file and creates the binary lookup lexicon file
HRESULT EncodeBackup (void)
{
   HRESULT hRes = NOERROR;

   if (TRUE == fUseLtsToCode)
   {
      strcpy (szTextLexFileIn, szTempPath);
      strcat (szTextLexFileIn, "LookupTextFile");
      strcat (szTextLexFileIn, ".in");

      hRes = ScrubLexForLTS ();
      
      _ASSERTE (SUCCEEDED (hRes));
      if (FAILED (hRes))
         return hRes;
   }
   else
   {
      strcpy (szTextLexFileIn, szLookupTextFile);
      CountWordsProns ();
   }

   if (nLkupWords)
   {
      hRes = ConstructWordsPronsCode ();

      _ASSERTE (SUCCEEDED (hRes));
      if (FAILED (hRes))
         return hRes;
      
      hRes = EncodeWordsProns ();

      _ASSERTE (SUCCEEDED (hRes));
      if (FAILED (hRes))
         return hRes;
   }

   hRes = WriteLookupLexFile ();

   _ASSERTE (SUCCEEDED (hRes));

   return hRes;
} // HRESULT EncodeBackup (void)


#ifdef _DEBUG

// Reads the binary lookup lexicon file and creates the text lookup lexicon file
// and compares it to the supplied text lookup lexicon file
HRESULT DecodeBackup (void)
{
   HRESULT hRes = NOERROR;
   
   FILE *fp = NULL;
   FILE *fpout = NULL;
   CLookup *pLookup = NULL;

   WORD_INFO_BUFFER WI;
   INDEXES_BUFFER IB;

   ZeroMemory(&WI, sizeof(WI));
   ZeroMemory(&IB, sizeof(IB));

   pLookup = new CLookup(NULL);
   if (!pLookup)
   {
      goto DecodeBackupReturn;
   }

   WCHAR wszLookupLexFile[MAX_PATH];

   MultiByteToWideChar (CP_ACP, MB_COMPOSITE, szLookupLexFile, -1, wszLookupLexFile, MAX_PATH);

   hRes = pLookup->Init(wszLookupLexFile, wszLtsLexFile);
   if (FAILED(hRes))
   {
      goto DecodeBackupReturn;
   }

   fp = fopen (szTextLexFileIn, "r");
   if (!fp)
   {
      _ASSERTE (0);
      hRes = E_FAIL;
      goto DecodeBackupReturn;
   }

   strcpy (szTextLexFileOut, szTempPath);
   strcat (szTextLexFileOut, "LookupTextFile");
   strcat (szTextLexFileOut, ".out");

   fpout = fopen (szTextLexFileOut, "w");
   if (!fpout)
   {
      _ASSERTE (0);
      hRes = E_FAIL;
      goto DecodeBackupReturn;
   }

   // Walk the input lookup text file picking off words and 
   // getting their information from the binary lookup lexicon
  
   char sz[1024];
   while (fgets (sz, 1024, fp))
   {
      PSTR pWord;
      pWord = strchr (sz, ' ');
      *pWord++ = 0;

      if (strcmp (sz, "Word"))
         continue;

      fprintf (fpout, "Word %s", pWord);

      // Get the word's information from the binary lexicon

      if (pWord[strlen (pWord) - 1] == '\n')
         pWord[strlen (pWord) - 1] = 0;

      WCHAR wsz[MAX_STRING_LEN];

      MultiByteToWideChar (CP_ACP, MB_COMPOSITE, pWord, -1, wsz, MAX_STRING_LEN);

      // Get the information of the word
      hRes = pLookup->GetWordInformation(wsz, Lcid, PRON|POS, LEXTYPE_VENDOR, &WI, &IB, NULL, NULL);
      //hRes = pLookup->GetWordInformation(wsz, Lcid, PRON|POS, LEXTYPE_VENDOR, (PLEX_WORD_INFO)Info, 
      //                                   wInfoIndex, MAX_INFO_RETURNED_SIZE, MAX_INDEX_RETURNED_SIZE,
      //                                   &dwInfoBytesNeeded, &dwIndexBytesNeeded, &dwNumInfoBlocks, NULL, NULL);
      if (FAILED (hRes))
      {
         _ASSERTE (0);
         goto DecodeBackupReturn;
      }

      DWORD iPron, iPOS;
      iPron = 0;
      iPOS = 0;

      // Convert the pronunciations to text form
      for (DWORD i = 0; i < WI.cInfoBlocks; i++)
      {
         switch ((((LEX_WORD_INFO*)(WI.pInfo))[IB.pwIndex[i]]).Type)
         {
         case PRON:
            {
               char szPron[MAX_PRON_LEN * 10];

               itoah ((((LEX_WORD_INFO*)(WI.pInfo))[IB.pwIndex[i]]).wPronunciation, szPron);
               
               fprintf (fpout, "Pronunciation%d %s\n", iPron++, szPron);

               // reset the iPOS
               iPOS = 0;

               break;
            }

         case POS:
            {
               fprintf (fpout, "POS%d %d\n", iPOS++, (((LEX_WORD_INFO*)(WI.pInfo))[IB.pwIndex[i]]).POS);
               break;
            }
         } // switch (p[wInfoIndex[i]].Type)
      } // for (DWORD i = 0; i < nInfo; i++)
   } // while (fgets (sz, 1024, fp))

DecodeBackupReturn:

   CoTaskMemFree(WI.pInfo);
   CoTaskMemFree(IB.pwIndex);

   if (pLookup)
   {
      delete pLookup;
   }

   fclose (fp);
   fclose (fpout);

   return hRes;

} // HRESULT DecodeBackup (void)


#if 0
HRESULT TestLts (void)
{
   HRESULT hRes = NOERROR;

   FILE *fp = fopen (szTextLexFileIn, "r");
   if (!fp)
   {
      return E_FAIL;
   }

   PLEXICON pLexicon;

   WCHAR wszLookupLexFile[MAX_PATH * 3];

   MultiByteToWideChar (CP_ACP, MB_COMPOSITE, szLookupLexFile, -1, wszLookupLexFile, MAX_PATH * 3);

   if (FAILED(hRes = GetLexiconObject (&pLexicon, wszLookupLexFile, Lcid)))
   {
      goto TestLtsReturn;
   }

   char sz[1024];
   WCHAR wProns [2048];

   while (fgets (sz, 1024, fp))
   {
      PSTR pWord = strchr (sz, ' ');
      *pWord++ = 0;

      if (strcmp (sz, "Word"))
         continue;

      if (pWord[strlen (pWord) - 1] == '\n')
         pWord[strlen (pWord) - 1] = 0;

      strcat (pWord, "ers");
    
      WCHAR wsz[MAX_STRING_LEN];

      MultiByteToWideChar (CP_ACP, MB_COMPOSITE, pWord, -1, wsz, MAX_STRING_LEN);

      DWORD dReq;
      DWORD nProns;
      WORD wPronIndex[MAX_NUM_LEXINFO];

      // Get the Lts pronunciations of the word
      hRes = pLexicon->GetWordPronunciations (wsz, wProns, wPronIndex, sizeof (wProns), &dReq, &nProns, LEXTYPE_USER|LEXTYPE_VENDOR|LEXTYPE_GUESS);
      _ASSERTE (SUCCEEDED(hRes));
      if (FAILED(hRes))
      {
         goto TestLtsReturn;
      }

      if (FAILED (hRes = pLexicon->IPAToEnginePhone (wProns, sz)))
      {
         goto TestLtsReturn;
      }

      if (FAILED (hRes = pLexicon->EnginePhoneToIPA (sz, wProns)))
      {
         goto TestLtsReturn;
      }
   }

TestLtsReturn:

   fclose (fp);

   if (FAILED(hRes))
   {
      _ASSERTE (0);
   }

   return hRes;

} // HRESULT TestLts (void)

#endif

#endif


HRESULT BuildLookup (LCID lid, GUID LexGuid, const WCHAR * pwLookupTextFile, const WCHAR * pwLookupLexFile, 
                     const WCHAR *pwLtsLexFile, BOOL fUseLtsCode, BOOL fSupIsRealWord)
{  
   HRESULT hRes = NOERROR;

   if (IsBadReadPtr (pwLookupTextFile, sizeof (WCHAR) * 2) ||
       IsBadReadPtr (pwLookupLexFile, sizeof (WCHAR) * 2) ||
       IsBadReadPtr (pwLtsLexFile, sizeof (WCHAR) * 2))
      return E_INVALIDARG;

   HANDLE hMutex = CreateMutex (NULL, FALSE, pMutexName);
   if (!hMutex)
      return E_FAIL;

   WaitForSingleObject (hMutex, INFINITE);

   WideCharToMultiByte (CP_ACP, 0, pwLookupTextFile, -1, szLookupTextFile, MAX_PATH, NULL, NULL);
   WideCharToMultiByte (CP_ACP, 0, pwLookupLexFile, -1, szLookupLexFile, MAX_PATH, NULL, NULL);

   wcscpy(wszLtsLexFile, pwLtsLexFile);

   GetTempPath (2*MAX_PATH, szTempPath);
   if (szTempPath[strlen (szTempPath) - 1] != '\\')
      strcat (szTempPath, "\\");

   Lcid = lid;
   gLexGuid = LexGuid;
   fSupportIsRealWord = fSupIsRealWord;
   fUseLtsToCode = fUseLtsCode;

   FILE *fpLookupTextFile = fopen (szLookupTextFile, "r");
   if (!fpLookupTextFile)
   {
      hRes = E_FAIL;
      goto ReturnBuildLookupLts;
   }

   fclose (fpLookupTextFile);
   fpLookupTextFile = NULL;

   FILE *fpLookupLexFile;
   fpLookupLexFile = fopen (szLookupLexFile, "wb");
   if (!fpLookupLexFile)
   {
      hRes = E_FAIL;
      goto ReturnBuildLookupLts;
   }

   fclose (fpLookupLexFile);
   fpLookupLexFile = NULL;

   WordsEncoder = new CHuffEncoder;
   if (!WordsEncoder)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLookupLts;
   }

   PronsEncoder = new CHuffEncoder;
   if (!PronsEncoder)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLookupLts;
   }

   PosEncoder = new CHuffEncoder;
   if (!PosEncoder)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLookupLts;
   }

   //pLtsData = pLtsDat;
   //nLtsSize = nLtsDat;

   pLts = new CLTS(NULL);
   if (!pLts)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLookupLts;
   }

   pLts->SetBuildMode (true);

   if (FAILED(hRes = pLts->Init (pwLtsLexFile, NULL)))
   {
      goto ReturnBuildLookupLts;
   }

   strcpy (WordCBFile, szTempPath);
   strcat (WordCBFile, "WordCB.lex");

   strcpy (PronCBFile, szTempPath);
   strcat (PronCBFile, "PronCB.lex");

   strcpy (PosCBFile, szTempPath);
   strcat (PosCBFile, "PosCB.lex");

   hRes = EncodeBackup ();
   if (FAILED (hRes))
   {
      goto ReturnBuildLookupLts;
   }

#ifdef _DEBUG

   hRes = DecodeBackup ();
   if (FAILED (hRes))
   {
      goto ReturnBuildLookupLts;
   }

   _ASSERTE (_CrtCheckMemory());

#if 0
   hRes = TestLts ();
   if (FAILED (hRes))
   {
      goto ReturnBuildLookupLts;
   }
#endif
#endif

ReturnBuildLookupLts:

   free (pBlock);
   free (pHash);
   free (pCmpHash);

   delete pLts;
   delete WordsEncoder;
   delete PronsEncoder;
   delete PosEncoder;

   ReleaseMutex (hMutex);
   CloseHandle (hMutex);

   _ASSERTE (_CrtCheckMemory());

   _CrtDumpMemoryLeaks();

   return hRes;

} // STDMETHODIMP BuildLookup ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\cf.cpp ===
/*****************************************************************************
*  CF.cpp
*     Implements the class factory, manager object and the standard COM exports
*
*  Owner: YunusM
*
*  Copyright 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#include "PreCompiled.h"

//---- Globals ---------------------------------------------------------------

static LONG gcCFObjectCount = 0;       // number of CF objects existing
static LONG gcObjectCount = 0;         // number of objects existing
static LONG gcLockCount = 0;           // number of times that this is locked


/*****************************************************************************
* ObjectDestroyed *
*-----------------*
*  Decrements the object count - One object per manager object which in turn
*  contains all other objects
**********************************************************************YUNUSM*/
void ObjectDestroyed(void)
{
   InterlockedDecrement(&gcObjectCount);
}


//---- Class Factories Implementation ----------------------------------------

//---- API Class Factory -----------------------------------------------------

/*****************************************************************************
* CAPIClassFactory *
*----------------*
*  Constructor
**********************************************************************YUNUSM*/
CAPIClassFactory::CAPIClassFactory(void)
{
   m_cRef = 0L;
   return;
}


/*****************************************************************************
* ~CAPIClassFactory *
*----------------*
*  Destructor
**********************************************************************YUNUSM*/
CAPIClassFactory::~CAPIClassFactory(void)
{
   return;
}


/*****************************************************************************
* QueryInterface *
*----------------*
*  Gets an interface pointer
*
*  Return: E_NOINTERFACE, NOERROR
**********************************************************************YUNUSM*/
STDMETHODIMP CAPIClassFactory::QueryInterface(
                                           REFIID riid,        // IID of the interface              
                                           LPVOID FAR * ppv    // pointer to the interface returned 
                                           )
{
   *ppv = NULL;

   // Any interface on this object is the object pointer
   if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
   {
      *ppv = (LPVOID) this;
   }

   // If we assign an interface then addref
   if (NULL != *ppv)
   {
      ((LPUNKNOWN)*ppv)->AddRef();
      return NOERROR;
   }

   return E_NOINTERFACE;
} // STDMETHODIMP CAPIClassFactory::QueryInterface(REFIID riid, LPVOID FAR * ppv)


/*****************************************************************************
* AddRef *
*--------*
*  Increments the ref count
*
*  Return: new ref count
**********************************************************************YUNUSM*/
STDMETHODIMP_ (ULONG) CAPIClassFactory::AddRef(void)
{
   return ++m_cRef;
} // STDMETHODIMP_ (ULONG) CAPIClassFactory::AddRef(void)


/*****************************************************************************
* Release *
*---------*
*  Decrements the ref count
*
*  Return: new ref count
**********************************************************************YUNUSM*/
STDMETHODIMP_ (ULONG) CAPIClassFactory::Release(void)
{
   ULONG cRefT;

   cRefT = --m_cRef;

   if (0L == m_cRef) 
   {
      delete this;
      InterlockedDecrement(&gcCFObjectCount);
   }

   return cRefT;
} // STDMETHODIMP_ (ULONG) CAPIClassFactory::Release(void)


/*****************************************************************************
* CreateInstance *
*----------------*
*  Creates a LexAPI Object
*
*  Return: CLASS_E_NOAGGREGATION, E_NOINTERFACE, E_FAIL, NOERROR
**********************************************************************YUNUSM*/
STDMETHODIMP CAPIClassFactory::CreateInstance(
                                           LPUNKNOWN punkOuter,   // outer unknown
                                           REFIID riid,           // IID 
                                           LPVOID * ppvObj        // LexAPI object
                                           )
{
   HRESULT hr = S_OK;

   *ppvObj = NULL;

   if (NULL != punkOuter)
   {
      return ResultFromScode(CLASS_E_NOAGGREGATION);
   }

   CAPIManager *pMgr = new CAPIManager(punkOuter, ObjectDestroyed);

   if (NULL == pMgr)
   {
      hr = E_OUTOFMEMORY;
      goto ReturnCAPIClassFactory;
   }

   hr = pMgr->Init();

   if (SUCCEEDED(hr))
   {
      hr = pMgr->QueryInterface(riid, ppvObj);
   }
   

ReturnCAPIClassFactory:

   if (FAILED(hr))
   {
      if (pMgr)
      {
         delete pMgr;
         pMgr = NULL;
      }
   }
   else
   {
      InterlockedIncrement(&gcObjectCount);
   }

   return hr;

} // STDMETHODIMP CAPIClassFactory::CreateInstance()


/*****************************************************************************
* LockServer *
*------------*
*  Locks/Unlocks the Server
*
*  Return: E_FAIL, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CAPIClassFactory::LockServer(
                                          BOOL fLock // if TRUE lock the server, elxe unlock
                                          )
{
   if (fLock)
   {
      InterlockedIncrement(&gcLockCount);
   }
   else
   {
      if (gcLockCount > (-1))
      {
         InterlockedDecrement(&gcLockCount);
      }
      else
      {
        return E_FAIL;
      }
   }

   return S_OK;

} // STDMETHODIMP CAPIClassFactory::LockServer(BOOL fLock)


//---- SR Vendor lexicon Factory ---------------------------------------------

/*****************************************************************************
* CVendorClassFactory *
*---------------------*
*  Constructor
**********************************************************************YUNUSM*/
CVendorClassFactory::CVendorClassFactory(
                                         CLSID Clsid
                                         )
{
   m_cRef = 0L;
   m_Clsid = Clsid;

   return;
}


/*****************************************************************************
* ~CVendorClassFactory *
*----------------------*
*  Destructor
**********************************************************************YUNUSM*/
CVendorClassFactory::~CVendorClassFactory(void)
{
   return;
}


/*****************************************************************************
* QueryInterface *
*----------------*
*  Gets an interface pointer
*
*  Return: E_NOINTERFACE, NOERROR
**********************************************************************YUNUSM*/
STDMETHODIMP CVendorClassFactory::QueryInterface(
                                                   REFIID riid,      // IID of the interface             
                                                   LPVOID FAR * ppv  // pointer to the interface returned
                                                   )
{
   *ppv = NULL;

   // Any interface on this object is the object pointer
   if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
   {
      *ppv = (LPVOID) this;
   }

   // If we assign an interface then addref
   if (NULL != *ppv)
   {
      ((LPUNKNOWN)*ppv)->AddRef();
      return NOERROR;
   }

   return E_NOINTERFACE;
}


/*****************************************************************************
* AddRef *
*--------*
*  Increments the ref count
*
*  Return: new ref count
**********************************************************************YUNUSM*/
STDMETHODIMP_ (ULONG) CVendorClassFactory::AddRef(void)
{
   return ++m_cRef;
}


/*****************************************************************************
* Release *
*---------*
*  Decrements the ref count
*
*  Return: new ref count
**********************************************************************YUNUSM*/
STDMETHODIMP_ (ULONG) CVendorClassFactory::Release(void)
{
   ULONG cRefT;

   cRefT = --m_cRef;

   if (0L == m_cRef) 
   {
      delete this;
      InterlockedDecrement(&gcCFObjectCount);
   }

   return cRefT;
}


/*****************************************************************************
* CreateInstance *
*----------------*
*  Creates a LexAPI Object
*
*  Return: CLASS_E_NOAGGREGATION, E_NOINTERFACE, E_FAIL, NOERROR
**********************************************************************YUNUSM*/
STDMETHODIMP CVendorClassFactory::CreateInstance(
                                                   LPUNKNOWN punkOuter, // outer unknown 
                                                   REFIID riid,         // IID          
                                                   LPVOID * ppvObj      // LexAPI object
                                                   )
{
   HRESULT hr = S_OK;

   *ppvObj = NULL;

   if (NULL != punkOuter)
   {
      return ResultFromScode(CLASS_E_NOAGGREGATION);
   }

   CVendorManager *pMgr = new CVendorManager(punkOuter, ObjectDestroyed, m_Clsid);

   if (NULL == pMgr)
   {
      hr = E_OUTOFMEMORY;
      goto ReturnCVendorClassFactory;
   }

   hr = pMgr->Init();

   if (SUCCEEDED(hr))
   {
      hr = pMgr->QueryInterface(riid, ppvObj);
   }
   

ReturnCVendorClassFactory:

   if (FAILED(hr))
   {
      if (pMgr)
      {
         delete pMgr;
         pMgr = NULL;
      }
   }
   else
   {
      InterlockedIncrement(&gcObjectCount);
   }

   return hr;

} // STDMETHODIMP CVendorClassFactory::CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID * ppvObj)


/*****************************************************************************
* LockServer *
*------------*
*  Locks/Unlocks the Server
*
*  Return: E_FAIL, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CVendorClassFactory::LockServer(
                                               BOOL fLock // if TRUE lock the server, elxe unlock
                                               )
{
   if (fLock)
   {
      InterlockedIncrement(&gcLockCount);
   }
   else
   {
      if (gcLockCount > (-1))
      {
         InterlockedDecrement(&gcLockCount);
      }
      else
      {
        return E_FAIL;
      }
   }

   return S_OK;

} // STDMETHODIMP CSREnumClassFactory::LockServer(BOOL fLock)


/*****************************************************************************
* DllMain *
*---------*
*  Entry point for the Dll
*
*  Return: TRUE
**********************************************************************YUNUSM*/
BOOL WINAPI DllMain(
                    HINSTANCE hInst, // handle to DLL module
                    DWORD fdwReason, // reason for calling function
                    LPVOID           // reserved
                    )
{
   switch(fdwReason) 
   {
      case DLL_PROCESS_ATTACH:
         DisableThreadLibraryCalls(hInst);
#ifdef _DEBUG
         {
         int nTmpFlag;

         nTmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
         nTmpFlag |= _CRTDBG_CHECK_ALWAYS_DF;
         _CrtSetDbgFlag(nTmpFlag);
         }
#endif
         break;

      case DLL_PROCESS_DETACH:
         break;
   }

   return TRUE;

} // BOOL WINAPI DllMain(HINSTANCE hInst, DWORD fdwReason, LPVOID lpvXX)


/*****************************************************************************
* DllGetClassObject *
*-------------------*
*  This is the external entry point for the OLE DLL,
*  It follows standard OLE interface.
*
*  Return: E_FAIL, E_NOINTERFACE, E_OUTOFMEMORY, S_OK
**********************************************************************YUNUSM*/
STDAPI DllGetClassObject(
                         REFCLSID rclsid,    // CLSID
                         REFIID riid,        // IID
                         LPVOID FAR * ppv    // interface pointer returned
                         )
{
	if (!IsEqualCLSID (rclsid, CLSID_Lexicon) &&
       !IsEqualCLSID (rclsid, CLSID_MSSR1033Lexicon) &&
       !IsEqualCLSID (rclsid, CLSID_MSTTS1033Lexicon) &&
       !IsEqualCLSID (rclsid, CLSID_MSSR1041Lexicon) &&
       !IsEqualCLSID (rclsid, CLSID_MSTTS1041Lexicon) &&
       !IsEqualCLSID (rclsid, CLSID_MSSR2052Lexicon) &&
       !IsEqualCLSID (rclsid, CLSID_MSTTS2052Lexicon) &&
       !IsEqualCLSID (rclsid, CLSID_MSLTS1033Lexicon) &&
       !IsEqualCLSID (rclsid, CLSID_MSLTS2052Lexicon) &&
       !IsEqualCLSID (rclsid, CLSID_MSLTS1041Lexicon))
   {
		return E_FAIL;
   }

   // check that we can provide the interface

   if (!IsEqualIID (riid, IID_IUnknown) &&
	    !IsEqualIID (riid, IID_IClassFactory))
   {
      return E_NOINTERFACE;
   }

   // return our IClassFactory for the object
   if (IsEqualCLSID (rclsid, CLSID_Lexicon))
   {
      *ppv = (LPVOID) new CAPIClassFactory();
      if (NULL == *ppv) 
      {
         return E_OUTOFMEMORY;
      }
   }
   else 
   {
      // CLSID_MSGenLexicon
      *ppv = (LPVOID) new CVendorClassFactory(rclsid);
      if (NULL == *ppv) 
      {
         return E_OUTOFMEMORY;
      }
   }

   InterlockedIncrement(&gcCFObjectCount);

   // addref the object through any interfaces we return

   ((LPUNKNOWN) *ppv)->AddRef();

   return S_OK;

} // HRESULT STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR * ppv)


/*****************************************************************************
* DllCanUnloadNow *
*-----------------*
*  This is the external entry point for the OLE DLL,
*  It follows standard OLE interface.
*
*  Return: S_OK S_FALSE
**********************************************************************YUNUSM*/
STDAPI DllCanUnloadNow(void)
{
   HRESULT hr = S_FALSE;

   if (gcObjectCount == 0 && gcCFObjectCount == 0 && gcLockCount == 0)
   {
      hr = S_OK;
   }

   return hr;

} // STDAPI DllCanUnloadNow(void)


/*****************************************************************************
* DllRegisterServer *
*-------------------*
*  This is the external entry point for the OLE DLL,
*  It follows standard OLE interface.
*
*  Return: S_OK E_FAIL
**********************************************************************YUNUSM*/
STDAPI DllRegisterServer(void)
{
   HRESULT hr = S_OK;
   LONG lRet;
   HKEY hKey = NULL;
   DWORD dwDisposition;
   LPOLESTR pwszCLSID = NULL;

   // Create the vendor subkey
   lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Lexicon\\Vendor", 0, 
                         NULL, 0, 0, NULL, &hKey, &dwDisposition);
   RegCloseKey(hKey);

   if (ERROR_SUCCESS != lRet && REG_OPENED_EXISTING_KEY != dwDisposition)
   {
      hr = E_FAIL;
      goto ReturnDllRegisterServer;
   }

   // Create the user subkey
   lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Lexicon\\User", 0, 
                         NULL, 0, 0, NULL, &hKey, &dwDisposition);
   RegCloseKey(hKey);

   if (ERROR_SUCCESS != lRet && REG_OPENED_EXISTING_KEY != dwDisposition)
   {
      hr = E_FAIL;
      goto ReturnDllRegisterServer;
   }

   // Open the vendor subkey
   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Lexicon\\Vendor", 0,
                       KEY_ALL_ACCESS, &hKey);
   if (ERROR_SUCCESS != lRet)
   {
      hr = E_FAIL;
      goto ReturnDllRegisterServer;
   }

   hr = StringFromCLSID(CLSID_MSSR1033Lexicon, &pwszCLSID);
   if (FAILED(hr))
   {
      goto ReturnDllRegisterServer;
   }

   char szCLSID[256];

   WideCharToMultiByte (CP_ACP, 0, pwszCLSID, -1, szCLSID, 256, NULL, NULL);

   VENDOR_CLSID_LCID_HDR Hdr;

   Hdr.CLSID = CLSID_MSSR1033Lexicon;
   Hdr.cLcids = 1;
   Hdr.aLcidsSupported[0] = 1033;

   // Create the name-value pair for MS generic lexicon under Vendor subkey
   lRet = RegSetValueEx(hKey, "Microsoft.SREnglishLexicon.5", 0, REG_BINARY, (PBYTE)&Hdr, sizeof(Hdr));
   if (ERROR_SUCCESS != lRet)
   {
      hr = E_FAIL;
      goto ReturnDllRegisterServer;
   }

   Hdr.CLSID = CLSID_MSTTS1033Lexicon;
   Hdr.cLcids = 1;
   Hdr.aLcidsSupported[0] = 1033;

   // Create the name-value pair for MS generic lexicon under Vendor subkey
   lRet = RegSetValueEx(hKey, "Microsoft.TTSEnglishLexicon.5", 0, REG_BINARY, (PBYTE)&Hdr, sizeof(Hdr));
   if (ERROR_SUCCESS != lRet)
   {
      hr = E_FAIL;
      goto ReturnDllRegisterServer;
   }

   Hdr.CLSID = CLSID_MSLTS1033Lexicon;
   Hdr.cLcids = 1;
   Hdr.aLcidsSupported[0] = 1033;

   // Create the name-value pair for MS generic lexicon under Vendor subkey
   lRet = RegSetValueEx(hKey, "Microsoft.LTSEnglishLexicon.5", 0, REG_BINARY, (PBYTE)&Hdr, sizeof(Hdr));
   if (ERROR_SUCCESS != lRet)
   {
      hr = E_FAIL;
      goto ReturnDllRegisterServer;
   }

   RegCloseKey(hKey);

   // Add this vendor lexicon under all the users

   // BUGBUG: Postponed. For now when a user is set it will use all the vendor lexicons registered subject
   // to authentication.

   /*
   // Open the user subkey
   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Lexicon\\User\\", 0, KEY_ALL_ACCESS, &hKey);
   if (ERROR_SUCCESS != lRet)
   {
      hr = E_FAIL;
      goto ReturnDllRegisterServer;
   }

   DWORD dwIndex;
   dwIndex = 0;
   char szUserName[MAX_PATH*2];
   DWORD cbName;
   FILETIME ft;

   // Enumerate users and for each user add the key-value pair for the vendor lexicon under the particular
   // user's subkey
   while (ERROR_SUCCESS == (lRet = RegEnumKeyEx(hKey, dwIndex++, szUserName, &cbName, NULL, NULL, NULL, &ft)))
   {
      // Add this vendor lexicon under this user - If its already there it will be overwritten
      lRet = RegSetValueEx(hKey, "Microsoft.EnglishGenericLexicon.5", 0, REG_BINARY, (PBYTE)&Hdr, sizeof(Hdr));
      if (ERROR_SUCCESS != lRet)
      {
         hr = E_FAIL;
         goto ReturnDllRegisterServer;
      }
   }

   if (ERROR_NO_MORE_ITEMS != lRet)
      hr = E_FAIL;
   */

ReturnDllRegisterServer:

   if (pwszCLSID)
      CoTaskMemFree(pwszCLSID);

   RegCloseKey(hKey);

   return hr;
} // STDAPI DllRegisterServer (void)


/*****************************************************************************
* DllUnregisterServer *
*---------------------*
*  This is the external entry point for the OLE DLL,
*  It follows standard OLE interface.
*
*  Return: S_OK
**********************************************************************YUNUSM*/
STDAPI DllUnregisterServer (void)
{
   // LexAPI unregister
   RegDeleteKey (HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Lexicon");

   return S_OK;
} // STDAPI DllUnregisterServer (void)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\cdict.h ===
#ifndef _CDICT_H_
#define _CDICT_H_

#include "LexAPI.h"
#include "CRWLock.h"

#pragma warning(disable : 4200)

#define INIT_DICT_HASH_SIZE 100 // initial hash table length per lcid in a dict file
#define DELETIONS_ARRAY_SIZE 25 // This is the maximum number of (latest) word deletions we will record
#define ADDITIONS_ARRAY_SIZE 75 // This is the maximum number of (latest) word additions we can efficiently access

typedef struct __lcidnode
{
   LCID lcid;
   DWORD nHashOffset; // offset in bytes from the start of mem block to the hash table
   DWORD nHashLength; // hash table length
   DWORD nWords;  // number of words in the hash table
} LCIDNODE, *PLCIDNODE;

typedef struct __dictnode
{
   // size of this node
   DWORD nSize;
   DWORD nGenerationId;
   DWORD nNumInfoBlocks;
   // offsets in bytes from the start of the shared memory block
   DWORD nNextOffset;
   // Buffer holding (Null-terminated Word + 1 or more of LEX_WORD_INFO blocks)
   BYTE pBuffer[0];
} DICTNODE, *PDICTNODE;

typedef struct __freedictnode
{
   // sizeof this node;
   DWORD nSize;
   // offsets in bytes from the start of the shared memory block to the next node
   DWORD nNextOffset;
} FREENODE, *PFREENODE;

// An array of __changedwordcachenode nodes is the cache holding offsets to added words
// Another array of __changedwordcachenode nodes is the cache holding offsets to deleted words
// For added words the offset points to the actual word in the dictionary
// For deleted words the offset points to a DICTNODE with zero nNumInfoBlocks
typedef struct __changedwordcachenode
{
   LCID Lcid;
   DWORD nOffset;
   DWORD nGenerationId;
} WCACHENODE, *PWCACHENODE;

typedef struct __rwlexinfo
{
   GUID        gLexiconID;       // Lexicon ID
   DWORD       dwLexType;        // Lexicon Type
   RWLOCKINFO  RWLockInfo;       // reader/writer lock
   GUID        gDictMapName;     // guid used as map name
   DWORD       nRWWords;         // number of words in dict
   bool        fReadOnly;        // true if read only dict
   DWORD       nDictSize;        // dict size in bytes
   DWORD       nFreeHeadOffset;  // free list head
   bool        fRemovals;        // true if there have been any removals - used to detect if data is compact
   bool        fAdditions;       // true if there have been any additions
   DWORD       nAddGenerationId; // the master add generation id
   DWORD       nDelGenerationId; // the master del generation id
   WORD        iAddCacheNext;    // Index in the add words cache where the next element is to be added
   WORD        iDelCacheNext;    // Index in the del words cache where the next element is to be added
} RWLEXINFO, *PRWLEXINFO;

#define MAX_DICT_SIZE 20971520 // 20M

#define MAX_INFO_RETURNED_SIZE ((sizeof(LEX_WORD_INFO) + (MAX_PRON_LEN + 1) * sizeof (WCHAR)) * MAX_NUM_LEXINFO)
#define MAX_PRON_RETURNED_SIZE (((MAX_PRON_LEN + 1) * sizeof (WCHAR)) * MAX_NUM_LEXINFO)
#define MAX_INDEX_RETURNED_SIZE (MAX_NUM_LEXINFO * sizeof (WORD))

class CDict
{
   friend class CLookup;
   friend HRESULT BuildAppLex (PWSTR pwTextFile, bool fReadOnly, PWSTR pwLexFile);

   public:

      CDict();
      ~CDict();
      HRESULT Init(PWSTR pFileName, DWORD dwLexType);
      HRESULT Init(PRWLEXINFO pInfo);
      
      void Lock(bool fReadOnly);
      void UnLock(bool fReadOnly);
      bool IsEmpty(void);
      //HRESULT GetWordPronunciations(PCWSTR pwWord, LCID lcid, PWSTR pwProns, PWORD pwPronIndex,
      //                              DWORD dwPronBytes, DWORD dwIndexBytes, PDWORD pdwPronBytesNeeded, 
      //                              PDWORD pdwPronIndexBytesNeeded, PDWORD pdwNumProns, DWORD *pdwLexTypeFound, GUID *pGuidLexFound);
      HRESULT GetWordInformation(const WCHAR *pwWord, LCID lcid, DWORD dwInfoTypeFlags, PWORD_INFO_BUFFER pInfo,
                                 PINDEXES_BUFFER pIndexes, DWORD *pdwLexTypeFound, GUID *pGuidLexFound);
      //HRESULT AddWordPronunciations(PCWSTR pwWord, LCID lcid, PCWSTR pwProns, DWORD dwNumProns);
      HRESULT AddWordInformation(const WCHAR * pwWord, LCID lcid, WORD_INFO_BUFFER *pWordInfo, DWORD *pdwOffset = NULL);
      HRESULT RemoveWord(PCWSTR pwWord, LCID lcid);
      HRESULT GetChangedUserWords(LCID Lcid, DWORD dwAddGenerationId, DWORD dwDelGenerationId, DWORD *dwNewAddGenerationId, 
                                  DWORD *dwNewDelGenerationId, WORD_SYNCH_BUFFER *pWordSynchBuffer);
      void GetId(GUID *Id);
      HRESULT GetAllWords(LCID Lcid, WORD_SYNCH_BUFFER *pWordSynchBuffer);
      HRESULT Serialize(bool fQuick = false);
      HRESULT FlushAscii(LCID lcid, PWSTR pwFileName);

   private:

      void _Destructor(void);
      DWORD _SizeofWordInfoArray(PLEX_WORD_INFO pInfo, DWORD dwNumInfo);
      void _SizeOfDictNode(PCWSTR pwWord, PLEX_WORD_INFO pInfo, DWORD dwNumInfo, DWORD *pnDictNodeSize, DWORD *pnInfoSize);
      DWORD _AddNewWord(PCWSTR pwWord, PLEX_WORD_INFO pInfo, DWORD nNewNodeSize, DWORD nInfoSize, DWORD nNumInfo);
      DWORD _GetFreeDictNode(DWORD nSize);
      void _AddDictNodeToFreeList(DWORD nOffset);
      void _DumpAscii(HANDLE hFile, DWORD nOffset);
      void _SetReadOnly(bool fReadOnly);
      void _ResetForCompact(void);
      HRESULT _Serialize(bool fQuick = false);
      void _GetDictEntries(PWORD_SYNCH_BUFFER pWordSynchBuffer, DWORD *pdwOffsets, DWORD dwNumOffsets);
      void _GetChangedWordsOffsets(LCID Lcid, PWCACHENODE pWordsCache, DWORD dwCacheSize, DWORD *pdwOffsets);
      HRESULT _ReallocWordSynchBuffer(WORD_SYNCH_BUFFER *pWordSynchBuffer, DWORD dwNumAddWords, DWORD dwNumDelWords,
                                      DWORD dwWordsSize);
      void _SizeofChangedWords(LCID Lcid, PWCACHENODE pWordsCache, DWORD dwCacheSize, DWORD *pdwNumWords,
                               DWORD *pdwWordsSize, DWORD *pdwNumInfo);
      HRESULT _SizeofAllWords(LCID Lcid, DWORD *pdwNumWords, DWORD *pdwWordsSize, DWORD **ppdwWordOffsets);


   private:

      PRWLEXINFO m_pRWLexInfo;                     // lex header
      ILxNotifySink *m_pNotifySink;                // pointer to notification sink
      ILxAuthenticateSink *m_pAuthenticateSink;    // pointer to authentication sink
      ILxCustomUISink *m_pCustomUISink;            // pointer to custom UI sink
      ILxHookLexiconObject *m_pHookLexiconObject;  // pointer to hook lexicon object
      WCHAR m_wDictFile[MAX_PATH];                 // The disk file for this dict object
      HANDLE m_hInitMutex;                         // mutex to protect init and serialize
      HANDLE m_hFileMapping;                       // file map handle
      PBYTE m_pSharedMem;                          // shared mem pointer
      PWCACHENODE m_pAddWordsCache;                // Cache holding offsets to the last ADDITIONS_ARRAY_SIZE word additions
      PWCACHENODE m_pDelWordsCache;                // Cache holding offsets to the last DELETIONS_ARRAY_SIZE word deletions
      bool m_fSerializeMode;                       // true if this CDict is serializing
      CRWLock m_RWLock;                            // reader/writer lock to protect access to dictionary
};

typedef CDict *PCDICT;

HRESULT BuildEmptyDict (bool fReadOnly, PWSTR pwLexFile, DWORD dwLexType);

#endif // _CDICT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\crwlock.h ===
#ifndef _RWLOCK_H_
#define _RWLOCK_H_

#include <windows.h>


typedef struct _rwlockinfo
{
   GUID gLockMapName;
   GUID gLockInitMutexName;
   GUID gLockReaderEventName;
   GUID gLockGlobalMutexName;
   GUID gLockWriterMutexName;
} RWLOCKINFO, *PRWLOCKINFO;


class CRWLock
{
public:
   CRWLock ();
   ~CRWLock ();
   HRESULT Init (PRWLOCKINFO);

   void ClaimReaderLock (void);
   void ReleaseReaderLock (void);

   void ClaimWriterLock (void);
   void ReleaseWriterLock (void);

private:
   HANDLE m_hFileMapping;
   PVOID  m_pSharedMem;
   HANDLE m_hInitMutex;
   HANDLE m_hReaderEvent;
   HANDLE m_hGlobalMutex;
   HANDLE m_hWriterMutex;
   PDWORD m_piCounter;
};

typedef class CRWLock *PCRWLOCK;

#endif // _RWLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\guidseg.cpp ===
#include <windows.h>
#include <objbase.h>
#include <objerror.h>
#include <initguid.h>
#include "Guids.h"
#include "MSGenLex.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\huffd.cpp ===
#include "PreCompiled.h"

CHuffDecoder::CHuffDecoder (PBYTE pCodeBook)
{
   int nOffset = 0;

   m_nKeys = *((int *)(pCodeBook + nOffset));
   
   nOffset += sizeof (int);

   m_nLenTree = *((int *)(pCodeBook + nOffset));

   nOffset += sizeof (int);

   m_iRoot = *((int *)(pCodeBook + nOffset));

   nOffset += sizeof (int);

   m_pHuffKey = (PHUFFKEY)(pCodeBook + nOffset);

   nOffset += m_nKeys * sizeof (HUFFKEY);

   m_pDecodeTree = (PHUFF_NODE)(pCodeBook + nOffset);

} // CHuffDecoder::CHuffDecoder ()


CHuffDecoder::~CHuffDecoder ()
{

} // CHuffDecoder::~CHuffDecoder ()


HRESULT CHuffDecoder::Next (PDWORD pEncodedBuf, int *iBitOffset, PHUFFKEY pKey)
{
   if (!m_nKeys)
   {
      return E_FAIL;
   }
   
   // Start decoding from the bit position *iBitOffset

   int iDWORD = (*iBitOffset) >> 5;
   int iBit   = (*iBitOffset) & 0x1f;

   int iNode = m_iRoot;
   PDWORD p = pEncodedBuf + iDWORD;

   int nCodeLen = 0;

   do 
   {
      if ((*p) & (1 << iBit))
         iNode = m_pDecodeTree[iNode].iRight;
      else
         iNode = m_pDecodeTree[iNode].iLeft;

      iBit++;

      if (iBit == 32)
      {
         iBit = 0;
         p++;
      }

      nCodeLen++;
   
   } while (m_pDecodeTree[iNode].iLeft != (WORD)-1);

   _ASSERTE (m_pDecodeTree[iNode].iRight == (WORD)-1);

   (*iBitOffset) += nCodeLen;

   _ASSERTE (iNode < m_nKeys);

   *pKey = m_pHuffKey [iNode];

   return NOERROR;

} // CHuffDecoder::Next (PHUFFKEY pKey, int *iBit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\crwlock.cpp ===
#include "PreCompiled.h"

CRWLock::CRWLock ()
{
   m_hFileMapping = NULL;
   m_pSharedMem = NULL;
   m_hInitMutex = NULL;
   m_hReaderEvent = NULL;
   m_hGlobalMutex = NULL;
   m_hWriterMutex = NULL;
   m_piCounter = NULL;
}


CRWLock::~CRWLock()
{
   CloseHandle (m_hInitMutex);
   CloseHandle (m_hReaderEvent);
   CloseHandle (m_hGlobalMutex);
   CloseHandle (m_hWriterMutex);
   
   UnmapViewOfFile (m_pSharedMem);
   CloseHandle (m_hFileMapping);
}


HRESULT CRWLock::Init (PRWLOCKINFO pInfo)
{
   if (IsBadReadPtr (pInfo, sizeof (RWLOCKINFO)))
   {
      return E_INVALIDARG;
   }
   
   HRESULT hRes = NOERROR;
   char szObject [64];
   
   // We don't ask for ownership of the mutex because more than
   // one thread could be executing here

   GuidToString (&(pInfo->gLockInitMutexName), szObject);
   m_hInitMutex = CreateMutex (NULL, FALSE, szObject);
   if (!m_hInitMutex)
   {
      hRes = E_FAIL;
      goto ReturnInit;
   }

   WaitForSingleObject (m_hInitMutex, INFINITE);

   GuidToString (&(pInfo->gLockReaderEventName), szObject);
   m_hReaderEvent = CreateEvent (NULL, TRUE, FALSE, szObject);

   GuidToString (&(pInfo->gLockGlobalMutexName), szObject);
   m_hGlobalMutex = CreateEvent (NULL, FALSE, TRUE, szObject);

   GuidToString (&(pInfo->gLockWriterMutexName), szObject);
   m_hWriterMutex = CreateMutex (NULL, FALSE, szObject);

   if (!m_hReaderEvent || !m_hGlobalMutex || !m_hWriterMutex)
   {
      hRes = E_FAIL;
      goto ReturnInit;
   }

   GuidToString (&(pInfo->gLockMapName), szObject);

   m_hFileMapping =  CreateFileMapping 
      (  
      (HANDLE)0xffffffff, // use the system paging file
      NULL,
      PAGE_READWRITE,
      0,
      sizeof (DWORD),
      szObject
      );

   if (!m_hFileMapping)
   {
      hRes = E_FAIL;
      goto ReturnInit;
   }

   m_pSharedMem = MapViewOfFile
      (
      m_hFileMapping,
      FILE_MAP_WRITE,
      0,
      0,
      0
      );

   if (!m_pSharedMem)
   {
      hRes = E_FAIL;
      goto ReturnInit;
   }

   m_piCounter = (PDWORD)(m_pSharedMem);
   *m_piCounter = (DWORD)-1;

ReturnInit:
   
   ReleaseMutex (m_hInitMutex);

   return hRes;

} // HRESULT CRWLock::Init (void)


void CRWLock::ClaimReaderLock (void)
{
   if (InterlockedIncrement ((LPLONG)m_piCounter) == 0)
   {
      WaitForSingleObject (m_hGlobalMutex, INFINITE);
      SetEvent (m_hReaderEvent);
   }

   WaitForSingleObject (m_hReaderEvent, INFINITE);

} // void CRWLock::ClaimReaderLock (void)


void CRWLock::ClaimWriterLock (void)
{
   WaitForSingleObject (m_hWriterMutex, INFINITE);
   WaitForSingleObject (m_hGlobalMutex, INFINITE);

} // void CRWLock::ClaimWriterLock (void)


void CRWLock::ReleaseReaderLock (void)
{
   if (InterlockedDecrement ((LPLONG)m_piCounter) < 0)
   {
      ResetEvent (m_hReaderEvent);
      SetEvent (m_hGlobalMutex);
   }

} // void CRWLock::ReleaseReaderLock (void)


void CRWLock::ReleaseWriterLock (void)
{
   SetEvent (m_hGlobalMutex);
   ReleaseMutex (m_hWriterMutex);

} // void CRWLock::ReleaseWriterLock (void)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\huffc.cpp ===
#include "PreCompiled.h"


CHuffEncoder::CHuffEncoder ()
{
   m_nKeys        = 0;
   m_nLenTreeBuf  = 0;
   m_nUseTreeBuf  = 0;
   m_pEncodeTree  = NULL;
   m_pHuffKey     = NULL;
   m_iRoot        = 0;
   m_pCodeTable   = NULL;
   m_pEncodedBuf  = NULL;
   m_nLenEnBuf    = 0;
   m_nUseEnBuf    = 0;
   m_iBitFlush    = 0;

} // CHuffEncoder::CHuffEncoder ()


CHuffEncoder::~CHuffEncoder ()
{
   free (m_pEncodeTree);
   free (m_pHuffKey);
   free (m_pCodeTable);
   free (m_pEncodedBuf);

} // CHuffEncoder::~CHuffEncoder ()


HRESULT CHuffEncoder::Count (HUFFKEY Key)
{
   // Look for the key
   for (int i = 0; i < m_nUseTreeBuf; i++)
   {
      if (Key == m_pHuffKey[i])
      {
         (m_pEncodeTree[i].nCount)++;
         return NOERROR;
      }
   }

   if (m_nUseTreeBuf == m_nLenTreeBuf)
   {
      m_nLenTreeBuf += 256;
      m_pHuffKey = (PHUFFKEY) realloc (m_pHuffKey, m_nLenTreeBuf * sizeof (HUFFKEY));
      if (!m_pHuffKey)
         return E_OUTOFMEMORY;

      m_pEncodeTree = (PHUFF_EN_NODE) realloc (m_pEncodeTree, m_nLenTreeBuf * sizeof (HUFF_EN_NODE));
      if (!m_pEncodeTree)
         return E_OUTOFMEMORY;
   }

   // Create a new key a vlaue - which is also a leaf for the huffman code tree
   m_pHuffKey     [m_nUseTreeBuf]            = Key;
   m_pEncodeTree  [m_nUseTreeBuf].nCount     = 1;
   m_pEncodeTree  [m_nUseTreeBuf].fConsider  = true;
   m_pEncodeTree  [m_nUseTreeBuf].iLeft      = (WORD)-1; // -1 means leaf node (key value)
   m_pEncodeTree  [m_nUseTreeBuf].iRight     = (WORD)-1; // -1 means leaf node (key value)

   m_nUseTreeBuf++;
   m_nKeys++;
            
   return NOERROR;

} // CHuffEncoder::Count (HUFFKEY Key)


HRESULT CHuffEncoder::ConstructCode (FILE *fp)
{
   m_iRoot = 0;

   // Construct the Huffman tree
   if (!m_nKeys)
   {
      goto WRITEOUT;
   }

   for (;;)
   {
      // find the two nodes with the lowest counts and with fConsider flags ON

      int iLowest = 0x7fffffff;
      int iLowest1 = 0x7fffffff; // second lowest

      int nLowest = 0x7fffffff;
      int nLowest1 = 0x7fffffff;

      for (int i = 0; i < m_nUseTreeBuf; i++)
      {
         if (false == m_pEncodeTree[i].fConsider)
            continue;

         if (m_pEncodeTree[i].nCount < nLowest)
         {
            nLowest1 = nLowest;
            iLowest1 = iLowest;

            nLowest = m_pEncodeTree[i].nCount;
            iLowest = i;
         }
         else if (m_pEncodeTree[i].nCount < nLowest1)
         {
            nLowest1 = m_pEncodeTree[i].nCount;
            iLowest1 = i;
         }
      }

      _ASSERTE (iLowest != 0x7fffffff);

      if (iLowest1 == 0x7fffffff)
      {
         m_pEncodeTree[iLowest].fConsider = false; // Not necessary but safe
         m_pEncodeTree[iLowest].iParent   = (unsigned short)-1;    // Not necessary but safe
         m_iRoot = iLowest;
         break;
      }

      if (m_nUseTreeBuf == m_nLenTreeBuf)
      {
         m_nLenTreeBuf += 256;
         m_pEncodeTree = (PHUFF_EN_NODE) realloc (m_pEncodeTree, m_nLenTreeBuf * sizeof (HUFF_EN_NODE));
         if (!m_pEncodeTree)
            return E_OUTOFMEMORY;
      }

      m_pEncodeTree[m_nUseTreeBuf].iLeft  = (unsigned short)iLowest;
      m_pEncodeTree[m_nUseTreeBuf].iRight = (unsigned short)iLowest1;
      m_pEncodeTree[m_nUseTreeBuf].nCount = m_pEncodeTree[iLowest].nCount + 
                                            m_pEncodeTree[iLowest1].nCount;
      m_pEncodeTree[m_nUseTreeBuf].fConsider = true;

      m_pEncodeTree[iLowest].fConsider  = false;
      m_pEncodeTree[iLowest].iParent    = (unsigned short)m_nUseTreeBuf;
      m_pEncodeTree[iLowest1].fConsider = false;
      m_pEncodeTree[iLowest1].iParent   = (unsigned short)m_nUseTreeBuf;

      m_nUseTreeBuf++;

   } // for (;;)

   _ASSERTE (m_iRoot);

   // Build a table of keys and codes for quick encoding
   m_pCodeTable = (PCODE_TABLE) malloc (m_nKeys * sizeof (CODE_TABLE));
   if (!m_pCodeTable)
      return E_OUTOFMEMORY;

   int i;
   for (i = 0; i < m_nKeys; i++)
   {
      _ASSERTE (i != m_iRoot);

      int iNode = i;
      m_pCodeTable[i].nBits = 0;
      m_pCodeTable[i].Code  = (CODETYPE)0;

      // The least significant bit of code occupies the MSB of m_pCodeTable[i].Code

      for (;;)
      {
         (m_pCodeTable[i].nBits)++;

         _ASSERTE (m_pCodeTable[i].nBits < 8 * sizeof (m_pCodeTable[i].Code)); 

         int iParent = m_pEncodeTree[iNode].iParent;

         _ASSERTE ((iNode == m_pEncodeTree[iParent].iLeft) ||
                   (iNode == m_pEncodeTree[iParent].iRight));

         if (iNode == (m_pEncodeTree[iParent].iRight))
         {
            m_pCodeTable[i].Code |= (((CODETYPE)1) << (8 * sizeof (m_pCodeTable[0].Code) - m_pCodeTable[i].nBits));
         }
      
         iNode = m_pEncodeTree[iNode].iParent;

         if (iNode == m_iRoot)
            break;

      } // for (;;)

      m_pCodeTable[i].Code >>= (8 * sizeof (m_pCodeTable[i].Code) - m_pCodeTable[i].nBits);

   } // for (int i = 0; i < nKeys; i++)

WRITEOUT:

   // Write out the huffman tree to the file, fp
   fwrite (&m_nKeys, sizeof (m_nKeys), 1, fp);
   fwrite (&m_nUseTreeBuf, sizeof (m_nUseTreeBuf), 1, fp);
   fwrite (&m_iRoot, sizeof (m_iRoot), 1, fp);
   fwrite (m_pHuffKey, sizeof (HUFFKEY), m_nKeys, fp);

   // write out only the relevant parts of encode tree nodes needed for decoding
   for (i = 0; i < m_nUseTreeBuf; i++)
   {
      PHUFF_NODE p = (PHUFF_NODE)(m_pEncodeTree + i);
      fwrite (p, sizeof (HUFF_NODE), 1, fp);
   }

   // free the stuff no longer needed
   free (m_pEncodeTree);
   m_pEncodeTree = NULL;

   return NOERROR;

} // HRESULT CHuffEncoder::ConstructCode (FILE *fp)


HRESULT CHuffEncoder::Encode (HUFFKEY Key)
{
   if (m_nLenEnBuf < m_nUseEnBuf + 256)
   {
      m_nLenEnBuf += 512;
      m_pEncodedBuf = (PDWORD) realloc (m_pEncodedBuf, m_nLenEnBuf * sizeof (DWORD));
      if (!m_pEncodedBuf)
         return E_OUTOFMEMORY;
   }

   for (int i = 0; i < m_nKeys; i++)
   {
      if (m_pHuffKey[i] == Key)
         break;
   }

   _ASSERTE (i < m_nKeys);

   if (i >= m_nKeys)
      return E_FAIL;

   int iDWORD = m_iBitFlush >> 5;
   int iBit   = m_iBitFlush & 0x1f;

   PDWORD p = m_pEncodedBuf + iDWORD;

   for (int j = 0; j < m_pCodeTable[i].nBits; j++)
   {
      CODETYPE d = (m_pCodeTable[i].Code & (1 << j));
      if (d)
         (*p) |= (1 << iBit);
      else
         (*p) &= ~(1 << iBit);
      ++iBit;

      if (iBit == 0x20)
      {
         p++;
         iBit = 0;
      }
   }

   m_iBitFlush += m_pCodeTable[i].nBits;

   m_nUseEnBuf = (((m_iBitFlush + 0x1f) & (~0x1f)) >> 5);

   return NOERROR;

} // HRESULT CHuffEncoder::Encode (HUFFKEY Key)


HRESULT CHuffEncoder::Flush (PDWORD pBuf, int *iBit)
{
   *iBit = m_iBitFlush;

   CopyMemory (pBuf, m_pEncodedBuf, sizeof (DWORD)* (((m_iBitFlush + 0x1f) & (~0x1f)) >> 5));

   m_iBitFlush = 0;
   return NOERROR;

} // HRESULT CHuffEncoder::Flush (PDWORD *ppBuf, int *iBit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\clts.cpp ===
/*****************************************************************************
*  CLts.cpp
*     Implements the LTS vendor lexicon object
*
*  Owner: YunusM
*
*  Copyright 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#include "PreCompiled.h"

//---------- Defines --------------------------------------------------------

#define MAX_CHARS_IN_INTPHONE 3
#define MAX_CHARS_IN_IPA 3
#define MAX_WORDS_IN_COMBO 10

//---------- Globals statics ------------------------------------------------

static const PCSTR pLtsMapName = "65D56DBB-1F9E-11d3-9C25-00C04F8EF87C";


//---------- CLTS class implementation --------------------------------------

/*****************************************************************************
* CLTS *
*------*
*  Constructor 
*
*  Return: 
**********************************************************************YUNUSM*/
CLTS::CLTS (CVendorManager *pMgr)
{
   m_cRef = 0;
   m_pMgr = pMgr;
   m_fInit = false;
   m_Lcid = (LCID)-1;
   m_fAuthenticated = TRUE;

   m_fBuild = false;

   m_pLtsData = NULL;
   m_hLtsMap = NULL;
   m_hLtsFile = NULL;

   m_pIntPhoneIPAIdMap = NULL;
   m_uIntPhoneIPAIdMap = 0;
   m_pLTSPhoneIPAIndex = NULL;
   m_uLTSPhones = 0;
   m_pEngPhoneIPAIndex = NULL;
   m_uEnginePhones = 0;
   m_pIPAEngPhoneIndex = NULL;

   m_pLTSForest = NULL;
   m_pp = NULL;

   InitializeCriticalSection (&m_cs);

} // CLTS::CLTS (CVendorManager *pMgr)


/*****************************************************************************
* _Destructor *
*-------------*
*  The real destructor
*
*  Return: 
**********************************************************************YUNUSM*/
void CLTS::_Destructor(void)
{
   _ASSERTE(_CrtCheckMemory());

   UnmapViewOfFile (m_pLtsData);
   CloseHandle (m_hLtsMap);
   CloseHandle (m_hLtsFile);
   m_pLtsData = NULL;
   m_hLtsMap = NULL;
   m_hLtsFile = NULL;

   if (m_pLTSForest)
      ::LtscartFreeData(m_pLTSForest);
   m_pLTSForest = NULL;

   if (m_pp)
      delete (m_pp);
   m_pp = NULL;

   m_pIntPhoneIPAIdMap = NULL;
   m_pLTSPhoneIPAIndex = NULL;
   m_pEngPhoneIPAIndex = NULL;
   m_pIPAEngPhoneIndex = NULL;
   m_uIntPhoneIPAIdMap = 0;
   m_uLTSPhones = 0;
   m_uEnginePhones = 0;
} // void CLTS::_Destructor(void)


/*****************************************************************************
* ~CLTS *
*-------*
*  The destructor
*
*  Return: 
**********************************************************************YUNUSM*/
CLTS::~CLTS()
{
   _Destructor();
} // CLTS::~CLTS()


/*****************************************************************************
* Init *
*------*
*  The Init functions creates the file map and initializes the member pointers
*
*  Return: S_OK, E_FAIL, E_OUTOFMEMORY, Win32 errors
**********************************************************************YUNUSM*/
HRESULT CLTS::Init(PCWSTR pwLtsFile,      // The file holding the Lts lexicon
                   PCWSTR                 // Dummy argument to be able to derive from a base class
                   )
{
   // Not validating arguments since this is an internal call   

   HRESULT hRes = S_OK;

   EnterCriticalSection (&m_cs);

   // Do not allow this object to be inited multiple times
   if (true == m_fInit)
   {
      hRes = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);
      goto ReturnInit;
   }

   m_fInit = true;

   char szLtsFile[MAX_PATH];

   // We limit the fully qualified name length to a max of MAX_PATH
   if (!WideCharToMultiByte (CP_ACP, 0, pwLtsFile, -1, szLtsFile, MAX_PATH, NULL, NULL))
   {
      hRes = E_FAIL;
      goto ReturnInit;
   }

   // Map the Lts lexicon file
   m_hLtsFile = CreateFile (szLtsFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
   if (m_hLtsFile == INVALID_HANDLE_VALUE)
   {
      hRes = HRESULT_FROM_WIN32 (GetLastError()); // bad input
      goto ReturnInit;
   }
  
   m_hLtsMap = CreateFileMapping (m_hLtsFile, NULL, PAGE_READONLY | SEC_COMMIT, 0 , 0, pLtsMapName);
   if (!m_hLtsMap) 
   {
      hRes = HRESULT_FROM_WIN32 (GetLastError());
      goto ReturnInit;
   }
  
   m_pLtsData = (PBYTE) MapViewOfFile (m_hLtsMap, FILE_MAP_READ, 0, 0, 0);
   if (!m_pLtsData) 
   {
      hRes = HRESULT_FROM_WIN32 (GetLastError());
      goto ReturnInit;
   }

   int nOffset;
   nOffset = 0;
   LTSLEXINFO LtsHeader;

   // Read LtsHeader
   CopyMemory (&LtsHeader, m_pLtsData + nOffset, sizeof (LTSLEXINFO));
   nOffset += sizeof (LTSLEXINFO);

   m_Lcid = LtsHeader.Lcid;
   m_gLexiconId = LtsHeader.gLexiconID;

   // Read the number of entries in the map file (total number of phones)
   m_uIntPhoneIPAIdMap = *((DWORD*)(m_pLtsData + nOffset));
   nOffset += sizeof (DWORD);
   _ASSERTE (m_uIntPhoneIPAIdMap);

   // Read the number of Lts phones
   m_uLTSPhones = *((DWORD*)(m_pLtsData + nOffset));
   nOffset += sizeof (DWORD);
   _ASSERTE (m_uLTSPhones);

   // Read the number of Engine phones
   m_uEnginePhones = *((DWORD*)(m_pLtsData + nOffset));
   nOffset += sizeof (DWORD);
   _ASSERTE (m_uLTSPhones);

   // Read the int phone to IPA map
   m_pIntPhoneIPAIdMap = (PHONEID*)(m_pLtsData + nOffset);
   nOffset += (sizeof (PHONEID) * m_uIntPhoneIPAIdMap);

   // LTS phones to IPA index
   m_pLTSPhoneIPAIndex = (PBYTE)(m_pLtsData + nOffset);
   nOffset += m_uLTSPhones;

   // Engine phones to IPA index
   m_pEngPhoneIPAIndex = (PBYTE)(m_pLtsData + nOffset);
   nOffset += m_uEnginePhones;

   // IPA to Engine phones index
   m_pIPAEngPhoneIndex = (PBYTE)(m_pLtsData + nOffset);
   nOffset += m_uEnginePhones;

   switch (PRIMARYLANGID (LANGIDFROMLCID (m_Lcid))) 
   {
   // so far we have two languages - there're no LTS rules for Japanese
   case LANG_ENGLISH: 
      {
      m_pLTSForest = ::LtscartReadData (m_pLtsData + nOffset);
      if (!m_pLTSForest) 
      {
         hRes = E_OUTOFMEMORY;
         goto ReturnInit;
      }

      // Create and initialize the preprocessor
      m_pp = new CPreProc ();
      if (!m_pp)
      {
         hRes = E_OUTOFMEMORY;
         goto ReturnInit;
      }

      hRes = m_pp->SetLanguage (LANGIDFROMLCID (m_Lcid));
      if (FAILED (hRes))
         goto ReturnInit;

      hRes = m_pp->SetSRMode(TRUE);
      if (FAILED (hRes))
         goto ReturnInit;
      }
   break;
   }

ReturnInit:

   if (FAILED (hRes))
      _Destructor();

   LeaveCriticalSection (&m_cs);

   return hRes;
} // HRESULT CLTS::Init ()


/*****************************************************************************
* AddRef *
*--------*
*  Delegates the AddRef to the manager
*
*  Return : new count
**********************************************************************YUNUSM*/
STDMETHODIMP_(ULONG) CLTS::AddRef()
{
   m_pMgr->AddRef();
   return ++m_cRef;
} // STDMETHODIMP_(ULONG) CLTS::AddRef()


/*****************************************************************************
* Release *
*---------*
*  Delegates the Release to the manager
*
*  Return : new count
**********************************************************************YUNUSM*/
STDMETHODIMP_(ULONG) CLTS::Release()
{
   ULONG i = --m_cRef;
   m_pMgr->Release();
   return i;
} // STDMETHODIMP_(ULONG) CLTS::Release()


/*****************************************************************************
* QueryInterface *
*----------------*
*  Delegates the QueryInterface to the manager
*
*  Return : NOERROR, E_NOINTERFACE
**********************************************************************YUNUSM*/
STDMETHODIMP CLTS::QueryInterface(
                                  REFIID riid,       // IID of the interface
                                  LPVOID FAR * ppv   // pointer to the interface returned
                                  )
{
   return m_pMgr->QueryInterface(riid, ppv);
} // STDMETHODIMP CLTS::QueryInterface()


/*****************************************************************************
* GetHeader *
*-----------*
*   Returns the header of this lexicon (not LTSLEXINFO)
*
*  Return : E_POINTER, E_INVALIDARG, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLTS::GetHeader(LEX_HDR *pLexHdr)
{
   if (!pLexHdr)
      return E_POINTER;

   if (IsBadWritePtr(pLexHdr, sizeof(LEX_HDR)))
      return E_INVALIDARG;

   return E_NOTIMPL;
} // STDMETHODIMP CLTS::GetHeader(LEX_HDR *pLexHdr)


/*****************************************************************************
* Authenticate *
*--------------*
*  Examines the engine Id and returns the lexicon id. In this case CLTS does
*  not care who uses it.
*
*  Return : E_POINTER, E_INVALIDARG, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLTS::Authenticate(GUID,           // GUID of the client (engine)
                                GUID *pLexId    // returned GUID of CLTS lexicon
                                )
{
   if (!pLexId)
      return E_POINTER;

   if (IsBadWritePtr(pLexId, sizeof(GUID)))
      return E_INVALIDARG;

   // We don't care what client wnats to use us.

   *pLexId = m_gLexiconId;

	return S_OK;
} // STDMETHODIMP CLTS::Authenticate(GUID ClientId, GUID *pLexId)


/*****************************************************************************
* IsAuthenticated *
*-----------------*
*  Returns TRUE if authenticated. In this case LTS lexicon does
*  not care who uses it.
*
*  Return : E_POINTER, E_INVALIDARG, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLTS::IsAuthenticated(BOOL *pfAuthenticated)
{
	if (!pfAuthenticated)
      return E_POINTER;

   if (IsBadWritePtr(pfAuthenticated, sizeof(BOOL)))
      return E_INVALIDARG;

   *pfAuthenticated = m_fAuthenticated;   

	return S_OK;
} // STDMETHODIMP CLTS::IsAuthenticated(BOOL *pfAuthenticated)


/*****************************************************************************
* EnginePhoneToIPA *
*------------------*
*  Converts an engine phone to IPA
*
*  Return :
**********************************************************************YUNUSM*/
HRESULT CLTS::EnginePhoneToIPA (PSTR pIntPhone, // Internal phone string
                                PWSTR pIPA      // Returned IPA string
                                )
{
   return ToIPA (pIntPhone, pIPA, m_pEngPhoneIPAIndex, m_uEnginePhones);

} // HRESULT CLTS::EnginePhoneToIPA (PSTR pIntPhone, PWSTR pIPA)


/*****************************************************************************
* LTSPhoneToIPA *
*---------------*
*  Converts an LTS phone to IPA
*
*  Return :
**********************************************************************YUNUSM*/
HRESULT CLTS::LTSPhoneToIPA (PSTR pIntPhone,    // IPA string
                             PWSTR pIPA         // Returned internal phone string
                             )
{
   return ToIPA (pIntPhone, pIPA, m_pLTSPhoneIPAIndex, m_uLTSPhones);
} // HRESULT CLTS::LTSPhoneToIPA (PSTR pIntPhone, PWSTR pIPA)


/*****************************************************************************
* ToIPA *
*-------*
*  Convert an internal phone string to IPA code string
*  The internal phones are space separated and may have a space
*  at the end. pIPA has to be of length MAX_PRON_LEN WCHARs atleast.
*
*  Return : S_OK E_FAIL
**********************************************************************YUNUSM*/
HRESULT CLTS::ToIPA (PSTR pIntPhone,            // Internal phone string
                     PWSTR pIPA,                // Returned IPA string
                     PBYTE pIndex,              // Index mapping internal phones to IPA
                     DWORD nIndex               // Length of the index
                     )
{
   *pIPA = NULL;

   PSTR p, p1;
   PWSTR pw = pIPA;

   char szPhone [MAX_PRON_LEN];

   strcpy (szPhone, pIntPhone);

   p = szPhone;

   while (p)
   {
      p1 = strchr (p, ' ');
      if (p1)
      {
         *p1++ = NULL;

         // sometimes there is a terminating space
         if (!*p1)
            p1 = NULL;
         else
         {
            // sometimes there's more than one space between phones!! (like G  EH R IX T in our dictionary)
            while (*p1 == ' ')
               p1++;
         }
      }

      int i = 0;
      int j = nIndex - 1;

      while (i <= j) 
      {
         int l = stricmp(p, m_pIntPhoneIPAIdMap[pIndex[(i+j)/2]].szPhone);
         if (l > 0)
            i = (i+j)/2 + 1;
         else if (l < 0)
            j = (i+j)/2 - 1;
         else 
         {
            // found

            // BUGBUG: We should probably return an error here instead of NOERROR
            // But who will care to notice that the pron has been clipped to
            // about 256 chars? There's something else more wrong!

            if ((pw - pIPA) > (MAX_PRON_LEN - MAX_CHARS_IN_IPA - 2))
               return NOERROR;

            wcscpy (pw, (PWSTR)(&(m_pIntPhoneIPAIdMap[pIndex[(i+j)/2]].ipaPhone)));
            pw += wcslen (pw);
            break;
         }
      }

      _ASSERTE (i <= j);

      if (i > j)
      {
         return E_FAIL;
      }

      p = p1;
   }

   return S_OK;
} // HRESULT CLTS::ToIPA (PSTR pIntPhone, PWSTR pIPA, PBYTE pIndex, DWORD nIndex)


/*****************************************************************************
* EnginePhoneToIPA *
*------------------*
*  Converts an IPA to engine phone
*
*  Return :
**********************************************************************YUNUSM*/
HRESULT CLTS::IPAToEnginePhone (PWSTR pIPA,     // IPA string
                                PSTR pIntPhone  // returned internal phone string
                                )
{
   return FromIPA (pIPA, pIntPhone, m_pIPAEngPhoneIndex, m_uEnginePhones);

} // HRESULT CLTS::EnginePhoneToIPA (PSTR pIntPhone, PWSTR pIPA)


/*****************************************************************************
* ToIPA *
*-------*
*  Convert an IPA code string to internal phone string. The
*  internal phones are separated by spaces (no terminating space).
*  pIntPhone has to be of length MAX_PRON_LEN chars atleast.
*
*  Return : S_OK E_FAIL
**********************************************************************YUNUSM*/
HRESULT CLTS::FromIPA (PWSTR pIPA,              // Returned IPA string                 
                       PSTR pIntPhone,          // Internal phone string
                       PBYTE pIndex,            // Index mapping internal phones to IPA
                       DWORD nIndex             // Length of the index                 
                       )
{
   DWORD nLen = wcslen (pIPA);
   DWORD nOffset = 0;

   PSTR p = pIntPhone;
   *p = NULL;

   while (nLen)
   {
      __int64 wIPAStr = 0;
      DWORD nCompare = (nLen > MAX_CHARS_IN_IPA) ? MAX_CHARS_IN_IPA : nLen;
      
      wcsncpy ((PWSTR)(&wIPAStr), pIPA + nOffset, nCompare);

      for (;;)
      {
         int i = 0;
         int j = nIndex - 1;

         while (i <= j) 
         {
            if (m_pIntPhoneIPAIdMap[pIndex[(i+j)/2]].ipaPhone > wIPAStr)
            {
               j = (i+j)/2 - 1;
            }
            else if (m_pIntPhoneIPAIdMap[pIndex[(i+j)/2]].ipaPhone < wIPAStr)
            {
               i = (i+j)/2 + 1;
            }
            else
            {
               break;
            }
         }

         if (i <= j)
         {
            // found
            // 2 for the seperating space and terminating NULL

            // BUGBUG: We should probably return an error here instead of NOERROR
            // But who will care to notice that the pron has been clipped to
            // about 256 chars? There's something else more wrong!
            
            if ((p - pIntPhone) > (MAX_PRON_LEN - MAX_CHARS_IN_INTPHONE - 2))
               return NOERROR;

            if (p != pIntPhone)
               strcat (p, " ");

            strcat (p, m_pIntPhoneIPAIdMap[pIndex[(i+j)/2]].szPhone);
            p += strlen (p);

            // Here 'p' is always pointing to a NULL so the above strcats work fine

            break;
         }

         ((PWSTR)(&wIPAStr))[--nCompare] = 0;

         _ASSERTE (nCompare);

         if (!nCompare)
         {
            *pIntPhone = NULL;
            return E_FAIL;
         }
      
      } // for (;;)

      nLen -= nCompare;
      nOffset += nCompare;
   
   } // while (nLen)

   return NOERROR;
} // HRESULT CLTS::FromIPA (PWSTR pIPA, PSTR pIntPhone)


/*****************************************************************************
* IsPunctW *
*----------*
*  Detects if a character is a punctuation mark.
*
*  Return : true false
**********************************************************************YUNUSM*/
__forceinline bool IsPunctW(WCHAR Char       // Character
                            )
{
   switch (Char) {
   case L'.':
   case L',':
   case L';':
   case L':':
   case L'!':
   case L'?':
   case L'':
   case L'-':
   case L'&':
   case L'%':
   case L'$':
   case L'"':
   case L'#':
   case L'*':
   case L'/':
   case L'@':
   case L'+':
   case L'=':
   case L'~':
   case L'(':
   case L')':
   case L'\\':
      //case L'\'':  // we dont want to preprocess possessives like mike's
      return true;
   }

   return false;
} // _inline BOOL IsPunctW (WCHAR Char)


/*****************************************************************************
* GetWordInformation *
*--------------------*
*  Gets the information of a word
*
*  Return : E_POINTER LEXERR_BADLCID LEXERR_BADINFOTYPE LEXERR_BADLEXTYPE
*           LEXERR_BADWORDINFOBUFFER LEXERR_BADINDEXBUFFER E_INVALIDARG S_OK
*           E_OUTOFMEMORY
*
**********************************************************************YUNUSM*/
STDMETHODIMP CLTS::GetWordInformation(const WCHAR *pwWord,        // Word string                                                                      
                                      LCID lcid,                  // Lcid on which to search this word - can be DONT_CARE_LCID                       
                                      DWORD dwTypes,              // OR of types of word information to retrieve                                     
                                      DWORD dwLex,                // OR of the LEXTYPES                                                              
                                      PWORD_INFO_BUFFER pInfo,    // Buffer in which word info are returned                                          
                                      PINDEXES_BUFFER pIndexes,   // Buffer holding indexes to pronunciations                                        
                                      DWORD *pdwLexTypeFound,     // Lex type of the lexicon in which the word and its prons were found (can be NULL)
                                      GUID *pGuidLexFound)        // Lex GUID in which the word and its prons were found (can be NULL)               
{
   // BUGBUG: Validation may  not be necessary if we move away from COM servers 
   // to data files for vendor lexicons

   if (!pwWord)
      return E_POINTER;

   if (lcid != m_Lcid)
      return LEXERR_BADLCID;
   
   if (!(dwTypes & PRON))
      return LEXERR_BADINFOTYPE;

   if (!(dwLex & LEXTYPE_GUESS))
      return LEXERR_BADLEXTYPE;

   if (_IsBadWordInfoBuffer(pInfo, lcid, false))
      return LEXERR_BADWORDINFOBUFFER;

   if (_IsBadIndexesBuffer(pIndexes))
      return LEXERR_BADINDEXBUFFER;

   if (pdwLexTypeFound && IsBadWritePtr(pdwLexTypeFound, sizeof(DWORD)) ||
       pGuidLexFound && IsBadWritePtr(pGuidLexFound, sizeof(GUID)))
      return E_INVALIDARG;

   WCHAR      wComboProns [MAXWORDPRONS][MAX_PRON_LEN];
   DWORD      nCombos = 0;
   DWORD      nPronsLen = 0;
   HRESULT    hRes = S_OK;
   WCHAR      SIL_IPA_STR[2];

   SIL_IPA_STR[0] = 0x005f;
   SIL_IPA_STR[1] = 0;

   switch (PRIMARYLANGID(LANGIDFROMLCID (m_Lcid))) 
   {
   case LANG_JAPANESE:
      {
         char szInputWord[MAX_STRING_LEN];

         WideCharToMultiByte (CP_ACP, 0, pwWord, -1, szInputWord, MAX_STRING_LEN, NULL, NULL);

         int nLength = MAX_STRING_LEN * 2;
         char *pJapPron = (PSTR) malloc (nLength * sizeof(char));
         if (!pJapPron)
         {
            hRes = E_OUTOFMEMORY;
            goto ReturnLtsGetPronunciations;
         }
         
         *pJapPron = 0;
         char szSep[] = {'_', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
         char szSyl[MAX_STRING_LEN];
         
         PSTR pszToken = strtok(szInputWord, szSep);
         *szSyl = 0;
         while (pszToken)
         {
            if ((int)strlen(pJapPron) > nLength + 128) 
            {
               nLength += 128;
               pJapPron = (PSTR) realloc (pJapPron, nLength);
               if (!pJapPron)
               {
                  hRes = E_OUTOFMEMORY;
                  goto ReturnLtsGetPronunciations;
               }
            }
         
            if ((pszToken[0] >= '0') && (pszToken[0] <= '9')) 
            {
               //finished.
               break;
            }
            
            strcpy(szSyl, pszToken);
            if ( !strcmp ( szSyl, "STOP" ) ) 
            {
               strcat ( pJapPron, "STOP " );
				   pszToken = strtok ( NULL, szSep);
               continue;
            }
             
            PSTR pch = szSyl;
             
            while ( *pch )
            {
               char szPhone[2];
         
               switch (toupper(*pch))
               {
               case 'K':
					case 'D':
               case 'H':
               case 'M':
               case 'R':
               case 'W':
               case 'G':
               case 'Z':
               case 'B':
               case 'P':
               case 'J':
               case 'Y':
               case 'V':
               case 'F':
                  szPhone[0] = *pch;
                  szPhone[1] = 0;
                  strcat( pJapPron,  szPhone);
                  strcat( pJapPron, " ");
                  pch++;
                  break;
               case 'C': //CH
                  pch++;
                  _ASSERTE(*pch == 'H');
                  if (*pch == 'H') 
                  {
                      strcat( pJapPron, "CH ");
                      pch++;
                  }
                  break;
               case 'N':
                  pch++;
                  if (*pch == 'N') 
                  {
                      strcat( pJapPron, "NN ");
                      pch++;
                  } 
                  else 
                  {
                      strcat( pJapPron, "N ");
                  }
                  break;
               case 'T':
                  pch++;
                  if (*pch == 'S') 
                  {
                      strcat( pJapPron, "TS ");
                      pch++;
                  } 
                  else 
                  {
                      strcat( pJapPron, "T ");
                  }
                  break;
               case 'S': //SH
                  pch++;
                  if (*pch == 'H') 
                  {
                      strcat( pJapPron, "SH ");
                      pch++;
                  } 
                  else 
                  {
                      strcat( pJapPron, "S ");
                  }
                  break;
               case 'A':
                  pch++;
                  if (*pch == 'A') 
                  {
                      strcat( pJapPron, "AA ");
                      pch++;
                  } 
                  else 
                  {
                      strcat( pJapPron, "A ");
                  }
                  break;
               case 'I':
                  pch++;
                  if (*pch == 'I') 
                  {
                      strcat( pJapPron, "II ");
                      pch++;
                  } 
                  else 
                  {
                      strcat( pJapPron, "I ");
                  }
                  break;
               case 'U':
                  pch++;
                  if (*pch == 'U') 
                  {
                      strcat( pJapPron, "UU ");
                      pch++;
                  } 
                  else 
                  {
                      strcat( pJapPron, "U ");
                  }
                  break;
               case 'E':
                  pch++;
                  if (*pch == 'E') 
                  {
                      strcat( pJapPron, "EE ");
                      pch++;
                  } 
                  else 
                  {
                      strcat( pJapPron, "E ");
                  }
                  break;
               case 'O':
                  pch++;
                  if (*pch == 'O') 
                  {
                      strcat( pJapPron, "OO ");
                      pch++;
                  } 
                  else
                  {
                      strcat( pJapPron, "O ");
                  }
                  break;
					default:
                  //  Invalid phoneme
						_ASSERTE(0);
               }
            } // while ( *pch )
            
            pszToken = strtok( NULL, szSep);
         
         } // while (pszToken)

         _ASSERTE (strlen (pJapPron));

         hRes = LTSPhoneToIPA (pJapPron, wComboProns[0]);

         free (pJapPron);
         
         if (FAILED (hRes))
         {
            goto ReturnLtsGetPronunciations;
         }

         _ASSERTE (*(wComboProns[0])); // the way ahtoi works
         
         nPronsLen = wcslen (wComboProns[0]) + 1; // double null

         nCombos = 1;
         
         break;
      
      } // case LANG_JAPANESE:

   case LANG_ENGLISH:
      {
         // Preprocess the word
         HRESULT hRes;
         SDATA dWords;
         dWords.pData = NULL;
         DWORD dwWordCnt;
         
         WCHAR wCurrentWord [MAX_STRING_LEN];

         wcscpy (wCurrentWord, pwWord);
         
         hRes = m_pp->ParseString (wCurrentWord, &dWords, &dwWordCnt, FALSE);
         if (FAILED(hRes))
         {
            goto ReturnLtsGetPronunciations;
         }

         PWSTR pWords = (PWSTR)dWords.pData;

         // Get the pronunciations of individual words

         WCHAR aWordsProns[MAX_WORDS_IN_COMBO][MAX_OUTPUT_STRINGS][MAX_PRON_LEN];
         DWORD anWordsProns[MAX_WORDS_IN_COMBO];

         bool afVowel[MAX_WORDS_IN_COMBO];
         bool fAnyVowel = false;

         for (DWORD i = 0; i < dwWordCnt; i++)
         {
            char szSubWord[MAX_STRING_LEN];

            *szSubWord = NULL;

            _ASSERTE (wcslen (pWords) < MAX_STRING_LEN);

            WideCharToMultiByte (CP_ACP, 0, pWords, -1, szSubWord, MAX_STRING_LEN, NULL, NULL);

            if (true == IsPunctW (*pWords))
            {
               fAnyVowel = true;
               afVowel [i] = true;
            }
            else
            {
               afVowel [i] = false;
            }
            
            LTS_OUTPUT * pLTSOutput = ::LtscartGetPron (m_pLTSForest, szSubWord);

            anWordsProns[i] = pLTSOutput->num_prons;
            
            // Convert the internal phones to IPA and copy to the aWordsProns array

            for (DWORD j = 0; (int)j < pLTSOutput->num_prons; j++)
            {
               _ASSERTE (strlen (pLTSOutput->pron[j].pstr));

               hRes = LTSPhoneToIPA (pLTSOutput->pron[j].pstr, aWordsProns[i][j]);

               if (FAILED (hRes))
               {
                  goto ReturnLtsGetPronunciations;
               }

            } // for (DWORD j = 0; j < pLTSOutput->num_prons; j++)

            pWords += wcslen (pWords) + 1;

         } // for (DWORD i = 0; i < dwWordCnt; i++)

         HeapFree(GetProcessHeap(), 0, dWords.pData);

         // Combine the individual prons - The combo prons also are limited to the max
         // pron len - MAX_PRON_LEN

         nCombos = 0;
         nPronsLen = 0;

         for (;;)
         {
            wComboProns[nCombos][0] = 0;

            bool fContinue = false;
            DWORD dwComboLen = 0;

            for (DWORD i = 0; i < dwWordCnt; i++)
            {
               DWORD j;

               if (anWordsProns[i] > nCombos + 1)
                  fContinue = true;

               if (nCombos >= anWordsProns[i])
               {
                  j = anWordsProns[i] - 1;
               }
               else
               {
                  j = nCombos;
               }

               DWORD d1 = wcslen (aWordsProns[i][j]);
               
               if ((dwComboLen + d1) > (MAX_PRON_LEN - 1))
                  break;

               wcscat (wComboProns[nCombos], aWordsProns[i][j]);

               dwComboLen += d1;
            }

            _ASSERTE (!wComboProns[nCombos][dwComboLen]);

            nPronsLen += (dwComboLen + 1); // pron length including the end NULL

            ++nCombos;

            if (!fContinue || (nCombos == MAXWORDPRONS))
               break;
         
         } // for (;;)


         // If any of the individual words are vowels then create a combo pron with
         // SIL in place of vowels - for the non-vowel words use their first pron

         if ((false == m_fBuild) && (true == fAnyVowel))
         {
            if (nCombos == MAXWORDPRONS)
            {
               // overwrite the last combo pron

               nCombos = MAXWORDPRONS - 1;
               nPronsLen -= (wcslen (wComboProns[MAXWORDPRONS - 1]) + 1);
            }
 
            wComboProns[nCombos][0] = NULL;

            DWORD dwComboLen = 0;

            for (DWORD i = 0; i < dwWordCnt; i++)
            {
               DWORD d1;

               if (true == afVowel[i])
               {
                  d1 = wcslen (SIL_IPA_STR);

                  if ((dwComboLen + d1) > (MAX_PRON_LEN - 1))
                     break;

                  wcscat (wComboProns[nCombos], SIL_IPA_STR);
               }
               else
               {
                  d1 = wcslen (aWordsProns[i][0]);

                  if ((dwComboLen + d1) > MAX_PRON_LEN)
                     break;

                  wcscat (wComboProns[nCombos], aWordsProns[i][0]);
               }

               dwComboLen += d1;
            }

            _ASSERTE (!wComboProns[nCombos][dwComboLen]);

            nPronsLen += (dwComboLen + 1);

            nCombos++;

         } // if (true == fAnyVowel)

         _ASSERTE (nPronsLen);

         break;
      
      } // case LANG_ENGLISH:

   } // switch (PRIMARYLANGID(LANGIDFROMLCID (m_Lcid)))

   hRes = _ReallocWordInfoBuffer(pInfo, nCombos * 2 * sizeof(LEX_WORD_INFO) + nPronsLen * sizeof (WCHAR));
   if (FAILED(hRes))
      goto ReturnLtsGetPronunciations;

   hRes = _ReallocIndexesBuffer(pIndexes, nCombos);
   if (FAILED(hRes))
      goto ReturnLtsGetPronunciations;

   LEX_WORD_INFO *paContiguousInfos;
   paContiguousInfos = (LEX_WORD_INFO *)malloc(nCombos * sizeof(LEX_WORD_INFO) + nPronsLen * sizeof (WCHAR));
   if (!paContiguousInfos)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnLtsGetPronunciations;
   }

   LEX_WORD_INFO *p;
   p = paContiguousInfos;

   DWORD i;
   for (i = 0; i < nCombos; i++)
   {
      p->Type = PRON;
      wcscpy(p->wPronunciation, wComboProns[i]);

      p = (LEX_WORD_INFO *)(((BYTE*)p) + _SizeofWordInfo(p));
   }

   _AlignWordInfo(paContiguousInfos, nCombos, PRON, pInfo, pIndexes);
   
   free(paContiguousInfos);

   if (pdwLexTypeFound)
      *pdwLexTypeFound = LEXTYPE_GUESS;

   if (pGuidLexFound)
      *pGuidLexFound = m_gLexiconId;

ReturnLtsGetPronunciations:

   _CrtCheckMemory();

   return hRes;

} // STDMETHODIMP CLTS::GetWordInformation()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\huffc.h ===
#ifndef _HUFFC_H_
#define _HUFFC_H_

#include "HuffD.h"

typedef unsigned int CODETYPE;

typedef struct _huffencodenode : public HUFF_NODE
{
   WORD     iParent;
   int      nCount;
   bool     fConsider;
} HUFF_EN_NODE, *PHUFF_EN_NODE;

typedef struct
{
   BYTE     nBits;
   CODETYPE Code;
} CODE_TABLE, *PCODE_TABLE;

class CHuffEncoder
{
public:
   
   CHuffEncoder              ();
   ~CHuffEncoder             ();
   
   HRESULT Count             (HUFFKEY Key);
   HRESULT ConstructCode     (FILE *fp);
   HRESULT Encode            (HUFFKEY Key);
   HRESULT Flush             (PDWORD pBuf, int *iBit);
   int     GetNumKeys        (void) { return m_nKeys; }

private:
   
   int            m_nKeys;
   int            m_nLenTreeBuf;
   int            m_nUseTreeBuf;
   PHUFF_EN_NODE  m_pEncodeTree;
   PHUFFKEY       m_pHuffKey;
   int            m_iRoot;
   PCODE_TABLE    m_pCodeTable;
   PDWORD         m_pEncodedBuf;
   int            m_nLenEnBuf;
   int            m_nUseEnBuf;
   int            m_iBitFlush;
};

#endif // _HUFFC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\guids.h ===
// Lexicon GUIDs also returned as lexicon authentication GUIDs

// {FE299096-0680-11d3-9C24-00C04F8EF87C}
DEFINE_GUID(GUID_MSSRLEX_1033,
0xfe299096, 0x680, 0x11d3, 0x9c, 0x24, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {3FCDDADF-1F5E-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(GUID_MSTTSLEX_1033,
0x3fcddadf, 0x1f5e, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {3FCDDAE0-1F5E-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(GUID_MSLTSLEX_1033,
0x3fcddae0, 0x1f5e, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {3FCDDAE1-1F5E-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(GUID_MSSRLEX_1041,
0x3fcddae1, 0x1f5e, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {3FCDDAE2-1F5E-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(GUID_MSTTSLEX_1041,
0x3fcddae2, 0x1f5e, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {3FCDDAE3-1F5E-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(GUID_MSLTSLEX_1041,
0x3fcddae3, 0x1f5e, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {3FCDDAE4-1F5E-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(GUID_MSSRLEX_2052,
0x3fcddae4, 0x1f5e, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {3FCDDAE5-1F5E-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(GUID_MSTTSLEX_2052,
0x3fcddae5, 0x1f5e, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {3FCDDAE6-1F5E-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(GUID_MSLTSLEX_2052,
0x3fcddae6, 0x1f5e, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);


//--------- RW Lock GUIDs for Lookup lexicons

// {E4908630-E544-11d2-8F27-000000000000}
DEFINE_GUID(GUID_RWLEX_MAPNAME, 
0xe4908630, 0xe544, 0x11d2, 0x8f, 0x27, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// {E4908631-E544-11d2-8F27-000000000000}
DEFINE_GUID(GUID_RWLEX_INITMUTEXNAME, 
0xe4908631, 0xe544, 0x11d2, 0x8f, 0x27, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// {E4908632-E544-11d2-8F27-000000000000}
DEFINE_GUID(GUID_RWLOCK_MAPNAME, 
0xe4908632, 0xe544, 0x11d2, 0x8f, 0x27, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// {E4908635-E544-11d2-8F27-000000000000}
DEFINE_GUID(GUID_RWLOCK_INITMUTEXNAME, 
0xe4908635, 0xe544, 0x11d2, 0x8f, 0x27, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// {E4908636-E544-11d2-8F27-000000000000}
DEFINE_GUID(GUID_RWLOCK_READEREVENTNAME, 
0xe4908636, 0xe544, 0x11d2, 0x8f, 0x27, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// {E4908637-E544-11d2-8F27-000000000000}
DEFINE_GUID(GUID_RWLOCK_GLOBALMUTEXNAME, 
0xe4908637, 0xe544, 0x11d2, 0x8f, 0x27, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);

// {E4908638-E544-11d2-8F27-000000000000}
DEFINE_GUID(GUID_RWLOCK_WRITERMUTEXNAME, 
0xe4908638, 0xe544, 0x11d2, 0x8f, 0x27, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\lexhdr.h ===
#pragma once

#include "HuffC.h"
#include "ltscart.h"
#include "Util.h"
#include "Managers.h"

// SDATA type definition copied from the SAPI4 speech.h for the benefit of the preprocessor
typedef struct {
   PVOID    pData;
   DWORD    dwSize;
} SDATA, * PSDATA;


#include <preproc.h>
#include "CRWLock.h"
#include "CDict.h"
#include "Guids.h"

#define MAXTOTALCBSIZE     9  // = CBSIZE + MAXELEMENTSIZE
#define MAXELEMENTSIZE     5  // = greater of (LTSINDEXSIZE, POSSIZE)
#define CBSIZE             4  // = LASTINFOFLAGSIZE + WORDINFOTYPESIZE
#define LASTINFOFLAGSIZE   1
#define WORDINFOTYPESIZE   3
#define LTSINDEXSIZE       4
#define POSSIZE            5 // a maximum of 32 parts of speech

#define MAXLTSPRONMATCHED  15 // = 2 ** LTSINDEXSIZE - 1

#define MAXWORDPRONS       10

#define MAXINFOBUFLEN MAX_NUM_LEXINFO * ((MAX_PRON_LEN * sizeof (WCHAR)) + 2 * sizeof (LEX_WORD_INFO))

enum WORDINFOTYPE_INT {I_LKUPLKUPPRON = 1, I_LKUPLTSPRON, I_POS};

#define INIT_DICT_HASH_SIZE 100 // initial hash table length per lcid in a dict file

/*
Control block layout

struct CB
{
   BYTE fLast : LASTINFOFLAGSIZE; // Is this the last Word Information piece
   BYTE Type : WORDINFOTYPESIZE;  // Allow for 8 types
};
*/

typedef struct _ltslexinfo
{
   GUID        gLexiconID;
   LCID        Lcid;
} LTSLEXINFO, *PLTSLEXINFO;


typedef struct _lkuplexinfo : public RWLEXINFO
{
   GUID        gLexiconID;
   LCID        Lcid;
   DWORD       nNumberWords;
   DWORD       nNumberProns;
   DWORD       nLengthHashTable;
   DWORD       nBitsPerHashEntry;
   DWORD       nLengthCmpBlockBits;
   DWORD       nWordCBSize;
   DWORD       nPronCBSize;
   DWORD       nPosCBSize;
   DWORD       nLTSFileOffset;
   DWORD       nLTSFileSize;
} LKUPLEXINFO, *PLKUPLEXINFO;


class CVendorLexicon : public ILxLexiconObject
{
public:
   CVendorLexicon() {}
   virtual ~CVendorLexicon() {}
   virtual HRESULT Init(PCWSTR pwFileName, PCWSTR pwDummy) = 0;

};

// The LTS class
class CLTS : public CVendorLexicon
{
public:

   CLTS(CVendorManager *);
   virtual ~CLTS();
   HRESULT Init(PCWSTR pwFileName, PCWSTR pwDummy);
   void _Destructor(void);

   STDMETHODIMP_(ULONG) AddRef();
   STDMETHODIMP_(ULONG) Release();
   STDMETHODIMP QueryInterface(REFIID, LPVOID*);

	STDMETHODIMP GetHeader(LEX_HDR *pLexHdr);
	STDMETHODIMP Authenticate(GUID ClientId, GUID *LexId);
	STDMETHODIMP IsAuthenticated(BOOL *pfAuthenticated);
	STDMETHODIMP RemoveWord (const WCHAR*, LCID)
      {  return E_NOTIMPL; }
	STDMETHODIMP AddWordInformation (const WCHAR*, LCID, PWORD_INFO_BUFFER)
      {  return E_NOTIMPL; }
	STDMETHODIMP GetWordInformation (const WCHAR *pwWord, LCID lcid, DWORD dwTypes, DWORD dwLex, PWORD_INFO_BUFFER pInfo, PINDEXES_BUFFER pIndexes, DWORD *pdwLexTypeFound, GUID *pGuidLexFound);
   HRESULT EnginePhoneToIPA      (PSTR pIntPhone, PWSTR pIPA);
   HRESULT LTSPhoneToIPA         (PSTR pIntPhone, PWSTR pIPA);
   HRESULT IPAToEnginePhone      (PWSTR pIPA, PSTR pIntPhone);

   void    SetBuildMode          (bool f) { m_fBuild = f; };

private:

   HRESULT ToIPA                 (PSTR pIntPhone, PWSTR pIPA, PBYTE pIndex, DWORD nIndex);
   HRESULT FromIPA               (PWSTR pIPA, PSTR pIntPhone, PBYTE pIndex, DWORD nIndex);

   LONG                 m_cRef;
   CVendorManager       *m_pMgr;
   BOOL                 m_fAuthenticated;
   CRITICAL_SECTION     m_cs;                // Critical section to prevent multiple Inits
   bool                 m_fInit;             // To prevent multiple Inits
   

   LCID                 m_Lcid;              // LCID
   GUID                 m_gLexiconId;        // Lexicon GUID

   BYTE                 *m_pLtsData;
   HANDLE               m_hLtsMap;
   HANDLE               m_hLtsFile;

   PHONEID              *m_pIntPhoneIPAIdMap;// IPA to internal phone map
   ULONG                m_uIntPhoneIPAIdMap; // Length of phone - IPAmap
   
   PBYTE                m_pLTSPhoneIPAIndex; // Index to go from LTS phones to IPA
   ULONG                m_uLTSPhones;        // Length of m_pLTSPhoneIPAIndex

   PBYTE                m_pEngPhoneIPAIndex; // Index to go from engine phones to IPA
   ULONG                m_uEnginePhones;     // Length of m_pLTSPhoneIPAIndex

   PBYTE                m_pIPAEngPhoneIndex; // Index to go from IPA to engine phones

   bool                 m_fBuild;            // Eliminate some preprocessing if in build-mode

   LTS_FOREST           *m_pLTSForest;
   CPreProc             *m_pp;               // pre-processor
};

typedef CLTS *PLTS;

// The lookup lexicon class
class CLookup : public CVendorLexicon
{
public:

   CLookup(CVendorManager *);
   virtual ~CLookup();
   void _Constructor(CVendorManager *pMgr);
   void _Destructor(void);
   HRESULT Init(PCWSTR pwLkupFileName, PCWSTR pwLtsFileName);
   HRESULT _Init(PCWSTR pwLkupFileName, PCWSTR pwLtsFileName);

   STDMETHODIMP_(ULONG) AddRef();
   STDMETHODIMP_(ULONG) Release();
   STDMETHODIMP         QueryInterface(REFIID, LPVOID*);

	STDMETHODIMP GetHeader(LEX_HDR *pLexHdr);
	STDMETHODIMP Authenticate(GUID ClientId, GUID *LexId);
	STDMETHODIMP IsAuthenticated(BOOL *pfAuthenticated);
	STDMETHODIMP GetWordInformation (const WCHAR *pwWord, LCID lcid, DWORD dwTypes, DWORD dwLex, PWORD_INFO_BUFFER pInfo, PINDEXES_BUFFER pIndexes, DWORD *pdwLexTypeFound, GUID *pGuidLexFound);

   STDMETHODIMP AddWordInformation(const WCHAR * pwWord, LCID lcid, PWORD_INFO_BUFFER pInfo)
   {
      return m_RWLex.AddWordInformation(pwWord, lcid, pInfo);
   }

   STDMETHODIMP RemoveWord (PCWSTR pwWord, LCID lcid)
   {
      return m_RWLex.RemoveWord (pwWord, lcid);
   }

   __forceinline PLTS    GetLTSObject      (void) { return m_pLts; }

   HRESULT Shutdown (bool fSerialize);

private:

   __forceinline DWORD    GetCmpHashEntry   (DWORD dhash);
   __forceinline bool     CompareHashValue  (DWORD dhash, DWORD d);
                 void     CopyBitsAsDWORDs  (PDWORD pDest, PDWORD pSource, 
                                             DWORD dSourceOffset, DWORD nBits);
   __forceinline HRESULT  ReadWord          (DWORD *dOffset, PWSTR pwWord);
   __forceinline HRESULT  ReadWordInfo      (PWSTR pWord, WORDINFOTYPE Type, DWORD *dOffset,
                                             PBYTE pProns, DWORD dLen, DWORD *pdLenRequired);

   LONG m_cRef;
   CVendorManager    *m_pMgr;
   BOOL m_fAuthenticated;
   bool              m_fInit;          // Call Init() only once
   WCHAR             m_wszLkupFile[MAX_PATH]; // The disk file for this lookup object
   WCHAR             m_wszLtsFile[MAX_PATH];  // The disk file for thie lts object

   CDict             m_RWLex;          // The RW lexicon object used as a cache to store added words
                                       // before they are merged in the lookup lexicon

   HANDLE            m_hInitMutex;     // Handle to the init mutex
   HANDLE            m_hLkupFile;      // Handle to lookup file
   HANDLE            m_hLkupMap;       // Handle to map on lookup file
   PBYTE             m_pLkup;          // Pointer to view on map on lookup file
   PBYTE             m_pWordHash;      // Word hash table holding offsets into the compressed block
   PDWORD            m_pCmpBlock;      // Pointer to compressed block holding words + CBs + prons
   PINT              m_pRefCount;      // Pointer to an int that is ref count
   HANDLE            m_hRefMapping;    // Handle to the mapfile to the ref counter

   PLKUPLEXINFO      m_pLkupLexInfo;   // Lookup lex info header
   LCID              m_Lcid;           // Language Id

   CHuffDecoder      *m_pWordsDecoder; // Huffman decoder for words
   CHuffDecoder      *m_pPronsDecoder; // Huffman decoder for pronunciations
   CHuffDecoder      *m_pPosDecoder;   // Huffman decoder for part of speech

   PLTS              m_pLts;           // LTS object to get LTS pronunciations
};

typedef CLookup *PLOOKUP;


void towcslower (PWSTR pw);

DWORD GetWordHashValueStub (PWSTR pszWord, DWORD nLengthHash);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\lexicon.cpp ===
/*****************************************************************************
*  Lexicon.cpp
*     Implements the ILxLexicon, ILxWalkStates and ILxAdvanced interfaces as a
*     single class.
*
*  Owner: YunusM
*
*  Copyright 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#include "PreCompiled.h"

#pragma warning(disable : 4100)

static const PSTR pSetUserMutex = "12955068-098F-11d3-9C24-00C04F8EF87C";

// BUGBUG: Change m_cs to a light weight reader/writer lock. Wouldnt need this lock
// if user and app lex are not settable multiple times

/*****************************************************************************
* CLexicon *
*----------*
*  Constructor - returns the result on the stack which eliminates the Init call
*
*  Return: S_OK, E_FAIL
**********************************************************************YUNUSM*/
CLexicon::CLexicon(
                   CAPIManager *pMgr,     // Manager object pointer
                   HRESULT &hr            // Returned hResult
                   )
{              
   hr = S_OK;

   m_pMgr = pMgr;
   m_cRef = 0;
   m_pwUserName = NULL;
   m_pwUserLexFile = NULL;
   m_pUserLex = NULL;
   m_pwAppLexFile = NULL;
   m_pAppLex = NULL;
   m_nVendorLexs = 0;
   m_pVendorLexs = NULL;
   m_hSetUserMutex = NULL;
   m_pNotifySink = NULL;
   m_pAuthenticateSink = NULL;
   m_pCustomUISink = NULL;
   m_pHookLexiconObject = NULL;
   m_fHookPosition = false;

   __try
   {
      InitializeCriticalSection(&m_cs);
   }
   __except(NULL)
   {
      hr = E_FAIL;
   }
} // CLexicon::CLexicon(CAPIManager *pMgr, HRESULT &hr)


/*****************************************************************************
* _ReleaseUservendorLexs *
*------------------------*
*  Release the user and vendor lexicons
*
*  Return: CDict::Serialize()
**********************************************************************YUNUSM*/
HRESULT CLexicon::_ReleaseUserVendorLexs(void)
{
   HRESULT hr = S_OK;

   _ASSERTE(_CrtCheckMemory());

   if (m_pVendorLexs)
   {
      for (DWORD i = 0; i < m_nVendorLexs; i++)
      {
         _ASSERTE(_CrtCheckMemory());

         m_pVendorLexs[i]->Release();
      }
   }

   free(m_pVendorLexs);
   m_pVendorLexs = NULL;
   m_nVendorLexs = NULL;

   if (m_pUserLex)
   {
      hr = m_pUserLex->Serialize(false);
      _ASSERTE (SUCCEEDED(hr));
   }

   free(m_pwUserLexFile);
   m_pwUserLexFile = NULL;

   free(m_pwUserName);
   m_pwUserName = NULL;

   if (m_pUserLex)
   {
      delete(m_pUserLex);
      m_pUserLex = NULL;
   }

   return hr;
} // HRESULT CLexicon::_ReleaseUserVendorLexs(void)


/*****************************************************************************
* _ReleaseAppLex *
*----------------*
*  Release the app lexicon
**********************************************************************YUNUSM*/
void CLexicon::_ReleaseAppLex(void)
{
   free(m_pwAppLexFile);
   m_pwAppLexFile = NULL;

   if (m_pAppLex)
   {
      delete m_pAppLex;
      m_pAppLex = NULL;
   }
} // HRESULT CLexicon::_ReleaseAppLex(void)


/*****************************************************************************
* ~CLexicon *
*-----------*
*  Destructor
**********************************************************************YUNUSM*/
CLexicon::~CLexicon()
{
   _ReleaseUserVendorLexs();
   _ReleaseAppLex();

   if (m_pNotifySink)
      m_pNotifySink->Release();

   if (m_pAuthenticateSink)
      m_pAuthenticateSink->Release();

   if (m_pCustomUISink)
      m_pCustomUISink->Release();

   if (m_pHookLexiconObject)
      m_pHookLexiconObject->Release();

   ReleaseMutex(m_hSetUserMutex);

   DeleteCriticalSection(&m_cs);
} // CLexicon::~CLexicon()


/*****************************************************************************
* AddRef *
*--------*
*  Delegates the AddRef to the manager
*
*  Return : new count
**********************************************************************YUNUSM*/
STDMETHODIMP_ (ULONG) CLexicon::AddRef()
{
   m_pMgr->AddRef();
   return ++m_cRef;
} // STDMETHODIMP_ (ULONG) CLexicon::AddRef()


/*****************************************************************************
* Release *
*---------*
*  Delegates the Release to the manager
*
*  Return : new count
**********************************************************************YUNUSM*/
STDMETHODIMP_ (ULONG) CLexicon::Release()
{
   ULONG i = --m_cRef;
   m_pMgr->Release();
   return i;
} // STDMETHODIMP_ (ULONG) CLexicon::Release()


/*****************************************************************************
* QueryInterface *
*----------------*
*  Delegates the QueryInterface to the manager
*
*  Return : NOERROR, E_NOINTERFACE
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::QueryInterface(
                                      REFIID riid,       // IID of the interface
                                      LPVOID FAR * ppv   // pointer to the interface returned
                                      )
{
   return m_pMgr->QueryInterface(riid, ppv);
}

//-------------- ILxLexicon implementation -----------------------------------


/*****************************************************************************
* GetUser *
*---------*
*  Get the current user
*
*  Return : E_POINTER, E_INVALIDARG, E_OUTOFMEMORY, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetUser(
                               WCHAR **ppwUserName  // user name to set - If the call succeeds the 
                                                    // client should CoTaskMemFree *pwUserName
                               )
{
   if (!ppwUserName)
      return E_POINTER;

   if (IsBadWritePtr(*ppwUserName, sizeof(WCHAR*)))
      return E_INVALIDARG;

   if (!m_pUserLex)
      return LEXERR_SETUSERLEXICON;

   HRESULT hr = S_OK;

   EnterCriticalSection(&m_cs);

   *ppwUserName = (PWSTR)CoTaskMemAlloc(wcslen(m_pwUserName) * sizeof(WCHAR));
   if (!*ppwUserName)
   {
      hr = E_OUTOFMEMORY;
      goto ReturnGetUser;
   }

   wcscpy(*ppwUserName, m_pwUserName);

ReturnGetUser:

   LeaveCriticalSection(&m_cs);

   return hr;
} // STDMETHODIMP CLexicon::GetUser()


/*****************************************************************************
* SetUser *
*---------*
*  Sets the user. Loads the new user lexicon. If one does not exist it creates one.
*  Loads the vendor lexicons which this user wants to use. A lexicon is loaded if
*  it supports atleast one of the LCIDs that the user is interested in
*  If a use is already set then that user's user lexicon is serialized and the vendor
*  lexicons are unloaded.
*
*  Return : E_POINTER, E_INVALIDARG, E_OUTOFMEMORY, E_FAIL, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::SetUser(
                               WCHAR *pwUserName,  // User name to set
                               DWORD cLcids,       // Number of lcids this user is interested in
                               LCID *pLcid         // pointer to the the Lcid array
                               )
{
   if (!pwUserName)
      return E_POINTER;

   if (LexIsBadStringPtr(pwUserName))
      return E_INVALIDARG;

   if (cLcids)
   {
      if (!pLcid)
         return E_POINTER;

      if (IsBadReadPtr(pLcid, cLcids * sizeof(LCID)))
         return E_INVALIDARG;
   }

   HRESULT hr = S_OK;
   BOOL *pfUse = NULL;

   EnterCriticalSection(&m_cs);

   // Acquire an exclusive lock because we are modifying the registry here
   m_hSetUserMutex = CreateMutex(NULL, FALSE, pSetUserMutex);
   if (!m_hSetUserMutex)
   {
      hr = HRESULT_FROM_WIN32(GetLastError ());
      goto ReturnSetUser;
   }

   WaitForSingleObject(m_hSetUserMutex, INFINITE);

   if (m_pUserLex)
      hr = _ReleaseUserVendorLexs();

   // Query the registry for this user
   char szUserName[MAX_PATH];
   if (!WideCharToMultiByte(CP_ACP, 0, pwUserName, -1, szUserName, MAX_PATH, NULL, NULL))
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      goto ReturnSetUser;
   }

   char szSubKey[MAX_PATH];
   strcpy(szSubKey, "SOFTWARE\\Microsoft\\Lexicon\\User\\");
   strcat(szSubKey, szUserName);

   HKEY hKey;
   DWORD dwDisposition;
   LONG lRet;
   bool fCreated;
   
   lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, NULL, 0, 0, NULL, &hKey, &dwDisposition);

   RegCloseKey(hKey);
   if (ERROR_SUCCESS != lRet  && REG_OPENED_EXISTING_KEY != dwDisposition)
   {
      hr = E_FAIL;
      goto ReturnSetUser;
   }

   (REG_OPENED_EXISTING_KEY == dwDisposition) ? fCreated = false : fCreated = true;

   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_ALL_ACCESS, &hKey);
   if (ERROR_SUCCESS != lRet)
   {
      hr = E_FAIL;
      goto ReturnSetUser;
   }

   char szUserLexDir[MAX_PATH];
   WCHAR wszUserLexDir[MAX_PATH];

   // BUGBUG: Where to store the user lexicon? Cannot use the roaming profile in ZAW. Unsupported on 9X and CE
   strcpy(szUserLexDir, "C:\\UserLexicons");
   CreateDirectory(szUserLexDir, NULL);

   DWORD dwType;       
   DWORD dwSizeRet;

   // Get the path the store the user lexicon file
   if (true == fCreated)
   {
      lRet = RegSetValueEx(hKey, "UserLexicon", 0, REG_SZ, (PBYTE)szUserLexDir, (strlen(szUserLexDir) + 1)*sizeof(char));
      if (ERROR_SUCCESS != lRet)
      {
         hr = E_FAIL;
         goto ReturnSetUser;
      }

      // Enumerate the vendor lexicons and add them to this user
      HKEY hKeyVendor;
      lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Lexicon\\Vendor", 0, KEY_ALL_ACCESS, &hKeyVendor);
      if (ERROR_SUCCESS != lRet)
      {
         hr = E_FAIL;
         goto ReturnSetUser;
      }

      char szValueName[256];
      DWORD cbValueName;
      BYTE bValueData[512];
      DWORD cbValueData;
      DWORD dwIndex;

      dwIndex = 0;
      cbValueName = 256;
      cbValueData = 512;

      while (ERROR_SUCCESS == (lRet = RegEnumValue(hKeyVendor, dwIndex++, szValueName, &cbValueName, NULL, &dwType, bValueData, &cbValueData)))
      {
         lRet = RegSetValueEx(hKey, szValueName, 0, REG_EXPAND_SZ, bValueData, cbValueData);
         if (ERROR_SUCCESS != lRet)
         {
            hr = E_FAIL;
            goto ReturnSetUser;
         }

         cbValueName = 256;
         cbValueData = 512;
      }
      
      if (ERROR_NO_MORE_ITEMS != lRet)
      {
         hr = E_FAIL;
         goto ReturnSetUser;
      }
   }
   else
   {
      lRet = RegQueryValueEx(hKey, "UserLexicon", NULL, &dwType, (PBYTE)szUserLexDir, &dwSizeRet);
      if (ERROR_SUCCESS != lRet)
      {
         hr = E_FAIL;
         goto ReturnSetUser;
      }
   }

   MultiByteToWideChar(CP_ACP, MB_COMPOSITE, szUserLexDir, -1, wszUserLexDir, MAX_PATH);

   m_pwUserName = (PWSTR)malloc((wcslen(pwUserName) + 1) * sizeof(WCHAR));
   if (!m_pwUserName)
   {
      hr = E_OUTOFMEMORY;
      goto ReturnSetUser;
   }

   m_pwUserLexFile = (PWSTR) malloc((wcslen(wszUserLexDir) + wcslen(pwUserName) + wcslen(L".lex") + 8) * sizeof(WCHAR));
   if (!m_pwUserLexFile)
   {
      hr = E_OUTOFMEMORY;
      goto ReturnSetUser;
   }

   wcscpy(m_pwUserLexFile, wszUserLexDir);

   if (m_pwUserLexFile[wcslen(m_pwUserLexFile) - 1] != L'\\')
      wcscat(m_pwUserLexFile, L"\\");

   wcscat(m_pwUserLexFile, pwUserName);
   wcscat(m_pwUserLexFile, L".lex");

   m_pUserLex = new CDict();
   if (!m_pUserLex)
   {
      hr = E_OUTOFMEMORY;
      goto ReturnSetUser;
   }

   hr = m_pUserLex->Init(m_pwUserLexFile, LEXTYPE_USER);
   if (FAILED(hr))
      goto ReturnSetUser;

   // Load the vendor lexs
   
   DWORD dwIndex;

   char szValueName[256];
   DWORD cbValueName;
   BYTE bValueData[2048];
   DWORD cbValueData;

   dwIndex = 0;
   cbValueName = 256;
   cbValueData = 2048;

   while (ERROR_SUCCESS == (lRet = RegEnumValue(hKey, dwIndex++, szValueName, &cbValueName, NULL, &dwType, bValueData, &cbValueData)))
   {
      // CAUTION: These values shouldnot be used in the rest of loop
      cbValueName = 256;
      cbValueData = 2048;

      if (!strcmp(szValueName, "UserLexicon"))
         continue;

      PVENDOR_CLSID_LCID_HDR pHdr = (PVENDOR_CLSID_LCID_HDR)bValueData;

      // check if this vendor lex supports any of the lcids passed in for this user

      for (DWORD i = 0; i < cLcids; i++)
      {
         for (DWORD j = 0; j < pHdr->cLcids; j++)
         {
            if (pLcid[i] == pHdr->aLcidsSupported[j] || pLcid[i] == DONT_CARE_LCID)
               goto LCIDFOUND;
         }
      }

      continue;

LCIDFOUND:

      // this vendor lex supports atleast one of the Lcids this user wants - so load it
      m_nVendorLexs++;

      ILxLexiconObject **p = (ILxLexiconObject**) realloc(m_pVendorLexs, m_nVendorLexs * sizeof(PILXLEXICONOBJECT));
      if (!p)
      {
         hr = E_OUTOFMEMORY;
         goto ReturnSetUser;
      }

      m_pVendorLexs = p;

      hr = CoCreateInstance(pHdr->CLSID, NULL, CLSCTX_INPROC_SERVER, IID_ILxLexiconObject, (LPVOID*)&(m_pVendorLexs[m_nVendorLexs-1]));
      if (FAILED(hr))
         goto ReturnSetUser;
   }

   RegCloseKey(hKey);

   // Authenticate the vendor lexicons
   if (m_pAuthenticateSink)
   {
      BOOL *pfUse = (BOOL *)calloc(m_nVendorLexs, sizeof(BOOL));
      if (!pfUse)
         goto ReturnSetUser;

      hr = m_pAuthenticateSink->AuthenticateVendorLexicons(m_nVendorLexs, m_pVendorLexs, pfUse);
      if (FAILED(hr))
         goto ReturnSetUser;

      // Verify if the vendor lex wants to use an engine if that engine wants to use the lex
      for (DWORD i = 0; i < m_nVendorLexs; i++)
      {
         BOOL f;
         m_pVendorLexs[i]->IsAuthenticated(&f);

         if (FALSE == f)
         {
            m_pVendorLexs[i]->Release();
            m_pVendorLexs[i] = NULL;
         }
      }
   }

ReturnSetUser:

   if (FAILED(hr))
   {
      _ReleaseUserVendorLexs();

      if (pfUse)
         free(pfUse);
   }
   else if (m_pNotifySink)
      m_pNotifySink->NotifyUserLexiconChange();

   ReleaseMutex(m_hSetUserMutex);
   LeaveCriticalSection(&m_cs);

   return hr;
} // STDMETHODIMP CLexicon::SetUser(WCHAR *pwUserName, WCHAR *pwUserLexDir)


/*****************************************************************************
* SetAppLexicon *
*---------------*
*  Sets the application lexicon. If an application lexicon is already set it unloads
*  the current lexicon and loads the new lexicon
*
*  Return : E_POINTER, E_INVALIDARG, E_OUTOFMEMORY, E_FAIL, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::SetAppLexicon(
                                     WCHAR *pwPathFileName // App lexicon file name with path
                                     )
{
   if (!pwPathFileName)
      return E_POINTER;

   if (LexIsBadStringPtr(pwPathFileName))
      return E_INVALIDARG;
   
   EnterCriticalSection(&m_cs);

   HRESULT hr = S_OK;

   if (m_pAppLex)
      _ReleaseAppLex();

   m_pwAppLexFile = (PWSTR) malloc((wcslen (pwPathFileName) + 1)* sizeof (WCHAR));
   if (!m_pwAppLexFile)
   {
      hr = E_OUTOFMEMORY;
      goto ReturnSetApp;
   }

   wcscpy(m_pwAppLexFile, pwPathFileName);

   m_pAppLex = new CDict();
   if (!m_pAppLex)
   {
      hr = E_OUTOFMEMORY;
      goto ReturnSetApp;
   }

   hr = m_pAppLex->Init(m_pwAppLexFile, LEXTYPE_APP);
   if (FAILED(hr))
      goto ReturnSetApp;

ReturnSetApp:

   if (FAILED(hr))
      _ReleaseAppLex();
   else if (m_pNotifySink)
      m_pNotifySink->NotifyAppLexiconChange();

   LeaveCriticalSection(&m_cs);

   return hr;

} // STDMETHODIMP CLexicon::SetAppLexicon(WCHAR *pwPathFileName)


/*****************************************************************************
* GetWordPronunciations *
*-----------------------*
*  Gets the pronunciations of the word - Is a special case of GetWordInformation
*
*  Return : E_POINTER, E_INVALIDARG, LEXERR_NOTINLEX, E_OUTOFMEMORY, E_FAIL, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetWordPronunciations(
                                             const WCHAR *pwWord,       // Word string                                              
                                             LCID lcid,                 // Lcid on which to search this word - can be DONT_CARE_LCID
                                             DWORD dwLex,               // OR of the LEXTYPES                                       
                                             PWORD_PRONS_BUFFER pProns, // Buffer in which prons are returned                       
                                             PINDEXES_BUFFER pIndexes,  // Buffer holding indexes to pronunciations                 
                                             DWORD *pdwLexTypeFound,    // Lex type of the lexicon in which the word and its prons were found (can be NULL)
                                             GUID *pGuidLexFound        // Lex GUID in which the word and its prons were found (can be NULL)
                                             )
{
   HRESULT hr = LEXERR_NOTINLEX;

   if (!pwWord || !pProns || !pIndexes)
      return E_POINTER;

   if (LexIsBadStringPtr(pwWord) || 
      IsBadWritePtr(pProns, sizeof (WORD_PRONS_BUFFER)) || 
      IsBadWritePtr(pIndexes, sizeof(pIndexes)) ||
      (pdwLexTypeFound && IsBadWritePtr(pdwLexTypeFound, sizeof(DWORD))) ||
      (pGuidLexFound && IsBadWritePtr(pGuidLexFound, sizeof(GUID))))
      return E_INVALIDARG;

   // BUGBUG: Validate input WORD_PRONS_BUFFER and INDEXES_BUFFER

   WORD_INFO_BUFFER WI;
   INDEXES_BUFFER IB;

   ZeroMemory(&WI, sizeof(WI));
   ZeroMemory(&IB, sizeof(IB));

   hr = GetWordInformation(pwWord, lcid, PRON, dwLex, &WI, &IB, pdwLexTypeFound, pGuidLexFound);

   if (SUCCEEDED(hr))
      hr = _InfoToProns(&WI, &IB, pProns, pIndexes);

   if (SUCCEEDED(hr))
   {
      CoTaskMemFree(WI.pInfo);
      CoTaskMemFree(IB.pwIndex);
   }

   return hr;
} // STDMETHODIMP CLexicon::GetWordPronunciations


/*****************************************************************************
* GetWordPronunciations *
*-----------------------*
*  Gets the information of the word
*
*  Return : E_POINTER, E_INVALIDARG, LEXERR_NOTINLEX, E_OUTOFMEMORY, E_FAIL, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetWordInformation(
                                          const WCHAR *pwWord,       // Word string                                               
                                          LCID lcid,                 // Lcid on which to search this word - can be DONT_CARE_LCID
                                          DWORD dwTypes,             // OR of types of word information to retrieve              
                                          DWORD dwLex,               // OR of the LEXTYPES                                       
                                          PWORD_INFO_BUFFER pInfo,   // Buffer in which word info are returned                   
                                          PINDEXES_BUFFER pIndexes,  // Buffer holding indexes to pronunciations                 
                                          DWORD *pdwLexTypeFound,    // Lex type of the lexicon in which the word and its prons were found (can be NULL)
                                          GUID *pGuidLexFound        // Lex GUID in which the word and its prons were found (can be NULL)
                                          )
{
   HRESULT hr = S_OK;


   if (!pwWord)
      return E_POINTER;

   if (lcid != lcid)
      return LEXERR_BADLCID;
   
   if (_AreBadWordInfoTypes(dwTypes))
      return LEXERR_BADINFOTYPE;

   if (_AreBadLexTypes(dwLex))
      return LEXERR_BADLEXTYPE;

   if (_IsBadWordInfoBuffer(pInfo, lcid, false))
      return LEXERR_BADWORDINFOBUFFER;

   if (_IsBadIndexesBuffer(pIndexes))
      return LEXERR_BADINDEXBUFFER;

   if (pdwLexTypeFound && IsBadWritePtr(pdwLexTypeFound, sizeof(DWORD)) ||
       pGuidLexFound && IsBadWritePtr(pGuidLexFound, sizeof(GUID)))
      return E_INVALIDARG;

   EnterCriticalSection(&m_cs);

   // First query the user lexicon
   if (dwLex & LEXTYPE_USER)
   {
      hr = m_pUserLex->GetWordInformation(pwWord, lcid, dwTypes, pInfo, pIndexes, pdwLexTypeFound, pGuidLexFound);
      if (FAILED(hr))
      {
         if (LEXERR_NOTINLEX != hr)
            goto ReturnGetWordInformation;
      }
      else
         goto ReturnGetWordInformation;
   }

   // Next query the app lexicon
   if ((dwLex & LEXTYPE_APP) && m_pAppLex)
   {
      hr = m_pAppLex->GetWordInformation(pwWord, lcid, dwTypes, pInfo, pIndexes, pdwLexTypeFound, pGuidLexFound);
      if (FAILED(hr))
      {
         if (LEXERR_NOTINLEX != hr)
            goto ReturnGetWordInformation;
      }
      else
         goto ReturnGetWordInformation;
   }

   // Next query the vendor lexicons
   if (dwLex & (LEXTYPE_VENDOR | LEXTYPE_GUESS))
   {
      if (m_pHookLexiconObject && m_fHookPosition)
      {
         hr = m_pHookLexiconObject->GetWordInformation(pwWord, lcid, dwTypes, dwLex, pInfo, pIndexes, pdwLexTypeFound, pGuidLexFound);
      }

      DWORD i;
      for (i = 0; i < m_nVendorLexs; i++)
      {
         if (!m_pVendorLexs[i])
            continue;

         hr = (m_pVendorLexs[i])->GetWordInformation(pwWord, lcid, dwTypes, dwLex, pInfo, pIndexes, pdwLexTypeFound, pGuidLexFound);
         if (FAILED(hr))
            continue;
         else
            goto ReturnGetWordInformation;
      }

      if (m_pHookLexiconObject)
      {
         hr = m_pHookLexiconObject->GetWordInformation(pwWord, lcid, dwTypes, dwLex, pInfo, pIndexes, pdwLexTypeFound, pGuidLexFound);
      }

      goto ReturnGetWordInformation;
   }

ReturnGetWordInformation:

   LeaveCriticalSection(&m_cs);
	return hr;
} // STDMETHODIMP CLexicon::GetWordInformation()


/*****************************************************************************
* AddWordPronunciations *
*-----------------------*
*  Add a word and its pronunciations
*
*  Return : E_POINTER, E_INVALIDARG, LEXERR_SETUSERLEXICON, E_OUTOFMEMORY, E_FAIL, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::AddWordPronunciations(
                                             const WCHAR * pwWord,      // Word to add                   
                                             LCID lcid,                 // LCID of this word             
                                             WORD_PRONS_BUFFER *pProns  // Pronunciation(s) for this word
                                             )
{
   HRESULT hr = S_OK;

   if (!pwWord || !pProns)
      return E_POINTER;

   if (LexIsBadStringPtr(pwWord) || IsBadReadPtr(pProns, sizeof(WORD_PRONS_BUFFER)))
      return E_INVALIDARG;

   // Convert pProns to a WORD_INFO_BUFFER
   WORD_INFO_BUFFER WI;
   
   ZeroMemory(&WI, sizeof(WI));
   hr = _PronsToInfo(pProns, &WI);
   if (FAILED(hr))
      return hr;

   EnterCriticalSection(&m_cs);
   
   hr = m_pUserLex->AddWordInformation (pwWord, lcid, &WI);
   if (SUCCEEDED(hr) && m_pNotifySink)
      m_pNotifySink->NotifyUserLexiconChange();

   LeaveCriticalSection(&m_cs);

   CoTaskMemFree(WI.pInfo);

   return hr;

} // STDMETHODIMP CLexicon::AddWordPronunciations


/*****************************************************************************
* AddWordInformation *
*--------------------*
*  Add a word and its information
*
*  Return : E_POINTER, E_INVALIDARG, LEXERR_SETUSERLEXICON, E_OUTOFMEMORY, E_FAIL, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::AddWordInformation(
                                          const WCHAR * pwWord,   // Word to add                 
                                          LCID lcid,              // LCID of this word           
                                          PWORD_INFO_BUFFER pInfo // Information(s) for this word
                                          )
{
   HRESULT hr = S_OK;

   if (!pwWord || !pInfo)
      return E_POINTER;

   if (LexIsBadStringPtr(pwWord) || IsBadReadPtr(pInfo, sizeof(WORD_INFO_BUFFER)))
      return E_INVALIDARG;

   EnterCriticalSection(&m_cs);

   if (m_pUserLex)
      hr = m_pUserLex->AddWordInformation (pwWord, lcid, pInfo);
   else
      hr = LEXERR_SETUSERLEXICON;

   if (SUCCEEDED(hr) && m_pNotifySink)
      m_pNotifySink->NotifyUserLexiconChange();

   LeaveCriticalSection(&m_cs);

   return hr;

} // STDMETHODIMP CLexicon::AddWordInformation


/*****************************************************************************
* RemoveWord *
*------------*
*  Remove a word and its information
*
*  Return : E_POINTER, E_INVALIDARG, LEXERR_SETUSERLEXICON, E_FAIL, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::RemoveWord(
                                  const WCHAR *pwWord,   // Word to remove     
                                  LCID lcid              // LCID of this word 
                                  )
{
   HRESULT hr = S_OK;

   if (!pwWord)
      return E_POINTER;

   if (LexIsBadStringPtr(pwWord) || _IsBadLcid(lcid))
      return E_INVALIDARG;

   EnterCriticalSection(&m_cs);

   if (m_pUserLex)
      hr = m_pUserLex->RemoveWord (pwWord, lcid);
   else
      hr = LEXERR_SETUSERLEXICON;

   if (SUCCEEDED(hr) && m_pNotifySink)
      m_pNotifySink->NotifyUserLexiconChange();

   LeaveCriticalSection(&m_cs);

   return hr;

} // STDMETHODIMP CLexicon::RemoveWord


/*****************************************************************************
* InvokeLexiconUI *
*-----------------*
*  Invoke the lexicon UI
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::InvokeLexiconUI(void)
{
   HRESULT hr = S_OK;

   if (m_pCustomUISink)
      hr = m_pCustomUISink->InvokeCustomUI();
   else
      hr = E_NOTIMPL;

   return hr;
} // STDMETHODIMP CLexicon::InvokeLexiconUI(void)


//-------------- ILxWalkStates implementation --------------------------------

/*****************************************************************************
* GetLexCount *
*-------------*
*  Get the number of user, app and vendor lexicons
*  This is called by the client to get the total number of lexicons and then to allocate
*  that many SEARCH_STATEs if it wants to call the low level API on eanh of the lexicons
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetLexCount(
                                   DWORD *dwNumUserLex,     // number of user lexicons   
                                   DWORD *dwNumAppLex,      // number of app lexicons    
                                   DWORD *dwNumVendorLex    // number of vendor lexicons 
                                   )
{
   return E_NOTIMPL;
} // STDMETHODIMP CLexicon::GetLexCount()


/*****************************************************************************
* GetSibling *
*------------*
*  Get the next sibling
*  The client allocates as many SEARCH_STATEs as the number of lexicons it wants to query.
*  The client initializes all members of each SEARCH_STATE to be zero except the dwLex which
*  the clients sets to the lexicon for which this SEARCH_STATE is to be queried
*  For a lexicon type for which there is more than one lexicon like the vendor lexicon the
*  dwLex should be set to vendor lexicon for that many SEARCH_STATEs and the API will go to
*  that many vendor lexicons and gets their states
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetSibling(
                                  DWORD dwNumSearchStates,  // number of SEARCH_STATEs 
                                  SEARCH_STATE *pState      // array of SEARCH_STATEs 
                                  )
{
   return E_NOTIMPL;
} // STDMETHODIMP CLexicon::GetSibling()


/*****************************************************************************
* GetChild *
*----------*
*  Get the child. Rest foi comments as in GetSibling
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetChild(
                                DWORD dwNumSearchStates, 
                                SEARCH_STATE *pState
                                )
{
   return E_NOTIMPL;
} // STDMETHODIMP CLexicon::GetChild()


/*****************************************************************************
* FindSibling *
*-------------*
*  Find a sibling
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::FindSibling(
                                   DWORD dwNumSearchStates, 
                                   WCHAR wNodeChar, 
                                   SEARCH_STATE *pState
                                   )
{
   return E_NOTIMPL;
} // STDMETHODIMP CLexicon::FindSibling()

//-------------- ILxAdvanced implementation ----------------------------------


/*****************************************************************************
* AddWordProbabilities *
*----------------------*
*  Adds a word with LM probabilities distributed over the chars of the word
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::AddWordProbabilities(
                                  WCHAR *pwWord,      // Word to add                                
                                  DWORD dwNumChars,   // Number of characters                       
                                  float *pflProb      // array of float probabilities for characters
                                  )
{
   return E_NOTIMPL;
} // STDMETHODIMP CLexicon::AddWordProbabilities()


/*****************************************************************************
* GetWordInString *
*-----------------*
*  Given a string return a word >= minimum len
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetWordInString(
                             WCHAR *pwString,      // string of NULL terminated characters                                   
                             DWORD dwMinLen,       // minimum length of word to be found                                     
                             DWORD *pdwStartChar   // Start position (0 based) of the word in string. -1 if no word is found.
                             )
{
   return E_NOTIMPL;
} // STDMETHODIMP CLexicon::GetWordInString()


/*****************************************************************************
* GetWordToken *
*--------------*
*  Given a word return its token - every word has a unique ID which isa combination of Lex GUID and and a DWORD
*  This api walks down the lexicon stack querying the lexicon types specified in dwLex and stops at the first hit
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetWordToken(
                          DWORD dwLex,             // OR of LEXTYPEs     
                          WCHAR *pwWord,           // Word               
                          WORD_TOKEN *pWordToken   // Word token returned
                          )
{
   return E_NOTIMPL;
} // STDMETHODIMP CLexicon::GetWordToken()


/*****************************************************************************
* GetWordFromToken *
*------------------*
*  Given a token return the word
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetWordFromToken(
                           WORD_TOKEN *pWordToken, // Word token                                            
                           WCHAR **ppwWord         // Returned word - should be CoTaskMemFreed by the caller
                           )
{
   return E_NOTIMPL;
} // STDMETHODIMP CLexicon::GetWordFromToken()


/*****************************************************************************
* GetBestPath *
*-------------*
*  Takes the input lattice with probabilities, adds to it the LM probabilities from lexicon and returns the best path
*  BUGBUG: Get the args right
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetBestPath(
                            BYTE *pLattice,        // Lattice with probabilities 
                            BYTE *pBestPath        // Returned best path         
                            )
{
   return E_NOTIMPL;
} // STDMETHODIMP CLexicon::GetBestPath()


//-------------- ILxNotifySource implementation ------------------------------

/*****************************************************************************
* SetNotifySink *
*---------------*
*  Set the notification sink pointers
*
*  Return : E_POINTER, E_INVALIDARG, S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::SetNotifySink(
                                     ILxNotifySink *pNotifySink,              // Notification pointer to an ILxNotifySink (can be NULL)
                                     ILxAuthenticateSink *pAuthenticateSink,  // Notification pointer to an ILxAuthenticateSink (can be NULL)
                                     ILxCustomUISink *pCustomUISink           // Notification pointer to an ILxCustomUISink (can be NULL)
                                     )
{
   //BUGBUG: validate args
   
   EnterCriticalSection(&m_cs);

   // Release old
   if (pNotifySink)
      pNotifySink->Release();

   if (pAuthenticateSink)
      pAuthenticateSink->Release();

   if (pCustomUISink)
      pCustomUISink->Release();

   // Store away
   m_pNotifySink = pNotifySink;
   m_pAuthenticateSink = pAuthenticateSink;
   m_pCustomUISink = pCustomUISink;

   LeaveCriticalSection(&m_cs);

   return S_OK;
} // STDMETHODIMP CLexicon::SetNotifySink()

//-------------- ILxSynchWithLexicon implementation ------------------------------

/*****************************************************************************
* GetAppLexiconID *
*-----------------*
*  Get the app lex id - can be used by the client to check if it has already syned to this app lexicon
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetAppLexiconID(
                                       GUID *pID  // Id of the app lexicon
                                       )
{
   if (!pID)
      return E_POINTER;

   if (IsBadWritePtr(pID, sizeof(GUID)))
      return E_INVALIDARG;

   if (!m_pAppLex)
      return LEXERR_APPLEXNOTSET;

   EnterCriticalSection(&m_cs);

   m_pAppLex->GetId(pID);

   LeaveCriticalSection(&m_cs);

   return S_OK;

} // STDMETHODIMP CLexicon::GetAppLexiconID()


/*****************************************************************************
* GetAppLexicon *
*---------------*
*  Get the app lex entries
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetAppLexicon(
                                     LCID Lcid,                            // LCID of the words to retrieve
                                     GUID AppId,                           // App Lex id
                                     WORD_SYNCH_BUFFER *pWordSynchBuffer   // buffer to get back the app lexicon's words
                                     )
{
   if (!pWordSynchBuffer)
      return E_POINTER;

   if (IsBadWritePtr(pWordSynchBuffer, sizeof(WORD_SYNCH_BUFFER)))
      return E_INVALIDARG;

   if (!m_pAppLex)
      return LEXERR_APPLEXNOTSET;

   HRESULT hr = S_OK;

   EnterCriticalSection(&m_cs);

   GUID Id;
   m_pAppLex->GetId(&Id);

   if (Id != AppId)
   {
      hr = E_INVALIDARG;
      goto ReturnGetAppLexicon;
   }

   hr = m_pAppLex->GetAllWords(Lcid, pWordSynchBuffer);
   if (FAILED(hr))
      goto ReturnGetAppLexicon;

   LeaveCriticalSection(&m_cs);

ReturnGetAppLexicon:

   return hr;
} // STDMETHODIMP CLexicon::GetAppLexicon()


/*****************************************************************************
* GetChangedUserWords *
*---------------------*
*  Get the changed user lexicon's words - The client should call ILxLexicon 
*  (and set dwLex to LEXTYPE_USER) to get the words's info
*
*  Return : E_POINTER E_INVALIDARG S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::GetChangedUserWords(
                                           LCID Lcid,                            // LCID of the words to retrieve
                                           DWORD dwAddGenerationId,              // The current AddGenId of the client
                                           DWORD dwDelGenerationId,              // The current DelGenId of the client
                                           DWORD *pdwNewAddGenerationId,         // The new AddGenId of the client
                                           DWORD *pdwNewDelGenerationId,         // The new DelGenId of the client
                                           WORD_SYNCH_BUFFER *pWordSynchBuffer   // The buffer to return the changed user words
                                           )
{
   if (!pdwNewAddGenerationId || !pdwNewDelGenerationId || !pWordSynchBuffer)
      return E_POINTER;

   if (IsBadWritePtr(pdwNewAddGenerationId, sizeof(DWORD)) ||
       IsBadWritePtr(pdwNewDelGenerationId, sizeof(DWORD)) ||
       IsBadWritePtr(pWordSynchBuffer, sizeof(WORD_SYNCH_BUFFER)))
      return E_INVALIDARG;

   EnterCriticalSection(&m_cs);

   HRESULT hr = GetChangedUserWords(Lcid, dwAddGenerationId, dwDelGenerationId, pdwNewAddGenerationId, 
                                    pdwNewDelGenerationId, pWordSynchBuffer);

   LeaveCriticalSection(&m_cs);

   return hr;
} // STDMETHODIMP CLexicon::GetChangedUserWords()

//-------------- ILxHookLexiconObject implementation -------------------------

/*****************************************************************************
* SetHook *
*---------*
*  Set the hook pointer and set the scope of bypass of LexAPI functionality
*
*  Return : 
**********************************************************************YUNUSM*/
STDMETHODIMP CLexicon::SetHook(
                               ILxLexiconObject *pLexiconObject, // The ILxLexiconObject interface to which the Get/Add/Remove calls are rerouted to by the lexAPI
                               BOOL fTopVendor                   // ILxLexiconObject* is called before calling other registered vendor lexicons. If this is FALSE
                                                                 // then the passed in ILxLexiconObject* is called after calling all other vendor lexicons
                               )
{
   if (!pLexiconObject)
      return E_POINTER;

   if (m_pHookLexiconObject)
      m_pHookLexiconObject->Release();

   EnterCriticalSection(&m_cs);

   m_pHookLexiconObject = pLexiconObject;
   m_fHookPosition = (fTopVendor ? true : false);

   LeaveCriticalSection(&m_cs);

   return S_OK;
} // STDMETHODIMP CLexicon::SetHook()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\huffd.h ===
#ifndef _HUFFD_H_
#define _HUFFD_H_

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
//#include <crtdbg.h>

typedef WORD HUFFKEY;
typedef PWORD PHUFFKEY;

typedef struct _huffnode
{
   WORD     iLeft;
   WORD     iRight;
} HUFF_NODE, *PHUFF_NODE;

class CHuffDecoder
{
public:
   CHuffDecoder              (PBYTE pCodeBook);
   ~CHuffDecoder             ();

   HRESULT Next              (PDWORD pEncodedBuf, int *iBitOffset, PHUFFKEY pKey);

private:
   int         m_nKeys;
   int         m_nLenTree;
   int         m_iRoot;
   PHUFFKEY    m_pHuffKey;
   PHUFF_NODE  m_pDecodeTree;
};
 
#endif // _HUFFD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\ltscart.cpp ===
/******************************************************************************************
Ltscart.c -- CART based LTS

History:

	11/11/96 Li Jiang (lij)
            Yunus Mohammed (yunusm)

This file is copyright (c) 1996, Microsoft Corporation.  All rights 
reserved.
******************************************************************************************/

#include "PreCompiled.h"
#pragma warning(disable : 4100)

/* the following are for exceptions: single letter and NULL output */
static char *bogus_pron = "B OW1 G AH0 S P R AH0 N AH0 N S IY0 EY1 SH AH0 N";
static char *single_letter_pron[] = 
{
"EY1",
"B IY1",
"S IY1",
"D IY1",
"IY1",
"EH1 F",
"JH IY1",
"EY1 CH",
"AY1",
"JH EY1",
"K EY1",
"EH1 L",
"EH1 M",
"EH1 N",
"OW1",
"P IY1",
"K Y UW1",
"AA1 R",
"EH1 S",
"T IY1",
"Y UW0",
"V IY1",
"D AH1 B AH0 L Y UW0",
"EH1 K S",
"W AY1",
"Z IY1"
};


static LTS_HEAP *lts_initialize_heap(void)
{
  LTS_HEAP *heap = (LTS_HEAP *) calloc(1, sizeof(LTS_HEAP));
  if (!heap)
     return NULL;

  heap->hhp_outstr = heap->hhp1;
  heap->hhp_strptr = heap->hhp2;
  heap->hhp_outres = heap->hhp3;
  HhpCreate(heap->hhp_outstr, sizeof(LTS_OUT_STRING), cbBlockDef);
  HhpCreate(heap->hhp_strptr, sizeof(LTS_OUT_STRING *) * MAX_ALT_STRINGS, 
	    cbBlockDef);
  HhpCreate(heap->hhp_outres, sizeof(LTS_OUT_RESULT), cbBlockDef);

  return heap;
} // static LTS_HEAP *lts_initialize_heap(void)


static void lts_free_heap(LTS_HEAP *heap)
{
//  SnapshotHhp(heap->hhp_outstr);
  HhpFree(heap->hhp_outstr);
//  SnapshotHhp(heap->hhp_strptr);
  HhpFree(heap->hhp_strptr);
//  SnapshotHhp(heap->hhp_outres);
  HhpFree(heap->hhp_outres);
  free(heap);
} // static void lts_free_heap(LTS_HEAP *heap)


/*
 * not worthwhile to use binary search with only about 30 entries
 */
static int symbol_to_id(LTS_SYMTAB *tab, char *sym)
{
  int i;
  for (i = 0; i < tab->n_symbols; i++)
    if (stricmp(tab->storage + tab->sym_idx[i], sym) == 0)
      return i;
  return NO_SYMBOL;
} // static int symbol_to_id(LTS_SYMTAB *tab, char *sym)


static char *id_to_symbol(LTS_SYMTAB *tab, int id)
{
  if (id < 0 || id > tab->n_symbols)
    return NULL;
  else
    return tab->storage + tab->sym_idx[id];
} // static char *id_to_symbol(LTS_SYMTAB *tab, int id)


__inline void ODS (const char *format, ...)
{
#ifdef _DEBUG
   
   va_list arglist;
   va_start (arglist, format);

   char buf[2048];
   _vsnprintf(buf, 2048, format, arglist);
   OutputDebugString(buf);

   va_end (arglist);
#endif
}


static void read_symbol(char *sym_file, LTS_SYMTAB *tab)
{
  FILE *fp;
  int ns, len, i;
  char sym[128], *p;

  fp = fopen(sym_file, "r");
  if (!fp)
     return;

  for (len = 0, ns = 0; fscanf(fp, "%s", sym) == 1; ns++)
    len += strlen(sym) + 1;
  /* for NULL symbol */
  ns++;
  len += 2;
  tab->sym_idx = (int *) calloc (ns, sizeof(int));
  if (!tab->sym_idx)
     return;

  tab->n_bytes = len;
  tab->storage = (char *) calloc (tab->n_bytes, sizeof(char));
  if (!tab->storage)
     return;

  tab->n_symbols = ns;

  ODS ("%d symbols\n", ns);

  tab->sym_idx[0] = 0;
  i = 1;
  tab->storage[0] = '@'; // special char for "unavailble context", could be used in questions
  tab->storage[1] = 0;
  p = &(tab->storage[2]);

  rewind(fp);
  for (; fscanf(fp, "%s", sym) == 1; i++) {
    tab->sym_idx[i] = p - tab->storage;
    strcpy(p, sym);
    p += strlen(sym) + 1;
  }

  _ASSERTE(ns == i);
  _ASSERTE(p == tab->storage + tab->n_bytes);
} // static void read_symbol(char *sym_file, LTS_SYMTAB *tab)


static void read_feature(char *feat_file, LTS_SYMTAB *tab, LTS_FEATURE *feat)
{
  FILE *fp = fopen(feat_file, "r");
  if (!fp)
     return;

  int nq = 0, i, sym_idx;
  char line[256], word[64], *cptr;

  while (fgets(line, 256, fp)) 
    if (get_a_word(line, word, ' ') != NULL) nq++;
  feat->n_feat = nq;
  feat->dim = (tab->n_symbols + 31) / 32;
  feat->feature = (int **) calloc(nq, sizeof(int *));
  if (!feat->feature)
     return;

  for (i = 0; i < nq; i++) {
    feat->feature[i] = (int *)calloc(feat->dim, sizeof(int));
    if (!feat->feature[i])
       return;
  }

  rewind(fp);
  for (i = 0; fgets (line, sizeof(line)-1, fp) != NULL; i++) {
    cptr = get_a_word (line, word, ' ');
    if (cptr == NULL)
      {--i; continue;} /* empty line */

    /* get the list of phones that have this feature */
    while ((cptr=get_a_word (cptr, word, ' ')) != NULL) {
      if ((sym_idx = symbol_to_id(tab, word)) == NO_SYMBOL) {
         ODS ("Cannot find symbol <%s> for feature <%d>. ignored.\n", word, i);
	      continue;                                                            
      }
      _ASSERTE(sym_idx < tab->n_symbols);
      SET_BIT(feat->feature[i], sym_idx);
    }
  }
  _ASSERTE(i == nq);
  ODS ("%d features\n", nq);
  fclose (fp);
} // static void read_feature(char *feat_file, LTS_SYMTAB *tab, LTS_FEATURE *feat)


static T_NODE *read_tree(char *treedir, char *sym, int dim)
{
  char filename[256], question[2048];
  float entropy_reduction;
  int parent, lchild, rchild, i, num_nodes, cnt, c1, c2;
  T_NODE **tree_list, *root;
  FILE *fp;

  sprintf(filename, "%s\\%s.tree", treedir, sym);
  fp = fopen(filename, "r");
  if (!fp)
     return NULL;

  /* skip the first line */
  fgets(question, 512, fp);

  num_nodes = 0;
  while (fscanf(fp, "%f %d %d %d %s (%d=%d+%d)", 
		&entropy_reduction, &parent,
                &lchild, &rchild, question, &cnt, &c1, &c2) == 8) {
    if (strlen(question) >= 2047) {
      int *z = 0; z[0] = z[1];
    }

    if (rchild > num_nodes)
      num_nodes = rchild;
  }
  rewind(fp);
  fgets(question, 512, fp);

  tree_list = (T_NODE **) calloc(num_nodes + 1, sizeof(T_NODE *));
  if (!tree_list)
     return NULL;

  for (i = 0; i < num_nodes + 1; i++) {
    tree_list[i] = (T_NODE *) calloc(1, sizeof(T_NODE));
    if (!tree_list[i])
       return NULL;

    tree_list[i]->count = (int *) calloc(dim, sizeof(int));
    if (!tree_list[i]->count)
       return NULL;
  }

  while (fscanf(fp, "%f %d %d %d %s (%d=%d+%d)", &entropy_reduction, &parent,
                &lchild, &rchild, question, &cnt, &c1, &c2) == 8) {
    tree_list[parent]->entropy_dec = entropy_reduction;
    tree_list[parent]->yes_child = tree_list[lchild];
    tree_list[parent]->no_child = tree_list[rchild];
    tree_list[parent]->prod = _strdup(question);
    if (tree_list[parent]->n_samples != 0 &&
	tree_list[parent]->n_samples != cnt) {
      int *z = 0; z[0] = z[1];
    }
    else if (tree_list[parent]->n_samples == 0) /* root */
      tree_list[parent]->n_samples = cnt;
    tree_list[lchild]->n_samples = c1;
    tree_list[rchild]->n_samples = c2;

    /* for debug use */
    tree_list[lchild]->index = lchild;
    tree_list[rchild]->index = rchild;
  }
  fclose(fp);

  root = tree_list[0];
  free(tree_list);

  return root;
} // static T_NODE *read_tree(char *treedir, char *sym, int dim)


static T_NODE **read_forest(char *treedir, LTS_SYMTAB *tab)
{
  int i;
  T_NODE **forest = (T_NODE **) calloc(tab[INPUT].n_symbols, 
					  sizeof(T_NODE *));
  if (!forest)
     return NULL;

  for (i = 1; i < tab->n_symbols; i++)
    forest[i] = read_tree(treedir, id_to_symbol(&(tab[INPUT]), i), 
			  tab[OUTPUT].n_symbols);

  return forest;
} // static T_NODE **read_forest(char *treedir, LTS_SYMTAB *tab)


__inline int ans_simp_question (LTS_FEATURE *feat, SIMPLE_QUESTION question, 
			 LTS_SAMPLE *sample)
{
  SYMBOL id;
  int *phones = feat[question.questype].feature[question.feature];

  SAMPLE_GET_CONTEXT(sample, question.questype, question.context,
                     question.offset, id);

  return (TST_BIT(phones, id) ? TRUE : FALSE);
} // __inline int ans_simp_question (LTS_FEATURE *feat, SIMPLE_QUESTION question, 


static int product_eval (LTS_FEATURE *feat, char *term, LTS_SAMPLE *sample)
{
  int negate, result;
  SIMPLE_QUESTION ques;
  char *cptr;

  cptr = term;
  while (TRUE) {
    /* negation sign */    
    if (*cptr == '~') {
      negate = TRUE;
      cptr++;
    }
    else
      negate = FALSE;

    if (!isdigit(*cptr)) {
      //quit (-1, "Invalid product in product_eval\n");
//      OutputDebugString("Invalid product in product_eval\n");
      return FALSE;
    }

    for (result = *cptr++ - '0'; isdigit (*cptr); cptr++)
      result = result * 10 + (*cptr - '0');

    QUES_DECODE(result, ques.questype, ques.context, ques.offset, 
		ques.feature);
    if ((negate ^ ans_simp_question (feat, ques, sample)) == FALSE)
      return FALSE;

    if (*cptr == '\0')
      break;
    if (*cptr++ != '&') {
      //quit (-1, "product_eval:  syntax error in product term %s\n", term);
      /*
      char szTemp[512];

      sprintf(szTemp, "product_eval:  syntax error in product term %s\n", term);
      OutputDebugString(szTemp);
      */
      return FALSE;
    }
  }

  return TRUE;
} // static int product_eval (LTS_FEATURE *feat, char *term, LTS_SAMPLE *sample)


static int ans_comp_question(LTS_FEATURE *feat, char *prod, 
			       LTS_SAMPLE *sample)
{
  int i, num_products, limit;
  char *cptr, string[LONGEST_STR], *products[MAX_PRODUCTS];

  strcpy(string, prod);
  for (cptr = string, num_products = 1; *cptr != '\0'; cptr++)
    if (*cptr == '|') num_products++;

  if (num_products > MAX_PRODUCTS) {
    //quit(1, "please increase MAX_PRODUCTS up to %d at least\n", num_products);

     /*
    char szTemp[256];
    sprintf(szTemp, "please increase MAX_PRODUCTS up to %d at least\n", num_products);
    OutputDebugString(szTemp);
    */

    return FALSE;
  }

  for (i = 0, limit = num_products -1, cptr = string; ; i++) {
    products[i] = cptr++;
    if (i == limit)
      break;

    for (; *cptr != '|'; cptr++);
    *cptr++ = '\0';
  }

  for (i = 0; i < num_products; i++) {
    if (product_eval (feat, products[i], sample) == TRUE)
      return TRUE;
  }

  return FALSE;
} // static int ans_comp_question(LTS_FEATURE *feat, char *prod, 


static T_NODE *find_leaf(LTS_FEATURE *feat, T_NODE *root, LTS_SAMPLE *sample)
{
  if (!root->yes_child)
    return root;
  else if (ans_comp_question(feat, root->prod, sample))
    return find_leaf(feat, root->yes_child, sample);
  else
    return find_leaf(feat, root->no_child, sample);
} // static T_NODE *find_leaf(LTS_FEATURE *feat, T_NODE *root, LTS_SAMPLE *sample)


static int lts_product_eval (LTS_FEATURE *feat, LTS_PROD *term, 
			       LTS_SAMPLE *sample, LTS_PROD **next)
{
  int negate, result;
  SIMPLE_QUESTION ques;
  LTS_PROD *cptr = term;

  while (TRUE) {
    if ((*cptr) & PROD_NEG) {
      negate = TRUE;
      result = (*cptr) ^ PROD_NEG;
    }
    else {
      negate = FALSE;
      result = (*cptr);
    }

    QUES_DECODE(result, ques.questype, ques.context, ques.offset, 
		ques.feature);
    if ((negate ^ ans_simp_question (feat, ques, sample)) == FALSE) {
      while (*cptr != PROD_TERM && *cptr != QUES_TERM)
	cptr++;
      if (*cptr == QUES_TERM)
	*next = NULL;
      else
	*next = cptr + 1;
      return FALSE;
    }

    cptr++;
    if (*cptr == QUES_TERM) {
      *next = NULL;
      break;
    }
    else if (*cptr == PROD_TERM) {
      *next = cptr + 1;
      break;
    }
  }

  return TRUE;
} // static int lts_product_eval (LTS_FEATURE *feat, LTS_PROD *term, 


static int lts_ans_comp_question(LTS_TREE *tree, LTS_FEATURE *feat, 
				   int idx, LTS_SAMPLE *sample)
{
  LTS_PROD *next, *term = (LTS_PROD *) ((char *) tree->p_prod + idx);

  while (TRUE) {
    if (lts_product_eval (feat, term, sample, &next) == TRUE)
      return TRUE;
    if (next == NULL)
      break;
    term = next;
  }

  return FALSE;
} // static int lts_ans_comp_question(LTS_TREE *tree, LTS_FEATURE *feat, 


static LTS_NODE *lts_find_leaf(LTS_TREE *tree, LTS_FEATURE *feat, 
			       LTS_NODE *root, LTS_SAMPLE *sample)
{
  if (IS_LEAF_NODE(root))
    return root;
  else if (lts_ans_comp_question(tree, feat, root->idx, sample))
    return lts_find_leaf(tree, feat, root + root->yes, sample);
  else
    return lts_find_leaf(tree, feat, root + root->yes + 1, sample);
} // static LTS_NODE *lts_find_leaf(LTS_TREE *tree, LTS_FEATURE *feat, 


static void assign_samples(LTS_FEATURE *feat, T_NODE **forest, 
			   char *sample_file, LTS_SYMTAB *tab)
{
  char line[LONGEST_STR], *src, *tgt, sym[128], *p;
  FILE *fp = fopen(sample_file, "r");
  if (!fp)
    return;

  int slen = 0, tlen = 0, num_samples = 0, id, i;
  int line_num = 0;
  LTS_SAMPLE *sample;
  T_NODE *leaf;
  SYMBOL *buffer;

  sample = (LTS_SAMPLE *) calloc (LONGEST_STR, sizeof(LTS_SAMPLE));
  if (!sample)
     return;

  buffer = (SYMBOL *) calloc(LONGEST_STR, sizeof(SYMBOL));
  if (!buffer)
     return;

  buffer[0] = NULL_SYMBOL_ID;
  while (fgets(line, LONGEST_STR, fp)) {
    line_num++;
    if ((p = strchr(line, '>')) == 0) {
      //quit(-1, "no separator in line %d <%s>\n", line_num, line);
      /*
      char szTemp[256];

      sprintf(szTemp, "no separator in line %d <%s>\n", line_num, line);
      OutputDebugString(szTemp);
      */
      return;
    }

    src = line;
    tgt = p + 1;
    *p = 0;

    p = strchr(tgt, '(');
    if (p)
      *p = 0; /* sentence id */
    slen = tlen = 0;
    for (p = get_a_word(src, sym, ' '); p; p = get_a_word(p, sym, ' ')) {
      if ((id = symbol_to_id(&(tab[INPUT]), sym)) == NO_SYMBOL || 
	   id == NULL_SYMBOL_ID) {
        //quit(-1, "Cannot find symbol <%s> in line %d <%s>. skip.\n", sym,
        //     line_num, src);
        /*
        char szTemp[256];

        sprintf(szTemp, "Cannot find symbol <%s> in line %d <%s>. skip.\n", sym,
             line_num, src);
        OutputDebugString(szTemp);
        */
        return;
      }
      buffer[1 + slen++] = (SYMBOL) id;
    }

    buffer[1 + slen++] = NULL_SYMBOL_ID;

    for (p = get_a_word(tgt, sym, ' '); p; p = get_a_word(p, sym, ' ')) {
      if ((id = symbol_to_id(&(tab[OUTPUT]), sym)) == NO_SYMBOL ||
	   id == NULL_SYMBOL_ID) {
        //quit(-1, "Cannot find symbol <%s> in line %d <%s>. skip.\n", sym,
        //     line_num, src);
        /*
        char szTemp[256];

        sprintf(szTemp, "Cannot find symbol <%s> in line %d <%s>. skip.\n", sym,
             line_num, src);
        OutputDebugString(szTemp);
        */
        return;
      }
      buffer[1 + slen + tlen++] = (SYMBOL) id;
    }
    buffer[1 + slen + tlen++] = NULL_SYMBOL_ID;
    if (tlen != slen) {
      //quit(-1, "mismatch at input samples length (%d %d)\n", slen, tlen);
      /*
      char szTemp[256];

      sprintf(szTemp, "mismatch at input samples length (%d %d)\n", slen, tlen);
      OutputDebugString(szTemp);
      */
      return;
    }

    for (i = 0; i < tlen - 1; i++) {
      sample[i].pIn = buffer + 1 + i;
      sample[i].pOut = buffer + 1 + tlen + i;
      leaf = find_leaf(feat, forest[*(sample[i].pIn)], sample + i);
      leaf->count[*(sample[i].pOut)]++;
    }
    num_samples++;
  } /* while */

  ODS("totally %d samples\n", num_samples);
  fclose(fp);
  free(buffer);
  free(sample);
} // static void assign_samples(LTS_FEATURE *feat, T_NODE **forest, 


static void walk_tree(T_NODE *root, int dim)
{
  int i;

  if (root->yes_child) {
    walk_tree(root->yes_child, dim);
    walk_tree(root->no_child, dim);
    for (i = 0; i < dim; i++)
      root->count[i] = root->yes_child->count[i] + root->no_child->count[i];
  }
} // static void walk_tree(T_NODE *root, int dim)


static void free_tree(T_NODE *root)
{
  if (root->yes_child) {
    free_tree(root->yes_child);
    free_tree(root->no_child);
  }

  free(root->count);
  free(root);
} // static void free_tree(T_NODE *root)


static int count_all_nodes(T_NODE *root)
{
  if (! root->yes_child)
    return 1;
  else {
    int y = count_all_nodes(root->yes_child);
    int n = count_all_nodes(root->no_child);
    return y + n + 1;
  }
} // static int count_all_nodes(T_NODE *root)


static void prune_node(T_NODE *root, int min_count, float threshold)
{
  if (! root->yes_child)
    return;
  else
    if (root->n_samples < min_count ||
	root->entropy_dec < threshold) {
      free_tree(root->yes_child);
      root->yes_child = NULL;
      free_tree(root->no_child);
      root->no_child = NULL;
      return;
    }
  else {
    prune_node(root->yes_child, min_count, threshold);
    prune_node(root->no_child, min_count, threshold);
  }
} // static void prune_node(T_NODE *root, int min_count, float threshold)


static void prune_forest(T_NODE **forest, int min_count,
			 float min_entropy_dec, int in_dim, int out_dim)
{
  int i, nodes;

  ODS("min_count = %d, entropy decrease threshold = %f\n",
          min_count, min_entropy_dec);
  for (nodes = 0, i = 1; i < in_dim; i++)
    nodes += count_all_nodes(forest[i]);
  ODS("%d tree nodes\n", nodes);
  ODS("e.g. %d\n", count_all_nodes(forest[1]));

  for (i = 1; i < in_dim; i++) {
    walk_tree(forest[i], out_dim);
    prune_node(forest[i], min_count, min_entropy_dec);
  }

  for (nodes = 0, i = 1; i < in_dim; i++)
    nodes += count_all_nodes(forest[i]);
  ODS ("%d tree nodes\n", nodes);
  ODS("e.g. %d\n", count_all_nodes(forest[1]));
} // static void prune_forest(T_NODE **forest, int min_count,


static int count_prod_bytes(char *prod)
{
  int bytes = 0;
  char *p = prod;

  while (*p) {
    while (*p == '~' || (*p >= '0' && *p <= '9')) p++;
    bytes += sizeof(short);
    if (*p == '&')
      p++;
    else if (*p == '|') {
      bytes += sizeof(short); /* separator */
      p++;
    }
    else if (*p != 0) {
      int *z = 0;
      ODS("unrecognized char %c in prod (%s)\n", *p, prod);
      z[0] = z[1];
    }
  }

  bytes += sizeof(short); /* final separator */
  return bytes;
} // static int count_prod_bytes(char *prod)


static void tree_collect_info(T_NODE *root, int *p_nodes, 
			      int *p_prod_bytes, int *p_dist_bytes, 
			      int dim)
{
  if (root->yes_child) {
    tree_collect_info(root->yes_child, p_nodes, p_prod_bytes, 
		      p_dist_bytes, dim);
    tree_collect_info(root->no_child, p_nodes, p_prod_bytes, 
		      p_dist_bytes, dim);
    *p_prod_bytes += count_prod_bytes(root->prod);
  }
  else {
    int i;
    *p_dist_bytes += sizeof(int);
    for (i = 0; i < dim; i++)
      if (root->count[i] > 0)
	*p_dist_bytes += sizeof(LTS_PAIR);
  }

  (*p_nodes)++;
} // static void tree_collect_info(T_NODE *root, int *p_nodes, 


static void convert_node(T_NODE *root, LTS_TREE *l_root, int dim, 
			 int *prod_idx, int *dist_idx)
{
  if (root->yes_child) {
    LTS_PROD *pr = (LTS_PROD *) ((char *)l_root->p_prod + *prod_idx), prod;
    int neg;
    char *p = root->prod;

    _ASSERTE(root->yes_child->index - root->index < 65536);
    //l_root->nodes[root->index].yes = root->yes_child->index - root->index;
    l_root->nodes[root->index].yes = 
       (unsigned short)(root->yes_child->index - root->index);
    l_root->nodes[root->index].idx = *prod_idx;
    while (*p) {
      if (*p == '~') {
	neg = 1;
	p++;
      }
      else
	neg = 0;
      for (prod = *p++ - '0'; isdigit (*p); p++)
	prod = prod * 10 + (*p - '0');
      _ASSERTE(prod < MAX_PROD);
      if (neg)
	prod |= PROD_NEG;
      *pr++ = prod;
      if (*p == '&')
	p++;
      else if (*p == '|') {
	*pr++ = PROD_TERM;
	p++;
      }
      else if (*p == 0)
	*pr++ = QUES_TERM;
    }
    *prod_idx = (char *) pr - (char *) l_root->p_prod;
    _ASSERTE(*prod_idx <= l_root->size_prod);

    convert_node(root->yes_child, l_root, dim, prod_idx, dist_idx);
    convert_node(root->no_child, l_root, dim, prod_idx, dist_idx);
  }
  else {
    /* be careful about alignment */
    LTS_DIST *pd = (LTS_DIST *) ((char *)l_root->p_dist + *dist_idx);
    LTS_PAIR *pp = &(pd->p_pair);
    int cnt = 0, i;
    l_root->nodes[root->index].yes = NO_CHILD;
    l_root->nodes[root->index].idx = *dist_idx;

    for (i = 0; i < dim; i++)
      if (root->count[i] > 0) {
	//pp->id = i;
	pp->id = (short)i;
	//pp->cnt = root->count[i];
	pp->cnt = (short)(root->count[i]);
	cnt++;
	pp++;
      }
    pd->c_dists = cnt;
    *dist_idx += cnt * sizeof(LTS_PAIR) + sizeof(int);
    _ASSERTE(*dist_idx <= l_root->size_dist);
  }
} // static void convert_node(T_NODE *root, LTS_TREE *l_root, int dim, 


static LTS_TREE *convert_tree(T_NODE *root, int dim)
{
  int n_nodes = 0, n_prod_bytes = 0, n_dist_bytes = 0;
  int head, tail, index;
  int pr = 0, di = 0;
  LTS_TREE *l_root = (LTS_TREE *) calloc(1, sizeof(LTS_TREE));
  if (!l_root)
     return NULL;

  T_NODE **queue, *node;

  tree_collect_info(root, &n_nodes, &n_prod_bytes, &n_dist_bytes, dim);
  printf("%d nodes, %d bytes for prods, %d bytes for dist\n", n_nodes,
	 n_prod_bytes, n_dist_bytes);

  l_root->n_nodes = n_nodes;
  l_root->nodes = (LTS_NODE *) calloc(n_nodes, sizeof(LTS_NODE));
  if (!l_root->nodes)
     return NULL;

  l_root->size_prod = n_prod_bytes;
  l_root->p_prod = (LTS_PROD *) calloc(n_prod_bytes, sizeof(char));
  if (!l_root->p_prod)
     return NULL;

  l_root->size_dist = n_dist_bytes;
  l_root->p_dist = (LTS_DIST *) calloc(n_dist_bytes, sizeof(char));
  if (!l_root->p_dist)
     return NULL;

  /* put index on nodes using FIFO */
  queue = (T_NODE **) calloc(n_nodes, sizeof(T_NODE *));
  if (!queue)
     return NULL;

  head = tail = index = 0;
  queue[tail++] = root;
  while (head != tail) {
    node = queue[head++];
    node->index = index++;

    if (node->yes_child) {
      queue[tail++] = node->yes_child;
      queue[tail++] = node->no_child;
      _ASSERTE(tail <= n_nodes);
    }
  }
  free(queue);

  convert_node(root, l_root, dim, &pr, &di);
  if (pr != n_prod_bytes || di != n_dist_bytes) {
    int *z = 0; z[0] = z[1];
  }

  return l_root;
} // static LTS_TREE *convert_tree(T_NODE *root, int dim)


static LTS_FOREST *convert_forest(T_NODE **forest, LTS_SYMTAB *tab,
				  LTS_FEATURE *feat)
{
  LTS_FOREST *l_forest = (LTS_FOREST *) calloc(1, sizeof(LTS_FOREST));
  if (!l_forest)
     return NULL;

  int i;

  l_forest->symbols = tab;
  l_forest->features = feat;

  l_forest->tree = (LTS_TREE **) calloc(tab[INPUT].n_symbols, 
					   sizeof(LTS_TREE *));
  if (!l_forest->tree)
     return NULL;

  for (i = 1; i < tab[INPUT].n_symbols; i++) {
    l_forest->tree[i] = convert_tree(forest[i], tab[OUTPUT].n_symbols);
    free_tree(forest[i]);
  }

  return l_forest;
} // static LTS_FOREST *convert_forest(T_NODE **forest, LTS_SYMTAB *tab,


LTS_FOREST *LtscartLoadDataFromTree(char *in_sym, char *out_sym, 
				    char *in_feat, char *out_feat, 
				    char *tree_dir, int min_count, 
				    float min_entropy_dec, char *sample_file)
{
  LTS_SYMTAB *tab;
  LTS_FEATURE *feat;
  T_NODE **forest;
  LTS_FOREST *l_forest;

  tab = (LTS_SYMTAB *) calloc(2, sizeof(LTS_SYMTAB));
  if (!tab)
     return NULL;

  read_symbol(in_sym, &(tab[INPUT]));
  read_symbol(out_sym, &(tab[OUTPUT]));

  feat = (LTS_FEATURE *) calloc(2, sizeof(LTS_FEATURE));
  if (!feat)
     return NULL;

  read_feature(in_feat, &(tab[INPUT]), &(feat[INPUT]));
  read_feature(out_feat, &(tab[OUTPUT]), &(feat[OUTPUT]));

  forest = read_forest(tree_dir, tab);
  assign_samples(feat, forest, sample_file, tab);
  prune_forest(forest, min_count, min_entropy_dec, 
	       tab[INPUT].n_symbols, tab[OUTPUT].n_symbols);
  l_forest = convert_forest(forest, tab, feat);

  l_forest->heap = lts_initialize_heap();
  return l_forest;
} // LTS_FOREST *LtscartLoadDataFromTree(char *in_sym, char *out_sym, 


static LTS_DIST *lts_find_leaf_count(LTS_FOREST *l_forest, SYMBOL *pIn, 
				     SYMBOL *pOut)
{
  LTS_TREE *tree = l_forest->tree[*pIn];
  LTS_NODE *leaf;
  LTS_SAMPLE sample;

  /*
   * construct a sample in order to share all the code with training
   */
  sample.pIn = pIn;
  sample.pOut = pOut;

  /* *pOut cannot be NULL_SYMBOL_ID */
  *pOut = NULL_SYMBOL_ID + 1;

  leaf = lts_find_leaf(tree, l_forest->features, &(tree->nodes[0]), &sample);
  return (LTS_DIST *) ((char *)tree->p_dist + leaf->idx);
} // static LTS_DIST *lts_find_leaf_count(LTS_FOREST *l_forest, SYMBOL *pIn, 


static LTS_OUT_RESULT *allocate_out_result(LTS_FOREST *l_forest)
{
  LTS_OUT_RESULT *res = (LTS_OUT_RESULT *)
    PvAllocFromHhp(l_forest->heap->hhp_outres);
  res->out_strings = (LTS_OUT_STRING **) 
    PvAllocFromHhp(l_forest->heap->hhp_strptr);
  res->num_allocated_strings = MAX_ALT_STRINGS;
  res->num_strings = 0;

  return res;
} // static LTS_OUT_RESULT *allocate_out_result(LTS_FOREST *l_forest)


static void free_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res)
{
  int i;

  for (i = 0; i < res->num_strings; i++)
    FreeHhpPv(l_forest->heap->hhp_outstr, res->out_strings[i]);
  if (res->num_allocated_strings == MAX_ALT_STRINGS)
    FreeHhpPv(l_forest->heap->hhp_strptr, res->out_strings);
  else
    free(res->out_strings);  /* dirty */

  FreeHhpPv(l_forest->heap->hhp_outres, res);
} // static void free_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res)


static void reallocate_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res, 
				  int min)
{
  int s = res->num_allocated_strings, old_size = s;
  LTS_OUT_STRING **p;

  while (s < min)
    s += INC_ALT_STRINGS;
  p = res->out_strings;

  res->out_strings = (LTS_OUT_STRING **) 
    calloc(s, sizeof(LTS_OUT_STRING *));
  if (!res->out_strings)
     return;

  memcpy(res->out_strings, p, old_size * sizeof(LTS_OUT_STRING *));

  if (old_size == MAX_ALT_STRINGS)
    FreeHhpPv(l_forest->heap->hhp_strptr, p);
  else
    free(p);

  res->num_allocated_strings = s;
  ODS("increased out_strings to %d in order to meet %d\n", s, min);
} // static void reallocate_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res, 


static void grow_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res, 
			    SYMBOL i, int count, float inv_sum, 
			    LTS_OUT_RESULT *tmpRes)
{
  int j;

  if (res->num_strings + tmpRes->num_strings >= res->num_allocated_strings)
    reallocate_out_result(l_forest, res, 
			  res->num_strings + tmpRes->num_strings);
  for (j = 0; j < tmpRes->num_strings; j++) {
    SYMBOL *psrc = tmpRes->out_strings[j]->psym;
    SYMBOL *ptgt;
    res->out_strings[res->num_strings + j] = 
      (LTS_OUT_STRING *)PvAllocFromHhp(l_forest->heap->hhp_outstr);
    ptgt = res->out_strings[res->num_strings + j]->psym;
    *ptgt++ = i;
    while (*psrc != NULL_SYMBOL_ID)
      *ptgt++ = *psrc++;
    *ptgt++ = NULL_SYMBOL_ID;
    res->out_strings[res->num_strings + j]->prob = count * inv_sum * 
      tmpRes->out_strings[j]->prob;
  }
  res->num_strings += tmpRes->num_strings;
  free_out_result(l_forest, tmpRes);
} // static void grow_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res, 


static LTS_OUT_RESULT *gen_one_output(LTS_FOREST *l_forest, int len, 
				      SYMBOL *input_id, int in_index, 
				      SYMBOL *output_id, float cutoff)
{
  SYMBOL out[MAX_STRING_LEN], *pOut;
  LTS_OUT_RESULT *res = allocate_out_result(l_forest);
  int sum, i, dim;
  LTS_DIST *pdf;
  LTS_PAIR *l_pair, *lp;
  float cut, inv_sum;

  /*
   * copy output_id to local
   */
  {
    SYMBOL *psrc = output_id - 1, *ptgt = out;
    while (*psrc != NULL_SYMBOL_ID) psrc--;
    while (psrc != output_id)
      *ptgt++ = *psrc++;
    pOut = ptgt;
    /* sanity check */
    if (pOut - out != in_index + 1) {
      int *z=0; z[0]=z[1];
    }
  }

  if (in_index == len - 1) {
    pdf = lts_find_leaf_count(l_forest, input_id + in_index, pOut);
    l_pair = &(pdf->p_pair);
    dim = pdf->c_dists;
    for (lp = l_pair, sum = 0, i = 0; i < dim; i++, lp++)
      sum += lp->cnt;
    _ASSERTE(sum > 0);
    inv_sum = 1.0f / sum;
    cut = cutoff * sum;
    for (lp = l_pair, i = 0; i < dim; i++, lp++)
      if ((float)(lp->cnt) > cut) {
	res->out_strings[res->num_strings] = 
	  (LTS_OUT_STRING *)PvAllocFromHhp(l_forest->heap->hhp_outstr);
	res->out_strings[res->num_strings]->psym[0] = (SYMBOL) lp->id;
	res->out_strings[res->num_strings]->psym[1] = NULL_SYMBOL_ID;
	res->out_strings[res->num_strings]->prob = lp->cnt * inv_sum;
	res->num_strings++;
      } /* cut */
  }
  else {
    LTS_OUT_RESULT *tmpRes;

    pdf = lts_find_leaf_count(l_forest, input_id + in_index, pOut);
    dim = pdf->c_dists;
    l_pair = &(pdf->p_pair);
    for (lp = l_pair, sum = 0, i = 0; i < dim; i++, lp++)
      sum += lp->cnt;
    _ASSERTE(sum > 0);

    inv_sum = 1.0f / sum;
    cut = cutoff * sum;
    for (lp = l_pair, i = 0; i < dim; i++, lp++) {
      if ((float)(lp->cnt) > cut) {
	SYMBOL *pTmpOut = pOut + 1;
	*pOut = (SYMBOL) lp->id;
	tmpRes = gen_one_output(l_forest, len, input_id, in_index + 1, 
				pTmpOut, cutoff);
	grow_out_result(l_forest, res, (SYMBOL)(lp->id), lp->cnt, 
			inv_sum, tmpRes);
      }
    } /* i */
  } /* else */

  return res;
} // static LTS_OUT_RESULT *gen_one_output(LTS_FOREST *l_forest, int len, 


static int comp_out_result_prob(const void *vp1, const void *vp2)
{
  LTS_OUT_STRING **p1 = (LTS_OUT_STRING **) vp1, 
		**p2 = (LTS_OUT_STRING **) vp2;

  if ((*p1)->prob > (*p2)->prob)
    return -1;
  else if ((*p1)->prob < (*p2)->prob)
    return 1;
  else
    return 0;
} // static int comp_out_result_prob(const void *vp1, const void *vp2)


static void lts_fill_out_buffer(LTS_FOREST *l_forest, LTS_OUT_RESULT *out, 
				char *word)
{
  int i, j, n;
  float inv_sum, sum = 0.0f;
  char phnstr[LONGEST_STR];
  LTS_SYMTAB *tab = l_forest->symbols;

  if (out == NULL)
    return;

  if (word)
    strcpy(l_forest->out.word, word);
  else
    l_forest->out.word[0] = 0;

  /* normalize probabilities */
  for (i = 0; i < out->num_strings; i++)
    sum += out->out_strings[i]->prob;
  inv_sum = 1.0f / sum;
  for (i = 0; i < out->num_strings; i++)
    out->out_strings[i]->prob *= inv_sum;

  /*
   * sort them according to the prob field
   */
  qsort(out->out_strings, out->num_strings, sizeof(LTS_OUT_STRING *),
	&comp_out_result_prob);

  if (out->num_strings > MAX_OUTPUT_STRINGS - l_forest->out.num_prons) {
    n = MAX_OUTPUT_STRINGS - l_forest->out.num_prons;
    for (sum = 0.0f, i = 0; i < n; i++)
      sum += out->out_strings[i]->prob;
    inv_sum = 1.0f / sum;
    for (i = 0; i < n; i++)
      out->out_strings[i]->prob *= inv_sum;
  }
  else
    n = out->num_strings;

  for (j = l_forest->out.num_prons, i = 0; i < n; i++) {
    SYMBOL *p = out->out_strings[i]->psym;
    char *psrc, *ptgt;

    if (out->out_strings[i]->prob < MIN_OUT_PROB)
      continue;

    phnstr[0] = 0;
    l_forest->out.pron[j].prob = out->out_strings[i]->prob;

    while (*p != NULL_SYMBOL_ID) {
      strcat(phnstr, id_to_symbol(&(tab[OUTPUT]), *p++));
      strcat(phnstr, " ");
    }

    psrc = phnstr;
    ptgt = l_forest->out.pron[j].pstr;
    while (*psrc) {
      if (*psrc != '#' && *psrc != '_')
	*ptgt++ = *psrc++;
      else if (*psrc == '_') {
	*ptgt++ = ' ';
	psrc++;
      }
      else
	psrc += 2; /* skip an extra space */
      /* extreme case, truncate it */
      if (ptgt - l_forest->out.pron[j].pstr >= MAX_PRON_LEN) {
	for (ptgt--; !isspace(*ptgt); ptgt--); /* never output partial phone */
	ptgt++;
        break;
      }
    }
    // output could contain only '# '
    if (ptgt > l_forest->out.pron[j].pstr && *(ptgt - 1) == ' ')
      *(ptgt - 1) = 0; /* remove the last space */
    else
      *ptgt = 0; /* shouldn't happen unless ptgt didn't move */
    if (ptgt > l_forest->out.pron[j].pstr)
      j++;
  } /* i */

  if (j <= MAX_OUTPUT_STRINGS)
    l_forest->out.num_prons = j;
  else
    l_forest->out.num_prons = MAX_OUTPUT_STRINGS; // should never happen

  free_out_result(l_forest, out);
} // static void lts_fill_out_buffer(LTS_FOREST *l_forest, LTS_OUT_RESULT *out, 


void assign_a_fixed_pron(LTS_OUTPUT *out, char *pron, char *word)
{
  out->num_prons = 1;
  strcpy(out->word, word);
  out->pron[0].prob = 1.0f;
  if (strlen(pron) < MAX_PRON_LEN)
    strcpy(out->pron[0].pstr, pron);
  else {
    char *p;
    strncpy(out->pron[0].pstr, pron, MAX_PRON_LEN);
    p = &(out->pron[0].pstr[MAX_PRON_LEN - 1]);
    while (!isspace(*p)) p--; /* truncate the last partial phoneme */
    *p = 0;
  }
} // void assign_a_fixed_pron(LTS_OUTPUT *out, char *pron, char *word)


void assign_a_spelling_pron(LTS_OUTPUT *out, char *word)
{
  char *p;

  strcpy(out->word, word);
  if (ispunct(*word))
    p = word + 1;
  else
    p = word;

  out->num_prons = 1;
  out->pron[0].prob = 1.0f;
  out->pron[0].pstr[0] = 0;
  for (; *p; p++) {
    char c = tolower(*p);
    if (c < 'a' || c > 'z')
      continue;
    if (strlen(out->pron[0].pstr) + strlen(single_letter_pron[c - 'a']) 
	< MAX_PRON_LEN - 1) {
      strcat(out->pron[0].pstr, single_letter_pron[c - 'a']);
      strcat(out->pron[0].pstr, " ");
    }
    else
      break;
  }
} // void assign_a_spelling_pron(LTS_OUTPUT *out, char *word)


LTS_OUTPUT *LtscartGetPron(LTS_FOREST *l_forest, char *word)
{
  LTS_OUT_RESULT *pres = NULL;
  char *p, *base;
  SYMBOL buffer[LONGEST_STR], *pbuf = buffer + 1;
  int len, id, hasvowel = 0, allcapital = 1;

  l_forest->out.num_prons = 0;
  buffer[0] = NULL_SYMBOL_ID;
  len = 0;

  if (word == NULL || (base = strtok(word, " \t\n")) == NULL) {
    assign_a_fixed_pron(&(l_forest->out), bogus_pron, "NUL");
    return &(l_forest->out);
  }
  else {
    base = strtok(word, " \t\n");
    if (ispunct(*base))
      for (p = base; *p && ispunct(*p); p++);
    else
      p = base;
  }

  for (; *p; p++) {
    char b[2];
    b[0] = tolower(*p); b[1] = 0;
    if (!hasvowel && (b[0] == 'a' || b[0] == 'e' || b[0] == 'i' || 
	b[0] == 'o' || b[0] == 'u' || b[0] == 'y'))
      hasvowel = 1;
    if (allcapital && islower(*p))
      allcapital = 0;
    if ((id = symbol_to_id (&(l_forest->symbols[INPUT]), b)) == NO_SYMBOL ||
	 id == NULL_SYMBOL_ID) {
      ODS("cannot find the symbol %s, skip!\n", p);
      continue;
    }
    pbuf[len++] = (SYMBOL) id;
  }

  pbuf[len] = NULL_SYMBOL_ID;
  if (len >= MAX_STRING_LEN || len <= 0)
    assign_a_fixed_pron(&(l_forest->out), bogus_pron, word);
  else if (len == 1) {
    LTS_SYMTAB *tab = l_forest->symbols;
    char *p = id_to_symbol(&(tab[INPUT]), pbuf[0]);
    char c = tolower(p[0]);
    if (c >= 'a' && c <= 'z')
      assign_a_fixed_pron(&(l_forest->out), single_letter_pron[c - 'a'], word);
    else
      assign_a_fixed_pron(&(l_forest->out), bogus_pron, word);
  }
  else if (!hasvowel)
    assign_a_spelling_pron(&(l_forest->out), word);
  else {
    if (allcapital)
      assign_a_spelling_pron(&(l_forest->out), word);
    pres = gen_one_output(l_forest, len, pbuf, 0, pbuf, DEFAULT_PRUNE);
    lts_fill_out_buffer(l_forest, pres, word);
  }

  if (l_forest->out.num_prons == 0)
    assign_a_fixed_pron(&(l_forest->out), bogus_pron, word);

  return &(l_forest->out);
} // LTS_OUTPUT *LtscartGetPron(LTS_FOREST *l_forest, char *word)


LTS_FOREST *LtscartReadData (PBYTE map_addr)
{
  int i;
  LTS_FOREST *l_forest;
  LTS_SYMTAB *tab;
  LTS_FEATURE *feat;
  int output = 0;

  l_forest = (LTS_FOREST *) calloc(1, sizeof(LTS_FOREST));
  if (!l_forest)
     return NULL;
  
  //read in the symbol table
  l_forest->symbols = (LTS_SYMTAB *) calloc(2, sizeof(LTS_SYMTAB));
  if (!l_forest->symbols)
     return NULL;

  tab = &(l_forest->symbols[INPUT]);
  CopyMemory(&(tab->n_symbols), map_addr + output, sizeof(int));
  output += sizeof(int);
  
  tab->sym_idx = (int *)(map_addr + output);
  output += tab->n_symbols * sizeof(int);

  CopyMemory(&(tab->n_bytes), map_addr + output, sizeof(int));
  output += sizeof(int);

  tab->storage = (char*)(map_addr + output);
  output += tab->n_bytes * sizeof(char);

  tab = &(l_forest->symbols[OUTPUT]);
  CopyMemory(&(tab->n_symbols), map_addr + output, sizeof(int));
  output += sizeof(int);

  tab->sym_idx = (int*)(map_addr + output);
  output += tab->n_symbols * sizeof(int);
  CopyMemory(&(tab->n_bytes), map_addr + output, sizeof(int));
  output += sizeof(int);

  tab->storage = (char*)(map_addr + output);
  output += tab->n_bytes * sizeof(char);

  // read in the feature vector
  l_forest->features = (LTS_FEATURE *) calloc(2, sizeof(LTS_FEATURE));
  if (!l_forest->features)
     return NULL;

  feat = &(l_forest->features[INPUT]);
  
  CopyMemory(&(feat->n_feat), map_addr + output, sizeof(int));
  output += sizeof(int);
  
  CopyMemory(&(feat->dim), map_addr + output, sizeof(int));
  output += sizeof(int);

  feat->feature = (int **) calloc(feat->n_feat, sizeof(int *));
  if (!feat->feature)
     return NULL;

  for (i = 0; i < feat->n_feat; i++) {
    feat->feature[i] = (int*)(map_addr + output);
    output += feat->dim * sizeof(int);
  }

  feat = &(l_forest->features[OUTPUT]);
  CopyMemory(&(feat->n_feat), map_addr + output, sizeof(int));
  output += sizeof(int);

  CopyMemory(&(feat->dim), map_addr + output, sizeof(int));
  output += sizeof(int);

  feat->feature = (int **) calloc(feat->n_feat, sizeof(int *));
  if (!feat->feature)
     return NULL;

  for (i = 0; i < feat->n_feat; i++) {
    feat->feature[i] = (int*)(map_addr + output);
    output += feat->dim * sizeof(int);
  }

  /*
   * read in the tree
   */
  l_forest->tree = (LTS_TREE **) calloc(l_forest->symbols[INPUT].n_symbols,
					   sizeof(LTS_TREE *));
  if (!l_forest->tree)
     return NULL;

  for (i = 1; i < l_forest->symbols[INPUT].n_symbols; i++) {
    LTS_TREE *l_root;
    l_forest->tree[i] = l_root = (LTS_TREE *) calloc(1, sizeof(LTS_TREE));
    if (!l_root)
       return NULL;

    CopyMemory(&(l_root->n_nodes), map_addr + output, sizeof(int));
    output += sizeof(int);

    l_root->nodes = (LTS_NODE*)(map_addr + output);
    output += l_root->n_nodes * sizeof(LTS_NODE);

    CopyMemory(&(l_root->size_dist), map_addr + output, sizeof(int));
    output += sizeof(int);

    l_root->p_dist = (LTS_DIST*)(map_addr + output);
    output += l_root->size_dist * sizeof(char);
    
    CopyMemory(&(l_root->size_prod), map_addr + output, sizeof(int));
    output += sizeof(int);

    if (l_root->size_prod > 0) {
      l_root->p_prod = (LTS_PROD*)(map_addr + output);
      output += l_root->size_prod * sizeof(char);
    }
  }

  //fclose(fp);

  // initilize internal buffer
  l_forest->heap = lts_initialize_heap();

  return l_forest;
} // LTS_FOREST *LtscartReadData(char *forest_image, HANDLE *hFile1, 


void LtscartFreeData(LTS_FOREST *l_forest)
{
  for (int i = 1; i < l_forest->symbols[INPUT].n_symbols; i++) {
    free(l_forest->tree[i]);
  }
  free(l_forest->tree);

  free(l_forest->features[INPUT].feature);
  free(l_forest->features[OUTPUT].feature);
  free(l_forest->features);

  free(l_forest->symbols);

  lts_free_heap(l_forest->heap);
  free(l_forest);
} // void LtscartFreeData(LTS_FOREST *l_forest, HANDLE m_hFile, 


/* default: more_separator = ' ' */
/* line is terminated by \0, which is NOT a whitespace. */
static char *get_a_word (char *line, char *word, char more_separator)
{
    register int i;

    while (*line == more_separator || isspace(*line)) line++;
    if (*line == '\0') { word[0] = '\0'; return NULL; }
    i = 0;
    do { word[i++] = *line++;} while (!isspace(*line) 
		      && *line != more_separator && *line != '\0');
    word[i] = '\0';
    return line;
} // static char *get_a_word (char *line, char *word, char more_separator)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\lexapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sun Jun 13 11:26:45 1999
 */
/* Compiler settings for D:\sapi5\Src\Lexicon\LexAPI\LexAPI.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __LexAPI_h__
#define __LexAPI_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ILxLexicon_FWD_DEFINED__
#define __ILxLexicon_FWD_DEFINED__
typedef interface ILxLexicon ILxLexicon;
#endif 	/* __ILxLexicon_FWD_DEFINED__ */


#ifndef __ILxWalkStates_FWD_DEFINED__
#define __ILxWalkStates_FWD_DEFINED__
typedef interface ILxWalkStates ILxWalkStates;
#endif 	/* __ILxWalkStates_FWD_DEFINED__ */


#ifndef __ILxAdvanced_FWD_DEFINED__
#define __ILxAdvanced_FWD_DEFINED__
typedef interface ILxAdvanced ILxAdvanced;
#endif 	/* __ILxAdvanced_FWD_DEFINED__ */


#ifndef __ILxLexiconObject_FWD_DEFINED__
#define __ILxLexiconObject_FWD_DEFINED__
typedef interface ILxLexiconObject ILxLexiconObject;
#endif 	/* __ILxLexiconObject_FWD_DEFINED__ */


#ifndef __ILxNotifySink_FWD_DEFINED__
#define __ILxNotifySink_FWD_DEFINED__
typedef interface ILxNotifySink ILxNotifySink;
#endif 	/* __ILxNotifySink_FWD_DEFINED__ */


#ifndef __ILxCustomUISink_FWD_DEFINED__
#define __ILxCustomUISink_FWD_DEFINED__
typedef interface ILxCustomUISink ILxCustomUISink;
#endif 	/* __ILxCustomUISink_FWD_DEFINED__ */


#ifndef __ILxAuthenticateSink_FWD_DEFINED__
#define __ILxAuthenticateSink_FWD_DEFINED__
typedef interface ILxAuthenticateSink ILxAuthenticateSink;
#endif 	/* __ILxAuthenticateSink_FWD_DEFINED__ */


#ifndef __ILxHookLexiconObject_FWD_DEFINED__
#define __ILxHookLexiconObject_FWD_DEFINED__
typedef interface ILxHookLexiconObject ILxHookLexiconObject;
#endif 	/* __ILxHookLexiconObject_FWD_DEFINED__ */


#ifndef __ILxNotifySource_FWD_DEFINED__
#define __ILxNotifySource_FWD_DEFINED__
typedef interface ILxNotifySource ILxNotifySource;
#endif 	/* __ILxNotifySource_FWD_DEFINED__ */


#ifndef __ILxSynchWithLexicon_FWD_DEFINED__
#define __ILxSynchWithLexicon_FWD_DEFINED__
typedef interface ILxSynchWithLexicon ILxSynchWithLexicon;
#endif 	/* __ILxSynchWithLexicon_FWD_DEFINED__ */


#ifndef __Lexicon_FWD_DEFINED__
#define __Lexicon_FWD_DEFINED__

#ifdef __cplusplus
typedef class Lexicon Lexicon;
#else
typedef struct Lexicon Lexicon;
#endif /* __cplusplus */

#endif 	/* __Lexicon_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_LexAPI_0000 */
/* [local] */ 


enum LEX_TYPE
    {	LEXTYPE_USER	= 1,
	LEXTYPE_APP	= 2,
	LEXTYPE_VENDOR	= 4,
	LEXTYPE_GUESS	= 8
    };

enum PART_OF_SPEECH
    {	NOUN	= 0,
	ADJ	= NOUN + 1,
	ADV	= ADJ + 1,
	VERB	= ADV + 1,
	PRPRN	= VERB + 1,
	FNME	= PRPRN + 1,
	DET	= FNME + 1,
	PREP	= DET + 1,
	IJ	= PREP + 1,
	PRONOUN	= IJ + 1,
	CONJ	= PRONOUN + 1,
	ANY	= CONJ + 1,
	DEL	= ANY + 1
    };

enum WORDINFOTYPE
    {	PRON	= 1,
	SR_PRON	= 2,
	TTS_PRON	= 3,
	POS	= 4
    };
#define	DONT_CARE_LCID	( ( LCID  )-1 )

#define	MAX_STRING_LEN	( 128 )

#define	MAX_PRON_LEN	( 384 )

#define	MAX_NUM_LEXINFO	( 16 )

#define	MAX_NUM_LANGS_SUPPORTED	( 16 )

#define	LEXERR_INVALIDTEXTCHAR	( 0x80040801 )

#define	LEXERR_NOTINLEX	( 0x80040803 )

#define	LEXERR_LCIDNOTFOUND	( 0x8004080b )

#define	LEXERR_APPLEXNOTSET	( 0x8004080d )

#define	LEXERR_VERYOUTOFSYNC	( 0x8004080e )

#define	LEXERR_SETUSERLEXICON	( 0x8004080f )

#define	LEXERR_BADLCID	( 0x80040810 )

#define	LEXERR_BADINFOTYPE	( 0x80040811 )

#define	LEXERR_BADLEXTYPE	( 0x80040812 )

#define	LEXERR_BADINDEXBUFFER	( 0x80040813 )

#define	LEXERR_BADWORDINFOBUFFER	( 0x80040814 )

#define	LEXERR_BADWORDPRONBUFFER	( 0x80040815 )

typedef /* [switch_type] */ union _WORD_INFO_UNION
    {
    /* [case()] */ WCHAR wPronunciation[ 1 ];
    /* [case()] */ WORD POS;
    /* [default] */  /* Empty union arm */ 
    }	LEX_WORD_INFO_UNION;

typedef /* [public] */ struct  __MIDL___MIDL_itf_LexAPI_0000_0001
    {
    WORD Type;
    union 
        {
        WCHAR wPronunciation[ 1 ];
        WORD POS;
        }	;
    }	LEX_WORD_INFO;

typedef struct __MIDL___MIDL_itf_LexAPI_0000_0001 __RPC_FAR *PLEX_WORD_INFO;

typedef /* [public] */ struct  __MIDL___MIDL_itf_LexAPI_0000_0003
    {
    DWORD cIndexes;
    DWORD cWordsAllocated;
    /* [length_is][size_is] */ WORD __RPC_FAR *pwIndex;
    }	INDEXES_BUFFER;

typedef struct __MIDL___MIDL_itf_LexAPI_0000_0003 __RPC_FAR *PINDEXES_BUFFER;

typedef /* [public] */ struct  __MIDL___MIDL_itf_LexAPI_0000_0004
    {
    DWORD cProns;
    DWORD cWcharsUsed;
    DWORD cWcharsAllocated;
    /* [length_is][size_is] */ WCHAR __RPC_FAR *pwProns;
    }	WORD_PRONS_BUFFER;

typedef struct __MIDL___MIDL_itf_LexAPI_0000_0004 __RPC_FAR *PWORD_PRONS_BUFFER;

typedef /* [public] */ struct  __MIDL___MIDL_itf_LexAPI_0000_0005
    {
    DWORD cInfoBlocks;
    ULONG cBytesUsed;
    ULONG cBytesAllocated;
    /* [length_is][size_is] */ BYTE __RPC_FAR *pInfo;
    }	WORD_INFO_BUFFER;

typedef struct __MIDL___MIDL_itf_LexAPI_0000_0005 __RPC_FAR *PWORD_INFO_BUFFER;

typedef /* [public][public][public] */ struct  __MIDL___MIDL_itf_LexAPI_0000_0006
    {
    DWORD cWords;
    DWORD cWordsBytesUsed;
    DWORD cWordsBytesAllocated;
    /* [length_is][size_is] */ BYTE __RPC_FAR *pWords;
    DWORD cBoolsUsed;
    DWORD cBoolsAllocated;
    /* [length_is][size_is] */ BOOL __RPC_FAR *pfAdd;
    }	WORD_SYNCH_BUFFER;

typedef struct __MIDL___MIDL_itf_LexAPI_0000_0006 __RPC_FAR *PWORD_SYNCH_BUFFER;

typedef /* [public][public][public][public] */ struct  __MIDL___MIDL_itf_LexAPI_0000_0007
    {
    CLSID CLSID;
    DWORD cLcids;
    LCID aLcidsSupported[ 20 ];
    }	VENDOR_CLSID_LCID_HDR;

typedef struct __MIDL___MIDL_itf_LexAPI_0000_0007 __RPC_FAR *PVENDOR_CLSID_LCID_HDR;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_LexAPI_0000_0008
    {
    VENDOR_CLSID_LCID_HDR LcidHdr;
    WCHAR wszManufacturer[ 128 ];
    WCHAR wszDescription[ 256 ];
    }	LEX_HDR;

typedef struct __MIDL___MIDL_itf_LexAPI_0000_0008 __RPC_FAR *PLEX_HDR;

typedef /* [public][public][public][public] */ struct  __MIDL___MIDL_itf_LexAPI_0000_0009
    {
    LCID Lcid;
    DWORD dwLex;
    HRESULT hResult;
    DWORD cUsed;
    DWORD cAllocated;
    WCHAR __RPC_FAR *pwWordNodes;
    DWORD __RPC_FAR *pdwNodePositions;
    WCHAR wNodeChar;
    BOOL fEndofWord;
    }	SEARCH_STATE;

typedef struct __MIDL___MIDL_itf_LexAPI_0000_0009 __RPC_FAR *PSEARCH_STATE;

typedef /* [public][public][public] */ struct  __MIDL___MIDL_itf_LexAPI_0000_0010
    {
    GUID gLexId;
    DWORD dwWordId;
    }	WORD_TOKEN;

typedef struct __MIDL___MIDL_itf_LexAPI_0000_0010 __RPC_FAR *PWORD_TOKEN;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0000_v0_0_s_ifspec;

#ifndef __ILxLexicon_INTERFACE_DEFINED__
#define __ILxLexicon_INTERFACE_DEFINED__

/* interface ILxLexicon */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILxLexicon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4FAF16F6-F75B-11D2-9C24-00C04F8EF87C")
    ILxLexicon : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUser( 
            /* [in] */ WCHAR __RPC_FAR *pwUserName,
            /* [in] */ DWORD cLcids,
            /* [size_is][out] */ LCID __RPC_FAR *pLcidsSupported) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUser( 
            /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwUserName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAppLexicon( 
            /* [in] */ WCHAR __RPC_FAR *pwPathFileName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWordPronunciations( 
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ DWORD dwLex,
            /* [out][in] */ PWORD_PRONS_BUFFER pProns,
            /* [out][in] */ PINDEXES_BUFFER pIndexes,
            /* [out][in] */ DWORD __RPC_FAR *pdwLexTypeFound,
            /* [out][in] */ GUID __RPC_FAR *pGuidLexFound) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWordInformation( 
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ DWORD dwTypes,
            /* [in] */ DWORD dwLex,
            /* [out][in] */ PWORD_INFO_BUFFER pInfo,
            /* [out][in] */ PINDEXES_BUFFER pIndexes,
            /* [out][in] */ DWORD __RPC_FAR *pdwLexTypeFound,
            /* [out][in] */ GUID __RPC_FAR *pGuidLexFound) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddWordPronunciations( 
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ PWORD_PRONS_BUFFER pProns) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddWordInformation( 
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ PWORD_INFO_BUFFER pInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveWord( 
            const WCHAR __RPC_FAR *pwWord,
            LCID lcid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeLexiconUI( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILxLexiconVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILxLexicon __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILxLexicon __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILxLexicon __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUser )( 
            ILxLexicon __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwUserName,
            /* [in] */ DWORD cLcids,
            /* [size_is][out] */ LCID __RPC_FAR *pLcidsSupported);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUser )( 
            ILxLexicon __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwUserName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAppLexicon )( 
            ILxLexicon __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwPathFileName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWordPronunciations )( 
            ILxLexicon __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ DWORD dwLex,
            /* [out][in] */ PWORD_PRONS_BUFFER pProns,
            /* [out][in] */ PINDEXES_BUFFER pIndexes,
            /* [out][in] */ DWORD __RPC_FAR *pdwLexTypeFound,
            /* [out][in] */ GUID __RPC_FAR *pGuidLexFound);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWordInformation )( 
            ILxLexicon __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ DWORD dwTypes,
            /* [in] */ DWORD dwLex,
            /* [out][in] */ PWORD_INFO_BUFFER pInfo,
            /* [out][in] */ PINDEXES_BUFFER pIndexes,
            /* [out][in] */ DWORD __RPC_FAR *pdwLexTypeFound,
            /* [out][in] */ GUID __RPC_FAR *pGuidLexFound);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddWordPronunciations )( 
            ILxLexicon __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ PWORD_PRONS_BUFFER pProns);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddWordInformation )( 
            ILxLexicon __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ PWORD_INFO_BUFFER pInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveWord )( 
            ILxLexicon __RPC_FAR * This,
            const WCHAR __RPC_FAR *pwWord,
            LCID lcid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeLexiconUI )( 
            ILxLexicon __RPC_FAR * This);
        
        END_INTERFACE
    } ILxLexiconVtbl;

    interface ILxLexicon
    {
        CONST_VTBL struct ILxLexiconVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILxLexicon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILxLexicon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILxLexicon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILxLexicon_SetUser(This,pwUserName,cLcids,pLcidsSupported)	\
    (This)->lpVtbl -> SetUser(This,pwUserName,cLcids,pLcidsSupported)

#define ILxLexicon_GetUser(This,pwUserName)	\
    (This)->lpVtbl -> GetUser(This,pwUserName)

#define ILxLexicon_SetAppLexicon(This,pwPathFileName)	\
    (This)->lpVtbl -> SetAppLexicon(This,pwPathFileName)

#define ILxLexicon_GetWordPronunciations(This,pwWord,lcid,dwLex,pProns,pIndexes,pdwLexTypeFound,pGuidLexFound)	\
    (This)->lpVtbl -> GetWordPronunciations(This,pwWord,lcid,dwLex,pProns,pIndexes,pdwLexTypeFound,pGuidLexFound)

#define ILxLexicon_GetWordInformation(This,pwWord,lcid,dwTypes,dwLex,pInfo,pIndexes,pdwLexTypeFound,pGuidLexFound)	\
    (This)->lpVtbl -> GetWordInformation(This,pwWord,lcid,dwTypes,dwLex,pInfo,pIndexes,pdwLexTypeFound,pGuidLexFound)

#define ILxLexicon_AddWordPronunciations(This,pwWord,lcid,pProns)	\
    (This)->lpVtbl -> AddWordPronunciations(This,pwWord,lcid,pProns)

#define ILxLexicon_AddWordInformation(This,pwWord,lcid,pInfo)	\
    (This)->lpVtbl -> AddWordInformation(This,pwWord,lcid,pInfo)

#define ILxLexicon_RemoveWord(This,pwWord,lcid)	\
    (This)->lpVtbl -> RemoveWord(This,pwWord,lcid)

#define ILxLexicon_InvokeLexiconUI(This)	\
    (This)->lpVtbl -> InvokeLexiconUI(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexicon_SetUser_Proxy( 
    ILxLexicon __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwUserName,
    /* [in] */ DWORD cLcids,
    /* [size_is][out] */ LCID __RPC_FAR *pLcidsSupported);


void __RPC_STUB ILxLexicon_SetUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexicon_GetUser_Proxy( 
    ILxLexicon __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *pwUserName);


void __RPC_STUB ILxLexicon_GetUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexicon_SetAppLexicon_Proxy( 
    ILxLexicon __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwPathFileName);


void __RPC_STUB ILxLexicon_SetAppLexicon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexicon_GetWordPronunciations_Proxy( 
    ILxLexicon __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwWord,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwLex,
    /* [out][in] */ PWORD_PRONS_BUFFER pProns,
    /* [out][in] */ PINDEXES_BUFFER pIndexes,
    /* [out][in] */ DWORD __RPC_FAR *pdwLexTypeFound,
    /* [out][in] */ GUID __RPC_FAR *pGuidLexFound);


void __RPC_STUB ILxLexicon_GetWordPronunciations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexicon_GetWordInformation_Proxy( 
    ILxLexicon __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwWord,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwTypes,
    /* [in] */ DWORD dwLex,
    /* [out][in] */ PWORD_INFO_BUFFER pInfo,
    /* [out][in] */ PINDEXES_BUFFER pIndexes,
    /* [out][in] */ DWORD __RPC_FAR *pdwLexTypeFound,
    /* [out][in] */ GUID __RPC_FAR *pGuidLexFound);


void __RPC_STUB ILxLexicon_GetWordInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexicon_AddWordPronunciations_Proxy( 
    ILxLexicon __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwWord,
    /* [in] */ LCID lcid,
    /* [in] */ PWORD_PRONS_BUFFER pProns);


void __RPC_STUB ILxLexicon_AddWordPronunciations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexicon_AddWordInformation_Proxy( 
    ILxLexicon __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwWord,
    /* [in] */ LCID lcid,
    /* [in] */ PWORD_INFO_BUFFER pInfo);


void __RPC_STUB ILxLexicon_AddWordInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexicon_RemoveWord_Proxy( 
    ILxLexicon __RPC_FAR * This,
    const WCHAR __RPC_FAR *pwWord,
    LCID lcid);


void __RPC_STUB ILxLexicon_RemoveWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexicon_InvokeLexiconUI_Proxy( 
    ILxLexicon __RPC_FAR * This);


void __RPC_STUB ILxLexicon_InvokeLexiconUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILxLexicon_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_LexAPI_0208 */
/* [local] */ 

typedef ILxLexicon __RPC_FAR *PILXLEXICON;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0208_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0208_v0_0_s_ifspec;

#ifndef __ILxWalkStates_INTERFACE_DEFINED__
#define __ILxWalkStates_INTERFACE_DEFINED__

/* interface ILxWalkStates */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILxWalkStates;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85A9C6FE-1490-11d3-9C25-00C04F8EF87C")
    ILxWalkStates : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLexCount( 
            /* [out] */ DWORD __RPC_FAR *dwNumUserLex,
            /* [out] */ DWORD __RPC_FAR *dwNumAppLex,
            /* [out] */ DWORD __RPC_FAR *dwNumVendorLex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSibling( 
            /* [in] */ DWORD dwNumSearchStates,
            /* [size_is][out][in] */ SEARCH_STATE __RPC_FAR *pState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChild( 
            /* [in] */ DWORD dwNumSearchStates,
            /* [size_is][out][in] */ SEARCH_STATE __RPC_FAR *pState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindSibling( 
            /* [in] */ DWORD dwNumSearchStates,
            /* [in] */ WCHAR wNodeChar,
            /* [size_is][out][in] */ SEARCH_STATE __RPC_FAR *pState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILxWalkStatesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILxWalkStates __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILxWalkStates __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILxWalkStates __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLexCount )( 
            ILxWalkStates __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *dwNumUserLex,
            /* [out] */ DWORD __RPC_FAR *dwNumAppLex,
            /* [out] */ DWORD __RPC_FAR *dwNumVendorLex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSibling )( 
            ILxWalkStates __RPC_FAR * This,
            /* [in] */ DWORD dwNumSearchStates,
            /* [size_is][out][in] */ SEARCH_STATE __RPC_FAR *pState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChild )( 
            ILxWalkStates __RPC_FAR * This,
            /* [in] */ DWORD dwNumSearchStates,
            /* [size_is][out][in] */ SEARCH_STATE __RPC_FAR *pState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindSibling )( 
            ILxWalkStates __RPC_FAR * This,
            /* [in] */ DWORD dwNumSearchStates,
            /* [in] */ WCHAR wNodeChar,
            /* [size_is][out][in] */ SEARCH_STATE __RPC_FAR *pState);
        
        END_INTERFACE
    } ILxWalkStatesVtbl;

    interface ILxWalkStates
    {
        CONST_VTBL struct ILxWalkStatesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILxWalkStates_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILxWalkStates_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILxWalkStates_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILxWalkStates_GetLexCount(This,dwNumUserLex,dwNumAppLex,dwNumVendorLex)	\
    (This)->lpVtbl -> GetLexCount(This,dwNumUserLex,dwNumAppLex,dwNumVendorLex)

#define ILxWalkStates_GetSibling(This,dwNumSearchStates,pState)	\
    (This)->lpVtbl -> GetSibling(This,dwNumSearchStates,pState)

#define ILxWalkStates_GetChild(This,dwNumSearchStates,pState)	\
    (This)->lpVtbl -> GetChild(This,dwNumSearchStates,pState)

#define ILxWalkStates_FindSibling(This,dwNumSearchStates,wNodeChar,pState)	\
    (This)->lpVtbl -> FindSibling(This,dwNumSearchStates,wNodeChar,pState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxWalkStates_GetLexCount_Proxy( 
    ILxWalkStates __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *dwNumUserLex,
    /* [out] */ DWORD __RPC_FAR *dwNumAppLex,
    /* [out] */ DWORD __RPC_FAR *dwNumVendorLex);


void __RPC_STUB ILxWalkStates_GetLexCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxWalkStates_GetSibling_Proxy( 
    ILxWalkStates __RPC_FAR * This,
    /* [in] */ DWORD dwNumSearchStates,
    /* [size_is][out][in] */ SEARCH_STATE __RPC_FAR *pState);


void __RPC_STUB ILxWalkStates_GetSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxWalkStates_GetChild_Proxy( 
    ILxWalkStates __RPC_FAR * This,
    /* [in] */ DWORD dwNumSearchStates,
    /* [size_is][out][in] */ SEARCH_STATE __RPC_FAR *pState);


void __RPC_STUB ILxWalkStates_GetChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxWalkStates_FindSibling_Proxy( 
    ILxWalkStates __RPC_FAR * This,
    /* [in] */ DWORD dwNumSearchStates,
    /* [in] */ WCHAR wNodeChar,
    /* [size_is][out][in] */ SEARCH_STATE __RPC_FAR *pState);


void __RPC_STUB ILxWalkStates_FindSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILxWalkStates_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_LexAPI_0209 */
/* [local] */ 

typedef ILxWalkStates __RPC_FAR *PILXWALKSTATES;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0209_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0209_v0_0_s_ifspec;

#ifndef __ILxAdvanced_INTERFACE_DEFINED__
#define __ILxAdvanced_INTERFACE_DEFINED__

/* interface ILxAdvanced */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILxAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0639403D-17DF-11d3-9C25-00C04F8EF87C")
    ILxAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddWordProbabilities( 
            /* [in] */ WCHAR __RPC_FAR *pwWord,
            /* [in] */ DWORD dwNumChars,
            /* [size_is][in] */ float __RPC_FAR *pflProb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWordInString( 
            /* [in] */ WCHAR __RPC_FAR *pwString,
            /* [in] */ DWORD dwMinLen,
            /* [out] */ DWORD __RPC_FAR *pdwStartChar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWordToken( 
            /* [in] */ DWORD dwLex,
            /* [in] */ WCHAR __RPC_FAR *pwWord,
            /* [out][in] */ WORD_TOKEN __RPC_FAR *pWordToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWordFromToken( 
            /* [in] */ WORD_TOKEN __RPC_FAR *pWordToken,
            /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *ppwWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBestPath( 
            /* [in] */ BYTE __RPC_FAR *pLattice,
            /* [out][in] */ BYTE __RPC_FAR *pBestPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILxAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILxAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILxAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILxAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddWordProbabilities )( 
            ILxAdvanced __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwWord,
            /* [in] */ DWORD dwNumChars,
            /* [size_is][in] */ float __RPC_FAR *pflProb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWordInString )( 
            ILxAdvanced __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwString,
            /* [in] */ DWORD dwMinLen,
            /* [out] */ DWORD __RPC_FAR *pdwStartChar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWordToken )( 
            ILxAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwLex,
            /* [in] */ WCHAR __RPC_FAR *pwWord,
            /* [out][in] */ WORD_TOKEN __RPC_FAR *pWordToken);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWordFromToken )( 
            ILxAdvanced __RPC_FAR * This,
            /* [in] */ WORD_TOKEN __RPC_FAR *pWordToken,
            /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *ppwWord);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBestPath )( 
            ILxAdvanced __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pLattice,
            /* [out][in] */ BYTE __RPC_FAR *pBestPath);
        
        END_INTERFACE
    } ILxAdvancedVtbl;

    interface ILxAdvanced
    {
        CONST_VTBL struct ILxAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILxAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILxAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILxAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILxAdvanced_AddWordProbabilities(This,pwWord,dwNumChars,pflProb)	\
    (This)->lpVtbl -> AddWordProbabilities(This,pwWord,dwNumChars,pflProb)

#define ILxAdvanced_GetWordInString(This,pwString,dwMinLen,pdwStartChar)	\
    (This)->lpVtbl -> GetWordInString(This,pwString,dwMinLen,pdwStartChar)

#define ILxAdvanced_GetWordToken(This,dwLex,pwWord,pWordToken)	\
    (This)->lpVtbl -> GetWordToken(This,dwLex,pwWord,pWordToken)

#define ILxAdvanced_GetWordFromToken(This,pWordToken,ppwWord)	\
    (This)->lpVtbl -> GetWordFromToken(This,pWordToken,ppwWord)

#define ILxAdvanced_GetBestPath(This,pLattice,pBestPath)	\
    (This)->lpVtbl -> GetBestPath(This,pLattice,pBestPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILxAdvanced_AddWordProbabilities_Proxy( 
    ILxAdvanced __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwWord,
    /* [in] */ DWORD dwNumChars,
    /* [size_is][in] */ float __RPC_FAR *pflProb);


void __RPC_STUB ILxAdvanced_AddWordProbabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILxAdvanced_GetWordInString_Proxy( 
    ILxAdvanced __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwString,
    /* [in] */ DWORD dwMinLen,
    /* [out] */ DWORD __RPC_FAR *pdwStartChar);


void __RPC_STUB ILxAdvanced_GetWordInString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILxAdvanced_GetWordToken_Proxy( 
    ILxAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwLex,
    /* [in] */ WCHAR __RPC_FAR *pwWord,
    /* [out][in] */ WORD_TOKEN __RPC_FAR *pWordToken);


void __RPC_STUB ILxAdvanced_GetWordToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILxAdvanced_GetWordFromToken_Proxy( 
    ILxAdvanced __RPC_FAR * This,
    /* [in] */ WORD_TOKEN __RPC_FAR *pWordToken,
    /* [out] */ WCHAR __RPC_FAR *__RPC_FAR *ppwWord);


void __RPC_STUB ILxAdvanced_GetWordFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILxAdvanced_GetBestPath_Proxy( 
    ILxAdvanced __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pLattice,
    /* [out][in] */ BYTE __RPC_FAR *pBestPath);


void __RPC_STUB ILxAdvanced_GetBestPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILxAdvanced_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_LexAPI_0210 */
/* [local] */ 

typedef ILxAdvanced __RPC_FAR *PILXADVANCED;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0210_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0210_v0_0_s_ifspec;

#ifndef __ILxLexiconObject_INTERFACE_DEFINED__
#define __ILxLexiconObject_INTERFACE_DEFINED__

/* interface ILxLexiconObject */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILxLexiconObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4FAF16FD-F75B-11D2-9C24-00C04F8EF87C")
    ILxLexiconObject : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHeader( 
            /* [out] */ LEX_HDR __RPC_FAR *pLexHdr) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Authenticate( 
            /* [in] */ GUID ClientId,
            /* [out] */ GUID __RPC_FAR *LexId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsAuthenticated( 
            BOOL __RPC_FAR *pfAuthenticated) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWordInformation( 
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ DWORD dwTypes,
            /* [in] */ DWORD dwLex,
            /* [out][in] */ PWORD_INFO_BUFFER pInfo,
            /* [out][in] */ PINDEXES_BUFFER pIndexes,
            /* [out][in] */ DWORD __RPC_FAR *pdwLexTypeFound,
            /* [out][in] */ GUID __RPC_FAR *pGuidLexFound) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddWordInformation( 
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ PWORD_INFO_BUFFER pInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveWord( 
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILxLexiconObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILxLexiconObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILxLexiconObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILxLexiconObject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHeader )( 
            ILxLexiconObject __RPC_FAR * This,
            /* [out] */ LEX_HDR __RPC_FAR *pLexHdr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Authenticate )( 
            ILxLexiconObject __RPC_FAR * This,
            /* [in] */ GUID ClientId,
            /* [out] */ GUID __RPC_FAR *LexId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsAuthenticated )( 
            ILxLexiconObject __RPC_FAR * This,
            BOOL __RPC_FAR *pfAuthenticated);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWordInformation )( 
            ILxLexiconObject __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ DWORD dwTypes,
            /* [in] */ DWORD dwLex,
            /* [out][in] */ PWORD_INFO_BUFFER pInfo,
            /* [out][in] */ PINDEXES_BUFFER pIndexes,
            /* [out][in] */ DWORD __RPC_FAR *pdwLexTypeFound,
            /* [out][in] */ GUID __RPC_FAR *pGuidLexFound);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddWordInformation )( 
            ILxLexiconObject __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid,
            /* [in] */ PWORD_INFO_BUFFER pInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveWord )( 
            ILxLexiconObject __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwWord,
            /* [in] */ LCID lcid);
        
        END_INTERFACE
    } ILxLexiconObjectVtbl;

    interface ILxLexiconObject
    {
        CONST_VTBL struct ILxLexiconObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILxLexiconObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILxLexiconObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILxLexiconObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILxLexiconObject_GetHeader(This,pLexHdr)	\
    (This)->lpVtbl -> GetHeader(This,pLexHdr)

#define ILxLexiconObject_Authenticate(This,ClientId,LexId)	\
    (This)->lpVtbl -> Authenticate(This,ClientId,LexId)

#define ILxLexiconObject_IsAuthenticated(This,pfAuthenticated)	\
    (This)->lpVtbl -> IsAuthenticated(This,pfAuthenticated)

#define ILxLexiconObject_GetWordInformation(This,pwWord,lcid,dwTypes,dwLex,pInfo,pIndexes,pdwLexTypeFound,pGuidLexFound)	\
    (This)->lpVtbl -> GetWordInformation(This,pwWord,lcid,dwTypes,dwLex,pInfo,pIndexes,pdwLexTypeFound,pGuidLexFound)

#define ILxLexiconObject_AddWordInformation(This,pwWord,lcid,pInfo)	\
    (This)->lpVtbl -> AddWordInformation(This,pwWord,lcid,pInfo)

#define ILxLexiconObject_RemoveWord(This,pwWord,lcid)	\
    (This)->lpVtbl -> RemoveWord(This,pwWord,lcid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexiconObject_GetHeader_Proxy( 
    ILxLexiconObject __RPC_FAR * This,
    /* [out] */ LEX_HDR __RPC_FAR *pLexHdr);


void __RPC_STUB ILxLexiconObject_GetHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexiconObject_Authenticate_Proxy( 
    ILxLexiconObject __RPC_FAR * This,
    /* [in] */ GUID ClientId,
    /* [out] */ GUID __RPC_FAR *LexId);


void __RPC_STUB ILxLexiconObject_Authenticate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexiconObject_IsAuthenticated_Proxy( 
    ILxLexiconObject __RPC_FAR * This,
    BOOL __RPC_FAR *pfAuthenticated);


void __RPC_STUB ILxLexiconObject_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexiconObject_GetWordInformation_Proxy( 
    ILxLexiconObject __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwWord,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwTypes,
    /* [in] */ DWORD dwLex,
    /* [out][in] */ PWORD_INFO_BUFFER pInfo,
    /* [out][in] */ PINDEXES_BUFFER pIndexes,
    /* [out][in] */ DWORD __RPC_FAR *pdwLexTypeFound,
    /* [out][in] */ GUID __RPC_FAR *pGuidLexFound);


void __RPC_STUB ILxLexiconObject_GetWordInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexiconObject_AddWordInformation_Proxy( 
    ILxLexiconObject __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwWord,
    /* [in] */ LCID lcid,
    /* [in] */ PWORD_INFO_BUFFER pInfo);


void __RPC_STUB ILxLexiconObject_AddWordInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxLexiconObject_RemoveWord_Proxy( 
    ILxLexiconObject __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwWord,
    /* [in] */ LCID lcid);


void __RPC_STUB ILxLexiconObject_RemoveWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILxLexiconObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_LexAPI_0211 */
/* [local] */ 

typedef ILxLexiconObject __RPC_FAR *PILXLEXICONOBJECT;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0211_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0211_v0_0_s_ifspec;

#ifndef __ILxNotifySink_INTERFACE_DEFINED__
#define __ILxNotifySink_INTERFACE_DEFINED__

/* interface ILxNotifySink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILxNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("32C5378E-04CD-11d3-9C24-00C04F8EF87C")
    ILxNotifySink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyAppLexiconChange( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyUserLexiconChange( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILxNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILxNotifySink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILxNotifySink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILxNotifySink __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyAppLexiconChange )( 
            ILxNotifySink __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyUserLexiconChange )( 
            ILxNotifySink __RPC_FAR * This);
        
        END_INTERFACE
    } ILxNotifySinkVtbl;

    interface ILxNotifySink
    {
        CONST_VTBL struct ILxNotifySinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILxNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILxNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILxNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILxNotifySink_NotifyAppLexiconChange(This)	\
    (This)->lpVtbl -> NotifyAppLexiconChange(This)

#define ILxNotifySink_NotifyUserLexiconChange(This)	\
    (This)->lpVtbl -> NotifyUserLexiconChange(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxNotifySink_NotifyAppLexiconChange_Proxy( 
    ILxNotifySink __RPC_FAR * This);


void __RPC_STUB ILxNotifySink_NotifyAppLexiconChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxNotifySink_NotifyUserLexiconChange_Proxy( 
    ILxNotifySink __RPC_FAR * This);


void __RPC_STUB ILxNotifySink_NotifyUserLexiconChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILxNotifySink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_LexAPI_0212 */
/* [local] */ 

typedef ILxNotifySink __RPC_FAR *PILXNOTIFYSINK;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0212_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0212_v0_0_s_ifspec;

#ifndef __ILxCustomUISink_INTERFACE_DEFINED__
#define __ILxCustomUISink_INTERFACE_DEFINED__

/* interface ILxCustomUISink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILxCustomUISink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E8C668C2-1C7A-11d3-9C25-00C04F8EF87C")
    ILxCustomUISink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeCustomUI( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILxCustomUISinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILxCustomUISink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILxCustomUISink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILxCustomUISink __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeCustomUI )( 
            ILxCustomUISink __RPC_FAR * This);
        
        END_INTERFACE
    } ILxCustomUISinkVtbl;

    interface ILxCustomUISink
    {
        CONST_VTBL struct ILxCustomUISinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILxCustomUISink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILxCustomUISink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILxCustomUISink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILxCustomUISink_InvokeCustomUI(This)	\
    (This)->lpVtbl -> InvokeCustomUI(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxCustomUISink_InvokeCustomUI_Proxy( 
    ILxCustomUISink __RPC_FAR * This);


void __RPC_STUB ILxCustomUISink_InvokeCustomUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILxCustomUISink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_LexAPI_0213 */
/* [local] */ 

typedef ILxCustomUISink __RPC_FAR *PILXCUSTOMUISINK;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0213_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0213_v0_0_s_ifspec;

#ifndef __ILxAuthenticateSink_INTERFACE_DEFINED__
#define __ILxAuthenticateSink_INTERFACE_DEFINED__

/* interface ILxAuthenticateSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILxAuthenticateSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F7E615A8-1231-11d3-9C24-00C04F8EF87C")
    ILxAuthenticateSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AuthenticateVendorLexicons( 
            /* [in] */ DWORD dwNumLexiconObjects,
            /* [size_is][size_is][in] */ ILxLexiconObject __RPC_FAR *__RPC_FAR *ppLexiconObjects,
            /* [size_is][out] */ BOOL __RPC_FAR *pbAuthenticated) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILxAuthenticateSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILxAuthenticateSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILxAuthenticateSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILxAuthenticateSink __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AuthenticateVendorLexicons )( 
            ILxAuthenticateSink __RPC_FAR * This,
            /* [in] */ DWORD dwNumLexiconObjects,
            /* [size_is][size_is][in] */ ILxLexiconObject __RPC_FAR *__RPC_FAR *ppLexiconObjects,
            /* [size_is][out] */ BOOL __RPC_FAR *pbAuthenticated);
        
        END_INTERFACE
    } ILxAuthenticateSinkVtbl;

    interface ILxAuthenticateSink
    {
        CONST_VTBL struct ILxAuthenticateSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILxAuthenticateSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILxAuthenticateSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILxAuthenticateSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILxAuthenticateSink_AuthenticateVendorLexicons(This,dwNumLexiconObjects,ppLexiconObjects,pbAuthenticated)	\
    (This)->lpVtbl -> AuthenticateVendorLexicons(This,dwNumLexiconObjects,ppLexiconObjects,pbAuthenticated)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxAuthenticateSink_AuthenticateVendorLexicons_Proxy( 
    ILxAuthenticateSink __RPC_FAR * This,
    /* [in] */ DWORD dwNumLexiconObjects,
    /* [size_is][size_is][in] */ ILxLexiconObject __RPC_FAR *__RPC_FAR *ppLexiconObjects,
    /* [size_is][out] */ BOOL __RPC_FAR *pbAuthenticated);


void __RPC_STUB ILxAuthenticateSink_AuthenticateVendorLexicons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILxAuthenticateSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_LexAPI_0214 */
/* [local] */ 

typedef ILxAuthenticateSink __RPC_FAR *PILXAUTHENTICATESINK;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0214_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0214_v0_0_s_ifspec;

#ifndef __ILxHookLexiconObject_INTERFACE_DEFINED__
#define __ILxHookLexiconObject_INTERFACE_DEFINED__

/* interface ILxHookLexiconObject */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILxHookLexiconObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F67C2FF9-1232-11d3-9C24-00C04F8EF87C")
    ILxHookLexiconObject : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetHook( 
            /* [in] */ ILxLexiconObject __RPC_FAR *pLexiconObject,
            /* [in] */ BOOL fTopVendor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILxHookLexiconObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILxHookLexiconObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILxHookLexiconObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILxHookLexiconObject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHook )( 
            ILxHookLexiconObject __RPC_FAR * This,
            /* [in] */ ILxLexiconObject __RPC_FAR *pLexiconObject,
            /* [in] */ BOOL fTopVendor);
        
        END_INTERFACE
    } ILxHookLexiconObjectVtbl;

    interface ILxHookLexiconObject
    {
        CONST_VTBL struct ILxHookLexiconObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILxHookLexiconObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILxHookLexiconObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILxHookLexiconObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILxHookLexiconObject_SetHook(This,pLexiconObject,fTopVendor)	\
    (This)->lpVtbl -> SetHook(This,pLexiconObject,fTopVendor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxHookLexiconObject_SetHook_Proxy( 
    ILxHookLexiconObject __RPC_FAR * This,
    /* [in] */ ILxLexiconObject __RPC_FAR *pLexiconObject,
    /* [in] */ BOOL fTopVendor);


void __RPC_STUB ILxHookLexiconObject_SetHook_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILxHookLexiconObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_LexAPI_0215 */
/* [local] */ 

typedef ILxHookLexiconObject __RPC_FAR *PILXHOOKLEXICONOBJECT;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0215_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0215_v0_0_s_ifspec;

#ifndef __ILxNotifySource_INTERFACE_DEFINED__
#define __ILxNotifySource_INTERFACE_DEFINED__

/* interface ILxNotifySource */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILxNotifySource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA1C3C72-04CD-11d3-9C24-00C04F8EF87C")
    ILxNotifySource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNotifySink( 
            /* [in] */ ILxNotifySink __RPC_FAR *pNotifySink,
            /* [in] */ ILxAuthenticateSink __RPC_FAR *pAuthenticateSink,
            /* [in] */ ILxCustomUISink __RPC_FAR *pCustomUISink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILxNotifySourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILxNotifySource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILxNotifySource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILxNotifySource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifySink )( 
            ILxNotifySource __RPC_FAR * This,
            /* [in] */ ILxNotifySink __RPC_FAR *pNotifySink,
            /* [in] */ ILxAuthenticateSink __RPC_FAR *pAuthenticateSink,
            /* [in] */ ILxCustomUISink __RPC_FAR *pCustomUISink);
        
        END_INTERFACE
    } ILxNotifySourceVtbl;

    interface ILxNotifySource
    {
        CONST_VTBL struct ILxNotifySourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILxNotifySource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILxNotifySource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILxNotifySource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILxNotifySource_SetNotifySink(This,pNotifySink,pAuthenticateSink,pCustomUISink)	\
    (This)->lpVtbl -> SetNotifySink(This,pNotifySink,pAuthenticateSink,pCustomUISink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILxNotifySource_SetNotifySink_Proxy( 
    ILxNotifySource __RPC_FAR * This,
    /* [in] */ ILxNotifySink __RPC_FAR *pNotifySink,
    /* [in] */ ILxAuthenticateSink __RPC_FAR *pAuthenticateSink,
    /* [in] */ ILxCustomUISink __RPC_FAR *pCustomUISink);


void __RPC_STUB ILxNotifySource_SetNotifySink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILxNotifySource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_LexAPI_0216 */
/* [local] */ 

typedef ILxNotifySource __RPC_FAR *PILXNOTIFYSOURCE;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0216_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0216_v0_0_s_ifspec;

#ifndef __ILxSynchWithLexicon_INTERFACE_DEFINED__
#define __ILxSynchWithLexicon_INTERFACE_DEFINED__

/* interface ILxSynchWithLexicon */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILxSynchWithLexicon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FCDAACEE-0954-11d3-9C24-00C04F8EF87C")
    ILxSynchWithLexicon : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAppLexiconID( 
            /* [out] */ GUID __RPC_FAR *ID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAppLexicon( 
            /* [in] */ LCID Lcid,
            /* [in] */ GUID AppId,
            /* [out][in] */ WORD_SYNCH_BUFFER __RPC_FAR *pWordSynchBuffer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChangedUserWords( 
            /* [in] */ LCID Lcid,
            /* [in] */ DWORD dwAddGenerationId,
            /* [in] */ DWORD dwDelGenerationId,
            /* [out] */ DWORD __RPC_FAR *dwNewAddGenerationId,
            /* [out] */ DWORD __RPC_FAR *dwNewDelGenerationId,
            /* [out][in] */ WORD_SYNCH_BUFFER __RPC_FAR *pWordSynchBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILxSynchWithLexiconVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILxSynchWithLexicon __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILxSynchWithLexicon __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILxSynchWithLexicon __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAppLexiconID )( 
            ILxSynchWithLexicon __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *ID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAppLexicon )( 
            ILxSynchWithLexicon __RPC_FAR * This,
            /* [in] */ LCID Lcid,
            /* [in] */ GUID AppId,
            /* [out][in] */ WORD_SYNCH_BUFFER __RPC_FAR *pWordSynchBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChangedUserWords )( 
            ILxSynchWithLexicon __RPC_FAR * This,
            /* [in] */ LCID Lcid,
            /* [in] */ DWORD dwAddGenerationId,
            /* [in] */ DWORD dwDelGenerationId,
            /* [out] */ DWORD __RPC_FAR *dwNewAddGenerationId,
            /* [out] */ DWORD __RPC_FAR *dwNewDelGenerationId,
            /* [out][in] */ WORD_SYNCH_BUFFER __RPC_FAR *pWordSynchBuffer);
        
        END_INTERFACE
    } ILxSynchWithLexiconVtbl;

    interface ILxSynchWithLexicon
    {
        CONST_VTBL struct ILxSynchWithLexiconVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILxSynchWithLexicon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILxSynchWithLexicon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILxSynchWithLexicon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILxSynchWithLexicon_GetAppLexiconID(This,ID)	\
    (This)->lpVtbl -> GetAppLexiconID(This,ID)

#define ILxSynchWithLexicon_GetAppLexicon(This,Lcid,AppId,pWordSynchBuffer)	\
    (This)->lpVtbl -> GetAppLexicon(This,Lcid,AppId,pWordSynchBuffer)

#define ILxSynchWithLexicon_GetChangedUserWords(This,Lcid,dwAddGenerationId,dwDelGenerationId,dwNewAddGenerationId,dwNewDelGenerationId,pWordSynchBuffer)	\
    (This)->lpVtbl -> GetChangedUserWords(This,Lcid,dwAddGenerationId,dwDelGenerationId,dwNewAddGenerationId,dwNewDelGenerationId,pWordSynchBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxSynchWithLexicon_GetAppLexiconID_Proxy( 
    ILxSynchWithLexicon __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *ID);


void __RPC_STUB ILxSynchWithLexicon_GetAppLexiconID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxSynchWithLexicon_GetAppLexicon_Proxy( 
    ILxSynchWithLexicon __RPC_FAR * This,
    /* [in] */ LCID Lcid,
    /* [in] */ GUID AppId,
    /* [out][in] */ WORD_SYNCH_BUFFER __RPC_FAR *pWordSynchBuffer);


void __RPC_STUB ILxSynchWithLexicon_GetAppLexicon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILxSynchWithLexicon_GetChangedUserWords_Proxy( 
    ILxSynchWithLexicon __RPC_FAR * This,
    /* [in] */ LCID Lcid,
    /* [in] */ DWORD dwAddGenerationId,
    /* [in] */ DWORD dwDelGenerationId,
    /* [out] */ DWORD __RPC_FAR *dwNewAddGenerationId,
    /* [out] */ DWORD __RPC_FAR *dwNewDelGenerationId,
    /* [out][in] */ WORD_SYNCH_BUFFER __RPC_FAR *pWordSynchBuffer);


void __RPC_STUB ILxSynchWithLexicon_GetChangedUserWords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILxSynchWithLexicon_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_LexAPI_0217 */
/* [local] */ 

typedef ILxSynchWithLexicon __RPC_FAR *PILXSYNCHWITHLEXICON;



extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0217_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_LexAPI_0217_v0_0_s_ifspec;


#ifndef __LEXAPILib_LIBRARY_DEFINED__
#define __LEXAPILib_LIBRARY_DEFINED__

/* library LEXAPILib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_LEXAPILib;

EXTERN_C const CLSID CLSID_Lexicon;

#ifdef __cplusplus

class DECLSPEC_UUID("4FAF16E7-F75B-11D2-9C24-00C04F8EF87C")
Lexicon;
#endif
#endif /* __LEXAPILib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\managers.cpp ===
#include "PreCompiled.h"

CAPIManager::CAPIManager(LPUNKNOWN pUnkOuter, PFOBJECTDESTROYED pfObjDestroyed)
{
   m_pOuterUnk = pUnkOuter;
   m_pLexicon = NULL;
   m_pfObjDestroyed = pfObjDestroyed;
   m_cRef = 0;
}


CAPIManager::~CAPIManager()
{
   if (m_pLexicon)
      delete m_pLexicon;
}


HRESULT CAPIManager::Init(void)
{
   HRESULT hr = S_OK;

   m_pLexicon = new CLexicon(this, hr);
   if (!m_pLexicon)
   {
      return E_OUTOFMEMORY;
   }

   if (FAILED(hr))
   {
      delete m_pLexicon;
      m_pLexicon = NULL;
   }

   return hr;
}


STDMETHODIMP_ (ULONG) CAPIManager::AddRef(void)
{
   return ++m_cRef;
}


STDMETHODIMP_ (ULONG) CAPIManager::Release(void)
{
   ULONG i = --m_cRef;
   if (0 == i)
   {
      (*m_pfObjDestroyed)();
      delete this;
   }
     
   return i;
}


STDMETHODIMP CAPIManager::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
   *ppv = NULL;

   if (IsEqualIID(riid, IID_IUnknown))
      *ppv = this;

   if (IsEqualIID(riid, IID_ILxLexicon))
      *ppv = (ILxLexicon*)m_pLexicon;

   if (IsEqualIID(riid, IID_ILxWalkStates))
      *ppv = (ILxWalkStates*)m_pLexicon;

   if (IsEqualIID(riid, IID_ILxAdvanced))
      *ppv = (ILxAdvanced*)m_pLexicon;

   if (NULL != *ppv)
   {
      ((LPUNKNOWN)*ppv)->AddRef();
      return NOERROR;
   }

   return E_NOINTERFACE;
}


CVendorManager::CVendorManager(LPUNKNOWN pUnkOuter, 
                               PFOBJECTDESTROYED pfObjDestroyed,
                               CLSID Clsid
                               )
{
   m_pOuterUnk = pUnkOuter;
   m_pVendorLex = NULL;
   m_pfObjDestroyed = pfObjDestroyed;
   m_cRef = 0;
   m_Clsid = Clsid;
}


CVendorManager::~CVendorManager()
{
   delete m_pVendorLex;
}


HRESULT CVendorManager::Init(void)
{
   HRESULT hr = S_OK;
   bool fLkup = true;
   WCHAR *pwFileName1 = NULL;
   WCHAR *pwFileName2 = NULL;

   if (IsEqualCLSID (m_Clsid, CLSID_MSSR1033Lexicon))
   {
      pwFileName1 = L"C:\\LSR1033.lxa";
      pwFileName2 = L"C:\\LLTS1033.lxa";
   }
   else if (IsEqualCLSID (m_Clsid, CLSID_MSTTS1033Lexicon))
   {
      pwFileName1 = L"C:\\LTTS1033.lxa";
      pwFileName2 = L"C:\\LLTS1033.lxa";
   }
   else if (IsEqualCLSID (m_Clsid, CLSID_MSLTS1033Lexicon))
   {
      fLkup = false;
      pwFileName1 = L"C:\\LLTS1033.lxa";
   }
   else if (IsEqualCLSID (m_Clsid, CLSID_MSSR1041Lexicon))
   {
      pwFileName1 = L"C:\\LSR1041.lxa";
      pwFileName2 = L"C:\\LLTS1041.lxa";
   }
   else if (IsEqualCLSID (m_Clsid, CLSID_MSSR2052Lexicon))
   {
      pwFileName1 = L"C:\\LSR2052.lxa";
      pwFileName2 = L"C:\\LLTS1041.lxa"; // We use English LTS
   }
   else if (IsEqualCLSID (m_Clsid, CLSID_MSTTS1041Lexicon))
   {
      pwFileName1 = L"C:\\LTTS1041.lxa";
      pwFileName2 = L"C:\\LLTS1041.lxa";
   }
   else if (IsEqualCLSID (m_Clsid, CLSID_MSTTS2052Lexicon))
   {
      pwFileName1 = L"C:\\LTTS2052.lxa";
      pwFileName2 = L"C:\\LLTS1033.lxa";  // We use English LTS
   }
   else if (IsEqualCLSID (m_Clsid, CLSID_MSLTS1041Lexicon))
   {
      fLkup = false;
      pwFileName1 = L"LLTS1041.lxa";
   }
   else if (IsEqualCLSID (m_Clsid, CLSID_MSLTS2052Lexicon))
   {
      fLkup = false;
      pwFileName1 = L"LLTS1033.lxa";  // We use English LTS
   }

   _ASSERTE(pwFileName1);

   if (fLkup)
      m_pVendorLex = new CLookup(this);
   else
      m_pVendorLex = new CLTS(this);
   
   if (!m_pVendorLex)
   {
      hr = E_OUTOFMEMORY;
      goto ReturnInit;
   }

   hr = m_pVendorLex->Init(pwFileName1, pwFileName2);
   if (FAILED(hr))
      goto ReturnInit;

ReturnInit:

   if (FAILED(hr))
   {
      delete m_pVendorLex;
      m_pVendorLex = NULL;
   }

   return hr;
}


STDMETHODIMP_ (ULONG) CVendorManager::AddRef(void)
{
   return ++m_cRef;
}


STDMETHODIMP_ (ULONG) CVendorManager::Release(void)
{
  ULONG i = --m_cRef;
  if (0 == i)
  {
     (*m_pfObjDestroyed)();

     delete this;
  }
     
  return i;
}


STDMETHODIMP CVendorManager::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
   *ppv = NULL;

   if (IsEqualIID(riid, IID_IUnknown))
   {
      *ppv = this;
   }

   if (IsEqualIID(riid, IID_ILxLexiconObject))
   {
      *ppv = m_pVendorLex;
   }

   if (NULL != *ppv)
   {
      ((LPUNKNOWN)*ppv)->AddRef();
      return NOERROR;
   }

   return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\ltscart.h ===
#ifndef _LTS_CART_H
#define _LTS_CART_H


#include "smalloc.h"

#define INPUT  0
#define OUTPUT 1
#define _LEFT   2
#define _RIGHT  3

#define OUTPUT_QUES_OFFSET 20000
#define RIGHT_QUES_OFFSET 10000
#define QUESTION_CODE_RANGE 1000

#define MAX_PRODUCTS 300

#define CLR_BIT(array, n)       ((array)[(n)/32] &= ~(1<<((n)%32)))
#define SET_BIT(array, n)       ((array)[(n)/32] |=  (1<<((n)%32)))
#define TST_BIT(array, n)       ((array)[(n)/32] &   (1<<((n)%32)))

#define LONGEST_STR 1024
#define NULL_SYMBOL_ID 0
#define NO_SYMBOL -1

typedef unsigned char SYMBOL;

typedef struct 
{
   char szPhone[8];
   __int64 ipaPhone;
} PHONEID;

typedef struct 
{
  int n_symbols;
  int *sym_idx;
  int n_bytes;
  char *storage;
} LTS_SYMTAB;

typedef struct
{
  SYMBOL *pIn;
  SYMBOL *pOut;
} LTS_SAMPLE;

typedef struct 
{
  int n_feat;
  int dim;
  int **feature;
} LTS_FEATURE;

typedef struct t_node 
{
  float entropy_dec;
  int n_samples;
  int *count;
  char *prod;
  int index;
  struct t_node *yes_child;
  struct t_node *no_child;
} T_NODE;

#define NO_CHILD 0
#define IS_LEAF_NODE(x) ((x)->yes == NO_CHILD)
typedef struct 
{
  unsigned short yes;   /* index to yes child, no child will always follow */
  int idx;   /* index to prod (for internal) and dist (for leaf) */     
} LTS_NODE;

typedef struct 
{
  short id;
  short cnt;
} LTS_PAIR;

typedef struct 
{
  int c_dists;
  LTS_PAIR p_pair;
} LTS_DIST;

typedef unsigned short LTS_PROD;

#define PROD_NEG  0x8000
#define MAX_PROD  0x8ffc
#define PROD_TERM 0xfffe
#define QUES_TERM 0xffff

typedef struct 
{
  int n_nodes;
  LTS_NODE *nodes;
  LTS_DIST *p_dist;
  int size_dist;
  LTS_PROD *p_prod;
  int size_prod;
} LTS_TREE;

typedef struct 
{
  char hhp1[cbHhp];
  HHP hhp_outstr;
  char hhp2[cbHhp];
  HHP hhp_strptr;
  char hhp3[cbHhp];
  HHP hhp_outres;
} LTS_HEAP;

#define MAX_ALT_STRINGS 64
#define INC_ALT_STRINGS 32
#define MAX_OUTPUT_STRINGS 10
#define MIN_OUT_PROB 0.01f
#define DEFAULT_PRUNE 0.1f

typedef struct
{
  float prob;
  char  pstr[MAX_PRON_LEN];
} LTS_OUT_PRON;

typedef struct
{
  int num_prons;
  char word[MAX_STRING_LEN];
  LTS_OUT_PRON pron[MAX_OUTPUT_STRINGS];
} LTS_OUTPUT;

typedef struct
{
  float prob;
  SYMBOL psym[MAX_STRING_LEN];
} LTS_OUT_STRING;

typedef struct outresult
{
  int num_strings;
  int num_allocated_strings;
  LTS_OUT_STRING **out_strings;
} LTS_OUT_RESULT;

typedef struct 
{
  LTS_SYMTAB *symbols;
  LTS_FEATURE *features;
  LTS_TREE **tree;
  LTS_HEAP *heap;
  LTS_OUTPUT out;
} LTS_FOREST;

typedef struct simp_question
{
  char questype;
  char context;
  char offset;
  short feature;
} SIMPLE_QUESTION;

#define QUES_DECODE(code, questype, context, offset, feature) \
{ \
  int c = code; \
  if (c > OUTPUT_QUES_OFFSET) { \
    questype = OUTPUT; \
    c -= OUTPUT_QUES_OFFSET; \
  } \
  else \
    questype = INPUT; \
  if (c > RIGHT_QUES_OFFSET) { \
    context = _RIGHT; \
    c -= RIGHT_QUES_OFFSET; \
  } \
  else \
    context = _LEFT; \
  offset = c / QUESTION_CODE_RANGE; \
  feature = c % QUESTION_CODE_RANGE; \
}

#define SAMPLE_GET_CONTEXT(sample, questype, context, offset, id) { \
  SYMBOL *ps, i; \
  if ((questype) == INPUT) \
    ps = (sample)->pIn; \
  else \
    ps = (sample)->pOut; \
  if ((context) == _LEFT) { \
    for (i = 0; i < (offset) && *ps != NULL_SYMBOL_ID; i++, ps--); \
    id = *ps; \
  } \
  else { \
    for (i = 0; i < (offset) && *ps != NULL_SYMBOL_ID; i++, ps++); \
    id = *ps; \
  } \
}

#ifdef __cplusplus
extern "C" {
#endif
LTS_FOREST *LtscartLoadDataFromTree (char *in_sym, char *out_sym, char *in_feat, char *out_feat, 
				                         char *tree_dir, int min_count, float min_entropy_dec, 
                                     char *sample_file);

LTS_FOREST *LtscartReadData (PBYTE);

void LtscartFreeData (LTS_FOREST *l_forest);

LTS_OUTPUT *LtscartGetPron(LTS_FOREST *l_forest, char *word);

char *get_a_word (char *, char *, char);
#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\lexapi_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sun Jun 13 11:26:45 1999
 */
/* Compiler settings for D:\sapi5\Src\Lexicon\LexAPI\LexAPI.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ILxLexicon = {0x4FAF16F6,0xF75B,0x11D2,{0x9C,0x24,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const IID IID_ILxWalkStates = {0x85A9C6FE,0x1490,0x11d3,{0x9C,0x25,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const IID IID_ILxAdvanced = {0x0639403D,0x17DF,0x11d3,{0x9C,0x25,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const IID IID_ILxLexiconObject = {0x4FAF16FD,0xF75B,0x11D2,{0x9C,0x24,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const IID IID_ILxNotifySink = {0x32C5378E,0x04CD,0x11d3,{0x9C,0x24,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const IID IID_ILxCustomUISink = {0xE8C668C2,0x1C7A,0x11d3,{0x9C,0x25,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const IID IID_ILxAuthenticateSink = {0xF7E615A8,0x1231,0x11d3,{0x9C,0x24,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const IID IID_ILxHookLexiconObject = {0xF67C2FF9,0x1232,0x11d3,{0x9C,0x24,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const IID IID_ILxNotifySource = {0xCA1C3C72,0x04CD,0x11d3,{0x9C,0x24,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const IID IID_ILxSynchWithLexicon = {0xFCDAACEE,0x0954,0x11d3,{0x9C,0x24,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const IID LIBID_LEXAPILib = {0x4FAF16E8,0xF75B,0x11D2,{0x9C,0x24,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


const CLSID CLSID_Lexicon = {0x4FAF16E7,0xF75B,0x11D2,{0x9C,0x24,0x00,0xC0,0x4F,0x8E,0xF8,0x7C}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\precompiled.h ===
#ifndef _PRECOMPILED_H_
#define _PRECOMPILED_H_
#include <windows.h>
#include <objbase.h>
#include <objerror.h>
#include <crtdbg.h>
#include <stdio.h>
#include <math.h>
#include "Util.h"
#include "HuffC.h"
#include "HuffD.h"
#include "CRWLock.h"
#include "CDict.h"
#include "LexHdr.h"
#include "MSGenLex.h"
#include "LexAPI.h"
#include "CLexicon.h"
#endif // _PRECOMPILED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\precompiled.cpp ===
#include "PreCompiled.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\msgenlex.h ===
#pragma once

// ------ English Lexicons ----------------------------------------------

// {21F43736-080E-11d3-9C24-00C04F8EF87C}
DEFINE_GUID(CLSID_MSSR1033Lexicon,
0x21f43736, 0x80e, 0x11d3, 0x9c, 0x24, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {CAC05A01-1DEB-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(CLSID_MSTTS1033Lexicon, 
0xcac05a01, 0x1deb, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {9FE33913-1F92-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(CLSID_MSLTS1033Lexicon,
0x9fe33913, 0x1f92, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// ------ Japanese Lexicons ----------------------------------------------

// {CAC05A02-1DEB-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(CLSID_MSSR1041Lexicon, 
0xcac05a02, 0x1deb, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {CAC05A03-1DEB-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(CLSID_MSTTS1041Lexicon, 
0xcac05a03, 0x1deb, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {9FE33914-1F92-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(CLSID_MSLTS1041Lexicon,
0x9fe33914, 0x1f92, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// ------ Simplified Chinese Lexicons ----------------------------------------------

// {CAC05A05-1DEB-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(CLSID_MSSR2052Lexicon, 
0xcac05a05, 0x1deb, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {CAC05A06-1DEB-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(CLSID_MSTTS2052Lexicon, 
0xcac05a06, 0x1deb, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {9FE33916-1F92-11d3-9C25-00C04F8EF87C}
DEFINE_GUID(CLSID_MSLTS2052Lexicon,
0x9fe33916, 0x1f92, 0x11d3, 0x9c, 0x25, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);


HRESULT BuildLookup (LCID lid, GUID LexGuid, const WCHAR * pwLookupTextFile, const WCHAR * pwLookupLexFile, 
                     const WCHAR *pwLtsLexFile, BOOL fUseLtsCode, BOOL fSupIsRealWord);

HRESULT BuildLts (LCID Lcid, GUID LexGuid, PCWSTR pwszLtsRulesFile, PCWSTR pwszPhoneMapFile, PCWSTR pwszLtsLexFile);

typedef (*PBUILDLOOKUP) (LCID, GUID, const WCHAR *, const WCHAR *, const WCHAR *, BOOL, BOOL);
typedef (*PBUILDLTS) (LCID, GUID, PCWSTR, PCWSTR, PCWSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\managers.h ===
/*****************************************************************************
*  Managers.h
*     Declares the manager classes
*
*  Owner: YunusM
*
*  Copyright 1999 Microsoft Corporation All Rights Reserved.
******************************************************************************/

#pragma once

#include "CF.h"
#include "CLexicon.h"
#include "LexHdr.h"

//--- Forward and External Declarations --------------------------------------

class CVendorLexicon;

//--- Class, Struct and Union Definitions ------------------------------------

/*****************************************************************************
* Manager object to manage the classes implementing the LexAPI interfaces
**********************************************************************YUNUSM*/
class CAPIManager : public IUnknown
{
   public:
      CAPIManager(LPUNKNOWN, PFOBJECTDESTROYED);
      ~CAPIManager();
      HRESULT Init();

      STDMETHODIMP_(ULONG) AddRef();
      STDMETHODIMP_(ULONG) Release();
      STDMETHODIMP         QueryInterface(REFIID, LPVOID*);

   private:
      CLexicon *m_pLexicon;
      LPUNKNOWN m_pOuterUnk;
      PFOBJECTDESTROYED m_pfObjDestroyed;
      LONG m_cRef;
}; 


/*****************************************************************************
* Manager object to manage the classes implementing Vendor lexicon interfaces
**********************************************************************YUNUSM*/
class CVendorManager : public IUnknown
{
   friend HRESULT BuildLookup (LCID lid, const WCHAR * pwLookupTextFile, const WCHAR * pwLookupLexFile, 
                   BYTE * pLtsDat, DWORD nLtsDat, BOOL fUseLtsCode, BOOL fSupIsRealWord);
public:
   CVendorManager(LPUNKNOWN, PFOBJECTDESTROYED, CLSID);
   ~CVendorManager();
   HRESULT Init(void);

   STDMETHODIMP_(ULONG) AddRef();
   STDMETHODIMP_(ULONG) Release();
   STDMETHODIMP         QueryInterface(REFIID, LPVOID*);

private:
   CVendorLexicon *m_pVendorLex;
   LPUNKNOWN m_pOuterUnk;
   PFOBJECTDESTROYED m_pfObjDestroyed;
   LONG m_cRef;
   CLSID m_Clsid;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\util.h ===
#pragma once

#include <windows.h>
#include  "LexAPI.h"

void ahtoi (PSTR pStr, PWSTR pH, DWORD *dH = NULL);
void itoah (PWCHAR pH, PSTR pA);
bool LexIsBadStringPtr(const WCHAR * psz, ULONG cMaxChars = 0xFFFF);
HRESULT GuidToString (GUID *pG, PSTR pszG);
void towcslower (PWSTR pw);
DWORD _SizeofWordInfo (PLEX_WORD_INFO pInfo);
HRESULT _ReallocWordPronsBuffer(WORD_PRONS_BUFFER *pWordPron, DWORD dwBytesSize);
HRESULT _ReallocWordInfoBuffer(WORD_INFO_BUFFER *pWordInfo, DWORD dwBytesSize);
HRESULT _ReallocIndexesBuffer(INDEXES_BUFFER *pIndex, DWORD dwIndexes);
HRESULT _InfoToProns(WORD_INFO_BUFFER *pWordInfo, INDEXES_BUFFER *pWordIndex, 
                     WORD_PRONS_BUFFER *pWordPron, INDEXES_BUFFER *pPronIndex);
HRESULT _PronsToInfo(WORD_PRONS_BUFFER *pWordPron, WORD_INFO_BUFFER *pWordInfo);
void _AlignWordInfo(LEX_WORD_INFO *pWordInfoStored, DWORD dwNumInfo, DWORD dwInfoTypeFlags,
                    WORD_INFO_BUFFER *pWordInfoReturned, INDEXES_BUFFER *pwInfoIndex);
bool _IsBadIndexesBuffer(INDEXES_BUFFER *pIndex);
bool _IsBadPron(WCHAR *pwPron, LCID lcid);
bool _IsBadPOS(PART_OF_SPEECH Pos);
bool _IsBadLexType(LEX_TYPE Type);
bool _AreBadLexTypes(DWORD dwTypes);
bool _IsBadWordInfoType(WORDINFOTYPE Type);
bool _AreBadWordInfoTypes(DWORD dwTypes);
bool _IsBadLcid(LCID lcid);
bool _IsBadWordPronsBuffer(WORD_PRONS_BUFFER *pWordProns, LCID lcid, bool fValidateProns = false);
bool _IsBadWordInfoBuffer(WORD_INFO_BUFFER *pWordInfo, LCID lcid, bool fValidateInfo = false);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\lexapi\util.cpp ===
/*****************************************************************************
*  Util.cpp
*     Implements utility and validation functions
*
*  Owner: YunusM
*
*  Copyright 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#include "PreCompiled.h"

// convert space separated tokens to an array of shorts
void ahtoi (PSTR pStr, PWSTR pH, DWORD *dH)
{
   char pA[1024];
   strcpy (pA, pStr);

   if (dH)
      *dH = 0;

   int n = 0;
   char Sep[] = {' '};
   PSTR p = strtok (pA, Sep);

   while (p) {
      // reverse p
      int i = 0;
      int j = strlen (p) - 1;

      while (i < j) {
         char c = p[j];
         p[j] = p[i];
         p[i] = c;

         i++;
         j--;
      }

      i = 0;
      j = 0;

      while (*p) {
         int k = *p;
         if (k >= 'a')
            k = 10 + k - 'a';
         else
            k -= '0';

         for (int m = 0, q = 1; m < j; m++)
            q *= 16;

         j++;
         i += k * q;
         p++;
      }

      pH[n++] = (WORD)i;

      p = strtok (NULL, Sep);
   }

   pH[n] = 0;

   if (dH)
      *dH = n;
}


void itoah (PWCHAR pH, PSTR pA)
{                                    
   *pA = 0;

   DWORD dH = wcslen (pH);

   for (DWORD i = 0; i < dH; i++) {
      char sz[128];
      sprintf (sz, "%x ", pH[i]);
      strcat (pA, sz);
   }

   int len = strlen (pA);

   if (len)
      pA [len - 1] = 0;
}

bool LexIsBadStringPtr(const WCHAR * psz, ULONG cMaxChars)
{
    bool IsBad = false;
    __try
    {
        do
        {
            if( *psz++ == 0 ) return IsBad;
        }
        while( --cMaxChars );
    }
    __except( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION )
    {
        IsBad = true;
//        _ASSERT(0);
    }
    return IsBad;
} // bool LexIsBadStringPtr(const WCHAR * psz, ULONG cMaxChars)

HRESULT GuidToString (GUID *pG, PSTR pszG)
{
   if (IsBadWritePtr (pszG, 38))
      return E_INVALIDARG;

   PBYTE p = (PBYTE)(pG->Data4);

   sprintf (pszG, "%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X", pG->Data1, pG->Data2, pG->Data3, p[0], p[1],
                  p[2], p[3], p[4], p[5], p[6], p[7]);

   return NOERROR;

} // HRESULT GuidToString (GUID pG, char pszG)


void towcslower (PWSTR pw)
{
   PWSTR p = pw;

   while (*p)
   {
      *p = towlower (*p);
      p++;
   }

} // void towcslower (PWSTR pw)


DWORD _SizeofWordInfo (PLEX_WORD_INFO p)
{
   DWORD nInfoSize = 0;

   nInfoSize = sizeof (LEX_WORD_INFO);

   switch (p->Type)
   {
   case PRON:
      {
        DWORD d = (wcslen (p->wPronunciation) + 1) * sizeof (WCHAR);
        if (d > sizeof (LEX_WORD_INFO_UNION))
        {
           nInfoSize += d - sizeof (LEX_WORD_INFO_UNION);
        }
        break;
      }
      // Nothing to add for type POS. It is included in sizeof (LEX_WORD_INFO)
   }

   return nInfoSize;
} // DWORD _SizeofWordInfo (PLEX_WORD_INFO pInfo)


HRESULT _ReallocWordPronsBuffer(WORD_PRONS_BUFFER *pWordPron, DWORD dwBytesSize)
{
   if (pWordPron->cWcharsAllocated * sizeof(WCHAR) < dwBytesSize)
   {
      dwBytesSize += (dwBytesSize % sizeof(WCHAR));
      WCHAR *p = (WCHAR *)CoTaskMemRealloc(pWordPron->pwProns, dwBytesSize);
      if (!p)
         return E_OUTOFMEMORY;
      pWordPron->pwProns = (WCHAR *)p;
      pWordPron->cWcharsAllocated = dwBytesSize/sizeof(WCHAR);
   }

   return S_OK;
} // HRESULT _ReallocWordPronsBuffer(WORD_PRON_BUFFER *pWordPron)


HRESULT _ReallocWordInfoBuffer(WORD_INFO_BUFFER *pWordInfo, DWORD dwBytesSize)
{
   if (pWordInfo->cBytesAllocated < dwBytesSize)
   {
      BYTE *p = (BYTE *)CoTaskMemRealloc(pWordInfo->pInfo, dwBytesSize);
      if (!p)
         return E_OUTOFMEMORY;
      pWordInfo->pInfo = p;
      pWordInfo->cBytesAllocated = dwBytesSize;
   }

   return S_OK;
} // HRESULT _ReallocWordInfoBuffer(WORD_INFO_BUFFER *pWordInfo)


HRESULT _ReallocIndexesBuffer(INDEXES_BUFFER *pIndex, DWORD dwIndexes)
{
   if (pIndex->cWordsAllocated < dwIndexes)
   {
      WORD *p = (WORD *)CoTaskMemRealloc(pIndex->pwIndex, dwIndexes * sizeof(WORD));
      if (!p)
         return E_OUTOFMEMORY;
      pIndex->pwIndex = p;
      pIndex->cWordsAllocated = dwIndexes;
   }

   return S_OK;
} // HRESULT _ReallocIndexesBuffer(INDEXES_BUFFER *pIndex, DWORD dwIndexes)


HRESULT _InfoToProns(WORD_INFO_BUFFER *pWordInfo, 
                     INDEXES_BUFFER *pWordIndex, 
                     WORD_PRONS_BUFFER *pWordPron,
                     INDEXES_BUFFER *pPronIndex
                     )
{
   // Not validating arguments since this function is only called by internal clients

   HRESULT hr = _ReallocWordPronsBuffer(pWordPron, pWordInfo->cBytesAllocated);
   if (FAILED(hr))
      return hr;

   hr = _ReallocIndexesBuffer(pPronIndex, pWordIndex->cIndexes);
   if (FAILED(hr))
      return hr;

   _ASSERTE(pWordInfo->cInfoBlocks == pWordIndex->cIndexes);

   pWordPron->cProns = pWordInfo->cInfoBlocks;

   WCHAR *pwProns = pWordPron->pwProns;
   BYTE *pInfo = pWordInfo->pInfo;
   DWORD dwLen = 0;
   pPronIndex->cIndexes = 0;

   for (DWORD i = 0; i < pWordInfo->cInfoBlocks; i++)
   {
      if (((LEX_WORD_INFO*)(pInfo + dwLen))->Type != PRON)
         continue;

      (pWordIndex->pwIndex)[(pPronIndex->cIndexes)++] = (unsigned short)(pwProns - pWordPron->pwProns);

      wcscpy(pwProns, ((LEX_WORD_INFO*)(pInfo + dwLen))->wPronunciation);

      dwLen += _SizeofWordInfo((LEX_WORD_INFO*)(pInfo + dwLen));
      pwProns += wcslen(pwProns) + 1;
   }

   if (pwProns - pWordPron->pwProns > (int)pWordPron->cWcharsAllocated ||
       pPronIndex->cIndexes > pWordIndex->cIndexes)
      return E_FAIL;

   pWordPron->cWcharsUsed = pwProns - pWordPron->pwProns;

   return S_OK;
} // HRESULT _InfoToProns(WORD_INFO_BUFFER *pWordInfo, WORD_PRON_BUFFER *pWordPron)


HRESULT _PronsToInfo(WORD_PRONS_BUFFER *pWordPron, WORD_INFO_BUFFER *pWordInfo)
{
   // Not validating arguments since this function is only called by internal clients

   HRESULT hr = _ReallocWordInfoBuffer(pWordInfo, 
      pWordPron->cProns * sizeof(LEX_WORD_INFO) + pWordPron->cWcharsUsed * sizeof(WCHAR));
   if (FAILED(hr))
      return hr;

   pWordInfo->cInfoBlocks = pWordPron->cProns;

   BYTE *p = pWordInfo->pInfo;
   WCHAR *pPron = pWordPron->pwProns;

   DWORD dwBytesUsed = 0;

   for (DWORD i = 0; i < pWordPron->cProns; i++)
   {
      ((LEX_WORD_INFO *)(p + dwBytesUsed))->Type = PRON;
      wcscpy(((LEX_WORD_INFO *)(p + dwBytesUsed))->wPronunciation, pPron);
      dwBytesUsed += _SizeofWordInfo((LEX_WORD_INFO *)(p + dwBytesUsed));
      pPron += wcslen(pPron) + 1;
   }

   if (dwBytesUsed > pWordInfo->cBytesAllocated)
      return E_FAIL;

   pWordInfo->cBytesUsed = dwBytesUsed;

   return S_OK;
} // HRESULT _PronsToInfo(WORD_PRON_BUFFER *pWordPron, WORD_INFO_BUFFER *pWordInfo)


void _AlignWordInfo(LEX_WORD_INFO *pWordInfoStored,
                    DWORD dwNumInfo,
                    DWORD dwInfoTypeFlags,
                    WORD_INFO_BUFFER *pInfo, 
                    INDEXES_BUFFER *pIndex
                    )
{
   // Destination buffers are assumed to be big enough

   DWORD dwTotalLen = 0;
   DWORD iBlock = 0;

   LEX_WORD_INFO *pWordInfoReturned = (LEX_WORD_INFO *)pInfo->pInfo;
   WORD *pwInfoIndex = pIndex->pwIndex;

   for (DWORD i = 0; i < dwNumInfo; i++)
   {
      DWORD dwLen = 0;
      DWORD dwInfo = 0;

      WORD Type = pWordInfoStored->Type;

      if (dwInfoTypeFlags & Type)
      {
         // Increase the dwTotalLen so that it is a multiple of sizeof (LEX_WORD_INFO);
         // Note: WordInfos are made to be start LEX_WORD_INFO multiple boundaries only in
         // the buffer that is returned. They are not stored that way, that is why we only
         // increment the returned info pointer below

         dwLen = dwTotalLen % sizeof (LEX_WORD_INFO);
         if (dwLen)
            dwLen = sizeof (LEX_WORD_INFO) - dwLen;
         pWordInfoReturned = (PLEX_WORD_INFO)(((PBYTE)(pWordInfoReturned)) + dwLen);

         dwTotalLen += dwLen;

         pwInfoIndex[iBlock++] = (WORD)(dwTotalLen / sizeof (LEX_WORD_INFO));
         
         dwTotalLen += sizeof (LEX_WORD_INFO);

         *pWordInfoReturned = *pWordInfoStored;

         dwInfo += sizeof (LEX_WORD_INFO);
      }
      
      switch (Type)
      {
      case PRON:
         dwLen = sizeof (WCHAR) * (wcslen (pWordInfoStored->wPronunciation) + 1);

         wcscpy (pWordInfoReturned->wPronunciation, pWordInfoStored->wPronunciation);
         if (dwLen > sizeof (LEX_WORD_INFO_UNION))
         {
            dwLen -= sizeof (LEX_WORD_INFO_UNION);
            dwTotalLen += dwLen;
            dwInfo += dwLen;
         }
         break;

      // nothing to do since for POS since POS is included in sizeof (LEX_WORD_INFO)
      case POS:
         break;
      
      default:
         _ASSERTE (0);
      }

      pWordInfoStored = (PLEX_WORD_INFO)(((PBYTE)(pWordInfoStored)) + dwInfo);
      pWordInfoReturned = (PLEX_WORD_INFO)(((PBYTE)(pWordInfoReturned)) + dwInfo);

   } // for (DWORD i = 0; i < dwnumInfo; i++)

   pInfo->cInfoBlocks = iBlock;
   pInfo->cBytesUsed = dwTotalLen;
   pIndex->cIndexes = iBlock;
} // void _AlignWordInfo()


bool _IsBadIndexesBuffer(INDEXES_BUFFER *pIndex)
{
   // pIndex should not be NULL
   if (pIndex->cIndexes > pIndex->cWordsAllocated ||
       IsBadWritePtr(pIndex->pwIndex, pIndex->cWordsAllocated * sizeof(WORD)))
      return true;

   return false;
} // bool _IsBadIndexesBuffer(INDEXES_BUFFER *pIndex)


bool _IsBadPron(WCHAR *pwPron, LCID lcid)
{
   if (LexIsBadStringPtr(pwPron, MAX_PRON_LEN))
      return true;

   // BUGBUG: Do IPA validation
   return false;
} // bool _IsBadPron(WCHAR *pwPron, LCID lcid)


bool _IsBadPOS(PART_OF_SPEECH Pos)
{
   if (Pos < NOUN || Pos > DEL)
      return true;

   return false;
} // bool _IsBadPOS(PART_OF_SPEECH Pos)


bool _IsBadLexType(LEX_TYPE Type)
{
   if (Type != LEXTYPE_USER && Type != LEXTYPE_APP &&
       Type != LEXTYPE_VENDOR && Type != LEXTYPE_GUESS)
      return true;

   return false;
} // bool _IsBadLexType(LEX_TYPE Type)


bool _AreBadLexTypes(DWORD dwTypes)
{
   bool IsBad = false;

   for (DWORD i = 0; i < 32; i++)
   {
      if (((1 << i) & dwTypes) && (_IsBadLexType((LEX_TYPE)(1 << i))))
      {
         IsBad = true;
         break;
      }
   }

   return IsBad;
} // bool _AreBadLexTypes(DWORD dwTypes)


bool _IsBadWordInfoType(WORDINFOTYPE Type)
{
   if (Type != PRON && Type != POS)
      return true;

   return false;
} // bool _IsBadWordInfoType(WORDINFOTYPE Type)


bool _AreBadWordInfoTypes(DWORD dwTypes)
{
   bool IsBad = false;

   for (DWORD i = 0; i < 32; i++)
   {
      if (((1 << i) & dwTypes) && (_IsBadWordInfoType((WORDINFOTYPE)(1 << i))))
      {
         IsBad = true;
         break;
      }
   }

   return IsBad;
} // bool _AreBadWordInfoTypes(DWORD dwTypes)


bool _IsBadLcid(LCID lcid)
{
   // BUGBUG: Can we do better?
   return ((!lcid) ? true : false);
} // bool _IsBadLcid(LCID lcid)


bool _IsBadWordPronsBuffer(WORD_PRONS_BUFFER *pWordProns, LCID lcid, bool fValidateProns)
{
   // pWordProns should not be NULL
   if (pWordProns->cWcharsUsed > pWordProns->cWcharsAllocated ||
       IsBadWritePtr(pWordProns->pwProns, pWordProns->cWcharsAllocated * sizeof(WCHAR)))
      return true;

   if (!fValidateProns)
      return false;

   bool IsBad = false;

   // Walk the prons buffer and validate prons
   __try
   {
      WCHAR *pwPron = pWordProns->pwProns;
      for (DWORD i = 0; i < pWordProns->cProns; i++)
      {
         if (_IsBadPron(pwPron, lcid))
         {
            IsBad = true;
            break;
         }

         pwPron += wcslen(pwPron) + 1;
      }
   }
   __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
   {
       IsBad = true;
   }

   return IsBad;
} // bool _IsBadWordPronsBuffer(WORD_PRONS_BUFFER *pWordProns)


bool _IsBadWordInfoBuffer(WORD_INFO_BUFFER *pWordInfo, LCID lcid, bool fValidateInfo)
{
   // pWordInfo should not be NULL
   if (pWordInfo->cBytesUsed > pWordInfo->cBytesAllocated ||
       IsBadWritePtr(pWordInfo->pInfo, pWordInfo->cBytesAllocated))
      return false;

   if (!fValidateInfo)
      return false;

   bool IsBad = false;

   // Walk the info array buffer and validate each info
   __try
   {
      LEX_WORD_INFO *pInfo = (LEX_WORD_INFO *)(pWordInfo->pInfo);

      DWORD dwPronLen;

      for (DWORD i = 0; i < pWordInfo->cInfoBlocks; i++)
      {
         dwPronLen = 0;

         switch(pInfo->Type)
         {
         case PRON:
            if (_IsBadPron(pInfo->wPronunciation, lcid))
            {
               IsBad = true;
               goto ReturnIsBadWordInfo;
            }
            else
            {
               dwPronLen += (wcslen(pInfo->wPronunciation) + 1) * sizeof(WCHAR);
               if (dwPronLen > sizeof(LEX_WORD_INFO_UNION))
                  dwPronLen -= sizeof(LEX_WORD_INFO_UNION);
            }
            break;

         case POS:
            if (_IsBadPOS((PART_OF_SPEECH)pInfo->POS))
            {
               IsBad = true;
               goto ReturnIsBadWordInfo;
            }
            break;

         default:
            IsBad = true;
            goto ReturnIsBadWordInfo;
         }

         pInfo = (LEX_WORD_INFO *)(((BYTE*)pInfo) + sizeof(LEX_WORD_INFO) + dwPronLen);
      }
   }
   __except(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION)
   {
      IsBad = true;
   }

ReturnIsBadWordInfo:

   return IsBad;
} // bool _IsBadWordInfoBuffer(WORD_INFO_BUFFER *pWordInfo, LCID lcid, bool fValidateInfo = false)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\test\apitest\main.cpp ===
#include "..\..\..\sapi\StdAfx.h"
#include <stdio.h>
#include <crtdbg.h>
#include "..\..\..\..\sdk\include\sapi.h"


HRESULT hr = S_OK;
// Enumerate the token objects and grab the first user
CComPtr<ISpTokenEnumBuilder> spEnumTokens;
CComPtr<ISpRegistryObjectToken> spRegToken;
ULONG celtFetched;
CComPtr <ISpUser> pUser;
CComPtr <ISpLexicon> pLex;

HRESULT GetLexiconPtr(void)
{
   spEnumTokens = NULL;
   spRegToken = NULL;
   celtFetched = NULL;
   pUser = NULL;
   pLex = NULL;
	
   hr = spEnumTokens.CoCreateInstance(CLSID_SpTokenEnumBuilder);
   if (FAILED(hr))
      return hr;

   hr = spEnumTokens->InitFromCategorySubKey(L"Users", L"Inst");
   if (FAILED(hr))
      return hr;

   hr = spEnumTokens->GetCount(&celtFetched);
   if (FAILED(hr) || !celtFetched)
      return hr;

   if (SUCCEEDED(hr = spEnumTokens->Next(1, (ISpObjectToken**)&spRegToken, &celtFetched)))
      hr = spRegToken->CreateInstance(NULL, CLSCTX_ALL, IID_ISpUser, (void**)&pUser);

   if (FAILED(hr))
       return hr;
   
   hr = pUser->GetLexicon(&pLex);

   return hr;
}



HRESULT Init()
{
    hr = S_OK;

    hr = GetLexiconPtr();

    WCHAR wszPron[5];
   wszPron[0] = 0x6a;
   wszPron[1] = 0;
   if (SUCCEEDED(hr))
      hr = pLex->AddPronunciation(L"Telephone", 1033, SPPS_Noun, wszPron);

   if (SUCCEEDED(hr))
      hr = GetLexiconPtr();

   if (SUCCEEDED(hr))
      hr = pLex->RemovePronunciation(L"Telephone", 1033, SPPS_Noun, wszPron);

   //if (SUCCEEDED(hr))
   //   hr = GetLexiconPtr();

   wszPron[0] = 0x7a;
   wszPron[1] = 0;

   if (SUCCEEDED(hr))
      hr = pLex->AddPronunciation(L"Telephone", 1033, SPPS_Noun, wszPron);

   if (SUCCEEDED(hr))
      hr = GetLexiconPtr();

   if (SUCCEEDED(hr))
      hr = pLex->RemovePronunciation(L"Telephone", 1033, SPPS_Noun, wszPron);

   if (SUCCEEDED(hr))
      hr = GetLexiconPtr();

   SPWORDPRONUNCIATIONLIST SPPron;
   ZeroMemory(&SPPron, sizeof(SPPron));
   if (SUCCEEDED(hr))
      hr = pLex->GetPronunciations(L"Telephone", 1033, eLEXTYPE_USER, &SPPron);

   return hr;
}


int main(int argc, char *argv[])
{
   HRESULT hr;

   _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF);
    _CrtSetBreakAlloc(225);
    _CrtSetBreakAlloc(162);
    _CrtSetBreakAlloc(107);


   //hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
   hr = CoInitialize(NULL);

   if (SUCCEEDED(hr))
      hr = Init();
   
   CoUninitialize();

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\tools\bldlts\main.cpp ===
/*****************************************************************************
*  Main.cpp
*     Functions to build the LTS lexicon
*
*  Owner: YunusM
*
*  Copyright 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#include "..\..\..\sapi\StdAfx.h"
#include "sapi.h"
#include "..\..\..\sapi\CommonLx.h"
#include <initguid.h>
#include <crtdbg.h>

// BUGBUG: This validation GUID also defined in LtsLx.cpp in SAPI
// {578EAD4E-330C-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(guidLtsValidationId,
0x578ead4e, 0x330c, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {4D4B1584-33D9-11d3-9C27-00C04F8EF87C}
DEFINE_GUID(CLSID_MSLTS1033Lexicon, 
0x4d4b1584, 0x33d9, 0x11d3, 0x9c, 0x27, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {E880AEA0-4456-11d3-9C29-00C04F8EF87C}
DEFINE_GUID(CLSID_MSLTS1041Lexicon, 
0xe880aea0, 0x4456, 0x11d3, 0x9c, 0x29, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);


HRESULT BuildLts (LANGID LangID, 
                  char *pszLtsRulesFile, 
                  char *pszPhoneMapFile, 
                  char *pszLtsLexFile
                  )
{
   FILE *frules = NULL;
   FILE *fmap = NULL;
   FILE *flts = NULL;

   frules = fopen (pszLtsRulesFile, "rb");
   fmap = fopen (pszPhoneMapFile, "r");
   flts = fopen (pszLtsLexFile, "wb");
   if (!frules || !fmap || !flts)
      return E_FAIL;

   // Header
   LTSLEXINFO ltsLexInfo;

   ltsLexInfo.guidValidationId = guidLtsValidationId;

   switch (LangID)
   {
   case 1033:
      ltsLexInfo.guidLexiconId = CLSID_MSLTS1033Lexicon;
      break;
   
   case 1041:
      ltsLexInfo.guidLexiconId = CLSID_MSLTS1041Lexicon;
      break;
   
   default:
      return E_FAIL;
   }

   ltsLexInfo.LangID = LangID;
   fwrite (&ltsLexInfo, sizeof (LTSLEXINFO), 1, flts);

   // Write the map file to the lex file
   fseek(fmap, 0, SEEK_END);
   DWORD dwSize = ftell(fmap);

   char *p = (char *)malloc(dwSize + 1);
   if (!p)
      return E_OUTOFMEMORY;

   fseek(fmap, 0, SEEK_SET);
   dwSize = fread(p, 1, dwSize, fmap); // The returned dwSize is less than the passed in dwSize because '\r\n' gets converted to '\n'
   p[dwSize++] = 0;
   fwrite(p, 1, dwSize, flts);
   // Write a null value
   free(p);

   // Lts rules
   fseek (frules, 0, SEEK_END);
   dwSize = ftell (frules);
   fseek (frules, 0, SEEK_SET);

   p = (char*) malloc(dwSize);
   if (!p)
      return E_OUTOFMEMORY;

   fread(p, 1, dwSize, frules);
   fwrite(p, 1, dwSize, flts);
   free(p);

   fclose (flts);
   fclose (fmap);
   fclose (frules);

   _ASSERTE (_CrtCheckMemory ());

   return S_OK;
} /* BuildLts */

/*
HRESULT TestLts(LANGID LangID,
                char * szLtsLexFile
                )
{
   HRESULT hr = CoInitialize(NULL);
   if (FAILED(hr))
      return hr;

   // Enumerate the token objects looking for MS_1033_LTS or MS_1041_LTS
   CComPtr<ISpTokenEnumBuilder> spEnumTokens;
   CComPtr<ISpRegistryObjectToken> spRegToken;
   
   ULONG celtFetched;

   hr = spEnumTokens.CoCreateInstance(CLSID_SpTokenEnumBuilder);
   if (FAILED(hr))
      return hr;

   hr = spEnumTokens->InitFromCategoryInstances(L"LTSLexicon");
   if (FAILED(hr))
      return hr;

   hr = spEnumTokens->GetCount(&celtFetched);
   if (FAILED(hr) || !celtFetched)
      return hr;

   WCHAR *pwszTag = NULL;
   switch (LangID)
   {
   case 1033:
      pwszTag = L"MS_1033_LTS";
      break;

   case 1041:
      pwszTag = L"MS_1041_LTS";
      break;

   default:
      return E_FAIL;
   }

   while (SUCCEEDED(spEnumTokens->Next(1, (ISpObjectToken**)&spRegToken, &celtFetched)))
   {
      WCHAR *pwszId;
      hr = spRegToken->GetID(&pwszId);
      if (FAILED(hr))
         return hr;

      if (wcsstr(pwszId, pwszTag))
      {
         CoTaskMemFree(pwszId);
         break;
      }

      CoTaskMemFree(pwszId);
      spRegToken = NULL;
   }

   CComPtr<ISpLexicon> pLex;

   hr = spRegToken->CreateInstance(NULL, CLSCTX_INPROC_SERVER, IID_ISpLexicon, (void**)&pLex);
   if (FAILED(hr))
      return hr;

   SPWORDPRONUNCIATIONLIST SPList;
   ZeroMemory(&SPList, sizeof(SPList));

   // Get the information of the word
   hr = pLex->GetPronunciations(L"father", LangID, eLEXTYPE_LTS, &SPList);
   if (FAILED(hr))
      return hr;

   CoTaskMemFree(SPList.pvBuffer);

   return S_OK;
}
*/

int main (int argc, char * argv[])
{
   if (argc != 5)
   {
      printf ("Usage: BldLts LangID LtsRulesFile PhoneMapFile LtsLexFile\n");
      return -1;
   }

   LANGID LangID = atoi (argv[1]);
   if (LangID != 1033 && LangID != 1041)
   {
      printf("Bad LangID\n");
      return -1;
   }

   if (FAILED(BuildLts(LangID, argv[2], argv[3], argv[4])))
   {
      printf("BuildLts failed\n");
      return -1;
   }

   /*
   if (FAILED(TestLts(LangID, argv[4])))
   {
      printf("TestLts failed\n");
      return -1;
   }
   */

   return 0;
} /* main */

//--- End of File --------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\tools\bldvendor\lexguids.cpp ===
#include <initguid.h>
#include "lexguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\tools\bldvendor\lexguids.h ===
#pragma once

//BUGBUG: gLkupValidationId also defined in VendorLx.cpp in sapi
// {12B545C3-3003-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(gLkupValidationId, 
0x12b545c3, 0x3003, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {376FE442-3028-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(CLSID_MSSR1033Lexicon, 
0x376fe442, 0x3028, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {376FE443-3028-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(CLSID_MSSR1041Lexicon, 
0x376fe443, 0x3028, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {376FE444-3028-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(CLSID_MSTTS1033Lexicon, 
0x376fe444, 0x3028, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {4BF1DE66-3028-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(CLSID_MSTTS1041Lexicon, 
0x4bf1de66, 0x3028, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {376FE446-3028-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(CLSID_MSSR2052Lexicon, 
0x376fe446, 0x3028, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

// {4BF1DE68-3028-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(CLSID_MSTTS2052Lexicon, 
0x4bf1de68, 0x3028, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\tools\bldvendor\huffc.h ===
#ifndef _HUFFC_H_
#define _HUFFC_H_

#include <stdio.h>
#include "HuffD.h"
#include <atlbase.h>
#include <CommonLx.h>

typedef unsigned int CODETYPE;

typedef struct _huffencodenode : public HUFF_NODE
{
   WORD     iParent;
   int      nCount;
   bool     fConsider;
} HUFF_EN_NODE, *PHUFF_EN_NODE;

typedef struct
{
   BYTE     nBits;
   CODETYPE Code;
} CODE_TABLE, *PCODE_TABLE;

class CHuffEncoder
{
public:
   
   CHuffEncoder              ();
   ~CHuffEncoder             ();
   
   HRESULT Count             (HUFFKEY Key);
   HRESULT ConstructCode     (FILE *fp);
   HRESULT Encode            (HUFFKEY Key);
   HRESULT Flush             (PDWORD pBuf, int *iBit);
   int     GetNumKeys        (void) { return m_nKeys; }

private:
   
   int            m_nKeys;
   int            m_nLenTreeBuf;
   int            m_nUseTreeBuf;
   PHUFF_EN_NODE  m_pEncodeTree;
   PHUFFKEY       m_pHuffKey;
   int            m_iRoot;
   PCODE_TABLE    m_pCodeTable;
   PDWORD         m_pEncodedBuf;
   int            m_nLenEnBuf;
   int            m_nUseEnBuf;
   int            m_iBitFlush;
};

#endif // _HUFFC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\tools\isweeknd\isweeknd.cpp ===
#include <time.h>

main()
{
   struct tm *newtime;
   time_t long_time;

   time( &long_time );
   newtime = localtime( &long_time );

   if (newtime->tm_wday == 0 || newtime->tm_wday == 6)
      return 1;

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\tools\bldvendor\bldvendor.cpp ===
/*****************************************************************************
*  BldBackup.cpp
*     Functions to build the lookup and lts vendor lexicons. This file was
*     written to be a part of internal too. This has to be changed to a class
*     and all the globals should be eliminated. The functionality however stays
*     the same.
*    
*  Owner: YunusM
*
*  Copyright 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#include <windows.h>
#include "HuffC.h"
//#include <atlbase.h>
#include <sapi.h>
#include <CommonLx.h>
#include <math.h>
#include "lexguids.h"
//#include <initguid.h>

// GLOBALS

DWORD nCodePage            = 0;   // code page to use
DWORD nLkupWords           = 0;   // Number of words stored in lookup file
DWORD nLkupProns           = 0;   // Number of prons stored in lookup file
DWORD nLkupPOSs            = 0;   // Number of parts-of-speechs stored in lookup file

DWORD nBlockLen            = 0;   // Length of block containing words and pronunciations
DWORD nBlockUseDWORDs      = 0;   // Amount of block in use in DWORDs
DWORD nBlockUseBits        = 0;   // Amount of block in use in bits
DWORD *pBlock              = NULL;// The block containing the compressed words + CBs + prons
DWORD nMaxInfoLen          = 0;   // The max space required by a SPWORDPRONUNCIATIONLIST holding a word's prons/poss

DWORD *pHash               = NULL;// Hash table of words to hold offsets into pBlock
DWORD nHashLen             = 0;   // Length of the hash table
DWORD nBitsPerHash         = 0;   // Number of bits used to store a hash entry
DWORD nCollisions          = 0;   // Number of collisions when building the hash table

PBYTE pCmpHash             = NULL;// Hash table (with just enough number of bits)
                                  // of words to hold offsets into pBlock
DWORD nCmpHashBytes        = 0;   // Size of pCmpHash rounded to next byte

CHuffEncoder *WordsEncoder = NULL;// Huffman encoder to encode words
CHuffEncoder *PronsEncoder = NULL;// Huffman encoder to encode prons
CHuffEncoder *PosEncoder   = NULL;// Huffman encoder to encode POSs

LANGID LangID                  = (LANGID)-1;  // LangID of the lexicon being built
GUID gLexGuid;                    // Lookup lexicon GUID

char szTempPath[2*MAX_PATH];      // The path to the temporary directory
char szLookupTextFile[MAX_PATH];     // Input file
char szLookupLexFile[MAX_PATH];   // Output file
char szTextLexFileOut[MAX_PATH];  // The file generated out of binary lookup lex to check
char WordCBFile [MAX_PATH * 2];   // Words code book file
char PronCBFile [MAX_PATH * 2];   // Prons code book file
char PosCBFile [MAX_PATH * 2];    // POS code book file
ISpPhoneConverter *pPhoneConv = NULL;// phone convertor
bool fSR                   = false;// SR file
bool fTTS                  = false;// TTS file
bool fSymbolicPhones       = false; // Whether phones in text file are symbolic form

/******************************************************************************
* _itoah *
*--------*
*     Description:
*       convert an array of shorts to space separated tokens
*
*     Return:
**************************************************************YUNUSM**********/
inline void _itoah(PWCHAR pH,     // string of WCHARs
                   PSTR pA        // space separated token string
                   )  
{                                    
   *pA = 0;

   DWORD dH = wcslen (pH);

   for (DWORD i = 0; i < dH; i++) {
      char sz[128];
      sprintf (sz, "%x ", pH[i]);
      strcat (pA, sz);
   }

   int len = strlen (pA);

   if (len)
      pA [len - 1] = 0;
} /* _itoah */

void _ahtoi(char *pszSpaceSeparatedTokens,        // space separated tokens
            WCHAR *pszHexChars,                   // output WCHAR (hex) string
            DWORD *pcch = NULL                    // number of WCHARs
            )
{
    // Each space separated hex char takes no more than 5 chars
    char szInput[5 * SP_MAX_PRON_LENGTH + 1];
    strcpy (szInput, pszSpaceSeparatedTokens);
    pszSpaceSeparatedTokens = szInput;
    _strlwr(pszSpaceSeparatedTokens);

    *pszHexChars = 0;
    if (pcch)
        *pcch = 0;

    int nHexChars = 0;
    char *pszToken = strtok(pszSpaceSeparatedTokens, " ");
	// Horner's rule
    while (pszToken) 
    {
        // Convert the token to its numeral form in a WCHAR
        WCHAR wHexVal = 0;
        bool fFirst = true;

        while (*pszToken)
        {
            WCHAR k = *pszToken;
            if (k >= 'a')
                k = 10 + k - 'a';
            else
                k -= '0';

            if (fFirst)
                fFirst = false;
            else
                wHexVal *= 16;

            wHexVal += k;
            pszToken++;
       }

       pszHexChars[nHexChars++] = wHexVal;
       pszToken = strtok(NULL, " ");
   }

   pszHexChars[nHexChars] = 0;

   if (pcch)
      *pcch = nHexChars;
} /* _ahtoi */


// Set the 'iBit' bit of 'p' to 1
void SetBit (PBYTE p, DWORD iBit)
{
   DWORD dByte = iBit / 8;
   DWORD dBitinByte = iBit % 8;

   p[dByte] |= (1 << (7 - dBitinByte));
}


// Set the 'iBit' bit of 'p' to 1
void SetBitInDWORD (PDWORD p, DWORD iBit)
{
   DWORD dDWORD = iBit / 32;
   DWORD dBitinDWORD = iBit % 32;

   p[dDWORD] |= 1 << dBitinDWORD;
}


// Add a buffer of so many bits long to the big block
void AddToBlock (DWORD *pBuffer, DWORD nBits)
{
   DWORD nDWORDs = ((nBits + 0x1f) & (~0x1f)) >> 5;

   CopyMemory (pBlock + nBlockUseDWORDs, pBuffer, nDWORDs * sizeof (DWORD));

   if (nBlockUseDWORDs * 32 - nBlockUseBits)
   {
      for (DWORD i = 0; i < nDWORDs; i++)
      {
         pBlock[nBlockUseDWORDs + i - 1] &= ~(-1 << (32 - (nBlockUseDWORDs * 32 - nBlockUseBits)));

         pBlock[nBlockUseDWORDs + i - 1] |= 
            pBlock[nBlockUseDWORDs + i] << (32 - (nBlockUseDWORDs * 32 - nBlockUseBits));

         pBlock[nBlockUseDWORDs + i] >>= nBlockUseDWORDs * 32 - nBlockUseBits;
      }
   }

   nBlockUseBits += nBits;

   nBlockUseDWORDs = ((nBlockUseBits + 0x1f) & (~0x1f)) >> 5;
} // void AddToBlock (PBYTE pBuffer, DWORD nBits)


// Build the code books for the encoding of words and pronunciations
HRESULT ConstructWordsPronsCode(void)
{
   HRESULT hr = S_OK;
   
   FILE *fpWordsCode = NULL;
   FILE *fpPronsCode = NULL;
   FILE *fpPossCode = NULL;

   FILE *fp = fopen (szLookupTextFile, "r");
   if (!fp)
   {
      hr = E_FAIL;
      goto ReturnConstructCode;
   }

   // Build the code books
   char sz[1024];
   while (fgets (sz, 1024, fp))
   {
      WCHAR wsz[1024];

      MultiByteToWideChar(nCodePage, MB_PRECOMPOSED, sz, -1, wsz, 1024);
      DWORD d = GetLastError();
      PWSTR pw = wcschr (wsz, L' ');
      _ASSERTE (pw);
      if (!pw)
      {
         hr = E_FAIL;
         goto ReturnConstructCode;
      }

      *pw++ = 0;
      PSTR p = strchr (sz, ' ');
      *p++ = 0;

      if (pw[wcslen(pw) - 1] == L'\n')
         pw[wcslen(pw) - 1] = 0;

      if (p[strlen(p) - 1] == L'\n')
         p[strlen(p) - 1] = 0;

      if (wsz == wcsstr(wsz, L"Word"))
      {
         _wcslwr (pw);
         do
         {
            WORD w = *pw;

            if (FAILED(hr = WordsEncoder->Count (w)))
            {
               _ASSERTE (0);
               break;
            }
         } while (*pw++); // encode the terminating null too
      }
      else if (wsz == wcsstr (wsz, L"Pronunciation"))
      {
         WCHAR wPron[SP_MAX_PRON_LENGTH * 3];
         DWORD d;

         if (fSymbolicPhones)
         {
            if (FAILED(pPhoneConv->PhoneToId(pw, wPron)))
            {
               _ASSERTE(false);
               return E_FAIL;
            }
            d = wcslen(wPron);
         }
         else
         {
            _ahtoi(p, wPron, &d);
         }

         for (DWORD i = 0; i <= d; i++) // encode the terminating null too
         {
            if (FAILED(hr = PronsEncoder->Count (wPron[i])))
            {
               _ASSERTE(0);
               break;
            }
         }
      }
      else if (wsz == wcsstr (wsz, L"POS"))
      {
         SPPARTOFSPEECH pos;

         pos = (SPPARTOFSPEECH)atoi (p);

         if (FAILED(hr = PosEncoder->Count ((HUFFKEY)pos)))
         {
            _ASSERTE(0);
            break;
         }
      }
      else
      {
         _ASSERTE (0);
         hr = E_FAIL;
         break;
      }
   }

   // The huffman encoder needs atleast two keys to work properly
   if (1 == WordsEncoder->GetNumKeys ())
   {
      WordsEncoder->Count ((HUFFKEY)-1);
      WordsEncoder->Count ((HUFFKEY)-2);
   }

   if (1 == PronsEncoder->GetNumKeys ())
   {
      PronsEncoder->Count ((HUFFKEY)-1);
      PronsEncoder->Count ((HUFFKEY)-2);
   }

   if (1 == PosEncoder->GetNumKeys ())
   {
      PosEncoder->Count ((HUFFKEY)-1);
      PosEncoder->Count ((HUFFKEY)-2);
   }
   
   // Write out the code books
   
   fpWordsCode = fopen (WordCBFile, "wb");
   fpPronsCode = fopen (PronCBFile, "wb");
   fpPossCode = fopen (PosCBFile, "wb");
   
   if (!fpWordsCode || !fpPronsCode || !fpPossCode)
   {
      hr = E_FAIL;
      goto ReturnConstructCode;
   }

   if ((FAILED(hr = WordsEncoder->ConstructCode (fpWordsCode))) || 
       (FAILED(hr = PronsEncoder->ConstructCode (fpPronsCode))) ||
       (FAILED(hr = PosEncoder->ConstructCode (fpPossCode))))
      goto ReturnConstructCode;

ReturnConstructCode:
   fclose (fpWordsCode);
   fclose (fpPronsCode);
   fclose (fpPossCode);
   fclose (fp);

   return hr;
} // int ConstructWordsPronsCode (void)


HRESULT CountWordsProns (void)
{
   HRESULT hr = S_OK;
   nLkupWords = 0;
   nLkupProns = 0;
   nLkupPOSs = 0;

   FILE * fpLookupTextFile = fopen (szLookupTextFile, "r");
   if (!fpLookupTextFile)
      return E_FAIL;

   char sz[SP_MAX_PRON_LENGTH * 5];
   while (fgets (sz, SP_MAX_PRON_LENGTH * 5, fpLookupTextFile))
   {
      if (sz == strstr (sz, "Word"))
         nLkupWords++;
      else if (sz == strstr(sz, "Pronunciation"))
         nLkupProns++;
      else if (sz == strstr(sz, "POS"))
         nLkupPOSs++;
      else
      {
         hr = E_FAIL;
         break;
      }
   }
   fclose (fpLookupTextFile);

   return hr;
} // HRESULT CountWordsProns (void)


// Encode the words and prons and write them to the big block along with
// the control blocks (CBs)
HRESULT EncodeWordsProns(void)
{
   FILE *fp = fopen (szLookupTextFile, "r");
   if (!fp)
   {
      _ASSERTE (0);
      return E_FAIL;
   }

   HRESULT hr = S_OK;

   // Allocate the hash table to hold the offsets into the words + CB + prons block
   nHashLen = (DWORD)(1.5 * nLkupWords) + 1;

   // Chose a prime in between the two powers of 2
   if (nHashLen >= 0x10000 && nHashLen < 0x20000)
      nHashLen = 88471;
   else if (nHashLen >= 0x20000 && nHashLen < 0x40000)
      nHashLen = 182821;

   pHash = (DWORD *) malloc (nHashLen * sizeof (DWORD));
   if (!pHash)
      return E_OUTOFMEMORY;

   FillMemory (pHash, nHashLen * sizeof (DWORD), 0xFF);

   DWORD iCBBitToSet = 0;

   nBlockLen = (nLkupWords + nLkupProns) * 30; // arbitrary!
   pBlock = (PDWORD) calloc (nBlockLen, 1);
   if (!pBlock)
      return E_OUTOFMEMORY;

   char sz[SP_MAX_PRON_LENGTH * 5];
   DWORD dwInfoLen = 0;

   while (fgets (sz, SP_MAX_PRON_LENGTH * 5, fp))
   {
      WCHAR wsz[SP_MAX_PRON_LENGTH * 5];

      MultiByteToWideChar(nCodePage, MB_PRECOMPOSED, sz, -1, wsz, 1024);

      PWSTR pw = wcschr (wsz, L' ');
      _ASSERTE (pw);
      if (!pw)
         return E_FAIL;

      *pw++ = 0;
      while (*pw == ' ')
         pw++;

      PSTR p = strchr (sz, ' ');
      *p++ = 0;
      while (*p == ' ')
         p++;

      if (pw[wcslen(pw) - 1] == L'\n')
         pw[wcslen(pw) - 1] = 0;

      if (p[strlen(p) - 1] == '\n')
         p[strlen(p) - 1] = 0;

      if (wsz == wcsstr (wsz, L"Word"))
      {
         if (dwInfoLen > nMaxInfoLen)
             nMaxInfoLen = dwInfoLen;
         dwInfoLen = sizeof(SPWORDPRONUNCIATIONLIST);

         // limit the length of the word
         pw [SP_MAX_WORD_LENGTH - 1] = 0;

         WCHAR wszWord[SP_MAX_WORD_LENGTH];
         wcscpy(wszWord, pw);

         // New word - set the fLast bit in previous word's last CB block
         if (iCBBitToSet) // Dont set the first time we are here
            SetBitInDWORD (pBlock, iCBBitToSet);

         _wcslwr(pw);

         // Hash the word
         DWORD dHash = GetWordHashValue(pw, nHashLen);
         while (pHash [dHash] != (DWORD)-1)
         {
            nCollisions++;
            dHash++;
            if (dHash == nHashLen)
               dHash = 0;
         }

         pHash [dHash] = nBlockUseBits;
         
         // Encode the word
         DWORD d = wcslen (pw);
         for (DWORD i = 0; i <= d; i++) 
         { 
            // pass in null too
            if (FAILED(hr = WordsEncoder->Encode ((HUFFKEY)pw[i])))
               return hr;
         }
   
         _ASSERTE (i == d + 1);

         DWORD nBits = 0;
         DWORD bBuffer[SP_MAX_WORD_LENGTH * 3];

         ZeroMemory (bBuffer, sizeof (bBuffer));
         WordsEncoder->Flush (bBuffer, (int*)&nBits);
         _ASSERTE (nBits);

#ifdef _DEBUG
         DWORD dSave = nBlockUseBits;
#endif
         AddToBlock (bBuffer, nBits);
         _ASSERTE (nBlockUseBits ==  dSave + nBits);
      }
      else if (sz == strstr (sz, "Pronunciation"))
      {
         // convert the pron to WCHARs
         WCHAR wPron[SP_MAX_PRON_LENGTH * 3];

         if (fSymbolicPhones)
         {
            if (FAILED(pPhoneConv->PhoneToId(pw, wPron)))
            {
               _ASSERTE(false);
               return E_FAIL;
            }

             if (fSR && SPIsBadLexPronunciation(pPhoneConv, wPron))
             {
                _ASSERTE(0);
                return E_FAIL;
             }
         }
         else
         {
             _ahtoi(p, wPron);
         }

         dwInfoLen += sizeof(SPWORDPRONUNCIATION) + (wcslen(wPron) + 1) * sizeof(WCHAR);

         // limit the length of the pron
         wPron [SP_MAX_PRON_LENGTH - 1] = 0;

         // Store a control block
         DWORD cb = 0;
         _ASSERTE ((8 *sizeof (cb)) > MAXTOTALCBSIZE);
         // Save the first bit position of cb in pBlock so that
         // we can set it to 1 in case this is the last pron
         iCBBitToSet = nBlockUseBits + CBSIZE - 1;

         ZeroMemory (&cb, sizeof (cb));

         cb = ePRON;
         AddToBlock (&cb, CBSIZE);

         // Encode the pronunciation
         DWORD d = wcslen (wPron);
         for (DWORD i = 0; i <= d; i++) 
         { 
            // Encode the terminated NULL too
            if (FAILED(hr = PronsEncoder->Encode (wPron[i])))
               return hr;
         }

         DWORD nBits = 0;
         DWORD bBuffer[SP_MAX_PRON_LENGTH * 3];
         
         ZeroMemory (bBuffer, sizeof (bBuffer));
         PronsEncoder->Flush (bBuffer, (int*)&nBits);
         _ASSERTE (nBits);

#ifdef _DEBUG
         DWORD dSave = nBlockUseBits;
#endif
         AddToBlock (bBuffer, nBits);
         _ASSERTE (nBlockUseBits ==  dSave + nBits);
      }
      else if (sz == strstr (sz, "POS"))
      {
         SPPARTOFSPEECH pos = (SPPARTOFSPEECH)atoi (p);
        // BUGBUG - just taking this out until POS is settled...
        // if (SPIsBadPartOfSpeech(pos))
        // {
        //    _ASSERTE(0);
        //    return E_FAIL;
        // }

         dwInfoLen += sizeof(SPWORDPRONUNCIATION);

         // Store a control block
         DWORD cb = 0;
          _ASSERTE ((8 *sizeof (cb)) > MAXTOTALCBSIZE);

         // Save the first bit position of cb in pBlock so that
         // we can set it to 1 in case this is the last pron
         iCBBitToSet = nBlockUseBits + CBSIZE - 1;

         ZeroMemory (&cb, sizeof (cb));

         cb = ePOS;
         AddToBlock (&cb, CBSIZE);

         // Encode the POS
         if (FAILED(hr = PosEncoder->Encode ((HUFFKEY)pos)))
         {
            _ASSERTE (0);
            return hr;
         }

         DWORD nBits = 0;
         DWORD bBuffer[SP_MAX_PRON_LENGTH];

         ZeroMemory (bBuffer, sizeof (bBuffer));
         PosEncoder->Flush (bBuffer, (int*)&nBits);
         _ASSERTE (nBits);

#ifdef _DEBUG
         DWORD dSave = nBlockUseBits;
#endif
         AddToBlock (bBuffer, nBits);
         _ASSERTE (nBlockUseBits ==  dSave + nBits);
      }
   } // while (fgets (sz, SP_MAX_PRON_LENGTH * 5, fp))

   fclose(fp);

   // For the last word
   if (iCBBitToSet)
   {
      SetBitInDWORD (pBlock, iCBBitToSet);
      if (dwInfoLen > nMaxInfoLen)
         nMaxInfoLen = dwInfoLen;
   }

   nMaxInfoLen *= 2;

   // Convert the hash table to its shortest bit length form

   double fnBits = log(nBlockUseBits) / log(2);
   nBitsPerHash = (int)fnBits;

   if (fnBits > (double)((int)(fnBits)))
      nBitsPerHash += 1;
   
   nCmpHashBytes = (((nBitsPerHash * nHashLen) + 0x7) & (~0x7)) / 8;

   pCmpHash = (PBYTE) calloc (1, nCmpHashBytes);
   if (!pCmpHash)
      return E_OUTOFMEMORY;

   for (DWORD i = 0; i < nHashLen; i++)
   {
      for (DWORD j = 0; j < nBitsPerHash; j++)
      {
         if (pHash [i] & (1 <<( nBitsPerHash - j - 1)))
            SetBit (pCmpHash, i * nBitsPerHash + j);
      }
   }

   // pad atleast MAXELEMENTSIZE at the end so that we dont't have to worry about
   // overshooting the end of block while decoding because of variable-length codes
   nBlockUseDWORDs += ((MAXELEMENTSIZE + 32) >> 5);

   return S_OK;
} // int EncodeWordsProns (void)


HRESULT WriteLookupLexFile (void)
{
   FILE *fp = fopen (szLookupLexFile, "wb");
   FILE *fpwcb = fopen (WordCBFile, "rb");
   FILE *fppcb = fopen (PronCBFile, "rb");
   FILE *fpposcb = fopen (PosCBFile, "rb");

   if (!fp || !fpwcb || !fppcb || !fpposcb)
   {
      _ASSERTE (0);
      return E_FAIL;
   }

   fseek (fpwcb, 0, SEEK_END);
   fseek (fppcb, 0, SEEK_END);
   fseek (fpposcb, 0, SEEK_END);

   // Build LKUPLEXINFO

   LOOKUPLEXINFO lkupLexInfo;
   ZeroMemory(&lkupLexInfo, sizeof(LOOKUPLEXINFO));

   lkupLexInfo.guidValidationId = gLkupValidationId;
   lkupLexInfo.guidLexiconId = gLexGuid;
   lkupLexInfo.LangID = LangID;
   lkupLexInfo.nNumberWords = nLkupWords;
   lkupLexInfo.nNumberProns = nLkupProns;
   lkupLexInfo.nMaxWordInfoLen = nMaxInfoLen;
   lkupLexInfo.nLengthHashTable = nHashLen;
   lkupLexInfo.nBitsPerHashEntry = nBitsPerHash;
   lkupLexInfo.nCompressedBlockBits = nBlockUseBits;
   lkupLexInfo.nWordCBSize = ftell (fpwcb);
   lkupLexInfo.nPronCBSize = ftell (fppcb);
   lkupLexInfo.nPosCBSize = ftell (fpposcb);

   // Write the header
   fwrite (&lkupLexInfo, sizeof (lkupLexInfo), 1, fp);

   // Write the Words Codebook
   DWORD dwCBSize;
   if (lkupLexInfo.nWordCBSize > lkupLexInfo.nPronCBSize)
      dwCBSize = lkupLexInfo.nWordCBSize;
   else
      dwCBSize = lkupLexInfo.nPronCBSize;

   if (dwCBSize < lkupLexInfo.nPosCBSize)
      dwCBSize = lkupLexInfo.nPosCBSize;

   PBYTE pCB = (PBYTE) malloc (dwCBSize);
   if (!pCB)
      return E_OUTOFMEMORY;

   // Write the words codebook
   fseek (fpwcb, 0, SEEK_SET);
   fread (pCB, 1, lkupLexInfo.nWordCBSize, fpwcb);
   fwrite (pCB, 1, lkupLexInfo.nWordCBSize, fp);

   // Write the prons codebook
   fseek (fppcb, 0, SEEK_SET);
   fread (pCB, 1, lkupLexInfo.nPronCBSize, fppcb);
   fwrite (pCB, 1, lkupLexInfo.nPronCBSize, fp);

   // Write the pos codebook
   fseek (fpposcb, 0, SEEK_SET);
   fread (pCB, 1, lkupLexInfo.nPosCBSize, fpposcb);
   fwrite (pCB, 1, lkupLexInfo.nPosCBSize, fp);

   // Write the hash table
   fwrite (pCmpHash, 1, nCmpHashBytes, fp);

   // Write the words + CBs + prons + Poss block
   fwrite (pBlock, sizeof (DWORD), nBlockUseDWORDs, fp);

   free (pCB);

#ifdef _DEBUG
   int nLkupSize = ftell (fp);
#endif

   fclose (fpwcb);
   fclose (fppcb);
   fclose (fpposcb);
   fclose (fp);

#ifdef _DEBUG

   char szMessage[256];

   sprintf (szMessage, "\n******** Lookup Lexicon Stats ********\n");
   OutputDebugString (szMessage);
   sprintf (szMessage, "Number of words written to the lookup file = %d\n", nLkupWords);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Number of prons written to the lookup file = %d\n", nLkupProns);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Number of POSs written to the lookup file = %d\n", nLkupPOSs);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Size of block the compressed block in DWORDs = %d\n", nBlockUseDWORDs);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Size of Hash table = %d\n", (nHashLen * nBitsPerHash)/8);
   OutputDebugString (szMessage);
   sprintf (szMessage, "Total Size of the Lkup file = %d\n", nLkupSize);
   OutputDebugString (szMessage);
   sprintf (szMessage, "**************************************\n\n");
   OutputDebugString (szMessage);

#endif

   return S_OK;
} // HRESULT WriteLookupLexFile (void)


// Reads the text lookup lexicon file and creates the binary lookup lexicon file
HRESULT EncodeBackup(void)
{
   HRESULT hr = S_OK;

   hr = CountWordsProns();

   if (SUCCEEDED(hr) && nLkupWords)
   {
      hr = ConstructWordsPronsCode();

      if (SUCCEEDED(hr))
         hr = EncodeWordsProns();
   }

   if (SUCCEEDED(hr))
      hr = WriteLookupLexFile();

   return hr;
} /* EncodeBackup */


#ifdef _DEBUG

// Reads the binary lookup lexicon file and creates the text lookup lexicon file
// and compares it to the supplied text lookup lexicon file
HRESULT DecodeBackup (WCHAR *pwszInst)
{
   USES_CONVERSION;
   HRESULT hRes = NOERROR;
   
   FILE *fp = NULL;
   FILE *fpout = NULL;

   CComPtr<ISpObjectToken> cpObjectToken;
   CComPtr<ISpLexicon> pLex;

   WCHAR szTokenId[MAX_PATH];
   wcscpy(szTokenId, SPREG_USER_ROOT);
   wcscat(szTokenId, L"\\TempVendor\\Tokens\\");
   wcscat(szTokenId, pwszInst);
   
   hRes = SpGetTokenFromId(szTokenId, &cpObjectToken, TRUE);
   if (FAILED(hRes))
   {
       goto DecodeBackupReturn;
   }
   hRes = SpCreateObjectFromToken(cpObjectToken, &pLex);
   if (FAILED(hRes))
   {
       goto DecodeBackupReturn;
   }

   SPWORDPRONUNCIATIONLIST SPList;
   ZeroMemory(&SPList, sizeof(SPList));

   fp = fopen (szLookupTextFile, "r");
   if (!fp)
   {
      _ASSERTE (0);
      hRes = E_FAIL;
      goto DecodeBackupReturn;
   }

   strcpy (szTextLexFileOut, szTempPath);
   strcat (szTextLexFileOut, "LookupTextFile");
   strcat (szTextLexFileOut, ".out");

   fpout = fopen (szTextLexFileOut, "w");
   if (!fpout)
   {
      _ASSERTE (0);
      hRes = E_FAIL;
      goto DecodeBackupReturn;
   }

   // Walk the input lookup text file picking off words and 
   // getting their information from the binary lookup lexicon
  
   char sz[1024];
   while (fgets (sz, 1024, fp))
   {
      PSTR pWord;
      pWord = strchr (sz, ' ');
      *pWord++ = 0;

      if (strcmp (sz, "Word"))
         continue;

      fprintf (fpout, "Word %s", pWord);

      // Get the word's information from the binary lexicon

      if (pWord[strlen (pWord) - 1] == '\n')
         pWord[strlen (pWord) - 1] = 0;

      WCHAR wsz[SP_MAX_WORD_LENGTH];

      MultiByteToWideChar(nCodePage, MB_PRECOMPOSED, pWord, -1, wsz, SP_MAX_WORD_LENGTH);

      // Get the information of the word
      hRes = pLex->GetPronunciations(wsz, LangID, eLEXTYPE_PRIVATE1, &SPList);
      if (FAILED(hRes))
      {
         _ASSERTE (0);
         goto DecodeBackupReturn;
      }

      DWORD iPron, iPOS;
      iPron = 0;
      iPOS = 0;

      SPWORDPRONUNCIATION *pWordPronunciation = SPList.pFirstWordPronunciation;
      WCHAR wszPrevPron[SP_MAX_PRON_LENGTH];
      *wszPrevPron = 0;

      // Convert the pronunciations to text form
      while (pWordPronunciation)
      {
         if (wcscmp(pWordPronunciation->szPronunciation, wszPrevPron))
         {
            if (fSymbolicPhones)
            {
    		   hRes = pPhoneConv->IdToPhone(pWordPronunciation->szPronunciation, wszPrevPron);
	    	   _ASSERTE(SUCCEEDED(hRes));
            }
            else
            {
                wcscpy(wszPrevPron, pWordPronunciation->szPronunciation);
            }

            char szPron[SP_MAX_PRON_LENGTH * 10];
            _itoah(wszPrevPron, szPron);
            fprintf (fpout, "Pronunciation%d %s\n", iPron++, szPron);

            // reset the iPOS
            iPOS = 0;
         }

         if (SPPS_NotOverriden != pWordPronunciation->ePartOfSpeech)
            fprintf (fpout, "POS%d %d\n", iPOS++, pWordPronunciation->ePartOfSpeech);

         pWordPronunciation = pWordPronunciation->pNextWordPronunciation;
      } // while (pWordPronunciation)
   } // while (fgets (sz, 1024, fp))

DecodeBackupReturn:

   CoTaskMemFree(SPList.pvBuffer);

   if (fp)
      fclose (fp);
   if (fpout)
      fclose (fpout);

   return hRes;

} // HRESULT DecodeBackup (void)
#endif


HRESULT BuildLookup (LANGID lid,
                     GUID LexGuid,
                     char* pwLookupTextFile,
                     char* pwLookupLexFile,
                     char* pszSRTTS
                     )
{  
   USES_CONVERSION;
   HRESULT hRes = NOERROR;

   CComPtr<ISpObjectToken> cpToken;

   if (IsBadReadPtr (pwLookupTextFile, sizeof (WCHAR) * 2) ||
       IsBadReadPtr (pwLookupLexFile, sizeof (WCHAR) * 2))
      return E_INVALIDARG;

   strcpy(szLookupTextFile, pwLookupTextFile);
   strcpy(szLookupLexFile, pwLookupLexFile);

   GetTempPath (2*MAX_PATH, szTempPath);
   if (szTempPath[strlen (szTempPath) - 1] != '\\')
      strcat (szTempPath, "\\");

   LangID = lid;
   gLexGuid = LexGuid;

   FILE *fpLookupTextFile = fopen (szLookupTextFile, "r");
   if (!fpLookupTextFile)
   {
      hRes = E_FAIL;
      goto ReturnBuildLookupLts;
   }

   fclose (fpLookupTextFile);
   fpLookupTextFile = NULL;

   FILE *fpLookupLexFile;
   fpLookupLexFile = fopen (szLookupLexFile, "wb");
   if (!fpLookupLexFile)
   {
      hRes = E_FAIL;
      goto ReturnBuildLookupLts;
   }

   fclose (fpLookupLexFile);
   fpLookupLexFile = NULL;

   WordsEncoder = new CHuffEncoder;
   if (!WordsEncoder)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLookupLts;
   }

   PronsEncoder = new CHuffEncoder;
   if (!PronsEncoder)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLookupLts;
   }

   PosEncoder = new CHuffEncoder;
   if (!PosEncoder)
   {
      hRes = E_OUTOFMEMORY;
      goto ReturnBuildLookupLts;
   }

   strcpy (WordCBFile, szTempPath);
   strcat (WordCBFile, "WordCB.lex");

   strcpy (PronCBFile, szTempPath);
   strcat (PronCBFile, "PronCB.lex");

   strcpy (PosCBFile, szTempPath);
   strcat (PosCBFile, "PosCB.lex");

   hRes = EncodeBackup ();
   if (FAILED (hRes))
      goto ReturnBuildLookupLts;

   WCHAR *pwszInst;

   switch (LangID)
   {
   case 1033:
      if (!stricmp(pszSRTTS, "SR"))
      {
         pwszInst = L"MS_1033_SR_LKUP";
      }
      else
      {
         pwszInst = L"MS_1033_TTS_LKUP";
      }
      break;

   case 1041:
      if (!stricmp(pszSRTTS, "SR"))
      {
         pwszInst = L"MS_1041_SR_LKUP";
      }
      else
      {
         pwszInst = L"MS_1041_TTS_LKUP";
      }
      break;

   case 2052:
      if (!stricmp(pszSRTTS, "SR"))
      {
         pwszInst = L"MS_2052_SR_LKUP";
      }
      else
      {
         pwszInst = L"MS_2052_TTS_LKUP";
      }
      break;
   }

#ifdef _DEBUG

   WCHAR szTokenId[MAX_PATH];
   wcscpy(szTokenId, SPREG_USER_ROOT);
   wcscat(szTokenId, L"\\TempVendor");

   // Create a temp token in registry
   hRes = SpCreateNewTokenEx(
                szTokenId,
                pwszInst,
                &CLSID_SpCompressedLexicon,
                NULL,
                0,
                NULL,
                &cpToken,
                NULL);
   if (FAILED(hRes))
   {
       goto ReturnBuildLookupLts;
   }
   else
   {
       WCHAR szFullPath[MAX_PATH];
       if (SUCCEEDED(hRes))
       {
           if (!_wfullpath(szFullPath, A2W(szLookupLexFile), MAX_PATH))
           {
               hRes = E_FAIL;
           }
       }
       if (SUCCEEDED(hRes))
       {
           hRes = cpToken->SetStringValue(L"DataFile", szFullPath);
       }
       if (FAILED(hRes))
       {
           goto ReturnBuildLookupLts;
       }
   }

   hRes = DecodeBackup(pwszInst);

   if (cpToken != NULL)
   {
       hRes = cpToken->Remove(NULL);
   }
   if (FAILED (hRes))
      goto ReturnBuildLookupLts;

   _ASSERTE (_CrtCheckMemory());
#endif

ReturnBuildLookupLts:
   free (pBlock);
   free (pHash);
   free (pCmpHash);

   delete WordsEncoder;
   delete PronsEncoder;
   delete PosEncoder;

   _ASSERTE (_CrtCheckMemory());
   _CrtDumpMemoryLeaks();

   return hRes;
} // STDMETHODIMP BuildLookup ()


int main (int argc, char * argv[])
{
   USES_CONVERSION;

   WCHAR * wszConverterType = NULL;
    
   if (argc != 5)
   {
      printf ("Usage: %s LangID LookupTextFile LookupLexFile SR|TTS\n", argv[0]);
      return -1;
   }

   GUID gLex;
   LANGID LangID = (LANGID)atoi(argv[1]);

   if (LangID != 1033 && LangID != 1041 && LangID != 2052)
   {
      printf("Bad LangID\n");
      return -1;
   }

   HRESULT hr = CoInitialize(NULL);
   if (FAILED(hr))
      return hr;

   if (LangID == 1033)
      nCodePage = 1252;
   else if (LangID == 1041)
      nCodePage = 932;
   else
      nCodePage = 936;

   if (!stricmp(argv[4], "SR"))
   {
      fSR = true;
      wszConverterType = L"Type=SR";
      if (LangID == 1033)
      {
         gLex = CLSID_MSSR1033Lexicon;
         // fSymbolicPhones flag could be used to have dictionaries in human-readable
         // form, using symbolic phoneme names instead of hex phoneids as now.
         // Since the vendor dictionary is already in hex,
         // we may as well leave them as is, for now
         // fSymbolicPhones = true;
         // BUGBUG: If we do turn this on, need to find SR phone converters somehow...
         wszConverterType = L"Type=SRVendor";
      }
      else if (LangID == 1041)
         gLex = CLSID_MSSR1041Lexicon;
      else if (LangID == 2052)
         gLex = CLSID_MSSR2052Lexicon;
   }
   else if (!stricmp(argv[4], "TTS"))
   {
      fTTS = true;
      wszConverterType = L"Type=TTS";
      if (LangID == 1033)
         gLex = CLSID_MSTTS1033Lexicon;
      else if (LangID == 1041)
         gLex = CLSID_MSTTS1041Lexicon;
      else if (LangID == 2052)
         gLex = CLSID_MSTTS2052Lexicon;
   }
   else
   {
      printf("Bad SR|TTS specifer\n");
      return -1;
   }

   if (fSymbolicPhones)
   {
       hr = SpCreatePhoneConverter(
                LangID, 
                wszConverterType,
                NULL, 
                &pPhoneConv);
   }

   if (FAILED(hr))
       return -1;

   hr = BuildLookup(LangID, gLex, argv[2], argv[3], argv[4]);
   if (FAILED(hr))
      return -1;

   if (pPhoneConv)
      pPhoneConv->Release();

   CoUninitialize();

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\tools\bldvendor\huffc.cpp ===
#include <windows.h>
#include "HuffC.h"

CHuffEncoder::CHuffEncoder ()
{
   m_nKeys        = 0;
   m_nLenTreeBuf  = 0;
   m_nUseTreeBuf  = 0;
   m_pEncodeTree  = NULL;
   m_pHuffKey     = NULL;
   m_iRoot        = 0;
   m_pCodeTable   = NULL;
   m_pEncodedBuf  = NULL;
   m_nLenEnBuf    = 0;
   m_nUseEnBuf    = 0;
   m_iBitFlush    = 0;

} // CHuffEncoder::CHuffEncoder ()


CHuffEncoder::~CHuffEncoder ()
{
   free (m_pEncodeTree);
   free (m_pHuffKey);
   free (m_pCodeTable);
   free (m_pEncodedBuf);

} // CHuffEncoder::~CHuffEncoder ()


HRESULT CHuffEncoder::Count (HUFFKEY Key)
{
   // Look for the key
   for (int i = 0; i < m_nUseTreeBuf; i++)
   {
      if (Key == m_pHuffKey[i])
      {
         (m_pEncodeTree[i].nCount)++;
         return NOERROR;
      }
   }

   if (m_nUseTreeBuf == m_nLenTreeBuf)
   {
      m_nLenTreeBuf += 256;
      m_pHuffKey = (PHUFFKEY) realloc (m_pHuffKey, m_nLenTreeBuf * sizeof (HUFFKEY));
      if (!m_pHuffKey)
         return E_OUTOFMEMORY;

      m_pEncodeTree = (PHUFF_EN_NODE) realloc (m_pEncodeTree, m_nLenTreeBuf * sizeof (HUFF_EN_NODE));
      if (!m_pEncodeTree)
         return E_OUTOFMEMORY;
   }

   // Create a new key a vlaue - which is also a leaf for the huffman code tree
   m_pHuffKey     [m_nUseTreeBuf]            = Key;
   m_pEncodeTree  [m_nUseTreeBuf].nCount     = 1;
   m_pEncodeTree  [m_nUseTreeBuf].fConsider  = true;
   m_pEncodeTree  [m_nUseTreeBuf].iLeft      = (WORD)-1; // -1 means leaf node (key value)
   m_pEncodeTree  [m_nUseTreeBuf].iRight     = (WORD)-1; // -1 means leaf node (key value)

   m_nUseTreeBuf++;
   m_nKeys++;
            
   return NOERROR;

} // CHuffEncoder::Count (HUFFKEY Key)


HRESULT CHuffEncoder::ConstructCode (FILE *fp)
{
   m_iRoot = 0;

   // Construct the Huffman tree
   if (!m_nKeys)
   {
      goto WRITEOUT;
   }

   for (;;)
   {
      // find the two nodes with the lowest counts and with fConsider flags ON

      int iLowest = 0x7fffffff;
      int iLowest1 = 0x7fffffff; // second lowest

      int nLowest = 0x7fffffff;
      int nLowest1 = 0x7fffffff;

      for (int i = 0; i < m_nUseTreeBuf; i++)
      {
         if (false == m_pEncodeTree[i].fConsider)
            continue;

         if (m_pEncodeTree[i].nCount < nLowest)
         {
            nLowest1 = nLowest;
            iLowest1 = iLowest;

            nLowest = m_pEncodeTree[i].nCount;
            iLowest = i;
         }
         else if (m_pEncodeTree[i].nCount < nLowest1)
         {
            nLowest1 = m_pEncodeTree[i].nCount;
            iLowest1 = i;
         }
      }

      SPDBG_ASSERT(iLowest != 0x7fffffff);

      if (iLowest1 == 0x7fffffff)
      {
         m_pEncodeTree[iLowest].fConsider = false; // Not necessary but safe
         m_pEncodeTree[iLowest].iParent   = (unsigned short)-1;    // Not necessary but safe
         m_iRoot = iLowest;
         break;
      }

      if (m_nUseTreeBuf == m_nLenTreeBuf)
      {
         m_nLenTreeBuf += 256;
         m_pEncodeTree = (PHUFF_EN_NODE) realloc (m_pEncodeTree, m_nLenTreeBuf * sizeof (HUFF_EN_NODE));
         if (!m_pEncodeTree)
            return E_OUTOFMEMORY;
      }

      m_pEncodeTree[m_nUseTreeBuf].iLeft  = (unsigned short)iLowest;
      m_pEncodeTree[m_nUseTreeBuf].iRight = (unsigned short)iLowest1;
      m_pEncodeTree[m_nUseTreeBuf].nCount = m_pEncodeTree[iLowest].nCount + 
                                            m_pEncodeTree[iLowest1].nCount;
      m_pEncodeTree[m_nUseTreeBuf].fConsider = true;

      m_pEncodeTree[iLowest].fConsider  = false;
      m_pEncodeTree[iLowest].iParent    = (unsigned short)m_nUseTreeBuf;
      m_pEncodeTree[iLowest1].fConsider = false;
      m_pEncodeTree[iLowest1].iParent   = (unsigned short)m_nUseTreeBuf;

      m_nUseTreeBuf++;

   } // for (;;)

   SPDBG_ASSERT(m_iRoot);

   // Build a table of keys and codes for quick encoding
   m_pCodeTable = (PCODE_TABLE) malloc (m_nKeys * sizeof (CODE_TABLE));
   if (!m_pCodeTable)
      return E_OUTOFMEMORY;

   int i;
   for (i = 0; i < m_nKeys; i++)
   {
      _ASSERTE (i != m_iRoot);

      int iNode = i;
      m_pCodeTable[i].nBits = 0;
      m_pCodeTable[i].Code  = (CODETYPE)0;

      // The least significant bit of code occupies the MSB of m_pCodeTable[i].Code

      for (;;)
      {
         (m_pCodeTable[i].nBits)++;

         _ASSERTE (m_pCodeTable[i].nBits < 8 * sizeof (m_pCodeTable[i].Code)); 

         int iParent = m_pEncodeTree[iNode].iParent;

         _ASSERTE ((iNode == m_pEncodeTree[iParent].iLeft) ||
                   (iNode == m_pEncodeTree[iParent].iRight));

         if (iNode == (m_pEncodeTree[iParent].iRight))
         {
            m_pCodeTable[i].Code |= (((CODETYPE)1) << (8 * sizeof (m_pCodeTable[0].Code) - m_pCodeTable[i].nBits));
         }
      
         iNode = m_pEncodeTree[iNode].iParent;

         if (iNode == m_iRoot)
            break;

      } // for (;;)

      m_pCodeTable[i].Code >>= (8 * sizeof (m_pCodeTable[i].Code) - m_pCodeTable[i].nBits);

   } // for (int i = 0; i < nKeys; i++)

WRITEOUT:

   // Write out the huffman tree to the file, fp
   fwrite (&m_nKeys, sizeof (m_nKeys), 1, fp);
   fwrite (&m_nUseTreeBuf, sizeof (m_nUseTreeBuf), 1, fp);
   fwrite (&m_iRoot, sizeof (m_iRoot), 1, fp);
   fwrite (m_pHuffKey, sizeof (HUFFKEY), m_nKeys, fp);

   // write out only the relevant parts of encode tree nodes needed for decoding
   for (i = 0; i < m_nUseTreeBuf; i++)
   {
      PHUFF_NODE p = (PHUFF_NODE)(m_pEncodeTree + i);
      fwrite (p, sizeof (HUFF_NODE), 1, fp);
   }

   // free the stuff no longer needed
   free (m_pEncodeTree);
   m_pEncodeTree = NULL;

   return NOERROR;

} // HRESULT CHuffEncoder::ConstructCode (FILE *fp)


HRESULT CHuffEncoder::Encode (HUFFKEY Key)
{
   if (m_nLenEnBuf < m_nUseEnBuf + 256)
   {
      m_nLenEnBuf += 512;
      m_pEncodedBuf = (PDWORD) realloc (m_pEncodedBuf, m_nLenEnBuf * sizeof (DWORD));
      if (!m_pEncodedBuf)
         return E_OUTOFMEMORY;
   }

   for (int i = 0; i < m_nKeys; i++)
   {
      if (m_pHuffKey[i] == Key)
         break;
   }

   _ASSERTE (i < m_nKeys);

   if (i >= m_nKeys)
      return E_FAIL;

   int iDWORD = m_iBitFlush >> 5;
   int iBit   = m_iBitFlush & 0x1f;

   PDWORD p = m_pEncodedBuf + iDWORD;

   for (int j = 0; j < m_pCodeTable[i].nBits; j++)
   {
      CODETYPE d = (m_pCodeTable[i].Code & (1 << j));
      if (d)
         (*p) |= (1 << iBit);
      else
         (*p) &= ~(1 << iBit);
      ++iBit;

      if (iBit == 0x20)
      {
         p++;
         iBit = 0;
      }
   }

   m_iBitFlush += m_pCodeTable[i].nBits;

   m_nUseEnBuf = (((m_iBitFlush + 0x1f) & (~0x1f)) >> 5);

   return NOERROR;

} // HRESULT CHuffEncoder::Encode (HUFFKEY Key)


HRESULT CHuffEncoder::Flush (PDWORD pBuf, int *iBit)
{
   *iBit = m_iBitFlush;

   CopyMemory (pBuf, m_pEncodedBuf, sizeof (DWORD)* (((m_iBitFlush + 0x1f) & (~0x1f)) >> 5));

   m_iBitFlush = 0;
   return NOERROR;

} // HRESULT CHuffEncoder::Flush (PDWORD *ppBuf, int *iBit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\lexicon\tools\regdata\regdata.cpp ===
#include <tchar.h>
#include <atlbase.h>
#include "sphelper.h"
#include "spunicode.h"
// #include "..\..\data\ms1033srmap.h"
// #include "..\..\data\ms1033srvendormap.h"
// #include "..\..\data\ms1033ltsmap.h"
#include "..\..\data\ms1033ttsmap.h" // BUGBUG - Ought to be renamed as below for e.g.
#include "..\..\data\2052SAPImap.h"
#include "..\..\data\1041SAPImap.h"

// This code does not ship

// This code creates the registry entries for the vendor and lts lexicons. The lexicon
// datafiles registered here are the ones checked in the slm source tree. This is not
// done using a reg file because we need to compute the absolute path of the datafiles
// which can be different on different machines because of different root slm directories.

CSpUnicodeSupport   g_Unicode;

HRESULT AddPhoneConv(
    WCHAR *pszTokenKeyName, 
    WCHAR *pszDescription, 
    WCHAR *pszLanguage,
    BOOL fNoDelimiter,
    BOOL fNumericPhones,
    const CLSID *pclsid,
    WCHAR *pszPhoneMap)
{
    HRESULT hr;

    CComPtr<ISpObjectToken> cpToken;
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    hr = SpCreateNewTokenEx(
            SPCAT_PHONECONVERTERS,
            pszTokenKeyName,
            pclsid, 
            pszDescription,
            0,
            NULL,
            &cpToken,
            &cpDataKeyAttribs);

    if (SUCCEEDED(hr) && fNoDelimiter)
    {
        hr = cpDataKeyAttribs->SetStringValue(L"NoDelimiter", L"");
    }

    if (SUCCEEDED(hr) && fNumericPhones)
    {
        hr = cpDataKeyAttribs->SetStringValue(L"NumericPhones", L"");
    }

    if (SUCCEEDED(hr) && pszLanguage != NULL)
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Language", pszLanguage);
    }

    if (SUCCEEDED(hr) && pszPhoneMap)
    {
        hr = cpToken->SetStringValue(L"PhoneMap", pszPhoneMap);
    }
            
    return hr;
}

int _tmain()
{
    HRESULT hr;

    hr = CoInitialize(NULL);

    CComPtr<ISpObjectTokenCategory> cpPhoneConvCategory;
    if (SUCCEEDED(hr))
    {
        hr = SpGetCategoryFromId(SPCAT_PHONECONVERTERS, &cpPhoneConvCategory, TRUE);

        if (SUCCEEDED(hr))
        {
            CComPtr<ISpDataKey> cpTokens;

            if (SUCCEEDED(cpPhoneConvCategory->OpenKey(L"Tokens", &cpTokens)))
            {
                // Delete old phone converters.
                WCHAR * pszSubKeyName = NULL;
                while (SUCCEEDED(cpTokens->EnumKeys(0, &pszSubKeyName)))
                {
                    // Since NT doesn't allow recursive delete, need to delete Attributes subkey first.
                    {
                        CComPtr<ISpDataKey> cpPhoneKey;

                        hr = cpTokens->OpenKey(pszSubKeyName, &cpPhoneKey);

                        if (SUCCEEDED(hr))
                            hr = cpPhoneKey->DeleteKey(L"Attributes");
                    }

                    if (SUCCEEDED(hr))
                        hr = cpTokens->DeleteKey(pszSubKeyName);

                    CoTaskMemFree(pszSubKeyName);

                    if (FAILED(hr))
                        break;
                }
            }
        }
    }
    cpPhoneConvCategory.Release();

    if (SUCCEEDED(hr))
        hr = AddPhoneConv(L"English", L"English Phone Converter", L"409", FALSE, FALSE, &CLSID_SpPhoneConverter, pszms1033ttsmap);

    if (SUCCEEDED(hr))
        hr = AddPhoneConv(L"Japanese", L"Japanese Phone Converter", L"411", TRUE, TRUE, &CLSID_SpPhoneConverter, psz1041SAPImap);

    if (SUCCEEDED(hr))
        hr = AddPhoneConv(L"Chinese", L"Chinese Phone Converter", L"804", FALSE, FALSE, &CLSID_SpPhoneConverter, psz2052SAPImap);

    CoUninitialize();

    return SUCCEEDED(hr)
                ? 0
                : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\spserver.h ===
// SpServer.h : Declaration of the CSpServer

#ifndef __SPSERVER_H_
#define __SPSERVER_H_

#include "resource.h"       // main symbols

class CSpLinkedNode;

/////////////////////////////////////////////////////////////////////////////
// CSpOwnedList - class for maintaining a list of all objects created on behalf
//                  of a client process.  This is used to auto release the objects
//                  if the client should die.  NOTE:  IUnknown is somewhat overloaded
//                  in this implementation.  QI is not impl, AddRef returns 1, and
//                  Release walks the list and frees all linked objects.  In the normal
//                  close case, SpServer will call FreeList which asserts that the list
//                  is empty and deletes this list object.
class CSpOwnedList : public IUnknown
{
private:
    CSpLinkedNode *m_pHead;             // weak pointer to start of list of objects created
                                        // by a process instance
    CRITICAL_SECTION m_csList;
    BOOL m_bReleasing;

public:
	CSpOwnedList()
    {
        m_pHead = NULL;
        ::InitializeCriticalSection(&m_csList);
        m_bReleasing = FALSE;
    }
    ~CSpOwnedList()
    {
        SPDBG_ASSERT(m_pHead == NULL);
        ::DeleteCriticalSection(&m_csList);
    }

// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
    {
        return E_NOTIMPL;
    }
    virtual STDMETHODIMP_(ULONG) AddRef(void)
    {
        return 1;
    }
    virtual STDMETHODIMP_(ULONG) Release(void);

    void LinkOwnedObject(CSpLinkedNode *pObj);
    void UnlinkOwnedObject(CSpLinkedNode *pObj);
    void FreeList(void);
};

/////////////////////////////////////////////////////////////////////////////
// CSpLinkedNode - a base class that defines the members needed for each node
//                  to be linked into list maintained by the CSpOwnedList object;
//                  and a single method "FreeInstance" that CSpOwnedList calls
//                  to force the release of a node.
class CSpLinkedNode
{
protected:
    CSpOwnedList *m_pOwnerList;         // weak pointer

public:
    CSpLinkedNode *m_pNext;             // weak pointer

    virtual void FreeInstance(void) = NULL;
};

/////////////////////////////////////////////////////////////////////////////
// CSpLinkedAgg - aggregator class used to link all objects created on behalf
//                  of a client process.  This is used by SpServer in implementing
//                  ISpServer::CreateInstance.  All of the objects are linked into
//                  SpServer's instance of CSpOwnedList which allows for auto
//                  cleanup, if the owner process dies.
class CSpLinkedAgg : public IUnknown, public CSpLinkedNode
{
private:
    LONG m_cRef;
    CComPtr<IUnknown> m_cpUnkInner;
public:
    ~CSpLinkedAgg()
    {
        if (m_cpUnkInner) {
            m_cRef = 1;     // guard before m_cpUnkInner is released
            m_cpUnkInner.Release();
        }
    }

    HRESULT CreateInstance(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj, CSpOwnedList *pOwnerList)
    {
        HRESULT hr;

        m_pOwnerList = NULL;
        m_pNext = NULL;
        m_cRef = 1;
        hr = m_cpUnkInner.CoCreateInstance(rclsid, this);
        if (SUCCEEDED(hr)) {
            hr = m_cpUnkInner->QueryInterface(riid, ppvObj);    // bumped m_cRef, if successful
            if (SUCCEEDED(hr)) {
                m_pOwnerList = pOwnerList;
                if (pOwnerList) {
                    pOwnerList->LinkOwnedObject(this);
                }
            }
        }
        Release();  // release if CoCreate or QI failed, else dec m_cRef back to 1;
        return hr;
    }

    void FreeInstance(void)
    {
        delete this;
    }

// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
    {
        if (riid == IID_IUnknown) {
            *ppvObj = this;
            AddRef();
            return S_OK;
        }
        return m_cpUnkInner->QueryInterface(riid, ppvObj);
    }
    virtual STDMETHODIMP_(ULONG) AddRef(void)
    {
        return InterlockedIncrement(&m_cRef);
    }
    virtual STDMETHODIMP_(ULONG) Release(void)
    {
        LONG res;

        res = InterlockedDecrement(&m_cRef);
        if (res == 0) {
            if (m_pOwnerList) {
                m_pOwnerList->UnlinkOwnedObject(this);
            }
            delete this;
        }
        return res;
    }
};


/////////////////////////////////////////////////////////////////////////////
// CSpServer
class ATL_NO_VTABLE CSpServer : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSpServer, &CLSID_SpServer>,
    public CSpLinkedNode,
    public IMarshal,
	public ISpServer,
    public ISpIPC
{
private:
    PVOID m_pClientHalf;
    DWORD m_dwClientThreadID;
    HANDLE m_hClientProcess;
    CComObject<CSpIPCmgr> *m_pIPCmgr;

    // m_pOwnerList is a shared reference pointer - the reference is shared with _Module.
    // In the case of the client process dying without cleaning up, _Module will Release
    // the list object which will force the release of all the process specific objects.
    // In normal termination, this object will call m_pOwnerList->FreeList() which asserts
    // that the list is empty, and then deletes the list object.
public:
	CSpServer()
	{
        m_pClientHalf = NULL;
        m_dwClientThreadID = 0;
        m_hClientProcess = NULL;
        m_pIPCmgr = NULL;
        m_pOwnerList = NULL;
	}

    void FinalRelease();

    void FreeInstance(void)
    {
        m_pOwnerList = NULL;
        Release();              // force the Release of the reference held by the client
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SPSERVER)
DECLARE_NOT_AGGREGATABLE(CSpServer)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSpServer)
	COM_INTERFACE_ENTRY(ISpServer)
    COM_INTERFACE_ENTRY(IMarshal)
END_COM_MAP()

// IMarshal
    STDMETHODIMP GetUnmarshalClass
    (
        /*[in]*/ REFIID riid,
        /*[in], unique]*/ void *pv,
        /*[in]*/ DWORD dwDestContext,
        /*[in], unique]*/ void *pvDestContext,
        /*[in]*/ DWORD mshlflags,
        /*[out]*/ CLSID *pCid
    );

    STDMETHODIMP GetMarshalSizeMax
    (
        /*[in]*/ REFIID riid,
        /*[in], unique]*/ void *pv,
        /*[in]*/ DWORD dwDestContext,
        /*[in], unique]*/ void *pvDestContext,
        /*[in]*/ DWORD mshlflags,
        /*[out]*/ DWORD *pSize
    );

    STDMETHODIMP MarshalInterface
    (
        /*[in], unique]*/ IStream *pStm,
        /*[in]*/ REFIID riid,
        /*[in], unique]*/ void *pv,
        /*[in]*/ DWORD dwDestContext,
        /*[in], unique]*/ void *pvDestContext,
        /*[in]*/ DWORD mshlflags
    );

    STDMETHODIMP UnmarshalInterface
    (
        /*[in], unique]*/ IStream *pStm,
        /*[in]*/ REFIID riid,
        /*[out]*/ void **ppv
    );

    STDMETHODIMP ReleaseMarshalData
    (
        /*[in], unique]*/ IStream *pStm
    );

    STDMETHODIMP DisconnectObject
    (
        /*[in]*/ DWORD dwReserved
    );

// ISpIPC
	STDMETHOD(MethodCall)(DWORD dwMethod, ULONG ulCallFrameSize, ISpServerCallContext *pCCtxt);

// ISpServer
public:
	STDMETHOD(ClaimCallContext)(/*[in, defaultvalue(NULL)]*/ PVOID pSvrObjPtr, ISpServerCallContext **ppCCtxt);
    STDMETHOD(CreateInstance)(REFCLSID rclsid, /*[in, defaultvalue(NULL)]*/ ISpIPC *pOwnerObj, ISpObjectRef **ppSOR)
    {
        return E_NOTIMPL;
    }

};

#endif //__SPSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by spsvr.rc
//
#define IDR_Spsvr                       100
#define IDR_SPSERVER                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\spserver.cpp ===
// SpServer.cpp : Implementation of CSpServer
#include "stdafx.h"
#include "Sapi.h"
#include "SrTask.h"
#include "SpIPCmgr.h"
#include "SpServer.h"
#include "SpServerPr.h"

extern CExeModule _Module;


/////////////////////////////////////////////////////////////////////////////
// CSpObjectRef
STDMETHODIMP_(ULONG) CSpObjectRef::Release(void)
{
    ULONG l;

    l = --m_cRef;
    if (l == 0) {
        delete this;
    }
    return l;
}

HRESULT CSpObjectRef::CreateInstance(ISpServer *pServer, ISpIPC *pOwnerObj, REFCLSID rclsid)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSpServer

void CSpServer::FinalRelease()
{
    if (m_hClientProcess) {
        _Module.StopTrackingProcess(m_hClientProcess);
        CloseHandle(m_hClientProcess);
    }
    if (m_pOwnerList) {
        m_pOwnerList->UnlinkOwnedObject(this);
        m_pOwnerList->FreeList();
    }
    if (m_pIPCmgr)
        m_pIPCmgr->Release();
}

// IMarshal methods
STDMETHODIMP CSpServer::GetUnmarshalClass(
    /*[in]*/ REFIID riid,
    /*[in], unique]*/ void *pv,
    /*[in]*/ DWORD dwDestContext,
    /*[in], unique]*/ void *pvDestContext,
    /*[in]*/ DWORD mshlflags,
    /*[out]*/ CLSID *pCid)
{
    *pCid = CLSID_SpServerPr;
    return S_OK;
}

STDMETHODIMP CSpServer::GetMarshalSizeMax(
    /*[in]*/ REFIID riid,
    /*[in], unique]*/ void *pv,
    /*[in]*/ DWORD dwDestContext,
    /*[in], unique]*/ void *pvDestContext,
    /*[in]*/ DWORD mshlflags,
    /*[out]*/ DWORD *pSize)
{
    *pSize = 3 * sizeof(DWORD) + sizeof(PVOID);
    return S_OK;
}

STDMETHODIMP CSpServer::MarshalInterface(
    /*[in], unique]*/ IStream *pStm,
    /*[in]*/ REFIID riid,
    /*[in], unique]*/ void *pv,
    /*[in]*/ DWORD dwDestContext,
    /*[in], unique]*/ void *pvDestContext,
    /*[in]*/ DWORD mshlflags)
{
    HRESULT hr;
    DWORD n;

    hr = CreateIPCmgr(&m_pIPCmgr);
    if ( FAILED(hr) )
        return hr;

    n = m_pIPCmgr->AvailableTasks();
    hr = pStm->Write(&n, sizeof(DWORD), 0);
    if ( FAILED(hr) )
        return hr;

    n = MAXTASKS;
    hr = pStm->Write(&n, sizeof(DWORD), 0);
    if ( FAILED(hr) )
        return hr;

    n = m_pIPCmgr->TaskSharedStackSize();
    hr = pStm->Write(&n, sizeof(DWORD), 0);
    if ( FAILED(hr) )
        return hr;

    ISpIPC * pObj = (ISpIPC*)this;
    hr = pStm->Write(&pObj, sizeof(pObj), 0);
    if ( FAILED(hr) )
        return hr;

    AddRef();
    return S_OK;
}

STDMETHODIMP CSpServer::UnmarshalInterface(
    /*[in], unique]*/ IStream *pStm,
    /*[in]*/ REFIID riid,
    /*[out]*/ void **ppv)
{
    return S_OK;
}

STDMETHODIMP CSpServer::ReleaseMarshalData(
    /*[in], unique]*/ IStream *pStm)
{
    return S_OK;
}

STDMETHODIMP CSpServer::DisconnectObject(
    /*[in]*/ DWORD dwReserved)
{
    return S_OK;
}

STDMETHODIMP CSpServer::ClaimCallContext(PVOID pTargetObjPtr, ISpServerCallContext **ppCCtxt)
{
    HRESULT hr;
    CComObject<CSrTask> *pTask;

    *ppCCtxt = NULL;
    hr = m_pIPCmgr->ClaimTask(&pTask);
    if ( SUCCEEDED(hr) ) {
        if (pTargetObjPtr)
            hr = pTask->ClaimContext(pTargetObjPtr, m_dwClientThreadID, ppCCtxt);
        else
            hr = pTask->ClaimContext(m_pClientHalf, m_dwClientThreadID, ppCCtxt);
    }
    return hr;
}

STDMETHODIMP CSpServer::MethodCall(DWORD dwMethod, ULONG ulCallFrameSize, ISpServerCallContext *pCCtxt)
{
    HRESULT hr = S_OK;
    BYTE *tos;

    pCCtxt->GetTopOfStack(&tos, NULL);
    switch (dwMethod) {
    case METHOD_SPSERVER_COMPLETEINIT:
        // complete initialization
        {
            CF_SPSERVER_COMPLETEINIT *pCF;

            pCF = (CF_SPSERVER_COMPLETEINIT *)(tos - sizeof(CF_SPSERVER_COMPLETEINIT));
            m_pClientHalf = pCF->pClientSideObject;
            m_dwClientThreadID = pCF->dwThreadID;
            m_hClientProcess = OpenProcess(SYNCHRONIZE, FALSE, pCF->dwProcessID);
            m_pOwnerList = new CSpOwnedList;
            SPDBG_ASSERT(m_pOwnerList != NULL);  // the server will work, but no autocleanup for this process
            if (m_pOwnerList) {
                m_pOwnerList->LinkOwnedObject(this);
                _Module.TrackProcess(m_hClientProcess, m_pOwnerList);
            }
        }
        break;

    case METHOD_SPSERVER_RELEASE:
        {
            // Release();
            IUnknown **ppObject;

            ppObject = (IUnknown **)(tos - sizeof(IUnknown*));
            if (*ppObject) {
                (*ppObject)->Release();
                break;
            }
        }
        // fall through to METHOD_SPSERVER_RELEASESELF, if pTargetObject == NULL
    case METHOD_SPSERVER_RELEASESELF:
        Release();
        break;

    case METHOD_SPSERVER_CREATEINSTANCE:
        {
            CF_SPSERVER_CREATEINSTANCE *pCF;
            CComPtr<ISpIPCObject> cpIPCObj;
            CSpObjectRef *pRef;

            pCF = (CF_SPSERVER_CREATEINSTANCE *)(tos - sizeof(CF_SPSERVER_CREATEINSTANCE));
            {
                hr = E_OUTOFMEMORY;
                if (m_pOwnerList) {
                    CSpLinkedAgg* pAgg = new CSpLinkedAgg;
                    if (pAgg) {
                        hr = pAgg->CreateInstance(pCF->clsid, IID_ISpIPC, (void**)&pCF->pServerSideObject, m_pOwnerList);
                     // pAgg = NULL;    // pAgg is no longer a valid reference, either the object was
                                        // was deleted, or pCF->pServerSideObject refers to the aggregation
                    }
                }
            }
            if (SUCCEEDED(hr)) {
                if (SUCCEEDED( pCF->pServerSideObject->QueryInterface(IID_ISpIPCObject,
                                    (void**)&cpIPCObj) )) {
                    pRef = new CSpObjectRef((ISpServer*)this, pCF->pClientSideObject);
                    if (pRef) {
		                cpIPCObj->SetOppositeHalf(pRef);
                        pRef->Release();
                    }
                    else {
                        // failed to create cSpObjectRef, so release created object and fail creation
                        pCF->pServerSideObject->Release();
                        pCF->pServerSideObject = NULL;
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            break;
        }
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSpOwnedList

ULONG STDMETHODCALLTYPE CSpOwnedList::Release(void)
{
    CSpLinkedNode *p;

    ::EnterCriticalSection(&m_csList);
    m_bReleasing = TRUE;
    while (m_pHead) {
        p = m_pHead->m_pNext;
        m_pHead->FreeInstance();
        m_pHead = p;
    }
    delete this;
    return 0;
}

void CSpOwnedList::FreeList(void)
{
    if (!m_bReleasing)
        delete this;
}

void CSpOwnedList::LinkOwnedObject(CSpLinkedNode *pObj)
{
    SPDBG_ASSERT(pObj != NULL);
    ::EnterCriticalSection(&m_csList);
    pObj->m_pNext = m_pHead;
    m_pHead = pObj;
    ::LeaveCriticalSection(&m_csList);
}

void CSpOwnedList::UnlinkOwnedObject(CSpLinkedNode *pObj)
{
    CSpLinkedNode **ppPrev;

    SPDBG_ASSERT(pObj != NULL);
    ::EnterCriticalSection(&m_csList);
	ppPrev = &m_pHead;
	while (*ppPrev)
	{
		if ((*ppPrev) == pObj)
		{
			*ppPrev = pObj->m_pNext;
            ::LeaveCriticalSection(&m_csList);
            return;
		}
		ppPrev = &((*ppPrev)->m_pNext);
	}
    ::LeaveCriticalSection(&m_csList);
    SPDBG_ASSERT(0); // node not found in list
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\spipcmgr.cpp ===
// SpIPCmgr.cpp : Implementation of CSpIPCmgr
#include "stdafx.h"
#include "Sapi.h"
#include "SrTask.h"
#include "SpIPCmgr.h"
#include <tchar.h>

#define SHAREDMEMNAME    _T("srsvr_mem")
#define TASKCALLFORMAT   _T("srvr_call%x")
#define TASKEVENTFORMAT  _T("srvr_event%x")
#define TASKMUTEXFORMAT  _T("srvr_mutex%x")
#define CLIENTCALLFORMAT _T("srsvr_clicall%x")

#define TASKSTACKPAGES  4
#define SHMEMSIZE       (MAXTASKS * TASKSTACKPAGES * 4096)
#define TASKS           4

CComObject<CSpIPCmgr> *g_pIPCmgr;

HRESULT CreateIPCmgr(CComObject<CSpIPCmgr> **ppIPCmgr)
{
    HRESULT hr;

    if (g_pIPCmgr == NULL) {
        hr = CComObject<CSpIPCmgr>::CreateInstance(&g_pIPCmgr);
        if ( FAILED(hr) )
            return hr;
        // leave global ptr as a weak ptr so it will be freed with the last referencing object
    }
    *ppIPCmgr = g_pIPCmgr;
    (*ppIPCmgr)->AddRef();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSpIPCmgr

HRESULT CSpIPCmgr::FinalConstruct()
{
    HRESULT hr = E_OUTOFMEMORY;
    int i, tasks;
    DWORD *stackptr;
    HANDLE hWakeEvent, hCallEvent;
    TCHAR objname[MAX_PATH];

    m_hMapObject = CreateFileMapping( 
        (HANDLE) 0xFFFFFFFF, // use paging file
        NULL,                // no security attributes
        PAGE_READWRITE,      // read/write access
        0,                   // size: high 32-bits
        SHMEMSIZE,           // size: low 32-bits
        SHAREDMEMNAME);      // name of map object
    if (m_hMapObject == NULL) 
        return hr;

    // Get a pointer to the file-mapped shared memory.
    m_lpvMem = (BYTE*)MapViewOfFile( 
        m_hMapObject,   // object to map view of
        FILE_MAP_WRITE, // read/write access
        0,              // high offset:  map from
        0,              // low offset:   beginning
        0);             // default: map entire file
    if (m_lpvMem == NULL) 
        goto failure; 

    tasks = 0;
    for (i = 0; i < TASKS; i++) {
        stackptr = (DWORD *)(m_lpvMem + i * TASKSTACKPAGES * 4096);
        wsprintf(objname, TASKEVENTFORMAT, i);
        hWakeEvent = CreateEvent(NULL, FALSE, FALSE, objname);
        if (hWakeEvent != NULL) {
            wsprintf(objname, TASKCALLFORMAT, i);
            hCallEvent = CreateEvent(NULL, FALSE, FALSE, objname);
            if (hCallEvent != NULL) {
                wsprintf(objname, TASKMUTEXFORMAT, i);
                m_hMutexes[i] = CreateMutex(NULL, FALSE, objname);
                if (m_hMutexes[i] != NULL) {
                    if (SUCCEEDED(CComObject<CSrTask>::CreateInstance(&m_cptask[i]))) {
                        m_cptask[i]->AddRef();
                        if (SUCCEEDED(m_cptask[i]->Init(i, hWakeEvent, hCallEvent, m_hMutexes[i], stackptr, TASKSTACKPAGES * 4096))) {
                            tasks++;
                            continue;   // skip handle cleanup, and go to next task
                        }
                        m_cptask[i]->Release();
                    }
                    CloseHandle(m_hMutexes[i]);
                }
                CloseHandle(hCallEvent);
            }
            CloseHandle(hWakeEvent);
        }
        m_cptask[i] = NULL;
        m_hMutexes[i] = INVALID_HANDLE_VALUE;
    }

    if (tasks > 0) {
        return S_OK;
    }

failure:
    if (m_lpvMem)
        UnmapViewOfFile(m_lpvMem);
    if (m_hMapObject)
        CloseHandle(m_hMapObject);
    return hr;
}

void CSpIPCmgr::FinalRelease()
{
    int i;

    for (i = 0; i < TASKS; i++) {
        if (m_cptask[i]) {
            m_cptask[i]->Close();
            m_cptask[i]->Release();
        }
    }
    g_pIPCmgr = NULL;
}

DWORD CSpIPCmgr::AvailableTasks(void)
{
    return TASKS;
}

DWORD CSpIPCmgr::TaskSharedStackSize(void)
{
    return TASKSTACKPAGES * 4096;
}

HRESULT CSpIPCmgr::ClaimTask(CComObject<CSrTask> **ppTask)
{
    DWORD selected;

    *ppTask = NULL;

    selected = WaitForMultipleObjects(TASKS, m_hMutexes, FALSE, INFINITE);
    if (selected != WAIT_TIMEOUT) {
        selected -= WAIT_OBJECT_0;  // task #
        *ppTask = m_cptask[selected];
        return S_OK;
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\spipcmgr.h ===
// SpIPCmgr.h : Declaration of the CSpIPCmgr

#ifndef __SPIPCMGR_H_
#define __SPIPCMGR_H_

#include "resource.h"       // main symbols

#define MAXTASKS        8

/////////////////////////////////////////////////////////////////////////////
// CSpIPCmgr
class ATL_NO_VTABLE CSpIPCmgr : 
	public CComObjectRootEx<CComMultiThreadModel>
{
private:
HANDLE m_hMapObject;     // handle to file mapping
BYTE  *m_lpvMem;         // pointer to shared memory
CComObject<CSrTask> *m_cptask[MAXTASKS];
HANDLE m_hMutexes[MAXTASKS];

public:
	CSpIPCmgr()
	{
        m_hMapObject = NULL;
        m_lpvMem = NULL;
        ZeroMemory((BYTE*)&m_cptask, sizeof(m_cptask));
	}

    HRESULT FinalConstruct();
    void FinalRelease();

DECLARE_NOT_AGGREGATABLE(CSpIPCmgr)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSpIPCmgr)
END_COM_MAP()

    DWORD AvailableTasks(void);
    DWORD TaskSharedStackSize(void);
	HRESULT ClaimTask(CComObject<CSrTask> **ppTask);

};

HRESULT CreateIPCmgr(CComObject<CSpIPCmgr> **ppIPCmgr);

#endif //__SPIPCMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\srsvr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Aug 17 11:19:08 1999
 */
/* Compiler settings for \\iitdev\spgslm\src\sapi5\Src\srsvr\srsvr.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __srsvr_h__
#define __srsvr_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "sapi.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __SRSVRLib_LIBRARY_DEFINED__
#define __SRSVRLib_LIBRARY_DEFINED__

/* library SRSVRLib */
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_SRSVRLib;
#endif /* __SRSVRLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\spsvr.cpp ===
// spsvr.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f spsvrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "Sapi.h"
#include "spsvr.h"

#include "spsvr_i.c"
#include "SrTask.h"
#include "SpIPCmgr.h"
#include "SpServer.h"
#include "sapiint_i.c"

const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up



// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

HRESULT CExeModule::TrackProcess(HANDLE hClientProcess, IUnknown *pProcUnk)
{
    EnterCriticalSection(&m_csObjMap);
    hProcesses[dwHandleCnt] = hClientProcess;
    pProcessUnk[dwHandleCnt++] = pProcUnk;
    LeaveCriticalSection(&m_csObjMap);
    dwRemove = 0;
    SetEvent(hEventShutdown); // restart monitor's wait
    return S_OK;
}

HRESULT CExeModule::StopTrackingProcess(HANDLE hClientProcess)
{
    DWORD i;

    EnterCriticalSection(&m_csObjMap);
    i = 1;
    while (i < dwHandleCnt) {
        if (hProcesses[i] == hClientProcess) {
            hProcesses[i] = NULL;
            dwRemove = i;
            break;
        }
        i++;
    }
    LeaveCriticalSection(&m_csObjMap);
    if (dwRemove)
        SetEvent(hEventShutdown); // single monitor to remove handle from list and then restart wait
    return S_OK;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

void CExeModule::_RemoveProcessEntry(DWORD dwRemove)
{
    CopyMemory(&hProcesses[dwRemove], &hProcesses[dwRemove+1], (MAX_PROCESSES - dwRemove - 1) * sizeof(HANDLE));
    CopyMemory(&pProcessUnk[dwRemove], &pProcessUnk[dwRemove+1], (MAX_PROCESSES - dwRemove - 1) * sizeof(IUnknown *));
    dwHandleCnt--;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    DWORD dwWait=0;

    ZeroMemory(&hProcesses[0], sizeof(hProcesses));
    hProcesses[0] = hEventShutdown;
    dwHandleCnt = 1;
    bActivity = false;
    while (1)
    {
        do {
            dwWait = WaitForMultipleObjects(dwHandleCnt, &hProcesses[0], FALSE, INFINITE);
            if (dwWait == WAIT_OBJECT_0) {
                if (bActivity)
                    break;
                if (dwRemove) {
                    EnterCriticalSection(&m_csObjMap);
                    _RemoveProcessEntry(dwRemove);
                    LeaveCriticalSection(&m_csObjMap);
                }
            }
        } while (dwWait == WAIT_OBJECT_0);

        if (dwWait > WAIT_OBJECT_0) {
            // a process has terminated
            // BUGBUG walk through list and release objects owned by the process
            dwWait -= WAIT_OBJECT_0;
            EnterCriticalSection(&m_csObjMap);
            hProcesses[dwWait] = NULL;
            IUnknown *pUnk = pProcessUnk[dwWait];
            _RemoveProcessEntry(dwWait);
            LeaveCriticalSection(&m_csObjMap);
            pUnk->Release();
        }
        else {
#if 0
            do
            {
                bActivity = false;
                dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
            } while (dwWait == WAIT_OBJECT_0);
            // timed out
            if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
#else
            if (m_nLockCnt == 0)
#endif
            {
    #if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
                CoSuspendClassObjects();
                if (!bActivity && m_nLockCnt == 0)
    #endif
                    break;
            }
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SpServer, CSpServer)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
#ifdef _WIN32_WCE
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
#endif
    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance, &LIBID_SPSVRLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_Spsvr, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_Spsvr, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }

    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\lexedit\globals.h ===
#ifndef __LEXEDIT_GLOBALS_H__
#define __LEXEDIT_GLOBALS_H__
		
#include "LexEdit_1.h"

// Global handles to each of the dialogs
extern HWND					g_hDlg;
extern HINSTANCE			g_hInst;

// Other global variables
extern WCHAR				g_szWFileName[256];
extern TCHAR*				g_pszFileText;

#endif // __LEXEDIT_GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\lexedit\lexedit_1.cpp ===
// LexEdit_1.cpp : Defines the entry point for the application.
//

#include "StdAfx.h"
#include "resource.h"

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	

    HACCEL      hAccel;
    HWND        hWnd = NULL;
    MSG         msg;
    WNDCLASSEX  wc;
	HRESULT     hr   = S_OK;
        
    // Store the global instance
    g_hInst = hInstance;
    
    // Initialize the Win95 control library
    InitCommonControls();
    
    // Initialize COM
    CoInitialize(NULL);

    // Register the main dialog class
    ZeroMemory( &wc, sizeof(wc) );
    wc.cbSize = sizeof( wc );
    GetClassInfoEx( NULL, WC_DIALOG, &wc );
    wc.lpfnWndProc      = DlgProcMain;
    wc.hInstance        = hInstance;
    wc.hCursor          = LoadCursor( NULL, IDC_ARROW );
    wc.hbrBackground    = GetSysColorBrush( COLOR_3DFACE );
    wc.lpszMenuName     = NULL;
    wc.hIcon            = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_APPICON) );
    wc.hIconSm          = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_APPICON) );

    if(!RegisterClassEx(&wc))
        goto exit;

    //--- Create the default voice and get the TTS default wave format
    hr = cpVoice.CoCreateInstance( CLSID_SpVoice );
    if (FAILED(hr))
        goto exit;

   // Create the main dialog
    g_hDlg  = CreateDialog( hInstance, MAKEINTRESOURCE(IDD_MAIN),
                            NULL, (DLGPROC)DlgProcMain );
    
    // If we didn't get our dialogs, we need to bail.
    if( !g_hDlg )
        goto exit;

	// Make the main dialog visible
    ShowWindow(g_hDlg, SW_RESTORE);
    UpdateWindow(g_hDlg);

    hAccel = LoadAccelerators( hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1) );
                    
    // Enter the message loop
    while(GetMessage(&msg, NULL, 0, 0) > 0)
    {
        if (!TranslateAccelerator (g_hDlg, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }


exit:

	// Free the dialogs
    DestroyWindow(g_hDlg);
	cpVoice.Release();

	// Unload COM
    CoUninitialize();

    // Return 0
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\lexedit\dlgmain.cpp ===
#include "StdAfx.h"

//
// Handlers for Windows messages
//
BOOL MainHandleInitDialog(HWND hWnd, HWND hwndFocus, LPARAM lParam);
void MainHandleClose(HWND hWnd);
void MainHandleDestroy(HWND hWnd);
void MainHandleCommand(HWND hWnd, int id, HWND hWndControl, UINT codeNotify);

//
// Other local functions
//
BOOL CallOpenFileDialog( HWND hWnd, LPSTR szFileName );
bool ReadLine();
void DisplayValues( HWND hWnd );
HRESULT ConvertReadableToUnicode( const char *szReadable, WCHAR *szwUnicode );

// Global variables - needed to be able to read from file...
using namespace std;
typedef vector<char*> STRINGVECTOR;

STRINGVECTOR fileVector;
int fileIndex;
FILE *fStream, *fSkip, *fDelete, *fTemp;
TCHAR szAFileName[256], tempFileName[257];
BOOL bGotFile = FALSE;
TCHAR sOrth[30], sPos1A[10], sPos1B[10], sPos1C[10], sPos1D[10], sIpa1[40];
TCHAR sPos2A[10], sPos2B[10], sPos2C[10], sPos2D[10], sIpa2[40], sComments[200];
TCHAR sCurline[100], sPrevline[100];

LPARAM CALLBACK DlgProcMain(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
     // Call the appropriate message handler
    switch(uMsg)                                                    
    {
        HANDLE_MSG( hwnd, WM_INITDIALOG, MainHandleInitDialog );
        HANDLE_MSG( hwnd, WM_CLOSE, MainHandleClose );      
        HANDLE_MSG( hwnd, WM_DESTROY, MainHandleDestroy );
        HANDLE_MSG( hwnd, WM_COMMAND, MainHandleCommand );
    }

    // Call the default message handler.
    // NOTE:    Only do this on this main dialog proc.  For any other dialogs,
    //          return TRUE, or the dialog will pop up, and not ever give up
    //          focus.
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/////////////////////////////////////////////////////////////////
void MainHandleCommand(HWND hWnd, int id, HWND hWndControl, UINT codeNotify)
/////////////////////////////////////////////////////////////////
//
// Handle each of the WM_COMMAND messages that come in, and hand them
// off to the correct function.
//
{
    char *temp, buffer[100];

	switch(id)
    {
		case IDC_BUTTON_OPEN:


            // if file already open, close it before opening a new one...
            if (bGotFile) {
                fclose(fSkip);
                fclose(fDelete);
                fileVector.clear();
            }

            // Do the Open File Dialog...
            bGotFile = CallOpenFileDialog( hWnd, szAFileName );

            if (bGotFile) {

                // DO SOME REGISTRY STUFF TO LOAD THE FIRST UNEDITED WORD...
                LONG lRetVal;
                HKEY hkResult;
                char szPosition[4] = "0";  
                DWORD size = 4;

                lRetVal = RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("LexiconFilePosition"), 0, NULL, 0,
                              KEY_ALL_ACCESS, NULL, &hkResult, NULL );
   
                if( lRetVal == ERROR_SUCCESS )         
                {        
                    RegQueryValueEx( hkResult, _T(szAFileName), NULL, NULL, (PBYTE)szPosition, &size );         
                    RegCloseKey( hkResult );
                }
                fileIndex = atoi(szPosition);

                strcpy(tempFileName, szAFileName);
                strcpy((tempFileName + strlen(tempFileName)), "~");

                SetDlgItemText( hWnd, IDC_EDIT_ORTH, tempFileName );

                // OPEN THE FILE, AND READ IT IN TO fileVector... (also copy it into a temporary file)
                if( (fStream = fopen( szAFileName, "r" )) != NULL &&
                    (fTemp = fopen( tempFileName, "w" )) != NULL)
                {
                    int i = 0;
                    temp = new char[100];
                    while (fgets(temp, 100, fStream) != NULL) {
                        fileVector.push_back(temp);
                        fputs(temp, fTemp);
                        temp = new char[100];
                    }
                    fclose(fTemp);
                    fclose(fStream);
                    delete [] temp;

                    // DISPLAY THE FIRST UNEDITED WORD...
                    if ( ReadLine() )
                        DisplayValues(hWnd);
                    else {
                        strcpy(sOrth, "NO WORDS!");
                        DisplayValues(hWnd);
                    }
                } 
                char fSkipFileName[100] = "";
                char fDeleteFileName[100] = "";
                strcat(fSkipFileName, szAFileName);
                strcat(fSkipFileName, "skip");
                strcat(fDeleteFileName, szAFileName);
                strcat(fDeleteFileName, "delete");
    
                fSkip = fopen(fSkipFileName, "a+");
                fDelete = fopen(fDeleteFileName, "a+");

            }


            break;

        case IDC_BUTTON_DONE:

            if (bGotFile) {

                // Check word values against their initial values...
                char sCurPos1A[10], sCurPos1B[10], sCurPos1C[10], sCurPos1D[10], sCurIpa1[40];
                char sCurPos2A[10], sCurPos2B[10], sCurPos2C[10], sCurPos2D[10], sCurIpa2[40], sCurComments[200];

                GetDlgItemText( hWnd, IDC_EDIT_POS1A, sCurPos1A, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS1B, sCurPos1B, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS1C, sCurPos1C, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS1D, sCurPos1D, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_IPA1, sCurIpa1, 40 );
                GetDlgItemText( hWnd, IDC_EDIT_POS2A, sCurPos2A, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS2B, sCurPos2B, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS2C, sCurPos2C, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_POS2D, sCurPos2D, 10 );
                GetDlgItemText( hWnd, IDC_EDIT_IPA2, sCurIpa2, 40 );
                GetDlgItemText( hWnd, IDC_EDIT_COMMENTS, sCurComments, 200 );

                if ((strcmp(sPos1A, sCurPos1A) != 0) ||
                    (strcmp(sPos1B, sCurPos1B) != 0) ||
                    (strcmp(sPos1C, sCurPos1C) != 0) ||
                    (strcmp(sPos1D, sCurPos1D) != 0) ||
                    (strcmp(sIpa1, sCurIpa1) != 0)   ||
                    (strcmp(sPos2A, sCurPos2A) != 0) ||
                    (strcmp(sPos2B, sCurPos2B) != 0) ||
                    (strcmp(sPos2C, sCurPos2C) != 0) ||
                    (strcmp(sPos2D, sCurPos2D) != 0) ||
                    (strcmp(sIpa2, sCurIpa2) != 0)   ||
                    (strcmp(sComments, sCurComments) != 0)) {
                    
                    // LINE WAS EDITED
                    strcpy(buffer, "");
                    strcat(buffer, sOrth);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos1A);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos1B);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos1C);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos1D);
                    strcat(buffer, ",");
                    strcat(buffer, sCurIpa1);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos2A);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos2B);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos2C);
                    strcat(buffer, ",");
                    strcat(buffer, sCurPos2D);
                    strcat(buffer, ",");
                    strcat(buffer, sCurIpa2);
                    strcat(buffer, ",");
                    strcat(buffer, sCurComments);
                    strcat(buffer, "\n");

                    char *temp = fileVector.at(fileIndex - 1);
                    strcpy(temp, buffer);

                } else {
                    // LINE WAS NOT EDITED
                }

                // Display next word...
                // First get rid of the previous word values...
                strcpy(sPos1A, "");
                strcpy(sPos1B, "");
                strcpy(sPos1C, "");
                strcpy(sPos1D, "");
                strcpy(sIpa1, "");
                strcpy(sPos2A, "");
                strcpy(sPos2B, "");
                strcpy(sPos2C, "");
                strcpy(sPos2D, "");
                strcpy(sIpa2, "");
                strcpy(sComments, "");

                if ( ReadLine() ) 
                    DisplayValues(hWnd);
                else {
                    strcpy(sOrth, "NO WORDS LEFT!");
                    DisplayValues(hWnd);
                }
            }    
            break;

        case IDC_BUTTON_RESET:

            DisplayValues(hWnd);
            break;

        case IDC_BUTTON_PREVIOUS:

            // First get rid of the previous word values...
            strcpy(sPos1A, "");
            strcpy(sPos1B, "");
            strcpy(sPos1C, "");
            strcpy(sPos1D, "");
            strcpy(sIpa1, "");
            strcpy(sPos2A, "");
            strcpy(sPos2B, "");
            strcpy(sPos2C, "");
            strcpy(sPos2D, "");
            strcpy(sIpa2, "");
            strcpy(sComments, "");

            fileIndex -= 2;
            ReadLine();
            DisplayValues(hWnd);
            break;

        case IDC_BUTTON_PLAY1:
        
            WCHAR sWIpa1[40];
            char sCurIpa1[40];
            GetDlgItemText( hWnd, IDC_EDIT_IPA1, sCurIpa1, 40 );

            wcscpy(sWIpa1, L"<PRON IPA=\"");
            ConvertReadableToUnicode(sCurIpa1, sWIpa1+11);
            wcscpy((sWIpa1 + wcslen(sWIpa1)), L"\"/>a</PRON>");

            cpVoice->Speak( sWIpa1, SPF_USEGLOBALDOC, NULL );
            break;

        case IDC_BUTTON_PLAY2:

            WCHAR sWIpa2[40];
            char sCurIpa2[40];
            GetDlgItemText( hWnd, IDC_EDIT_IPA2, sCurIpa2, 40 );

            wcscpy(sWIpa2, L"<PRON IPA=\"");
            ConvertReadableToUnicode(sCurIpa2, sWIpa2+11);
            wcscpy((sWIpa2 + wcslen(sWIpa2)), L"\"/>a</PRON>");

            cpVoice->Speak( sWIpa2, SPF_USEGLOBALDOC, NULL );
            break;

        case IDC_BUTTON_SKIP:

            GetDlgItemText( hWnd, IDC_EDIT_COMMENTS, sComments, 200 );

            strcpy(buffer, "");
            strcat(buffer, sOrth);
            strcat(buffer, ",");
            strcat(buffer, sPos1A);
            strcat(buffer, ",");
            strcat(buffer, sPos1B);
            strcat(buffer, ",");
            strcat(buffer, sPos1C);
            strcat(buffer, ",");
            strcat(buffer, sPos1D);
            strcat(buffer, ",");
            strcat(buffer, sIpa1);
            strcat(buffer, ",");
            strcat(buffer, sPos2A);
            strcat(buffer, ",");
            strcat(buffer, sPos2B);
            strcat(buffer, ",");
            strcat(buffer, sPos2C);
            strcat(buffer, ",");
            strcat(buffer, sPos2D);
            strcat(buffer, ",");
            strcat(buffer, sIpa2);
            strcat(buffer, ",");
            strcat(buffer, sComments);
            strcat(buffer, "\n");

            fputs(buffer, fSkip);

            // Display next word...
            // First get rid of the previous word values...
            strcpy(sPos1A, "");
            strcpy(sPos1B, "");
            strcpy(sPos1C, "");
            strcpy(sPos1D, "");
            strcpy(sIpa1, "");
            strcpy(sPos2A, "");
            strcpy(sPos2B, "");
            strcpy(sPos2C, "");
            strcpy(sPos2D, "");
            strcpy(sIpa2, "");
            strcpy(sComments, "");

            if ( ReadLine() ) 
                DisplayValues(hWnd);
            else {
                strcpy(sOrth, "NO WORDS LEFT!");
                DisplayValues(hWnd);
            }

            break;

        case IDC_BUTTON_DELETE:

            GetDlgItemText( hWnd, IDC_EDIT_COMMENTS, sComments, 200 );

            strcpy(buffer, "");
            strcat(buffer, sOrth);
            strcat(buffer, ",");
            strcat(buffer, sPos1A);
            strcat(buffer, ",");
            strcat(buffer, sPos1B);
            strcat(buffer, ",");
            strcat(buffer, sPos1C);
            strcat(buffer, ",");
            strcat(buffer, sPos1D);
            strcat(buffer, ",");
            strcat(buffer, sIpa1);
            strcat(buffer, ",");
            strcat(buffer, sPos2A);
            strcat(buffer, ",");
            strcat(buffer, sPos2B);
            strcat(buffer, ",");
            strcat(buffer, sPos2C);
            strcat(buffer, ",");
            strcat(buffer, sPos2D);
            strcat(buffer, ",");
            strcat(buffer, sIpa2);
            strcat(buffer, ",");
            strcat(buffer, sComments);
            strcat(buffer, "\n");

            fputs(buffer, fDelete);

            // Display next word...
            // First get rid of the previous word values...
            strcpy(sPos1A, "");
            strcpy(sPos1B, "");
            strcpy(sPos1C, "");
            strcpy(sPos1D, "");
            strcpy(sIpa1, "");
            strcpy(sPos2A, "");
            strcpy(sPos2B, "");
            strcpy(sPos2C, "");
            strcpy(sPos2D, "");
            strcpy(sIpa2, "");
            strcpy(sComments, "");

            if ( ReadLine() ) 
                DisplayValues(hWnd);
            else {
                strcpy(sOrth, "NO WORDS LEFT!");
                DisplayValues(hWnd);
            }

            break;
    }
	
	return;
}


///////////////////////
void DisplayValues(HWND hWnd)
///////////////////////

{
	SetDlgItemText( hWnd, IDC_EDIT_ORTH, sOrth );
    SetDlgItemText( hWnd, IDC_EDIT_POS1A, sPos1A );
    SetDlgItemText( hWnd, IDC_EDIT_POS1B, sPos1B );
    SetDlgItemText( hWnd, IDC_EDIT_POS1C, sPos1C );
    SetDlgItemText( hWnd, IDC_EDIT_POS1D, sPos1D );
    SetDlgItemText( hWnd, IDC_EDIT_POS2A, sPos2A );
    SetDlgItemText( hWnd, IDC_EDIT_POS2B, sPos2B );
    SetDlgItemText( hWnd, IDC_EDIT_POS2C, sPos2C );
    SetDlgItemText( hWnd, IDC_EDIT_POS2D, sPos2D );
    SetDlgItemText( hWnd, IDC_EDIT_IPA1, sIpa1 );
    SetDlgItemText( hWnd, IDC_EDIT_IPA2, sIpa2 );
    SetDlgItemText( hWnd, IDC_EDIT_COMMENTS, sComments );
}

////////////////////////////////
bool ReadLine()
////////////////////////////////

{ 
    char *linePtr, sLine[100], temp[100];

    linePtr = fileVector.at(fileIndex);
    strcpy(sLine, linePtr);
    fileIndex++;

    // Get Orthography...
    sscanf(sLine, "%[^,],%s", sOrth, sLine);

    // Get Pos1A
    sscanf(sLine, "%[^,],%s", sPos1A, temp);
    if (strcmp(sPos1A, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos1B
    sscanf(sLine, "%[^,],%s", sPos1B, temp);
    if (strcmp(sPos1B, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos1C
    sscanf(sLine, "%[^,],%s", sPos1C, temp);
    if (strcmp(sPos1C, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos1D
    sscanf(sLine, "%[^,],%s", sPos1D, temp);
    if (strcmp(sPos1D, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);
 
    // Get Ipa1
    sscanf(sLine, "%[^,],%s", sIpa1, temp);
    if (strcmp(sIpa1, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos2A
    sscanf(sLine, "%[^,],%s", sPos2A, temp);
    if (strcmp(sPos2A, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos2B
    sscanf(sLine, "%[^,],%s", sPos2B, temp);
    if (strcmp(sPos2B, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos2C
    sscanf(sLine, "%[^,],%s", sPos2C, temp);
    if (strcmp(sPos2C, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Pos2D
    sscanf(sLine, "%[^,],%s", sPos2D, temp);
    if (strcmp(sPos2D, "") == 0) 
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    // Get Ipa2
    sscanf(sLine, "%[^,],%s", sIpa2, temp);
    if (strcmp(sIpa2, "") == 0)
        sscanf(sLine, ",%s", sLine);
    else
        strcpy(sLine, temp);

    sscanf(sLine, "%[^,],%s", sComments, temp);
    return true;
}

//////////////////////////////////////////////////////////////////////
HRESULT ConvertReadableToUnicode( const char *szReadable, WCHAR *szwUnicode )
//////////////////////////////////////////////////////////////////////
{

    char cFirst, cSecond;
    int iRIndex = 0, iUIndex = 0;

    if ( szReadable == NULL )
        return E_INVALIDARG;
    if ( szwUnicode == NULL )
        return E_POINTER;

    cFirst = szReadable[iRIndex];

    while (cFirst) {

        if (('a' <= cFirst) && (cFirst <= 'z')) {
           
            switch (cFirst) 
            {
            case 'b':
                szwUnicode[iUIndex] = 0x62;
                break;
            case 'p':
                szwUnicode[iUIndex] = 0x70;
                break;
            case 'd':
                szwUnicode[iUIndex] = 0x64;
                break;
            case 't':
                szwUnicode[iUIndex] = 0x74;
                break;
            case 'g':
                szwUnicode[iUIndex] = 0x261;
                break;
            case 'k':
                szwUnicode[iUIndex] = 0x6b;
                break;
            case 'f':
                szwUnicode[iUIndex] = 0x66;
                break;
            case 'v':
                szwUnicode[iUIndex] = 0x76;
                break;
            case 's':
                szwUnicode[iUIndex] = 0x73;
                break;
            case 'z':
                szwUnicode[iUIndex] = 0x7a;
                break;
            case 'l':
                szwUnicode[iUIndex] = 0x6c;
                break;
            case 'r':
                szwUnicode[iUIndex] = 0x27b;
                break;
            case 'y':
                szwUnicode[iUIndex] = 0x6a;
                break;
            case 'w':
                szwUnicode[iUIndex] = 0x77;
                break;
            case 'h':
                szwUnicode[iUIndex] = 0x266;
                break;
            case 'm':
                szwUnicode[iUIndex] = 0x6d;
                break;
            case 'n':
                szwUnicode[iUIndex] = 0x6e;
                break;
            case 'j':
                szwUnicode[iUIndex] = 0x2a3;
                break;
            default:
                return E_FAIL;
            }
            iRIndex++;
            iUIndex++;

        } else if (('A' <= cFirst) && (cFirst <= 'Z')) {

            cSecond = szReadable[++iRIndex];
            switch (cFirst) 
            {
            case 'A':
                switch (cSecond)
                {
                case 'A':
                    szwUnicode[iUIndex] = 0x61;
                    break;
                case 'E':
                    szwUnicode[iUIndex] = 0xe6;
                    break;
                case 'O':
                    szwUnicode[iUIndex] = 0x254;
                    break;
                case 'X':
                    szwUnicode[iUIndex] = 0x259;
                    break;
                case 'Y':
                    szwUnicode[iUIndex] = 0x61;
                    szwUnicode[++iUIndex] = 0x26a;
                    break;
                case 'W':
                    szwUnicode[iUIndex] = 0x61;
                    szwUnicode[++iUIndex] = 0x28a;
                    break;
                default:
                    return E_FAIL;
                }
                break;
            case 'E':
                switch (cSecond)
                {
                case 'H':
                    szwUnicode[iUIndex] = 0x25b;
                    break;
                case 'R':
                    szwUnicode[iUIndex] = 0x25a;
                    break;
                case 'Y':
                    szwUnicode[iUIndex] = 0x65;
                    break;
                default:
                    return E_FAIL;
                }
                break;
           case 'I':
               switch (cSecond)
               {
               case 'H':
                   szwUnicode[iUIndex] = 0x26a;
                   break;
               case 'Y':
                   szwUnicode[iUIndex] = 0x69;
                   break;
               case 'X':
                   szwUnicode[iUIndex] = 0x268;
                   break;
               default:
                   return E_FAIL;
               }
               break;
           case 'U':
               switch (cSecond)
               {
               case 'H':
                   szwUnicode[iUIndex] = 0x28a;
                   break;
               case 'W':
                   szwUnicode[iUIndex] = 0x75;
                   break;
               case 'X':
                    szwUnicode[iUIndex] = 0x28c;
                    break;
               default:
                   return E_FAIL;
               }
               break;
           case 'O':
               switch (cSecond)
               {
               case 'Y':
                   szwUnicode[iUIndex] = 0x254;
                   szwUnicode[++iUIndex] = 0x26a;
                   break;
               case 'W':
                   szwUnicode[iUIndex] = 0x6f;
                   szwUnicode[++iUIndex] = 0x28a;
                   break;
               default:
                   return E_FAIL;
               }
               break;
           case 'D':
                switch (cSecond)
                {
                case 'H':
                    szwUnicode[iUIndex] = 0xf0;
                    break;
                case 'X':
                    szwUnicode[iUIndex] = 0x74;
                    break;
                default:
                    return E_FAIL;
                }
                break;
            case 'T':
                if (cSecond == 'H') {
                    szwUnicode[iUIndex] = 0x3b8;
                    break;
                } else {
                    return E_FAIL;
                }
            case 'S':
                if (cSecond == 'H') {
                    szwUnicode[iUIndex] = 0x283;
                    break;
                } else {
                    return E_FAIL;
                }
            case 'Z':
                if (cSecond == 'H') {
                    szwUnicode[iUIndex] = 0x292;
                    break;
                } else {
                    return E_FAIL;
                }
            case 'C':
                if (cSecond == 'H') {
                    szwUnicode[iUIndex] = 0x2a7;
                    break;
                } else {
                    return E_FAIL;
                }
            default:
                return E_FAIL;
            }
            iRIndex++;
            iUIndex++;

        } else {
            switch (cFirst)
            {
            case '1':
                szwUnicode[iUIndex] = 0x2c8;
                break;
            case '2':
                szwUnicode[iUIndex] = 0x2cc;
                break;
            case '-':
                szwUnicode[iUIndex] = 0x2d;
                break;
            default:
                return E_FAIL;
            }
            iRIndex++;
            iUIndex++;
        }

        cFirst = szReadable[iRIndex];

    }
    szwUnicode[iUIndex] = 0;
    return S_OK;
}


/////////////////////////////////////////////////////////////////
BOOL CallOpenFileDialog( HWND hWnd, LPSTR szFileName )  
/////////////////////////////////////////////////////////////////

{
    OPENFILENAME    ofn;
	BOOL            bRetVal     = TRUE;
    LONG            lRetVal;
    HKEY            hkResult;
    TCHAR           szPath[256]       = _T("");
    DWORD           size = 256;

	// Open the last directory used by this app (stored in registry)
    lRetVal = RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("PathTTSDataFiles"), 0, NULL, 0,
                        KEY_ALL_ACCESS, NULL, &hkResult, NULL );

    if( lRetVal == ERROR_SUCCESS )
    {
        RegQueryValueEx( hkResult, _T("TTSFiles"), NULL, NULL, (PBYTE)szPath, &size );
    
        RegCloseKey( hkResult );
    }

    ofn.lStructSize       = OPENFILENAME_SIZE_VERSION_400;
    ofn.hwndOwner         = hWnd;    
	ofn.lpstrFilter       = "TXT (*.txt)\0*.txt\0All Files (*.*)\0*.*\0";
    ofn.lpstrCustomFilter = NULL;    
	ofn.nFilterIndex      = 1;    
	ofn.lpstrInitialDir   = szPath;
	ofn.lpstrFile         = szFileName;  
	ofn.nMaxFile          = 256;
    ofn.lpstrTitle        = NULL;
    ofn.lpstrFileTitle    = NULL;    
	ofn.lpstrDefExt       = NULL;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_READONLY | OFN_PATHMUSTEXIST;

	// Pop the dialog
    bRetVal = GetOpenFileName( &ofn );

    // Write the directory path you're in to the registry
    TCHAR   pathstr[256] = _T("");
    strcpy( pathstr, szFileName );

    int i=0; 
    while( pathstr[i] != NULL )
    {
        i++;
    }
    while( pathstr[i] != '\\' )
    {
        i --;
    }
    pathstr[i] = NULL;

    // Now write the string to the registry
    lRetVal = RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("PathTTSDataFiles"), 0, NULL, 0,
                        KEY_ALL_ACCESS, NULL, &hkResult, NULL );

    if( lRetVal == ERROR_SUCCESS )
    {
        RegSetValueEx( hkResult, _T("TTSFiles"), NULL, REG_EXPAND_SZ, (PBYTE)pathstr, strlen(pathstr)+1 );
    
        RegCloseKey( hkResult );
    }

    return bRetVal;
}

/////////////////////////////////////////////////////////////////
BOOL MainHandleInitDialog(HWND hWnd, HWND hwndFocus, LPARAM lParam)
/////////////////////////////////////////////////////////////////
{
	// Store this as the "Main Dialog"
	g_hDlg  = hWnd;
    strcpy(sCurline, "");

	return TRUE;
}

/////////////////////////////////////////////////////////////////
void MainHandleClose(HWND hWnd)
/////////////////////////////////////////////////////////////////
{
    LONG lRetVal;
    HKEY hkResult;
    char buffer[10], *temp;
    itoa(fileIndex, buffer, 10); 

    lRetVal = RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("LexiconFilePosition"), 0, NULL, 0,
                        KEY_ALL_ACCESS, NULL, &hkResult, NULL );

    if( lRetVal == ERROR_SUCCESS )
    {
        RegSetValueEx( hkResult, _T(szAFileName), NULL, REG_EXPAND_SZ, (PBYTE)buffer, strlen(buffer)+1 );    
        RegCloseKey( hkResult );
    }


    if (bGotFile) {
        // Save new information back to file in a SAFE manner...
        if ((fStream = fopen( szAFileName, "w" )) != NULL) {
            int i = 0;
            while (i < fileVector.size()) {
                temp = fileVector.at(i);
                fputs(temp, fStream);
                i++;
            }
            fclose(fStream);
            DeleteFile(tempFileName);
        }
    
        fclose(fDelete);
        fclose(fSkip);
    }

    // Terminate the app
    PostQuitMessage(0);

    // Return success
    return;
}

/////////////////////////////////////////////////////////////////
void MainHandleDestroy(HWND hWnd)
/////////////////////////////////////////////////////////////////
{

    LONG lRetVal;
    HKEY hkResult;
    char buffer[10];
    itoa(fileIndex, buffer, 10);

    lRetVal = RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("LexiconFilePosition"), 0, NULL, 0,
                        KEY_ALL_ACCESS, NULL, &hkResult, NULL );

    if( lRetVal == ERROR_SUCCESS )
    {
        RegSetValueEx( hkResult, _T(szAFileName), NULL, REG_EXPAND_SZ, (PBYTE)buffer, strlen(buffer)+1 );    
        RegCloseKey( hkResult );
    }

    // Return success
    return;                                                           
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\lexedit\lexedit_1.h ===
#ifndef _INC_LEXEDIT
#define _INC_LEXEDIT

#include <windows.h>		// System includes
#include <atlbase.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include "resource.h"
//#include <stdio.h>
#include <tchar.h>
#include <olectl.h>			// Required for showing property page
#include <sapi.h>			// SAPI includes
#include <sphelper.h>
#include <spuihelp.h>


//
// Prototypes for dialog procs
//
LPARAM CALLBACK DlgProcMain(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif // _INC_LEXEDIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\lexedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LexEdit_1.rc
//
#define IDD_MAIN                        101
#define IDI_APPICON                     102
#define IDR_ACCELERATOR1                106
#define IDC_EDIT_ORTH                   1000
#define IDC_EDIT_POS                    1001
#define IDC_EDIT_PRONUNCIATION          1002
#define IDC_SLIDER_RATE                 1003
#define IDC_SLIDER_VOLUME               1004
#define IDC_COMBO_VOICE                 1005
#define IDC_BUTTON_PLAY                 1007
#define IDC_BUTTON_DELETE               1008
#define IDC_BUTTON_RESET                1009
#define IDC_BUTTON_NEXT                 1010
#define IDC_BUTTON_DONE                 1010
#define IDC_BUTTON_PREVIOUS             1012
#define IDC_BUTTON_OPEN                 1013
#define IDC_BUTTON_SKIP                 1017
#define IDC_EDIT_IPA1                   1024
#define IDC_EDIT_POS1A                  1025
#define IDC_EDIT_POS1B                  1026
#define IDC_EDIT_POS1C                  1027
#define IDC_EDIT_POS1D                  1028
#define IDC_EDIT_IPA2                   1029
#define IDC_EDIT_POS2A                  1030
#define IDC_EDIT_POS2B                  1031
#define IDC_EDIT_POS2C                  1032
#define IDC_EDIT_POS2D                  1033
#define IDC_BUTTON_PLAY1                1034
#define IDC_BUTTON_PLAY2                1035
#define IDC_EDIT_COMMENTS               1039

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1040
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\lexedit\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	LexEdit_1.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

HWND                g_hDlg              = NULL;
HINSTANCE           g_hInst		        = NULL;
CComPtr<ISpVoice>   cpVoice             = NULL;
long                g_DefaultRate       = 350;
USHORT              g_DefaultVolume     = 50;



// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3F2DAE34_7D6D_11D2_8C9E_00C04F72DB08__INCLUDED_)
#define AFX_STDAFX_H__3F2DAE34_7D6D_11D2_8C9E_00C04F72DB08__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define MAX_PROCESSES 20

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
    HANDLE hProcesses[MAX_PROCESSES];
    IUnknown *pProcessUnk[MAX_PROCESSES];   // Holds a shared reference to an object that controls
                                            // all objects created on behalf of a process.  A single
                                            // Release of this Unk will cause all process specific
                                            // objects to be released.
    DWORD dwHandleCnt;
    DWORD dwRemove;

    HRESULT TrackProcess(HANDLE hClientProcess, IUnknown *pProcUnk);
    HRESULT StopTrackingProcess(HANDLE hClientProcess);
    void _RemoveProcessEntry(DWORD idx);
};
extern CExeModule _Module;

#ifdef _WIN32_WCE
#include <WinCEstub.h>
#endif

#include <atlcom.h>
#include <SPDDKHlp.h>
#include "sapiint.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3F2DAE34_7D6D_11D2_8C9E_00C04F72DB08__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\lexedit\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <vector>
#include <windows.h>
#include <atlbase.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include "resource.h"
//#include <stdio.h>
#include <tchar.h>
#include <olectl.h>			// Required for showing property page
#include <sapi.h>			// SAPI includes
#include <sphelper.h>
#include <spuihelp.h>


//
// Prototypes for dialog procs
//
LPARAM CALLBACK DlgProcMain(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);



// Global handles to each of the dialogs
extern HWND					g_hDlg;
extern HINSTANCE			g_hInst;
extern CComPtr<ISpVoice> cpVoice;
extern long g_DefaultRate;
extern USHORT g_DefaultVolume;


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\srtask.h ===
// SrTask.h : Declaration of the CSrTask

#ifndef __SRTASK_H_
#define __SRTASK_H_

#include "resource.h"       // main symbols

class CCallCtxt : ISpServerCallContext
{
friend class CSrTask;
private:
    ULONG  m_cRef;
    DWORD  m_tasknum;
    HANDLE m_hCompleteEvent;
    DWORD *m_stackptr;
    LONG   m_stacksize;
    HANDLE m_hMutex;
    DWORD  m_dwClientThreadID;
    DWORD  m_originalSP;
    IUnknown *m_pouter;
    PVOID  m_pTargetObject;

public:
    CCallCtxt()
    {
        m_cRef = 1;
        m_tasknum = 0;
        m_hCompleteEvent = NULL;
        m_hMutex = NULL;
        m_stackptr = NULL;
        m_dwClientThreadID = 0;
        m_originalSP = 0;
        m_pouter = NULL;
        m_pTargetObject = NULL;
    }

    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

// ISpServerCallContext
    STDMETHODIMP Call(DWORD methodIdx, PVOID pCallFrame, ULONG ulCallFrameSize, BOOL bCFInOut);
    STDMETHODIMP GetTopOfStack(BYTE **ppTOS, ULONG *pulAvailable)
    {
        *ppTOS = ((BYTE*)m_stackptr) + *m_stackptr;
        if (pulAvailable)
            *pulAvailable = m_stacksize - (LONG)*m_stackptr;
        return S_OK;
    }

    STDMETHODIMP_(BYTE*) AdjustStack(LONG lAmount)
    {
        if (lAmount >= 0) {
            SPDBG_ASSERT((lAmount & 3) == 0);        // must be dword aligned amount
            BYTE *pTOS = ((BYTE*)m_stackptr) + *m_stackptr;
            *m_stackptr += lAmount;
            return pTOS;
        }
        else {
            SPDBG_ASSERT(((-lAmount) & 3) == 0);     // must be dword aligned amount
            *m_stackptr += lAmount;
            return ((BYTE*)m_stackptr) + *m_stackptr;
        }
    }
};

/////////////////////////////////////////////////////////////////////////////
// CSrTask
class ATL_NO_VTABLE CSrTask : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public IUnknown
{
private:
    HANDLE m_hThread;
    HANDLE m_hWakeEvent;
    BOOL   m_bRunning;
    CCallCtxt m_cctxt;

public:
	CSrTask()
	{
        m_hThread = NULL;
        m_hWakeEvent = NULL;
        m_bRunning = TRUE;
        m_cctxt.m_pouter = (IUnknown*)this;
	}

    void FinalRelease();

DECLARE_NOT_AGGREGATABLE(CSrTask)

DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject)
    {
        if (iid == IID_ISpServerCallContext) {
            *ppvObject = (ISpServerCallContext *)&m_cctxt;
            m_cctxt.AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    HRESULT Init(DWORD tasknum, HANDLE hCompEvent, HANDLE hWakeEvent, HANDLE hMutex, DWORD *stackptr, LONG stacksize);
    void Close(void);

    DWORD ThreadProc(void);

    HRESULT ClaimContext(PVOID pTargetObject, DWORD dwClientThreadID, ISpServerCallContext **ppCCtxt)
    {
        m_cctxt.m_pTargetObject = pTargetObject;
        m_cctxt.m_cRef = 0;
        m_cctxt.m_dwClientThreadID = dwClientThreadID;
        *ppCCtxt = (ISpServerCallContext *)&m_cctxt;
        m_cctxt.AddRef();
        return S_OK;
    }

};

#endif //__SRTASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\resetusr\resetusr.h ===
/****************************************************************************
*	spuser.h
*		<put description here>
*
*	Owner: cthrash
*	Copyright  1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

//--- Forward and External Declarations -------------------------------------

BOOL    ParseCmdLine(char *, char **);
HRESULT ResetUser(char *);
HRESULT Report(char * lpMsg, HRESULT hr);

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\srsvr\srtask.cpp ===
// SrTask.cpp : Implementation of CSrTask
#include "stdafx.h"
#include "Sapi.h"
#include "SrTask.h"
#include "SpIPCmgr.h"
#include "SpServer.h"
#include "SpServerPr.h"

DWORD WINAPI InitThreadProc(LPVOID pdata)
{
    DWORD res;
    CComObject<CSrTask> *pthis = (CComObject<CSrTask>*)pdata;

    res = pthis->ThreadProc();
    pthis->Release();
    return res;
}

/////////////////////////////////////////////////////////////////////////////
// CSrTask

void CSrTask::FinalRelease()
{
    if (m_cctxt.m_hCompleteEvent)
        CloseHandle(m_cctxt.m_hCompleteEvent);
    if (m_hWakeEvent)
        CloseHandle(m_hWakeEvent);
    if (m_cctxt.m_hMutex)
        CloseHandle(m_cctxt.m_hMutex);
}


HRESULT CSrTask::Init(DWORD tasknum, HANDLE hCompEvent, HANDLE hWakeEvent, HANDLE hMutex, DWORD *stackptr, LONG stacksize)
{
    DWORD id;

    AddRef();   // thread now holds a ref
    m_hThread = CreateThread(NULL, 1024, InitThreadProc, (CComObject<CSrTask>*)this, 0, &id);
    if (m_hThread) {
        m_cctxt.m_tasknum = tasknum;
        m_cctxt.m_hCompleteEvent = hCompEvent;
        m_hWakeEvent = hWakeEvent;
        m_cctxt.m_hMutex = hMutex;
        m_cctxt.m_stackptr = stackptr;
        m_cctxt.m_stacksize = stacksize;
        *m_cctxt.m_stackptr = 4;  // initial stack pointer for each task stack
        return S_OK;
    }
    Release();  // failed to create thread, so no ref
    return E_OUTOFMEMORY;
}

void CSrTask::Close(void)
{
    if (m_hThread) {
        m_bRunning = FALSE;
        SetEvent(m_hWakeEvent);
        m_hThread = NULL;
    }
}

DWORD CSrTask::ThreadProc(void)
{
    HRESULT hr;
    CF_IPC *pCF;

#ifdef _WIN32_WCE
    if (SUCCEEDED(::CoInitializeEx(NULL, COINIT_MULTITHREADED)))
#else
    if (SUCCEEDED(::CoInitialize(NULL)))
#endif
    {
        while (m_bRunning)
        {
            WaitForSingleObject(m_hWakeEvent, INFINITE);
            if (m_bRunning)
            {
                SpCleanupCallFrame(&pCF, &m_cctxt);
                hr = pCF->pTargetObject->MethodCall(pCF->dwMethod, pCF->ulCallFrameSize, (ISpServerCallContext*)&m_cctxt);
                HRESULT *pHR;
                SpReserveCallFrame(&pHR, &m_cctxt);
                *pHR = hr;
                SetEvent(m_cctxt.m_hCompleteEvent);
            }
        }
        ::CoUninitialize();
    }
    return 0;
}

// CCallCtxt

STDMETHODIMP CCallCtxt::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    return m_pouter->QueryInterface(riid, ppvObj);
}

ULONG STDMETHODCALLTYPE CCallCtxt::AddRef(void)
{
    ULONG l;

    l = ++m_cRef;
    if (l == 1) {
        // first ref
        m_originalSP = *m_stackptr;
    }
    return l;
}

ULONG STDMETHODCALLTYPE CCallCtxt::Release(void)
{
    ULONG l;

    l = --m_cRef;
    if (l == 0) {
        m_cRef = 1;
        *m_stackptr = m_originalSP;
        m_dwClientThreadID = 0;
        ReleaseMutex(m_hMutex);
    }
    return l;
}

STDMETHODIMP CCallCtxt::Call(DWORD methodIdx, PVOID pCallFrame, ULONG ulCallFrameSize, BOOL bCFInOut)
{
    CF_IPC *pCF;
    HRESULT *pHR;
    PBYTE pTOS;

    if (m_dwClientThreadID) {
        if (pCallFrame) {
            pTOS = AdjustStack(ulCallFrameSize);
            SPDBG_ASSERT(pTOS);
            CopyMemory(pTOS, pCallFrame, ulCallFrameSize);
        }
        SpReserveCallFrame(&pCF, this);
        pCF->dwMethod = methodIdx;
        pCF->ulCallFrameSize = ulCallFrameSize;
        pCF->pTargetObject = (ISpIPC*)m_pTargetObject;
        PostThreadMessage(m_dwClientThreadID, WM_USER, m_tasknum, 0);
        WaitForSingleObject(m_hCompleteEvent, INFINITE);
        SpCleanupCallFrame(&pHR, this);

        if (pCallFrame) {
            if (bCFInOut && SUCCEEDED(*pHR))
                CopyMemory(pCallFrame, pTOS, ulCallFrameSize);
            AdjustStack(-(LONG)ulCallFrameSize);
        }
        return *pHR;
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\resetusr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by spuser.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\resetusr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	spuser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\src\tts\msprompteng\msscpctl.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: MSScriptControl */

#ifndef _msscptctl_H_
#define _msscptctl_H_

DEFINE_GUID(LIBID_MSScriptControl,0x0E59F1D2L,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/* Functions defined in module: ScriptControlConstants */
    const LPSTR GlobalModule = "Global";
    const long NoTimeout = -1;

typedef enum {
    Initialized = 0,
    Connected = 1
} ScriptControlStates;

DEFINE_GUID(IID_IScriptProcedure,0x70841C73L,0x067D,0x11D0,0x95,0xD8,0x00,0xA0,0x24,0x63,0xAB,0x28);

/* Definition of interface: IScriptProcedure */
#undef INTERFACE
#define INTERFACE IScriptProcedure

DECLARE_INTERFACE_(IScriptProcedure, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptProcedure methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_NumArgs)(THIS_ long FAR* pcArgs) PURE;
    STDMETHOD(get_HasReturnValue)(THIS_ VARIANT_BOOL FAR* pfHasReturnValue) PURE;
};

DEFINE_GUID(IID_IScriptProcedureCollection,0x70841C71L,0x067D,0x11D0,0x95,0xD8,0x00,0xA0,0x24,0x63,0xAB,0x28);

/* Definition of interface: IScriptProcedureCollection */
#undef INTERFACE
#define INTERFACE IScriptProcedureCollection

DECLARE_INTERFACE_(IScriptProcedureCollection, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptProcedureCollection methods */
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppenumProcedures) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT Index, IScriptProcedure FAR* FAR* ppdispProcedure) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* plCount) PURE;
};

DEFINE_GUID(IID_IScriptModule,0x70841C70L,0x067D,0x11D0,0x95,0xD8,0x00,0xA0,0x24,0x63,0xAB,0x28);

/* Definition of interface: IScriptModule */
#undef INTERFACE
#define INTERFACE IScriptModule

DECLARE_INTERFACE_(IScriptModule, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptModule methods */
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_CodeObject)(THIS_ IDispatch * FAR* ppdispObject) PURE;
    STDMETHOD(get_Procedures)(THIS_ IScriptProcedureCollection FAR* FAR* ppdispProcedures) PURE;
    STDMETHOD(AddCode)(THIS_ BSTR Code) PURE;
    STDMETHOD(Eval)(THIS_ BSTR Expression, VARIANT FAR* pvarResult) PURE;
    STDMETHOD(ExecuteStatement)(THIS_ BSTR Statement) PURE;
    STDMETHOD(Run)(THIS_ BSTR ProcedureName, SAFEARRAY FAR* FAR* Parameters, VARIANT FAR* pvarResult) PURE;
};

DEFINE_GUID(IID_IScriptModuleCollection,0x70841C6FL,0x067D,0x11D0,0x95,0xD8,0x00,0xA0,0x24,0x63,0xAB,0x28);

/* Definition of interface: IScriptModuleCollection */
#undef INTERFACE
#define INTERFACE IScriptModuleCollection

DECLARE_INTERFACE_(IScriptModuleCollection, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptModuleCollection methods */
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppenumContexts) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT Index, IScriptModule FAR* FAR* ppmod) PURE;
    STDMETHOD(get_Count)(THIS_ long FAR* plCount) PURE;
    STDMETHOD(Add)(THIS_ BSTR Name, VARIANT FAR* Object, IScriptModule FAR* FAR* ppmod) PURE;
};

DEFINE_GUID(IID_IScriptError,0x70841C78L,0x067D,0x11D0,0x95,0xD8,0x00,0xA0,0x24,0x63,0xAB,0x28);

/* Definition of interface: IScriptError */
#undef INTERFACE
#define INTERFACE IScriptError

DECLARE_INTERFACE_(IScriptError, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptError methods */
    STDMETHOD(get_Number)(THIS_ long FAR* plNumber) PURE;
    STDMETHOD(get_Source)(THIS_ BSTR FAR* pbstrSource) PURE;
    STDMETHOD(get_Description)(THIS_ BSTR FAR* pbstrDescription) PURE;
    STDMETHOD(get_HelpFile)(THIS_ BSTR FAR* pbstrHelpFile) PURE;
    STDMETHOD(get_HelpContext)(THIS_ long FAR* plHelpContext) PURE;
    STDMETHOD(get_Text)(THIS_ BSTR FAR* pbstrText) PURE;
    STDMETHOD(get_Line)(THIS_ long FAR* plLine) PURE;
    STDMETHOD(get_Column)(THIS_ long FAR* plColumn) PURE;
    STDMETHOD(Clear)(THIS) PURE;
};

DEFINE_GUID(IID_IScriptControl,0x0E59F1D3L,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

/* Definition of interface: IScriptControl */
#undef INTERFACE
#define INTERFACE IScriptControl

DECLARE_INTERFACE_(IScriptControl, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptControl methods */
    STDMETHOD(get_Language)(THIS_ BSTR FAR* pbstrLanguage) PURE;
    STDMETHOD(put_Language)(THIS_ BSTR bstrLanguage) PURE;
    STDMETHOD(get_State)(THIS_ ScriptControlStates FAR* pssState) PURE;
    STDMETHOD(put_State)(THIS_ ScriptControlStates ssState) PURE;
    STDMETHOD(put_SitehWnd)(THIS_ long hwnd) PURE;
    STDMETHOD(get_SitehWnd)(THIS_ long FAR* phwnd) PURE;
    STDMETHOD(get_Timeout)(THIS_ long FAR* plMilleseconds) PURE;
    STDMETHOD(put_Timeout)(THIS_ long lMilleseconds) PURE;
    STDMETHOD(get_AllowUI)(THIS_ VARIANT_BOOL FAR* pfAllowUI) PURE;
    STDMETHOD(put_AllowUI)(THIS_ VARIANT_BOOL fAllowUI) PURE;
    STDMETHOD(get_UseSafeSubset)(THIS_ VARIANT_BOOL FAR* pfUseSafeSubset) PURE;
    STDMETHOD(put_UseSafeSubset)(THIS_ VARIANT_BOOL fUseSafeSubset) PURE;
    STDMETHOD(get_Modules)(THIS_ IScriptModuleCollection FAR* FAR* ppmods) PURE;
    STDMETHOD(get_Error)(THIS_ IScriptError FAR* FAR* ppse) PURE;
    STDMETHOD(get_CodeObject)(THIS_ IDispatch * FAR* ppdispObject) PURE;
    STDMETHOD(get_Procedures)(THIS_ IScriptProcedureCollection FAR* FAR* ppdispProcedures) PURE;
    STDMETHOD(_AboutBox)(THIS) PURE;
    STDMETHOD(AddObject)(THIS_ BSTR Name, IDispatch * Object, VARIANT_BOOL AddMembers) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(AddCode)(THIS_ BSTR Code) PURE;
    STDMETHOD(Eval)(THIS_ BSTR Expression, VARIANT FAR* pvarResult) PURE;
    STDMETHOD(ExecuteStatement)(THIS_ BSTR Statement) PURE;
    STDMETHOD(Run)(THIS_ BSTR ProcedureName, SAFEARRAY FAR* FAR* Parameters, VARIANT FAR* pvarResult) PURE;
};

DEFINE_GUID(DIID_DScriptControlSource,0x8B167D60L,0x8605,0x11D0,0xAB,0xCB,0x00,0xA0,0xC9,0x0F,0xFF,0xC0);

/* Definition of dispatch interface: DScriptControlSource */
#undef INTERFACE
#define INTERFACE DScriptControlSource

DECLARE_INTERFACE_(DScriptControlSource, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* DScriptControlSource methods:
    void Error(void);
    void Timeout(void);
    */
};

DEFINE_GUID(CLSID_Procedure,0x0E59F1DAL,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class Procedure;
#endif

DEFINE_GUID(CLSID_Procedures,0x0E59F1DBL,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class Procedures;
#endif

DEFINE_GUID(CLSID_Module,0x0E59F1DCL,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class Module;
#endif

DEFINE_GUID(CLSID_Modules,0x0E59F1DDL,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class Modules;
#endif

DEFINE_GUID(CLSID_Error,0x0E59F1DEL,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class Error;
#endif

DEFINE_GUID(CLSID_ScriptControl,0x0E59F1D5L,0x1FBE,0x11D0,0x8F,0xF2,0x00,0xA0,0xD1,0x00,0x38,0xBC);

#ifdef __cplusplus
class ScriptControl;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\resetusr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <atlbase.h>
#include <sapi.h>
#include <sphelper.h>
#include <stdlib.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\spuser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by spuser.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\spuser\spuser.h ===
/****************************************************************************
*	spuser.h
*		<put description here>
*
*	Owner: cthrash
*	Copyright  1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

enum SearchOption_t
{
    eSearchByName,
    eSearchByLcid,
    eHelp,
    eNone
};

struct SearchArgument_t
{
    CSpDynamicString dstrName;
    LCID             lcid;
};

struct NameValuePair
{
    char *  pszName;
    LCID    lcid;
};

//--- Forward and External Declarations -------------------------------------

SearchOption_t  ParseCmdLine(LPSTR, SearchArgument_t *);
HRESULT         ShowDefaultUser();
HRESULT         SwitchDefaultUser(SearchOption_t, SearchArgument_t *);
void            ShowUserName(WCHAR * pszName);
HRESULT         Report(char * lpMsg, HRESULT hr);

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\spuser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	spuser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\spuser\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <atlbase.h>
#include <sapi.h>
#include <sphelper.h>
#include <stdlib.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\templates\class.h ===
/****************************************************************************
* <>
********************************************************************<>*/
class 
{
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\templates\function.cpp ===
/****************************************************************************
* *
*-----------------*
*   Description:  
*       <>
*
*   Return:
*   <>
********************************************************************<>*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\templates\template.cpp ===
/****************************************************************************
*   <>.cpp
*       <>
*
*   Owner: <>
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#include "stdafx.h"
#include ".h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\templates\template.h ===
/****************************************************************************
*   <>.h
*       <>
*
*   Owner: <>
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

//--- Forward and External Declarations -------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\spuser\spuser.cpp ===
/****************************************************************************
*
*	spuser.cpp
*
*       Dev applet to change the default speech user
*
*	Owner: cthrash
*	Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*
*****************************************************************************/

#include "stdafx.h"
#include "spuser.h"

/**********************************************************************
* main *
*------*
*
*	Description:
*
*       Main entry point.
*
* 	Return:
*
*       S_OK, E_INVALIDARG
*
************************************************************* cthrash */

BOOL g_fVerbose = FALSE;

int APIENTRY 
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    SearchArgument_t SearchArgument;
    SearchOption_t SearchOption = ParseCmdLine(lpCmdLine, &SearchArgument);
    HRESULT hr;

    if (SearchOption != eHelp)
    {
        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            if (SearchOption == eNone)
            {
                hr = ShowDefaultUser();
            }
            else
            {
                hr = SwitchDefaultUser(SearchOption, &SearchArgument);
            }
                
            CoUninitialize();
        }
    }
    else
    {
        hr = Report("Usage:\tspuser [-v] {user-name}\n"
                          "\tspuser [-v] -{local-id}\n"
                          "\tspuser -?\n",
                     E_INVALIDARG);
    }

	return (int)hr;
}

/**********************************************************************
* ParseCmdLine *
*--------------*
*
*	Description:
*
*       Parse the command line.  Argument can be a name, or a locale
*       specification preceeded by a dash.  Locale specifications can
*       be one of the stock names, or a a numeric LCID.
*
* 	Return:
*
*       One of the SearchOption_t enumerated types
*
************************************************************* cthrash */

const struct NameValuePair aNameValuePair[] = 
{
    { "ameng",      1033 },
    { "enu",        1033 },
    { "japanese",   1041 },
    { "jpn",        1041 },
    { "chs",        2051 }
};

SearchOption_t
ParseCmdLine(
    LPSTR pszCmdLine,
    SearchArgument_t *pSearchArgument)
{
    SearchOption_t SearchOption;

    if (*pszCmdLine)
    {
        // Check first for the 'verbose' option.
        
        if (0 == strnicmp(pszCmdLine, "-v", 2))
        {
            g_fVerbose = TRUE;
            for (pszCmdLine += 2;isspace((unsigned)(unsigned char)*pszCmdLine); pszCmdLine++);
        }

        // A dash means the user specified a locale.

        if (*pszCmdLine == '-')
        {
            if (pszCmdLine[1] == '?')
            {
                SearchOption = eHelp;
            }
            else
            {
                LCID lcid = 0;

                pszCmdLine++;

                // first check the names we recognize

                for (int i=sizeof(aNameValuePair) / sizeof(aNameValuePair[0]); i--;)
                {
                    if (0 == lstrcmpA(aNameValuePair[i].pszName, pszCmdLine))
                    {
                        lcid = aNameValuePair[i].lcid;
                        break;
                    }
                }

                // next see if it was specified numerically

                if (!lcid)
                {
                    lcid = atoi(pszCmdLine);
                }

                pSearchArgument->lcid = lcid;
                SearchOption = pSearchArgument->lcid ? eSearchByLcid : eHelp;
            }
        }
        else
        {
            USES_CONVERSION;

            pSearchArgument->dstrName = A2W(pszCmdLine);
            SearchOption = eSearchByName;
        }
    }
    else
    {
        SearchOption = eNone;
    }

    return SearchOption;
}

/**********************************************************************
* ShowDefaultUser *
*-----------------*
*
*	Description:
*
*       Show the default user's name.
*
* 	Return:
*
*       HRESULT
*
************************************************************* cthrash */

HRESULT
ShowDefaultUser()
{
    HRESULT hr;

    CComPtr<ISpObjectToken> cpToken;
    CSpDynamicString dstrName;

    hr = SpGetDefaultTokenFromCategoryId(SPCAT_SPEECHUSER, &cpToken);

    if (SUCCEEDED(hr))
    {
        hr = SpGetDescription(cpToken, &dstrName);
    }                

    if (SUCCEEDED(hr))
    {
        ShowUserName(dstrName);
    }
    
    return hr;
}

/**********************************************************************
* SwitchDefaultUser *
*-------------------*
*
*	Description:
*
*       Parse the command line.  Argument can be a name, or a locale
*       specification preceeded by a dash.  Locale specifications can
*       be one of the stock names, or a a numeric LCID.
*
* 	Return:
*
*       One of the SearchOption_t enumerated types
*
************************************************************* cthrash */

HRESULT
SwitchDefaultUser(
    SearchOption_t SearchOption,
    SearchArgument_t * pSearchArgument)
{
    HRESULT hr;
    CComPtr<IEnumSpObjectTokens> cpEnum;
    ULONG celtFetched;
    BOOL fFoundMatch = 0;
    CSpDynamicString dstrName;

    hr = SpEnumTokens(SPCAT_SPEECHUSER, NULL, NULL, &cpEnum);

    if (SUCCEEDED(hr))
    {
        hr = cpEnum->GetCount(&celtFetched);
    }

    while (!fFoundMatch && SUCCEEDED(hr))
    {
        ISpRegistryObjectToken *pRegToken = 0;
        CSpDynamicString dstrID;
        ISpUser * pSpUser = 0;

        hr = cpEnum->Next(1, (ISpObjectToken**)&pRegToken, &celtFetched);

        if (hr != S_OK)
        {
            break;
        }

        hr = pRegToken->GetId(&dstrID);

        if (SUCCEEDED(hr))
        {
            hr = pRegToken->CreateInstance(NULL, CLSCTX_INPROC_SERVER, IID_ISpUser, (void**)&pSpUser);
        }

        if (SUCCEEDED(hr))
        {
            BOOL fSwitch;
            CSpDynamicString dstrNameT;

            hr = SpGetDescription(pRegToken, &dstrNameT);

            switch (SearchOption)
            {
                case eSearchByName:
                    {
                        fSwitch = SUCCEEDED(hr) && (0 == wcsicmp(pSearchArgument->dstrName, dstrNameT));
                    }
                    break;

                case eSearchByLcid:
                    {
                        SPUSERINFO UserInfo;

                        hr = pSpUser->GetInfo(&UserInfo);

                        fSwitch = SUCCEEDED(hr) && (UserInfo.cLanguages > 0) && (UserInfo.aLanguage[0] == pSearchArgument->lcid);
                    }
                    break;

                default:
                    fSwitch = FALSE; // in case somebody adds an enum
                    break;
            }

            if (fSwitch)
            {
                dstrName = dstrNameT;
                
                if (SUCCEEDED(hr))
                {
                    hr = cpResMgr->SetDefault(pRegToken);
                }

                if (SUCCEEDED(hr))
                {
                    fFoundMatch = 1;
                }
            }
        }

        if (pSpUser)
        {
            pSpUser->Release();
        }

        if (pRegToken)
        {
            pRegToken->Release();
        }
    }

    hr = SUCCEEDED(hr) ? (fFoundMatch ? S_OK : E_INVALIDARG) : hr;
    
    if (FAILED(hr))
    {
        Report("Couldn't find an appropriate user", E_INVALIDARG);
    }
    else if (g_fVerbose)
    {
        ShowUserName(dstrName);
    }

    return hr;
}

void
ShowUserName(WCHAR * pszName)
{
    USES_CONVERSION;

    CSpDynamicString dstrOutput;

    dstrOutput = "Current default user: ";
    dstrOutput.Append(pszName);

    g_fVerbose = TRUE;

    Report(W2T(dstrOutput), S_FALSE);
}

/**********************************************************************
* Report *
*--------*
*
*	Description:
*
*       Show a message box, possibly indicating an error.
*
* 	Return:
*
*       The HRESULT passed in is returned, for the convenience of
*       the caller.
*
************************************************************* cthrash */

HRESULT Report(char * lpMsg, HRESULT hr)
{
    if (hr != S_OK || g_fVerbose)
    {
        const UINT uType = MB_OK | (FAILED(hr) ? MB_ICONERROR : MB_ICONINFORMATION);

        MessageBox(HWND_DESKTOP, lpMsg, "spuser.exe", uType);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tools\resetusr\resetusr.cpp ===
/****************************************************************************
*
*	resetusr.cpp
*
*       Dev applet to change the default speech user
*
*	Owner: cthrash
*	Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*
*****************************************************************************/

#include "stdafx.h"
#include "resetusr.h"

/**********************************************************************
* main *
*------*
*
*	Description:
*
*       Main entry point.
*
* 	Return:
*
*       S_OK, E_INVALIDARG
*
************************************************************* cthrash */

BOOL g_fVerbose = FALSE;

int APIENTRY 
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    char * pszUserName;
    BOOL fReset = ParseCmdLine(lpCmdLine, &pszUserName);
    HRESULT hr;

    if (fReset)
    {
        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            hr = ResetUser(pszUserName);
                
            CoUninitialize();
        }
    }
    else
    {
        hr = Report("Usage:\tresetusr [-v] [user-name]\n"
                          "\tresetusr [-v] -default\n"
                          "\tresetusr -?\n",
                     E_INVALIDARG);
    }

	return (int)hr;
}

/**********************************************************************
* ParseCmdLine *
*--------------*
*
*	Description:
*
*       Parse the command line.  Argument can be a name, or the string
*       -default.
*
* 	Return:
*
*       TRUE -- delete the user specified,
*       FALSE -- show usage info
*
************************************************************* cthrash */

BOOL
ParseCmdLine(
    char * pszCmdLine,      // [in] Command line arguments
    char ** ppszUserName)   // [out] 
{
    BOOL fReset = FALSE;

    while (*pszCmdLine)
    {
        if (0 == strnicmp(pszCmdLine, "-v", 2))
        {
            g_fVerbose = TRUE;
        }
        else
        {
            if (0 == strnicmp(pszCmdLine, "-default", 8))
            {
                *ppszUserName = NULL;
                fReset = TRUE;
            }
            else if (0 != strnicmp(pszCmdLine, "-?", 2))
            {
                *ppszUserName = pszCmdLine;
                fReset = TRUE;
            }
            else
            {
                fReset = FALSE;
            }
            
            break;
        }

        for (pszCmdLine += 2;isspace((unsigned)(unsigned char)*pszCmdLine); pszCmdLine++);
    }

    return fReset;
}

/*****************************************************************************
* ResetUser *
*-----------*
*
*   Description:    Reset a user's AM state.
*
*   Return:         HRESULT
*
***************************************************************** cthrash ***/

HRESULT 
ResetUser(
    char * pszName)       // [in] Name; NULL implies the default user
{
    HRESULT hr, hrReturn;
    CComPtr<ISpObjectToken> cpEngineToken;
    CComPtr<ISpObjectToken> cpUserToken;
    CComPtr<ISpDataKey> cpDataKey;
    CComPtr<ISpDataKey> cpSubDataKey;
    CSpDynamicString dstrEngineGUID;
    CSpDynamicString dstrReport;

    // Should we provide a mechanism to pick engine?  Currently we pick the default.
    hr = SpGetDefaultTokenFromCategoryId(SPCAT_RECOGNIZERS, &cpEngineToken);

    if (SUCCEEDED(hr))
    {
        hr = cpEngineToken->GetId(&dstrEngineGUID);
    }
    
    if (SUCCEEDED(hr))
    {
        const WCHAR * pch = wcsrchr(dstrEngineGUID, L'\\');

        if (pch)
        {
            pch++;
            memmove((WCHAR *)dstrEngineGUID, pch, sizeof(WCHAR) * (1 + wcslen(pch)));
        }
    }

    // Get the user token;
    if (!pszName)
    {
        if (SUCCEEDED(hr))
        {
            hr = SpGetDefaultTokenFromCategoryId(SPCAT_SPEECHUSER, &cpUserToken);
        }
    }
    else
    {
        BOOL fFoundMatch = FALSE;
        CComPtr<IEnumSpObjectTokens> cpEnum;
        ULONG celtFetched;
        CSpDynamicString dstrName = pszName;

        if (SUCCEEDED(hr))
        {
            hr = SpEnumTokens(SPCAT_SPEECHUSER, NULL, NULL, &cpEnum);
        }
        if(hr == S_FALSE)
        {
            hr = SPERR_NOT_FOUND;
        }

        if (SUCCEEDED(hr))
        {
            hr = cpEnum->GetCount(&celtFetched);
        }

        while (!fFoundMatch && SUCCEEDED(hr))
        {
            ISpRegistryObjectToken *pRegToken = 0;

            hr = cpEnum->Next(1, (ISpObjectToken**)&pRegToken, &celtFetched);

            if (hr != S_OK)
            {
                break;
            }

            if (SUCCEEDED(hr))
            {
                CSpDynamicString dstrNameT;

                hr = SpGetDescription(pRegToken, &dstrNameT);

                fFoundMatch = 0 == wcsicmp(dstrName, dstrNameT);
            }

            if (fFoundMatch)
            {
                cpUserToken = pRegToken;
            }

            if (pRegToken)
            {
                pRegToken->Release();
            }
        }
    }

    hrReturn = hr;
    
    if (SUCCEEDED(hr))
    {
        hr = cpUserToken->OpenKey(dstrEngineGUID, &cpDataKey);
        hrReturn = (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ? S_OK : hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = cpDataKey->OpenKey(L"files", &cpSubDataKey);
        hrReturn = (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ? S_OK : hr;
    }

    // Nuke all the files first.
    
    if (SUCCEEDED(hr))
    {
        ULONG iKey;

        for (iKey = 0; hr == S_OK; iKey++)
        {
            CSpDynamicString dstrFileType;
            CSpDynamicString dstrFilePath;
            
            hr = cpSubDataKey->EnumValues(iKey, &dstrFileType);

            if (SUCCEEDED(hr))
            {
                hr = cpSubDataKey->GetStringValue(dstrFileType, &dstrFilePath);
            }

            if (SUCCEEDED(hr))
            {
                USES_CONVERSION;
                
                hr = DeleteFile(W2T(dstrFilePath)) ? S_OK : HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

                if (g_fVerbose)
                {
                    dstrReport.Append(L"Deleting ");
                    dstrReport.Append2(dstrFilePath, SUCCEEDED(hr) ? L" -- Success\n" : L" -- Fail\n");
                }
            }
        }

        hrReturn = hr = (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr) ? S_OK : hr;
    }

    // Nuke the files key
    
    if (SUCCEEDED(hr))
    {
        cpSubDataKey.Release();

        hr = cpDataKey->DeleteKey(L"files");            

        if (g_fVerbose)
        {
            CSpDynamicString dstrID;

            cpUserToken->GetID(&dstrID);

            dstrReport.Append2(L"Deleting Key ", dstrID);
            dstrReport.Append2(L"\\", dstrEngineGUID);
            dstrReport.Append2(L"\\Files", SUCCEEDED(hr) ? L" -- Success\n" : L" -- Fail\n");
        }

        hrReturn = hr;
    }
    
    if (FAILED(hrReturn))
    {
        //Report("DataCouldn't find an appropriate user", E_INVALIDARG);
    }
    else if (g_fVerbose && dstrReport)
    {
        USES_CONVERSION;

        Report(W2A(dstrReport), hr);
    }

    return hrReturn;
}

/**********************************************************************
* Report *
*--------*
*
*	Description:
*
*       Show a message box, possibly indicating an error.
*
* 	Return:
*
*       The HRESULT passed in is returned, for the convenience of
*       the caller.
*
************************************************************* cthrash */

HRESULT Report(char * lpMsg, HRESULT hr)
{
    if (hr != S_OK || g_fVerbose)
    {
        const UINT uType = MB_OK | (FAILED(hr) ? MB_ICONERROR : MB_ICONINFORMATION);

        MessageBox(HWND_DESKTOP, lpMsg, "resetusr.exe", uType);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\fmtconvert\fmtconvert.cpp ===
/******************************************************************************
* CFmtConvert.cpp *
*-----------------*
*  Functions of CFmtConvert class.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 05/03/00
*  All Rights Reserved
*
********************************************************************** DING ***/

#include "FmtConvert.h"
#include "sigproc.h"
#include "vapiIo.h"
#include <math.h>
#include <assert.h>

/*****************************************************************************
* Constructor   *
*---------------*
*   Description:
*
********************************************************************* DING ***/
CFmtConvert::CFmtConvert(double dHalfFilterLen)
{
    m_fResetFilter = true; 
    m_pdFilterCoef = NULL;
    m_pdLeftMemory = NULL;
    m_pdRightMemory = NULL;
    m_dHalfFilterLen = dHalfFilterLen;
}

/*****************************************************************************
* Destructor    *
*---------------*
*   Description:
*
********************************************************************* DING ***/
CFmtConvert::~CFmtConvert()
{
    DeleteResamplingFilter();
    DeleteBuffers();
}

/*****************************************************************************
* SetInputFormat       *
*----------------------*
*   Description:
*
********************************************************************* DING ***/
void CFmtConvert::SetInputFormat(WAVEFORMATEX* pUserWavFormat)
{
    assert(pUserWavFormat);
    assert(pUserWavFormat->nSamplesPerSec > 0 );

    if ( pUserWavFormat )
    {
        m_InWavFormat = *pUserWavFormat;
        m_fResetFilter = true;
    }
}

/*****************************************************************************
* SetOutputFormat      *
*----------------------*
*   Description:
*
********************************************************************* DING ***/
void CFmtConvert::SetOutputFormat(WAVEFORMATEX* pUserWavFormat)
{
    assert(pUserWavFormat);

    if ( pUserWavFormat )
    {
        m_OutWavFormat = *pUserWavFormat;
        m_fResetFilter = true;
    }
}

/*****************************************************************************
* ConvertSamples       *
*----------------------*
*   Description:
*   first read samples into VAPI_PCM16, then judge cases : 
*   1. STEREO -> mono + resampling
*      STEREO  -> 1 mono -> reSampling
*   2. mono  -> STEREO + resampling
*      mono   -> reSampling -> STEREO
*   3. STEREO  -> STEREO + resampling
*      STEREO  -> 2 MONO - > reSampling -> 2 MONO -> STEREO
*   4. mono  -> mono + resampling
*      mono  -> reSampling -> mono
*
********************************************************************* DING ***/
HRESULT CFmtConvert::ConvertSamples(const void* pvInSamples, int iInSampleLen,
                                    void** ppvOutSamples, int* piOutSampleLen)
{
    short*    pnInSample = NULL;
    short*    pnOutSample = NULL;
    short     *pnBuff = NULL;
    short     *pnBuff2 = NULL;
    double    *pdBuff = NULL;
    double    *pdBuff1 = NULL;
    int       iLen;
    int       iNumSamples = iInSampleLen;
    int       iInFormatType;
    int       iOutFormatType;  
    HRESULT   hr = S_OK;
    
    assert( m_InWavFormat.nSamplesPerSec > 0 );
    assert( m_InWavFormat.nChannels <= 2 );
    assert( m_InWavFormat.nChannels > 0 );
    assert( m_OutWavFormat.nChannels > 0 );
    assert( m_OutWavFormat.nSamplesPerSec > 0 );
    assert( m_OutWavFormat.nChannels <= 2 );

    //--- need reset filter
    if (m_fResetFilter)
    {
        DeleteResamplingFilter();
        DeleteBuffers();
        if  ( m_InWavFormat.nSamplesPerSec != m_OutWavFormat.nSamplesPerSec )
        {
            hr = CreateResamplingFilter(m_InWavFormat.nSamplesPerSec, m_OutWavFormat.nSamplesPerSec);
            if (FAILED(hr))
            {
                return hr;
            }
            
            hr = CreateBuffers();
            if (FAILED(hr))
            {
                return hr;
            }
        }

        m_fResetFilter = false;
    }

    iInFormatType  = VapiIO::TypeOf (&m_InWavFormat);
    iOutFormatType = VapiIO::TypeOf (&m_OutWavFormat);    
    if ( iInFormatType < 0 || iOutFormatType < 0 )
    {
        return E_FAIL;
    }

    if ( m_OutWavFormat.nSamplesPerSec == m_InWavFormat.nSamplesPerSec && iOutFormatType == iInFormatType && m_OutWavFormat.nChannels == m_InWavFormat.nChannels )
    {
        *piOutSampleLen = iInSampleLen;
        if ( (*ppvOutSamples = (void *)new char [*piOutSampleLen * VapiIO::SizeOf(iOutFormatType)]) == NULL ) 
        {
            return E_OUTOFMEMORY;
        }
        memcpy((char*)(*ppvOutSamples), (char*)pvInSamples, (*piOutSampleLen) * VapiIO::SizeOf(iOutFormatType));
        return hr;
    }
        
    //--- Convert samples to VAPI_PCM16
    if ((pnInSample = new short [iNumSamples]) == NULL) 
    {
        return E_OUTOFMEMORY;
    }  
    VapiIO::DataFormatConversion ((char *)pvInSamples, iInFormatType, (char*)pnInSample, VAPI_PCM16, iNumSamples);
    
    //--- case 1
    if ( m_InWavFormat.nChannels == 2 && m_OutWavFormat.nChannels == 1 )
    {
        Stereo2Mono(pnInSample, &iNumSamples, &pnOutSample);
        delete[] pnInSample;

        if ( m_InWavFormat.nSamplesPerSec != m_OutWavFormat.nSamplesPerSec )
        {
            pdBuff1 = Short2Double (pnOutSample, iNumSamples);
            delete[] pnOutSample;
            if ( pdBuff1 == NULL )
            {
                return E_OUTOFMEMORY;        
            }

            //--- resample
            hr = Resampling(pdBuff1, iNumSamples, m_pdLeftMemory, &pdBuff, &iLen);
            if ( FAILED(hr) )
            {
                return hr;
            }
            delete[] pdBuff1;

            pnBuff = Double2Short (pdBuff, iLen);
            delete[] pdBuff;
            if ( pnBuff == NULL )
            {
                return E_OUTOFMEMORY;        
            }
            iNumSamples = iLen;
        }
        else
        {
            if ( (pnBuff = new short [iNumSamples]) == NULL ) 
            {
                return E_OUTOFMEMORY;
            }
            memcpy(pnBuff, pnOutSample, iNumSamples * sizeof(*pnInSample));
            delete[] pnOutSample;
        }
    }
    
    //--- case 2
    if ( m_InWavFormat.nChannels == 1 && m_OutWavFormat.nChannels == 2 )
    {
        //--- resampling
        if ( m_InWavFormat.nSamplesPerSec != m_OutWavFormat.nSamplesPerSec )
        {
            pdBuff1 = Short2Double (pnInSample, iNumSamples);
            delete[] pnInSample;
            if ( pdBuff1 == NULL )
            {
                return E_OUTOFMEMORY;        
            }
            
            //--- resample
            hr = Resampling(pdBuff1, iNumSamples, m_pdLeftMemory, &pdBuff, &iLen);
            if ( FAILED(hr) )
            {
                return hr;
            }
            delete[] pdBuff1;

            iNumSamples = iLen;
            pnInSample = Double2Short (pdBuff, iLen);
            delete[] pdBuff;
            if ( pnInSample == NULL )
            {
                return E_OUTOFMEMORY;        
            }
        }

        //--- mono -> stereo
        Mono2Stereo(pnInSample, &iNumSamples, &pnBuff);
        delete[] pnInSample;
    }
    
    //--- case 3
    if ( m_InWavFormat.nChannels == 2 && m_OutWavFormat.nChannels == 2 )
    {
        //--- resampling
        if ( m_InWavFormat.nSamplesPerSec != m_OutWavFormat.nSamplesPerSec )
        {
            SplitStereo(pnInSample, &iNumSamples, &pnBuff, &pnBuff2);
            delete[] pnInSample;

            // channel 1
            pdBuff1 = Short2Double (pnBuff, iNumSamples);
            delete[] pnBuff;
            if ( pdBuff1 == NULL )
            {
                return E_OUTOFMEMORY;        
            }
            //--- resample
            hr = Resampling(pdBuff1, iNumSamples, m_pdLeftMemory, &pdBuff, &iLen);
            if ( FAILED(hr) )
            {
                return hr;
            }
            delete[] pdBuff1;

            pnInSample = Double2Short (pdBuff, iLen);
            if ( pnInSample == NULL )
            {
                return E_OUTOFMEMORY;        
            }
            delete[] pdBuff;
            
            // channel 2
            pdBuff1 = Short2Double (pnBuff2, iNumSamples);
            delete[] pnBuff2;
            if ( pdBuff1 == NULL )
            {
                return E_OUTOFMEMORY;        
            }
            //--- resample
            hr = Resampling(pdBuff1, iNumSamples, m_pdRightMemory, &pdBuff, &iLen);
            if ( FAILED(hr) )
            {
                return hr;
            }
            delete[] pdBuff1;

            iNumSamples = iLen;
            pnOutSample = Double2Short (pdBuff, iNumSamples);
            if ( pnOutSample == NULL )
            {
                return E_OUTOFMEMORY;        
            }
            delete[] pdBuff;
            
            MergeStereo(pnInSample, pnOutSample, &iNumSamples, &pnBuff);
            delete[] pnInSample;
            delete[] pnOutSample;
        } 
        else
        {
            if ( (pnBuff = new short [iNumSamples]) == NULL ) 
            {
                return E_OUTOFMEMORY;
            }    
            memcpy(pnBuff, pnInSample, iNumSamples * sizeof(*pnBuff));
            delete[] pnInSample;
        }
    }
    
    //--- case 4
    if ( m_InWavFormat.nChannels == 1 && m_OutWavFormat.nChannels == 1 )
    {
        //--- resampling
        if ( m_InWavFormat.nSamplesPerSec != m_OutWavFormat.nSamplesPerSec )
        {
            pdBuff1 = Short2Double (pnInSample, iNumSamples);
            delete[] pnInSample;
            if ( pdBuff1 == NULL )
            {
                return E_OUTOFMEMORY;        
            }

            //--- resample
            hr = Resampling(pdBuff1, iNumSamples, m_pdLeftMemory, &pdBuff, &iLen);
            if ( FAILED(hr) )
            {
                return hr;
            }
            delete[] pdBuff1;

            iNumSamples = iLen;
            pnBuff = Double2Short (pdBuff, iLen);
            delete[] pdBuff;
            if ( pnBuff == NULL )
            {
                return E_OUTOFMEMORY;        
            }
        }
        else
        {
            if ( (pnBuff = new short [iNumSamples]) == NULL ) 
            {
                return E_OUTOFMEMORY;
            }    
            memcpy(pnBuff, pnInSample, iNumSamples * sizeof(*pnBuff));
            delete[] pnInSample;
        }
    }
    
    //--- output
    if ( iOutFormatType < 0 )
    {
        iOutFormatType = iInFormatType;
    }  
    *piOutSampleLen = iNumSamples;
    
    //---Convert samples to output format
    if ( (*ppvOutSamples = (void *) new char [iNumSamples * VapiIO::SizeOf(iOutFormatType)]) == NULL ) 
    {
        return E_OUTOFMEMORY;
    }
    VapiIO::DataFormatConversion((char*)pnBuff, VAPI_PCM16, (char*)*ppvOutSamples, iOutFormatType, iNumSamples);
    delete[] pnBuff;
    
    m_eChunkStatus = FMTCNVT_BLOCK;

    return hr;
}

/*****************************************************************************
* FlushLastBuff       *
*---------------------*
*   Description:
*
********************************************************************* DING ***/
HRESULT CFmtConvert::FlushLastBuff(void** ppvOutSamples, int* piOutSampleLen)
{
    short*    pnInSample = NULL;
    short*    pnOutSample = NULL;
    short     *pnBuff = NULL;
    double    *pdBuff1 = NULL;
    double    *pdBuff2 = NULL;
    int       iBuffLen;
    int       iOutFormatType = VapiIO::TypeOf (&m_OutWavFormat);
    HRESULT   hr = S_OK;

    assert( m_InWavFormat.nSamplesPerSec > 0 );
    assert( m_InWavFormat.nChannels <= 2 );
    assert( m_InWavFormat.nChannels > 0 );
    assert( m_OutWavFormat.nChannels > 0 );
    assert( m_OutWavFormat.nSamplesPerSec > 0 );
    assert( m_OutWavFormat.nChannels <= 2 );

    m_eChunkStatus = FMTCNVT_LAST;
    if ( m_InWavFormat.nSamplesPerSec != m_OutWavFormat.nSamplesPerSec )
    {
        if ( m_InWavFormat.nChannels == 2 && m_OutWavFormat.nChannels == 2 )
        {
            hr = Resampling(pdBuff1, 0, m_pdLeftMemory, &pdBuff1, &iBuffLen);
            if ( FAILED(hr) )
            {
                return hr;
            }
            hr = Resampling(pdBuff1, 0, m_pdRightMemory, &pdBuff2, &iBuffLen);
            if ( FAILED(hr) )
            {
                return hr;
            }
            
            pnInSample = Double2Short (pdBuff1, iBuffLen);
            if ( pnInSample == NULL )
            {
                return E_OUTOFMEMORY;        
            }
            delete[] pdBuff1;
            
            pnOutSample = Double2Short (pdBuff2, iBuffLen);
            if ( pnOutSample == NULL )
            {
                return E_OUTOFMEMORY;        
            }
            delete[] pdBuff2;
            
            MergeStereo(pnInSample, pnOutSample, &iBuffLen, &pnBuff);
            delete[] pnInSample;
            delete[] pnOutSample;
        }
        else 
        {
            hr = Resampling(pdBuff1, 0, m_pdLeftMemory, &pdBuff1, &iBuffLen);
            if ( FAILED(hr) )
            {
                return hr;
            }
 
            pnBuff = Double2Short (pdBuff1, iBuffLen);
            if ( pnBuff == NULL )
            {
                return E_OUTOFMEMORY;        
            }
            delete[] pdBuff1;

            if ( m_InWavFormat.nChannels == 1 && m_OutWavFormat.nChannels == 2 )
            {
                if ( (pnOutSample = new short [iBuffLen]) == NULL ) 
                {
                    return E_OUTOFMEMORY;
                }
                memcpy((char *)pnOutSample, (char *)pnBuff, iBuffLen * sizeof(*pnBuff));
                delete[] pnBuff;
                Mono2Stereo(pnOutSample, &iBuffLen, &pnBuff);
                delete[] pnOutSample;
            }
        }
        
        *piOutSampleLen = iBuffLen;
        
        //---Convert samples to output format
        if ( (*ppvOutSamples = (void *) new char [iBuffLen * VapiIO::SizeOf(iOutFormatType)]) == NULL ) 
        {
            return E_OUTOFMEMORY;
        }
        VapiIO::DataFormatConversion((char*)pnBuff, VAPI_PCM16, (char*)*ppvOutSamples, iOutFormatType, iBuffLen);
        delete[] pnBuff;
    }    
    return hr;
}

/*****************************************************************************
*  Short2Double        *
*----------------------*
*   Description:
*      convert short array to double array
*
********************************************************************* DING ***/
double* CFmtConvert::Short2Double (short* pnIn, int iLen)
{
    double* pdOut = NULL;

    if ( (pdOut = new double [iLen]) != NULL ) 
    {    
        for ( int i = 0; i < iLen; i++)
        {
            pdOut[i] =  (double)pnIn[i];
        }
    }

    return pdOut;
}

/*****************************************************************************
*  Double2Short        *
*----------------------*
*   Description:
*      convert double array to short array
*
********************************************************************* DING ***/
short* CFmtConvert::Double2Short (double* pdIn, int iLen)
{
    short* pnOut = NULL;

    if ( (pnOut = new short [iLen]) != NULL ) 
    {
        for ( int i = 0; i < iLen; i++)
        {
            pnOut[i] =  (short)(pdIn[i] + 0.5);
        }
    }    
    return pnOut;
}

/*****************************************************************************
*  Mono2Stereo         *
*----------------------*
*   Description:
*      convert mono speech to stereo speech
*
********************************************************************* DING ***/
HRESULT CFmtConvert::Mono2Stereo (short* pnInSample, int* piNumSamples, short** ppnOutSample)
{
    int      iLen;
    
    iLen = *piNumSamples;
    if ( (*ppnOutSample = new short [iLen * 2]) == NULL ) 
    {
        return E_OUTOFMEMORY;
    }

    int k = 0;
    for ( int i = 0; i < iLen; i++)
    {
        (*ppnOutSample)[k]     = pnInSample[i];
        (*ppnOutSample)[k + 1] = pnInSample[i];
        k +=2;
    }
    *piNumSamples = 2 * iLen;
    
    return S_OK;
}

/*****************************************************************************
*  Stereo2Mono         *
*----------------------*
*   Description:
*      convert stereo speech to mono speech
*
********************************************************************* DING ***/
HRESULT CFmtConvert::Stereo2Mono (short* pnInSample, int* piNumSamples, short** ppnOutSample)
{
    int       iLen = (*piNumSamples) / 2;
    
    if ( (*ppnOutSample = new short [iLen]) == NULL )  
    {
        return E_OUTOFMEMORY;
    }

    int k = 0;
    for ( int i = 0;i < *piNumSamples; i += 2)
    {
        (*ppnOutSample)[k++] =  (short)( (double)(pnInSample[i] + pnInSample[i + 1]) / 2.0 + 0.5);
    }
    *piNumSamples = iLen;
    
    return S_OK;
}

/*****************************************************************************
*  MergeStereo         *
*----------------------*
*   Description:
*      merge 2 channel signals into one signal
*
********************************************************************* DING ***/
HRESULT CFmtConvert::MergeStereo (short* pnLeftSamples, short* pnRightSamples, 
                                  int *piNumSamples, short** ppnOutSamples)
{
    int iLen = (*piNumSamples) * 2;
    
    if ( (*ppnOutSamples = new short [iLen]) == NULL ) 
    {
        return E_OUTOFMEMORY;
    }

    int k = 0;
    for ( int i = 0; i < *piNumSamples; i++)
    {
        (*ppnOutSamples)[k] = pnLeftSamples[i];
        (*ppnOutSamples)[k + 1] = pnRightSamples[i];
        k += 2;
    }
    *piNumSamples = iLen;
    
    return S_OK;
}

/*****************************************************************************
*  SplitStereo         *
*----------------------*
*   Description:
*      split stereo signals into 2 channel mono signals
*
********************************************************************* DING ***/
HRESULT CFmtConvert::SplitStereo (short* pnInSample, int* piNumSamples, 
                                  short** ppnLeftSamples, short** ppnRightSamples)
{
    int iLen = (*piNumSamples) / 2;
    
    if ( (*ppnLeftSamples = new short [iLen]) == NULL ) 
    {
        return E_OUTOFMEMORY;
    }
    if ( (*ppnRightSamples = new short [iLen]) == NULL ) 
    {
        return E_OUTOFMEMORY;
    }

    int k = 0;
    for ( int i = 0; i < *piNumSamples; i += 2)
    {
        (*ppnLeftSamples)[k]  = pnInSample[i];
        (*ppnRightSamples)[k] = pnInSample[i + 1];
        k++;
    }
    *piNumSamples = iLen;
    
    return S_OK;
}

/*****************************************************************************
* CreateResamplingFilter *
*------------------------*
*   Description:
*
******************************************************************* DING  ***/

HRESULT CFmtConvert::CreateResamplingFilter (int iInSampFreq, int iOutSampFreq)
{
    int iLimitFactor;

    assert (iInSampFreq > 0);
    assert (iOutSampFreq > 0);

    FindResampleFactors (iInSampFreq, iOutSampFreq);
    iLimitFactor = (m_iUpFactor > m_iDownFactor) ? m_iUpFactor : m_iDownFactor;

    m_iFilterHalf =  (int)(iInSampFreq * iLimitFactor * m_dHalfFilterLen);
    m_iFilterLen =  2 * m_iFilterHalf + 1;

    if ( !(m_pdFilterCoef = WindowedLowPass(.5 /  (double)iLimitFactor,  (double)m_iUpFactor))) 
    {        
        return E_FAIL;
    }

    return S_OK;
}

/*****************************************************************************
* DeleteResamplingFilter *
*------------------------*
*   Description:
*
******************************************************************* DING  ***/
void CFmtConvert::DeleteResamplingFilter()
{
    if ( m_pdFilterCoef )
    {
        delete[] m_pdFilterCoef;
        m_pdFilterCoef = NULL;
    }
}

/*****************************************************************************
* CreateBuffers  *
*----------------*
*   Description:
*
******************************************************************* DING  ***/
HRESULT CFmtConvert::CreateBuffers()
{

    assert(m_iUpFactor > 0);

    m_iBuffLen =  (int)( (double)m_iFilterLen /  (double)m_iUpFactor);

    if ( (m_pdLeftMemory = new double [m_iBuffLen]) == NULL ) 
    {
        return E_OUTOFMEMORY;
    }

    if ( (m_pdRightMemory = new double [m_iBuffLen]) == NULL ) 
    {
        return E_OUTOFMEMORY;
    }

    for ( int i = 0; i < m_iBuffLen; i++)
    {
        m_pdLeftMemory[i] = 0.0;
        m_pdRightMemory[i] = 0.0;
    }

    m_eChunkStatus = FMTCNVT_FIRST; // first chunk

    return S_OK;
}

/*****************************************************************************
* DeleteBuffers  *
*----------------*
*   Description:
*
******************************************************************* DING  ***/
void CFmtConvert::DeleteBuffers()
{
    if ( m_pdLeftMemory )
    {
        delete[] m_pdLeftMemory;
        m_pdLeftMemory = NULL;
    }

    if ( m_pdRightMemory )
    {
        delete[] m_pdRightMemory;
        m_pdRightMemory = NULL;
    }
}

/*****************************************************************************
* WindowedLowPass *
*-----------------*
*   Description:
*       Creates a low pass filter using the windowing method.
*       dCutOff is spec. in normalized frequency
******************************************************************* DING  ***/
double* CFmtConvert::WindowedLowPass  (double dCutOff, double dGain)
{
    double* pdCoeffs = NULL;
    double* pdWindow = NULL;
    double  dArg;
    double  dSinc;
  
    assert (dCutOff>0.0 && dCutOff<0.5);

    pdWindow = ComputeWindow(WINDOW_BLACK, m_iFilterLen, true);
    if (!pdWindow)
    {
        return NULL;
    }

    pdCoeffs = new double[m_iFilterLen];

    if (pdCoeffs) 
    {
        dArg = 2.0 * M_PI * dCutOff;
        pdCoeffs[m_iFilterHalf] =  (double)(dGain * 2.0 * dCutOff);

        for (long i = 1; i <= m_iFilterHalf; i++) 
        {
            dSinc = dGain * sin(dArg * i) / (M_PI * i) * pdWindow[m_iFilterHalf- i];
            pdCoeffs[m_iFilterHalf+i] =  (double)dSinc;
            pdCoeffs[m_iFilterHalf-i] =  (double)dSinc;
        }   
    }

    delete[] pdWindow;

    return pdCoeffs;
}

/*****************************************************************************
* FindResampleFactors *
*---------------------*
*   Description:
*
******************************************************************* DING  ***/
void CFmtConvert::FindResampleFactors  (int iInSampFreq, int iOutSampFreq)
{
    static int  piPrimes[] = {2,3,5,7,11,13,17,19,23,29,31,37};
    static int  iPrimesLen = sizeof (piPrimes) / sizeof (piPrimes[0]);
    int         iDiv = 1;
    int         i;

    while (iDiv) 
    {
        iDiv = 0;
        for (i = 0; i < iPrimesLen; i++) 
        {
            if ( (iInSampFreq % piPrimes[i]) == 0 && (iOutSampFreq % piPrimes[i]) == 0 )
            {
                iInSampFreq /= piPrimes[i];
                iOutSampFreq /= piPrimes[i];
                iDiv = 1;
                break;
            }
        }   
    }

    m_iUpFactor = iOutSampFreq;
    m_iDownFactor = iInSampFreq;
}


/*****************************************************************************
* Resampling *
*------------*
*   Description:
*
******************************************************************* DING  ***/
HRESULT CFmtConvert::Resampling  (double* pdInSamples, int iInNumSamples, double *pdMemory, 
                                  double** ppdOutSamples, int* piOutNumSamples)
{
    int     iPhase;
    double  dAcum;
    int     j;
    int     n;
    int     iAddHalf;

    if(m_eChunkStatus == FMTCNVT_FIRST) 
    {
        *piOutNumSamples = (iInNumSamples * m_iUpFactor - m_iFilterHalf) / m_iDownFactor;
        iAddHalf = 1;
    } 
    else if(m_eChunkStatus == FMTCNVT_BLOCK) 
    {
        *piOutNumSamples = (iInNumSamples * m_iUpFactor) / m_iDownFactor;
        iAddHalf = 2;
    } 
    else if(m_eChunkStatus == FMTCNVT_LAST) 
    {
        *piOutNumSamples = (m_iFilterHalf * m_iUpFactor) / m_iDownFactor;
        iAddHalf = 2;
    }

    *ppdOutSamples = new double[*piOutNumSamples];
    if (*ppdOutSamples == NULL) 
    {
        return E_FAIL;
    }

    for  (int i = 0; i < *piOutNumSamples; i++) 
    {
        dAcum = 0.0;

        n =  (int)((i * m_iDownFactor - iAddHalf * m_iFilterHalf) /  (double)m_iUpFactor);
        iPhase = (i * m_iDownFactor) - ( n * m_iUpFactor + iAddHalf * m_iFilterHalf);
    
        for ( j = 0; j < m_iFilterLen / m_iUpFactor; j++) 
        {
            if (m_iUpFactor * j > iPhase)
            {
                if ( n + j >= 0 && n + j < iInNumSamples)
                {
                    dAcum += pdInSamples[n + j] * m_pdFilterCoef[m_iUpFactor * j - iPhase];
                } 
                else if ( n + j < 0 )
                {
                    dAcum += pdMemory[m_iBuffLen + n + j] * m_pdFilterCoef[m_iUpFactor * j - iPhase];
                } 
            }
        }

        (*ppdOutSamples)[i] = dAcum;
    }

    //--- store samples into buffer
    if(m_eChunkStatus != FMTCNVT_LAST)
    {
        for (n = 0, i = 0; i < m_iBuffLen; i++)
        {
            if (i + iInNumSamples >= m_iBuffLen)
            {
                pdMemory[i] = pdInSamples[n++];
            }
            else
            {
                pdMemory[i] = 0.0;
            }
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\sigproc\bispectrum.cpp ===
/******************************************************************************
* bispectrum.cpp *
*----------------*
*  I/O library functions for extended speech files (vapi format)
*------------------------------------------------------------------------------
*  Copyright (C) 1999  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "sigprocInt.h"


enum {WINDOW_OPTIMUM, WINDOW_PARZEN};
#define UNACCESS       1.0e08  // a big value used in unaccess initialization


class Double2D
{
    public:
        Double2D (int dim) {
            m_iSize = dim;

            m_ppdData = new double*[m_iSize];
            m_ppdData[0] = new double[m_iSize * m_iSize];
            for (int i = 1; i< m_iSize; i++) 
            {
                m_ppdData[i] = m_ppdData[0]+ i * m_iSize;
            }
        }

        ~Double2D() {
            delete[] m_ppdData[0];
            delete[] m_ppdData;            
        }

        Double2D& operator=(Double2D& orig)
        {
            if (m_ppdData) {
                delete[] m_ppdData[0];
                delete[] m_ppdData;
            }

            m_iSize = orig.m_iSize;
            m_ppdData = new double* [m_iSize];
            m_ppdData[0] = new double[m_iSize * m_iSize];
            memcpy(m_ppdData, orig.m_ppdData, sizeof(double)* m_iSize * m_iSize);

            for (int i = 1; i< m_iSize; i++) 
            {
                m_ppdData[i] = m_ppdData[0]+ i * m_iSize;
            }
            return (*this);
        }

        double& Element(int a, int b) 
        {
            return m_ppdData[a][b];
        };

        int Size(){
            return m_iSize;
        }

    private:
        double** m_ppdData;
        int m_iSize;
};


static struct _complex** 
GetBispectrumSeg(double *data, int nData, int nSeg, int L, int winType, double *workReal, double *workImag);
static struct _complex** Alloc2DimComplex(int dim);

static Double2D Get3rdMomentSeqLong (double *data, int N, int M, int L);
static double   Get3rdMomentSeq (int i, int j, int inDataLen, double *data);
static Double2D Get2DimWin (int len, int winType);
static double*  GetParzenWin (int length);
static double*  GetOptimumWin (int length);




/*
 *-----------------------------------------------------------------------------
 *
 * Optimum window (minimum bispectrm bias supremum) used for
 * bispectrum estimation (indirect method)
 * Note : the window length is 2 * len + 1, but output [0, 2 *length]
 *        because of [-len, len]
 *
 *-----------------------------------------------------------------------------
 */
double* GetOptimumWin (int length)
{
    double* x;
    int i;

    x = new double[2 * length + 1];

    if (x) 
    {

        for (i=-length; i<=length; i++) 
        {
            x[i + length] = 1.0 / M_PI * fabs(sin(M_PI * (double)i / (double)length))
                + (1.0 - fabs((double)i)/length)*(cos(M_PI * (double)i / (double)length));
        }
    }

    return x;
}

/*
 *-----------------------------------------------------------------------------
 *
 * Parzen window used for bispectrum estimation (indirect method)
 * Note : the window length is 2 * len + 1, the output size is [0, 2 *length]
 *        from [-len, len]
 *
 *-----------------------------------------------------------------------------
 */
double* GetParzenWin (int length)
{
    double* x;
    double  d;
    int i;

    x = new double [2 * length + 1];

    if (x) 
    {
        for (i=-length; i<=length; i++) 
        {
            if (abs(i) <= length/2) 
            {
                d = fabs((double)i/(double)length);

                x[i + length] = 1.0 - 6.0 * d * d + 6.0 * d * d * d;
            } 
            else 
            {
                x[i + length] = 2.0 * (1.0 - fabs((double)i * i * i) / length);
            }
        }
    }

    return x;
}


/*
 *-----------------------------------------------------------------------------
 *
 * Get a 2-dim window used for
 * bispectrum estimation (indirect method)
 * Note : the output matrix is [2 * len + 1] x [2 * len + 1]
 *        corresponding to [-len, len] x [-len, len]
 *
 *-----------------------------------------------------------------------------
 */
Double2D Get2DimWin (int len, int winType)
{
    double*  winData = NULL;
    int i;
    int j;
    int newLen;

    assert(len > 0);

    newLen = 2*len + 1;
    Double2D x(newLen);

    switch(winType) 
    {
    case WINDOW_OPTIMUM:
        winData = GetOptimumWin(len);
        break;
    case WINDOW_PARZEN:
        winData = GetParzenWin(len);
        break;
    default:
        break;
    }

    if (winData)
    {
        for (i=0; i<newLen; i++) 
        {
            for (j=0; j<newLen; j++) 
            {
                if(i >= j) 
                {
                    x.Element(i,j) = winData[i] * winData[j] * winData[i - j];
                } 
                else 
                {
                    x.Element(i,j) = winData[i] * winData[j] * winData[j - i];
                }
            }
        }
    }

    delete[] winData;

    return x;
}

/*
 *-----------------------------------------------------------------------------
 *
 * Get a 3rd moment sequence for a single segment
 *
 *-----------------------------------------------------------------------------
 */
static double
Get3rdMomentSeq (int i, int j, int inDataLen, double *data)
{
  double d;
  int m;
  int s1;
  int s2;
  
  s1 = __max(0, -i);
  s1 = __max(s1, -j);
  s2 = __min(inDataLen-1, inDataLen-1-i);
  s2 = __min(s2, inDataLen-1-j);
  d = (double)0.0;
  for(m = s1; m <= s2; m++) {
    d += data[m] * data[m+i] * data[m+j];
  }
  d /= (double)inDataLen;

  return d;
}

/*
 *-----------------------------------------------------------------------------
 *
 * Get a 3rd moment sequence for a long segment
 * Note : - the output matrix is [2 * len + 1] x [2 * len + 1]
 *          corresponding to [-len, len] x [-len, len]
 *        - N is divided into N = K * M; each segemnt has M records
 *        - L < M - 1;
 *
 *-----------------------------------------------------------------------------
 */
Double2D Get3rdMomentSeqLong (double *data, int N, int M, int L)
{
    int K;
    int i;
    int m;
    int n;

    assert(N > 0);
    assert(M > 0);
    assert(data);

    RemoveDc (data, N);

    if (N % M != 0 || L > M-2) 
    {
        fprintf(stderr, "%s\n", "Error in data segmentation.");
        return 0;
    }
    K = N / M;

    Double2D x(2*L + 1);

    for (m = -L; m <=L; m++) 
    {
        for (n = -L; n <=L; n++) 
        {
            x.Element(m+L, n+L) = UNACCESS;
        }
    }

    for (m = -L; m <=L; m++) 
    {
        for (n = -L; n <=L; n++) 
        {
        /*
         * judge if I could use symmetric properties
         */
            if (x.Element(n+L, m+L) != UNACCESS) 
            {
                x.Element(m+L, n+L) = x.Element(n+L, m+L);
                continue;  
            }

            if (m-n>=-L && m-n <=L && x.Element(-n+L, m-n+L) != UNACCESS) 
            {
                x.Element(m+L, n+L) = x.Element(-n+L, m-n+L);
                continue;  
            }

            if (n-m>=-L && n-m <=L && x.Element(n-m+L, -m+L) != UNACCESS) 
            {
                x.Element(m+L, n+L) = x.Element(n-m+L, -m+L);
                continue;  
            }

            if (m-n>=-L && m-n <=L && x.Element(m-n+L, -n+L) != UNACCESS) 
            {
                x.Element(m+L, n+L) = x.Element(m-n+L, -n+L);
                continue;  
            }

            if (n-m>=-L && n-m <=L && x.Element(m+L, n-m+L) != UNACCESS) 
            {
                x.Element(m+L, n+L) = x.Element(m+L, n-m+L);
                continue;  
            }
            
            /*
             * otherwise compute the value
             */

            x.Element(m+L, n+L) = 0.0;
            for (i = 0; i < K; i++) 
            {
                x.Element(m+L, n+L) += Get3rdMomentSeq (m, n, M, &data[i*M]);
            }
            x.Element(m+L, n+L) /= (double)K;
        }
    }
    
    return x;
}

/*
 *-----------------------------------------------------------------------------
 *
 * alloc memory for 2-D _complex
 * 
 *-----------------------------------------------------------------------------
 */
static struct _complex** 
Alloc2DimComplex(int dim)
{
  struct _complex  **r = NULL;
  int i;

  r = (struct _complex **)malloc(sizeof(struct _complex*) * dim);
  if(!r) {
    fprintf(stderr, "%s\n", "Error in memory allocation.");
    return NULL;
  }

  r[0] = (struct _complex*) malloc (sizeof(struct _complex) * dim * dim);
  if(!r[0]) {
    fprintf(stderr, "%s\n", "Error in memory allocation.");
    return NULL;
  }

  for (i = 1; i < dim; i++) {
    r[i] = r[0] + i*dim;
  }
  return(r);
}


/*
 *-----------------------------------------------------------------------------
 *
 * Get bispectrum estimation for one segment
 * Note : - the output matrix is [2 * len + 1] x [2 * len + 1]
 *          corresponding to [-len, len] x [-len, len]
 *        - N is divided into N = K * nSeg; each segemnt has nSeg records
 *        - L < nSeg - 1, L = nSeg - 2;
 *        - bispectrum length is 2*L+1
 *
 *-----------------------------------------------------------------------------
 */
struct _complex** 
GetBispectrumSeg(double *data, int nData, int nSeg, int L, int winType, double *workReal, double *workImag)
{
    struct _complex** x = NULL;
    register i;
    register j;
    int temp;
    register m;
    register n;
    int K;

    assert(data);
    
    temp = 2*L*L;
  
    Double2D winData = Get2DimWin (L, winType);

    if (nData % nSeg != 0) 
    {
        fprintf(stderr, "%s\n", "Error in data segmentation.");
        return x;
    }

    K = nData / nSeg;

    Double2D& r = Get3rdMomentSeqLong (data, nData, nSeg, L);

    for (m = -L; m <= L; m++) 
    {
        for(n = -L; n <= L; n++) 
        {
            r.Element(m+L, n+L) *= winData.Element(m+L, n+L);
        }
    }


    x = Alloc2DimComplex(2*L + 1);

    for(i = -L; i <= L; i++) {
        for(j = -L; j <= L; j++) {
            x[i+L][j+L].x = UNACCESS;
        }
    }
    for(i = -L; i <= L; i++) {
        for(j = -L; j <= L; j++) {
           /*
            * judge if I could use symetric properties
            */
            if(x[j+L][i+L].x != UNACCESS) {
                x[i+L][j+L] = x[j+L][i+L];
                continue;  
            }
            if(x[-j+L][-i+L].x != UNACCESS) {
                x[i+L][j+L] = x[-j+L][-i+L];
                continue;  
            }
            if(-i-j>=-L && -i-j <=L && x[-i-j+L][j+L].x != UNACCESS) {
                x[i+L][j+L] = x[-i-j+L][j+L];
                continue;  
            }
            if(-i-j>=-L && -i-j <=L && x[i+L][-i-j+L].x != UNACCESS) {
                x[i+L][j+L] = x[i+L][-i-j+L];
                continue;  
            }
            if(-i-j>=-L && -i-j <=L && x[-i-j+L][i+L].x != UNACCESS) {
                x[i+L][j+L] = x[-i-j+L][i+L];
                continue;  
            }
            if(-i-j>=-L && -i-j <=L && x[j+L][-i-j+L].x != UNACCESS) {
                x[i+L][j+L] = x[j+L][-i-j+L];
                continue;  
            }
      
            /*
             * otherwise, compute the value
             */
      
            x[i+L][j+L].x = 0.0;
            x[i+L][j+L].y = 0.0;
            for(m = -L; m <= L; m++) {
                for(n = -L; n <= L; n++) {
                    x[i+L][j+L].x += r.Element(m+L, n+L) * workReal[i*m + j*n + temp];
                    x[i+L][j+L].y += r.Element(m+L, n+L) * workImag[i*m + j*n + temp];
                }
            }
            //      printf("\15bispectrum processing ... %.2f%%   %.2f%% -> ", (double)(i+L) / (double)(2*L +1) * 100.0, 
            //        (double)(j+L) / (double)(2*L +1) * 100.0);
        }
        printf("\15bispectrum processing ... %.2f%%   ->", (double)(i+L) / (double)(2*L +1) * 100.0);
    }

    return x;
}


/*
 *-----------------------------------------------------------------------------
 *
 * Get bispectrum estimation for speech data
 * Note : 
 *        - nLenMs is length of speech in ms
 *        - nSpec is the length of bispectrum
 *        - num is number of output bispectrum
 *
 *-----------------------------------------------------------------------------
 */
struct _complex*** 
GetBispectrum(double *data, int nLenMs, int frameMs, int segMs, 
              int specOrder, double sf, int *num, int *nSpec)
{
  struct _complex*** x = NULL;
  double *extData = NULL;
  double *workReal = NULL;
  double *workImag = NULL;
  double d;
  int newDataLen;
  int i;
  int nData;
  int nWin;
  int nSeg;
  int L;

  assert(data);

  nData = (int)(nLenMs * sf / 1000.0);
  nWin = (int)(frameMs * sf / 1000.0);
  nSeg = (int)(segMs * sf / 1000.0);

  *num = nData / nWin;
  if(nData % nWin != 0) {
    *num += 1;
  }
  newDataLen = nWin * (*num);

  L = specOrder;
  *nSpec = 2*L + 1;

  /*
   * Add zero up to reqired length
   */

  extData = (double *)malloc(sizeof(*extData) * newDataLen);
  if(!extData) {
    fprintf(stderr, "%s\n", "Error in memory allocation.");
    return NULL;
  }

  for(i=0; i<newDataLen; i++){
    if(i < nData) {
      extData[i] = data[i];
    } else {
      extData[i] = 0.0;
    }
  }

  /*
   * work variables used for speed up
   */
  workReal = (double *)malloc(sizeof(*workReal) * (4 * L * L +1));
  if(!workReal) {
    fprintf(stderr, "%s\n", "Error in memory allocation.");
    return NULL;
  }

  workImag = (double *)malloc(sizeof(*workImag) * (4 * L * L +1));
  if(!workImag) {
    fprintf(stderr, "%s\n", "Error in memory allocation.");
    return NULL;
  }

  for(i=-2* L * L; i<=2* L * L; i++) {
    d = M_PI * ((double)i / (double)L);
    workReal[i+2* L * L] = cos(d);
    workImag[i+2* L * L] = -sin(d);
  }

  /*
   * get bispectrum
   */
  x  = (struct _complex ***)malloc(sizeof(struct _complex**) * (*num));
  if(!x) {
    fprintf(stderr, "%s\n", "Error in memory allocation.");
    return NULL;
  }
  for (i=0; i<*num; i++) {
    printf("\15bispectrum processing ...                     %.2f%%", (double)i / (double)(*num) * 100.0);
    x[i] = GetBispectrumSeg(&extData[i*nWin], nWin, nSeg, L, WINDOW_OPTIMUM,
      workReal, workImag);
  }
  printf("\15bispectrum processing ...                     %.2f%%\n", 100.0);

  if(extData) {
    free(extData);
  }
  if(workReal) {
    free(workReal);
  }
  if(workImag) {
    free(workImag);
  }

  return x;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\localttsenginesite\localttsenginesite.cpp ===
/////////////////////////////////////////////////////////////////////////////
// LocalTTSEngineSite.cpp: implementation of the CLocalTTSEngineSite class.
//
// Created by JOEM  02-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
//////////////////////////////////////////////////////////// JOEM  02-2000 //

#include "LocalTTSEngineSite.h"
#include <LIMITS>
#include <spddkhlp.h>
#include "vapiIO.h"

// If buffer is used, the min size is one sec
const int       g_iMinBufferSize    = 1;
const int       g_iMaxBufferSize    = 60; // let's keep it reasonable, ok!
const float     g_dMinBufferShift   = .25;
const double    g_dChunkSize        = .10;
const int       g_iBase             = 16;

// Default duration of chunks written from buffer to SAPI

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite
//
// Construction/Destruction
//
//////////////////////////////////////////////////////////// JOEM  02-2000 //
CLocalTTSEngineSite::CLocalTTSEngineSite()
{
    m_vcRef                      = 1;
    m_pMainOutputSite           = NULL;
    m_pOutputFormatId           = NULL;
    m_pOutputFormat             = NULL;

    m_pcBuffer                  = NULL;
    m_ulBufferBytes             = 0;
    m_ulBufferSeconds           = 0;
    m_ulMinBufferShift          = 0;
    m_ulDataEnd                 = 0;
    m_ulCurrentByte             = 0;
    m_ulSkipForward             = 0;

    m_pEventQueue               = NULL;
    m_pCurrentEvent             = NULL;
    m_pLastEvent                = NULL;

    m_ullTotalBytesReceived     = 0;
    m_ullPreviousBytesReceived  = 0;
    m_ullBytesWritten           = 0;
    m_ullBytesWrittenToSAPI     = 0;
    m_lTotalBytesSkipped        = 0;

    m_pTsm                      = NULL;
    m_flRateAdj                 = 1.0; // Regular rate unless user changes it.
    m_flVol                     = 1.0; // Full volume unless user changes it.
}

CLocalTTSEngineSite::~CLocalTTSEngineSite()
{
    m_pMainOutputSite   = NULL;

    if ( m_pOutputFormat )
    {
        free( m_pOutputFormat );
        m_pOutputFormat = NULL;
        m_pOutputFormatId = NULL;
    }

    Event* pEvent       = m_pEventQueue;
    Event* pNextEvent   = NULL;
    while ( pEvent )
    {
        pNextEvent = pEvent->pNext;
        delete pEvent;
        pEvent = pNextEvent;
    }

    if ( m_pcBuffer )
    {
        delete [] m_pcBuffer;
        m_pcBuffer = NULL;
    }

    if ( m_pTsm )
    {
        delete m_pTsm;
        m_pTsm = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::QueryInterface
//
//
//////////////////////////////////////////////////////////// JOEM  02-2000 //
STDMETHODIMP CLocalTTSEngineSite::QueryInterface ( REFIID iid, void** ppv )
{
    if ( iid == IID_ISpTTSEngineSite )
    {
        *ppv = (ISpTTSEngineSite*) this;
    }
    else if ( iid == IID_ISpTTSEngineSite )
    {
        *ppv = (ISpTTSEngineSite*) this;
    }
    else if ( iid == IID_ISpEventSink )
    {
        *ppv = (ISpEventSink*) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::AddRef
//////////////////////////////////////////////////////////// JOEM  02-2000 //
ULONG CLocalTTSEngineSite::AddRef(void)
{
    return InterlockedIncrement(&m_vcRef);
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::Release
//////////////////////////////////////////////////////////// JOEM  02-2000 //
ULONG CLocalTTSEngineSite::Release(void)
{
    if ( 0 == InterlockedDecrement(&m_vcRef) )
    {
        delete this;
        return 0;
    }

    return (ULONG) m_vcRef;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::SetOutputSite
//
// Sets pointer to main SAPI output site.
// Sets/resets data buffer and accumulators to zero.
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
void CLocalTTSEngineSite::SetOutputSite(ISpTTSEngineSite* pOutputSite)
{ 
    SPDBG_FUNC( "CLocalTTSEngineSite::SetOutputSite" );

    SPDBG_ASSERT(pOutputSite);

    m_pMainOutputSite           = pOutputSite; 

    // flush the buffer
    m_ulCurrentByte         = 0;
    m_ulDataEnd             = 0;
    m_ulSkipForward         = 0;
    memset( m_pcBuffer, 0, m_ulBufferBytes * sizeof(char) );

    // flush the event queue and start over
    Event* pEvent       = m_pEventQueue;
    Event* pNextEvent   = NULL;
    while ( pEvent )
    {
        pNextEvent = pEvent->pNext;
        delete pEvent;
        pEvent = pNextEvent;
    }
    m_pEventQueue       = NULL;
    m_pCurrentEvent     = NULL;
    m_pLastEvent        = NULL;

    // reset counters
    m_ullTotalBytesReceived     = 0;
    m_ullPreviousBytesReceived  = 0;
    m_ullBytesWritten           = 0;
    m_ullBytesWrittenToSAPI     = 0; 
    m_lTotalBytesSkipped        = 0;

    m_flRateAdj                 = 1.0; // Regular rate unless user changes it.
    m_flVol                     = 1.0; // Full volume unless user changes it.
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::SetBufferSize
//
// Sets the size of the audio data buffer, and creates the buffer if the
// output format is known (but Text output is not buffered).
//
// **Destroys contents of existing buffer.**  That's ok, because this function
// is not exposed to the application -- just to the engine, where speak calls
// are synchronous.
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
STDMETHODIMP CLocalTTSEngineSite::SetBufferSize(const ULONG ulSeconds)
{
    SPDBG_FUNC( "CLocalTTSEngineSite::SetBufferSize" );
    HRESULT hr = S_OK;

    // don't need to preserve contents of old buffer -- it's flushed between
    // speak calls anyway.
    if ( m_pcBuffer )
    {
        delete [] m_pcBuffer;
        m_pcBuffer = NULL;
    }
    m_ulBufferBytes     = 0;
    m_ulBufferSeconds   = 0;
    m_ulMinBufferShift  = 0;
    m_ulDataEnd         = 0;
    m_ulCurrentByte     = 0;

    if ( ulSeconds )
    {
        if ( ulSeconds < g_iMinBufferSize )
        {
            m_ulBufferSeconds = g_iMinBufferSize;
        }
        else if ( ulSeconds > g_iMaxBufferSize )
        {
            m_ulBufferSeconds = g_iMaxBufferSize;
        }
        else
        {
            m_ulBufferSeconds = ulSeconds;
        }

        // check format -- don't set a buffer for text format
        if ( m_pOutputFormatId )
        {
            if ( *m_pOutputFormatId != SPDFID_Text )
            {
                // if the wav format is defined, allocate the buffer for the correct #secs of data
                if ( m_pOutputFormat )
                {
                    m_ulBufferBytes = m_ulBufferSeconds * m_pOutputFormat->nAvgBytesPerSec;
                    
                    m_pcBuffer = new char[m_ulBufferBytes];
                    if ( !m_pcBuffer )
                    {
                        m_ulBufferBytes = 0;
                        m_ulBufferSeconds = 0;
                        hr = E_OUTOFMEMORY;
                    }

                    if ( SUCCEEDED(hr) )
                    {
                        // Make the min shift approximately 1/4 of buffer
                        // When the buffer is full, data shifts off the end by this amount.
                        m_ulMinBufferShift  = g_dMinBufferShift * m_ulBufferBytes;
                        // data must shift by multiples of nBlockAlign
                        m_ulMinBufferShift -= ( m_ulMinBufferShift % m_pOutputFormat->nBlockAlign );
                    }
                }
            }
            else
            {
                m_ulBufferSeconds = 0; // can't buffer text - but not an error(?)
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::SetOutputFormat
//
// Sets the format in which samples are sent to SAPI.
// Also creates the rate changer.
//
////////////////////////////////////////////////////// JOEM 01-2001 //
STDMETHODIMP CLocalTTSEngineSite::SetOutputFormat(const GUID *pOutputFormatId, const WAVEFORMATEX *pOutputFormat)
{
    SPDBG_FUNC( "CLocalTTSEngineSite::SetOutputFormat" );
    HRESULT hr = S_OK;

    SPDBG_ASSERT(pOutputFormatId);

    if ( pOutputFormatId && *pOutputFormatId == SPDFID_Text )
    {
        m_pOutputFormatId = pOutputFormatId;

        SetBufferSize(0); // deletes the current buffer, if any (can't buffer text)

        if ( m_pOutputFormat )
        {
            delete m_pOutputFormat;
            m_pOutputFormat = NULL;
        }
    }
    else if ( pOutputFormat )
    {

        // Do we need to change the format?
        if ( !m_pOutputFormat ||
            m_pOutputFormat->wFormatTag         != pOutputFormat->wFormatTag        ||
            m_pOutputFormat->nChannels          != pOutputFormat->nChannels         ||
            m_pOutputFormat->nSamplesPerSec     != pOutputFormat->nSamplesPerSec    ||
            m_pOutputFormat->nAvgBytesPerSec    != pOutputFormat->nAvgBytesPerSec   ||
            m_pOutputFormat->nBlockAlign        != pOutputFormat->nBlockAlign       ||
            m_pOutputFormat->wBitsPerSample     != pOutputFormat->wBitsPerSample    ||
            m_pOutputFormat->cbSize             != pOutputFormat->cbSize
            )
        {

            // save these values to determine whether buffer and/or rate changer need adjusting
            // for the new format
            DWORD oldnAvgBytesPerSec = 0;
            DWORD oldnSamplesPerSec = 0;
            if ( m_pOutputFormat )
            {
                oldnAvgBytesPerSec = m_pOutputFormat->nAvgBytesPerSec;
                oldnSamplesPerSec = m_pOutputFormat->nSamplesPerSec;
            }
            
            // free the current waveformatex
            if ( m_pOutputFormat )
            {
                free(m_pOutputFormat);
                m_pOutputFormat = NULL;
            }
            // this needs to copy the output format, not just point to it,
            // because engine will pass in const pointer.
            m_pOutputFormat = (WAVEFORMATEX*) malloc( sizeof(WAVEFORMATEX) + pOutputFormat->cbSize );
            if ( !m_pOutputFormat )
            {
                hr = E_OUTOFMEMORY;
            }
            else 
            {
                m_pOutputFormatId = pOutputFormatId;
                memcpy(m_pOutputFormat, pOutputFormat, sizeof(WAVEFORMATEX) + pOutputFormat->cbSize );
            }
            
            if ( SUCCEEDED(hr) )
            {
                // Re-adjust the buffer size for the new format, if necessary
                if ( oldnAvgBytesPerSec != m_pOutputFormat->nAvgBytesPerSec )
                {
                    hr = SetBufferSize(m_ulBufferSeconds);
                }
            }
        
            // once we know the sampling frequency, we can create the rate changer
            if ( SUCCEEDED(hr) )
            {
                if ( !m_pTsm )
                {
                    m_pTsm = new CTsm( g_dRateScale[BASE_RATE], m_pOutputFormat->nSamplesPerSec );
                }
                
                if ( !m_pTsm )
                {
                    hr = E_OUTOFMEMORY;
                }
                
                if ( SUCCEEDED(hr) )
                {
                    // Reset the rate changer sampling frequency, if necessary
                    if ( oldnSamplesPerSec != m_pOutputFormat->nSamplesPerSec )
                    {
                        if ( m_pTsm->SetSamplingFrequency( m_pOutputFormat->nSamplesPerSec ) 
                            != m_pOutputFormat->nSamplesPerSec )
                        {
                            delete m_pTsm;
                            m_pTsm = NULL;
                            hr = E_FAIL;
                        }
                    }
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::GetActions
//
// When using a buffer, mask all actions except abort. This module handles 
// the real-time changes, so it makes the engine output regular rate and vol 
// all the time. (But the engine handles XML-based rate/vol changes.)
//
// When not buffering, pass the call to SAPI, but OR'd with vol and rate. 
//
//////////////////////////////////////////////////////////// JOEM  02-2000 //
DWORD CLocalTTSEngineSite::GetActions( void )
{
    if ( m_pcBuffer )
    {
        return m_pMainOutputSite->GetActions() & SPVES_ABORT;
    }
    else
    {
        // When prompt eng calls GetVolume or GetRate, SAPI turns off the 
        // SPVES_VOLUME/SPVES_RATE flags.  OR them here to force the TTS engine 
        // to call GetRate and GetVolume too. 
        return m_pMainOutputSite->GetActions() | SPVES_VOLUME | SPVES_RATE;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::GetRate (ISpTTSEngineSite::GetRate)
//
// When using a buffer, simply sets plRateAdjust to 0 to make the engine 
// use normal rate (module controls real-time rate changes).
//
// When not buffering, pass the call to SAPI. 
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
STDMETHODIMP CLocalTTSEngineSite::GetRate ( long* plRateAdjust )
{ 
    SPDBG_FUNC( "CLocalTTSEngineSite::GetRate" );
    HRESULT hr = S_OK;

    if ( m_pcBuffer )
    {
        *plRateAdjust = 0; 
    }
    else
    {
        hr = m_pMainOutputSite->GetRate ( plRateAdjust );
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr; 
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::GetVolume (ISpTTSEngineSite::GetVolume)
//
// When using a buffer, simply sets punVolume to 100 to make the engine use 
// full volume (module controls real-time vol changes).
//
// When not buffering, pass the call to SAPI. 
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
STDMETHODIMP CLocalTTSEngineSite::GetVolume ( USHORT* punVolume )
{ 
    SPDBG_FUNC( "CLocalTTSEngineSite::GetVolume" );
    HRESULT hr = S_OK;

    if ( m_pcBuffer )
    {
        *punVolume = 100; 
    }
    else
    {
        hr = m_pMainOutputSite->GetVolume ( punVolume );
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr; 
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::GetSkipInfo (ISpTTSEngineSite::GetSkipInfo)
//
// When using a buffer, simply returns 0 to prevent the engine from skipping
// (module controls skips).
//
// When not buffering, pass the call to SAPI. 
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
STDMETHODIMP CLocalTTSEngineSite::GetSkipInfo ( SPVSKIPTYPE* peType, long* plNumItems )
{ 
    SPDBG_FUNC( "CLocalTTSEngineSite::GetSkipInfo" );
    HRESULT hr = S_OK;

    if ( m_pcBuffer )
    {
        *peType = SPVST_SENTENCE;
        *plNumItems = 0;
    }
    else
    {
        hr = m_pMainOutputSite->GetSkipInfo ( peType, plNumItems );
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr; 
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::CompleteSkip (ISpTTSEngineSite::CompleteSkip)
//
// When using a buffer, this just returns.
//
// When not buffering, pass the call to SAPI. 
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
STDMETHODIMP CLocalTTSEngineSite::CompleteSkip ( long lNumSkipped )
{ 
    SPDBG_FUNC( "CLocalTTSEngineSite::CompleteSkip" );
    HRESULT hr = S_OK;

    if ( !m_pcBuffer )
    {
        hr = m_pMainOutputSite->CompleteSkip ( lNumSkipped );
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr; 
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::AddEvents (ISpTTSEngineSite::AddEvents)
//
// Two engines (Prompt and TTS) might be writing to this output site.
// Each will not know that the other is sending data, so events  
// won't have the correct ullAudioStreamOffset.
//
// Consequently, CLocalTTSEngineSite::UpdateBytesWritten must be called 
// after each time the Prompt engine issues a TTS->speak call and after 
// each time the PE calls CLocalTTSEngineSite::Write.  
//
// Note that when this is used by a single engine, there is no need to 
// (or harm in) calling UpdateBytesWritten.  Consequently, TTS engines 
// require no modification -- the Prompt Engine manages AudioStreamOffset 
// when there are 2 engines writing data. 
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
STDMETHODIMP CLocalTTSEngineSite::AddEvents(const SPEVENT* pEventArray, ULONG ulCount )
{ 
    SPDBG_FUNC( "CLocalTTSEngineSite::AddEvents" );
    HRESULT hr          = S_OK;
    ULONG   i           = 0;

    SPDBG_ASSERT(pEventArray || !ulCount);
    
    // Are we buffering?
    if ( m_pcBuffer )
    {
        Event*  pNewEvent   = NULL;

        for ( i=0; SUCCEEDED(hr) && i<ulCount; i++ )
        {
            // Make a new Event structure
            pNewEvent = new Event;
            if ( !pNewEvent )
            {
                hr = E_OUTOFMEMORY;
            }
            if ( SUCCEEDED(hr) )
            {
                pNewEvent->pPrev = NULL;
                pNewEvent->pNext = NULL;
                memcpy(&pNewEvent->event, &pEventArray[i], sizeof(SPEVENT) );
                // ullAudioStreamOffset adjusted here since two engines may be writing data
                pNewEvent->event.ullAudioStreamOffset += m_ullPreviousBytesReceived;
                
                // Put it in the event queue, sorted
                // Is this the only event in the queue?
                if ( !m_pEventQueue )
                {
                    m_pEventQueue   = pNewEvent;
                    m_pCurrentEvent = pNewEvent;
                    m_pLastEvent    = pNewEvent;
                }
                else
                {
                    // Does the new event go last?
                    if ( m_pLastEvent && m_pLastEvent->event.ullAudioStreamOffset <= pNewEvent->event.ullAudioStreamOffset )
                    {
                        m_pLastEvent->pNext = pNewEvent;
                        pNewEvent->pPrev = m_pLastEvent;
                        m_pLastEvent = pNewEvent;
                    }
                    else
                    {
                        // figure out where it goes -- most likely it goes near the end, so step
                        // backward through the list
                        Event* pInsertHere = m_pLastEvent;
                        while ( pInsertHere )
                        {
                            if ( pInsertHere->event.ullAudioStreamOffset <= pNewEvent->event.ullAudioStreamOffset )
                            {
                                pNewEvent->pPrev            = pInsertHere;
                                pInsertHere->pNext->pPrev   = pNewEvent;
                                pNewEvent->pNext            = pInsertHere->pNext;
                                pInsertHere->pNext          = pNewEvent;
                            }
                            else
                            {
                                pInsertHere = pInsertHere->pPrev;
                            }
                        }
                        // did we reach the front of the list?
                        if ( !pInsertHere )
                        {
                            // insert it at the beginning
                            pNewEvent->pNext = m_pEventQueue;
                            m_pEventQueue->pPrev = pNewEvent;
                            m_pEventQueue = pNewEvent;
                        }
                    } // else
                } // else
                
                //if there's no current event, make the first in this array current.
                if ( !m_pCurrentEvent )
                {
                    m_pCurrentEvent = pNewEvent;
                }
            } // if ( SUCCEEDED(hr) )
        } // for ( i=0; SUCCEEDED(hr) && i<ulCount; i++ )
    }
    else
    {
        // no buffer -- just send the events
        SPEVENT* pEvents = const_cast<SPEVENT*> (pEventArray);

        for ( i=0; i<ulCount; i++ )
        {
            pEvents[i].ullAudioStreamOffset += m_ullPreviousBytesReceived;
        }
        
        hr = m_pMainOutputSite->AddEvents(pEvents, ulCount); 
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr; 
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::SendEvents
//
// Steps through the event buffer, sending events that should occur within
// the current block of data.
//
// The event's ullAudioStreamOffset must be adjust by the count of bytes 
// skipped (includes skip forward and backward).  The sum must then be scaled
// to match the cumulative real-time rate adjustments that have occurred 
// (ratio of bytes-sent-to-SAPI to the unaltered byte count).
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
STDMETHODIMP CLocalTTSEngineSite::SendEvents()
{ 
    SPDBG_FUNC( "CLocalTTSEngineSite::SendEvents" );
    HRESULT hr                  = S_OK;
    ULONG   ulEventPos          = 0;
    ULONG   ulOriginalOffset    = 0;
    float   flRateAdj           = 1.0;
    
    // was there a previous rate adjustment to factor in?
    if ( m_ullBytesWrittenToSAPI != m_ullBytesWritten )
    {
        flRateAdj = (float)m_ullBytesWrittenToSAPI / m_ullBytesWritten;
    }

    while ( SUCCEEDED(hr) && m_pCurrentEvent )
    {
        // only send events up to the current byte count
        if ( m_pCurrentEvent->event.ullAudioStreamOffset <= (m_ullBytesWritten + m_lTotalBytesSkipped) )
        {
            ulOriginalOffset = m_pCurrentEvent->event.ullAudioStreamOffset;

            // Adjust the cb by amount skipped
            // BytesSkipped should never be greater than the current event's position!!
            // If this happens, RescheduleEvents is not working properly.
            SPDBG_ASSERT(m_lTotalBytesSkipped <= (long)m_pCurrentEvent->event.ullAudioStreamOffset);
            m_pCurrentEvent->event.ullAudioStreamOffset -= m_lTotalBytesSkipped;
            // Adjust by proportion rate change
            m_pCurrentEvent->event.ullAudioStreamOffset *= flRateAdj;
            // Make sure it's a multiple of nBlockAlign
            m_pCurrentEvent->event.ullAudioStreamOffset -= (m_pCurrentEvent->event.ullAudioStreamOffset % m_pOutputFormat->nBlockAlign );

            hr = m_pMainOutputSite->AddEvents(&m_pCurrentEvent->event, 1);

            // restore the original in case we need to skip back
            m_pCurrentEvent->event.ullAudioStreamOffset = ulOriginalOffset;

            m_pCurrentEvent = m_pCurrentEvent->pNext;
        }
        else
        {
            break;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr; 
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::RescheduleEvents
//
// Resets the pointer to the current event.
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
void CLocalTTSEngineSite::RescheduleEvents(Event* pStart)
{ 
    SPDBG_FUNC( "CLocalTTSEngineSite::RescheduleEvents" );

    Event* pEvent = pStart;

    // Reschedules (or skips) events based on bytes skipped (forward or backward)
    while ( pEvent && ( pEvent->event.ullAudioStreamOffset < m_ullBytesWritten + m_lTotalBytesSkipped ) )
    {
        pEvent = pEvent->pNext;
    }

    m_pCurrentEvent = pEvent;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::FlushEvents
//
// Some events are flushed when corresponding audio data is pushed off the
// end of the buffer.
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
void CLocalTTSEngineSite::FlushEvents(const ULONG cb)
{ 
    SPDBG_FUNC( "CLocalTTSEngineSite::FlushEvents" );

    Event* pEvent     = m_pEventQueue;
    Event* pNextEvent = NULL;

    while ( pEvent && pEvent->event.ullAudioStreamOffset <= cb )
    {
        pNextEvent = pEvent->pNext;
        
        delete pEvent;
        pEvent = pNextEvent;
        if ( pEvent )
        {
            pEvent->pPrev = NULL;
        }
    }
    if ( pEvent )
    {
        m_pEventQueue = pEvent;
    }
    else
    {
        m_pEventQueue   = NULL;
        m_pCurrentEvent = NULL;
        m_pLastEvent    = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::Write
//
// Copies the data (pBuff) onto the end of the audio buffer (at current empty
// location), pushing data off the front of the buffer to make room, 
// if necessary.
//
// If buffer size is too small, some of the data is written directly to
// the SAPI output site and the rest will be buffered.
//
// If no buffer exists, all of the data is written directly to SAPI.
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
STDMETHODIMP CLocalTTSEngineSite::Write( const void* pBuff, ULONG cb, ULONG *pcbWritten )
{
    SPDBG_FUNC( "CLocalTTSEngineSite::Write" );
    HRESULT hr              = S_OK;
    long    lSpaceNeeded    = 0;
    char*   pcStart         = NULL;
    ULONG   ulBytesToWrite  = 0;
    bool    fAbort          = false;

    char* pcBuff    = (char*)pBuff;
    pcStart         = pcBuff;
    
    m_ullTotalBytesReceived += cb;

    // Are we buffering the samples, or just sending them?
    if ( m_pcBuffer )
    {
        // Do we need extra space?
        lSpaceNeeded = ( m_ulDataEnd + cb ) - m_ulBufferBytes;

        // if out of space, push some off the front to make room
        if ( lSpaceNeeded > 0 )
        {
            // Is the buffer big enough?
            if ( cb > m_ulBufferBytes )
            {
                ulBytesToWrite = cb - m_ulBufferBytes;
                hr = WriteToSAPI( pcBuff, ulBytesToWrite, &fAbort );

                if ( SUCCEEDED(hr) )
                {
                    // we're going to replace the entire buffer with what's left 
                    // so the current data in the buffer is garbage now.
                    m_ulDataEnd = 0;
                    pcStart = &pcBuff[ulBytesToWrite]; // make pcStart point to what's left after WriteToSapi 
                    // Flush the entire event buffer
                    FlushEvents(m_ullBytesWritten + m_lTotalBytesSkipped);
                }
            }
            else
            {
                // how much should we shift off the end? 
                lSpaceNeeded = ( lSpaceNeeded > m_ulMinBufferShift ) ? lSpaceNeeded : m_ulMinBufferShift;
                
                // Move the stuff we're saving to the beginning of the buffer (overwrite the shifted amount)
                memmove( m_pcBuffer, &m_pcBuffer[ lSpaceNeeded ], (m_ulDataEnd - lSpaceNeeded) * sizeof(char) );
                // The data end now shifts toward front of buffer
                m_ulDataEnd -= lSpaceNeeded;
                pcStart = pcBuff; // make pcStart point to all of the new data
                // Flush everything received (minus the new bytes) minus what's left to buffer
                FlushEvents(m_ullTotalBytesReceived - cb - (m_ulBufferBytes - lSpaceNeeded));
            }
        }
        
        if ( SUCCEEDED(hr) )
        {
            // go to the end of the data we're keeping
            m_ulCurrentByte = m_ulDataEnd;
            // copy new data onto end of buffer.  
            memcpy( &m_pcBuffer[m_ulCurrentByte], pcStart, cb - ulBytesToWrite ); 
            // Mark the new end 
            m_ulDataEnd += (cb - ulBytesToWrite); 
            
            if ( !fAbort )
            {
                hr = WriteBuffer();
            }
        }
    }
    else
    {
        hr = WriteToSAPI( pcBuff, cb, &fAbort );
    }

    if ( SUCCEEDED(hr) && pcbWritten )
    {
        *pcbWritten = cb;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::WriteBuffer
//
// Sends data from the buffer to SAPI (via WriteToSAPI) in small chunks, 
// checking for skip/abort actions.  (WriteToSAPI does vol/rate changes).
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
STDMETHODIMP CLocalTTSEngineSite::WriteBuffer()
{
    SPDBG_FUNC( "CLocalTTSEngineSite::WriteBuffer" );
    HRESULT hr              = S_OK;
    ULONG   nBytesToWrite   = 0;
    bool    fAbort          = false;
    ULONG   ulChunkSize     = 0;

    ulChunkSize = g_dChunkSize * m_pOutputFormat->nAvgBytesPerSec;
    ulChunkSize -= (ulChunkSize % m_pOutputFormat->nBlockAlign); // write in multiples of nBlockAlign
    
    // Try to write one full chunk (approx. 0.1 sec) of audio per loop
    while ( SUCCEEDED(hr) && m_ulCurrentByte < m_ulDataEnd )
    {
        // Stop speaking?
        if ( fAbort || ( m_pMainOutputSite->GetActions() & SPVES_ABORT ) )
        {
            break;
        }

        // Still skipping forward?
        if ( m_ulSkipForward > 0 )
        {
            if ( m_ulDataEnd - m_ulCurrentByte > m_ulSkipForward )
            {
                // there is some data in buffer that can be written
                m_ulCurrentByte += m_ulSkipForward;         // move the current byte forward by the skip amount
                m_lTotalBytesSkipped += m_ulSkipForward;    // keep accumulating
                m_ulSkipForward = 0;                        // no more to skip
                RescheduleEvents(m_pCurrentEvent);          // skip associated events
            }
            else
            {
                // skip all of the rest of the data in the buffer and await more
                m_ulSkipForward -= ( m_ulDataEnd - m_ulCurrentByte );       // reduce bytes left to skip
                m_lTotalBytesSkipped += ( m_ulDataEnd - m_ulCurrentByte );  // keep accumulating
                m_ulCurrentByte = m_ulDataEnd;                              // move to end of buffered data
                m_pCurrentEvent = m_pLastEvent;                             // move to end of event buffer
                break;                                                      // no data to be written
            }

        }

        // New skip?
        if( m_pMainOutputSite->GetActions() & SPVES_SKIP )
        {
            SPVSKIPTYPE SkipType;
            long        lSkipCount = 0;
            
            hr = m_pMainOutputSite->GetSkipInfo( &SkipType, &lSkipCount );

            if ( SUCCEEDED(hr) )
            {
                long    lBytesToSkip    = 0;
                long    lSkipped        = 0;

                lBytesToSkip = lSkipCount * m_pOutputFormat->nAvgBytesPerSec;
                lBytesToSkip *= m_flRateAdj; // we're skipping by seconds, so rate-adjust
                lBytesToSkip -= ( lBytesToSkip % m_pOutputFormat->nBlockAlign ); // need multiple of nBlockAlign

                // skipping forward?
                if ( lBytesToSkip > 0 )
                {
                    m_ulSkipForward += lBytesToSkip;
                    lSkipped = lBytesToSkip;
                }
                else // skipping backward
                {
                    // don't skip backward past the beginning
                    if ( (long) m_ulCurrentByte + lBytesToSkip < 0 )
                    {
                        lSkipped -= m_ulCurrentByte; // just go back to beginning
                        m_ulCurrentByte = 0;
                    }
                    else
                    {
                        lSkipped = lBytesToSkip;
                        m_ulCurrentByte += lSkipped; // lBytesSkipped is negative
                    }
                    m_lTotalBytesSkipped += lSkipped;
                    
                    RescheduleEvents(m_pEventQueue);
                }

                hr = m_pMainOutputSite->CompleteSkip( lSkipCount );
                continue;
            }
        }

        if ( SUCCEEDED(hr) )
        {
            // Do we have a full chunk of audio samples?
            if ( m_ulDataEnd - m_ulCurrentByte > ulChunkSize )
            {
                // Yes?  Write a full chunk
                nBytesToWrite = ulChunkSize;
            }
            else
            {
                // No?  Write all that we have
                nBytesToWrite = m_ulDataEnd - m_ulCurrentByte;
                // this should always be a multiple of nBlockAlign already!
                SPDBG_ASSERT(nBytesToWrite == (nBytesToWrite - (nBytesToWrite % m_pOutputFormat->nBlockAlign) ) );
            }
            
            if ( nBytesToWrite )
            {
                hr = WriteToSAPI( (void*)&m_pcBuffer[m_ulCurrentByte], nBytesToWrite, &fAbort );
            }
        }

        if ( SUCCEEDED(hr) )
        {
            m_ulCurrentByte += nBytesToWrite;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::WriteToSAPI
//
// Forwards the data to the SAPI output site, adjusting vol/rate if necessary.
// Accumulates count of bytes to be written, and bytes actually written to SAPI.
//
//////////////////////////////////////////////////////////// JOEM  01-2001 //
STDMETHODIMP CLocalTTSEngineSite::WriteToSAPI( const void* pvBuff, const ULONG cb, bool* pfAbort )
{
    SPDBG_FUNC( "CLocalTTSEngineSite::WriteToSAPI" );
    HRESULT hr              = S_OK;
    void*   pvTsmBuff       = NULL;
    void*   pvVolBuff       = NULL;
    int     iNumOutSamples  = 0;
    ULONG   ulOutCb         = 0;
    long    lRateAdj        = 0;

    const void* pvSendBuff  = pvBuff; // this is what we'll send to SAPI, unless Tsm/Vol changes it

    SPDBG_ASSERT(pvBuff);
    SPDBG_ASSERT(cb);
    SPDBG_ASSERT(pfAbort);
    
    if ( m_pOutputFormatId && *m_pOutputFormatId != SPDFID_Text )
    {
        iNumOutSamples = cb / m_pOutputFormat->nBlockAlign;
        
        if ( m_pcBuffer )
        {
            // check for rate change
            if ( m_pMainOutputSite->GetActions() & SPVES_RATE )
            {
                hr = m_pMainOutputSite->GetRate( &lRateAdj );
                if ( SUCCEEDED(hr) && lRateAdj )
                {
                    ComputeRateAdj(lRateAdj, &m_flRateAdj);
                    m_pTsm->SetScaleFactor( m_flRateAdj );
                }
            }
            
            // real-time rate change
            if ( SUCCEEDED(hr) && m_pTsm && m_flRateAdj != 1.0 )
            {
                int iTsmResult = 0;
                
                if ( iNumOutSamples > m_pTsm->GetFrameLen() )
                {
                    iTsmResult = m_pTsm->AdjustTimeScale(pvBuff, iNumOutSamples, &pvTsmBuff, &iNumOutSamples, m_pOutputFormat);
                    
                    if ( iTsmResult == 0 )
                    {
                        hr = E_FAIL;
                    }
                    if ( SUCCEEDED(hr) )
                    {
                        // send the Tsm modified buff instead of the original
                        pvSendBuff = pvTsmBuff;
                    }
                }
            }
            
            // real-time volume change
            if ( SUCCEEDED(hr) )
            {
                if ( m_pMainOutputSite->GetActions() & SPVES_VOLUME )
                {
                    USHORT unVol = 0;
                    
                    hr = m_pMainOutputSite->GetVolume( &unVol );
                    
                    if ( SUCCEEDED(hr) && unVol != 100 )
                    {
                        m_flVol = ((float) unVol) / 100; // make dVol fractional
                    }
                }
                
                if ( m_flVol != 1.0 )
                {
                    hr = ApplyGain( pvSendBuff, &pvVolBuff, iNumOutSamples );
                    // Did ApplyGain need to create a new buffer?
                    if ( pvVolBuff )
                    {
                        // send the volume modified buff instead of the original
                        pvSendBuff = pvVolBuff;
                    }
                }
            }
        } // if ( m_pcBuffer )
    } // if ( m_pOutputFormatId && *m_pOutputFormatId != SPDFID_Text )
    
    // stop speaking?
    if ( m_pMainOutputSite->GetActions() & SPVES_ABORT )
    {
        *pfAbort = true;
    }
    
    if ( SUCCEEDED(hr) && !*pfAbort )
    {
        ULONG ulOutCb = 0;
        m_ullBytesWritten += cb;
        if ( m_pOutputFormatId && *m_pOutputFormatId != SPDFID_Text )
        {
            ulOutCb = iNumOutSamples * m_pOutputFormat->nBlockAlign; 
            m_ullBytesWrittenToSAPI += ulOutCb;
            // send all the buffered events up to the current byte count 
            hr = SendEvents();
        }
        else
        {
            ulOutCb = cb;
            m_ullBytesWrittenToSAPI += cb;
        }

        hr = m_pMainOutputSite->Write(pvSendBuff, ulOutCb, NULL);
    }

    if ( pvTsmBuff )
    {
        delete [] pvTsmBuff;
        pvTsmBuff = NULL;
    }
    if ( pvVolBuff )
    {
        delete [] pvVolBuff;
        pvVolBuff = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::ComputeRateAdj
//
// Computes the rate multiplier.
//
/////////////////////////////////////////////////////// JOEM 11-2000 //
void CLocalTTSEngineSite::ComputeRateAdj(const long lRate, float* flRate)
{
    SPDBG_FUNC( "CLocalTTSEngineSite::ComputeRateAdj" );

    SPDBG_ASSERT(flRate);

    if ( lRate < 0 )
    {
        if ( lRate < MIN_RATE )
        {
            *flRate = 1.0 / g_dRateScale[0 - MIN_RATE];
        }
        else
        {
            *flRate = 1.0 / g_dRateScale[0 - lRate];
        }
    }
    else 
    {
        if ( lRate > MAX_RATE )
        {
            *flRate = g_dRateScale[MAX_RATE];
        }
        else
        {
            *flRate = g_dRateScale[lRate];
        }
    }
}

//////////////////////////////////////////////////////////////////////
// CLocalTTSEngineSite::ApplyGain
//
// Real-time volume adjustment.
//
////////////////////////////////////////////////////// JOEM 01-2001 //
STDMETHODIMP CLocalTTSEngineSite::ApplyGain(const void* pvInBuff, void** ppvOutBuff, const int iNumSamples)
{
    SPDBG_FUNC( "CLocalTTSEngineSite::ApplyGain" );
    HRESULT hr      = S_OK;
    int     i       = 0;

    SPDBG_ASSERT(pvInBuff);
    SPDBG_ASSERT(iNumSamples);

    // Apply Volume
    if ( SUCCEEDED(hr) && m_flVol != 1.0 )
    {
        long lGain = (long) ( m_flVol * (1 << g_iBase) );

        if ( m_pOutputFormat->wFormatTag == WAVE_FORMAT_ALAW || m_pOutputFormat->wFormatTag == WAVE_FORMAT_MULAW )
        {
            short*  pnBuff  = NULL;

            // need to convert samples
            int iOriginalFormatType  = VapiIO::TypeOf (m_pOutputFormat);

            if ( iOriginalFormatType == -1 )
            {
                hr = E_FAIL;
            }
            
            // Allocate the intermediate buffer
            if ( SUCCEEDED(hr) )
            {
                pnBuff = new short[iNumSamples];
                if ( !pnBuff )
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            // Allocate the final (out) buffer
            if ( SUCCEEDED(hr) )
            {
                *ppvOutBuff = new char[iNumSamples * VapiIO::SizeOf(iOriginalFormatType)];
                if ( !*ppvOutBuff )
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // Convert to something we can use
            if ( SUCCEEDED(hr) )
            {                
                if ( 0 == VapiIO::DataFormatConversion ((char *)pvInBuff, iOriginalFormatType, (char*)pnBuff, VAPI_PCM16, iNumSamples) )
                {
                    hr = E_FAIL;
                }
            }
            // Apply gain
            if ( SUCCEEDED(hr) )
            {
                for ( i=0; i<iNumSamples; i++ )
                {
                    pnBuff[i] = (short) ( ( pnBuff[i] * lGain ) >> g_iBase );
                }
            }
            // convert it back (from intermediate buff to final out buff)
            if ( SUCCEEDED(hr) )
            {                
                if ( 0 == VapiIO::DataFormatConversion ((char *)pnBuff, VAPI_PCM16, (char*)*ppvOutBuff, iOriginalFormatType, iNumSamples) )
                {
                    hr = E_FAIL;
                }
            }

            if ( pnBuff )
            {
                delete [] pnBuff;
                pnBuff = NULL;
            }
        }
        else if ( m_pOutputFormat->wFormatTag == WAVE_FORMAT_PCM )
        {
            // no converting necessary
            switch ( m_pOutputFormat->nBlockAlign )
            {
            case 1:
                for ( i=0; i<iNumSamples; i++ )
                {
                    ((char*)pvInBuff)[i] = (char) ( (((char*)pvInBuff)[i] * lGain) >> g_iBase );
                }
                break;
            case 2:
                for ( i=0; i<iNumSamples; i++ )
                {
                    ((short*)pvInBuff)[i] = (short) ( (((short*)pvInBuff)[i] * lGain) >> g_iBase );
                }
                break;
            default:
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }


    if ( FAILED(hr) )
    {
        if ( *ppvOutBuff )
        {
            delete [] *ppvOutBuff;
            *ppvOutBuff = NULL;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\getopt\getopt.h ===
/******************************************************************************
* getopt.h *
*----------*
*  This is the equivalent to the program options parsing utility
*  found in most UNIX compilers.
*------------------------------------------------------------------------------
*  Copyright (C) 1997 Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998 Entropic, Inc.
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/21/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef __GETOPT_H_
#define __GETOPT_H_

#include <windows.h>

class CGetOpt
{
    public:
        CGetOpt (bool fReportError = true);
        void  Init ( int argc, char* argv[], char* opstring);
        int   NextOption ();
        char* OptArg ();
        int   OptInd ();

    private:
        int    m_argc;
        char** m_argv;
        char*  m_optstring;

        char*  m_scan;
        int    m_optind;
        char*  m_optarg;
        bool   m_opterr;
};

class CWGetOpt
{
    public:
        CWGetOpt (bool fReportError = true);
        void   Init ( int argc, WCHAR* argv[], WCHAR* opstring);
        int    NextOption ();
        WCHAR* OptArg ();
        int    OptInd ();

    private:
        int     m_argc;
        WCHAR** m_argv;
        WCHAR*  m_optstring;

        WCHAR*  m_scan;
        int     m_optind;
        WCHAR*  m_optarg;
        bool    m_opterr;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\fmtconvert\fmtconvert.h ===
/******************************************************************************
* CFmtConvert.h *
*---------------*
*  Declarations of CFmtConvert class.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 05/03/00
*  All Rights Reserved
*
********************************************************************** DING ***/

#ifndef _FMTCONVERT_H_
#define _FMTCONVERT_H_

#include <windows.h>
#include <mmreg.h>

// #define FILTER_LEN_2  .0005 //(sec)

//--- class declare
class   CFmtConvert 
{
    public:
        CFmtConvert(double dHalfFilterLen = 0.0005);
        ~CFmtConvert();

        void            SetInputFormat (WAVEFORMATEX* userWavFormat);
        void            SetOutputFormat (WAVEFORMATEX* userWavFormat);
        HRESULT         ConvertSamples (const void* pvInSamples, int iInSampleLen, void** pvOutSamples, int* iOutSampleLen);
        HRESULT         FlushLastBuff (void** ppvOutSamples, int* piOutSampleLen);
    
    private:
        //-- mono & stereo
        HRESULT         SplitStereo (short* pnInSample, int* iSamplesLen, short** pnLeftSamples, short** pnRightSamples);
        HRESULT         MergeStereo (short* pnLeftSamples, short* pnRightSamples, int *iSamplesLen, short** pnOutSamples);
        HRESULT         Stereo2Mono (short* pnInSample, int* iSamplesLen, short** pnOutSample);
        HRESULT         Mono2Stereo (short* pnInSample, int* iSamplesLen, short** pnOutSample);

        //-- precission conversions
        double*         Short2Double (short* pnIn, int iLen);
        short*          Double2Short (double* pdIn, int iLen);

        //-- resample
        HRESULT         Resampling  (double* pdInSamples, int iInNumSamples, double *pdMemory, 
                                     double** ppdOutSamples, int* piOutNumSamples);
        HRESULT         CreateResamplingFilter (int iInSampFreq, int iOutSampFreq);
        void            DeleteResamplingFilter ();
        void            FindResampleFactors  (int iInSampFreq, int iOutSampFreq);
        double*         WindowedLowPass  (double dCutOff, double dGain);
        
        //-- memory
        HRESULT         CreateBuffers ();
        void            DeleteBuffers ();

        enum            BlockCntrl_t { FMTCNVT_FIRST, FMTCNVT_BLOCK, FMTCNVT_LAST }; 

        WAVEFORMATEX    m_OutWavFormat;
        WAVEFORMATEX    m_InWavFormat;
        BOOL            m_fResetFilter;
        BlockCntrl_t    m_eChunkStatus;
        int             m_iUpFactor;
        int             m_iDownFactor;
        int             m_iFilterHalf;
        int             m_iFilterLen;
        int             m_iBuffLen;
        double          m_dHalfFilterLen;
        double*         m_pdFilterCoef;
        double*         m_pdLeftMemory;
        double*         m_pdRightMemory;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\getopt\getopt.cpp ===
/******************************************************************************
* getopt.cpp *
*------------*
*   Based on the program by Henry Spencer posted to Usenet net.sources list
*   This is the equivalent to the program options parsing utility
*   found in most UNIX compilers.
*------------------------------------------------------------------------------
*  Copyright (C) 1997 Entropic Research Laboratory, Inc. 
*  Copyright (C) 1998 Entropic, Inc.
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/21/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "getopt.h"
#include <stdio.h>
#include <string.h>


/*****************************************************************************
* CGetOpt::CGetOpt *
*------------------*
*   Description:
*       
******************************************************************* PACOG ***/
CGetOpt::CGetOpt(bool fReportError)
{
    m_argc = 0;
    m_argv = 0;
    m_optstring = 0;
    m_scan = 0;

    m_optind = 0;
    m_optarg = 0;
    m_opterr = fReportError;
}


/*****************************************************************************
* CGetOpt::Init *
*---------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CGetOpt::Init (int argc, char *argv[], char* optstring)
{
    m_argc = argc;
    m_argv = argv;
    m_optstring = optstring;
    m_scan = 0;
    m_optind = 0;
    m_optarg = 0;
}
    

/*****************************************************************************
* CGetOpt::NextOption *
*---------------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CGetOpt::NextOption()
{
    char c;
    char *place;

    m_optarg = 0;

    if (m_scan == 0|| *m_scan == '\0') 
    {
        if (m_optind == 0) 
        {
            m_optind++;
        }
    
        if (m_optind >= m_argc || m_argv[m_optind][0] != '-' || m_argv[m_optind][1] == '\0') 
        {
            return(EOF);
        }

        if (strcmp(m_argv[m_optind], "--") == 0) 
        {
            m_optind++;
            return(EOF);
        }
    
        m_scan = m_argv[m_optind]+1;
        m_optind++;
    }

    c = *m_scan++;
    place = strchr(m_optstring, c);
    
    if (place == 0 || c == ':') 
    {
        if (m_opterr) 
        {
            fprintf(stderr, "%s: unknown option -%c\n", m_argv[0], c);
        }
        return('?');    
    }

    place++;
    if (*place == ':') 
    {
        if (*m_scan != '\0') 
        {
            m_optarg = m_scan;
            m_scan   = 0;
        }
        else 
        {
            m_optarg = m_argv[m_optind];
            m_optind++;
        }
    }
    
    return c;
}
/*****************************************************************************
* CGetOpt::OptArg *
*-----------------*
*   Description:
*       
******************************************************************* PACOG ***/
char* CGetOpt::OptArg ()
{
    return m_optarg;
}

/*****************************************************************************
* CGetOpt::OptInd *
*-----------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CGetOpt::OptInd ()
{
    return m_optind;
}


/******
*
* WIDE CHAR VERSIONS
*
******/

/*****************************************************************************
* CWGetOpt::CWGetOpt *
*--------------------*
*   Description:
*       
******************************************************************* PACOG ***/
CWGetOpt::CWGetOpt(bool fReportError)
{
    m_argc = 0;
    m_argv = 0;
    m_optstring = 0;
    m_scan = 0;

    m_optind = 0;
    m_optarg = 0;
    m_opterr = fReportError;
}


/*****************************************************************************
* CWGetOpt::Init *
*---------------*
*   Description:
*       
******************************************************************* PACOG ***/
void CWGetOpt::Init (int argc, WCHAR *argv[], WCHAR* optstring)
{
    m_argc = argc;
    m_argv = argv;
    m_optstring = optstring;
    m_scan = 0;
    m_optind = 0;
    m_optarg = 0;
}
    

/*****************************************************************************
* CWGetOpt::NextOption *
*---------------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CWGetOpt::NextOption()
{
    WCHAR c;
    WCHAR *place;

    m_optarg = 0;

    if (m_scan == 0|| *m_scan == L'\0') 
    {
        if (m_optind == 0) 
        {
            m_optind++;
        }
    
        if (m_optind >= m_argc || m_argv[m_optind][0] != L'-' || m_argv[m_optind][1] == L'\0') 
        {
            return(EOF);
        }

        if (wcscmp(m_argv[m_optind], L"--") == 0) 
        {
            m_optind++;
            return(EOF);
        }
    
        m_scan = m_argv[m_optind]+1;
        m_optind++;
    }

    c = *m_scan++;
    place = wcschr(m_optstring, c);
    
    if (place == 0 || c == L':') 
    {
        if (m_opterr) 
        {
            fprintf(stderr, "%s: unknown option -%c\n", m_argv[0], c);
        }
        return(L'?');    
    }

    place++;
    if (*place == L':') 
    {
        if (*m_scan != L'\0') 
        {
            m_optarg = m_scan;
            m_scan   = 0;
        }
        else 
        {
            m_optarg = m_argv[m_optind];
            m_optind++;
        }
    }
    
    return c;
}
/*****************************************************************************
* CWGetOpt::OptArg *
*-----------------*
*   Description:
*       
******************************************************************* PACOG ***/
WCHAR* CWGetOpt::OptArg ()
{
    return m_optarg;
}

/*****************************************************************************
* CWGetOpt::OptInd *
*-----------------*
*   Description:
*       
******************************************************************* PACOG ***/
int CWGetOpt::OptInd ()
{
    return m_optind;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\localttsenginesite\localttsenginesite.h ===
//////////////////////////////////////////////////////////////////////
// LocalTTSEngineSite.h: interface for the CLocalTTSEngineSite class.
//
// Created by JOEM  04-2000
// Copyright (C) 2000 Microsoft Corporation
// All Rights Reserved
//
/////////////////////////////////////////////////////// JOEM 4-2000 //

#if !defined(AFX_LOCALTTSENGINESITE_H__70B0DA93_23F5_4F17_B525_4027F78AF195__INCLUDED_)
#define AFX_LOCALTTSENGINESITE_H__70B0DA93_23F5_4F17_B525_4027F78AF195__INCLUDED_

#include <sapiddk.h>
#include "tsm.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//-------------------------------------------
// Translate -10 <--> +10 rate control to 
// 10th root of three rate scale
//-------------------------------------------
enum USER_RATE_VALUE
{	
    MIN_RATE	= -10,
    BASE_RATE   = 0,
	MAX_RATE    = 10,
};

const double g_dRateScale[] =
{
    1.0,
    1.1161231740339044344426141383771, // 3 ^ 1/10
    1.2457309396155173259666803366403,
    1.3903891703159093404852542946161,
    1.5518455739153596742733451355167,
    1.7320508075688772935274463415059,
    1.9331820449317627515248789432662,
    2.1576692799745930995549489159803,
    2.4082246852806920462855086141912,
    2.6878753795222865835819210737269,
    3,
};

struct Event
{
    SPEVENT event;
    Event*  pPrev;
    Event*  pNext;
};

class CLocalTTSEngineSite : public ISpTTSEngineSite
{
public:
    CLocalTTSEngineSite();
    ~CLocalTTSEngineSite();

public:
    //--- IUnknown  --------------------------------------
    STDMETHOD(QueryInterface) ( REFIID iid, void** ppvObject );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release) (void);

    //--- ISpTTSEngineSite --------------------------------------
    STDMETHOD(GetEventInterest)( ULONGLONG * pullEventInterest )
        { return m_pMainOutputSite->GetEventInterest(pullEventInterest); }
    STDMETHOD(GetRate)( long* plRateAdjust );
    STDMETHOD(GetSkipInfo)( SPVSKIPTYPE* peType, long* plNumItems );
    STDMETHOD(CompleteSkip)( long lNumSkipped );
    STDMETHOD(GetVolume)( USHORT* punVolume );
    STDMETHOD(AddEvents)(const SPEVENT* pEventArray, ULONG ulCount );
    STDMETHOD(Write)( const void* pBuff, ULONG cb, ULONG *pcbWritten );
    STDMETHOD_(DWORD, GetActions)( void );

    //--- CLocalTTSEngineSite --------------------------------------
	void SetOutputSite(ISpTTSEngineSite* pOutputSite);
	STDMETHOD(SetBufferSize)(const ULONG ulSeconds);
	STDMETHOD(SetOutputFormat)(const GUID * pOutputFormatId, const WAVEFORMATEX *pOutputFormat);
    void UpdateBytesWritten() 
        { m_ullPreviousBytesReceived = m_ullTotalBytesReceived; }

private:
    STDMETHOD(WriteBuffer)();
    STDMETHOD(WriteToSAPI)( const void* pvBuff, const ULONG cb, bool* pfAbort );
    void ComputeRateAdj(const long lRate, float* flRate);
    STDMETHOD(ApplyGain)(const void* pvInBuff, void** ppvOutBuff, const int iNumSamples);
    STDMETHOD(SendEvents)();
    void RescheduleEvents(Event* pStart);
    void FlushEvents(const ULONG cb);

private:
    volatile LONG       m_vcRef;

    // output vars
    ISpTTSEngineSite*   m_pMainOutputSite;
    const GUID*         m_pOutputFormatId;
    WAVEFORMATEX*       m_pOutputFormat;

    // audio buffer
    char*               m_pcBuffer;
    ULONG               m_ulBufferBytes;
    ULONG               m_ulBufferSeconds;
    ULONG               m_ulMinBufferShift;
    ULONG               m_ulDataEnd;
    ULONG               m_ulCurrentByte;
    ULONG               m_ulSkipForward;

    // eventing managers
    Event*              m_pEventQueue;
    Event*              m_pCurrentEvent;
    Event*              m_pLastEvent;

    // event ullAudioStreamOffset managers
    ULONGLONG           m_ullTotalBytesReceived;    // sums every byte as they come in
    ULONGLONG           m_ullPreviousBytesReceived; // sums every byte of previous ::Write calls
    ULONGLONG           m_ullBytesWritten;          // sums every byte written (before rate adj)
    ULONGLONG           m_ullBytesWrittenToSAPI;    // sums every byte written to SAPI (differs due to rate change)
    LONG                m_lTotalBytesSkipped;       // cumulative skipped, plus or minus

    // rate changer
    CTsm*               m_pTsm;
    float               m_flRateAdj;
    double              m_flVol;
};

#endif // !defined(AFX_LOCALTTSENGINESITE_H__70B0DA93_23F5_4F17_B525_4027F78AF195__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\sigproc\lpc.cpp ===
/******************************************************************************
* lpc.cpp *
*---------*
*  I/O library functions for extended speech files (vapi format)
*------------------------------------------------------------------------------
*  Copyright (C) 1999  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "sigprocInt.h"



/*****************************************************************************
* ParcorFilterSyn *
*-----------------*
*   Description:
*       Synthesis lattice filter.
******************************************************************* PACOG ***/

void ParcorFilterSyn (double* pdData, int iNumData, double* pdParcor, double* pdMemory, int iOrder)
{
    double dAlfa;
    int j;

    assert (pdData);
    assert (pdParcor);
    assert (pdMemory);

    for (int i=0; i<iNumData; i++) 
    {
        dAlfa  = pdData[i];

        for (j=iOrder-1; j>=0; j--) 
        {
            dAlfa += pdMemory[j] * pdParcor[j];            

            if (j<iOrder-1)
            { 
                pdMemory[j+1] = pdMemory[j] - dAlfa * pdParcor[j];
            }
        }

        pdMemory[0] = dAlfa; 
        pdData[i]   = dAlfa;
    }
}

/*****************************************************************************
* ParcorFilterAn *
*----------------*
*   Description:
*       Inverse filter, lattice form.
******************************************************************* PACOG ***/

void ParcorFilterAn  (double* pdData, int iNumData, double* pdParcor, double* pdMemory, int iOrder)
{
    double dAlfa;
    double dBeta;
    double dDelay;
    int j;  

    assert (pdData);
    assert (pdParcor);
    assert (pdMemory);
  
    for (int i=0; i<iNumData; i++) 
    {
        dAlfa  = pdData[i];
        dDelay = pdData[i];

        for (j=0; j<iOrder; j++) 
        {
            dBeta  = pdMemory[j] - dAlfa * pdParcor[j];
            dAlfa -= pdMemory[j] * pdParcor[j];            

            pdMemory[j] = dDelay;
            dDelay      = dBeta;
        }

        pdData[i] = dAlfa;
    }
}

/*****************************************************************************
* Cepstrum *
*----------*
*   Description:
*       Computes order +1 autocorrelation coefficients of a data segment.
******************************************************************* PACOG ***/

double*  Autocor(double* x, int xLen, int iOrder)
{
    double* aut;
    int i;
    int n;

    assert (x);
    assert (xLen>0);
    assert (iOrder>0);

    if ((aut = new double[iOrder+1]) != 0) 
    {
        memset (aut, 0, sizeof(*aut) * (iOrder+1));

        for (i=0; i<=iOrder; i++) 
        {
            for (n=0; n<xLen- i; n++) 
            {
                aut[i] += x[n] * x[i+n];
            }
            aut[i] /= xLen;
        }
    }

    return aut;
}

/*****************************************************************************
* NormAutocor *
*-------------*
*   Description:
*       Computes autocorrelation coefficients of a data segment, normalized
*   by the value of the energy in that segment (r[0]). The energy value
*   is returned in r[0].
******************************************************************* PACOG ***/

double* NormAutocor(double* x, int xLen, int iOrder)
{
    double* aut;
    int i;
    int n;

    assert (x);
    assert (xLen>0);
    assert (iOrder>0);

    if ((aut = new double[iOrder+1]) != NULL) 
    {
       memset (aut, 0, sizeof(*aut) * (iOrder+1));
       for (i=0; i<=iOrder; i++) 
        {
            for (n=0; n<xLen - i; n++) 
            {
                aut[i] += x[n] * x[i+n];
            }
        }

        for (i=iOrder; i>=0; i-- ) 
        {
            aut[i] /= aut[0];
        }
    }

    return aut;
}

/*****************************************************************************
* DurbinRecursion *
*-----------------*
*   Description:
*
******************************************************************* PACOG ***/

double* DurbinRecursion (double* pdAutoc, int iOrder, int iCoefType, double *pdError)
{
    double* pdCoef = 0;
    double* pdAlfa1 = 0;
    double* pdAlfa2 = 0;
    double* pdParcor = 0;
    double dW;
    double dU;
    int m;
    int i;

    assert (pdAutoc);
    assert (iOrder>0);

    if ((pdAlfa1 = new double[iOrder+1]) == 0) 
    {
        goto error;
    }
    memset (pdAlfa1, 0, sizeof(*pdAlfa1)* (iOrder+1));

    if ((pdAlfa2 = new double[iOrder+1]) == 0)
    {
        goto error;
    }
    memset (pdAlfa2, 0, sizeof(*pdAlfa2)* (iOrder+1));

    pdAlfa1[0] = pdAlfa2[0] = 1.0;

    if ((pdParcor = new double[iOrder+1]) == 0) 
    {
        goto error;
    }
    memset (pdParcor, 0, sizeof(*pdParcor)* (iOrder+1));
  
    dW = pdAutoc[1];
    dU = pdAutoc[0];

    for (m=1; m<=iOrder; m++) 
    {
        if (dU == 0.0) 
        {
            pdParcor[m] = 0.0;
        } 
        else 
        {
            pdParcor[m]= dW/dU;
        }

        dU *= (1.0 - pdParcor[m]*pdParcor[m]);
  
        for (i=1; i<=m; i++) 
        {
            pdAlfa1[i] = pdAlfa2[i] - pdParcor[m]*pdAlfa2[m-i];      
        }

        if (m<iOrder) 
        { 
            dW = 0.0;
            for (i=0; i<=m; i++ ) 
            {
                dW += pdAlfa1[i]*pdAutoc[m+1-i];
            }
            memcpy (pdAlfa2, pdAlfa1, (iOrder+1)*sizeof(*pdAlfa1));
        } 
    }

    if (pdError) 
    {
        *pdError = sqrt(dU);  
        /*
        double acum=0.0;
        for (i=0;i<=iOrder;i++) 
        {
            acum+=pdAlfa1[i]+pdAutoc[i];
        }
        *pdError=sqrt(acum);
        */
    }

    if ((pdCoef = new double[iOrder]) == 0)
    {
        goto error;
    }

    if (iCoefType == LPC_ALFA) 
    {
        for (i=0 ; i<iOrder; i++) 
        {
            pdCoef[i] = pdAlfa1[i+1];
        }
    } 
    else 
    {
        for (i=0 ; i<iOrder; i++) 
        {
            pdCoef[i] = pdParcor[i+1];
        }
    }

    delete[] pdAlfa1;
    delete[] pdAlfa2;
    delete[] pdParcor;

    return pdCoef;

error:
    if (pdAlfa1) 
    {
        delete[] pdAlfa1;
    }
    if (pdAlfa2) 
    {
        delete[] pdAlfa2;
    }
    if (pdParcor) 
    {
        delete[] pdParcor;
    }

    return 0;
}

/*****************************************************************************
* GetDurbinCoef *
*---------------*
*   Description:
*
******************************************************************* PACOG ***/
double* GetDurbinCoef(double* pdData, int iNumData, int iOrder, int iCoefType, double *pdError)
{
    double* pdAutoc;
    double* coef;

    assert(pdData);
    assert(pdData>0);
    assert(iOrder>0);

    if ((pdAutoc = Autocor (pdData, iNumData, iOrder)) == 0)
    {
        return 0;
    }
  
    coef = DurbinRecursion ( pdAutoc, iOrder, iCoefType, pdError);

    delete[] pdAutoc;
  
    return coef;
}

/*****************************************************************************
* ParcorToAlfa *
*--------------*
*   Description:
*       Converts reflexion coefficient into Prediction coefs.
******************************************************************* PACOG ***/
bool ParcorToAlfa (double* pdParcor, double* pdAlfa, int iOrder)
{
    double *a1 = 0;
    double *a2 = 0;
    double *k1 = 0;
    int m;
    int i;
    bool fRetVal = false;
    
    assert (pdParcor);
    assert (pdAlfa);
    assert (iOrder>0);
    
    
    if ((a1 = new double[iOrder]) == 0)
    {
        goto exit;
    }
    memset (a1, 0, iOrder * sizeof(*a1));

    if ((a2 = new double[iOrder]) == 0)
    {
        goto exit;
    }
    memset (a2, 0, iOrder * sizeof(*a2));

    if ((k1 = new double[iOrder]) == 0)
    {
        goto exit;
    }
   
    a1[0] = a2[0] = 1.0;

    for (i=0; i<iOrder; i++) 
    {
        k1[i+1] = pdParcor[i];
    }
    
    for (m=1; m<=iOrder; m++) 
    {
        for (i=1;i<=m;i++) 
        {
            a1[i] = a2[i] - k1[m]*a2[m-i];      
        }
        
        if (m<iOrder) 
        {            
            memcpy(a2, a1, iOrder * sizeof(*a1));
        } 
    }
    
    for (i=0; i<iOrder; i++) 
    {
        pdAlfa[i] = a1[i+1];
    }
    
    fRetVal = true;

exit:
    if (a1)
    {
        delete[] a1;
    }
    if (a2)
    {
        delete[] a2;
    }
    if (k1)
    {
        delete[] k1;
    }

    return fRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\sigproc\nid.cpp ===
/******************************************************************************
* nid+.cpp *
*---------*
*  I/O library functions for extended speech files (vapi format)
*------------------------------------------------------------------------------
*  Copyright (C) 1999  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "sigprocInt.h"

#define FILTER_ORDER 40  /* Filter length 2*N+1 */

/*****************************************************************************
* sig *
*----------*
*   Description:
*       Implements (-1)^(M-n). It might be better to implement it with
*     a macro. M is the filter order, so this function is simmetrical from M.
******************************************************************* PACOG ***/

static double Sign (int n)
{
    if ((n-FILTER_ORDER)%2) 
    {
        return -1.0;
    }
    return 1.0;
}

/*****************************************************************************
* NonIntegerDelay *
*-----------------*
*   Description:
*       Introduces a non integer delay by sinc interpolation. 
*     The filter is simply truncated. Better response could be achieved by
*     using a different windowing function. So far, the response is adjusted
*     augmenting the number of points used in the interpolation.
*
*     dDelay: 0<dDelay<1, fraction of a sampling period. No negative values
*     are allowed.
******************************************************************* PACOG ***/

int NonIntegerDelay (double* pdSamples, int iNumSamples, double dDelay)
{
    double coefs[2*FILTER_ORDER+1];
    double* sampTemp;
    double constant;
    double acum;
    int firstCoef;
    int lastCoef;
    int i;
    int j;

    if (pdSamples && iNumSamples>0 && dDelay != 0.0 && fabs (dDelay) <1.0 ) 
    {
    //-- Allocate a temporary buffer to hold the pdSamples to filter. 
    //   The filtered samples go directly into the original buffer.
        
    if ( (sampTemp = new double [iNumSamples + 2*FILTER_ORDER+1]) == 0) 
    {
        return 0;
    }
    memset (sampTemp, 0, sizeof(double)* FILTER_ORDER);
    memcpy (sampTemp+FILTER_ORDER, pdSamples, iNumSamples * sizeof (*pdSamples));   
    memset (sampTemp+iNumSamples+FILTER_ORDER, 0, sizeof(double)* FILTER_ORDER);
  
    // Set up the filter. The amplitude constant does not depend 
    // on the sign of dDelay (sin(-x)= -sin(x))
    constant= fabs( sin(M_PI*dDelay)/M_PI );
    
    // Without windowing, the coefs are samples of abs(1/x)     
    coefs[FILTER_ORDER]=1.0/fabs(dDelay);  

    if (dDelay>0.0) 
    {
        for (j=1;j<=FILTER_ORDER;j++) 
        {
            coefs[FILTER_ORDER+j] = -Sign(j) / (j-(double)dDelay);
            coefs[FILTER_ORDER-j] = Sign(j) / (j+(double)dDelay);
        }
        firstCoef=1;
        lastCoef=2*FILTER_ORDER;
    } 
    else 
    {
        for (j=1;j<=FILTER_ORDER;j++) 
        {
            coefs[FILTER_ORDER-j] = -Sign(j) / (j+(double)dDelay);
            coefs[FILTER_ORDER+j] = Sign(j) / (j-(double)dDelay);
        }
        firstCoef = 0;
        lastCoef  = 2*FILTER_ORDER-1;
    }

    for (i=0;i<iNumSamples;i++) 
    {
        acum = 0.0;
        for (j=firstCoef; j<=lastCoef; j++ ) 
        {
            acum += sampTemp[i+j] * coefs[j];
        } 
        pdSamples[i]=constant*acum;
    }
    delete[] sampTemp;
  }

  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\sigproc\sigprocint.h ===
/******************************************************************************
* sigprocInt.h *
*--------------*
*  I/O library functions for extended speech files (vapi format)
*------------------------------------------------------------------------------
*  Copyright (C) 1999  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef _SIGPROCINT_H_
#define _SIGPROCINT_H_

#include "sigproc.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h>
#include <assert.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\sigproc\sigproc.h ===
/******************************************************************************
* sigproc.h *
*-----------*
*  I/O library functions for extended speech files (vapi format)
*------------------------------------------------------------------------------
*  Copyright (C) 1999  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef _SIGPROC_H_
#define _SIGPROC_H_

#ifndef M_PI
#define M_PI   3.14159265358979323846
#endif

#define LN2    0.6931471806


inline int LpcOrder( int p)
{
    return (int)((p / 1000.0) + 2.5);
}

enum {LPC_ALFA=0, LPC_PARCOR} ;
enum {WINDOW_HAMM, WINDOW_HANN, WINDOW_BLACK, WINDOW_RECT, WINDOW_BART};


double* ComputeWindow (int iType, int iSize, bool bSymmetric);

int     WindowSignal (double* pdSamples, int iNumSamples, int iType, bool bSymmetric);



double* GetDurbinCoef (double* pdData, int iNumData, int iOrder, int iCoefType, double *pdError);

double* Autocor (double* x, int m, int iOrder);

double* DurbinRecursion (double* pdAutoc, int iOrder, int iCoefType, double *pdError);


void    ParcorFilterSyn (double* pdData, int iNumData, double* pdParcor, double* pdMemory, int iOrder);

void    ParcorFilterAn  (double* pdData, int iNumData, double* pdParcor, double* pdMemory, int iOrder);

bool    ParcorToAlfa (double* pdParcor, double* pdAlfa, int iOrder);



double* Cepstrum (double *pdData, int iNumData, int iLpcOrder, int iCepOrder);

void    Alfa2Cepstrum (double* pdAlfa, int iNumAlfa, double* pdCepstrum, int iNumCepstrum);


double  EuclideanDist (double c1[], double c2[], int iLen);

double  Energy (double* pdData, int iNumData, int iWindType);


int     RemoveDc (double* pdSamples, int iNumSamples);

int     Resample (double* pdOriginal, int iNumOrig, 
                  int iInSampFreq, int iOutSampFreq,
                  double** pdResampled, int* iNumResamp);

int     NonIntegerDelay (double* pdSamples, int iNumSamples, double dDelay);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\sigproc\sigproc.cpp ===
/******************************************************************************
* sigproc.cpp *
*-------------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 1999  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "sigprocInt.h"


#define PREEMP_FACTOR  0.97F


/*****************************************************************************
* Cepstrum *
*----------*
*   Description:
*       compute lpc ceptrum form lpc coefficients
*       
******************************************************************* PACOG ***/

double* Cepstrum(double *pdData, int iNumData, int iLpcOrder, int iCepOrder)
{
    double* pdCepCoef = 0;
    double* pdWindow  = 0; 
    double* pdLpcCoef = 0;

    assert(iLpcOrder > 0);
    assert(iCepOrder > 0);

    // get lpc coef 
    pdWindow = ComputeWindow (WINDOW_HAMM, iNumData, false);
    if (!pdWindow) 
    {
        return 0;
    }
  
    for (int i=1; i<iNumData; i++) 
    {
        pdWindow[i] *= pdData[i] - PREEMP_FACTOR * pdData[i-1];
    }

    pdLpcCoef = GetDurbinCoef (pdWindow , iNumData, iLpcOrder, LPC_ALFA, NULL);

    if ((pdCepCoef = new double[iCepOrder]) == 0) 
    {
        return 0;
    }
    Alfa2Cepstrum (pdLpcCoef, iLpcOrder, pdCepCoef, iCepOrder);
  
    delete[] pdWindow;
    delete[] pdLpcCoef;
  
    return pdCepCoef;
}

/*****************************************************************************
* Alfa2Cepstrum *
*---------------*
*   Description:
*       compute lpc cepstrum from lpc coefficients
*       a = alfa (lpc) coefs, input
*       p = order of lpc analysis
*       c = cepstrum coefs, output
*       n = order of cepstral analysis
******************************************************************* PACOG ***/

void Alfa2Cepstrum (double* pdAlfa, int iNumAlfa, double* pdCepstrum, int iNumCepstrum)
{
    double dAux;
    int k;

    pdCepstrum[0] = -pdAlfa[0];
    
    for (int i = 1; i < iNumCepstrum; i++) 
    {
        if (i<iNumAlfa) 
        {
            pdCepstrum[i] = -pdAlfa[i];
        }
        else 
        {
            pdCepstrum[i] = 0.0;
        }

        dAux = 0.0;
    
        for (k = 1; k<=i && k<=iNumAlfa; k++) 
        {     
            dAux += ((double)(i+1-k)/(double)(i+1)) * pdCepstrum[i-k] * pdAlfa[k-1];
        }

        pdCepstrum[i] -= dAux;
    }
}


/*****************************************************************************
* EuclideanDist *
*---------------*
*   Description:
*
******************************************************************* PACOG ***/

double  EuclideanDist (double c1[], double c2[], int iLen)
{
    double dDist = 0.0;

    for (int i = 0; i < iLen; i++) 
    {
        dDist += (c1[i] - c2[i]) * (c1[i] - c2[i]);
    }

    return dDist;
}


/*****************************************************************************
* Energy *
*--------*
*   Description:
*       Compute the time-weighted RMS of a size segment of data.  The data
*     is weighted by a window of type w_type before RMS computation.  w_type
*     is decoded above in window().
******************************************************************* PACOG ***/

double Energy (double* pdData, int iNumData, int iWindType)
{
    static int iWindLen = 0;
    static double *pdWindow = 0;
    double dWData;
    double dSum = 0.0;
  
    assert (pdData);

    if (iWindLen != iNumData) 
    {
        if (pdWindow) 
        {
            delete[] pdWindow;
        }

        pdWindow = ComputeWindow (iWindType, iNumData, false);    
        if (!pdWindow) 
        {
            fprintf (stderr, "Memory error in Energy\n");
            return(0.0);
        }

        iWindLen = iNumData;
    }

    for (int i=0; i<iNumData; i++) 
    {
        dWData = pdData[i] * pdWindow[i];
        dSum += dWData * dWData;
    }

    return (double)sqrt((double)(dSum/iNumData));
}


/*****************************************************************************
* RemoveDc *
*----------*
*   Description:
*
******************************************************************* PACOG ***/

int RemoveDc (double* pdSamples, int iNumSamples)
{
    double dDc = 0.0;

    assert (pdSamples);
    assert (iNumSamples>0);

    for (int i=0; i<iNumSamples; i++) 
    {
        dDc += pdSamples[i];
    }
    dDc /= iNumSamples;
 
    for (i=0; i<iNumSamples; i++) 
    {
        pdSamples[i] -= dDc;
    }

    return (int) dDc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\tsm\tsm.cpp ===
//==========================================================================
//
// tsm.cpp --
// 
//    Copyright (c) 2000 Microsoft Corp.
//    Copyright (c) 1998  Entropic, Inc. 
//    Copyright (c) 1993  Entropic Research Laboratory, Inc. 
//    Copyright (c) 1991-1992 Massachusetts Institute of Technology
//
// WARNING: THE TECHNIQUE USED IN THIS CODE HAS A UNITED STATES PATENT
// PENDING.
//
//==========================================================================

#include "tsm.h"
#include "vapiio.h"
#include <stdlib.h>
#include <assert.h>


static const char *mitcy = "@(#)Copyright (c) 1991-1992, "
       "Massachusetts Institute of Technology\n@(#)All rights reserved";


//--------------------------------------------------------------------------
//
//
//
//--------------------------------------------------------------------------
CTsm::CTsm (double timeScale, int iSampFreq, int* piFrameLen, int* piFrameShift)
{
    double sampFreqFactor;

    assert (iSampFreq>0);
    assert (timeScale>0.0);
      
    m_dScale = timeScale;
    m_iWinLen = 120;
    m_iShiftAna = 80; 
    m_iShiftSyn = 80;
    m_iShiftMax = 100; 

    sampFreqFactor = iSampFreq/8000.0; 

    m_iWinLen   = (int) (m_iWinLen * sampFreqFactor);
    m_iShiftAna = (int) (m_iShiftAna * sampFreqFactor); 
    m_iShiftSyn = (int) (m_iShiftSyn * sampFreqFactor);
    m_iShiftMax = (int) (m_iShiftMax * sampFreqFactor);

    m_iFrameLen   = m_iWinLen + m_iShiftMax;
    m_iFrameShift = (int) (m_iShiftAna * timeScale);
    m_iNumPts     = m_iWinLen - m_iShiftSyn;

    m_pfOldTail = new double[m_iFrameLen];

    if ( piFrameLen && piFrameShift )
    {
        if ( m_pfOldTail==NULL) 
        {
            *piFrameLen = 0;
            *piFrameShift = 0;
        }
        else 
        {
            *piFrameLen   = m_iFrameLen;
            *piFrameShift = m_iFrameShift;
        }
    }
}

//--------------------------------------------------------------------------
//
//
//
//--------------------------------------------------------------------------

CTsm::~CTsm ()
{
    assert (m_pfOldTail);
  
    if (m_pfOldTail)
    {
        delete[] m_pfOldTail;
    }    
}


//--------------------------------------------------------------------------
//
//
//
//--------------------------------------------------------------------------

int CTsm::SetScaleFactor (double timeScale)
{
    assert (timeScale>0.0);

    m_dScale = timeScale;

    if (timeScale > 0.0) 
    {
        m_iFrameShift = (int) (m_iShiftAna * timeScale);
    }

    return m_iFrameShift;
}

//--------------------------------------------------------------------------
//
// Returns iSampFreq if successful
//
//--------------------------------------------------------------------------
int CTsm::SetSamplingFrequency (int iSampFreq)
{
    double sampFreqFactor;

    assert (iSampFreq>0.0);

    m_iWinLen = 120;
    m_iShiftAna = 80; 
    m_iShiftSyn = 80;
    m_iShiftMax = 100; 

    sampFreqFactor = iSampFreq/8000.0; 

    m_iWinLen   = (int) (m_iWinLen * sampFreqFactor);
    m_iShiftAna = (int) (m_iShiftAna * sampFreqFactor); 
    m_iShiftSyn = (int) (m_iShiftSyn * sampFreqFactor);
    m_iShiftMax = (int) (m_iShiftMax * sampFreqFactor);

    m_iFrameLen   = m_iWinLen + m_iShiftMax;
    m_iFrameShift = (int) (m_iShiftAna * m_dScale);
    m_iNumPts     = m_iWinLen - m_iShiftSyn;

    if ( m_pfOldTail )
    {
        delete [] m_pfOldTail;
        m_pfOldTail = NULL;
    }

    m_pfOldTail = new double[m_iFrameLen];

    if ( m_pfOldTail )
    {
        return iSampFreq;
    }
    else
    {
        return 0;
    }

}


//--------------------------------------------------------------------------
//
//
//
//--------------------------------------------------------------------------

int CTsm::FirstFrame (double* buffer)
{
    int i;
    
    assert (buffer);
    
    for (i = 0; i < m_iNumPts; i++) 
    {
        m_pfOldTail[i] = buffer[m_iShiftSyn+i];
    }
    
    m_iLag = 0;
    
    return m_iShiftSyn;
}

//--------------------------------------------------------------------------
//
//
//
//--------------------------------------------------------------------------

int CTsm::AddFrame (double* buffer, int* lag, int* nSamp)
{
    int i;
    int prevLag;
    
    assert (buffer);
    
    prevLag = m_iLag + m_iShiftSyn - m_iFrameShift;
    
    if ( (0 <= prevLag) && (prevLag <= m_iShiftMax)) 
    {
        m_iLag = prevLag;
    }
    else 
    {
        m_iLag = Crosscor(m_pfOldTail, buffer, m_iShiftMax, m_iNumPts);
    }
    
    // This loop is the overlap-add step
    for (i=0; i<m_iNumPts; i++) 
    {
        buffer[m_iLag+i] = ((m_pfOldTail[i] * (m_iNumPts - i)) + (buffer[m_iLag+i] * i)) / m_iNumPts;
    }
    
    *lag = m_iLag;
    *nSamp = m_iShiftSyn;
    
    for (i=0; i<m_iNumPts; i++) 
    {
        m_pfOldTail[i] = buffer[m_iLag + m_iShiftSyn + i];
    }
    
    return  (m_iLag + m_iShiftSyn);
}

//--------------------------------------------------------------------------
//
//
//
//--------------------------------------------------------------------------

int CTsm::LastFrame (double* buffer, int buffLen, int* lag, int *nSamp)
{
    int i;
    
    assert (buffer);
    assert (buffLen>0);
    assert (lag);
    assert (nSamp);
    
    for (i=0; i<m_iNumPts && i < buffLen; i++) 
    {
        buffer[i] = ((m_pfOldTail[i] * (m_iNumPts - i)) + (buffer[i] * i)) / m_iNumPts;
    }
    
    *lag = 0;
    *nSamp = buffLen;
    
    return buffLen;
}

//--------------------------------------------------------------------------
//
//
//
//--------------------------------------------------------------------------

int  CTsm::Crosscor(double* oldwin, double* newwin, int kmax, int numPts)
{
    double xcor;
    double xcormax;
    double numer;
    double denom;
    double *rgdenom=NULL;
    int bestk;
    int k;
    int i;
    
    bestk = 0;
    xcormax = 0.0;
    denom = 0.0;

    if (NULL == (rgdenom = new double[kmax+numPts+1]))
        return 0;

    // Precalculate the denominator values.  The denominator is the sum of the square of a set of
    // newwin samples, so square all of them, and sum the appropriate set.  We're calculating one
    // extra because the update goes one beyond the last window.
    for (k=0; k <numPts+kmax+1; k++)
    {
        rgdenom[k] = newwin[k] * newwin[k];
    }
    for (k=0; k < numPts; k++)
    {
        denom += rgdenom[k];
    }
    
    for (k=0; k <= kmax; k++) 
    {        
        numer = 0.0;
        
        for (i = 0; i < numPts; i++) 
        { 
            numer += oldwin[i] * newwin[k+i]; 
        }

        // A shift can only be the best if the correlation is positive.
        if (numer > 0)
        {
            xcor = (numer * numer)/denom;
            if (xcor > xcormax) 
            {
                xcormax = xcor;
                bestk = k;
            }
        }
        // Shift the denomination window one sample
        denom = denom - rgdenom[k] + rgdenom[k + numPts];
    }
    
    delete rgdenom;
    return bestk;
}


//--------------------------------------------------------------------------
// 
// Adjusts time scale putting resulting samples in ppvOutSamples.
// Converts format if necessary.
//
//---------------------------------------------------------- JOEM 01/2001 --

int  CTsm::AdjustTimeScale(const void* pvInSamples, const int iNumInSamples, 
                           void** ppvOutSamples, int* piNumOutSamples, WAVEFORMATEX* pFormat )
{
    char*   pcSamples       = NULL;
    short*  pnSamples       = NULL;
    short*  pnOutSamples    = NULL;
    double* pdBuffer        = NULL;

    int     iFrameLen       = 0;
    int     iFrameShift     = 0;
    int     firstSample     = 0;
    int     lag             = 0;
    int     lastSamp        = 0;
    bool    fSamplesEnd     = false;
    int     i               = 0;

    if ( iNumInSamples <= m_iFrameLen )
    {
        goto error;
    }

    int iInFormatType  = VapiIO::TypeOf (pFormat);

    if ( iInFormatType == VAPI_ALAW || iInFormatType == VAPI_ULAW )
    {
        //--- Convert samples to VAPI_PCM16
        pnSamples = new short [iNumInSamples];
        if ( !pnSamples )
        {
            goto error;
        }
        
        if ( 0 == VapiIO::DataFormatConversion ((char *)pvInSamples, iInFormatType, (char*)pnSamples, VAPI_PCM16, iNumInSamples) )
        {
            goto error;
        }
    }
    else if ( iInFormatType == VAPI_PCM8 )
    {
        // cast to char
        pcSamples = (char*) pvInSamples;
    }
    else if ( iInFormatType == VAPI_PCM16 )
    {
        // cast to short
        pnSamples = (short*) pvInSamples;
    }
    else
    {
        goto error;
    }
    

    iFrameLen = m_iFrameLen;
    iFrameShift = m_iFrameShift;

    // pdBuffer big enough for one frame
    pdBuffer = new double[iFrameLen];
    if ( !pdBuffer )
    {
        goto error;
    }
    
    // new data buffer overestimates the size that might be needed.
    // Actual sample count is accumulated below.

    // make SURE to overestimate the number of samples needed, so arbitrarily
    // add 1 to the rate before multiplying the sample count.
    double dRate = 1.0/m_dScale + 1;
    *piNumOutSamples = (int) ( dRate * iNumInSamples );
    
    pnOutSamples = new short[*piNumOutSamples];
    if ( !pnOutSamples )
    {
        goto error;
    }

    int iSamp   = 0;


    // First frame to process
    if ( pcSamples )
    {
        for ( i=0; i<iFrameLen; i++ )
        {
            pdBuffer[i] = (double) pcSamples[i];
        }
    }
    else if ( pnSamples )
    {
        for ( i=0; i<iFrameLen; i++ )
        {
            pdBuffer[i] = (double) pnSamples[i];
        }
    }
    else
    {
        goto error;
    }
    lastSamp = FirstFrame(pdBuffer);

    if ( pcSamples )
    {
        for ( i=0; i<lastSamp; i++ )
        {
            pnOutSamples[i] = (short) pcSamples[i];
        }
    }
    else if ( pnSamples )
    {
        for ( i=0; i<lastSamp; i++ )
        {
            pnOutSamples[i] = pnSamples[i];
        }
    }
    else
    {
        goto error;
    }
    *piNumOutSamples = lastSamp;
        
    // LOOP OVER FRAMES
    while ( !fSamplesEnd )
    {
        if ( pcSamples )
        {
            for ( i=0; i<iFrameLen; i++ )
            {
                if ( firstSample + i < iNumInSamples )
                {
                    pdBuffer[i] = (double) pcSamples[firstSample + i];
                }
                else 
                {
                    iFrameLen = i;
                    fSamplesEnd = true;
                    break;
                }
            }
        }
        else if ( pnSamples )
        {
            for ( i=0; i<iFrameLen; i++ )
            {
                if ( firstSample + i < iNumInSamples )
                {
                    pdBuffer[i] = (double) pnSamples[firstSample + i];
                }
                else 
                {
                    iFrameLen = i;
                    fSamplesEnd = true;
                    break;
                }
            }
        }
        else
        {
            goto error;
        }

        if ( fSamplesEnd )
        {
            if ( iFrameLen > 0 )
            {
                lastSamp = LastFrame (pdBuffer, iFrameLen, &lag, &iSamp);
            }
            else
            {
                iSamp = 0; lag = 0;
            }
        } 
        else
        {
            lastSamp = AddFrame (pdBuffer, &lag, &iSamp);
        }            
            
        for ( i=0; i<iSamp; i++ )
        {
            pnOutSamples[i+*piNumOutSamples] = (short)(pdBuffer[i+lag]);
        }
        *piNumOutSamples += iSamp;
        
        firstSample += iFrameShift;
    }
        
    // Flush the remaining samples
    if ( iFrameLen > lastSamp ) 
    {
        for ( i=0; i < iFrameLen - lastSamp; i++ )
        {
            pnOutSamples[i+*piNumOutSamples] = (short)pdBuffer[i+lastSamp];
        }
        *piNumOutSamples += ( iFrameLen - lastSamp );
    }

    if ( pdBuffer )
    {
        delete [] pdBuffer;
        pdBuffer = NULL;
    }
    if ( pnSamples && pnSamples != pvInSamples ) // might have allocated, or might have just cast.
    {
        delete [] pnSamples;
        pnSamples = NULL;
    }


    // DO WE NEED TO CONVERT BACK?
    if ( iInFormatType == VAPI_ALAW )
    {
        //--- Convert samples back
        *ppvOutSamples = new char [*piNumOutSamples];
        if ( !*ppvOutSamples )
        {
            goto error;
        }
        
        if ( 0 == VapiIO::DataFormatConversion ((char*)pnOutSamples, VAPI_PCM16, (char*)*ppvOutSamples, iInFormatType, *piNumOutSamples) )
        {
            goto error;
        }
        delete [] pnOutSamples;
        pnOutSamples = NULL;
    }
    if ( iInFormatType == VAPI_ULAW )
    {
        //--- Convert samples back
        *ppvOutSamples = new char [*piNumOutSamples];
        if ( !*ppvOutSamples )
        {
            goto error;
        }
        
        if ( 0 == VapiIO::DataFormatConversion ((char*)pnOutSamples, VAPI_PCM16, (char*)*ppvOutSamples, iInFormatType, *piNumOutSamples) )
        {
            goto error;
        }
        delete [] pnOutSamples;
        pnOutSamples = NULL;
    }
    if ( iInFormatType == VAPI_PCM8 )
    {
        //--- Convert samples back
        *ppvOutSamples = new char [*piNumOutSamples];
        if ( !*ppvOutSamples )
        {
            goto error;
        }
        
        if ( 0 == VapiIO::DataFormatConversion ((char*)pnOutSamples, VAPI_PCM16, (char*)*ppvOutSamples, iInFormatType, *piNumOutSamples) )
        {
            goto error;
        }
        delete [] pnOutSamples;
        pnOutSamples = NULL;

    }
    else if ( iInFormatType == VAPI_PCM16 )
    {
        *ppvOutSamples = pnOutSamples; // blocksize is already short
    }
    else
    {
        return 0;
    }
 
    return 1;

error:
    if ( pnSamples && pnSamples != pvInSamples ) // might have allocated, or might have just cast.
    {
        delete [] pnSamples;
    }
    if ( pnOutSamples )
    {
        delete [] pnOutSamples;
    }
    if ( pdBuffer )
    {
        delete [] pdBuffer;
    }
    if ( *ppvOutSamples )
    {
        delete [] (*ppvOutSamples);
        *ppvOutSamples = NULL;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\sigproc\window.cpp ===
/******************************************************************************
* window.cpp *
*------------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 1999  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "sigprocInt.h"

static double* Rectangular (int iLength);
static double* Bartlett    (int iLength, bool bSymmetric);
static double* Hanning     (int iLength, bool bSymmetric);
static double* Hamming     (int iLength, bool bSymmetric);
static double* Blackman    (int iLength, bool bSymmetric);


/*****************************************************************************
* WindowSignal *
*--------------*
*   Description:
*        Multiplies the input signal by a window. The window length is 
*     the length of the vector. The window is symmetrical if symmetry != 0.
*   Parameters:
*        samples: Vector to input data. It is modified by the routine.
*        type:    Type of window, must be one of the types defined in lpc.h
******************************************************************* PACOG ***/

int WindowSignal (double* pdSamples, int iNumSamples, int iWindType, bool bSymmetric)
{
    double* pdWindow;

    assert (pdSamples);
    assert (iNumSamples>0);
    
    if ( (pdWindow = ComputeWindow(iWindType, iNumSamples, bSymmetric)) == 0) 
    {
        return 0;
    }
    
    for (int i=0; i<iNumSamples; i++) 
    {
        pdSamples[i] *= pdWindow[i];
    }
    
    delete[] pdWindow;
    
    return 1;
}

/*****************************************************************************
* ComputeWindow *
*---------------*
*   Description:
*       This is a dispatch function, calling the appropiate function
*     to compute every different type of window.
*   Parameters: 
*       Window type and length
*   Returns: 
*       A vector containing the computed window.
******************************************************************* PACOG ***/

double* ComputeWindow (int iWindType, int iWindLen, bool bSymmetric)
{
    double* pdWind = NULL;
    
    assert (iWindLen>0);  
    
    if (iWindLen<=0) 
    {
        //fprintf (stderr, "Zero length window requested in ComputeWindow");
        return 0;
    }
    
    switch (iWindType) 
    {
    case WINDOW_RECT:
        pdWind = Rectangular (iWindLen);
        break;
    case WINDOW_BART:
        pdWind = Bartlett (iWindLen, bSymmetric);
        break;
    case WINDOW_HANN:
        pdWind = Hanning (iWindLen, bSymmetric);
        break;
    case WINDOW_HAMM:
        pdWind = Hamming (iWindLen, bSymmetric);
        break;
    case WINDOW_BLACK:
        pdWind = Blackman (iWindLen, bSymmetric);
        break;    
    default:
        //fprintf(stderr, "Window type not known");
        return 0;
    }
    
    return pdWind;
}

/*****************************************************************************
* Rectangular *
*-------------*
*   Description:
*       Returns a unit vector of the specified length.
******************************************************************* PACOG ***/

double* Rectangular (int iLength)
{
    double* pdWindow;

    if ((pdWindow = new double[iLength]) != 0) 
    {
        for (int i=0; i<iLength; i++) 
        {
            pdWindow[i]=1.0;
        }
    }

    return pdWindow;
}

/*****************************************************************************
* Bartlett *
*----------*
*   Description:
*       Returns a vector with a Bartlett window of the specified length.
******************************************************************* PACOG ***/

double* Bartlett (int iLength, bool bSymmetric)
{
    double* pdWindow;
    double dStep;

    if ((pdWindow = new double[iLength]) != 0)
    {
        if (bSymmetric) 
        {
            dStep=2.0/(iLength-1);
        }
        else 
        {
            dStep=2.0/iLength;
        }

        for (int i=0; i<iLength/2; i++) 
        {
            pdWindow[i] = i * dStep;
            pdWindow[iLength/2+i] = 1.0 - i * dStep;
        }

        if (iLength %2) 
        {
            if (bSymmetric) 
            {
                pdWindow[iLength-1] = pdWindow[0];  
            } 
            else 
            {
                pdWindow[iLength-1] = pdWindow[1];  
            }
        }
    }

    return pdWindow;
}

/*****************************************************************************
* Hamming *
*---------*
*   Description:
*        Returns a vector with a Hamming window of the specified length.
******************************************************************* PACOG ***/

double* Hamming (int iLength, bool bSymmetric)
{
    double* pdWindow;
    double dArg;

    if ((pdWindow = new double[iLength]) != 0)
    {
  
        dArg=2.0*M_PI;
        if (bSymmetric) 
        {
            dArg/=(double)(iLength - 1);
        }
        else 
        {
            dArg/=(double)iLength;
        }

        for (int i=0; i<iLength; i++) 
        {
            pdWindow[i]=0.54 - (0.46*cos(dArg*(double)i));
        }
    }
    return pdWindow;
}

/*****************************************************************************
* Hanning *
*---------*
*   Description:
*        Returns a vector with a Hamming window of the specified length.
******************************************************************* PACOG ***/

double* Hanning (int iLength, bool bSymmetric)
{
    double* pdWindow;
    double dArg;

    if ((pdWindow = new double[iLength]) != 0)
    {

        dArg=2.0*M_PI;
        if (bSymmetric) 
        {
            dArg/=(double)(iLength - 1);
        }
        else 
        {
            dArg/=(double)iLength;
        }

        for (int i=0; i<iLength; i++) 
        {
            pdWindow[i]=0.5 - (0.5*cos(dArg*(double)i));
        }
    }

    return pdWindow;
}

/*****************************************************************************
* Blackman *
*----------*
*   Description:
*       Returns a vector with a Blackman window of the specified length.
******************************************************************* PACOG ***/

double* Blackman (int iLength, bool bSymmetric)
{
    double* pdWindow;
    double dArg, dArg2;
  
    if ((pdWindow = new double[iLength]) != 0)
    {
        dArg=2.0*M_PI;
        if (bSymmetric) 
        {
            dArg/=(double)(iLength - 1);
        }
        else 
        {
            dArg/=(double)iLength;
        }

        dArg2=2.0*dArg;
        
        for (int i=0; i<iLength; i++) 
        {
            pdWindow[i]=0.42 - (0.5*cos(dArg*(double)i)) + (0.08*cos(dArg2*(double)i));
        }
    }

    return pdWindow;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\tsm\tsm.h ===
//==========================================================================
//
// tsm.h --
//
// Class definition for the time-scale modification algorithm 
//
//==========================================================================

#ifndef _TSM_H_
#define _TSM_H_

#include <windows.h>
#include <mmreg.h>

class CTsm
{
    public:
        CTsm (double timeScale, int iSampFreq = 8000, int* piFrameLen = 0, int* piFrameShift = 0);
        ~CTsm();

        int SetScaleFactor (double timeScale);
        int SetSamplingFrequency (int iSampFreq);
        double GetScaleFactor () { return m_dScale; }
        
        int FirstFrame (double* pdBuffer);
        int AddFrame   (double* pdBuffer, int* piLag, int* piNumSamp);        
        int LastFrame  (double* pdBuffer, int iBufLen, int* piLag, int* piNumSamp);
        int GetFrameLen() { return m_iFrameLen; }
        int GetFrameShift() { return m_iFrameShift; }
        int AdjustTimeScale(const void* pvInSamples, const int iNumInSamples, 
                           void** ppvOutSamples, int* piNumOutSamples, WAVEFORMATEX* pFormat);

    private:
        int Crosscor (double* pdFirst, double* pdSecond, int iNumXCor, int iNumPts);        
        
        int m_iWinLen;
        int m_iShiftAna;
        int m_iShiftSyn;
        int m_iShiftMax;
        int m_iFrameLen;
        int m_iFrameShift;
        int m_iNumPts;  
        int m_iLag;
        double m_dScale;

        double* m_pfOldTail;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\sigproc\resample.cpp ===
/******************************************************************************
* resample.cpp *
*--------------*
*  
*------------------------------------------------------------------------------
*  Copyright (C) 1999  Entropic, Inc
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "sigprocInt.h"

#define FILTER_LEN_2  .005 //(sec)

static double* WindowedLowPass (double dCutOff, double dGain, int iHalfLen);

static void FindResampleFactors (int iInSampFreq, int iOutSampFreq, 
                                 int* piUpFactor, int* piDownFactor);



/*****************************************************************************
* Resample *
*----------*
*   Description:
*
******************************************************************* PACOG ***/

int Resample (double* pdOriginal, int iNumOrig, int iInSampFreq, int iOutSampFreq,
              double** ppdResampled, int* piNumResamp)
{
    int iUpFactor;
    int iDownFactor;
    int iLimitFactor;
    double* pdFilterCoef;
    int iHalfLen;
    int iFilterLen;
    double dAcum;
    int iPhase;
    int i;
    int j;
    int n;

    assert (pdOriginal);
    assert (iNumOrig >0);
    assert (ppdResampled);
    assert (piNumResamp);
    assert (iInSampFreq >0);
    assert (iOutSampFreq >0);

    FindResampleFactors (iInSampFreq, iOutSampFreq, &iUpFactor, &iDownFactor);
    iLimitFactor = (iUpFactor>iDownFactor)? iUpFactor: iDownFactor;

    iHalfLen   = (int)(iInSampFreq * iLimitFactor * FILTER_LEN_2);
    iFilterLen =  2 * iHalfLen + 1;

    if (! (pdFilterCoef = WindowedLowPass(.5/iLimitFactor, iUpFactor, iHalfLen))) 
    {        
        return false;
    }

    *piNumResamp = (iNumOrig * iUpFactor) / iDownFactor;
    *ppdResampled = new double[*piNumResamp];
    if (*ppdResampled == 0) 
    {
        fprintf (stderr, "Memory error\n");
        return false;
    }

    for (i=0; i<*piNumResamp; i++) 
    {
        dAcum = 0.0;

        n = (int )((i * iDownFactor - iHalfLen) / (double)iUpFactor);
        iPhase = (i*iDownFactor) - (n*iUpFactor + iHalfLen);
    
        for (j=0; j<iFilterLen/iUpFactor; j++) 
        {
            if ( (n+j >=0) && (n+j < iNumOrig) && (iUpFactor*j > iPhase)) 
            {
                dAcum += pdOriginal[n + j] * pdFilterCoef[iUpFactor * j - iPhase];
            }
        }
        (*ppdResampled)[i] = dAcum;

    }

    return true;
}

/*****************************************************************************
* WindowedLowPass *
*-----------------*
*   Description:
*       Creates a low pass filter using the windowing method.
*       CutOff is spec. in normalized frequency
******************************************************************* PACOG ***/

double* WindowedLowPass (double dCutOff, double dGain, int iHalfLen)
{
    double* pdCoeffs;  
    double* pdWindow;
    double dArg;
    double dSinc;
    int iFilterLen = iHalfLen*2 +1;
    int i;
  
    assert (dCutOff>0.0 && dCutOff<0.5);

    pdWindow = ComputeWindow(WINDOW_BLACK, iFilterLen, true);
    if (!pdWindow)
    {
        return 0;
    }

    pdCoeffs = new double[iFilterLen];

    if (pdCoeffs) 
    {
        dArg = 2.0 * M_PI * dCutOff;
        pdCoeffs[iHalfLen] = (double)(dGain * 2.0 * dCutOff);

        for (i=1; i<=iHalfLen; i++) 
        {
            dSinc = dGain * sin(dArg*i)/(M_PI*i) * pdWindow[iHalfLen- i];
            pdCoeffs[iHalfLen+i] = (double)dSinc;
            pdCoeffs[iHalfLen-i] = (double)dSinc;
        }   
    }

    delete[] pdWindow;

    return pdCoeffs;
}
/*****************************************************************************
* FindResampleFactors *
*---------------------*
*   Description:
*
******************************************************************* PACOG ***/

void FindResampleFactors (int iInSampFreq, int iOutSampFreq, int* piUpFactor, int* piDownFactor)
{
    static int aiPrimes[] = {2,3,5,7,11,13,17,19,23,29,31,37};
    static int iNumPrimes = sizeof (aiPrimes) / sizeof(aiPrimes[0]);
    int iDiv = 1;
    int i;

    assert (piUpFactor);
    assert (piDownFactor);

    while (iDiv) 
    {
        iDiv = 0;
        for (i=0; i<iNumPrimes;i++) 
        {
            if ( (iInSampFreq % aiPrimes[i]) == 0 && (iOutSampFreq % aiPrimes[i]) == 0 )
            {
                iInSampFreq/=aiPrimes[i];
                iOutSampFreq/=aiPrimes[i];
                iDiv = 1;
                break;
            }
        }   
    }

    *piUpFactor   = iOutSampFreq;
    *piDownFactor = iInSampFreq;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\vapiio\alaw_ulaw.cpp ===
/******************************************************************************
* alaw_ulaw.cpp *
*---------------*
*  Conversion routines from pcm to alaw, ulaw, and alaw-ulaw conversion.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/
#include "vapiIoInt.h"


// copy from CCITT G.711 specifications 

// u- to A-law conversions 
unsigned char s_U2A[128] = 
{            
    1,  1,  2,  2,  3,  3,  4,  4,
    5,  5,  6,  6,  7,  7,  8,  8,
    9,  10, 11, 12, 13, 14, 15, 16,
    17, 18, 19, 20, 21, 22, 23, 24,
    25, 27, 29, 31, 33, 34, 35, 36,
    37, 38, 39, 40, 41, 42, 43, 44,
    46, 48, 49, 50, 51, 52, 53, 54,
    55, 56, 57, 58, 59, 60, 61, 62,
    64, 65, 66, 67, 68, 69, 70, 71,
    72, 73, 74, 75, 76, 77, 78, 79,
    81, 82, 83, 84, 85, 86, 87, 88,
    89, 90, 91, 92, 93, 94, 95, 96,
    97, 98, 99, 100, 101, 102, 103, 104,
    105, 106, 107, 108, 109, 110, 111, 112,
    113, 114, 115, 116, 117, 118, 119, 120,
    121, 122, 123, 124, 125, 126, 127, 128
};

// A- to u-law conversions 
unsigned char s_A2U[128] = 
{            
    1,  3,  5,  7,  9,  11, 13, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, 31,
    32, 32, 33, 33, 34, 34, 35, 35,
    36, 37, 38, 39, 40, 41, 42, 43,
    44, 45, 46, 47, 48, 48, 49, 49,
    50, 51, 52, 53, 54, 55, 56, 57,
    58, 59, 60, 61, 62, 63, 64, 64,
    65, 66, 67, 68, 69, 70, 71, 72,
    73, 74, 75, 76, 77, 78, 79, 79,
    80, 81, 82, 83, 84, 85, 86, 87,
    88, 89, 90, 91, 92, 93, 94, 95,
    96, 97, 98, 99, 100, 101, 102, 103,
    104, 105, 106, 107, 108, 109, 110, 111,
    112, 113, 114, 115, 116, 117, 118, 119,
    120, 121, 122, 123, 124, 125, 126, 127
};

/*****************************************************************************
* Alaw2Ulaw *
*-----------*
*   Description:
*       A-law to u-law conversion      
******************************************************************* PACOG ***/
unsigned char Alaw2Ulaw (unsigned char ucAVal)
{
    ucAVal &= 0xff;

    return ((ucAVal & 0x80) ? (0xFF ^ s_A2U[ucAVal ^ 0xD5]) : (0x7F ^ s_A2U[ucAVal ^ 0x55]));
}


/*****************************************************************************
* Ulaw2Alaw *
*-----------*
*   Description:
*       u-law to A-law conversion 
******************************************************************* PACOG ***/
unsigned char Ulaw2Alaw (unsigned char ucUVal)
{
    ucUVal &= 0xff;
    return ((ucUVal & 0x80) ? (0xD5 ^ (s_U2A[0xFF ^ ucUVal] - 1)) : (0x55 ^ (s_U2A[0x7F ^ ucUVal] - 1)));
}



#ifndef FAST_CONVERSION

/*
** This routine converts from linear to ulaw.
**
** Craig Reese: IDA/Supercomputing Research Center
** Joe Campbell: Department of Defense
** 29 September 1989
**
** References:
** 1) CCITT Recommendation G.711  (very difficult to follow)
** 2) "A New Digital Technique for Implementation of Any
**     Continuous PCM Companding Law," Villeret, Michel,
**     et al. 1973 IEEE Int. Conf. on Communications, Vol 1,
**     1973, pg. 11.12-11.17
** 3) MIL-STD-188-113,"Interoperability and Performance Standards
**     for Analog-to_Digital Conversion Techniques,"
**     17 February 1987
**
** Input: Signed 16 bit linear sample
** Output: 8 bit ulaw sample
*/

#undef ZEROTRAP      /* turn off the trap as per the MIL-STD */
#define uBIAS 0x84   /* define the add-in bias for 16 bit samples */
#define uCLIP 32635
#define ACLIP 31744

      
/*
 * A-law routines by Graeme W. Gill.
 * Date: 93/5/7
 *
 * References:
 * 1) CCITT Recommendation G.711
 *
 * These routines were used to create the fast
 * lookup tables.
 */
      
#define ACLIP 31744
      
unsigned char
Linear2Alaw ( int sample )
{
  static int exp_lut[128] = {
    1,1,2,2,3,3,3,3,
    4,4,4,4,4,4,4,4,
    5,5,5,5,5,5,5,5,
    5,5,5,5,5,5,5,5,
    6,6,6,6,6,6,6,6,
    6,6,6,6,6,6,6,6,
    6,6,6,6,6,6,6,6,
    6,6,6,6,6,6,6,6,
    7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7};
        
  int sign, exponent, mantissa;
  unsigned char Alawbyte;
        
  /* Get the sample into sign-magnitude. */
  sign = ((~sample) >> 8) & 0x80;   /* set aside the sign */
  if ( sign == 0 ) sample = -sample;    /* get magnitude */
  if ( sample > ACLIP ) sample = ACLIP; /* clip the magnitude */
  
  /* Convert from 16 bit linear to ulaw. */
  if (sample >= 256) {
    exponent = exp_lut[( sample >> 8 ) & 0x7F];
    mantissa = ( sample >> ( exponent + 3 ) ) & 0x0F;
    Alawbyte = (( exponent << 4 ) | mantissa);
  } else {
    Alawbyte = (sample >> 4);
  }

  Alawbyte ^= (sign ^ 0x55);
  return Alawbyte;
}
      
int
Alaw2Linear( unsigned char Alawbyte )
{
  static int exp_lut[8] = { 0, 264, 528, 1056, 2112, 4224, 8448, 16896 };
  int sign, exponent, mantissa, sample;
  
  Alawbyte ^= 0x55;
  sign = ( Alawbyte & 0x80 );
  Alawbyte &= 0x7f;     /* get magnitude */
  if (Alawbyte >= 16) {
    exponent = (Alawbyte >> 4 ) & 0x07;
    mantissa = Alawbyte & 0x0F;
    sample = exp_lut[exponent] + ( mantissa << ( exponent + 3 ) );
  } else {
    sample = (Alawbyte << 4) + 8;
  }
  if ( sign == 0 ) sample = -sample;
        
  return sample;
}
      
unsigned char
Linear2Ulaw( int sample )
{
  static int exp_lut[256] = {0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
    4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7};
  int sign, exponent, mantissa;
  unsigned char ulawbyte;
  
  /* Get the sample into sign-magnitude. */
  sign = (sample >> 8) & 0x80;    /* set aside the sign */
  if ( sign != 0 ) sample = -sample;    /* get magnitude */
  if ( sample > uCLIP ) sample = uCLIP;   /* clip the magnitude */
  
  /* Convert from 16 bit linear to ulaw. */
  sample = sample + uBIAS;
  exponent = exp_lut[( sample >> 7 ) & 0xFF];
  mantissa = ( sample >> ( exponent + 3 ) ) & 0x0F;
  ulawbyte = ~ ( sign | ( exponent << 4 ) | mantissa );
#ifdef ZEROTRAP
  if ( ulawbyte == 0 ) ulawbyte = 0x02; /* optional CCITT trap */
#endif
  
  return ulawbyte;
}

/*
** This routine converts from ulaw to 16 bit linear.
**
** Craig Reese: IDA/Supercomputing Research Center
** 29 September 1989
**
** References:
** 1) CCITT Recommendation G.711  (very difficult to follow)
** 2) MIL-STD-188-113,"Interoperability and Performance Standards
**     for Analog-to_Digital Conversion Techniques,"
**     17 February 1987
**
** Input: 8 bit ulaw sample
** Output: signed 16 bit linear sample
*/

int
Ulaw2Linear ( unsigned char ulawbyte )
{
  static int exp_lut[8] = { 0, 132, 396, 924, 1980, 4092, 8316, 16764 };
  int sign, exponent, mantissa, sample;
  
  ulawbyte = ~ ulawbyte;
  sign = ( ulawbyte & 0x80 );
  exponent = ( ulawbyte >> 4 ) & 0x07;
  mantissa = ulawbyte & 0x0F;
  sample = exp_lut[exponent] + ( mantissa << ( exponent + 3 ) );
  if ( sign != 0 ) sample = -sample;
  
  return sample;
}

#else

unsigned char ulaw_comp_table[16384] = {
  0xff,0xfe,0xfe,0xfd,0xfd,0xfc,0xfc,0xfb,
  0xfb,0xfa,0xfa,0xf9,0xf9,0xf8,0xf8,0xf7,
  0xf7,0xf6,0xf6,0xf5,0xf5,0xf4,0xf4,0xf3,
  0xf3,0xf2,0xf2,0xf1,0xf1,0xf0,0xf0,0xef,
  0xef,0xef,0xef,0xee,0xee,0xee,0xee,0xed,
  0xed,0xed,0xed,0xec,0xec,0xec,0xec,0xeb,
  0xeb,0xeb,0xeb,0xea,0xea,0xea,0xea,0xe9,
  0xe9,0xe9,0xe9,0xe8,0xe8,0xe8,0xe8,0xe7,
  0xe7,0xe7,0xe7,0xe6,0xe6,0xe6,0xe6,0xe5,
  0xe5,0xe5,0xe5,0xe4,0xe4,0xe4,0xe4,0xe3,
  0xe3,0xe3,0xe3,0xe2,0xe2,0xe2,0xe2,0xe1,
  0xe1,0xe1,0xe1,0xe0,0xe0,0xe0,0xe0,0xdf,
  0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xde,
  0xde,0xde,0xde,0xde,0xde,0xde,0xde,0xdd,
  0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdc,
  0xdc,0xdc,0xdc,0xdc,0xdc,0xdc,0xdc,0xdb,
  0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xda,
  0xda,0xda,0xda,0xda,0xda,0xda,0xda,0xd9,
  0xd9,0xd9,0xd9,0xd9,0xd9,0xd9,0xd9,0xd8,
  0xd8,0xd8,0xd8,0xd8,0xd8,0xd8,0xd8,0xd7,
  0xd7,0xd7,0xd7,0xd7,0xd7,0xd7,0xd7,0xd6,
  0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0xd5,
  0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,0xd4,
  0xd4,0xd4,0xd4,0xd4,0xd4,0xd4,0xd4,0xd3,
  0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd2,
  0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,0xd1,
  0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd0,
  0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xcf,
  0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,
  0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xce,
  0xce,0xce,0xce,0xce,0xce,0xce,0xce,0xce,
  0xce,0xce,0xce,0xce,0xce,0xce,0xce,0xcd,
  0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,
  0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcc,
  0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,
  0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcb,
  0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,
  0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xca,
  0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,
  0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xc9,
  0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,
  0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc8,
  0xc8,0xc8,0xc8,0xc8,0xc8,0xc8,0xc8,0xc8,
  0xc8,0xc8,0xc8,0xc8,0xc8,0xc8,0xc8,0xc7,
  0xc7,0xc7,0xc7,0xc7,0xc7,0xc7,0xc7,0xc7,
  0xc7,0xc7,0xc7,0xc7,0xc7,0xc7,0xc7,0xc6,
  0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,
  0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc5,
  0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,
  0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc4,
  0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,
  0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc3,
  0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,
  0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc2,
  0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,
  0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0xc1,
  0xc1,0xc1,0xc1,0xc1,0xc1,0xc1,0xc1,0xc1,
  0xc1,0xc1,0xc1,0xc1,0xc1,0xc1,0xc1,0xc0,
  0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
  0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xbf,
  0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,
  0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,
  0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,
  0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbe,
  0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,
  0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,
  0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,
  0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbd,
  0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,
  0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,
  0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,
  0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbc,
  0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,
  0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,
  0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,
  0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbb,
  0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,
  0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,
  0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,
  0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xba,
  0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,
  0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,
  0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,
  0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xb9,
  0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,
  0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,
  0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,
  0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb8,
  0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,
  0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,
  0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,
  0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,0xb7,
  0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,
  0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,
  0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,
  0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb6,
  0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,
  0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,
  0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,
  0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb5,
  0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,
  0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,
  0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,
  0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb4,
  0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,
  0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,
  0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,
  0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb3,
  0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,
  0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,
  0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,
  0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb2,
  0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,
  0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,
  0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,
  0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb1,
  0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
  0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
  0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,
  0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb0,
  0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,
  0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,
  0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,
  0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xaf,
  0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,
  0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,
  0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,
  0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,
  0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,
  0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,
  0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,
  0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xae,
  0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,
  0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,
  0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,
  0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,
  0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,
  0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,
  0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,
  0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xad,
  0xad,0xad,0xad,0xad,0xad,0xad,0xad,0xad,
  0xad,0xad,0xad,0xad,0xad,0xad,0xad,0xad,
  0xad,0xad,0xad,0xad,0xad,0xad,0xad,0xad,
  0xad,0xad,0xad,0xad,0xad,0xad,0xad,0xad,
  0xad,0xad,0xad,0xad,0xad,0xad,0xad,0xad,
  0xad,0xad,0xad,0xad,0xad,0xad,0xad,0xad,
  0xad,0xad,0xad,0xad,0xad,0xad,0xad,0xad,
  0xad,0xad,0xad,0xad,0xad,0xad,0xad,0xac,
  0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xac,
  0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xac,
  0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xac,
  0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xac,
  0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xac,
  0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xac,
  0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xac,
  0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xab,
  0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,
  0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,
  0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,
  0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,
  0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,
  0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,
  0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,
  0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xaa,
  0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
  0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
  0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
  0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
  0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
  0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
  0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,
  0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa9,
  0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,
  0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,
  0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,
  0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,
  0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,
  0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,
  0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,
  0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa8,
  0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,
  0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,
  0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,
  0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,
  0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,
  0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,
  0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,
  0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa7,
  0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,
  0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,
  0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,
  0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,
  0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,
  0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,
  0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,
  0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa6,
  0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,
  0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,
  0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,
  0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,
  0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,
  0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,
  0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,
  0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa5,
  0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
  0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
  0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
  0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
  0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
  0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
  0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
  0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa4,
  0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,
  0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,
  0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,
  0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,
  0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,
  0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,
  0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,
  0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa3,
  0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,
  0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,
  0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,
  0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,
  0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,
  0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,
  0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,
  0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa2,
  0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,
  0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,
  0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,
  0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,
  0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,
  0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,
  0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,
  0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa1,
  0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,
  0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,
  0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,
  0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,
  0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,
  0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,
  0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,
  0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa0,
  0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,
  0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,
  0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,
  0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,
  0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,
  0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,
  0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,
  0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,
  0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
  0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,
  0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,
  0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,
  0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,
  0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,
  0x0a,0x0a,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,
  0x0b,0x0b,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,
  0x0c,0x0c,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,
  0x0d,0x0d,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
  0x0e,0x0e,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
  0x0f,0x0f,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
  0x1a,0x1a,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
  0x1b,0x1b,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,
  0x1c,0x1c,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
  0x1d,0x1d,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
  0x1e,0x1e,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,
  0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,
  0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,
  0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,
  0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,
  0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,
  0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,
  0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,
  0x2a,0x2a,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,
  0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,
  0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,
  0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,
  0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,
  0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,
  0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,
  0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,
  0x2b,0x2b,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,
  0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,
  0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,
  0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,
  0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,
  0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,
  0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,
  0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,
  0x2c,0x2c,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,
  0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,
  0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,
  0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,
  0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,
  0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,
  0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,
  0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,
  0x2d,0x2d,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
  0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
  0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
  0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
  0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
  0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
  0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
  0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
  0x2e,0x2e,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,
  0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,
  0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,
  0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,
  0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,
  0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,
  0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,
  0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,
  0x2f,0x2f,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,
  0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,
  0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,
  0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,
  0x3a,0x3a,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,
  0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,
  0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,
  0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,
  0x3b,0x3b,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
  0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
  0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
  0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,
  0x3c,0x3c,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,
  0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,
  0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,
  0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,
  0x3d,0x3d,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,
  0x3e,0x3e,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
  0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
  0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
  0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
  0x3f,0x3f,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x41,0x41,0x41,0x41,0x41,0x41,
  0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,
  0x41,0x41,0x42,0x42,0x42,0x42,0x42,0x42,
  0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,
  0x42,0x42,0x43,0x43,0x43,0x43,0x43,0x43,
  0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,
  0x43,0x43,0x44,0x44,0x44,0x44,0x44,0x44,
  0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
  0x44,0x44,0x45,0x45,0x45,0x45,0x45,0x45,
  0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,
  0x45,0x45,0x46,0x46,0x46,0x46,0x46,0x46,
  0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
  0x46,0x46,0x47,0x47,0x47,0x47,0x47,0x47,
  0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,
  0x47,0x47,0x48,0x48,0x48,0x48,0x48,0x48,
  0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,
  0x48,0x48,0x49,0x49,0x49,0x49,0x49,0x49,
  0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,
  0x49,0x49,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
  0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
  0x4a,0x4a,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,
  0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,
  0x4b,0x4b,0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,
  0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,
  0x4c,0x4c,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,
  0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,
  0x4d,0x4d,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,
  0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,
  0x4e,0x4e,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,
  0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,
  0x4f,0x4f,0x50,0x50,0x50,0x50,0x50,0x50,
  0x50,0x50,0x51,0x51,0x51,0x51,0x51,0x51,
  0x51,0x51,0x52,0x52,0x52,0x52,0x52,0x52,
  0x52,0x52,0x53,0x53,0x53,0x53,0x53,0x53,
  0x53,0x53,0x54,0x54,0x54,0x54,0x54,0x54,
  0x54,0x54,0x55,0x55,0x55,0x55,0x55,0x55,
  0x55,0x55,0x56,0x56,0x56,0x56,0x56,0x56,
  0x56,0x56,0x57,0x57,0x57,0x57,0x57,0x57,
  0x57,0x57,0x58,0x58,0x58,0x58,0x58,0x58,
  0x58,0x58,0x59,0x59,0x59,0x59,0x59,0x59,
  0x59,0x59,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,
  0x5a,0x5a,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
  0x5c,0x5c,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,
  0x5d,0x5d,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,
  0x5e,0x5e,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,
  0x5f,0x5f,0x60,0x60,0x60,0x60,0x61,0x61,
  0x61,0x61,0x62,0x62,0x62,0x62,0x63,0x63,
  0x63,0x63,0x64,0x64,0x64,0x64,0x65,0x65,
  0x65,0x65,0x66,0x66,0x66,0x66,0x67,0x67,
  0x67,0x67,0x68,0x68,0x68,0x68,0x69,0x69,
  0x69,0x69,0x6a,0x6a,0x6a,0x6a,0x6b,0x6b,
  0x6b,0x6b,0x6c,0x6c,0x6c,0x6c,0x6d,0x6d,
  0x6d,0x6d,0x6e,0x6e,0x6e,0x6e,0x6f,0x6f,
  0x6f,0x6f,0x70,0x70,0x71,0x71,0x72,0x72,
  0x73,0x73,0x74,0x74,0x75,0x75,0x76,0x76,
  0x77,0x77,0x78,0x78,0x79,0x79,0x7a,0x7a,
  0x7b,0x7b,0x7c,0x7c,0x7d,0x7d,0x7e,0x7e};
    
int ulaw_exp_table[256] = {
  -32124,-31100,-30076,-29052,-28028,-27004,-25980,-24956,
  -23932,-22908,-21884,-20860,-19836,-18812,-17788,-16764,
  -15996,-15484,-14972,-14460,-13948,-13436,-12924,-12412,
  -11900,-11388,-10876,-10364, -9852, -9340, -8828, -8316,
  -7932, -7676, -7420, -7164, -6908, -6652, -6396, -6140,
  -5884, -5628, -5372, -5116, -4860, -4604, -4348, -4092,
  -3900, -3772, -3644, -3516, -3388, -3260, -3132, -3004,
  -2876, -2748, -2620, -2492, -2364, -2236, -2108, -1980,
  -1884, -1820, -1756, -1692, -1628, -1564, -1500, -1436,
  -1372, -1308, -1244, -1180, -1116, -1052,  -988,  -924,
  -876,  -844,  -812,  -780,  -748,  -716,  -684,  -652,
  -620,  -588,  -556,  -524,  -492,  -460,  -428,  -396,
  -372,  -356,  -340,  -324,  -308,  -292,  -276,  -260,
  -244,  -228,  -212,  -196,  -180,  -164,  -148,  -132,
  -120,  -112,  -104,   -96,   -88,   -80,   -72,   -64,
  -56,   -48,   -40,   -32,   -24,   -16,    -8,     0,
  32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956,
  23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764,
  15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412,
  11900, 11388, 10876, 10364,  9852,  9340,  8828,  8316,
  7932,  7676,  7420,  7164,  6908,  6652,  6396,  6140,
  5884,  5628,  5372,  5116,  4860,  4604,  4348,  4092,
  3900,  3772,  3644,  3516,  3388,  3260,  3132,  3004,
  2876,  2748,  2620,  2492,  2364,  2236,  2108,  1980,
  1884,  1820,  1756,  1692,  1628,  1564,  1500,  1436,
  1372,  1308,  1244,  1180,  1116,  1052,   988,   924,
  876,   844,   812,   780,   748,   716,   684,   652,
  620,   588,   556,   524,   492,   460,   428,   396,
  372,   356,   340,   324,   308,   292,   276,   260,
  244,   228,   212,   196,   180,   164,   148,   132,
  120,   112,   104,    96,    88,    80,    72,    64,
  56,    48,    40,    32,    24,    16,     8,     0};
     
unsigned char Alaw_comp_table[16384] = {
  0xD5,0xD5,0xD5,0xD5,0xD4,0xD4,0xD4,0xD4,
  0xD7,0xD7,0xD7,0xD7,0xD6,0xD6,0xD6,0xD6,
  0xD1,0xD1,0xD1,0xD1,0xD0,0xD0,0xD0,0xD0,
  0xD3,0xD3,0xD3,0xD3,0xD2,0xD2,0xD2,0xD2,
  0xDD,0xDD,0xDD,0xDD,0xDC,0xDC,0xDC,0xDC,
  0xDF,0xDF,0xDF,0xDF,0xDE,0xDE,0xDE,0xDE,
  0xD9,0xD9,0xD9,0xD9,0xD8,0xD8,0xD8,0xD8,
  0xDB,0xDB,0xDB,0xDB,0xDA,0xDA,0xDA,0xDA,
  0xC5,0xC5,0xC5,0xC5,0xC4,0xC4,0xC4,0xC4,
  0xC7,0xC7,0xC7,0xC7,0xC6,0xC6,0xC6,0xC6,
  0xC1,0xC1,0xC1,0xC1,0xC0,0xC0,0xC0,0xC0,
  0xC3,0xC3,0xC3,0xC3,0xC2,0xC2,0xC2,0xC2,
  0xCD,0xCD,0xCD,0xCD,0xCC,0xCC,0xCC,0xCC,
  0xCF,0xCF,0xCF,0xCF,0xCE,0xCE,0xCE,0xCE,
  0xC9,0xC9,0xC9,0xC9,0xC8,0xC8,0xC8,0xC8,
  0xCB,0xCB,0xCB,0xCB,0xCA,0xCA,0xCA,0xCA,
  0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,
  0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,
  0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,
  0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,
  0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,
  0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,
  0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,
  0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,
  0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,
  0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,
  0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,
  0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,
  0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,0xFB,
  0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,
  0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,
  0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,
  0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,
  0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,
  0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,
  0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,
  0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,
  0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,
  0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,
  0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,0xE1,
  0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,
  0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,
  0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,
  0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,
  0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,
  0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,
  0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,
  0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xED,
  0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,
  0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,
  0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,
  0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,
  0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
  0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,
  0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,
  0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,
  0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,
  0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,
  0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,
  0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,
  0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,
  0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,0xEA,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92,
  0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,
  0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,
  0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,
  0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,0x9D,
  0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,
  0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,
  0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,
  0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,0x9C,
  0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,
  0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,
  0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,
  0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,0x9F,
  0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,
  0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,
  0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,
  0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,0x9E,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
  0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,
  0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,
  0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,
  0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,0x9B,
  0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,
  0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,
  0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,
  0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,0x9A,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
  0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,
  0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,
  0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,
  0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,
  0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,
  0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,
  0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,
  0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,0x8D,
  0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,
  0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,
  0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,
  0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,
  0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,
  0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,
  0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,
  0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,0x8C,
  0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,
  0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,
  0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,
  0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,
  0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,
  0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,
  0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,
  0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,
  0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,
  0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,
  0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,
  0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,
  0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,
  0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,
  0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,
  0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,0x8E,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,
  0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,
  0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,
  0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,
  0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,
  0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,
  0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,
  0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,
  0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,0x8B,
  0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,
  0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,
  0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,
  0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,
  0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,
  0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,
  0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,
  0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,0x8A,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,0xB6,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,0xB1,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,0xB3,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,0xBE,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,0xB8,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,0xBA,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,0xA5,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,0xA4,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,0xA7,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,0xA6,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,0xA1,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,0xAD,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,0xAF,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,0xA9,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,0xAB,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
  0x2A,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,0x2B,
  0x2B,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
  0x28,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,
  0x29,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,
  0x2E,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,0x2F,
  0x2F,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,
  0x2C,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,
  0x2D,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
  0x22,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,
  0x23,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  0x20,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
  0x21,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
  0x26,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
  0x27,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
  0x24,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,
  0x25,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,0x3A,
  0x3A,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,0x3B,
  0x3B,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,
  0x38,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
  0x39,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,
  0x3E,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,
  0x3C,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,0x3D,
  0x3D,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,
  0x32,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
  0x33,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
  0x30,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,
  0x31,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
  0x36,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
  0x37,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,
  0x34,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
  0x35,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,
  0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,
  0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,
  0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,
  0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,
  0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,
  0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,
  0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,
  0x0A,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,
  0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,
  0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,
  0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,
  0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,
  0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,
  0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,
  0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,
  0x0B,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
  0x08,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
  0x09,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
  0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
  0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
  0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
  0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
  0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
  0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
  0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
  0x0E,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
  0x0F,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
  0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
  0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
  0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
  0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
  0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
  0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
  0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,
  0x0C,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,
  0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,
  0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,
  0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,
  0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,
  0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,
  0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,
  0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D,
  0x0D,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
  0x02,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
  0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
  0x06,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
  0x07,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,
  0x04,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,
  0x05,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,
  0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,
  0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,
  0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,0x1A,
  0x1A,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,
  0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,
  0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,
  0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,0x1B,
  0x1B,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
  0x18,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
  0x19,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,
  0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,
  0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,
  0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,
  0x1E,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
  0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
  0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
  0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
  0x1F,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,
  0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,
  0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,
  0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,
  0x1C,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,
  0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,
  0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,
  0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,0x1D,
  0x1D,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
  0x12,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,
  0x13,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x10,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
  0x11,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
  0x16,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
  0x17,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
  0x14,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,
  0x15,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,
  0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,0x6A,
  0x6A,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,
  0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,0x6B,
  0x6B,0x68,0x68,0x68,0x68,0x68,0x68,0x68,
  0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,
  0x68,0x69,0x69,0x69,0x69,0x69,0x69,0x69,
  0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,
  0x69,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,
  0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,0x6E,
  0x6E,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,
  0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,0x6F,
  0x6F,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,
  0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,
  0x6C,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,
  0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,0x6D,
  0x6D,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
  0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x62,
  0x62,0x63,0x63,0x63,0x63,0x63,0x63,0x63,
  0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,
  0x63,0x60,0x60,0x60,0x60,0x60,0x60,0x60,
  0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,
  0x60,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
  0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,
  0x61,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
  0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
  0x66,0x67,0x67,0x67,0x67,0x67,0x67,0x67,
  0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,
  0x67,0x64,0x64,0x64,0x64,0x64,0x64,0x64,
  0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,
  0x64,0x65,0x65,0x65,0x65,0x65,0x65,0x65,
  0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,
  0x65,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,0x7A,
  0x7A,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,0x7B,
  0x7B,0x78,0x78,0x78,0x78,0x78,0x78,0x78,
  0x78,0x79,0x79,0x79,0x79,0x79,0x79,0x79,
  0x79,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,
  0x7E,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
  0x7F,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,
  0x7C,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,
  0x7D,0x72,0x72,0x72,0x72,0x72,0x72,0x72,
  0x72,0x73,0x73,0x73,0x73,0x73,0x73,0x73,
  0x73,0x70,0x70,0x70,0x70,0x70,0x70,0x70,
  0x70,0x71,0x71,0x71,0x71,0x71,0x71,0x71,
  0x71,0x76,0x76,0x76,0x76,0x76,0x76,0x76,
  0x76,0x77,0x77,0x77,0x77,0x77,0x77,0x77,
  0x77,0x74,0x74,0x74,0x74,0x74,0x74,0x74,
  0x74,0x75,0x75,0x75,0x75,0x75,0x75,0x75,
  0x75,0x4A,0x4A,0x4A,0x4A,0x4B,0x4B,0x4B,
  0x4B,0x48,0x48,0x48,0x48,0x49,0x49,0x49,
  0x49,0x4E,0x4E,0x4E,0x4E,0x4F,0x4F,0x4F,
  0x4F,0x4C,0x4C,0x4C,0x4C,0x4D,0x4D,0x4D,
  0x4D,0x42,0x42,0x42,0x42,0x43,0x43,0x43,
  0x43,0x40,0x40,0x40,0x40,0x41,0x41,0x41,
  0x41,0x46,0x46,0x46,0x46,0x47,0x47,0x47,
  0x47,0x44,0x44,0x44,0x44,0x45,0x45,0x45,
  0x45,0x5A,0x5A,0x5A,0x5A,0x5B,0x5B,0x5B,
  0x5B,0x58,0x58,0x58,0x58,0x59,0x59,0x59,
  0x59,0x5E,0x5E,0x5E,0x5E,0x5F,0x5F,0x5F,
  0x5F,0x5C,0x5C,0x5C,0x5C,0x5D,0x5D,0x5D,
  0x5D,0x52,0x52,0x52,0x52,0x53,0x53,0x53,
  0x53,0x50,0x50,0x50,0x50,0x51,0x51,0x51,
  0x51,0x56,0x56,0x56,0x56,0x57,0x57,0x57,
  0x57,0x54,0x54,0x54,0x54,0x55,0x55,0x55};
          
int Alaw_exp_table[256] = {
  -5504, -5248, -6016, -5760, -4480, -4224, -4992, -4736,
  -7552, -7296, -8064, -7808, -6528, -6272, -7040, -6784,
  -2752, -2624, -3008, -2880, -2240, -2112, -2496, -2368,
  -3776, -3648, -4032, -3904, -3264, -3136, -3520, -3392,
  -22016,-20992,-24064,-23040,-17920,-16896,-19968,-18944,
  -30208,-29184,-32256,-31232,-26112,-25088,-28160,-27136,
  -11008,-10496,-12032,-11520, -8960, -8448, -9984, -9472,
  -15104,-14592,-16128,-15616,-13056,-12544,-14080,-13568,
  -344,  -328,  -376,  -360,  -280,  -264,  -312,  -296,
  -472,  -456,  -504,  -488,  -408,  -392,  -440,  -424,
  -88,   -72,  -120,  -104,   -24,    -8,   -56,   -40,
  -216,  -200,  -248,  -232,  -152,  -136,  -184,  -168,
  -1376, -1312, -1504, -1440, -1120, -1056, -1248, -1184,
  -1888, -1824, -2016, -1952, -1632, -1568, -1760, -1696,
  -688,  -656,  -752,  -720,  -560,  -528,  -624,  -592,
  -944,  -912, -1008,  -976,  -816,  -784,  -880,  -848,
  5504,  5248,  6016,  5760,  4480,  4224,  4992,  4736,
  7552,  7296,  8064,  7808,  6528,  6272,  7040,  6784,
  2752,  2624,  3008,  2880,  2240,  2112,  2496,  2368,
  3776,  3648,  4032,  3904,  3264,  3136,  3520,  3392,
  22016, 20992, 24064, 23040, 17920, 16896, 19968, 18944,
  30208, 29184, 32256, 31232, 26112, 25088, 28160, 27136,
  11008, 10496, 12032, 11520,  8960,  8448,  9984,  9472,
  15104, 14592, 16128, 15616, 13056, 12544, 14080, 13568,
  344,   328,   376,   360,   280,   264,   312,   296,
  472,   456,   504,   488,   408,   392,   440,   424,
  88,    72,   120,   104,    24,     8,    56,    40,
  216,   200,   248,   232,   152,   136,   184,   168,
  1376,  1312,  1504,  1440,  1120,  1056,  1248,  1184,
  1888,  1824,  2016,  1952,  1632,  1568,  1760,  1696,
  688,   656,   752,   720,   560,   528,   624,   592,
  944,   912,  1008,   976,   816,   784,   880,   848};
  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\vapiio\vapiioint.h ===
/******************************************************************************
* vapiIoInt.h *
*-------------*
*  I/O library functions for extended speech files (vapi format)
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef _VAPIIOINT_H_
#define _VAPIIOINT_H_

#include "vapiIo.h"

unsigned char Alaw2Ulaw(unsigned char ucAVal);
unsigned char Ulaw2Alaw(unsigned char ucUVal);

int Ulaw2Linear (unsigned char ucUVal);
unsigned char Linear2Ulaw(int iPcmVal);

int Alaw2Linear (unsigned char ucAVal);
unsigned char Linear2Alaw(int iPcmVal);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\vapiio\vapiio.cpp ===
/******************************************************************************
* vapiIo.cpp *
*------------*
*  I/O library functions for extended speech files (vapi format)
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#include "vapiIoInt.h"
#include <mmsystem.h>
#include <mmreg.h>
#include <assert.h>
#include <stdio.h>

typedef struct {
    int code;
    char* message;
} ErrorMsg;


class VapiFile : VapiIO
{
    public:
        VapiFile();
        ~VapiFile();

        int   OpenFile ( const char* pszFileName, int iMode ); 
        int   OpenFile ( const WCHAR* wcsFileName, int iMode ); 
        void  CloseFile ( );

        int   CreateChunk ( const char* pszName );
        int   CloseChunk ( );
        int   WriteToChunk (const char* pszData, int iSize);

        int   GetDataSize (long* lDataSize);
        int   Format (int* piSampFreq, int* piFormat, WAVEFORMATEX* pWaveFormatEx = NULL);
        int   WriteFormat (int iSampFreq, int iFormat);

        int   ReadSamples (double dFrom, double dTo, void** ppvSamples, int* piNumSamples, bool bClosedInterval);
        int   WriteSamples (void* pvSamples, int iNumSamples);

        int   ReadF0SampFreq (int* piSampFreq);
        int   WriteF0SampFreq (int iSampFreq);

        int   ReadFeature (char* pszName, float** ppfSamples, int* piNumSamples);
        int   WriteFeature (char* pszName, float* pfSamples, int iNumSamples);

        int   ReadEpochs (Epoch** ppEpochs, int* iNumEpochs);
        int   WriteEpochs (Epoch* pEpochs, int iNumEpochs);

        int   ReadLabels (char* pszName, Label** ppLabels, int* piNumLabels);
        int   WriteLabels (char* pszName, Label* pLabels, int iNumLabels);

        char* ErrMessage (int iErrCode);

    private:
        HMMIO m_HWav;
        MMCKINFO m_ParentInfo;
        MMCKINFO m_SubchunkInfo;
        int m_iSampFormat;
        int m_iSampFreq;

        static ErrorMsg m_ErrorMsg[];
        static int      m_iNumErrorMsg;
};


ErrorMsg VapiFile::m_ErrorMsg[] = {
    {VAPI_IOERR_NOERROR, 0},
    {VAPI_IOERR_MODE, "Wrong opening mode."},
    {VAPI_IOERR_MEMORY, "Memory error."},
    {VAPI_IOERR_CANTOPEN, "Error opening file."},
    {VAPI_IOERR_NOWAV, "Not RIFF-WAVE format."},
    {VAPI_IOERR_NOFORMAT, "Can't find data format."},
    {VAPI_IOERR_STEREO, "File is stereo\n"},
    {VAPI_IOERR_FORMAT, "Unknown data format."},
    {VAPI_IOERR_NOCHUNK, "Error accessing data chunk."},
    {VAPI_IOERR_DATAACCESS, "Error accessing input data."},
    {VAPI_IOERR_WRITEWAV, "Error creating RIFF-WAVE chunk."},
    {VAPI_IOERR_CREATECHUNK, "Error creating new subchunk."},
    {VAPI_IOERR_WRITECHUNK, "Error writing data in new subchunk."}
};

int VapiFile::m_iNumErrorMsg = sizeof (VapiFile::m_ErrorMsg) / sizeof (VapiFile::m_ErrorMsg[0]);


/*****************************************************************************
* VapiIO::ClassFactory *
*----------------------*
*   Description:
*       Class Factory, creates an object of the VapiIO implementation class.
******************************************************************* PACOG ***/
VapiIO* VapiIO::ClassFactory ()
{
    return new VapiFile();
}

/*****************************************************************************
* VapiIO::SizeOf *
*----------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiIO::SizeOf (int iType)
{
    switch (iType) 
    {
    case VAPI_PCM8:
    case VAPI_ALAW:
    case VAPI_ULAW:
        return 1;
    case VAPI_PCM16:
        return 2;
    default:
        return 0;
    }
    return 0;
}

/*****************************************************************************
* VapiIO::TypeOf *
*----------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiIO::TypeOf (WAVEFORMATEX *pWavFormat)
{
    int iSampFormat;

    if (pWavFormat->wFormatTag == WAVE_FORMAT_PCM) 
    {
        switch (pWavFormat->nBlockAlign/pWavFormat->nChannels) 
        {
        case 1:
            iSampFormat = VAPI_PCM8;
            break;
        case 2:
            iSampFormat = VAPI_PCM16;
            break;
        default:
            iSampFormat = -1;
            break;
        }
    } 
    else if (pWavFormat->wFormatTag == WAVE_FORMAT_ALAW) 
    {
        iSampFormat = VAPI_ALAW;
    }
    else if (pWavFormat->wFormatTag == WAVE_FORMAT_MULAW) 
    {
        iSampFormat = VAPI_ULAW;
    } 
    else
    {
        iSampFormat = -1;
    }

    return iSampFormat;
}

/*****************************************************************************
* VapiIO::DataFormatConversion *
*------------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiIO::DataFormatConversion (char* pcInput, int iInType, 
                                  char* pcOutput, int iOutType, int iNumSamples)
{
    int i;
    
    assert (pcInput);
    assert (pcOutput);
    assert (iNumSamples>0);
    
    // Check that these are valid types

    if (!SizeOf(iInType) || !SizeOf(iOutType)) 
    {
        return 0;
    }
    
    // If same type, just copy samples
    
    if (iInType == iOutType) 
    {
        memcpy( pcOutput, pcInput, iNumSamples * SizeOf(iInType));
        return 1;
    }
    
    // Ok, need to convert

    switch (iInType) 
    {        
    case VAPI_PCM16:
        switch (iOutType) 
        {
        case VAPI_PCM8:
            for (i=0; i<iNumSamples; i++) 
            {
                pcOutput[i] = ((int)((short*)pcInput)[i] + 32768) >> 8;
            }
            break;
        case VAPI_ALAW:
            for (i=0; i<iNumSamples; i++) 
            {
                pcOutput[i] = Linear2Alaw (((short*)pcInput)[i]);
            }
            break;
        case VAPI_ULAW:
            for (i=0; i<iNumSamples; i++) 
            {
                pcOutput[i] = Linear2Ulaw (((short*)pcInput)[i]);
            }
            break;
        }
        break;
    case VAPI_PCM8:
        switch (iOutType) 
        {
        case VAPI_PCM16:
            for (i=0; i<iNumSamples; i++) 
            {
                ((short*)pcOutput)[i] = (((int)((char*)pcInput)[i])<<8) - 32768;
            }
            break;
        case VAPI_ALAW:
            for (i=0; i<iNumSamples; i++) 
            {
                pcOutput[i] = Linear2Alaw ((short)((((int)((char*)pcInput)[i])<<8) - 32768));
            }
            break;
        case VAPI_ULAW:
            for (i=0; i<iNumSamples; i++) 
            {
                pcOutput[i] = Linear2Ulaw ((short)((((int)((char*)pcInput)[i])<<8) - 32768));
            }
            break;
        }
        break;
    case VAPI_ALAW:
        switch (iOutType) 
        {
        case VAPI_PCM16:
            for (i=0; i<iNumSamples; i++) 
            {
                ((short*)pcOutput)[i] = (short) Alaw2Linear(((char*)pcInput)[i]);
            }
            break;
        case VAPI_PCM8:
            for (i=0; i<iNumSamples; i++) 
            {
                pcOutput[i] = ((int)Alaw2Linear(((char*)pcInput)[i]) + 32768) >> 8;
            }
            break;
        case VAPI_ULAW:
            for (i=0; i<iNumSamples; i++) 
            {
                pcOutput[i] = Alaw2Ulaw(((char*)pcInput)[i]);
            }
            break;
        }
        break;
    case VAPI_ULAW:
        switch (iOutType) 
        {
        case VAPI_PCM16:
            for (i=0; i<iNumSamples; i++) 
            {
                ((short*)pcOutput)[i] = (short) Ulaw2Linear(((char*)pcInput)[i]);
            }
            break;
        case VAPI_PCM8:
            for (i=0; i<iNumSamples; i++) 
            {
                pcOutput[i] = ((int)Ulaw2Linear(((char*)pcInput)[i]) + 32768)>>8;
            }
            break;
        case VAPI_ALAW:
            for (i=0; i<iNumSamples; i++) 
            {
                pcOutput[i] = Ulaw2Alaw(((char*)pcInput)[i]);
            }
            break;
        }
        break;
    } 
    
    return 1;
}


/*****************************************************************************
* VapiFile::ErrMessage *
*----------------------*
*   Description:
*
******************************************************************* PACOG ***/

char* VapiFile::ErrMessage (int errCode) 
{
    for (int i=0; i< m_iNumErrorMsg; i++) 
    {
        if (errCode == m_ErrorMsg[i].code) 
        {
            return m_ErrorMsg[i].message;
        }
    }
    
    return 0;
}


/*****************************************************************************
* VapiFile::VapiFile *
*--------------------*
*   Description:
*
******************************************************************* PACOG ***/
VapiFile::VapiFile()
{
    m_HWav = 0;
    memset (&m_ParentInfo, 0, sizeof(m_ParentInfo));
    memset (&m_SubchunkInfo, 0, sizeof(m_SubchunkInfo));
    m_iSampFormat = 0;
    m_iSampFreq = 0;
}

/*****************************************************************************
* VapiFile::~VapiFile *
*---------------------*
*   Description:
*
******************************************************************* PACOG ***/
VapiFile::~VapiFile()
{
    CloseFile();
}

/*****************************************************************************
* VapiFile::OpenFile *
*--------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::OpenFile (const char* pszFileName, int iMode)
{
    int iErrCode = VAPI_IOERR_NOERROR;
    
    assert (pszFileName);
    
    switch (iMode) 
    {
    case VAPI_IO_READ:
        iMode = MMIO_READ;
        break;
    case VAPI_IO_WRITE:
        iMode = MMIO_WRITE|MMIO_CREATE;
        break;
    case VAPI_IO_READWRITE:
        iMode = MMIO_READWRITE;
        break;
    default:
        return VAPI_IOERR_MODE;
    }
        
    if ((m_HWav = mmioOpen ((char *)pszFileName, NULL, iMode)) == NULL) 
    {
        iErrCode = VAPI_IOERR_CANTOPEN;
        goto error;
    }
    
    if (iMode == MMIO_READ) 
    {
        m_ParentInfo.fccType = mmioFOURCC ('W', 'A', 'V', 'E');
        if (mmioDescend (m_HWav, &m_ParentInfo, 0, MMIO_FINDRIFF)) 
        {
            iErrCode = VAPI_IOERR_NOWAV;
            goto error;
        }
    } 
    else 
    {
        m_ParentInfo.fccType = mmioFOURCC ('W', 'A', 'V', 'E');
        if (mmioCreateChunk (m_HWav, &m_ParentInfo, MMIO_CREATERIFF)) 
        {
            iErrCode = VAPI_IOERR_WRITEWAV;
            goto error;
        }
    }
    return VAPI_IOERR_NOERROR;
    
error:
    CloseFile ();
    return iErrCode;
}


/*****************************************************************************
* VapiFile::OpenFile *
*--------------------*
*   Description: Same as previous OpenFile, but takes WCHAR* as arg
*
******************************************************************* JOEM ****/
int VapiFile::OpenFile (const WCHAR* wcsFileName, int iMode)
{
    int iErrCode = VAPI_IOERR_NOERROR;
    
    assert (wcsFileName);
    
    switch (iMode) 
    {
    case VAPI_IO_READ:
        iMode = MMIO_READ;
        break;
    case VAPI_IO_WRITE:
        iMode = MMIO_WRITE|MMIO_CREATE;
        break;
    case VAPI_IO_READWRITE:
        iMode = MMIO_READWRITE;
        break;
    default:
        return VAPI_IOERR_MODE;
    }
        
    if ((m_HWav = mmioOpenW ((WCHAR *)wcsFileName, NULL, iMode)) == NULL) 
    {
        iErrCode = VAPI_IOERR_CANTOPEN;
        goto error;
    }
    
    if (iMode == MMIO_READ) 
    {
        m_ParentInfo.fccType = mmioFOURCC ('W', 'A', 'V', 'E');
        if (mmioDescend (m_HWav, &m_ParentInfo, 0, MMIO_FINDRIFF)) 
        {
            iErrCode = VAPI_IOERR_NOWAV;
            goto error;
        }
    } 
    else 
    {
        m_ParentInfo.fccType = mmioFOURCC ('W', 'A', 'V', 'E');
        if (mmioCreateChunk (m_HWav, &m_ParentInfo, MMIO_CREATERIFF)) 
        {
            iErrCode = VAPI_IOERR_WRITEWAV;
            goto error;
        }
    }
    return VAPI_IOERR_NOERROR;
    
error:
    CloseFile ();
    return iErrCode;
}


/*****************************************************************************
* VapiFile::CloseFile *
*---------------------*
*   Description:
*
******************************************************************* PACOG ***/
void VapiFile::CloseFile ()
{
    if (m_HWav) 
    {
        mmioAscend (m_HWav, &m_ParentInfo, 0);
        mmioClose  (m_HWav, 0);

        memset (&m_ParentInfo, 0, sizeof(m_ParentInfo));
        m_HWav = 0;
    }    
}

/*****************************************************************************
* VapiFile::Format *
*------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::Format (int* piSampFreq, int* piFormat, WAVEFORMATEX* pWaveFormatEx)
{
    WAVEFORMATEX* WavFormat = NULL;
    WAVEFORMATEX  LocalWaveFormat;
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    
    assert (m_HWav);
    
    memset((void*)&LocalWaveFormat, 0, sizeof(WAVEFORMATEX));

    if ( pWaveFormatEx )
    {
        memset((void*)pWaveFormatEx, 0, sizeof(WAVEFORMATEX));
        WavFormat = pWaveFormatEx;
    }
    else
    {
        WavFormat = &LocalWaveFormat;
    }
    mmioSeek (m_HWav, m_ParentInfo.dwDataOffset+4, SEEK_SET);
    
    SubchunkInfo.ckid = mmioFOURCC ('f', 'm', 't', ' ');
    if (mmioDescend (m_HWav, &SubchunkInfo, &m_ParentInfo, MMIO_FINDCHUNK) ) 
    {
        iErrCode = VAPI_IOERR_NOFORMAT;
        goto error;
    }
    
    if (mmioRead (m_HWav, (char *)WavFormat, SubchunkInfo.cksize)!= (int)SubchunkInfo.cksize) 
    {
        iErrCode = VAPI_IOERR_NOFORMAT;
        goto error;
    }
    mmioAscend (m_HWav, &SubchunkInfo, 0);
    
    /*
     * Process header info.
     * Files must be mono, and in one of these formats
     */    
    if (WavFormat->nChannels >1 ) 
    {
        iErrCode = VAPI_IOERR_STEREO;
        goto error;
    }
    
    m_iSampFormat = TypeOf (WavFormat);

    if (m_iSampFormat < 0)
    {
        iErrCode = VAPI_IOERR_FORMAT;
        goto error;
    }
    
    m_iSampFreq = WavFormat->nSamplesPerSec;
    
    if (piFormat) 
    {
        *piFormat   = m_iSampFormat;
    }
    
    if (piSampFreq) 
    {
        *piSampFreq = m_iSampFreq;
    }
    
error:
    return iErrCode;
}
/*****************************************************************************
* VapiFile::GetDataSize *
*------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::GetDataSize (long* lDataSize)
{
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    
    /*
     * Go for the data
     */
    mmioSeek (m_HWav, m_ParentInfo.dwDataOffset+4, SEEK_SET);
    
    SubchunkInfo.ckid = mmioFOURCC ('d', 'a', 't', 'a');
    if (mmioDescend (m_HWav, &SubchunkInfo, &m_ParentInfo, MMIO_FINDCHUNK)) 
    {
        iErrCode = VAPI_IOERR_NOCHUNK;
        goto error;
    }
    
    *lDataSize = SubchunkInfo.cksize;

    mmioAscend (m_HWav, &SubchunkInfo, 0);

error:
    return iErrCode;
}

/*****************************************************************************
* VapiFile::WriteFormat *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::WriteFormat (int iSampFreq, int iFormat)
{
    WAVEFORMATEX WavFormat;
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    
    assert (m_HWav);
    assert (iSampFreq>0);
    
    switch (iFormat) 
    {
    case VAPI_PCM8:
        WavFormat.wFormatTag = WAVE_FORMAT_PCM;
        WavFormat.wBitsPerSample = 8; 
        break;
    case VAPI_ALAW:
        WavFormat.wFormatTag = WAVE_FORMAT_ALAW;
        WavFormat.wBitsPerSample = 8; 
        break;
    case VAPI_ULAW:
        WavFormat.wFormatTag = WAVE_FORMAT_MULAW;
        WavFormat.wBitsPerSample = 8; 
        break;
    case VAPI_PCM16:
        WavFormat.wFormatTag = WAVE_FORMAT_PCM;
        WavFormat.wBitsPerSample = 16;
        break;
    default:
        iErrCode = VAPI_IOERR_FORMAT;
        goto error;
    }
    
    WavFormat.nChannels = 1;
    WavFormat.nSamplesPerSec = iSampFreq;
    WavFormat.nBlockAlign = (WavFormat.wBitsPerSample / 8) ;
    WavFormat.nAvgBytesPerSec = WavFormat.nBlockAlign * WavFormat.nSamplesPerSec;
    WavFormat.cbSize = 0;
    
    SubchunkInfo.ckid = mmioFOURCC ('f', 'm', 't', ' ');
    if (mmioCreateChunk (m_HWav, &SubchunkInfo, 0) ) 
    {
        iErrCode = VAPI_IOERR_CREATECHUNK;
        goto error;
    }
    
    if (mmioWrite(m_HWav, (char *)&WavFormat, sizeof(WavFormat)) != (int)sizeof(WavFormat)) 
    {
        iErrCode = VAPI_IOERR_WRITECHUNK;
        goto error;
    }
    mmioAscend (m_HWav, &SubchunkInfo, 0);
    
    m_iSampFreq   = iSampFreq;
    m_iSampFormat = iFormat;
    
error:
    return iErrCode;
}

/*****************************************************************************
* VapiFile::CreateChunk *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::CreateChunk (const char* pszName)
{
    assert (pszName);
    
    m_SubchunkInfo.ckid = mmioStringToFOURCC (pszName, 0); 
    if (mmioCreateChunk (m_HWav, &m_SubchunkInfo, 0)) 
    {
        return VAPI_IOERR_CREATECHUNK;
    }
    return VAPI_IOERR_NOERROR;
}

/*****************************************************************************
* VapiFile::WriteToChunk *
*------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::WriteToChunk (const char* pcData, int iSize)
{
    assert (pcData);
    assert (iSize>0);
    
    if ( mmioWrite (m_HWav, pcData, iSize) != iSize ) 
    {
        return VAPI_IOERR_WRITECHUNK;
    }
    
    return VAPI_IOERR_NOERROR;
}

/*****************************************************************************
* VapiFile::CloseChunk *
*----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::CloseChunk ( )
{
    assert (m_HWav);
    mmioAscend (m_HWav, &m_SubchunkInfo, 0);
    return VAPI_IOERR_NOERROR;
}


/*****************************************************************************
* VapiFile::ReadSamples *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::ReadSamples (double dFrom, double dTo, 
                           void** ppvSamples, int* piNumSamples, bool bClosedInterval)
{
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    
    void* pvBuffer = NULL;
    int   iBuffLen;
    int   iBuffLenInFile;
    int   iSkipBytes;
    long  lRead;
    double dEndOfData;

    assert (m_HWav);
    assert (ppvSamples);
    assert (piNumSamples);
    
    assert (dFrom>=0.0);
    assert (dTo == -1.0 || dTo>=dFrom);
    
    /*
     * Go for the data
     */
    mmioSeek (m_HWav, m_ParentInfo.dwDataOffset+4, SEEK_SET);
    
    SubchunkInfo.ckid = mmioFOURCC ('d', 'a', 't', 'a');
    if (mmioDescend (m_HWav, &SubchunkInfo, &m_ParentInfo, MMIO_FINDCHUNK)) 
    {
        iErrCode = VAPI_IOERR_NOCHUNK;
        goto error;
    }
    
    iBuffLenInFile = SubchunkInfo.cksize;
    
    dEndOfData = ((double)iBuffLenInFile) / SizeOf(m_iSampFormat) / m_iSampFreq;
    if ( dFrom > dEndOfData )
    {
        // nothing to read
        iErrCode = VAPI_IOERR_NOCHUNK;
        goto error;
    }
    if ( dTo != -1.0 && dFrom >= dTo )
    {
        // nothing to read
        iErrCode = VAPI_IOERR_NOCHUNK;
        goto error;
    }

    /*
     * Read only the desired region 
     */
    if (dFrom < 0.0) 
    {
        dFrom = 0.0;
    }
    iSkipBytes = (int)(dFrom * m_iSampFreq + 0.5) * SizeOf(m_iSampFormat);
    
    if (dTo == -1.0) 
    {
        iBuffLen = iBuffLenInFile;
    }
    else 
    {
        iBuffLen = (int)(dTo * m_iSampFreq + 0.5) * SizeOf(m_iSampFormat); 
        
        if (iBuffLen>=iBuffLenInFile) 
        {
            dTo = -1.0;
            iBuffLen = iBuffLenInFile;
        }
    }
    
    iBuffLen -= iSkipBytes;
    
    if (bClosedInterval && dTo != -1.0) 
    {
        iBuffLen += SizeOf (m_iSampFormat);
    }
    
    if (iSkipBytes>0 && mmioSeek (m_HWav, iSkipBytes, SEEK_CUR) == -1) 
    {
        iErrCode = VAPI_IOERR_DATAACCESS;
        goto error;
    }
    
    if ((pvBuffer = new char[iBuffLen]) == NULL) 
    {
        iErrCode = VAPI_IOERR_MEMORY;
        goto error;
    }
    
    lRead = mmioRead (m_HWav, (char *)pvBuffer, iBuffLen);
    if ( lRead != (int)iBuffLen) 
    {
        iErrCode = VAPI_IOERR_DATAACCESS;
        goto error;
    }
    
    mmioAscend (m_HWav, &SubchunkInfo, 0);
    
    *ppvSamples  = pvBuffer;
    *piNumSamples = iBuffLen/SizeOf(m_iSampFormat);
    
    return VAPI_IOERR_NOERROR; 
    
error:
    
    if (pvBuffer) 
    {
        delete[] pvBuffer;
    }
    
    return iErrCode;
}

/*****************************************************************************
* VapiFile::WriteSamples *
*------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::WriteSamples (void* pvSamples, int iNumSamples)
{
    MMCKINFO subchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    int iBuffLen;
    
    assert (m_HWav);
    assert (pvSamples);
    assert (iNumSamples>0);
    
    subchunkInfo.ckid = mmioFOURCC ('d', 'a', 't', 'a');
    if (mmioCreateChunk (m_HWav, &subchunkInfo, 0) ) 
    {
        iErrCode = VAPI_IOERR_CREATECHUNK;
        goto error;
    }
    
    iBuffLen = iNumSamples * SizeOf (m_iSampFormat);
    
    if (mmioWrite(m_HWav, (char *)pvSamples, iBuffLen) != iBuffLen) 
    {
        iErrCode = VAPI_IOERR_WRITECHUNK;
        goto error;
    }
    mmioAscend (m_HWav, &subchunkInfo, 0);
    
error:
    return iErrCode;
}


/*****************************************************************************
* VapiFile::ReadF0SampFreq *
*--------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::ReadF0SampFreq (int* piSampFreq)
{
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    
    assert (m_HWav);
    assert (piSampFreq);
    
    mmioSeek (m_HWav, m_ParentInfo.dwDataOffset+4, SEEK_SET);
    
    SubchunkInfo.ckid = mmioFOURCC ('f', '0', 's', 'f') ; 
    
    if (mmioDescend (m_HWav, &SubchunkInfo, &m_ParentInfo, MMIO_FINDCHUNK) ==  MMIOERR_CHUNKNOTFOUND) 
    {
        iErrCode = VAPI_IOERR_NOCHUNK;  
    }
    else 
    {  
        if (mmioRead (m_HWav, (char *)piSampFreq, SubchunkInfo.cksize) != (int)SubchunkInfo.cksize) 
        {
            iErrCode = VAPI_IOERR_F0SFACCESS;
            goto error;
        }
        mmioAscend (m_HWav, &SubchunkInfo, 0);
    }
    
error:
    return iErrCode;
}


/*****************************************************************************
* VapiFile::WriteF0SampFreq *
*---------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::WriteF0SampFreq (int iSampFreq)
{
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    
    assert (m_HWav);
    assert (iSampFreq>0);
    
    SubchunkInfo.ckid = mmioFOURCC ('f', '0', 's', 'f') ; 
    
    if (mmioCreateChunk (m_HWav, &SubchunkInfo, 0) ) 
    {
        iErrCode = VAPI_IOERR_CREATECHUNK;
        goto error;
    }
    
    if (mmioWrite(m_HWav, (char *)&iSampFreq, sizeof(iSampFreq)) != sizeof(iSampFreq)) 
    {
        iErrCode = VAPI_IOERR_WRITECHUNK;
        goto error;
    }
    mmioAscend (m_HWav, &SubchunkInfo, 0);
    
error:
    return iErrCode;
}


/*****************************************************************************
* VapiFile::ReadFeature *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::ReadFeature (char* pszName, float** ppfSamples, int* piNumSamples)
{
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    
    assert (m_HWav);
    assert (pszName);
    assert (ppfSamples);
    assert (piNumSamples);
    
    mmioSeek (m_HWav, m_ParentInfo.dwDataOffset+4, SEEK_SET);
    
    SubchunkInfo.ckid = mmioStringToFOURCC (pszName, 0); 
    
    if (mmioDescend (m_HWav, &SubchunkInfo, &m_ParentInfo, MMIO_FINDCHUNK) == MMIOERR_CHUNKNOTFOUND) 
    {   
        iErrCode = VAPI_IOERR_NOCHUNK;    
    }
    else 
    {  
        *piNumSamples = SubchunkInfo.cksize/ sizeof(**ppfSamples);
        
        if ((*ppfSamples = new float[SubchunkInfo.cksize/sizeof(float)]) == NULL ) 
        {
            iErrCode = VAPI_IOERR_MEMORY;
            goto error;
        }
        
        if (mmioRead (m_HWav, (char *)*ppfSamples, SubchunkInfo.cksize) != (int)SubchunkInfo.cksize) 
        {
            iErrCode = VAPI_IOERR_FEATACCESS;
            goto error;
        }
        mmioAscend (m_HWav, &SubchunkInfo, 0);
    }
    
error:
    return iErrCode;
}


/*****************************************************************************
* VapiFile::WriteFeature *
*------------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::WriteFeature (char* pszName, float* pfSamples, int iNumSamples)
{
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    int iBuffLen;
    
    assert (m_HWav);
    assert (pszName);
    assert (pfSamples);
    assert (iNumSamples>0);
    
    SubchunkInfo.ckid = mmioStringToFOURCC (pszName, 0); 
    
    if (mmioCreateChunk (m_HWav, &SubchunkInfo, 0) ) 
    {
        iErrCode = VAPI_IOERR_CREATECHUNK;
        goto error;
    }
    
    iBuffLen = iNumSamples * sizeof(*pfSamples);
    if (mmioWrite(m_HWav, (char *)pfSamples, iBuffLen) != iBuffLen) 
    {
        iErrCode = VAPI_IOERR_WRITECHUNK;
        goto error;
    }
    mmioAscend (m_HWav, &SubchunkInfo, 0);
    
error:
    return iErrCode;
}


/*****************************************************************************
* VapiFile::ReadEpochs *
*----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::ReadEpochs (Epoch** ppEpochs, int* piNumEpochs)
{
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    
    assert (m_HWav);
    assert (ppEpochs);
    assert (piNumEpochs);
    
    mmioSeek (m_HWav, m_ParentInfo.dwDataOffset+4, SEEK_SET);
    
    SubchunkInfo.ckid = mmioFOURCC ('e', 'p', 'o', 'c');
    
    if (mmioDescend (m_HWav, &SubchunkInfo, &m_ParentInfo, MMIO_FINDCHUNK) == MMIOERR_CHUNKNOTFOUND) 
    {   
        iErrCode = VAPI_IOERR_NOCHUNK;    
        goto error;
    }
    else 
    {  
        *piNumEpochs = SubchunkInfo.cksize / sizeof(**ppEpochs);
        
        if ((*ppEpochs =  new Epoch[SubchunkInfo.cksize/sizeof(Epoch)]) == NULL ) 
        {
            iErrCode = VAPI_IOERR_MEMORY;
            goto error;
        }
        
        if (mmioRead (m_HWav, (char *)*ppEpochs, SubchunkInfo.cksize) != (int)SubchunkInfo.cksize) 
        {
            iErrCode = VAPI_IOERR_EPOCHACCESS;
            goto error;
        }
        
        mmioAscend (m_HWav, &SubchunkInfo, 0);
    }
    
error:
    return iErrCode;
}

/*****************************************************************************
* VapiFile::WriteEpochs *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::WriteEpochs (Epoch* pEpochs, int iNumEpochs)
{
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    int iBuffLen;
    
    assert (m_HWav);
    assert (pEpochs);
    assert (iNumEpochs>0);
    
    SubchunkInfo.ckid = mmioFOURCC ('e', 'p', 'o', 'c');
    
    if (mmioCreateChunk (m_HWav, &SubchunkInfo, 0) ) 
    {
        iErrCode = VAPI_IOERR_CREATECHUNK;
        goto error;
    }
    
    iBuffLen = iNumEpochs * sizeof(*pEpochs);
    if (mmioWrite(m_HWav, (char *)pEpochs, iBuffLen) != iBuffLen) 
    {
        iErrCode = VAPI_IOERR_WRITECHUNK;
        goto error;
    }
    mmioAscend (m_HWav, &SubchunkInfo, 0);
    
error:
    return iErrCode;
}


/*****************************************************************************
* VapiFile::ReadLabels *
*----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::ReadLabels (char* pszName, Label** ppLabels, int* piNumLabels)
{
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    
    assert (m_HWav);
    assert (pszName);
    assert (ppLabels);
    assert (piNumLabels);
    
    mmioSeek (m_HWav, m_ParentInfo.dwDataOffset+4, SEEK_SET);
    
    SubchunkInfo.ckid = mmioStringToFOURCC (pszName, 0); 
    
    if (mmioDescend (m_HWav, &SubchunkInfo, &m_ParentInfo, MMIO_FINDCHUNK) == MMIOERR_CHUNKNOTFOUND) 
    {   
        iErrCode = VAPI_IOERR_NOCHUNK;    
    }
    else 
    {  
        *piNumLabels = SubchunkInfo.cksize/ sizeof(**ppLabels);
        
        if ((*ppLabels = new Label[SubchunkInfo.cksize/sizeof(Label)]) == NULL ) 
        {
            iErrCode = VAPI_IOERR_MEMORY;
            goto error;
        }
        
        if (mmioRead (m_HWav, (char *)*ppLabels, SubchunkInfo.cksize) != (int)SubchunkInfo.cksize) 
        {
            iErrCode = VAPI_IOERR_LABELACCESS;
            goto error;
        }
        mmioAscend (m_HWav, &SubchunkInfo, 0);
    }
    
error:
    return iErrCode;
}


/*****************************************************************************
* VapiFile::WriteLabels *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiFile::WriteLabels (char* pszName, Label* pLabels, int iNumLabels)
{
    MMCKINFO SubchunkInfo;
    int iErrCode = VAPI_IOERR_NOERROR;
    int iBuffLen;
    
    assert (m_HWav);
    assert (pszName);
    assert (pLabels);
    assert (iNumLabels>0);
    
    SubchunkInfo.ckid = mmioStringToFOURCC (pszName, 0); 
    
    if (mmioCreateChunk (m_HWav, &SubchunkInfo, 0) ) 
    {
        iErrCode = VAPI_IOERR_CREATECHUNK;
        goto error;
    }
    
    iBuffLen = iNumLabels * sizeof(*pLabels);
    if (mmioWrite(m_HWav, (char *)pLabels, iBuffLen) != iBuffLen) 
    {
        iErrCode = VAPI_IOERR_WRITECHUNK;
        goto error;
    }
    mmioAscend (m_HWav, &SubchunkInfo, 0);
    
error:
    return iErrCode;
}


/*****************************************************************************
* VapiIO::ReadVapiFile *
*----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiIO::ReadVapiFile (const char* pszFileName, short** ppnSamples, int* piNumSamples, 
                          int* piSampFreq, int* piSampFormat, int* piF0SampFreq, 
                          float** ppfF0, int* piNumF0, float** ppfRms, int* piNumRms, 
                          Epoch** ppEpochs, int* piNumEpochs,
                          Label** ppPhones, int* piNumPhones, Label** ppWords, int* piNumWords)
{
    VapiIO* pViof = 0;
    void* pvBuffer = NULL;
    int iErrCode = VAPI_IOERR_NOERROR;
    int iRetVal;
    
    assert (pszFileName);


    if (( pViof = VapiIO::ClassFactory()) == 0) 
    {
        iErrCode = VAPI_IOERR_MEMORY;
        goto error;
    }
    
    if ( (iRetVal = pViof->OpenFile (pszFileName, VAPI_IO_READ)) != VAPI_IOERR_NOERROR) 
    {
        iErrCode = iRetVal;
        goto error;
    }
    
    if (ppnSamples && piNumSamples) 
    {
        int sFreq;
        int sType;
        
        iRetVal = pViof->Format (&sFreq, &sType);

        switch (iRetVal) 
        {
        case VAPI_IOERR_NOERROR:
            break;
        case VAPI_IOERR_NOCHUNK:
            sFreq = 0;
            break;
        default:
            iErrCode = iRetVal;
            goto error;
        }
        
        if (piSampFreq) 
        {
            *piSampFreq = sFreq;
        }
        
        if (piSampFormat) 
        {
            *piSampFormat = sType;
        }
        
        /*
         * Read samples
         */
        iRetVal = pViof->ReadSamples (0.0, -1.0, &pvBuffer, piNumSamples, 0);    
        
        switch (iRetVal) 
        {
        case VAPI_IOERR_NOERROR:
            break;
        case VAPI_IOERR_NOCHUNK:
            *ppnSamples  = NULL;
            *piNumSamples = 0;
            break;
        default:
            iErrCode = iRetVal;
            goto error;
        }
        
        /*
         * Convert samples to PCM16
         */  
        if ( (*ppnSamples = new short[*piNumSamples]) == 0) 
        {
            iErrCode = VAPI_IOERR_MEMORY;
            goto error;
        }
        
        DataFormatConversion ((char *)pvBuffer, sType, (char*)*ppnSamples, VAPI_PCM16, *piNumSamples);
        delete[] pvBuffer;
    }
    
    
    if (piF0SampFreq) 
    {
        iRetVal = pViof->ReadF0SampFreq (piF0SampFreq); 
        switch (iRetVal) 
        {
        case VAPI_IOERR_NOERROR:
            break;
        case VAPI_IOERR_NOCHUNK:
            *piF0SampFreq = 0;
            break;
        default:
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
    if (ppEpochs && piNumEpochs) 
    {
        iRetVal = pViof->ReadEpochs(ppEpochs, piNumEpochs);
        switch (iRetVal) 
        {
        case VAPI_IOERR_NOERROR:
            break;
        case VAPI_IOERR_NOCHUNK:
            *ppEpochs  = NULL;
            *piNumEpochs = 0;
            break;
        default:
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
    if (ppfF0 && piNumF0) 
    {
        iRetVal = pViof->ReadFeature ("f0", ppfF0, piNumF0);
        switch (iRetVal) 
        {
        case VAPI_IOERR_NOERROR:
            break;
        case VAPI_IOERR_NOCHUNK:
            *ppfF0  = NULL;
            *piNumF0 = 0;
            break;
        default:
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
    if (ppfRms && piNumRms) 
    {
        iRetVal = pViof->ReadFeature ("rms", ppfRms, piNumRms);
        switch (iRetVal) 
        {
        case VAPI_IOERR_NOERROR:
            break;
        case VAPI_IOERR_NOCHUNK:
            *ppfRms  = NULL;
            *piNumRms = 0;
            break;
        default:
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
    if (ppPhones && piNumPhones) 
    {
        iRetVal = pViof->ReadLabels ("phon", ppPhones, piNumPhones);
        switch (iRetVal) 
        {
        case VAPI_IOERR_NOERROR:
            break;
        case VAPI_IOERR_NOCHUNK:
            *ppPhones  = NULL;
            *piNumPhones = 0;
            break;
        default:
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
    if (ppWords && piNumWords) 
    {
        iRetVal = pViof->ReadLabels ("word", ppWords, piNumWords);
        switch (iRetVal) 
        {
        case VAPI_IOERR_NOERROR:
            break;
        case VAPI_IOERR_NOCHUNK:
            *ppWords  = NULL;
            *piNumWords = 0;
            break;
        default:
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
error:
    if (pViof) 
    {
        pViof->CloseFile();
        delete pViof;
    }

    return iErrCode;
}
/*****************************************************************************
* VapiIO::WriteVapiFile *
*-----------------------*
*   Description:
*
******************************************************************* PACOG ***/
int VapiIO::WriteVapiFile (const char* pszFileName, short* pnSamples, int iNumSamples, int iFormat,
                           int iSampFreq, int iF0SampFreq, float* pfF0, int iNumF0, 
                           float* pfRms, int iNumRms, Epoch* pEpochs, int iNumEpochs,
                           Label* pPhones, int iNumPhones, Label* pWords, int iNumWords)
{
    VapiIO* pViof = 0;
    void* pvBuffer = 0;
    int iErrCode = VAPI_IOERR_NOERROR;
    int iRetVal;
     
    assert (pszFileName);
     
    if (( pViof = VapiIO::ClassFactory()) == 0) 
    {
        iErrCode = VAPI_IOERR_MEMORY;
        goto error;
    }
    
    
    if ( (iRetVal = pViof->OpenFile (pszFileName, VAPI_IO_WRITE)) != VAPI_IOERR_NOERROR) 
    {
        iErrCode = iRetVal;
        goto error;
    }
    
    if (pnSamples && iNumSamples) 
    {
        if ((iRetVal = pViof->WriteFormat (iSampFreq, iFormat)) != VAPI_IOERR_NOERROR) 
        {
            iErrCode = iRetVal;
            goto error;
        }
        
        /*
         * Convert samples to output format
         */  
        if ( (pvBuffer = new char[iNumSamples * SizeOf(iFormat)]) == NULL) 
        {
            iErrCode = VAPI_IOERR_MEMORY;
            goto error;
        }
        
        DataFormatConversion ((char*)pnSamples, VAPI_PCM16, (char *)pvBuffer, iFormat, iNumSamples);
        
        /*
         * Write samples
         */
        if ((iRetVal = pViof->WriteSamples (pvBuffer, iNumSamples)) != VAPI_IOERR_NOERROR) 
        {
            iErrCode = iRetVal;
            goto error;
        }
        
        delete[] pvBuffer;
    }
    
    
    if (iF0SampFreq) 
    {
        if ((iRetVal = pViof->WriteF0SampFreq (iF0SampFreq)) != VAPI_IOERR_NOERROR) 
        {
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
    if (pEpochs && iNumEpochs) 
    {
        if ((iRetVal = pViof->WriteEpochs (pEpochs, iNumEpochs)) != VAPI_IOERR_NOERROR) 
        {
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
    if (pfF0 && iNumF0) 
    {
        if ((iRetVal = pViof->WriteFeature ("f0", pfF0, iNumF0)) != VAPI_IOERR_NOERROR) 
        {
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
    if (pfRms && iNumRms) 
    {
        if ((iRetVal = pViof->WriteFeature ("rms", pfRms, iNumRms)) != VAPI_IOERR_NOERROR) 
        {
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
    if (pPhones && iNumPhones) 
    {
        if ((iRetVal = pViof->WriteLabels ("phon", pPhones, iNumPhones))!= VAPI_IOERR_NOERROR) 
        {
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
    if (pWords && iNumWords) 
    {
        if ((iRetVal = pViof->WriteLabels ("word", pWords, iNumWords)) != VAPI_IOERR_NOERROR) 
        {
            iErrCode = iRetVal;
            goto error;
        }    
    }
    
error:
    if (pViof) 
    {
        pViof->CloseFile ();
        delete pViof;
    }

    return iErrCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\alloops.cpp ===
/*******************************************************************************
* AlloOps.cpp *
*-------------*
*   Description:
*       This module is the implementation file for the CAlloOps class.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"

#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef FeedChain_H
#include "FeedChain.h"
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif




//-----------------------------
// Data.cpp
//-----------------------------
extern const unsigned short  g_Opcode_To_ASCII[];
extern const unsigned long   g_AlloFlags[];


/*****************************************************************************
* CBookmarkList::~CBookmarkList *
*-------------------------------*
*   Description:
*   Destructor for CBookmarkList
*       
********************************************************************** MC ***/
CBookmarkList::~CBookmarkList()
{
    SPDBG_FUNC( "CBookmarkList::~CBookmarkList" );
    BOOKMARK_ITEM*  pItem;

    //----------------------------------------
    //   Remove every item in link list.
    //----------------------------------------
    while( !m_BMList.IsEmpty() )
    {
        pItem = (BOOKMARK_ITEM*)m_BMList.RemoveHead();
        delete pItem;
    }
} /* CBookmarkList::~CBookmarkList */




/*****************************************************************************
* CFEToken::CFEToken *
*------------------------*
*   Description:
*   Initializer for CFEToken
*       
********************************************************************** MC ***/
CFEToken::CFEToken()
{
    SPDBG_FUNC( "CFEToken::CFEToken" );

    user_Volume = DEFAULT_USER_VOL;
    user_Rate = DEFAULT_USER_RATE;
    user_Pitch = DEFAULT_USER_PITCH;
    user_Emph = DEFAULT_USER_EMPH;
    user_Break = 0;
    pBMObj = NULL;

    memset( &tokStr[0], 0, sizeof(WCHAR) * TOKEN_LEN_MAX);
    tokLen = 0;
    memset( &phon_Str[0], 0, sizeof(short) * SP_MAX_PRON_LENGTH);
    phon_Len = 0;
    m_posClass = POS_UNK;
    POScode = MS_Unknown;
    m_TuneBoundaryType = NULL_BOUNDARY;
    m_Accent = K_NOACC;
    m_Boundary = K_NOBND;

	m_TermSil			= 0;
    m_DurScale			= 0.0f;
    m_ProsodyDurScale	= 1.0f;
	m_PitchBaseOffs		= 0.0f;
	m_PitchRangeScale	= 1.0f;

	// The following don't need to be init'd
    m_PronType			= PRON_LTS;
    sentencePosition	= 0;				// Source sentence position for this token
    sentenceLen			= 0; 				// Source sentence length for this token
    srcPosition			= 0;				// Source position for this token
    srcLen				= 0; 				// Source length for this token
    m_Accent_Prom		= 0;                // prominence prosodic control
    m_Boundary_Prom		= 0;                // prominence prosodic control
	m_TermSil			= 0;				// Pad word with silence (in sec)

	//--- Diagnostic
	m_AccentSource		= ACC_NoSource;
	m_BoundarySource	= BND_NoSource;
	m_SilenceSource		= SIL_NoSource;


} /* CFEToken::CFEToken */


/*****************************************************************************
* CFEToken::~CFEToken *
*-----------------------*
*   Description:
*   Destructor for CFEToken
*       
********************************************************************** MC ***/
CFEToken::~CFEToken()
{
    SPDBG_FUNC( "CFEToken::~CFEToken" );

    if( pBMObj != NULL )
    {
        //---------------------------------------
        // Dispose bookmark list
        //---------------------------------------
        delete pBMObj;
    }

} /* CFEToken::~CFEToken */





/*****************************************************************************
* CAlloCell::CAlloCell *
*------------------------*
*   Description:
*   Initializer for CAlloCell
*       
********************************************************************** MC ***/
CAlloCell::CAlloCell()
{
    SPDBG_FUNC( "CAlloCell::CAlloCell" );
    long    i;

    m_allo				= _SIL_;
    m_dur				= 0;
    m_ftDuration		= m_UnitDur = 0;
    m_knots				= KNOTS_PER_PHON;
    m_ctrlFlags			= 0;
    m_user_Rate			= 0;
    m_user_Volume		= DEFAULT_USER_VOL;
    m_user_Pitch		= 0;
    m_user_Emph			= 0;
    m_user_Break		= 0;
    m_Sil_Break			= 0;
    m_Pitch_HI			= 0;
    m_Pitch_LO			= 0;
    m_pBMObj			= NULL;
    m_ToBI_Boundary		= K_NOBND;
    m_ToBI_Accent		= K_NOACC;
	m_TuneBoundaryType	= m_NextTuneBoundaryType = NULL_BOUNDARY;
    m_DurScale			= 1.0;
    m_ProsodyDurScale	= 1.0;
	m_PitchBaseOffs		= 0.0f;
	m_PitchRangeScale	= 1.0f;
    for( i = 0; i < KNOTS_PER_PHON; i++ )
    {
        m_ftTime[i] = 0;
        m_ftPitch[i] = 100;
    }


    m_Accent_Prom	 = 0;                   // prominence prosodic control
    m_Boundary_Prom	 = 0;                 // prominence prosodic control
    m_PitchBufStart	 = 0;
    m_PitchBufEnd	 = 0;
    m_SrcPosition	 = 0;
    m_SrcLen		 = 0;
    m_SentencePosition	 = 0;
    m_SentenceLen		 = 0;

	//--- Diagnostic
	m_AccentSource		= ACC_NoSource;
	m_BoundarySource	= BND_NoSource;
	m_SilenceSource		= SIL_NoSource;
	m_pTextStr			= NULL;

} /* CAlloCell::CAlloCell */


/*****************************************************************************
* CAlloCell::~CAlloCell *
*-----------------------*
*   Description:
*   Destructor for CAlloCell
*       
********************************************************************** MC ***/
CAlloCell::~CAlloCell()
{
    SPDBG_FUNC( "CAlloCell::~CAlloCell" );

    if( m_pBMObj != NULL )
    {
        //---------------------------------------
        // Dispose bookmark list
        //---------------------------------------
        delete m_pBMObj;
    }

    if( m_pTextStr != NULL )
    {
        //---------------------------------------
        // Dispose bookmark list
        //---------------------------------------
        delete m_pTextStr;
    }


} /* CAlloCell::~CAlloCell */





/*****************************************************************************
* CAlloList::CAlloList *
*------------------------*
*   Description:
*   Initialize list with 2 silence entries. These will 
*   become the head an tail when real entries are stuffed
*       
********************************************************************** MC ***/
CAlloList::CAlloList()
{
    SPDBG_FUNC( "CAlloList::CAlloList" );
    CAlloCell   *pCell;

    m_cAllos = 0;
	m_ListPos = NULL;
    //------------------------------------
    // Create initial TAIL silence cell
    //------------------------------------
    pCell = new CAlloCell;
    if( pCell )
    {
        m_AlloCellList.AddHead( pCell );
        pCell->m_ctrlFlags |= WORD_START + TERM_BOUND;
        pCell->m_TuneBoundaryType = TAIL_BOUNDARY;
		pCell->m_SilenceSource = SIL_Tail;
        m_cAllos++;
    }
    //------------------------------------
    // Create initial HEAD silence cell
    //------------------------------------
    pCell = new CAlloCell;
    if( pCell )
    {
        m_AlloCellList.AddHead( pCell );
        pCell->m_ctrlFlags |= WORD_START;
		pCell->m_SilenceSource = SIL_Head;
        m_cAllos++;
    }
} /* CAlloList::CAlloList */


                


/*****************************************************************************
* CAlloList::~CAlloList *
*-------------------------*
*   Description:
*   Remove every item in link list.
*       
********************************************************************** MC ***/
CAlloList::~CAlloList()
{
    SPDBG_FUNC( "CAlloList::~CAlloList" );
    CAlloCell   *pCell;

    while( !m_AlloCellList.IsEmpty() )
    {
        pCell = (CAlloCell*)m_AlloCellList.RemoveHead();
        delete pCell;
    }

} /* CAlloList::~CAlloList */





/*****************************************************************************
* CAlloList::GetAllo *
*---------------------*
*   Description:
*   Return pointer of allocell at index
*       
********************************************************************** MC ***/
CAlloCell *CAlloList::GetCell( long index )
{
    SPDBG_FUNC( "CAlloList::GetCell" );

    return (CAlloCell*)m_AlloCellList.GetAt( m_AlloCellList.FindIndex( index ));
} /* CAlloList::GetCell */


/*****************************************************************************
* CAlloList::GetTailCell *
*-------------------------*
*   Description:
*   Return pointer of last allo in link list
*       
********************************************************************** MC ***/
CAlloCell *CAlloList::GetTailCell()
{
    SPDBG_FUNC( "CAlloList::GetTailCell" );

    return (CAlloCell*)m_AlloCellList.GetTail();
} /* CAlloList::GetTailCell */


/*****************************************************************************
* CAlloList::GetTailCell *
*-----------------------*
*   Description:
*   Return allo list size
*       
********************************************************************** MC ***/
long CAlloList::GetCount()
{
    SPDBG_FUNC( "CAlloList::GetCount" );

    return m_AlloCellList.GetCount();
} /* CAlloList::GetCount */





/*****************************************************************************
* PrintPhon *
*-----------*
*   Description:
*   Print 2-char allo name
*       
********************************************************************** MC ***/
void PrintPhon( ALLO_CODE allo, char * /*msgStr*/)
{
    SPDBG_FUNC( "PrintPhon" );

    unsigned short  nChar;
    
    nChar = g_Opcode_To_ASCII[allo];
    if( nChar >> 8 )
    {
        SPDBG_DMSG1( "%c", nChar >> 8 );
    }
    if( nChar && 0xFF )
    {
        SPDBG_DMSG1( "%c", nChar & 0xFF );
    }
} /* PrintPhon */




/*****************************************************************************
* CAlloList::OutAllos *
*--------------------*
*   Description:
*   Dump ALLO_CELL contents
*       
********************************************************************** MC ***/
void CAlloList::OutAllos()
{
    SPDBG_FUNC( "CAlloOps::OutAllos" );
    CAlloCell       *pCurCell;

    long    i, flags, flagsT;
    char    msgStr[400];
    
    for( i = 0; i < m_cAllos; i++ )
    {
        pCurCell = GetCell( i );
        flags = pCurCell->m_ctrlFlags;
        
        if( flags & WORD_START)
        {
            SPDBG_DMSG0( "\n" );
        }
        
        //----------------------------
        // Allo
        //----------------------------
        PrintPhon( pCurCell->m_allo, msgStr );
        
        //----------------------------
        // Duration
        //----------------------------
        SPDBG_DMSG1( "\t%.3f\t", pCurCell->m_ftDuration );
        
        //----------------------------
        // Boundry
        //----------------------------
        if( flags & BOUNDARY_TYPE_FIELD)
        {
            SPDBG_DMSG0( "(" );
            if( flags & WORD_START)
            {
                SPDBG_DMSG0( "-wS" );
            }
            if( flags & TERM_BOUND)
            {
                SPDBG_DMSG0( "-tB" );
            }
            SPDBG_DMSG0( ")\t" );
        }
        
        //----------------------------
        // Syllable type
        //----------------------------
        if( flags & SYLLABLE_TYPE_FIELD)
        {
            SPDBG_DMSG0( "(" );
            if( flags & WORD_END_SYLL)
            {
                SPDBG_DMSG0( "-wE" );
            }
            if( flags & TERM_END_SYLL)
            {
                SPDBG_DMSG0( "-tE" );
            }
            SPDBG_DMSG0( ")\t" );
        }
        
        //----------------------------
        // Syllable order
        //----------------------------
        if( flags & SYLLABLE_ORDER_FIELD)
        {
            SPDBG_DMSG0( "(" );
            
            flagsT = flags & SYLLABLE_ORDER_FIELD;
            if( flagsT == FIRST_SYLLABLE_IN_WORD)
            {
                SPDBG_DMSG0( "-Fs" );
            }
            else if( flagsT == MID_SYLLABLE_IN_WORD)
            {
                SPDBG_DMSG0( "-Ms" );
            }
            else if( flagsT == LAST_SYLLABLE_IN_WORD)
            {
                SPDBG_DMSG0( "-Ls" );
            }
            SPDBG_DMSG0( ")\t" );
        }
        
        //----------------------------
        // Stress
        //----------------------------
        if( flags & PRIMARY_STRESS)
        {
            SPDBG_DMSG0( "-Stress\t" );
        }
        
        //----------------------------
        // Word initial consonant
        //----------------------------
        if( flags & WORD_INITIAL_CONSONANT)
        {
            SPDBG_DMSG0( "-InitialK\t" );
        }
        
        //----------------------------
        // Syllable start
        //----------------------------
        if( flags & SYLLABLE_START)
        {
            SPDBG_DMSG0( "-Syll\t" );
        }
        
        SPDBG_DMSG0( "\n" );
        }
} /* CAlloList::OutAllos */




/*****************************************************************************
* CAlloList::WordToAllo *
*-----------------------*
*   Description:
*   Copy word token to AlloCells
*   Insert allos BEFORE 'pEndCell'
*       
********************************************************************** MC ***/
bool CAlloList::WordToAllo( CFEToken *pPrevTok, CFEToken *pTok, CFEToken *pNextTok, CAlloCell *pEndCell )
{
    SPDBG_FUNC( "CAlloList::WordToAllo" );

    long    i;
    long    startLatch;
    CAlloCell   *pCurCell;
    long    firstVowel, lastVoiced;
    bool    gotAccent, isStressed;
	bool	hasSpeech;
    
    //-----------------------------------------
    // First, find ToBI accent locations
    //-----------------------------------------
    firstVowel  = lastVoiced = (-1);
    gotAccent   = false;
	hasSpeech	= false;
    for( i = 0; i < pTok->phon_Len; i++ )
    {
        isStressed = false;
        if( pTok->phon_Str[i] < _STRESS1_ )
        {
            //----------------------------
            // Potential ToBI accent
            //----------------------------
            if( (!gotAccent) && (g_AlloFlags[pTok->phon_Str[i]] & KVOWELF) )
            {
                if( (i < (pTok->phon_Len -1)) && (pTok->phon_Str[i+1] == _STRESS1_) )
                {
                    //-------------------------------------
                    // Put accent at 1st stressed vowel
                    //-------------------------------------
                    firstVowel = i;
                    gotAccent = true;
                }
                else if( firstVowel < 0 )
                {
                    //-------------------------------------
                    // In case there's no stressed vowel 
                    // in this word, use 1st vowel
                    //-------------------------------------
                    firstVowel = i;
                }
            }
            //----------------------------
            // Potential ToBI boundary
            //----------------------------
            if( g_AlloFlags[pTok->phon_Str[i]] & KVOICEDF )
            {
                lastVoiced = i;
            }
        }
    }
    //-----------------------------------------
    // Now, copy data to allo list
    //-----------------------------------------
    startLatch  = true;
    for( i = 0; i < pTok->phon_Len; i++ )
    {
        if( pTok->phon_Str[i] < _STRESS1_ )
        {
			if( (pTok->phon_Str[i] == _SIL_) && (pTok->m_TuneBoundaryType >= SUB_BOUNDARY_1) )
			{
				//----------------------------------------------------------------
				// Before skipping this, propagate the dur scale gain
				//----------------------------------------------------------------
				if( pTok->m_DurScale == 0 )
				{
					if( pPrevTok )
					{
						pTok->m_DurScale = pPrevTok->m_DurScale;
					}
					else
					{
						pTok->m_DurScale = 1.0;
					}
				}
				continue;
			}
            //------------------------------------
            // Create new cell
            //------------------------------------
            pCurCell = new CAlloCell;
            if( pCurCell )
            {
                m_AlloCellList.InsertBefore( m_AlloCellList.Find(pEndCell), pCurCell);
                m_cAllos++;

                //----------------------------
                // Copy only phons
                //----------------------------
                pCurCell->m_allo = (ALLO_CODE) pTok->phon_Str[i];
                //---------------------------------------------
                // See if this allo will generate speech
                //---------------------------------------------
				if( (pCurCell->m_allo >= _IY_) &&
					(pCurCell->m_allo <= _DX_) &&
					(pCurCell->m_allo != _SIL_) )
				{
					hasSpeech = true;
				}

                //----------------------------
                // Save src position
                //----------------------------
                pCurCell->m_SrcPosition = pTok->srcPosition;
                pCurCell->m_SrcLen = pTok->srcLen;
                pCurCell->m_SentencePosition = pTok->sentencePosition;
                pCurCell->m_SentenceLen = pTok->sentenceLen;

                //----------------------------
                // Flag WORD START?
                //----------------------------
                if( startLatch )
                {
                    pCurCell->m_ctrlFlags |= WORD_START;
                    startLatch = false;
                }

                //----------------------------
                // Is next allo a STRESS?
                //----------------------------
                if( i < (pTok->phon_Len -1) )
                {
                    if( pTok->phon_Str[i+1] == _STRESS1_ )
                    {
                        pCurCell->m_ctrlFlags |= PRIMARY_STRESS;
                    }
					else
					{
						//----------------------------------------------
						// Voice inventory does not have unstressed
						// entries for these diphongs
						//----------------------------------------------
						if( (pCurCell->m_allo == _AW_) ||
							(pCurCell->m_allo == _AY_) ||
							(pCurCell->m_allo == _EY_) ||
							(pCurCell->m_allo == _OY_) )
						{
							pCurCell->m_ctrlFlags |= PRIMARY_STRESS;
						}
					}
                }

				//---------------------------
				// Diagnostic
				//---------------------------
				if( pCurCell->m_allo == _SIL_ )
				{
					pCurCell->m_SilenceSource = pTok->m_SilenceSource;
				}
                //----------------------------
                // Place ToBI accent
                //----------------------------
                if( i == firstVowel )
                {
                    pCurCell->m_ToBI_Accent = pTok->m_Accent;
					//---------------------------
					// Diagnostic
					//---------------------------
					pCurCell->m_AccentSource = pTok->m_AccentSource;
					pCurCell->m_pTextStr = new char[pTok->tokLen+1];
					if( pCurCell->m_pTextStr )
					{
						WideCharToMultiByte (	CP_ACP, 0, 
												pTok->tokStr, -1, 
												pCurCell->m_pTextStr, pTok->tokLen+1, 
												NULL, NULL);
					}
                }
                pCurCell->m_Accent_Prom = pTok->m_Accent_Prom;
                //----------------------------
                // Place ToBI boundary
                //----------------------------
                if( i == lastVoiced )
                {
                    pCurCell->m_ToBI_Boundary = pTok->m_Boundary;
					//---------------------------
					// Diagnostic
					//---------------------------
					pCurCell->m_BoundarySource = pTok->m_BoundarySource;
                }
                pCurCell->m_Boundary_Prom = pTok->m_Boundary_Prom;

                //----------------------------
                // User Controls
                //----------------------------
                pCurCell->m_user_Volume = pTok->user_Volume;
                pCurCell->m_user_Rate = pTok->user_Rate;
                pCurCell->m_user_Pitch = pTok->user_Pitch;
				pCurCell->m_user_Emph = 0;
				if( pTok->user_Emph > 0 )
				{
					if( i == firstVowel )
					{
						pCurCell->m_user_Emph = pTok->user_Emph;
						pCurCell->m_ctrlFlags |= PRIMARY_STRESS;
					}
				}
                pCurCell->m_user_Break = pTok->user_Break;
                pCurCell->m_pBMObj = pTok->pBMObj;
                pTok->pBMObj = NULL;

				//-----------------------------------------------
				// If token's m_DurScale is not defined,
				//  try to use prev token's ratio
				//-----------------------------------------------
				if( pTok->m_DurScale == 0 )
				{
					if( pPrevTok )
					{
						pCurCell->m_DurScale = pPrevTok->m_DurScale;
					}
					else
					{
						pCurCell->m_DurScale = 1.0;
					}
					//-------------------------------------------------------
					// Write back in case next token is also undefined
					//-------------------------------------------------------
					pTok->m_DurScale = pCurCell->m_DurScale;
				}
				else
				{
					pCurCell->m_DurScale = pTok->m_DurScale;
				}
				pCurCell->m_ProsodyDurScale = pTok->m_ProsodyDurScale;

				if( pNextTok )
				{
					pCurCell->m_NextTuneBoundaryType = pNextTok->m_TuneBoundaryType;
				}
				else
				{
					pCurCell->m_NextTuneBoundaryType = NULL_BOUNDARY;
				}
				pCurCell->m_PitchBaseOffs = pTok->m_PitchBaseOffs;
				pCurCell->m_PitchRangeScale = pTok->m_PitchRangeScale;

                //----------------------------------------------
                // Is this a term word?
                //----------------------------------------------
                pCurCell->m_TuneBoundaryType = pTok->m_TuneBoundaryType;
                if( pTok->m_TuneBoundaryType != NULL_BOUNDARY )
                {
                    pCurCell->m_ctrlFlags |= TERM_BOUND + WORD_START;
                }
            }
        }

    }
	//----------------------------------------
	// Insert word pause?
	//----------------------------------------
	if( pTok->m_TermSil > 0 )
	{
        pCurCell = new CAlloCell;
        if( pCurCell )
        {
            m_AlloCellList.InsertBefore( m_AlloCellList.Find(pEndCell), pCurCell);
            m_cAllos++;

            //----------------------------
            // Add silence
            //----------------------------
            pCurCell->m_allo = _SIL_;

            //----------------------------
            // Save src position
            //----------------------------
            pCurCell->m_SrcPosition = pTok->srcPosition;
            pCurCell->m_SrcLen = pTok->srcLen;
            pCurCell->m_SentencePosition = pTok->sentencePosition;
            pCurCell->m_SentenceLen = pTok->sentenceLen;
            //----------------------------
            // User Controls
            //----------------------------
            pCurCell->m_user_Volume = pTok->user_Volume;
            pCurCell->m_user_Rate = pTok->user_Rate;
            pCurCell->m_user_Pitch = pTok->user_Pitch;
            pCurCell->m_user_Emph = pTok->user_Emph;
            pCurCell->m_user_Break = pTok->user_Break;
            pCurCell->m_pBMObj = NULL;
            pCurCell->m_TuneBoundaryType = pTok->m_TuneBoundaryType;
            pCurCell->m_Boundary_Prom = pTok->m_Boundary_Prom;
            pCurCell->m_Accent_Prom = pTok->m_Accent_Prom;
			pCurCell->m_ctrlFlags = 0;
			pCurCell->m_UnitDur = pTok->m_TermSil;
            pCurCell->m_Sil_Break = (unsigned long)(pCurCell->m_UnitDur * 1000);	// sec -> ms
			pCurCell->m_user_Break = 0;
			pCurCell->m_DurScale = pTok->m_DurScale;
			pCurCell->m_ProsodyDurScale = 1.0f;
		}
	}

	return hasSpeech;
} /* CAlloList::WordToAllo */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\common\vapiio\vapiio.h ===
/******************************************************************************
* vapiIo.h *
*----------*
*  I/O library functions for extended speech files (vapi format)
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 03/02/00
*  All Rights Reserved
*
********************************************************************* PACOG ***/

#ifndef __VAPIIO_H_
#define __VAPIIO_H_

#include <windows.h>
#include <mmreg.h>

#define VAPI_MAX_LABEL  80

// File open modes
enum {
  VAPI_IO_READ = 1,
  VAPI_IO_WRITE,
  VAPI_IO_READWRITE
};

// Error codes
enum {
  VAPI_IOERR_NOERROR, 
  VAPI_IOERR_MODE,
  VAPI_IOERR_MEMORY,
  VAPI_IOERR_CANTOPEN,
  VAPI_IOERR_NOWAV,
  VAPI_IOERR_NOFORMAT,
  VAPI_IOERR_STEREO,
  VAPI_IOERR_FORMAT,
  VAPI_IOERR_NOCHUNK,
  VAPI_IOERR_DATAACCESS,
  VAPI_IOERR_F0SFACCESS,
  VAPI_IOERR_FEATACCESS,
  VAPI_IOERR_EPOCHACCESS,
  VAPI_IOERR_LABELACCESS,
  VAPI_IOERR_WRITEWAV,
  VAPI_IOERR_CREATECHUNK, 
  VAPI_IOERR_WRITECHUNK
};

// Possible values for sample format
enum {
  VAPI_PCM16,
  VAPI_PCM8, 
  VAPI_ALAW,
  VAPI_ULAW
};

// TYPES 
struct Epoch {
  double time;
  char   voiced;
};

struct Label {
  char   label[VAPI_MAX_LABEL];
  float  endTime;
};

struct F0Vector {
  float* f0;
  int nF0;
  int sampFreq;
};

//----------------------------------------------------------------------
// VAPI FILE I/O CLASS
//

class VapiIO 
{
    public:
        virtual ~VapiIO() {};

        virtual int   OpenFile ( const char* pszFileName, int iMode ) = 0; 
        virtual int   OpenFile ( const WCHAR* wcsFileName, int iMode ) = 0; 
        virtual void  CloseFile ( ) = 0;

        virtual int   CreateChunk ( const char* pszNname ) = 0;
        virtual int   CloseChunk ( ) = 0;
        virtual int   WriteToChunk (const char* pcData, int iSize) = 0;

        virtual int   GetDataSize (long* lDataSize) = 0;
        virtual int   Format (int* piSampFreq, int* piFormat, WAVEFORMATEX* pWaveFormatEx = NULL) = 0;
        virtual int   WriteFormat (int iSampFreq, int iFormat) = 0;

        virtual int   ReadSamples (double dFrom, double dTo, void** pvSamples, int* iNumSamples, bool bClosedInterval) = 0;
        virtual int   WriteSamples (void* pvSamples, int iNumSamples) = 0;

        virtual int   ReadF0SampFreq (int* piSampFreq) = 0;
        virtual int   WriteF0SampFreq (int iSampFreq) = 0;

        virtual int   ReadFeature (char* pszName, float** ppfSamples, int* piNumSamples) = 0;
        virtual int   WriteFeature (char* pszName, float* pfSamples, int iNumSamples) = 0;

        virtual int   ReadEpochs (Epoch** ppEpochs, int* piNumEpochs) = 0;
        virtual int   WriteEpochs (Epoch* pEpochs, int iNumEpochs) = 0;

        virtual int   ReadLabels (char* pszName, Label** ppLabels, int* piNumLabels) = 0;
        virtual int   WriteLabels (char* pszName, Label* pLabels, int iNumLabels) = 0;

        virtual char* ErrMessage (int iErrCode) = 0;

        static int   TypeOf (WAVEFORMATEX *pWavFormat);
        static int   SizeOf (int iType);
        static int   DataFormatConversion (char* pcInput, int iInType, 
                                            char* pcOutput, int iOutType, int iNumSamples);

        static VapiIO* ClassFactory();

        // High Level Functions

        static int  ReadVapiFile (const char* pszFileName, short** ppnSamples, int* piNumSamples, 
                                  int* piSampFreq, int* piSampFormat,int* piF0SampFreq, float** ppfF0, int* piNumF0, 
                                  float** ppfRms, int* piNumRms, Epoch** ppEpochs, int* piNumEpochs,
                                  Label** ppPhones, int* piNumPhones, Label** ppWords, int* piNumWords);

        static int  WriteVapiFile (const char* pszFileName, short* pnSamples, int iNumSamples, int iFormat,
                                   int iSampFreq, int iF0SampFreq, float* pfF0, int iNumF0, 
                                   float* pfRms, int iNumRms, Epoch* pEpochs, int iNumEpochs,
                                   Label* pPhones, int iNumPhones, Label* pWords, int iNumWords);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\alphanorm.cpp ===
/***********************************************************************************************
* AlphaNorm.cpp *
*---------------*
*  Description:
*   These functions normalize mostly-alpha strings.
*-----------------------------------------------------------------------------------------------
*  Created by AARONHAL                                                           August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"
#include "stdsentenum.h"

/***********************************************************************************************
* IsAbbreviationEOS *
*-------------------*
*   Description:
*       Abbreviations which get here are ALWAYS abbreviations.  This function tries to determine 
*   whether or not the period at the end of the abbreviation is the end of the sentence.  
*
*   If match made:
*       Sets the Item in the ItemList at ItemPos to the abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsAbbreviationEOS( const AbbrevRecord* pAbbreviation, CItemList &ItemList, SPLISTPOS ItemPos, 
                                         CSentItemMemory &MemoryManager, BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IsAbbreviationEOS" );
    HRESULT hr = S_OK;
    BOOL fMatchedEOS = false;

    //--- Need to determine whether the abbreviation's period is also the end of the sentence.
    if ( !(*pfIsEOS) )
    {
        //--- Advance to the beginning of the next token
        const WCHAR *pTempNextChar = (WCHAR*) m_pEndOfCurrToken, *pTempEndChar = (WCHAR*) m_pEndChar;
        const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
        hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

        if ( SUCCEEDED( hr ) )
        {

            //--- If we have reached the end of the buffer, consider the abbreviation's period as
            //--- the end of the sentence.
            if ( !pTempNextChar )
            {
                *pfIsEOS = true;
                fMatchedEOS = true;
            }
            //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
            //--- the next token is a common first word (which must be capitalized).
            else if ( IsCapital( *pTempNextChar ) )
            {
                WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                //--- Try to match a first word.
                WCHAR temp = (WCHAR) *pTempEndOfItem;
                *pTempEndOfItem = 0;
                
                if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                              sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                {
                    *pfIsEOS = true;
                    fMatchedEOS = true;
                }

                *pTempEndOfItem = temp;
            }
        }
    }

    //--- Insert abbreviation into the ItemList
    if ( SUCCEEDED( hr ) )
    {
        CSentItem Item;

        Item.pItemSrcText       = m_pNextChar;
        Item.ulItemSrcLen       = (long) (m_pEndOfCurrItem - m_pNextChar);
        Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                  (long)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords         = 1;
        Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState  = &m_pCurrFrag->State;
            Item.Words[0].pWordText  = Item.pItemSrcText;
            Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
            Item.Words[0].pLemma     = Item.pItemSrcText;
            Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                if ( NeedsToBeNormalized( pAbbreviation ) )
                {
                    Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                }
                else
                {
                    Item.pItemInfo->Type = eABBREVIATION;
                }
                ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbreviation;
                ItemList.SetAt( ItemPos, Item );
            }
        }
    }

    return hr;
} /* IsAbbreviationEOS */

/***********************************************************************************************
* IfEOSNotAbbreviation *
*----------------------*
*   Description:
*       Abbreviations which get here may or may not be abbreviations.  If the period is EOS,
*   this is not an abbreviation (and return will be E_INVALIDARG), otherwise, it is an
*   abbreviation.
*
*   If match made:
*       Sets the Item in the ItemList at ItemPos to the abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IfEOSNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList &ItemList, SPLISTPOS ItemPos, 
                                            CSentItemMemory &MemoryManager, BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IfEOSNotAbbreviation" );
    HRESULT hr = S_OK;

    //--- Need to determine whether the abbreviation's period is also the end of the sentence.
    if ( !(*pfIsEOS) )
    {
        //--- Advance to the beginning of the next token
        const WCHAR *pTempNextChar = m_pEndOfCurrToken, *pTempEndChar = m_pEndChar;
        const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
        hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

        if ( !pTempNextChar )
        {
            hr = E_INVALIDARG;
        }

        if ( SUCCEEDED( hr ) )
        {

            //--- If we have reached the end of the buffer, consider the abbreviation's period as
            //--- the end of the sentence.
            if ( !pTempNextChar )
            {
                *pfIsEOS = true;
            }
            //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
            //--- the next token is a common first word (which must be capitalized).
            else if ( IsCapital( *pTempNextChar ) )
            {
                WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                //--- Try to match a first word.
                WCHAR temp = (WCHAR) *pTempEndOfItem;
                *pTempEndOfItem = 0;
                
                if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                              sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                {
                    *pfIsEOS = true;
                }

                *pTempEndOfItem = temp;
            }
        }
    }
    
    if ( *pfIsEOS )
    {
        //--- EOS - not an abbreviation
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Insert abbreviation into the ItemList
        CSentItem Item;

        Item.pItemSrcText       = m_pNextChar;
        Item.ulItemSrcLen       = (long)(m_pEndOfCurrItem - m_pNextChar);
        Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                  (long)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords         = 1;
        Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState  = &m_pCurrFrag->State;
            Item.Words[0].pWordText  = Item.pItemSrcText;
            Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
            Item.Words[0].pLemma     = Item.pItemSrcText;
            Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                if ( NeedsToBeNormalized( pAbbreviation ) )
                {
                    Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                }
                else
                {
                    Item.pItemInfo->Type = eABBREVIATION;
                }
                ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbreviation;
                ItemList.SetAt( ItemPos, Item );
            }
        }
    }

    return hr;
} /* IfEOSNotAbbreviation */

/***********************************************************************************************
* IfEOSAndLowercaseNotAbbreviation *
*----------------------------------*
*   Description:
*       Abbreviations which get here may or may not be abbreviations.  If the period is EOS,
*   and the next item is lowercase this is not an abbreviation (and return will be E_INVALIDARG), 
*   otherwise, it is an abbreviation.
*
*   If match made:
*       Sets the Item in the ItemList at ItemPos to the abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IfEOSAndLowercaseNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList &ItemList, 
                                                        SPLISTPOS ItemPos, CSentItemMemory &MemoryManager, 
                                                        BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IfEOSAndLowercaseNotAbbreviation" );
    HRESULT hr = S_OK;

    //--- Need to determine whether the abbreviation's period is also the end of the sentence.
    if ( !(*pfIsEOS) )
    {
        //--- Advance to the beginning of the next token
        const WCHAR *pTempNextChar = m_pEndOfCurrToken, *pTempEndChar = m_pEndChar;
        const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
        hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

        if ( SUCCEEDED( hr ) )
        {

            //--- If we have reached the end of the buffer, consider the abbreviation's period as
            //--- the end of the sentence.
            if ( !pTempNextChar )
            {
                *pfIsEOS = true;
            }
            //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
            //--- the next token is a common first word (which must be capitalized).
            else if ( IsCapital( *pTempNextChar ) )
            {
                WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                //--- Try to match a first word.
                WCHAR temp = (WCHAR) *pTempEndOfItem;
                *pTempEndOfItem = 0;
                
                if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                              sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                {
                    *pfIsEOS = true;
                }

                *pTempEndOfItem = temp;
            }
        }
    }
    
    if ( *pfIsEOS &&
         !iswupper( *m_pNextChar ) )
    {
        //--- EOS - not an abbreviation
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Insert abbreviation into the ItemList
        CSentItem Item;

        Item.pItemSrcText       = m_pNextChar;
        Item.ulItemSrcLen       = (long)(m_pEndOfCurrItem - m_pNextChar);
        Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                  (long)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords         = 1;
        Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState  = &m_pCurrFrag->State;
            Item.Words[0].pWordText  = Item.pItemSrcText;
            Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
            Item.Words[0].pLemma     = Item.pItemSrcText;
            Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                if ( NeedsToBeNormalized( pAbbreviation ) )
                {
                    Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                }
                else
                {
                    Item.pItemInfo->Type = eABBREVIATION;
                }
                ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbreviation;
                ItemList.SetAt( ItemPos, Item );
            }
        }
    }

    return hr;
} /* IfEOSNotAbbreviation */

/***********************************************************************************************
* SingleOrPluralAbbreviation *
*----------------------------*
*   Description:
*       At this point, we are already sure that the item is an abbreviation, and just need to
*   determine whether it should take its singular form, plural form, or some alternate.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::SingleOrPluralAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                                  CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::SingleOrPluralAbbreviation" );
    HRESULT hr = S_OK;

    //--- Get Item which comes before the abbreviation
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        pPron->pronArray[PRON_A].POScount = 1;
        pPron->pronArray[PRON_B].POScount = 0;
        pPron->pronArray[PRON_B].phon_Len = 0;
        pPron->hasAlt                     = false;
        pPron->altChoice                  = PRON_A;
        //--- Abbreviation table pronunciations are basically just vendor lex prons...
        pPron->pronType                   = eLEXTYPE_PRIVATE1;

        //--- If a cardinal number, need to do singular vs. plural logic
        if ( TempItem.pItemInfo->Type == eNUM_CARDINAL ||
             TempItem.pItemInfo->Type == eDATE_YEAR )
        {
            if ( ( TempItem.ulItemSrcLen == 1 &&
                   wcsncmp( TempItem.pItemSrcText, L"1", 1 ) == 0 ) ||
                 ( TempItem.ulItemSrcLen == 2 &&
                   wcsncmp( TempItem.pItemSrcText, L"-1", 2 ) == 0 ) )
            {
                //--- Use singular form - first entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
            else
            {
                //--- Use plural form - second entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
        }
        //--- If a decimal number, pick plural
        else if ( TempItem.pItemInfo->Type == eNUM_DECIMAL )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
        //--- If an ordinal number or fraction, pick singular
        else if ( TempItem.pItemInfo->Type == eNUM_ORDINAL )
        {
            //--- Use singular form - first entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Fractions and mixed fractions require some more work...
        else if ( TempItem.pItemInfo->Type == eNUM_FRACTION )
        {
            if ( ( (TTSNumberItemInfo*) TempItem.pItemInfo )->pFractionalPart->fIsStandard )
            {
                //--- Standard fractions (e.g. 11/20) get the plural form
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;

            }
            else
            {
                //--- Singular form with [of a] or [of an] inserted beforehand
                if ( bsearch( (void*) pAbbrevInfo->pPron1, (void*) g_Vowels, sp_countof( g_Vowels ), 
                     sizeof( WCHAR ), CompareWCHARAndWCHAR ) )
                {
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, g_pOfAn );
                    pPron->pronArray[PRON_A].phon_Len = wcslen( g_pOfAn );
                }
                else
                {
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, g_pOfA );
                    pPron->pronArray[PRON_A].phon_Len = wcslen( g_pOfA );
                }
                wcscat( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   += wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
        }
        else if ( TempItem.pItemInfo->Type == eNUM_MIXEDFRACTION )
        {
            //--- Plural form
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;

        }
        //--- Special case - preceded by "one"
        else if ( TempItem.ulItemSrcLen == 3 &&
                  wcsnicmp( TempItem.pItemSrcText, L"one", 3 ) == 0 )
        {
            //--- Use singular form - first entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Special case - Number cu. MeasurementAbbrev (e.g. 10 cu. cm, 1 cu cm)
        //--- Special case - Number fl. MeasurementAbbrev (e.g. 10 fl. oz., 10 fl oz)
        else if ( ( TempItem.ulItemSrcLen == 2 &&
                    ( _wcsnicmp( TempItem.pItemSrcText, L"cu", 2 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"sq", 2 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"fl", 2 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 3 &&
                    ( _wcsnicmp( TempItem.pItemSrcText, L"cu.", 3 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"sq.", 3 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"fl.", 3 ) == 0 ) ) )
        {
            if ( TempPos )
            {
                TempItem = ItemList.GetPrev( TempPos );
                //--- If a cardinal number, need to do singular vs. plural logic
                if ( TempItem.pItemInfo->Type == eNUM_CARDINAL )
                {
                    if ( ( TempItem.ulItemSrcLen == 1 &&
                           wcsncmp( TempItem.pItemSrcText, L"1", 1 ) == 0 ) ||
                         ( TempItem.ulItemSrcLen == 2 &&
                           wcsncmp( TempItem.pItemSrcText, L"-1", 2 ) == 0 ) )
                    {
                        //--- Use singular form - first entry
                        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                        pPron->POSchoice                    = pAbbrevInfo->POS1;
                    }
                    else
                    {
                        //--- Use plural form - second entry
                        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                        pPron->POSchoice                    = pAbbrevInfo->POS2;
                    }
                }
                //--- If a decimal number, pick plural
                else if ( TempItem.pItemInfo->Type == eNUM_DECIMAL )
                {
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;
                }
                //--- If an ordinal number or fraction, pick singular
                else if ( TempItem.pItemInfo->Type == eNUM_ORDINAL )
                {
                    //--- Use singular form - first entry
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                    pPron->POSchoice                    = pAbbrevInfo->POS1;
                }
                //--- Fractions and mixed fractions require some more work...
                else if ( TempItem.pItemInfo->Type == eNUM_FRACTION )
                {
                    if (( (TTSNumberItemInfo*) TempItem.pItemInfo )->pFractionalPart->fIsStandard ) 
                    {
						//--- Standard fractions (e.g. 11/20) get the plural form
						wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
						pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
					    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
					    pPron->POSchoice                    = pAbbrevInfo->POS2;
                    }
                    else
                    {
                        //--- Singular form with [of a] or [of an] inserted beforehand
						//--- (this was handled when processing 'cu' or 'sq')
                        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                        pPron->POSchoice                    = pAbbrevInfo->POS1;
                    }
                }
                else if ( TempItem.pItemInfo->Type == eNUM_MIXEDFRACTION )
                {
                    //--- Plural form
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;

                }
                //--- Special case - preceded by "one"
                else if ( TempItem.ulItemSrcLen == 3 &&
                          wcsnicmp( TempItem.pItemSrcText, L"one", 3 ) == 0 )
                {
                    //--- Use singular form - first entry
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                    pPron->POSchoice                    = pAbbrevInfo->POS1;
                }
                //--- Default behavior
                else
                {
                    //--- Use plural form - second entry
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;
                }
            }
        }
        //--- Check for number words - just cover through 99...
        else if ( ( TempItem.ulItemSrcLen == 3 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"two", 3 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"six", 3 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"ten", 3 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 4 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"four", 4 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"five", 4 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"nine", 4 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 5 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"three", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"seven", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eight", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"forty", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"fifty", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"sixty", 5 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 6 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"twenty", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"thirty", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eighty", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"ninety", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eleven", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"twelve", 6 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 7 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"seventy", 7 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"fifteen", 7 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"sixteen", 7 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 8 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"thirteen", 8 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"fourteen", 8 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eighteen", 8 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"nineteen", 8 ) == 0 ) ) )
        {
            //--- Use plural form - second entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;    
        }                    
        //--- Default behavior
        else
        {
            //--- Has alternate when non-number precedes - special case
            if ( pAbbrevInfo->pPron3 )
            {
                //--- Use initial form - third entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron3 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS3;
                pPron->POSchoice                    = pAbbrevInfo->POS3;
            }
            else
            {
                //--- Use plural form - second entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
        }
    }
    //--- Default behavior
    else if ( hr == E_INVALIDARG )
    {
        hr = S_OK;

        //--- Has alternate when non-number precedes - special case
        if ( pAbbrevInfo->pPron3 )
        {
            //--- Use initial form - third entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron3 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS3;
            pPron->POSchoice                    = pAbbrevInfo->POS3;
        }
        else
        {
            //--- Use plural form - second entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* SingleOrPluralAbbreviation */

/***********************************************************************************************
* DoctorDriveAbbreviation *
*-------------------------*
*   Description:
*       At this point, we are already sure that the item is an abbreviation, and just need to
*   determine whether it should be Doctor (Saint) or Drive (Street).
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::DoctorDriveAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                               CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::SingleOrPluralAbbreviation" );
    HRESULT hr = S_OK;
    BOOL fMatch = false;
    BOOL fDoctor = false;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get Item which comes after the Abbreviation
    SPLISTPOS TempPos = ListPos;
    if ( !ListPos )
    {
        //--- Go with Drive - end of buffer cannot be followed by a name...
        fDoctor = false;
        fMatch  = true;
    }
    else
    {
        TTSSentItem TempItem = ItemList.GetNext( TempPos );
        if ( TempItem.eItemPartOfSpeech == MS_EOSItem )
        {
            //--- Go with Drive - end of buffer cannot be followed by a name...
            fDoctor = false;
            fMatch  = true;
        }
        else
        {
            ULONG index = 0;

            //--- Try to match a Name (an uppercase letter followed by lowercase letters)
            if ( TempItem.ulItemSrcLen > 0 &&
                 iswupper( TempItem.pItemSrcText[index] ) )
            {
                index++;
                while ( index < TempItem.ulItemSrcLen &&
                        iswlower( TempItem.pItemSrcText[index] ) )
                {
                    index++;
                }
                //--- Check for possessives - RAID 5823
                if ( index == TempItem.ulItemSrcLen - 2    &&
                     TempItem.pItemSrcText[index+1] == L'\'' &&
                     TempItem.pItemSrcText[index+2] == L's' )
                {
                    index += 2;
                }

                //--- Check for directions - North, South, West, East, Ne, Nw, Se, Sw, N, S, E, W
                if ( index == TempItem.ulItemSrcLen &&
                     wcsncmp( TempItem.pItemSrcText, L"North", 5 ) != 0 &&
                     wcsncmp( TempItem.pItemSrcText, L"South", 5 ) != 0 &&
                     wcsncmp( TempItem.pItemSrcText, L"West", 4 )  != 0 &&
                     wcsncmp( TempItem.pItemSrcText, L"East", 4 )  != 0 &&
                     !( TempItem.ulItemSrcLen == 2 &&
                        ( wcsncmp( TempItem.pItemSrcText, L"Ne", 2 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"Nw", 2 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"Se", 2 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"Sw", 2 ) == 0 ) ) &&
                     !( TempItem.ulItemSrcLen == 1 &&
                        ( wcsncmp( TempItem.pItemSrcText, L"N", 1 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"S", 1 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"E", 1 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"W", 1 ) == 0 ) ) )
                {
                    //--- Check for name previous item
                    TempPos = ListPos;

                    ItemList.GetPrev( TempPos );
                    if ( TempPos )
                    {
                        ItemList.GetPrev( TempPos );
                        if ( TempPos )
                        {
                            TTSSentItem PrevItem = ItemList.GetPrev( TempPos );
                            index = 0;

                            if ( PrevItem.ulItemSrcLen > 0 &&
                                 iswupper( PrevItem.pItemSrcText[index++] ) )
                            {
                                while ( index < PrevItem.ulItemSrcLen &&
                                        islower( PrevItem.pItemSrcText[index] ) )
                                {
                                    index++;
                                }
                                if ( index == PrevItem.ulItemSrcLen )
                                {
                                    //--- Go with Drive - names before and after, e.g. Main St. Washington, D.C.
                                    fDoctor = false;
                                    fMatch  = true;
                                }
                            }
                        }
                    }                                    

                    if ( !fMatch )
                    {
                        //--- Go with Doctor - matched a Name after and not a name before
                        fDoctor = true;
                        fMatch  = true;
                    }
                }
                else if ( index == 1                    &&
                          TempItem.ulItemSrcLen == 2    &&
                          TempItem.pItemSrcText[index] == L'.' )
                {
                    //--- Go with Doctor - matched an initial
                    fDoctor = true;
                    fMatch  = true;
                }
            }
        }
    }

    if ( !fMatch ) 
    {
        //--- Try to get previous item...
        BOOL fSentenceInitial = false;
        TempPos = ListPos;
        if ( TempPos )
        {
            ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                ItemList.GetPrev( TempPos );
                if ( !TempPos )
                {
                    fSentenceInitial = true;
                }
                else
                {
                    TTSSentItem PrevItem = ItemList.GetPrev( TempPos );
                    if ( PrevItem.pItemInfo->Type == eOPEN_PARENTHESIS ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACKET     ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACE       ||
                         PrevItem.pItemInfo->Type == eSINGLE_QUOTE     ||
                         PrevItem.pItemInfo->Type == eDOUBLE_QUOTE )
                    {
                        fSentenceInitial = true;
                    }
                }
            }
        }
        //--- Sentence initial - go with Doctor
        if ( fSentenceInitial )
        {
            fDoctor = true;
            fMatch  = true;
        }
        //--- Default - go with Drive
        else
        {
            fDoctor = false;
            fMatch = true;
        }
    }

    if ( fDoctor )
    {
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
        pPron->POSchoice                    = pAbbrevInfo->POS1;
    }
    else
    {  
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->POSchoice                    = pAbbrevInfo->POS2;
    }


    return hr;
} /* DoctorDriveAbbreviation */

/***********************************************************************************************
* AbbreviationFollowedByDigit *
*-----------------------------*
*   Description:
*       At this point, we are already sure that the item is an abbreviation, and just need to
*   determine which pronunciation to go with.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::AbbreviationFollowedByDigit( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                                   CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::AbbreviationFollowedByDigit" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get Item which comes after the Abbreviation
    SPLISTPOS TempPos = ListPos;
    if ( !ListPos )
    {
        //--- Go with pron 2
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->POSchoice                    = pAbbrevInfo->POS2;
    }
    else
    {
        TTSSentItem TempItem = ItemList.GetNext( TempPos );

        if ( TempItem.ulItemSrcLen > 0 &&
             iswdigit( TempItem.pItemSrcText[0] ) )
        {
            //--- Go with pron 1
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        else
        {
            //--- Go with pron 2
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* AbbreviationFollowedByDigit */

/***********************************************************************************************
* AllCapsAbbreviation *
*---------------------*
*   Description:
*       This functions disambiguates abbreviations without periods which are pronounced
*   differently if they are all capital letters.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::AllCapsAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                           CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::AllCapsAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        for ( ULONG i = 0; i < TempItem.ulItemSrcLen; i++ )
        {
            if ( !iswupper( TempItem.pItemSrcText[i] ) )
            {
                break;
            }
        }
        //--- All Caps - go with first pronunciation
        if ( i == TempItem.ulItemSrcLen )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Not All Caps - go with second pronunciation
        else
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* AllCapsAbbreviation */

/***********************************************************************************************
* CapitalizedAbbreviation *
*-------------------------*
*   Description:
*       This functions disambiguates abbreviations without periods which are pronounced
*   differently if they begin with a capital letter.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::CapitalizedAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                               CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::CapitalizedAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        //--- Capitalized - go with first pronunciation
        if ( iswupper( TempItem.pItemSrcText[0] ) )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Not Capitalized - go with second pronunciation
        else
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* CapitalizedAbbreviation */

/***********************************************************************************************
* SECAbbreviation *
*-----------------*
*   Description:
*       This functions disambiguates SEC, Sec, and sec and so forth...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::SECAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                       CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::SECAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        for ( ULONG i = 0; i < TempItem.ulItemSrcLen; i++ )
        {
            if ( !iswupper( TempItem.pItemSrcText[i] ) )
            {
                break;
            }
        }
        //--- All Caps - go with SEC
        if ( i == TempItem.ulItemSrcLen )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron3 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS3;
            pPron->POSchoice                    = pAbbrevInfo->POS3;
        }
        //--- Not All Caps - do SingleOrPlural disambiguation
        else
        {
            SingleOrPluralAbbreviation( pAbbrevInfo, pPron, ItemList, ListPos );
        }
    }

    return hr;
} /* SECAbbreviation */

/***********************************************************************************************
* DegreeAbbreviation *
*--------------------*
*   Description:
*       This functions disambiguates C, F, and K (Celsius, Fahrenheit, Kelvin)
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::DegreeAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                          CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::DegreeAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item and previous item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem, PrevItem;
    BOOL fLetter = false;
    
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            TempItem = ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                PrevItem = ItemList.GetPrev( TempPos );
                if ( PrevItem.pItemInfo->Type != eNUM_DEGREES )
                {
                    fLetter = true;
                }
            }
            else
            {
                fLetter = true;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        if ( fLetter )
        {
            //--- This word is just the letter C, F, or K - second pron
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
        //--- This word is the degree expansion - Celsius, Fahrenheit, or Kelvin
        else
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
    }

    return hr;
} /* DegreeAbbreviation */

/***********************************************************************************************
* IsInitialIsm *
*--------------*
*   Description:
*       Checks the next token in the text stream to determine if it is an initialism.  Also 
*   tries to determine whether or not the period at the end of the initialism is the end of 
*   the sentence.  
*
*   If match made:
*       Advances m_pNextChar to the appropriate position (either the period at the end of the 
*   abbreviation, or just past that period).  Sets the Item in the ItemList at ItemPos to the
*   abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsInitialism( CItemList &ItemList, SPLISTPOS ItemPos, CSentItemMemory &MemoryManager,
                                    BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IsInitialism" );

    HRESULT hr = S_OK;
    BOOL fMatchedEOS = false;

    //--- Initialism must be at least two characters.
    if ( (long)(m_pEndOfCurrItem - m_pNextChar) < 4 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        const WCHAR *pIterator = NULL;
        ULONG ulCount = 0;
    
        pIterator  = m_pNextChar;

        //--- Iterate through the token, each time checking for an alpha character followed by a period.
        while ( SUCCEEDED(hr) &&
                pIterator <= m_pEndOfCurrItem - 2)
        {
            if ( !iswalpha(*pIterator) ||
                 *(pIterator + 1) != L'.' )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                pIterator += 2;
                ulCount++;
            }
        }

        //--- Need to determine whether the initialism's period is also the end of the sentence.
        if ( SUCCEEDED( hr ) &&
             !(*pfIsEOS) )
        {
            //--- Advance to the beginning of the next token
            const WCHAR *pTempNextChar = m_pEndOfCurrToken, *pTempEndChar = m_pEndChar;
            const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
            hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

            if ( SUCCEEDED( hr ) )
            {

                //--- If we have reached the end of the buffer, consider the abbreviation's period as
                //--- the end of the sentence.
                if ( !pTempNextChar )
                {
                    *pfIsEOS = true;
                    fMatchedEOS = true;
                }
                //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
                //--- the next token is a common first word (which must be capitalized).
                else if ( IsCapital( *pTempNextChar ) )
                {
                    WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                    //--- Try to match a first word.
                    WCHAR temp = (WCHAR) *pTempEndOfItem;
                    *pTempEndOfItem = 0;
                
                    if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                                  sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                    {
                        *pfIsEOS = true;
                        fMatchedEOS = true;
                    }

                    *pTempEndOfItem = temp;
                }
            }
        }

        //--- Now insert the Initialism in the ItemList.
        if ( SUCCEEDED(hr) )
        {
            CSentItem Item;
            Item.pItemSrcText       = m_pNextChar;
            Item.ulItemSrcLen       = (long)(m_pEndOfCurrItem - m_pNextChar);
            Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                      (long)( m_pNextChar - m_pCurrFrag->pTextStart );
            Item.ulNumWords         = ulCount;
            Item.Words = (TTSWord*) MemoryManager.GetMemory( ulCount * sizeof(TTSWord), &hr );
            if ( SUCCEEDED( hr ) )
            {
                SPVSTATE* pNewState = (SPVSTATE*) MemoryManager.GetMemory( sizeof( SPVSTATE ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    //--- Ensure letters are pronounced as nouns...
                    memcpy( pNewState, &m_pCurrFrag->State, sizeof( SPVSTATE ) );
                    pNewState->ePartOfSpeech = SPPS_Noun;

                    ZeroMemory( Item.Words, ulCount * sizeof(TTSWord) );
                    for ( ULONG i = 0; i < ulCount; i++ )
                    {
                        Item.Words[i].pXmlState  = pNewState;
                        Item.Words[i].pWordText  = &Item.pItemSrcText[ 2 * i ];
                        Item.Words[i].ulWordLen  = 1;
                        Item.Words[i].pLemma     = Item.Words[i].pWordText;
                        Item.Words[i].ulLemmaLen = Item.Words[i].ulWordLen;
                    }
                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo->Type = eINITIALISM;
                        ItemList.SetAt( ItemPos, Item );
                    }
                }
            }
        }
    }
    return hr;
} /* IsInitialism */

/***********************************************************************************************
* IsAlphaWord *
*-------------*
*   Description:
*       Checks the next token in the text stream to determine if it is an Alpha Word (all alpha
*   characters, except possibly a single apostrophe). 
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsAlphaWord( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo,
                                   CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsAlphaWord" );
    SPDBG_ASSERT( pStartChar < pEndChar );
    HRESULT hr = S_OK;

    bool fApostropheSeen = false;
    WCHAR *pCurrChar = (WCHAR*) pStartChar;

    while ( SUCCEEDED( hr ) &&
            pCurrChar &&
            pCurrChar < pEndChar )
    {
        if ( iswalpha( *pCurrChar ) )
        {
            pCurrChar++;
        }
        else if ( *pCurrChar == L'\''&&
                  !fApostropheSeen )
        {
            fApostropheSeen = true;
            pCurrChar++;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        //--- Matched Alpha Word
        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eALPHA_WORD;
        }
    }

    return hr;
} /* IsAlphaWord */

/***********************************************************************************************
* AbbreviationModifier *
*----------------------*
*   Description:
*       Fixes pronunciation issues for special case where 'sq' or 'cu' modifies
*		a measurement.
*
*************************************************************** MERESHAW **********************/
HRESULT CStdSentEnum::AbbreviationModifier( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                                  CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::AbbreviationModifier" );
    HRESULT hr = S_OK;

    //--- Get Item which comes before the abbreviation modifier
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        //--- Current Item - if All Caps, go with first pronunciation (need to do this before next 
        //---   stage of processing, since CU and FL's all caps prons take precedence over numeric...)
        TempItem = ItemList.GetPrev( TempPos );
        for ( ULONG i = 0; i < TempItem.ulItemSrcLen; i++ )
        {
            if ( !iswupper( TempItem.pItemSrcText[i] ) )
            {
                break;
            }
        }
        if ( i == TempItem.ulItemSrcLen )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
            return hr;
        }             
    }
    else
    {
        hr = E_INVALIDARG;
    }
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        pPron->pronArray[PRON_A].POScount = 1;
        pPron->pronArray[PRON_B].POScount = 0;
        pPron->pronArray[PRON_B].phon_Len = 0;
        pPron->hasAlt                     = false;
        pPron->altChoice                  = PRON_A;
        //--- Abbreviation table pronunciations are basically just vendor lex prons...
        pPron->pronType                   = eLEXTYPE_PRIVATE1;

        //--- If a cardinal, decimal, or ordinal number, use regular form
        if (( TempItem.pItemInfo->Type == eNUM_CARDINAL ) ||
			( TempItem.pItemInfo->Type == eNUM_DECIMAL ) ||
			( TempItem.pItemInfo->Type == eNUM_ORDINAL ) ||
			( TempItem.pItemInfo->Type == eNUM_MIXEDFRACTION ) ||
			( TempItem.pItemInfo->Type == eDATE_YEAR ) ||
			( TempItem.ulItemSrcLen == 3 &&
                  wcsnicmp( TempItem.pItemSrcText, L"one", 3 ) == 0 ))
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }

        //--- Fractions and mixed fractions require some more work...
        else if ( TempItem.pItemInfo->Type == eNUM_FRACTION )
        {
            if (( (TTSNumberItemInfo*) TempItem.pItemInfo )->pFractionalPart->fIsStandard ) 
            {
                //--- Standard fractions (e.g. 11/20) get the plural form
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
            else
            {
                //--- Singular form with [of a] inserted beforehand ([of an] case need not be
				//--- checked because we're only dealing with 'sq' or 'cu'.

				wcscpy( pPron->pronArray[PRON_A].phon_Str, g_pOfA );
				pPron->pronArray[PRON_A].phon_Len = wcslen( g_pOfA );
                
                wcscat( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   += wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
        }
 
        //--- Default behavior
        else
        {
            //--- Use default form ('sq')
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }
    //--- Default behavior - use first pron
    else if ( hr == E_INVALIDARG )
    {
        hr = S_OK;
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
        pPron->POSchoice                    = pAbbrevInfo->POS1;
    }

    return hr;
} /* AbbreviationModifier */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\alloops.h ===
/******************************************************************************
* AlloOps.h *
*-----------*
*  This is the header file for the following clsses:
*		CAlloCell
*		CAlloList
*		CDuration
*		CSyllableTagger
*		CToneTargets
*		CPitchProsody

  *------------------------------------------------------------------------------
  *  Copyright (C) 1999 Microsoft Corporation		  Date: 03/01/99
  *  All Rights Reserved
  *
*********************************************************************** MC ****/

#ifndef AlloOps_H
#define AlloOps_H

#include "stdafx.h"
#include "commonlx.h"

#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef FeedChain_H
#include "FeedChain.h"
#endif

#ifndef SPCollec_h
#include <SPCollec.h>
#endif

#include "SpTtsEngDebug.h"

//***************************
// Allophones
//***************************
typedef enum
{	
    _IY_,	_IH_,	_EH_,	_AE_,	_AA_,	_AH_,	_AO_,	_UH_,	_AX_,	_ER_,
    _EY_,	_AY_,	_OY_,	_AW_,	_OW_,	_UW_, 
    _IX_,	_SIL_,	_w_,	_y_,
    _r_,	_l_,	_h_,	_m_,	_n_,	_NG_,	_f_,	_v_,	_TH_,	_DH_,
    _s_,	_z_,	_SH_,	_ZH_,	_p_,	_b_,	_t_,	_d_,	_k_,	_g_,
    _CH_,	_JH_,	_DX_,	 
	_STRESS1_,
    _STRESS2_,
    _EMPHSTRESS_,
    _SYLLABLE_,
} ALLO_CODE;

static const long NUMBER_OF_ALLO = (_SYLLABLE_ + 1);

//-----------------------------------
// For 2-word allo conversion
//-----------------------------------
static const short NO_IPA = 0;



// XXXX XXXX XXXX XXXX XXXX bLis ssoo ttBB

// X = unused
// B = boundary type
// t = syllable type
// o = vowel order
// s = stress type
// i = word initial consonant
// L = syLlable start
// b = break

enum ALLOTAGS
{	
    WORD_START			= (1 << 0),
        TERM_BOUND			= (1 << 1),
        BOUNDARY_TYPE_FIELD = WORD_START | TERM_BOUND,			// mask
        
        WORD_END_SYLL		= (1 << 2),
        TERM_END_SYLL		= (1 << 3),
        SYLLABLE_TYPE_FIELD = WORD_END_SYLL | TERM_END_SYLL,	// mask
        
        FIRST_SYLLABLE_IN_WORD			= (1 << 4),  // in multi-syllable word
        MID_SYLLABLE_IN_WORD			= (2 << 4),
        LAST_SYLLABLE_IN_WORD			= (3 << 4),
        MORE_THAN_ONE_SYLLABLE_IN_WORD	= LAST_SYLLABLE_IN_WORD,  // either bit is set
        ONE_OR_NO_SYLLABLE_IN_WORD		= 0x0000,  // niether bits are set
        SYLLABLE_ORDER_FIELD			= LAST_SYLLABLE_IN_WORD,  // mask
        
        PRIMARY_STRESS		= (1 << 6),
        SECONDARY_STRESS	= (1 << 7),
        EMPHATIC_STRESS 	= (1 << 8),
        IS_STRESSED 		= PRIMARY_STRESS | SECONDARY_STRESS | EMPHATIC_STRESS,
        PRIM_OR_EMPH_STRESS = PRIMARY_STRESS | EMPHATIC_STRESS,
        STRESS_FIELD		= PRIMARY_STRESS | SECONDARY_STRESS | EMPHATIC_STRESS,	// mask
        
        WORD_INITIAL_CONSONANT	= (1 << 9), 		 // up to 1st vowel in word
        STRESSED_INITIAL_CONS	= (IS_STRESSED + WORD_INITIAL_CONSONANT),
        SYLLABLE_START			= (1 << 10),
        
        SIL_BREAK			= (1 << 11),
};


//***************************
// AlloFlags
//***************************
enum ALLOFLAGS
{	
    KVOWELF = (1<<0),
        KCONSONANTF = (1<<1),
        KVOICEDF = (1<<2),
        KVOWEL1F = (1<<3),
        KSONORANTF = (1<<4),
        KSONORANT1F = (1<<5),
        KNASALF = (1<<6),
        KLIQGLIDEF = (1<<7),
        KSONORCONSONF = (1<<8),
        KPLOSIVEF = (1<<9),
        KPLOSFRICF = (1<<10),
        KOBSTF = (1<<11),
        KSTOPF = (1<<12),
        KALVEOLARF = (1<<13),
        KVELAR = (1<<14),
        KLABIALF = (1<<15),
        KDENTALF = (1<<16),
        KPALATALF = (1<<17),
        KYGLIDESTARTF = (1<<18),
        KYGLIDEENDF = (1<<19),
        KGSTOPF = (1<<20),
        KFRONTF = (1<<21),
        KDIPHTHONGF = (1<<22),
        KHASRELEASEF = (1<<23),
        KAFFRICATEF = (1<<24),
        KLIQGLIDE2F = (1<<25),
        KVOCLIQ = (1<<26),
        KFRIC = (1<<27),
        
        KFLAGMASK1 = (KLABIALF+KDENTALF+KPALATALF+KALVEOLARF+KVELAR+KGSTOPF),
        KFLAGMASK2 = (KALVEOLARF-1),
};


#define BOUNDARY_BASE   1000
enum TOBI_BOUNDARY
{
    K_NOBND = 0,
    K_LMINUS = BOUNDARY_BASE,   // fall
    K_HMINUS,                   // none
    K_LMINUSLPERC,
    K_LMINUSHPERC,
    K_HMINUSHPERC,
    K_HMINUSLPERC,
};




enum TUNE_TYPE
{
    NULL_BOUNDARY = 0,  // no boundary NOTE: always put this at the beginning
    PHRASE_BOUNDARY,    // comma
    EXCLAM_BOUNDARY,    // exclamatory utterance terminator
    YN_QUEST_BOUNDARY,     // yes-no question terminator
    WH_QUEST_BOUNDARY,     // yes-no question terminator
    DECLAR_BOUNDARY,    // declarative terminator
    PAREN_L_BOUNDARY,   // left paren
    PAREN_R_BOUNDARY,   // right paren
    QUOTE_L_BOUNDARY,   // left quote
    QUOTE_R_BOUNDARY,   // right quote
	PHONE_BOUNDARY,
	TOD_BOUNDARY,
	ELLIPSIS_BOUNDARY,

    SUB_BOUNDARY_1,     // NOTE: always put these at the end
    SUB_BOUNDARY_2,
    SUB_BOUNDARY_3,
    SUB_BOUNDARY_4,
    SUB_BOUNDARY_5,
    SUB_BOUNDARY_6,
	NUMBER_BOUNDARY,

	TAIL_BOUNDARY,
};


//***************************
// ToBI Constants
//***************************
// !H is removed from consideration in the first pass processing
// !H can possibly be recovered from analysis of the labeling and
// contour at later stages (tilt, prominence, pitch range, downstep)
#define ACCENT_BASE   1
enum TOBI_ACCENT
{
    K_NOACC = 0,
    K_HSTAR = ACCENT_BASE,  // peak                         rise / fall
    K_LSTAR,                // acc syll nucleus valley      early fall
    K_LSTARH,               // late rise
    K_RSTAR,                //
    K_LHSTAR,               // early rise
    K_DHSTAR,               // 
	K_HSTARLSTAR,
};



enum BOUNDARY_SOURCE
{
    BND_NoSource = 0,

	//-- Phrase boundary rules
	BND_PhraseRule1,
	BND_PhraseRule2,
	BND_PhraseRule3,
	BND_PhraseRule4,
	BND_PhraseRule5,
	BND_PhraseRule6,
	BND_PhraseRule7,
	BND_PhraseRule8,
	BND_PhraseRule9,
	BND_PhraseRule10,
	BND_PhraseRule11,
	BND_PhraseRule12,
	BND_PhraseRule13,

	//-- ToBI
	BND_YNQuest,
	BND_WHQuest,
	BND_Period,
	BND_Comma,

	//--Templates
	BND_NumberTemplate,		// Should never get this!
	BND_IntegerQuant,
	BND_Currency_DOLLAR,
	BND_Frac_Num,

	BND_Phone_COUNTRY,
	BND_Phone_AREA,
	BND_Phone_ONE,
	BND_Phone_DIGITS,

	BND_TimeOFDay_HR,
	BND_TimeOFDay_AB,
	BND_Ellipsis,

	BND_ForcedTerm,			// Should never get this!

    BND_IDontKnow,
};

enum ACCENT_SOURCE
{
    ACC_NoSource = 0,

	//-- Phrase boundary rules
	ACC_PhraseRule1,
	ACC_PhraseRule2,
	ACC_PhraseRule3,
	ACC_PhraseRule4,
	ACC_PhraseRule5,
	ACC_PhraseRule6,
	ACC_PhraseRule7,
	ACC_PhraseRule8,
	ACC_PhraseRule9,
	ACC_PhraseRule10,
	ACC_PhraseRule11,
	ACC_PhraseRule12,
	ACC_PhraseRule13,

	//-- ToBI
	ACC_InitialVAux,
	ACC_FunctionSeq,
	ACC_ContentSeq,
	ACC_YNQuest,
	ACC_Period,
	ACC_Comma,

	//--Templates
	ACC_IntegerGroup,
	ACC_NumByNum,
	ACC_Frac_DEN,		// "half", "tenths", etc.
	ACC_Phone_1stArea,	// 1st digit in area code
	ACC_Phone_3rdArea,	// 3rd digit in area code
	ACC_Phone_1st3,		
	ACC_Phone_3rd3,		
	ACC_Phone_1st4,
	ACC_Phone_3rd4,
	ACC_TimeOFDay_HR,
	ACC_TimeOFDay_1stMin,
	ACC_TimeOFDay_M,

	ACC_PhoneBnd_AREA,
	ACC_PhoneBnd_34,
	ACC_PhoneBnd_4,

	ACC_IDontKnow,
};



enum SILENCE_SOURCE
{
    SIL_NoSource = 0,

	SIL_Term,
	SIL_QuoteStart,
	SIL_QuoteEnd,
	SIL_ParenStart,
	SIL_ParenEnd,
	SIL_Emph,
	SIL_SubBound,		// Should never see this (gets removed)
	SIL_XML,

	//-- Prosody templates
	SIL_TimeOfDay_HR,
	SIL_TimeOfDay_AB,

	SIL_Phone_COUNTRY,
	SIL_Phone_AREA,
	SIL_Phone_ONE,
	SIL_Phone_DIGITS,

	SIL_Fractions_NUM,
	SIL_Currency_DOLLAR,
	SIL_Integer_Quant,

	SIL_Head,
	SIL_Tail,
	SIL_Ellipsis,

	SIL_ForcedTerm,			// Should never get this!
};




static const short TOKEN_LEN_MAX	= 20;

class CFEToken
{
public:
    CFEToken();
    ~CFEToken();
    
    WCHAR           tokStr[TOKEN_LEN_MAX];
    long            tokLen;
    PRONSRC 		m_PronType;

    long            phon_Len;
    ALLO_CODE       phon_Str[SP_MAX_PRON_LENGTH];		// Allo string
    ENGPARTOFSPEECH	POScode;
    PROSODY_POS     m_posClass;

    ULONG           srcPosition;					// Source position for this token
    ULONG           srcLen; 						// Source length for this token
    ULONG           sentencePosition;				// Source position for sentence
    ULONG           sentenceLen; 					// Source length for sentence
    ULONG           user_Volume;					// 1 - 101
    long            user_Rate;						// -10 - 10
    long            user_Pitch; 					// -10 - 10
    long            user_Emph;						// 0 or 5
    ULONG           user_Break; 					// ms of silence
    CBookmarkList   *pBMObj;
    TOBI_ACCENT     m_Accent;                        // accent prosodic control
    long            m_Accent_Prom;                   // prominence prosodic control
    TOBI_BOUNDARY   m_Boundary;                        // boundary tone prosodic control
    long            m_Boundary_Prom;                   // prominence prosodic control
    TUNE_TYPE       m_TuneBoundaryType;             // Current token is a boundary
	float			m_TermSil;						// Pad word with silence (in sec)
    float           m_DurScale;						// Duration ratio
	float			m_ProsodyDurScale;
	float			m_PitchBaseOffs;				// Relative baseline pitch offset in octaves
	float			m_PitchRangeScale;				// Pitch range offset scale (0 - 2.0) 

	//--- Diagnostic
	ACCENT_SOURCE		m_AccentSource;		
	BOUNDARY_SOURCE		m_BoundarySource;
	SILENCE_SOURCE		m_SilenceSource;
};
typedef CSPList<CFEToken*,CFEToken*> CFETokenList;



class CAlloCell
{
public:
    CAlloCell();
    ~CAlloCell();
    //--------------------------------
    // Member Vars
    //--------------------------------
    ALLO_CODE	m_allo;
    short		m_dur;
    float		m_ftDuration;
    float       m_UnitDur;
    short		m_knots;
    float		m_ftTime[KNOTS_PER_PHON];
    float		m_ftPitch[KNOTS_PER_PHON];
    long		m_ctrlFlags;
    TOBI_ACCENT m_ToBI_Accent;
    long        m_Accent_Prom;                   // prominence prosodic control
    TOBI_BOUNDARY   m_ToBI_Boundary;
    long        m_Boundary_Prom;                 // prominence prosodic control
    long        m_PitchBufStart;
    long        m_PitchBufEnd;
    ULONG		m_user_Volume;
    long		m_user_Rate;
    long		m_user_Pitch;
    long		m_user_Emph;
    ULONG		m_user_Break;
    ULONG       m_Sil_Break;
    float		m_Pitch_HI;
    float		m_Pitch_LO;
    ULONG		m_SrcPosition;
    ULONG		m_SrcLen;
    ULONG       m_SentencePosition;				// Source position for sentence
    ULONG       m_SentenceLen; 					// Source length for sentence
    TUNE_TYPE   m_TuneBoundaryType;
    TUNE_TYPE   m_NextTuneBoundaryType;
    CBookmarkList	*m_pBMObj;
    float       m_DurScale;						// Duration ratio
	float		m_ProsodyDurScale;
	float		m_PitchBaseOffs;				// Relative baseline pitch offset in octaves
	float		m_PitchRangeScale;				// Pitch range offset scale (0 - 2.0) 

	//--- Diagnostic
	ACCENT_SOURCE		m_AccentSource;		
	BOUNDARY_SOURCE		m_BoundarySource;
	SILENCE_SOURCE		m_SilenceSource;
	char				*m_pTextStr;
};





class CAlloList
{
public:
    CAlloList();
    ~CAlloList();
    //--------------------------------
    // Methods
    //--------------------------------
    CAlloCell *GetCell( long index );
    CAlloCell *GetTailCell();
    long GetCount();
    bool WordToAllo( CFEToken *pPrevTok, CFEToken *pTok, CFEToken *pNextTok, CAlloCell *pEndCell );
	CAlloCell *GetHeadCell()
	{
		m_ListPos = m_AlloCellList.GetHeadPosition();
		return m_AlloCellList.GetNext( m_ListPos );
	}
	CAlloCell *GetNextCell()
	{
		if( m_ListPos )
		{
			return m_AlloCellList.GetNext( m_ListPos );
		}
		else
		{
			//-- We're at end of list!
			return NULL;
		}
	}
	//-- For debug only
    void OutAllos();

private:
    //--------------------------------
    // Member Vars
    //--------------------------------
    long		m_cAllos;
	SPLISTPOS	m_ListPos;
    CSPList<CAlloCell*,CAlloCell*> m_AlloCellList;
};



//-----------------------------------
// Speaking Rate parameters
//-----------------------------------
static const float MAX_SIL_DUR = 1.0f; 			// seconds
static const float MIN_ALLO_DUR = 0.011f;		// seconds
static const float MAX_ALLO_DUR = 5.0f;		// seconds


class CDuration
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    void AlloDuration( CAlloList *pAllos, float rateRatio );
    
private:
    void Pause_Insertion( long userDuration, long silBreak );
    void PhraseFinal_Lengthen( long cellCount );
    long Emphatic_Lenghen( long lastStress );
    //--------------------------------
    // Member vars
    //--------------------------------
    float   m_DurHold;
	float	m_TotalDurScale;
	float	m_durationPad;
    
    ALLO_CODE	m_cur_Phon;
    long		m_cur_PhonCtrl;
    long		m_cur_PhonFlags;
    long		m_cur_SyllableType;
    short		m_cur_VowelFlag;
    long		m_cur_Stress;
    ALLO_CODE	m_prev_Phon;
    long		m_prev_PhonCtrl;
    long		m_prev_PhonFlags;
    ALLO_CODE	m_next_Phon;
    long		m_next_PhonCtrl;
    long		m_next_PhonFlags;
    ALLO_CODE	m_next2_Phon;
    long		m_next2_PhonCtrl;
    long		m_next2_PhonFlags;
    TUNE_TYPE   m_NextBoundary, m_CurBoundary;
};






typedef struct
{ 
    ALLO_CODE	allo;
    long		ctrlFlags;
}ALLO_ARRAY;




class CSyllableTagger
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    void TagSyllables( CAlloList *pAllos );
    
private:
    void MarkSyllableOrder( long scanIndex);
    void MarkSyllableBoundry( long scanIndex);
    void MarkSyllableStart();
    short Find_Next_Word_Bound( short index );
    short If_Consonant_Cluster( ALLO_CODE Consonant_1st, ALLO_CODE Consonant_2nd);
	void ListToArray( CAlloList *pAllos );
	void ArrayToList( CAlloList *pAllos );
    
    //--------------------------------
    // Member vars
    //--------------------------------
    ALLO_ARRAY	*m_pAllos;
    long		m_numOfCells;
};


enum { TARG_PER_ALLO_MAX = 2 }; // One for accent and one for boundary



enum TUNE_STYLE
{
    FLAT_TUNE = 0,      // flat
    DESCEND_TUNE,       // go down
    ASCEND_TUNE,        // go up
};

//------------------
// Global Constants
//------------------
static const float PITCH_BUF_RES = (float)0.010;
static const float K_HSTAR_OFFSET = (float)0.5;
static const float K_HDOWNSTEP_COEFF  = (float)0.5;


//------------------
// Macros
//------------------
#define CeilVal(x) ((m_CeilSlope * x) + m_CeilStart)
#define FloorVal(x) ((m_FloorSlope * x) + m_FloorStart)
#define RefVal(x) ((m_RefSlope * x) + m_RefStart)



class CPitchProsody
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    void AlloPitch( CAlloList *pAllos, float baseLine, float pitchRange );
    
private:
    float DoPitchControl( long pitchControl, float basePitch );
    void PitchTrack();
    void SetDefaultPitch();
    void GetKnots();
    void NewTarget( long index, float value );

    //--------------------------------
    // Member vars
    //--------------------------------
    CAlloList		*m_pAllos;
    long			m_numOfCells;

    float           m_TotalDur;     // phrase duration in seconds
    TUNE_STYLE      m_Tune_Style;
    float           *m_pContBuf;
    float           m_OffsTime;
    TOBI_ACCENT     m_CurAccent;

	//------------------------
	// Diagnostic
	//------------------------
	ACCENT_SOURCE		m_CurAccentSource;		
	BOUNDARY_SOURCE		m_CurBoundarySource;
	char				*m_pCurTextStr;
};



#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\backend.cpp ===
/*******************************************************************************
* Backend.cpp *
*-------------*
*   Description:
*       This module is the implementation file for the CBackend class.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

#include "stdafx.h"
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef Backend_H
#include "Backend.h"
#endif
#ifndef FeedChain_H
#include "FeedChain.h"
#endif
#ifndef SPDebug_h
#include <spdebug.h>
#endif


//-----------------------------
// Data.cpp
//-----------------------------
extern const short   g_IPAToAllo[];
extern const short   g_AlloToViseme[];


//--------------------------------------
// DEBUG: Save utterance WAV file
//--------------------------------------
//#define   SAVE_WAVE_FILE  1




const unsigned char g_SineWaveTbl[] =
{
    0x7b,0x7e,0x81,0x84,0x87,0x89,0x8c,0x8f,0x92,0x95,0x98,0x9b,0x9d,0xa0,0xa3,0xa6,
    0xa8,0xab,0xae,0xb0,0xb3,0xb5,0xb8,0xbb,0xbd,0xbf,0xc2,0xc4,0xc7,0xc9,0xcb,0xcd,
    0xcf,0xd1,0xd3,0xd5,0xd7,0xd9,0xdb,0xdd,0xdf,0xe0,0xe2,0xe3,0xe5,0xe6,0xe8,0xe9,
    0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf2,0xf3,0xf3,0xf4,0xf4,0xf4,0xf4,
    0xf5,0xf5,0xf5,0xf5,0xf4,0xf4,0xf4,0xf4,0xf3,0xf3,0xf2,0xf1,0xf1,0xf0,0xef,0xee,
    0xed,0xec,0xeb,0xea,0xe9,0xe7,0xe6,0xe5,0xe3,0xe1,0xe0,0xde,0xdc,0xdb,0xd9,0xd7,
    0xd5,0xd3,0xd1,0xcf,0xcd,0xcb,0xc8,0xc6,0xc4,0xc1,0xbf,0xbc,0xba,0xb7,0xb5,0xb2,
    0xb0,0xad,0xaa,0xa8,0xa5,0xa2,0x9f,0x9d,0x9a,0x97,0x94,0x91,0x8f,0x8c,0x89,0x86,
    0x83,0x80,0x7d,0x7a,0x77,0x75,0x72,0x6f,0x6c,0x69,0x66,0x64,0x61,0x5e,0x5b,0x58,
    0x56,0x53,0x50,0x4e,0x4b,0x49,0x46,0x44,0x41,0x3f,0x3c,0x3a,0x38,0x35,0x33,0x31,
    0x2f,0x2d,0x2b,0x29,0x27,0x25,0x23,0x21,0x1f,0x1e,0x1c,0x1b,0x19,0x18,0x16,0x15,
    0x14,0x13,0x12,0x11,0x10,0x0f,0x0e,0x0d,0x0c,0x0c,0x0b,0x0b,0x0a,0x0a,0x0a,0x0a,
    0x09,0x09,0x09,0x09,0x0a,0x0a,0x0a,0x0a,0x0b,0x0b,0x0c,0x0d,0x0d,0x0e,0x0f,0x10,
    0x11,0x12,0x13,0x14,0x15,0x17,0x18,0x1a,0x1b,0x1d,0x1e,0x20,0x22,0x23,0x25,0x27,
    0x29,0x2b,0x2d,0x2f,0x31,0x34,0x36,0x38,0x3a,0x3d,0x3f,0x42,0x44,0x47,0x49,0x4c,
    0x4e,0x51,0x54,0x56,0x59,0x5c,0x5f,0x61,0x64,0x67,0x6a,0x6d,0x6f,0x72,0x75,0x78
};







/*void  PredictEpochDist(   float   duration,
long    nKnots,
float   SampleRate,
float   *pTime, 
float   *pF0)
{
long            curSamplesOut, endSample, j;
float           epochFreq;
long            epochLen, epochCount;

  
    curSamplesOut   = 0;
    endSample       = (long) (SampleRate * duration );
    epochCount      = 0;
    
      while( curSamplesOut < endSample )
      {
      j = 1;
      //---------------------------------------------------
      // Align to appropriate knot bassed on
      // current output sample
      //---------------------------------------------------
      while( (j < nKnots - 1) && (curSamplesOut > pTime[j]) ) 
      j++;
      //---------------------------------------------------
      // Calculate exact pitch thru linear interpolation
      //---------------------------------------------------
      epochFreq = LinInterp( pTime[j - 1], curSamplesOut, pTime[j], pF0[j - 1], pF0[j] );
      //---------------------------------------------------
      // Calc sample count for curent epoch
      //---------------------------------------------------
      epochLen  = (long) (SampleRate / epochFreq);
      epochCount++;
      
        curSamplesOut += epochLen;
        }
        
          
            }
*/











/*****************************************************************************
* CBackend::CBackend *
*--------------------*
*   Description: Constructor
*   
********************************************************************** MC ***/
CBackend::CBackend( )
{
    SPDBG_FUNC( "CBackend::CBackend" );
    m_pHistory      = NULL;
    m_pHistory2     = NULL;
    m_pFilter       = NULL;
    m_pReverb       = NULL;
    m_pOutEpoch     = NULL;
    m_pMap          = NULL;
    m_pRevFlag      = NULL;
    m_pSpeechBuf    = NULL;
    m_VibratoDepth  = 0;
    m_UnitVolume    = 1.0f;
    m_MasterVolume  = SPMAX_VOLUME;
    memset( &m_Synth, 0, sizeof(MSUNITDATA) );
} /* CBackend::CBackend */


/*****************************************************************************
* CBackend::~CBackend *
*---------------------*
*   Description:  Destructor
*       
********************************************************************** MC ***/
CBackend::~CBackend( )
{
    SPDBG_FUNC( "CBackend::~CBackend" );

    Release();
} /* CBackend::~CBackend */




/*****************************************************************************
* CBackend::Release *
*---------------------*
*   Description:
*   Free memory allocaterd by Backend
*       
********************************************************************** MC ***/
void CBackend::Release( )
{
    SPDBG_FUNC( "CBackend::Release" );
    CleanUpSynth( );

    if( m_pSpeechBuf)
    {
        delete m_pSpeechBuf;
        m_pSpeechBuf = NULL;
    }
    if( m_pHistory )
    {
        delete m_pHistory;
        m_pHistory = NULL;
    }
    if( m_pHistory2 )
    {
        delete m_pHistory2;
        m_pHistory2 = NULL;
    }
    if( m_pReverb )
    {
        delete m_pReverb;
        m_pReverb = NULL;
    }
} /* CBackend::Release */



/*****************************************************************************
* CBackend::Init *
*----------------*
*   Description:
*   Opens a backend instance, keeping a pointer of the acoustic
*   inventory.
*       
********************************************************************** MC ***/
HRESULT CBackend::Init( IMSVoiceData* pVoiceDataObj, CFeedChain *pSrcObj, MSVOICEINFO* pVoiceInfo )
{
    SPDBG_FUNC( "CBackend::Init" );
    long    LPCsize = 0;
    HRESULT hr = S_OK;
    
    m_pVoiceDataObj = pVoiceDataObj;
    m_SampleRate = (float)pVoiceInfo->SampleRate;
    m_pSrcObj   = pSrcObj;
    m_cOrder = pVoiceInfo->LPCOrder;
    m_pWindow = pVoiceInfo->pWindow;
    m_FFTSize = pVoiceInfo->FFTSize;
    m_VibratoDepth = ((float)pVoiceInfo->VibratoDepth) / 100.0f;
    m_VibratoDepth = 0;				// NOTE: disable vibrato
    m_VibratoFreq = pVoiceInfo->VibratoFreq;
    if( pVoiceInfo->eReverbType > REVERB_TYPE_OFF )
    {
        m_StereoOut = true;
        m_BytesPerSample = 4;
    }
    else
    {
        m_StereoOut = false;
        m_BytesPerSample = 2;
    }
    //---------------------------------------
    // Allocate AUDIO buffer
    //---------------------------------------
    m_pSpeechBuf = new float[SPEECH_FRAME_SIZE + SPEECH_FRAME_OVER];
    if( m_pSpeechBuf == NULL )
    {
        //--------------------------------------
        // Out of memory!
        //--------------------------------------
        hr = E_OUTOFMEMORY;
    }
    if( SUCCEEDED(hr) )
    {
        //---------------------------------------
        // Allocate HISTORY buffer
        //---------------------------------------

        LPCsize = m_cOrder + 1;
        m_pHistory = new float[LPCsize];
        if( m_pHistory == NULL )
        {
            //--------------------------------------
            // Out of memory!
            //--------------------------------------
            hr = E_OUTOFMEMORY;
        }
    }
    if( SUCCEEDED(hr) )
    {
        memset( m_pHistory, 0, LPCsize * sizeof(float) );
        m_pOutEpoch         = NULL;
        m_pMap              = NULL;
        m_pRevFlag          = NULL;
        m_fModifiers        = 0;
        m_vibrato_Phase1    = 0;


        //--------------------------------
        // Reverb Effect
        //--------------------------------
        //pVoiceInfo->eReverbType = REVERB_TYPE_HALL;
        if( pVoiceInfo->eReverbType > REVERB_TYPE_OFF )
        {
            //--------------------------------
            // Create ReverbFX object
            //--------------------------------
            if( m_pReverb == NULL )
            {
                m_pReverb = new CReverbFX;
                if( m_pReverb )
                {
                    short       result;
                    result = m_pReverb->Reverb_Init( pVoiceInfo->eReverbType, (long)m_SampleRate, m_StereoOut );
                    if( result != KREVERB_NOERROR )
                    {
                        //--------------------------------------------
                        // Not enough memory to do reverb
                        // Recover gracefully
                        //--------------------------------------------
                        delete m_pReverb;
                        m_pReverb = NULL;
                    }
                    /*else
                    {
                    //--------------------------------------------------------
                    // Init was successful, ready to do reverb now
                    //--------------------------------------------------------
                    }*/
                }
            }
        }

        //----------------------------
        // Linear taper region scale
        //----------------------------
        m_linearScale = (float) pow( 10.0, (double)((1.0f - LINEAR_BKPT) * LOG_RANGE) / 20.0 );


    #ifdef SAVE_WAVE_FILE
        m_SaveFile = (PCSaveWAV) new CSaveWAV;     // No check needed, if this fails, we simply don't save file.
        if( m_SaveFile )
        {
            m_SaveFile->OpenWavFile( (long)m_SampleRate );
        }
    #endif

    }
    else
    {
        if( m_pSpeechBuf )
        {
            delete m_pSpeechBuf;
            m_pSpeechBuf = NULL;
        }
        if( m_pHistory )
        {
            delete m_pHistory;
            m_pHistory = NULL;
        }
    }

    return hr;    
} /* CBackend::Init */


/*****************************************************************************
* CBackend::FreeSynth *
*---------------------*
*   Description:
*   Return TRUE if consoants can be clustered.
*       
********************************************************************** MC ***/
void CBackend::FreeSynth( MSUNITDATA* pSynth )
{
    SPDBG_FUNC( "CBackend::FreeSynth" );
    if( pSynth->pEpoch )
    {
        delete pSynth->pEpoch;
        pSynth->pEpoch = NULL;
    }
    if( pSynth->pRes )
    {
        delete pSynth->pRes;
        pSynth->pRes = NULL;
    }
    if( pSynth->pLPC )
    {
        delete pSynth->pLPC;
        pSynth->pLPC = NULL;
    }
} /* CBackend::FreeSynth */


/*****************************************************************************
* ExpConverter *
*--------------*
*   Description:
*   Convert linear to exponential taper
*   'ref' is a linear value between 0.0 to 1.0
*       
********************************************************************** MC ***/
static float   ExpConverter( float ref, float linearScale )
{
    SPDBG_FUNC( "ExpConverter" );
    float   audioGain;

    if( ref < LINEAR_BKPT)
    {
        //----------------------------------------
        // Linear taper below LINEAR_BKPT
        //----------------------------------------
        audioGain = linearScale * (ref / LINEAR_BKPT);
    }
    else
    {
        //----------------------------------------
        // Log taper above LINEAR_BKPT
        //----------------------------------------
        audioGain = (float) pow( 10.0, (double)((1.0f - ref) * LOG_RANGE) / 20.0 );
    }

    return audioGain;
} /* ExpConverter */



/*****************************************************************************
* CBackend::CvtToShort *
*----------------------*
*   Description:
*   Convert (in place) FLOAT audio to SHORT.
*       
********************************************************************** MC ***/
void CBackend::CvtToShort( float *pSrc, long blocksize, long stereoOut, float audioGain )
{
    SPDBG_FUNC( "CBackend::CvtToShort" );
    long        i;
    short       *pDest;
    float       fSamp;
    
    pDest = (short*)pSrc;
    for( i = 0; i < blocksize; ++i )
    {
        //------------------------
        // Read float sample...
        //------------------------
        fSamp = (*pSrc++) * audioGain;
        //------------------------
        // ...clip to 16-bits...
        //------------------------
        if( fSamp > 32767 )
        {
            fSamp = 32767;
        }
        else if( fSamp < (-32768) )
        {
            fSamp = (-32768);
        }
        //------------------------
        // ...save as SHORT
        //------------------------
        *pDest++ = (short)fSamp;
        if( stereoOut )
        {
            *pDest++ = (short)(0 - (int)fSamp);
        }
    }
} /* CBackend::CvtToShort */



/*****************************************************************************
* CBackend::PSOLA_Stretch *
*-------------------------*
*   Description:
*   Does PSOLA epoch stretching or compressing
*       
********************************************************************** MC ***/
void CBackend::PSOLA_Stretch(     float *pInRes, long InSize, 
                    float *pOutRes, long OutSize,
                    float *pWindow, 
                    long  cWindowSize )
{
    SPDBG_FUNC( "CBackend::PSOLA_Stretch" );
    long    i, lim;
    float   window, delta, kf;
    
    memset( pOutRes, 0, sizeof(float) * OutSize  );
    lim = MIN(InSize, OutSize );
    delta = (float)cWindowSize / (float)lim;
    kf = 0.5f;
    pOutRes[0] = pInRes[0];
    for( i = 1; i < lim; ++i )
    {
        kf += delta;
        window = pWindow[(long) kf];
        pOutRes[i] += pInRes[i] * window;
        pOutRes[OutSize - i] += pInRes[InSize - i] * window;
    }
} /* CBackend::PSOLA_Stretch */





/*****************************************************************************
* CBackend::PrepareSpeech *
*-------------------------*
*   Description:
*       
********************************************************************** MC ***/
void    CBackend::PrepareSpeech( ISpTTSEngineSite* outputSite )
{
    SPDBG_FUNC( "CBackend::PrepareSpeech" );
    
    //m_pUnits      = pUnits;
    //m_unitCount       = unitCount;
    //m_CurUnitIndex    = 0;
    m_pOutputSite = outputSite;
    m_silMode = true;
    m_durationTarget = 0;
    m_cOutSamples_Phon = 1;
    m_cOutEpochs = 0;            // Pull model big-bang
    m_SpeechState = SPEECH_CONTINUE;
    m_cOutSamples_Total = 0;
	m_HasSpeech = false;
} /* CBackend::PrepareSpeech */


/*****************************************************************************
* CBackend::ProsodyMod *
*----------------------*
*   Description:
*   Calculate the epoch sequence for the synthesized speech
* 
*   INPUT:
* 
*   OUTPUT:
*       FIlls 'pOutEpoch', 'pMap', and 'pRevFlag'
*       Returns new epoch count
*       
********************************************************************** MC ***/
long CBackend::ProsodyMod(     UNITINFO    *pCurUnit, 
                               long         cInEpochs, 
                               float        durationMpy )
{   
    SPDBG_FUNC( "CBackend::ProsodyMod" );
    long    iframe, framesize, framesizeOut, j;
    long    cntOut, csamplesOut, cOutEpochs;
    BOOL    fUnvoiced;
    short   fReverse;
    float   totalDuration;
    float   durationIn;         // Active accum of IN duration
    float   durationOut;        // Active accum of OUT duration aligned to IN domain
    float   freqMpy;
    BOOL    fAdvanceInput;
    float           vibrato;
    unsigned char   *SineWavePtr;
    float           epochFreq;
    float           *pTime;
    float           *pF0;
    
    iframe          = 0;
    durationIn      = 0.0f;
    durationOut     = 0.0f;
    csamplesOut     = 0;
    cntOut          = 0;
    cOutEpochs      = 0;
    fReverse        = false;
    pTime           = pCurUnit->pTime;
    pF0             = pCurUnit->pF0;
    
    //------------------------------------
    // Find total input duration
    //------------------------------------
    totalDuration   = 0;
    for( j = 0; j < cInEpochs; ++j )
    {
        totalDuration += ABS(m_pInEpoch[j]);
    }
    
    /*PredictEpochDist(     pCurUnit->duration,
    pCurUnit->nKnots,
    m_SampleRate,
    pTime, 
    pF0 );*/
    
    while( iframe < cInEpochs )
    {
        //-----------------------------------------
        //  Compute output frame length
        //-----------------------------------------
        if( m_pInEpoch[iframe] < 0 )
        {
            //-------------------------------------------------
            // Since we can't change unvoiced pitch,
            // do not change frame size for unvoiced frames
            //-------------------------------------------------
            framesize       = (long)((-m_pInEpoch[iframe]) + 0.5f);
            framesizeOut    = framesize;
            fUnvoiced       = true;
        }
        else
        {
            //---------------------------------------------------
            // Modify frame size for voiced epoch
            // based on epoch frequency
            //---------------------------------------------------
            j = 1;
            //---------------------------------------------------
            // Align to appropriate knot bassed on
            // current output sample
            //---------------------------------------------------
            while( (j < (long)pCurUnit->nKnots - 1) && (csamplesOut > pTime[j]) ) 
                j++;
            //---------------------------------------------------
            // Calculate exact pitch thru linear interpolation
            //---------------------------------------------------
            
            epochFreq = LinInterp( pTime[j - 1], (float)csamplesOut, pTime[j], pF0[j - 1], pF0[j] );
            
            
            SineWavePtr = (unsigned char*)&g_SineWaveTbl[0];
            vibrato = (float)(((unsigned char)(*(SineWavePtr + (m_vibrato_Phase1 >> 16)))) - 128);
            vibrato *= m_VibratoDepth;
            
            //---------------------------------------------------
            // Scale frame size using in/out ratio
            //---------------------------------------------------
            epochFreq       = epochFreq + vibrato;
            if( epochFreq < MIN_VOICE_PITCH )
            {
                epochFreq = MIN_VOICE_PITCH;
            }
            framesize       = (long)(m_pInEpoch[iframe] + 0.5f);
            framesizeOut    = (long)(m_SampleRate / epochFreq);
            
            
            vibrato         = ((float)256 / ((float)22050 / m_VibratoFreq)) * (float)framesizeOut;    // 3 Hz
            //vibrato           = ((float)256 / (float)7350) * (float)framesizeOut; // 3 Hz
            m_vibrato_Phase1 += (long)(vibrato * (float)65536);
            m_vibrato_Phase1 &= 0xFFFFFF;
            //---------------------------------------------------
            // @@@@ REMOVED 2x LIMIT
            //---------------------------------------------------
            /*if( framesizeOut > 2*framesize )
            {
            framesizeOut = 2*framesize;
            }
            if( framesize > 2*framesizeOut )
            {
            framesizeOut = framesize/2;
        }*/
            freqMpy = (float) framesize / framesizeOut;
            fUnvoiced = false;
        }
        
        
        //-------------------------------------------
        //  Generate next output frame
        //-------------------------------------------
        fAdvanceInput = false;
        if( durationOut + (0.5f * framesizeOut/durationMpy) <= durationIn + framesize )
        {
            //-----------------------------------------
            // If UNvoiced and odd frame,
            // reverse residual
            //-----------------------------------------
            if( fUnvoiced && (cntOut & 1) )
            {
                m_pRevFlag[cOutEpochs] = true;
                fReverse = true;
            }
            else
            {
                m_pRevFlag[cOutEpochs] = false;
                fReverse = false;
            }
            ++cntOut;
            
            durationOut += framesizeOut/durationMpy;
            csamplesOut += framesizeOut;
            m_pOutEpoch[cOutEpochs] = (float)framesizeOut;
            m_pMap[cOutEpochs] = iframe;
            cOutEpochs++;
        }
        else 
        {
            fAdvanceInput = true;
        }
        
        //-------------------------------------------
        // Advance to next input frame
        //-------------------------------------------
        if(     ((durationOut + (0.5f * framesizeOut/durationMpy)) > (durationIn + framesize)) || 
            //(cntOut >= 3) ||          @@@@ REMOVED 2x LIMIT
            //(fReverse == true) ||
            fAdvanceInput )
        {
            durationIn += framesize;
            ++iframe;
            cntOut = 0;
        }
    }
        
    return cOutEpochs;
} /* CBackend::ProsodyMod */



/*****************************************************************************
* CBackend::LPCFilter *
*---------------------*
*   Description:
*   LPC filter of order cOrder. It filters the residual signal
*   pRes, producing output pOutWave. This routine requires that
*   pOutWave has the true waveform history from [-cOrder,0] and
*   of course it has to be defined.
*       
********************************************************************** MC ***/
void CBackend::LPCFilter( float *pCurLPC, float *pCurRes, long len, float gain )
{
    SPDBG_FUNC( "CBackend::LPCFilter" );
    INT t, j;
    
    for( t = 0; t < len; t++ )
    {
        m_pHistory[0] = pCurLPC[0] * pCurRes[t];
        for( j = m_cOrder; j > 0; j-- )
        {
            m_pHistory[0] -= pCurLPC[j] * m_pHistory[j];
            m_pHistory[j] = m_pHistory[j - 1];
        }
        pCurRes[t] = m_pHistory[0] * gain;
    }
} /* CBackend::LPCFilter */


/*void CBackend::LPCFilter( float *pCurLPC, float *pCurRes, long len )
{
long        t;

  for( t = 0; t < len; t++ )
        {
        pCurRes[t] = pCurRes[t] * 10;
        }
        }
*/



/*****************************************************************************
* CBackend::ResRecons *
*---------------------*
*   Description:
*   Obtains output prosody modified residual
*       
********************************************************************** MC ***/
void CBackend::ResRecons( float *pInRes, 
                          long  InSize, 
                          float *pOutRes, 
                          long  OutSize, 
                          float scale )
{
    SPDBG_FUNC( "CBackend::ResRecons" );
    long        i, j;
    
    if( m_pRevFlag[m_EpochIndex] )
    {
        //----------------------------------------------------
        // Process repeated and reversed UNvoiced residual
        //----------------------------------------------------
        for( i = 0, j = OutSize-1;  i < OutSize;  ++i, --j )
        {
            pOutRes[i] = pInRes[j];
        }
    }
    else if( InSize == OutSize )
    {
        //----------------------------------------------------
        // Unvoiced residual or voiced residual 
        // with no pitch change
        //----------------------------------------------------
        memcpy( pOutRes, pInRes, sizeof(float) *OutSize );
    }
    else
    {
        //----------------------------------------------------
        // Process voiced residual   
        //----------------------------------------------------
        PSOLA_Stretch( pInRes, InSize, pOutRes, OutSize, m_pWindow, m_FFTSize );
    }
    
    //----------------------------------
    // Amplify frame
    //----------------------------------
    if( scale != 1.0f )
    {
        for( i = 0 ; i < OutSize; ++i )
        {
            pOutRes[i] *= scale;
        }
    }
} /* CBackend::ResRecons */




/*****************************************************************************
* CBackend::StartNewUnit *
*------------------------*
*   Description:
*   Synthesize audio samples for a target unit
* 
*   INPUT:
*       pCurUnit - unit ID, F0, duration, etc.
* 
*   OUTPUT:
*       Sets 'pCurUnit->csamplesOut' with audio length
*       
********************************************************************** MC ***/
HRESULT CBackend::StartNewUnit( )
{   
    SPDBG_FUNC( "CBackend::StartNewUnit" );
    long        cframeMax = 0, cInEpochs = 0, i;
    float       totalDuration, durationOut, durationMpy = 0;
    UNITINFO    *pCurUnit;
    HRESULT     hr = S_OK;
    SPEVENT     event;
	ULONGLONG	clientInterest;
 	USHORT		volumeVal;
   
	// Check for VOLUME change
	if( m_pOutputSite->GetActions() & SPVES_VOLUME )
	{
		hr = m_pOutputSite->GetVolume( &volumeVal );
		if ( SUCCEEDED( hr ) )
		{
			if( volumeVal > SPMAX_VOLUME )
			{
				//--- Clip rate to engine maximum
				volumeVal = SPMAX_VOLUME;
			}
			else if ( volumeVal < SPMIN_VOLUME )
			{
				//--- Clip rate to engine minimum
				volumeVal = SPMIN_VOLUME;
			}
			m_MasterVolume = volumeVal;
		}
	}

    //---------------------------------------
    // Delete previous unit
    //---------------------------------------
    CleanUpSynth( );
    
    //---------------------------------------
    // Get next phon
    //---------------------------------------
    hr = m_pSrcObj->NextData( (void**)&pCurUnit, &m_SpeechState );
    if( m_SpeechState == SPEECH_CONTINUE )
    {
		m_HasSpeech = pCurUnit->hasSpeech;
		m_pOutputSite->GetEventInterest( &clientInterest );

		//------------------------------------------------
        // Post SENTENCE event
        //------------------------------------------------
        if( (pCurUnit->flags & SENT_START_FLAG) && (clientInterest & SPFEI(SPEI_SENTENCE_BOUNDARY)) )
        {
			event.elParamType = SPET_LPARAM_IS_UNDEFINED;
            event.eEventId = SPEI_SENTENCE_BOUNDARY;
            event.ullAudioStreamOffset = m_cOutSamples_Total * m_BytesPerSample;
	        event.lParam = pCurUnit->sentencePosition;	        // Input word position
	        event.wParam = pCurUnit->sentenceLen;	            // Input word length
            m_pOutputSite->AddEvents( &event, 1 );
        }
        //------------------------------------------------
        // Post PHONEME event
        //------------------------------------------------
        if( clientInterest & SPFEI(SPEI_PHONEME) )
		{
			event.elParamType = SPET_LPARAM_IS_UNDEFINED;
			event.eEventId = SPEI_PHONEME;
			event.ullAudioStreamOffset = m_cOutSamples_Total * m_BytesPerSample;
			event.lParam = ((ULONG)pCurUnit->AlloFeatures << 16) + g_IPAToAllo[pCurUnit->AlloID];
			event.wParam = ((ULONG)(pCurUnit->duration * 1000.0f) << 16) + g_IPAToAllo[pCurUnit->NextAlloID];
			m_pOutputSite->AddEvents( &event, 1 );
		}

        //------------------------------------------------
        // Post VISEME event
        //------------------------------------------------
        if( clientInterest & SPFEI(SPEI_VISEME) )
		{
			event.elParamType = SPET_LPARAM_IS_UNDEFINED;
			event.eEventId = SPEI_VISEME;
			event.ullAudioStreamOffset = m_cOutSamples_Total * m_BytesPerSample;
			event.lParam = ((ULONG)pCurUnit->AlloFeatures << 16) + g_AlloToViseme[pCurUnit->AlloID];
			event.wParam = ((ULONG)(pCurUnit->duration * 1000.0f) << 16) + g_AlloToViseme[pCurUnit->NextAlloID];
			m_pOutputSite->AddEvents( &event, 1 );
		}

        //------------------------------------------------
        // Post any bookmark events
        //------------------------------------------------
        if( pCurUnit->pBMObj != NULL )
        {
            CBookmarkList   *pBMObj;
            BOOKMARK_ITEM*  pMarker;

            //-------------------------------------------------
            // Retrieve marker strings from Bookmark list and
            // enter into Event list
            //-------------------------------------------------
            pBMObj = (CBookmarkList*)pCurUnit->pBMObj;
            //cMarkerCount = pBMObj->m_BMList.GetCount();
			if( clientInterest & SPFEI(SPEI_TTS_BOOKMARK) )
			{
				//---------------------------------------
				// Send event for every bookmark in list
				//---------------------------------------
				SPLISTPOS	listPos;

				listPos = pBMObj->m_BMList.GetHeadPosition();
				while( listPos )
				{
					pMarker                    = (BOOKMARK_ITEM*)pBMObj->m_BMList.GetNext( listPos );
					event.eEventId             = SPEI_TTS_BOOKMARK;
					event.elParamType          = SPET_LPARAM_IS_STRING;
					event.ullAudioStreamOffset = m_cOutSamples_Total * m_BytesPerSample;
                    //--- Copy in bookmark string - has been NULL terminated in source already...
					event.lParam               = pMarker->pBMItem;
                    // Engine must convert string to long for wParam.
                    event.wParam               = _wtol((WCHAR *)pMarker->pBMItem);
					m_pOutputSite->AddEvents( &event, 1 );
				}
			}
            //---------------------------------------------
            // We don't need this Bookmark list any more
            //---------------------------------------------
            delete pBMObj;
            pCurUnit->pBMObj = NULL;
        }
		


        pCurUnit->csamplesOut = 0;
        //******************************************************
        // For SIL, fill buffer with zeros...
        //******************************************************
        if( pCurUnit->UnitID == UNIT_SIL )
        {   
            //---------------------------------------------
            // Calc SIL length
            //---------------------------------------------
            m_durationTarget    = (long)(m_SampleRate * pCurUnit->duration);
            m_cOutSamples_Phon  = 0;
            m_silMode           = true;
        
            //---------------------------------------------
            // Clear LPC filter storage
            //---------------------------------------------
            memset( m_pHistory, 0, sizeof(float)*(m_cOrder+1) );
        
            //--------------------------------
            // Success!
            //--------------------------------

            // Debug macro - output unit data...
            TTSDBG_LOGUNITS;
        }   
        //******************************************************
        // ...otherwise fill buffer with inventory data
        //******************************************************
        else
        {
            m_silMode = false;
            // Get unit data from voice
            hr = m_pVoiceDataObj->GetUnitData( pCurUnit->UnitID, &m_Synth );
            if( SUCCEEDED(hr) )
            {
                durationOut     = 0.0f;
                cInEpochs       = m_Synth.cNumEpochs;
                m_pInEpoch      = m_Synth.pEpoch;
                //cframeMax     = PeakValue( m_pInEpoch, cInEpochs );
                totalDuration   = (float)m_Synth.cNumSamples;

                //-----------------------------------------------
                // For debugging: Force duration to unit length
                //-----------------------------------------------
                /*float       unitDur;

                unitDur = totalDuration / 22050.0f;     
                if( pCurUnit->duration < unitDur )
                {
                    if( pCurUnit->speechRate < 1 )
                    {
                        pCurUnit->duration = unitDur * pCurUnit->speechRate;
                    }
                    else
                    {
                        pCurUnit->duration = unitDur;
                    }
                }*/

                durationMpy     = pCurUnit->duration;
        
                cframeMax = (long)pCurUnit->pF0[0];
                for( i = 1; i < (long)pCurUnit->nKnots; i++ )
                {
                    //-----------------------------------------
                    // Find the longest epoch
                    //-----------------------------------------
                    cframeMax = (long)(MAX(cframeMax,pCurUnit->pF0[i]));
                }
                cframeMax *= (long)(durationMpy * MAX_TARGETS_PER_UNIT);
        
        
                durationMpy = (m_SampleRate * durationMpy) / totalDuration;
                cframeMax += (long)(durationMpy * cInEpochs * MAX_TARGETS_PER_UNIT);
                //
                // mplumpe 11/18/97 : added to eliminate chance of crash.
                //
                cframeMax *= 2;
                //---------------------------------------------------
                // New epochs adjusted for duration and pitch
                //---------------------------------------------------
                m_pOutEpoch = new float[cframeMax];
                if( !m_pOutEpoch )
                {
                    //--------------------------------------
                    // Out of memory!
                    //--------------------------------------
                    hr = E_OUTOFMEMORY;
                    pCurUnit->csamplesOut = 0;
                    CleanUpSynth( );
                }
            }
            if( SUCCEEDED(hr) )
            {
                //---------------------------------------------------
                // Index back to orig epoch
                //---------------------------------------------------
                m_pMap = new long[cframeMax];
                if( !m_pMap )
                {
                    //--------------------------------------
                    // Out of memory!
                    //--------------------------------------
                    hr = E_OUTOFMEMORY;
                    pCurUnit->csamplesOut = 0;
                    CleanUpSynth( );
                }
            }
            if( SUCCEEDED(hr) )
            {
                //---------------------------------------------------
                // TRUE = reverse residual
                //---------------------------------------------------
                m_pRevFlag = new short[cframeMax];
                if( !m_pRevFlag )
                {
                    //--------------------------------------
                    // Out of memory!
                    //--------------------------------------
                    hr = E_OUTOFMEMORY;
                    pCurUnit->csamplesOut = 0;
                    CleanUpSynth( );
                }
            }
            if( SUCCEEDED(hr) )
            {
                //---------------------------------------------------------------------
                // Compute synthesis epochs and corresponding mapping to analysis
                // fills in:    m_pOutEpoch, m_pMap, m_pRevFlag
                //---------------------------------------------------------------------
                m_cOutEpochs = ProsodyMod( pCurUnit, cInEpochs, durationMpy );
        
                //------------------------------------------------
                // Now that actual epoch sizes are known,
                // calculate total audio sample count
                // @@@@ NO LONGER NEEDED
                //------------------------------------------------
                pCurUnit->csamplesOut = 0;
                for( i = 0; i < m_cOutEpochs; i++ )
                {
                    pCurUnit->csamplesOut += (long)(ABS(m_pOutEpoch[i]));
                }
        
        
                m_cOutSamples_Phon  = 0;
                m_EpochIndex        = 0;
                m_durationTarget    = (long)(pCurUnit->duration * m_SampleRate);
                m_pInRes            = m_Synth.pRes;
                m_pLPC              = m_Synth.pLPC;
                m_pSynthTime        = pCurUnit->pTime;
                m_pSynthAmp         = pCurUnit->pAmp;
                m_nKnots            = pCurUnit->nKnots;
                // NOTE: Maybe make log volume?
                m_UnitVolume        = (float)pCurUnit->user_Volume / 100.0f;

                //------------------------------------------------
                // Post WORD event
                //------------------------------------------------
               if( (pCurUnit->flags & WORD_START_FLAG) && (clientInterest & SPFEI(SPEI_WORD_BOUNDARY)) )
                {
					event.elParamType = SPET_LPARAM_IS_UNDEFINED;
                    event.eEventId = SPEI_WORD_BOUNDARY;
                    event.ullAudioStreamOffset = m_cOutSamples_Total * m_BytesPerSample;
	                event.lParam = pCurUnit->srcPosition;	        // Input word position
	                event.wParam = pCurUnit->srcLen;	            // Input word length
                    m_pOutputSite->AddEvents( &event, 1 );
                }
        

                //--- Debug macro - output unit data
                TTSDBG_LOGUNITS;
            }
        }
    }

    return hr;
} /* CBackend::StartNewUnit */





/*****************************************************************************
* CBackend::CleanUpSynth *
*------------------------*
*   Description:
*       
********************************************************************** MC ***/
void    CBackend::CleanUpSynth( )
{
    SPDBG_FUNC( "CBackend::CleanUpSynth" );

    if( m_pOutEpoch )
    {
        delete m_pOutEpoch;
        m_pOutEpoch = NULL;
    }
    if( m_pMap )
    {
        delete m_pMap;
        m_pMap = NULL;
    }
    if( m_pRevFlag )
    {
        delete m_pRevFlag;
        m_pRevFlag = NULL;
    }
    // NOTE: make object?
    FreeSynth( &m_Synth );

} /* CBackend::CleanUpSynth */



/*****************************************************************************
* CBackend::RenderFrame *
*-----------------------*
*   Description:
*   This this the central synthesis loop. Keep filling output audio
*   buffer until buffer frame is full or speech is done. To render 
*   continous speech, get each unit one at a time from upstream buffer.
*       
********************************************************************** MC ***/
HRESULT CBackend::RenderFrame( )
{
    SPDBG_FUNC( "CBackend::RenderFrame" );
    long        InSize, OutSize;
    long        iframe;
    float       *pCurInRes, *pCurOutRes;
    long        i, j;
    float       ampMpy;
    HRESULT     hr = S_OK;
    
    m_cOutSamples_Frame = 0;
    do
    {
        OutSize = 0;
        if( m_silMode )
        {
            //-------------------------------
            // Silence mode
            //-------------------------------
            if( m_cOutSamples_Phon >= m_durationTarget )
            {
                //---------------------------
                // Get next unit
                //---------------------------
                hr = StartNewUnit( );
                if (FAILED(hr))
                {
                    //-----------------------------------
                    // Try to end it gracefully...
                    //-----------------------------------
                    m_SpeechState = SPEECH_DONE;
                }

				TTSDBG_LOGSILEPOCH;
            }
            else
            {
                //---------------------------
                // Continue with current SIL
                //---------------------------
                m_pSpeechBuf[m_cOutSamples_Frame] = 0;
                OutSize = 1;
            }
        }
        else
        {
            if( m_EpochIndex < m_cOutEpochs )
            {
                //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                //
                // Continue with current phon
                //
                //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                //------------------------------------
                // Find current input residual
                //------------------------------------
                iframe = m_pMap[m_EpochIndex];
                pCurInRes = m_pInRes;
                for( i = 0; i < iframe; i++)
                {
                    pCurInRes += (long) ABS(m_pInEpoch[i]);
                }
                
                pCurOutRes  = m_pSpeechBuf + m_cOutSamples_Frame;
                InSize      = (long)(ABS(m_pInEpoch[iframe]));
                OutSize     = (long)(ABS(m_pOutEpoch[m_EpochIndex]));
                j = 1;
                while( (j < m_nKnots - 1) && (m_cOutSamples_Phon > m_pSynthTime[j]) )
                {
                    j++;
                }
                ampMpy = LinInterp( m_pSynthTime[j - 1], (float)m_cOutSamples_Phon, m_pSynthTime[j], m_pSynthAmp[j - 1], m_pSynthAmp[j] );
                //ampMpy = 1;
                
                //--------------------------------------------
                // Do stretching of residuals
                //--------------------------------------------
                ResRecons( pCurInRes, InSize, pCurOutRes, OutSize, ampMpy );
                
                //--------------------------------------------
                // Do LPC reconstruction
                //--------------------------------------------
                float       *pCurLPC;
				float       totalGain;

				totalGain = ExpConverter( ((float)m_MasterVolume / (float)SPMAX_VOLUME), m_linearScale ) 
								* ExpConverter( m_UnitVolume, m_linearScale );
                
                pCurLPC = m_pLPC + m_pMap[m_EpochIndex] * (1 + m_cOrder);
                pCurLPC[0] = 1.0f;
                LPCFilter( pCurLPC, &m_pSpeechBuf[m_cOutSamples_Frame], OutSize, totalGain );
                m_EpochIndex++;
            }
            else
            {
                //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                //
                // Get next phon
                //
                //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                hr = StartNewUnit( );
                if (FAILED(hr))
                {
                    //-----------------------------------
                    // Try to end it gracefully...
                    //-----------------------------------
                    m_SpeechState = SPEECH_DONE;
                }
				TTSDBG_LOGSILEPOCH;
            }
        }
        m_cOutSamples_Frame += OutSize;
        m_cOutSamples_Phon += OutSize;
        m_cOutSamples_Total += OutSize;

		TTSDBG_LOGEPOCHS;
    }
    while( (m_cOutSamples_Frame < SPEECH_FRAME_SIZE) && (m_SpeechState == SPEECH_CONTINUE) );
    
	if( SUCCEEDED(hr) )
	{
		//----------------------------------------------
		// Convert buffer from FLOAT to SHORT
		//----------------------------------------------
		if( m_pReverb )
		{
			//---------------------------------
			// Add REVERB
			//---------------------------------
			m_pReverb->Reverb_Process( m_pSpeechBuf, m_cOutSamples_Frame, 1.0f );
		}
		else
		{
			CvtToShort( m_pSpeechBuf, m_cOutSamples_Frame, m_StereoOut, 1.0f );
		}

        //--- Debug Macro - output wave data to stream
        TTSDBG_LOGWAVE;
	}
    
    if( SUCCEEDED( hr ) )
    {
        //------------------------------------
        // Send this buffer to SAPI site
        //------------------------------------
        DWORD   cbWritten;

		//------------------------------------------------------------------------------------
		// This was my lame hack to avoid sending buffers when nothing was spoken.
		// It was causing problems (among others) since StartNewUnit() was still sending
		// events - with no corresponding audio buffer! 
		//
		// This was too simple of a scheme. Disable this feature for now... 
		// ...until I come up with something more robust. (MC)
		//------------------------------------------------------------------------------------

		//if( m_HasSpeech )
		{
			hr = m_pOutputSite->Write( (void*)m_pSpeechBuf, 
									  m_cOutSamples_Frame * m_BytesPerSample, 
									  &cbWritten );
			if( FAILED( hr ) )
			{
				//----------------------------------------
				// Abort! Unable to write audio data
				//----------------------------------------
				m_SpeechState = SPEECH_DONE;
			}
		}
    }

    //------------------------------------
    // Return render state
    //------------------------------------
    return hr;
} /* CBackend::RenderFrame */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\data.cpp ===
/*******************************************************************************
* Data.cpp *
*----------*
*   Description:
*       Constant data tables.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

#include "stdafx.h"

#ifndef AlloOps_H
#include "AlloOps.h"
#endif
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif


#pragma warning(disable : 4305)
#pragma warning(disable : 4309)

#define	PUNCT_GAIN		1.67
#define	PUNCT_GAIN1		1.33
#define	SUB1_GAIN		1.00
#define	SUB2_GAIN		1.00




// I don't understand why I had to add "extern" here.
// If YOU do, please explain here for the rest of us:

extern const float g_BoundryStretchTbl[] =
{
    1.0,			// NULL_BOUNDARY = 0,  // no boundary
    PUNCT_GAIN1,    // PHRASE_BOUNDARY,    // comma
    PUNCT_GAIN,    // EXCLAM_BOUNDARY,    // exclamatory utterance terminator
    PUNCT_GAIN,    // YN_QUEST_BOUNDARY,     // yes-no question terminator
    PUNCT_GAIN,    // WH_QUEST_BOUNDARY,     // yes-no question terminator
    PUNCT_GAIN,    // DECLAR_BOUNDARY,    // declarative terminator
    SUB1_GAIN,    // PAREN_L_BOUNDARY,   // left paren
    SUB1_GAIN,    // PAREN_R_BOUNDARY,   // right paren
    SUB1_GAIN,    // QUOTE_L_BOUNDARY,   // left quote
    SUB1_GAIN,    // QUOTE_R_BOUNDARY,   // right quote
    SUB1_GAIN,    // PHONE_BOUNDARY,	// Telephone number
    1.30,			// TOD_BOUNDARY,		// Time-of-day

    SUB2_GAIN,    // SUB_BOUNDARY_1,     // NOTE: always put these at the end
    SUB2_GAIN,    // SUB_BOUNDARY_2,
    SUB2_GAIN,    // SUB_BOUNDARY_3,
    SUB2_GAIN,    // SUB_BOUNDARY_4,
    SUB2_GAIN,    // SUB_BOUNDARY_5,
    SUB2_GAIN,    // SUB_BOUNDARY_6,
    SUB2_GAIN,    // NUMBER_BOUNDARY,

	1.0,			// TAIL_BOUNDARY
};



extern const float   g_BoundryDurTbl[] =
{
    0.200,    // NULL_BOUNDARY = 0,  // no boundary
    0.200,    // PHRASE_BOUNDARY,    // comma
    0.300,    // EXCLAM_BOUNDARY,    // exclamatory utterance terminator
    0.300,    // YN_QUEST_BOUNDARY,     // yes-no question terminator
    0.300,    // WH_QUEST_BOUNDARY,     // wh question terminator
    0.300,    // DECLAR_BOUNDARY,    // declarative terminator
    0.200,    // PAREN_L_BOUNDARY,   // left paren
    0.200,    // PAREN_R_BOUNDARY,   // right paren
    0.200,    // QUOTE_L_BOUNDARY,   // left quote
    0.200,    // QUOTE_R_BOUNDARY,   // right quote
    0.100,    // PHONE_BOUNDARY,	// Telephone number
    0.010,    // TOD_BOUNDARY,		// Time-of-day
    0.200,    // ELLIPSIS_BOUNDARY,		// Ellipsis

    0.001,    // SUB_BOUNDARY_1,     // NOTE: always put these at the end
    0.001,    // SUB_BOUNDARY_2,
    0.001,    // SUB_BOUNDARY_3,
    0.001,    // SUB_BOUNDARY_4,
    0.001,    // SUB_BOUNDARY_5,
    0.001,    // SUB_BOUNDARY_6,

    0.001,    // NUMBER_BOUNDARY,

    0.001,    // TAIL_BOUNDARY,
};






//-------------------------------------------
// Translate -24 <--> +24 pitch control to 
// 24th root of two pitch scale
//-------------------------------------------
extern const float   g_PitchScale[] =
{
    1.0,
    1.0293022366434920287823718007739,
    1.0594630943592952645618252949463,
    1.0905077326652576592070106557607,
    1.1224620483093729814335330496792,
    1.1553526968722730102453370986819,
    1.1892071150027210667174999705605,
    1.2240535433046552391321602168255,
    1.2599210498948731647672106072777,
    1.2968395546510096659337541177919,
    1.3348398541700343648308318811839,
    1.3739536474580891017766557477492,
    1.4142135623730950488016887242091,
    1.4556531828421873543551155614673,
    1.4983070768766814987992807320292,
    1.5422108254079408236122918620901,
    1.5874010519681994747517056392717,
    1.6339154532410998436782440504114,
    1.6817928305074290860622509524658,
    1.7310731220122860533901844375553,
    1.7817974362806786094804524111803,
    1.8340080864093424634870831895876,
    1.8877486253633869932838263133343,
    1.9430638823072117374865788316417,
    2.0
};

//-------------------------------------------
// Translate -10 <--> +10 rate control to 
// 10th root of three rate scale
//-------------------------------------------
extern const float   g_RateScale[] =
{
    1.0,
    1.1161231740339044344426141383771,
    1.2457309396155173259666803366403,
    1.3903891703159093404852542946161,
    1.5518455739153596742733451355167,
    1.7320508075688772935274463415059,
    1.9331820449317627515248789432662,
    2.1576692799745930995549489159803,
    2.4082246852806920462855086141912,
    2.6878753795222865835819210737269,
    3,
    3.348369522101713303327842415131,
    3.7371928188465519779000410099203,
    4.1711675109477280214557628838472,
    4.6555367217460790228200354065486,
    5.1961524227066318805823390245155,
    5.7995461347952882545746368297956,
    6.4730078399237792986648467479371,
    7.2246740558420761388565258425687,
};







extern const unsigned short  g_Opcode_To_ASCII[] =
{
    'IY',   'IH',   'EH',   'AE',   'AA',   'AH',   'AO',   'UH',   'AX',   'ER',
    'EY',   'AY',   'OY',   'AW',   'OW',   'UW',
    'IX',   '_',   'w',    'y',
    'r',    'l',    'h',    'm',    'n',    'NG',   'f',    'v',    'TH',   'DH',
    's',    'z',    'SH',   'ZH',   'p',    'b',    't',    'd',    'k',    'g',
    'CH',   'JH',   'DX',   '1',    '2',    '3',    '/',
    0x5C,   '>',    '<',    '=',    '_',    '*',    '$',    ',',    '.',    '?',
    '!',    '-',    '#',    '+',    '~',    '@',    0,      0,      0,      0
};



extern const unsigned long   g_AlloFlags[] =
{

// IY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KYGLIDEENDF + KFRONTF,

// IH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// EH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// AE
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// AA
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// AH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// AO
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// UH
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// AX
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// ER
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F,

// EY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KYGLIDEENDF + KFRONTF + KDIPHTHONGF,

// AY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// OY
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// AW
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// OW
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// UW
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KDIPHTHONGF,

// IX
    KVOWELF + KVOICEDF + KVOWEL1F + KSONORANTF + KSONORANT1F + KFRONTF,

// SIL
    KSONORANT1F,

// W
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF + KLIQGLIDE2F,

// Y
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF + KYGLIDESTARTF + KYGLIDEENDF,

// R
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF + KLIQGLIDE2F,

// L
    KVOICEDF + KSONORANTF + KSONORANT1F + KCONSONANTF + KLIQGLIDEF + KSONORCONSONF,

// H
    KSONORANT1F + KCONSONANTF,

// M
    KVOICEDF + KSONORANTF + KSONORANT1F + KNASALF + KCONSONANTF + KSONORCONSONF + KOBSTF + KLABIALF + KHASRELEASEF,

// N
    KVOICEDF + KSONORANTF + KSONORANT1F + KNASALF + KCONSONANTF + KSONORCONSONF + KOBSTF + KALVEOLARF + KHASRELEASEF,

// NG
    KVOICEDF + KSONORANTF + KSONORANT1F + KNASALF + KCONSONANTF + KSONORCONSONF + KOBSTF + KVELAR + KHASRELEASEF,

// F
    KPLOSFRICF + KCONSONANTF + KLABIALF + KFRIC,

// V
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KLABIALF + KFRIC,

// TH
    KPLOSFRICF + KCONSONANTF + KDENTALF + KFRIC,

// DH
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KDENTALF + KFRIC,

// S
    KPLOSFRICF + KCONSONANTF + KALVEOLARF + KFRIC,

// Z
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KALVEOLARF + KFRIC,

// SH
    KPLOSFRICF + KCONSONANTF + KPALATALF + KFRIC,

// ZH
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KPALATALF + KFRIC,

// P
    KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KLABIALF + KHASRELEASEF,

// B
    KVOICEDF + KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KLABIALF + KHASRELEASEF,

// T
    KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KALVEOLARF + KHASRELEASEF,

// D
    KVOICEDF + KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KALVEOLARF + KHASRELEASEF,

// K
    KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KVELAR + KHASRELEASEF,

// G
    KVOICEDF + KPLOSFRICF + KSTOPF + KCONSONANTF + KPLOSIVEF + KOBSTF + KVELAR + KHASRELEASEF,

// CH
    KPLOSFRICF + KCONSONANTF + KPLOSIVEF + KOBSTF + KPALATALF + KAFFRICATEF,

// JH
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KPLOSIVEF + KOBSTF + KPALATALF + KAFFRICATEF,

// DX
    KVOICEDF + KPLOSFRICF + KCONSONANTF + KOBSTF,
};








extern const short   g_IPAToAllo[] =
{
    28,     // _IY_
    27,     // _IH_
    21,     // _EH_
    11,     // _AE_
    10,     // _AA_
    12,     // _AH_
    13,     // _AO_
    43,     // _UH_
    15,     // _AX_
    22,     // _ER_
    23,     // _EY_
    16,     // _AY_
    36,     // _OY_
    14,     // _AW_
    35,     // _OW_
    44,     // _UW_
    NO_IPA,     // _IX_
    7,     // _SIL_
    46,       // _w_
    47,       // _y_
    38,       // _r_     0x279
    31,       // _l_
    26,      // _h_      0x68
    32,       // _m_
    33,       // _n_
    34,      // _NG_
    24,       // _f_
    45,       // _v_
    42,      // _TH_
    20,      // _DH_
    39,       // _s_
    48,       // _z_
    40,      // _SH_
    49,      // _ZH_
    37,       // _p_
    17,       // _b_
    41,       // _t_
    19,       // _d_
    30,       // _k_
    25,       // _g_     0x67
    18,      // _CH_
    29,      // _JH_     0x2a4
    NO_IPA,       // _DX_       // @@@@
    8,      // _STRESS1_
    9,      // _STRESS2_
    NO_IPA,      // _EMPHSTRESS_
    1,      // _SYLLABLE_
};




extern const short   g_AlloToViseme[] =
{
    SP_VISEME_6,     // _IY_
    SP_VISEME_6,     // _IH_
    SP_VISEME_4,     // _EH_
    SP_VISEME_1,     // _AE_
    SP_VISEME_2,     // _AA_
    SP_VISEME_1,     // _AH_
    SP_VISEME_3,     // _AO_
    SP_VISEME_4,     // _UH_
    SP_VISEME_1,     // _AX_
    SP_VISEME_5,     // _ER_
    SP_VISEME_4,     // _EY_
    SP_VISEME_11,    // _AY_
    SP_VISEME_10,    // _OY_
    SP_VISEME_9,     // _AW_
    SP_VISEME_8,     // _OW_
    SP_VISEME_7,     // _UW_
    SP_VISEME_6,     // _IX_
    SP_VISEME_0,     // _SIL_
    SP_VISEME_7,       // _w_
    SP_VISEME_6,       // _y_
    SP_VISEME_13,       // _r_ 
    SP_VISEME_14,       // _l_
    SP_VISEME_12,      // _h_ 
    SP_VISEME_21,       // _m_
    SP_VISEME_19,       // _n_
    SP_VISEME_20,      // _NG_
    SP_VISEME_18,       // _f_
    SP_VISEME_18,       // _v_
    SP_VISEME_17,      // _TH_
    SP_VISEME_17,      // _DH_
    SP_VISEME_15,       // _s_
    SP_VISEME_15,       // _z_
    SP_VISEME_16,      // _SH_
    SP_VISEME_16,      // _ZH_
    SP_VISEME_21,       // _p_
    SP_VISEME_21,       // _b_
    SP_VISEME_19,       // _t_
    SP_VISEME_19,       // _d_
    SP_VISEME_20,       // _k_
    SP_VISEME_20,       // _g_
    SP_VISEME_16,      // _CH_
    SP_VISEME_16,      // _JH_ 
    SP_VISEME_13,       // _DX_       // @@@@
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\backend.h ===
/******************************************************************************
* Backend.h *
*-----------*
*  This is the header file for the CBackend implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

#ifndef Backend_H
#define Backend_H

#ifndef ReverbFX_H
#include "ReverbFX.h"
#endif
#ifndef FeedChain_H
#include "FeedChain.h"
#endif
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef SPCollec_h
#include <SPCollec.h>
#endif

#include "SpTtsEngDebug.h"





static const short MAX_TARGETS_PER_UNIT = 3;          // Max number of knots allowed
static const short MIN_VOICE_PITCH      = 10;         // Lowest voiced pitch (hertz)
static const short UNIT_SIL             = 0;           // Silence phon
static const short SPEECH_FRAME_SIZE	= 5000;        // Output audio uffer...
static const short SPEECH_FRAME_OVER	= 1000;        // ...plus pad

//----------------------------------------------------------
// find a yn corresponding to xn, 
// given (x0, y0), (x1, y1), x0 <= xn <= x1
//----------------------------------------------------------
inline float LinInterp( float x0, float xn, float x1, float y0, float y1 )
{
    return y0 + (y1-y0)*(xn-x0)/(x1-x0);
}

// Math marcos
#define ABS(x) ((x) >= 0 ? (x) : -(x))
#define MAX(x,y) (((x) >= (y)) ? (x) : (y))
#define MIN(x,y) (((x) <= (y)) ? (x) : (y))

static const float LINEAR_BKPT  = 0.1f;
static const float LOG_RANGE    = (-25.0f);

//********************************************************************
//
//  CBackend keeps track of all the state information for the
//  synthesis process.
//
//********************************************************************
class CBackend 
{
public:
    /*--- Constructors/Destructors ---*/
    CBackend ();
    ~CBackend ();

    /*=== Methods =======*/
    HRESULT Init(   IMSVoiceData* pVoiceDataObj, 
                    CFeedChain *pSrcObj, 
                    MSVOICEINFO* pVoiceInfo );
	SPEECH_STATE	GetSpeechState() {return m_SpeechState;}
    void    PrepareSpeech( ISpTTSEngineSite* outputSite );
    HRESULT RenderFrame( );


private:
    HRESULT StartNewUnit();
    long    ProsodyMod(    UNITINFO    *pCurUnit, 
                            long        cInEpochs, 
                            float       durationMpy);
    void    CleanUpSynth();
    void    ResRecons(  float   *pInRes,
                        long    InSize,
                        float   *pOutRes,
                        long    OutSize,
                        float   scale );
    void    LPCFilter( float *pCurLPC, float *pCurRes, long len, float gain );
    void    FreeSynth( MSUNITDATA* pSynth );
    void    PSOLA_Stretch(  float *pInRes, long InSize, 
                            float *pOutRes, long OutSize,
                            float *pWindow, 
                            long  cWindowSize );
    void    CvtToShort( float *pSrc, long blocksize, long stereoOut, float audioGain );
    void    Release( );
   
    /*=== Member Data ===*/
    CFeedChain      *m_pSrcObj;             // Backend gets its input from here
    MSUNITDATA      m_Synth;                // Unit data from 'Voicedataobj'
    float          *m_pHistory;             // LPC delays
    unsigned long   m_fModifiers;
    float          *m_pHistory2;            // IIR delays
    float          *m_pFilter;              // IIR/FIR coefficients
    long            m_cNumTaps;             // Coefficient count            
    LP_CReverbFX    m_pReverb;              // Reverb object


    long            *m_pMap;                // in/out epoch map
    float           *m_pOutEpoch;           // epoch sizes
    short           *m_pRevFlag;            // true = rev unvoiced

    float           *m_pInRes;              // m_pSynth.pRes
    float           *m_pInEpoch;            // m_pSynth.pEpoch
    float           *m_pLPC;                // m_pSynth->pLPC
    long            m_cOutSamples_Phon;     // sample count
    long            m_durationTarget;       // target sample total
    long            m_silMode;
    float           *m_pSynthTime;          // pCurUnit->pTime
    float           *m_pSynthAmp;           // pCurUnit->pAmp
    long            m_nKnots;               // pCurUnit->nKnots

    SPEECH_STATE    m_SpeechState;          // Either continue or done
    long            m_cOutSamples_Frame;    // Audio output sample count for frame
    float           *m_pSpeechBuf;          // Audio output sample buffer
    ULONG           m_cOutSamples_Total;    // Audio output sample count for Speak
    long            m_EpochIndex;           // Index for render
    long            m_cOutEpochs;           // Count for render


    long            m_vibrato_Phase1;       // Current vibrato phase index
    float           m_VibratoDepth;         // Vibrato gain
    float           m_VibratoFreq;          // Vibrato speed
    long            m_StereoOut;            // TRUE = stereo output
    long            m_BytesPerSample;       // 2 = mono, 4 = stereo
    IMSVoiceData*   m_pVoiceDataObj;        // Voice object
    ULONG           m_cOrder;               // LPC filter order
    float           m_SampleRate;           // I/O rate
    float*          m_pWindow;              // Hanning Window
    long            m_FFTSize;              // FFT length

    // User Controls
    float           m_UnitVolume;           // 0 - 1.0 (linear)
    long            m_MasterVolume;         // 0 - 100 (linear)
    float           m_linearScale;          // Linear taper region scale

    // SAPI audio sink
    ISpTTSEngineSite*   m_pOutputSite;
	bool			m_HasSpeech;
};




//--------------------------------
// Unimplemented
//--------------------------------
static const long BACKEND_BITFLAG_WHISPER     = (1 << 0);
static const long BACKEND_BITFLAG_FIR         = (1 << 1);
static const long BACKEND_BITFLAG_IIR         = (1 << 2);
static const long BACKEND_BITFLAG_REVERB      = (1 << 3);
static const float VIBRATO_DEFAULT_DEPTH      = 0.05f;
static const float VIBRATO_DEFAULT_FREQ       = 3.0f;          // hz

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\feedchain.h ===
/******************************************************************************
* FeedChain.h *
*-------------*
*  This is the header file for the CFeedChain implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

#ifndef FeedChain_H
#define FeedChain_H

#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef SPCollec_h
#include <SPCollec.h>
#endif



// Maximum posody breakpoints for each phon
typedef enum KNOTSLEN
{
    KNOTS_PER_PHON  = 20
}KNOTSLEN;



//-----------------------------------------------------
// This is the unit data the BE gets fron the FE
//-----------------------------------------------------
typedef struct UNITINFO
{
    ULONG       UnitID;         // Inventory table ID
    float       duration;       // Duration in seconds
    float       amp;			// Abs amplitude
    float       ampRatio;       // Amplitude gain
    ULONG       nKnots;         // Number of prosody breakpoints
    float       pTime[KNOTS_PER_PHON];  // Breakpoint length
    float       pF0[KNOTS_PER_PHON];    // Pitch breakpoint
    float       pAmp[KNOTS_PER_PHON];   // Amplitude gain breakpoint
    ULONG       PhonID;         // Phoneme ID
	ULONG		SenoneID;		// Context offset from PhonID
	USHORT		AlloID;
	USHORT		NextAlloID;
	USHORT		AlloFeatures;	// for viseme
    ULONG	    flags;          // Misc flags
    ULONG       csamplesOut;    // Number of rendered samples
	float		speechRate;

    //-- Event data
    ULONG       srcPosition;    // Position for WORD events
    ULONG       srcLen;         // Length for WORD events
    ULONG       sentencePosition;    // Position for SENTENCE events
    ULONG       sentenceLen;         // Length for SENTENCE events
    void        *pBMObj;        // Ptr to bookmark list

    //-- Control data
    ULONG       user_Volume;    // Output volume level
	bool		hasSpeech;
    
	//-- Debug output
	enum SILENCE_SOURCE		silenceSource;
    CHAR        szUnitName[15];
	long		ctrlFlags;
    /*long        cur_TIME;
    long        decompress_TIME;
    long        prosody_TIME;
    long        stretch_TIME;
    long        lpc_TIME;*/
} UNITINFO;



//-------------------------------------------------
// Since bookmarks can be stacked, we need to 
// save each individually into a list
//-------------------------------------------------
typedef struct 
{
    LPARAM  pBMItem;      // Ptr to text data
} BOOKMARK_ITEM;


class CBookmarkList
{
public:
    //----------------------------------------
    // Needs destructor to dealloc 
    // 'BOOKMARK_ITEM' memory
    //----------------------------------------
    ~CBookmarkList();

    //----------------------------------------
    // Linked list bookmark items
    //----------------------------------------
    CSPList<BOOKMARK_ITEM*, BOOKMARK_ITEM*> m_BMList;
};

//---------------------------------------------------
// Speech states
//---------------------------------------------------
enum SPEECH_STATE
{   
    SPEECH_CONTINUE,
    SPEECH_DONE
};



class CFeedChain
{
public:
    
    virtual HRESULT NextData( void **pData, SPEECH_STATE *pSpeechState ) = 0;
};



#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\disambig.cpp ===
/*******************************************************************************
* Disambig.cpp *
*--------------*
*	Description:
*		This module contains the methods to disambiguate part of speech and
*	select the correct pronounciation from the lexicon.
*-------------------------------------------------------------------------------
*  Created By: EDC										  Date: 07/15/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "commonlx.h"
#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif
#include "spttsengdebug.h"

/*****************************************************************************
* TryPOSConversion *
*------------------*  
*       
*   Description:
*       Checks to see whether the argument PRONRECORD contains the argument
*   ENGPARTOFSPEECH as an option.  If so, sets the PRONRECORD alternate
*   choice and part of speech choice, and returns true.  If not, just returns
*   false without modifying the PRONRECORD at all.
*
***************************************************************** AH *********/
bool TryPOSConversion( PRONRECORD& pPron, ENGPARTOFSPEECH PartOfSpeech )
{

    //--- Check first pronunciation
    for ( ULONG i = 0; i < pPron.pronArray[0].POScount; i++ )
    {
        if ( pPron.pronArray[0].POScode[i] == PartOfSpeech )
        {
            pPron.altChoice = 0;
            pPron.POSchoice = PartOfSpeech;
            return true;
        }
    }

    //--- Check second pronunciation
    if ( pPron.hasAlt )
    {
        for ( ULONG i = 0; i < pPron.pronArray[1].POScount; i++ )
        {
            if ( pPron.pronArray[1].POScode[i] == PartOfSpeech )
            {
                pPron.altChoice = 1;
                pPron.POSchoice = PartOfSpeech;
                return true;
            }
        }
    }

    return false;
} /* TryPOS Conversion */

/*****************************************************************************
* DisambiguatePOS *
*-----------------*  
*       
*   Description:
*       Disambiguate parts of speech by applying patches in order...  This 
*   work is an implementation of Eric Brill's rule-based part of speech
*   tagger - see, for example:
*
*   Brill, Eric. 1992. A simple rule-based part of speech tagger.  
*       In Proceedings of the Third Conference on Applied Natural
*       Language Processing, ACL. Trento, Italy.
*
***************************************************************** AH *********/
void DisambiguatePOS( PRONRECORD *pProns, ULONG cNumOfWords )
{
    SPDBG_FUNC( "DisambiguatePOS" );

    //--- Iterate over the patches, applying each (where applicable) to the
    //--- entire sentence.  For each patch, iterate over each word in the 
    //--- sentence to which the patch could apply (from left to right).
    for ( int i = 0; i < sp_countof( g_POSTaggerPatches ); i++ )
    {
        switch ( g_POSTaggerPatches[i].eTemplateType )
        {
        case PREV1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous POS matches, and
                            //--- the conversion POS is a possibility for this word, convert the
                            //--- POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches, and 
                            //--- the conversion POS is a possibility for this word, convert the
                            //--- POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 2; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the POS two previous matches, and
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 2; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the POS two after matches, and 
                            //--- the conversion POS is a possibility for this word, convert the
                            //--- POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1OR2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous POS matches OR the
                            //--- POS two previous matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j > 1                                                        &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }            
                        }
                    }
                }
            }
            break;
        case NEXT1OR2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches OR the POS
                            //--- two after matches, and the conversion POS is a possibility for this 
                            //--- word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j < cNumOfWords - 2                                          &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1OR2OR3T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous POS matches OR the
                            //--- POS two previous matches OR the POS three previous matches, and 
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j > 1                                                        &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j > 2                                                        &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 3].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }                         
                        }
                    }
                }
            }
            break;
        case NEXT1OR2OR3T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches OR the POS
                            //--- two after matches OR the POS three after matches, and the conversion 
                            //--- POS is a possibility for this word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j < cNumOfWords - 2                                          &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j < cNumOfWords - 3                                          &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 3].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1TNEXT1T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 1; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches, and the
                            //--- previous POS matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS2 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1TNEXT2T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 1; j < cNumOfWords - 2; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the POS two after matches, and the
                            //--- previous POS matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS2 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV2TNEXT1T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 2; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches, and the
                            //--- POS two previous matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS2 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CAP:
            {
                for ( ULONG j = 0; j < cNumOfWords; j++ )
                {
                    if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                    {
                        //--- If the current POS matches, and the word is capitalized, and the
                        //--- conversion POS is a possibility for this word, convert the POS.
                        if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                             iswupper( pProns[j].orthStr[0] ) )
                        {
                            TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                        }
                    }
                }
            }
            break;
        case NOTCAP:
            {
                for ( ULONG j = 0; j < cNumOfWords; j++ )
                {
                    if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                    {
                        //--- If the current POS matches, and the word is not capitalized, and the
                        //--- conversion POS is a possibility for this word, convert the POS.
                        if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                             !iswupper( pProns[j].orthStr[0] ) )
                        {
                            TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                        }
                    }
                }
            }
            break;
        case PREVCAP:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word is capitalized, 
                            //--- and the conversion POS is a possibility for this word, convert the 
                            //--- POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 iswupper( pProns[j - 1].orthStr[0] ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREVNOTCAP:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the word is capitalized, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 !iswupper( pProns[j - 1].orthStr[0] ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next word matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV2W:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 2; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the word two previous matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j - 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT2W:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 2; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the word two after matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j + 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1OR2W:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word OR the word two 
                            //--- previous matches, and the conversion POS is a possibility for this word, 
                            //--- convert the POS.
                            if ( ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) ||
                                 ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j - 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1OR2W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next word matches OR the word two after
                            //--- matches, and the conversion POS is a possibility for this word, convert the 
                            //--- POS.
                            if ( ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) ||
                                 ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j + 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWPREV1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the previous
                            //--- word matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                    &&
                                 _wcsicmp( pProns[j].orthStr,     g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWNEXT1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the next
                            //--- word matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                    &&
                                 _wcsicmp( pProns[j].orthStr,     g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWPREV1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the previous
                            //--- POS matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWNEXT1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the next
                            //--- POS matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRW:
            {
                for ( ULONG j = 0; j < cNumOfWords; j++ )
                {
                    if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                    {
                        //--- If the current POS matches, and the current word matches, and the
                        //--- conversion POS is a possibility for this word, convert the POS.
                        if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                             _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                        {
                            TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS ) ;
                        }
                    }
                }
            }
            break;
        case PREV1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word and POS match, and
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next word and POS match, and
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWPREV1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current words matches, and the
                            //--- previous word and POS match, and the conversion POS is a possibility
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 )     == 0 &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1              &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWNEXT1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current words matches, and the
                            //--- next word and POS match, and the conversion POS is a possibility
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 )     == 0 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1              &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        }
    }
} /* DisambiguatePOS */

/*****************************************************************************
* Pronounce *
*-----------*
*	Description:
*		Get lexicon or letter-to-sound (LTS) pronunciations
*		
********************************************************************** MC ***/
HRESULT CStdSentEnum::Pronounce( PRONRECORD *pPron )
{
    SPDBG_FUNC( "Pronounce" );
    SPWORDPRONUNCIATIONLIST 	SPList;
    HRESULT 	hr = SPERR_NOT_IN_LEX;
    ULONG	cPhonLen;
    DWORD dwFlags = eLEXTYPE_USER | eLEXTYPE_APP | eLEXTYPE_PRIVATE1 | eLEXTYPE_PRIVATE2;
    BOOL  fPOSExists = false;
    
    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );

    //--- Special Case - XML Provided Part Of Speech.  Search for exact match first...
    if ( pPron->XMLPartOfSpeech != MS_Unknown )
    {
        //--- Try User Lexicon
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_USER, &SPList );
        if ( SUCCEEDED( hr ) &&
             SPList.pFirstWordPronunciation )
        {
            for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                  pPronunciation = pPronunciation->pNextWordPronunciation )
            {
                if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                {
                    fPOSExists = true;
                    break;
                }
            }
            if ( !fPOSExists )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
            }
        }
        //--- Handle empty pronunciation
        else if ( !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
        //--- Try App Lexicon
        if ( !fPOSExists )
        {
            hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_APP, &SPList );
            if ( SUCCEEDED( hr ) &&
                SPList.pFirstWordPronunciation )
            {
                for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                      pPronunciation = pPronunciation->pNextWordPronunciation )
                {
                    if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                    {
                        fPOSExists = true;
                        break;
                    }
                }
                if ( !fPOSExists )
                {
                    if ( SPList.pvBuffer )
                    {
                        ::CoTaskMemFree( SPList.pvBuffer );
                        ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                    }
                }
            }
            //--- Handle empty pronunciation
            else if ( !SPList.pFirstWordPronunciation )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
                hr = SPERR_NOT_IN_LEX;
            }
        }
        //--- Try Vendor Lexicon
        if ( !fPOSExists )
        {
            hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_PRIVATE1, &SPList );
            if ( SUCCEEDED( hr ) &&
                 SPList.pFirstWordPronunciation )
            {
                for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                      pPronunciation = pPronunciation->pNextWordPronunciation )
                {
                    if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                    {
                        fPOSExists = true;
                        break;
                    }
                }
                if ( !fPOSExists )
                {
                    if ( SPList.pvBuffer )
                    {
                        ::CoTaskMemFree( SPList.pvBuffer );
                        ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                    }
                }
            }
            //--- Handle empty pronunciation
            else if ( !SPList.pFirstWordPronunciation )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
                hr = SPERR_NOT_IN_LEX;
            }
        }
        //--- Try Morph Lexicon
        if ( !fPOSExists )
        {
            hr = m_pMorphLexicon->DoSuffixMorph( pPron->orthStr, pPron->lemmaStr, 1033, dwFlags, &SPList );
            if ( SUCCEEDED( hr ) &&
                 SPList.pFirstWordPronunciation )
            {
                for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                      pPronunciation = pPronunciation->pNextWordPronunciation )
                {
                    if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                    {
                        fPOSExists = true;
                        break;
                    }
                }
                if ( !fPOSExists )
                {
                    //--- Need to do this the last time, to make sure we hit the default code below...
                    //--- RAID 5078
                    hr = SPERR_NOT_IN_LEX;
                    if ( SPList.pvBuffer )
                    {
                        ::CoTaskMemFree( SPList.pvBuffer );
                        ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                    }
                }
            }
            //--- Handle empty pronunciation
            else if ( !SPList.pFirstWordPronunciation )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
                hr = SPERR_NOT_IN_LEX;
            }
        }
    }
        
    //--- Default case - just look up orthography and go with first match.
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_USER, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }            
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_APP, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_PRIVATE1, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_pMorphLexicon->DoSuffixMorph( pPron->orthStr, pPron->lemmaStr, 1033, 
                                             dwFlags, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_PRIVATE2, &SPList );

        //--- Make all LTS words Nouns...
        for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation; 
              pPronunciation = pPronunciation->pNextWordPronunciation )
        {
            pPronunciation->ePartOfSpeech = SPPS_Noun;
        }
    }

    if (SUCCEEDED(hr))
    {
        //--- WARNING - this assumes pronunciations will only come from one type of lexicon, an assumption
        //---   which was true as of July, 2000
        pPron->pronType = SPList.pFirstWordPronunciation->eLexiconType;

        //------------------------------------------------------------
        // SAPI unrolls pronunciations from their POS.
        // So roll them back into the original collapsed array 
        // of one or two candidates with sorted POS (argh...)
        //------------------------------------------------------------
        SPWORDPRONUNCIATION 	*firstPron, *pCurPron, *pNextPron;
        
        //------------------------------------------
        // Init  pronunciation A
        //------------------------------------------
        pCurPron = firstPron = SPList.pFirstWordPronunciation;
        pPron->pronArray[PRON_A].POScount = 1;
        //----------------------------
        // Get phoneme length
        //----------------------------
        cPhonLen = wcslen( firstPron->szPronunciation ) + 1;	// include delimiter
        //----------------------------
        // Clip phoneme string to max  
        //----------------------------
        if( cPhonLen > SP_MAX_PRON_LENGTH )
        {
            cPhonLen = SP_MAX_PRON_LENGTH;
        }
        //----------------------------
        // Copy unicode phoneme string
        //----------------------------
        memcpy( pPron->pronArray[PRON_A].phon_Str, firstPron->szPronunciation, cPhonLen * sizeof(WCHAR) );
        pPron->pronArray[PRON_A].phon_Len = cPhonLen -1;		// minus delimiter
        pPron->pronArray[PRON_A].POScode[0] = (ENGPARTOFSPEECH)firstPron->ePartOfSpeech; 
        
        //------------------------------------------
        // Init  pronunciation B
        //------------------------------------------
        pPron->pronArray[PRON_B].POScount = 0;
        pPron->pronArray[PRON_B].phon_Len = 0;

        pNextPron = pCurPron->pNextWordPronunciation;
        
        while( pNextPron )
        {
            int 	isDiff;
            
            isDiff = wcscmp( firstPron->szPronunciation, pNextPron->szPronunciation );
            if( isDiff )
            {
                //------------------------------------------------
                // Next pronunciation is different from 1st
                //------------------------------------------------
                if( pPron->pronArray[PRON_B].POScount < POS_MAX )
                {
                    //---------------------------------------
                    // Gather POS B into array
                    //---------------------------------------
                    pPron->pronArray[PRON_B].POScode[pPron->pronArray[PRON_B].POScount] = 
                        (ENGPARTOFSPEECH)pNextPron->ePartOfSpeech;
                    pPron->pronArray[PRON_B].POScount++;
                    if( pPron->pronArray[PRON_B].phon_Len == 0 )
                    {
                        //-----------------------------------------
                        // If there's no B pron yet, make one
                        //-----------------------------------------
                        cPhonLen = wcslen( pNextPron->szPronunciation ) + 1;	// include delimiter
                        //----------------------------
                        // Clip phoneme string to max
                        //----------------------------
                        if( cPhonLen > SP_MAX_PRON_LENGTH )
                        {
                            cPhonLen = SP_MAX_PRON_LENGTH;
                        }
                        //----------------------------
                        // Copy unicode phoneme string
                        //----------------------------
                        memcpy( pPron->pronArray[PRON_B].phon_Str, 
                            pNextPron->szPronunciation, 
                            cPhonLen * sizeof(WCHAR) );
                        pPron->pronArray[PRON_B].phon_Len = cPhonLen -1;		// minus delimiter
                        pPron->hasAlt = true;
                    } 
                }
            }
            else
            {
                //------------------------------------------------
                // Next pronunciation is same as 1st
                //------------------------------------------------
                if( pPron->pronArray[PRON_A].POScount < POS_MAX )
                {
                    //---------------------------------------
                    // Gather POS A into array
                    //---------------------------------------
                    pPron->pronArray[PRON_A].POScode[pPron->pronArray[PRON_A].POScount] = 
                        (ENGPARTOFSPEECH)pNextPron->ePartOfSpeech;
                    pPron->pronArray[PRON_A].POScount++;
                }
            }
            pCurPron = pNextPron;
            pNextPron = pCurPron->pNextWordPronunciation;
        }
    }

    //--- If XML POS provided, set selection now as it won't be touched by the POS Tagger
    if ( pPron->XMLPartOfSpeech != MS_Unknown )
    {
        BOOL fMadeMatch = false;

        //--- Check first pronunciation
        for ( ULONG i = 0; i < pPron->pronArray[0].POScount; i++ )
        {
            if ( pPron->pronArray[0].POScode[i] == pPron->XMLPartOfSpeech )
            {
                pPron->altChoice = 0;
                pPron->POSchoice = pPron->XMLPartOfSpeech;
                fMadeMatch = true;
            }
        }

        //--- Check second pronunciation
        if ( pPron->hasAlt )
        {
            for ( ULONG i = 0; i < pPron->pronArray[1].POScount; i++ )
            {
                if ( pPron->pronArray[1].POScode[i] == pPron->XMLPartOfSpeech )
                {
                    pPron->altChoice = 1;
                    pPron->POSchoice = pPron->XMLPartOfSpeech;
                    fMadeMatch = true;
                }
            }
        }

        //--- If this POS didn't exist for the word, let POS Tagger do its thing
        //--- to determine a pronunciation, and then reassign the POS later...
        if ( !fMadeMatch )
        {
            pPron->XMLPartOfSpeech = MS_Unknown;
            pPron->POSchoice       = pPron->pronArray[PRON_A].POScode[0];
        }
    }
    //--- Set default POS, for later refinement by POS Tagger
    else
    {
        pPron->POSchoice = pPron->pronArray[PRON_A].POScode[0];
        pPron->altChoice = PRON_A;
    }

    if( SPList.pvBuffer )
    {
        ::CoTaskMemFree( SPList.pvBuffer );
    }

    return hr;
} /* Pronounce */

/*****************************************************************************
* CStdSentEnum::DetermineProns *
*------------------------------*
*   Description:
* 	  This method determines POS and looks up the pronounciation
********************************************************************* MC ****/
HRESULT CStdSentEnum::DetermineProns( CItemList& ItemList, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::DetermineProns" );
    HRESULT hr = S_OK;
    ULONG cNumOfProns, cPronIndex;
    PRONRECORD*	  pProns = NULL;

    //--- Count the total number of pronunciations needed
    cNumOfProns = 0;
    SPLISTPOS ListPos = ItemList.GetHeadPosition();
    while( ListPos )
    {
        TTSSentItem& Item = ItemList.GetNext( ListPos );
        for ( ULONG i = 0; i < Item.ulNumWords; i++ )
        {
            if( Item.Words[i].pWordText &&
                ( Item.Words[i].pXmlState->eAction == SPVA_Speak || 
                  Item.Words[i].pXmlState->eAction == SPVA_SpellOut || 
                  Item.Words[i].pXmlState->eAction == SPVA_Pronounce ) )
            {
                ++cNumOfProns;
            }
        }
    }

    if ( cNumOfProns )
    {
        pProns = new PRONRECORD[cNumOfProns];

        if( !pProns )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //--- First, get item pronunciation(s)
            ZeroMemory( pProns, cNumOfProns * sizeof(PRONRECORD) );
            cPronIndex = 0;
            ListPos = ItemList.GetHeadPosition();

            //--- Iterate through ItemList
            while( ListPos && SUCCEEDED( hr ) )
            {
                TTSSentItem& Item = ItemList.GetNext( ListPos );
                //--- Iterate over Words
                for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                {
                    //--- Get pronunciations and parts of speech for spoken items only
                    if ( Item.Words[i].pWordText && 
                         ( Item.Words[i].pXmlState->eAction == SPVA_Speak ||
                           Item.Words[i].pXmlState->eAction == SPVA_SpellOut ||
                           Item.Words[i].pXmlState->eAction == SPVA_Pronounce ) )
                    {
                        SPDBG_ASSERT( cPronIndex < cNumOfProns );
                        ULONG cItemLen = Item.Words[i].ulWordLen;
                        //--- Clip at max text length
                        if( cItemLen > ( SP_MAX_WORD_LENGTH-1 ) )
                        {
                            cItemLen = SP_MAX_WORD_LENGTH - 1;
                        }
                        //--- Copy item text
                        memcpy( pProns[cPronIndex].orthStr, 
                                Item.Words[i].pWordText, 
                                cItemLen * sizeof(WCHAR) );
                        pProns[cPronIndex].orthStr[cItemLen] = 0;
                        //--- Set Part of Speech, if given in XML
                        if ( Item.Words[i].pXmlState->ePartOfSpeech != MS_Unknown )
                        {
                            pProns[cPronIndex].XMLPartOfSpeech = (ENGPARTOFSPEECH)Item.Words[i].pXmlState->ePartOfSpeech;
                        }
                        //--- Do Lex Lookup, if necessary
                        if ( Item.Words[i].pXmlState->pPhoneIds == NULL || 
                             Item.Words[i].pXmlState->ePartOfSpeech == MS_Unknown )
                        {
                            //--- Special Case - Disambiguate Abbreviations
                            if ( Item.pItemInfo->Type == eABBREVIATION ||
                                 Item.pItemInfo->Type == eABBREVIATION_NORMALIZE )
                            {
                                const AbbrevRecord *pAbbrevInfo = 
                                    ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation;
                                if ( pAbbrevInfo->iPronDisambig < 0 )
                                {
                                    //--- Default case - just take the first (and only) pronunciation
                                    pProns[cPronIndex].pronArray[PRON_A].POScount   = 1;
                                    wcscpy( pProns[cPronIndex].pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                                    pProns[cPronIndex].pronArray[PRON_A].phon_Len   = 
                                        wcslen( pProns[cPronIndex].pronArray[PRON_A].phon_Str );
                                    pProns[cPronIndex].pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                                    pProns[cPronIndex].pronArray[PRON_B].POScount   = 0;
                                    pProns[cPronIndex].pronArray[PRON_B].phon_Len   = 0;
                                    pProns[cPronIndex].hasAlt                       = false;
                                    pProns[cPronIndex].altChoice                    = PRON_A;
                                    pProns[cPronIndex].POSchoice                    = pAbbrevInfo->POS1;
                                    //--- Abbreviation table prons are basically just vendor lex prons...
                                    pProns[cPronIndex].pronType                     = eLEXTYPE_PRIVATE1;
                                }
                                else
                                {
                                    hr = ( this->*g_PronDisambigTable[pAbbrevInfo->iPronDisambig] )
                                                ( pAbbrevInfo, &pProns[cPronIndex], ItemList, ListPos ); 
                                }
								pProns[cPronIndex].fUsePron = true;
                            }
                            //--- Default case
                            else
                            {
                                //--- Check disambiguation list
                                const AbbrevRecord* pAbbrevRecord = 
                                    (AbbrevRecord*) bsearch( (void*) pProns[cPronIndex].orthStr, (void*) g_AmbiguousWordTable,
                                                             sp_countof( g_AmbiguousWordTable ), sizeof( AbbrevRecord ),
                                                             CompareStringAndAbbrevRecord );
                                if ( pAbbrevRecord )
                                {
                                    hr = ( this->*g_AmbiguousWordDisambigTable[pAbbrevRecord->iPronDisambig] )
                                                ( pAbbrevRecord, &pProns[cPronIndex], ItemList, ListPos );
                                    pProns[cPronIndex].fUsePron = true;
                                }
                                //--- Do Lex Lookup, if necessary
                                else
                                {
                                    hr = Pronounce( &pProns[cPronIndex] );
                                }
                            }
                        }
                        cPronIndex++;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                //--- Next, disambiguate part-of-speech
                DisambiguatePOS( pProns, cNumOfProns );

                //--- Output debugging information
                TTSDBG_LOGPOSPOSSIBILITIES( pProns, cNumOfProns, STREAM_POSPOSSIBILITIES );

                //--- Finally, copy selected pronunciation to 'ItemList'
                PRONUNIT *selectedUnit;
                cPronIndex = 0;
                ListPos = ItemList.GetHeadPosition();

                while( ListPos && SUCCEEDED(hr) )
                {
                    TTSSentItem& Item = ItemList.GetNext( ListPos );
                    for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                    {
                        //--- Set pronunciation and part-of-speech for spoken items only
                        if( Item.Words[i].pWordText &&
                            ( Item.Words[i].pXmlState->eAction == SPVA_Speak || 
                              Item.Words[i].pXmlState->eAction == SPVA_SpellOut ||
                              Item.Words[i].pXmlState->eAction == SPVA_Pronounce ) )
                        {
                            SPDBG_ASSERT( cPronIndex < cNumOfProns );
                            //--- Use XML specified pronunciation, if given.
                            if ( Item.Words[i].pXmlState->pPhoneIds )
                            {
                                Item.Words[i].pWordPron = Item.Words[i].pXmlState->pPhoneIds;
                            }
                            else
                            {
                                selectedUnit = &pProns[cPronIndex].pronArray[pProns[cPronIndex].altChoice];
                                Item.Words[i].pWordPron =
                                    (SPPHONEID*) MemoryManager.GetMemory( (selectedUnit->phon_Len + 1) * 
                                                                          sizeof(SPPHONEID), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    wcscpy( Item.Words[i].pWordPron, selectedUnit->phon_Str );
                                }
                            }

                            //--- Use XML specified part-of-speech, if given.  This will override the case
                            //--- where the POS didn't exist as an option and the POS Tagger did its thing
                            //--- to find a pronunciation.
                            if ( Item.Words[i].pXmlState->ePartOfSpeech != MS_Unknown )
                            {
                                Item.Words[i].eWordPartOfSpeech = (ENGPARTOFSPEECH)Item.Words[i].pXmlState->ePartOfSpeech;
                            }
                            else
                            {
                                Item.Words[i].eWordPartOfSpeech = pProns[cPronIndex].POSchoice;
                            }

                            //--- Root word
                            if ( pProns[cPronIndex].lemmaStr[0] )
                            {
                                Item.Words[i].ulLemmaLen = wcslen( pProns[cPronIndex].lemmaStr );
                                Item.Words[i].pLemma = 
                                    (WCHAR*) MemoryManager.GetMemory( Item.Words[i].ulLemmaLen * sizeof(WCHAR), &hr );
                                if ( SUCCEEDED( hr ) )
                                {                               
                                    wcsncpy( (WCHAR*) Item.Words[i].pLemma, pProns[cPronIndex].lemmaStr,
                                             Item.Words[i].ulLemmaLen );
                                }
                            }

                            //--- Insert pron in text, if appropriate - RAID #4746
                            if ( pProns[cPronIndex].fUsePron )
                            {
                                ULONG ulNumChars = wcslen( Item.Words[i].pWordPron );
                                Item.Words[i].pWordText = 
                                    (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    ZeroMemory( (WCHAR*) Item.Words[i].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                                    (WCHAR) Item.Words[i].pWordText[0] = L'*';
                                    wcscpy( ( (WCHAR*) Item.Words[i].pWordText + 1 ), Item.Words[i].pWordPron );
                                    (WCHAR) Item.Words[i].pWordText[ ulNumChars + 1 ] = L'*';
									Item.Words[i].ulWordLen = ulNumChars + 2;
                                }
                            }

                            cPronIndex++;
                        }
                    }
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                //--- Check Post POS disambiguation list
                SPLISTPOS ListPos = ItemList.GetHeadPosition();
                while ( ListPos && SUCCEEDED( hr ) )
                {
                    TTSSentItem& Item = ItemList.GetNext( ListPos );
                    if ( Item.pItemInfo->Type == eALPHA_WORD ||
                         Item.pItemInfo->Type == eABBREVIATION ||
                         Item.pItemInfo->Type == eABBREVIATION_NORMALIZE )
                    {
                        WCHAR temp;
                        BOOL fPeriod = false;
                        if ( Item.pItemSrcText[Item.ulItemSrcLen - 1] == L'.' &&
                             Item.ulItemSrcLen > 1 )
                        {
                            temp = Item.pItemSrcText[Item.ulItemSrcLen - 1];
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen - 1 ) = 0;
                            fPeriod = true;
                        }
                        else
                        {
                            temp = Item.pItemSrcText[Item.ulItemSrcLen];
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen ) = 0;
                        }

                        const AbbrevRecord* pAbbrevRecord =
                            (AbbrevRecord*) bsearch( (void*) Item.pItemSrcText, (void*) g_PostLexLookupWordTable,
                                                     sp_countof( g_PostLexLookupWordTable ), sizeof( AbbrevRecord ),
                                                     CompareStringAndAbbrevRecord );
                        if ( pAbbrevRecord )
                        {
                            hr = ( this->*g_PostLexLookupDisambigTable[pAbbrevRecord->iPronDisambig] )
                                        ( pAbbrevRecord, ItemList, ListPos, MemoryManager );
                        }
                
                        if ( fPeriod )
                        {
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen - 1 ) = temp;
                        }
                        else
                        {
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen ) = temp;
                        }
                    }
                }
            }
        }
    }
    
    if (pProns)
    {
        delete [] pProns;
    }

    return hr;
} /* CStdSentEnum::DetermineProns */

/***********************************************************************************************
* MeasurementDisambig *
*---------------------*
*   Description:
*       This overrides initial pronunciations of measurement abbreviations when they are used
*   as modifiers - e.g. "a 7 ft. pole" vs. "the pole was 7 ft. long"
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::MeasurementDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                           SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::MeasurementDisambig" );
    HRESULT hr = S_OK;

    //--- Get previous two items
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                TTSSentItem TempItem = ItemList.GetPrev( TempPos );
                //--- Previous must be a number
                if ( TempItem.pItemInfo->Type == eNUM_CARDINAL )
                {
                    //--- Get next item
                    TempPos = ListPos;
                    TempItem = ItemList.GetNext( TempPos );
                    //--- Next must be a noun or adj
                    if ( TempItem.eItemPartOfSpeech == MS_Noun )
                    {
                        //--- Matched a 7 ft. pole type example - go with singular
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& MeasurementItem = ItemList.GetPrev( TempPos );
                        //--- Singular will always be shorter than plural, so this should never overwrite
                        //---   anything...
                        wcscpy( MeasurementItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( MeasurementItem.Words[0].pWordPron );
                        MeasurementItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) MeasurementItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) MeasurementItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) MeasurementItem.Words[0].pWordText + 1 ), MeasurementItem.Words[0].pWordPron );
                            (WCHAR) MeasurementItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							MeasurementItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                    else if ( TempItem.eItemPartOfSpeech == MS_Adj &&
                              TempPos )
                    {
                        //--- Next must be a noun
                        TempItem = ItemList.GetNext( TempPos );
                        {
                            if ( TempItem.eItemPartOfSpeech == MS_Noun )
                            {
                                //--- Matched a 7 ft. pole type example - go with singular
                                TempPos = ListPos;
                                ItemList.GetPrev( TempPos );
                                TTSSentItem& MeasurementItem = ItemList.GetPrev( TempPos );
                                //--- Singular will always be shorter than plural, so this should never overwrite
                                //---   anything...
                                wcscpy( MeasurementItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );

                                //--- Insert pron into word text - RAID #4746
                                ULONG ulNumChars = wcslen( MeasurementItem.Words[0].pWordPron );
                                MeasurementItem.Words[0].pWordText = 
                                    (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    ZeroMemory( (WCHAR*) MeasurementItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                                    (WCHAR) MeasurementItem.Words[0].pWordText[0] = L'*';
                                    wcscpy( ( (WCHAR*) MeasurementItem.Words[0].pWordText + 1 ), MeasurementItem.Words[0].pWordPron );
                                    (WCHAR) MeasurementItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
									MeasurementItem.Words[0].ulWordLen = ulNumChars + 2;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
} /* MeasurementDisambig */

/***********************************************************************************************
* TheDisambig *
*-------------*
*   Description:
*       This function disambiguates the word the - before a vowel it becomes "thee", before a
*   consonant it is "thuh"...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::TheDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                   SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::TheDisambig" );
    HRESULT hr = S_OK;

    //--- Get next item
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        TTSSentItem NextItem = ItemList.GetNext( TempPos );

        if ( NextItem.Words[0].pWordPron &&
             bsearch( (void*) NextItem.Words[0].pWordPron, (void*) g_Vowels, sp_countof( g_Vowels ), 
                      sizeof( WCHAR ), CompareWCHARAndWCHAR ) )
        {
            //--- Matched a vowel - go with / DH IY 1 /
            TempPos = ListPos;
            ItemList.GetPrev( TempPos );
            TTSSentItem& TheItem = ItemList.GetPrev( TempPos );
            //--- The two pronunciations are exactly the same length, so this should never overwrite
            //---   anything
            wcscpy( TheItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
            TheItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
            //--- Insert pron into word text - RAID #4746
            ULONG ulNumChars = wcslen( TheItem.Words[0].pWordPron );
            TheItem.Words[0].pWordText = 
                (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( (WCHAR*) TheItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                (WCHAR) TheItem.Words[0].pWordText[0] = L'*';
                wcscpy( ( (WCHAR*) TheItem.Words[0].pWordText + 1 ), TheItem.Words[0].pWordPron );
                (WCHAR) TheItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
				TheItem.Words[0].ulWordLen = ulNumChars + 2;
            }
        }
        else
        {
            //--- Didn't match a vowel - go with / DH AX 1 /
            TempPos = ListPos;
            ItemList.GetPrev( TempPos );
            TTSSentItem& TheItem = ItemList.GetPrev( TempPos );
            //--- The two pronunciations are exactly the same length, so this should never overwrite
            //---   anything
            wcscpy( TheItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
            TheItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
            //--- Insert pron into word text - RAID #4746
            ULONG ulNumChars = wcslen( TheItem.Words[0].pWordPron );
            TheItem.Words[0].pWordText = 
                (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( (WCHAR*) TheItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                (WCHAR) TheItem.Words[0].pWordText[0] = L'*';
                wcscpy( ( (WCHAR*) TheItem.Words[0].pWordText + 1 ), TheItem.Words[0].pWordPron );
                (WCHAR) TheItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
				TheItem.Words[0].ulWordLen = ulNumChars + 2;
            }
        }
    }

    return hr;
} /* TheDisambig */

/***********************************************************************************************
* ADisambig *
*-----------*
*   Description:
*       This function disambiguates the word "a" - / EY 1 - Noun / vs. / AX - Det /
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ADisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, CItemList& ItemList, 
                                 SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::ADisambig" );
    HRESULT hr = S_OK;
    BOOL fNoun = false;

    //--- Get Current Item...
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            TTSSentItem CurrentItem = ItemList.GetPrev( TempPos );

            //--- If "a" is part of a multi-word item, use the Noun pronunciation...
            //--- If "a" is not an AlphaWord, use the Noun pronunciation...
            if ( CurrentItem.ulNumWords > 1 ||
                 CurrentItem.pItemInfo->Type != eALPHA_WORD )
            {
                fNoun = true;
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
        }
    }

    if ( !fNoun )
    {
        //--- Get Next Item...
        TempPos = ListPos;
        if ( TempPos )
        {
            TTSSentItem NextItem = ItemList.GetNext( TempPos );

            //--- If "a" is followed by punctuation, use the Noun pronunciation...
            if ( !( NextItem.pItemInfo->Type & eWORDLIST_IS_VALID ) )
            {
                fNoun = true;
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
        }
    }

    //--- Default - use the Determiner pronunciation (but include Noun pronunciation as well,
    //---   so that POS tagger rules will work properly)...
    if ( !fNoun )
    {
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->pronArray[PRON_A].POScount   = 1;
        pPron->POSchoice                    = pAbbrevInfo->POS2;
        wcscpy( pPron->pronArray[PRON_B].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_B].phon_Len   = wcslen( pPron->pronArray[PRON_B].phon_Str );
        pPron->pronArray[PRON_B].POScode[0] = pAbbrevInfo->POS1;
        pPron->pronArray[PRON_B].POScount   = 1;
        pPron->hasAlt = true;
    }

    return hr;
} /* ADisambig */

/***********************************************************************************************
* PolishDisambig *
*----------------*
*   Description:
*       This function disambiguates the word "polish" - [p ow 1 l - ax sh - Noun] vs.
*   [p ow 1 l - ax sh - Adj] vs. [p aa 1 l - ih sh - Verb] vs. [p aa 1 l - ih sh - Noun]
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::PolishDisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, CItemList& ItemList, 
                                      SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::PolishDisambig" );
    HRESULT hr = S_OK;
    BOOL fMatch = false;

    //--- Get Current Item...
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            TTSSentItem CurrentItem = ItemList.GetPrev( TempPos );

            //--- If "Polish" is capitalized and not sentence-initial, and not preceded immediately
            //--- by an open double-quote or parenthesis, use Noun...
            if ( iswupper( CurrentItem.pItemSrcText[0] ) )
            {
                BOOL fSentenceInitial = false;
                if ( !TempPos )
                {
                    fSentenceInitial = true;
                }
                else
                {
                    TTSSentItem PrevItem = ItemList.GetPrev( TempPos );
                    if ( PrevItem.pItemInfo->Type == eOPEN_PARENTHESIS ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACKET     ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACE       ||
                         PrevItem.pItemInfo->Type == eSINGLE_QUOTE     ||
                         PrevItem.pItemInfo->Type == eDOUBLE_QUOTE )
                    {
                        fSentenceInitial = true;
                    }
                }
                if ( fSentenceInitial )
                {
                    fMatch = true;
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;
                }
                else
                {
                    fMatch = true;
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = MS_Noun;
                    pPron->POSchoice                    = MS_Noun;
                }
            }
        }
    }

    //--- Default - use the Verb pronunciation (but include the others as well,
    //---   so that POS tagger rules will work properly)...
    if ( !fMatch )
    {
        //--- Verb, Noun
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->pronArray[PRON_A].POScode[1] = pAbbrevInfo->POS3;
        pPron->pronArray[PRON_A].POScount   = 2;
        //--- Adj
        wcscpy( pPron->pronArray[PRON_B].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_B].phon_Len   = wcslen( pPron->pronArray[PRON_B].phon_Str );
        pPron->pronArray[PRON_B].POScode[0] = pAbbrevInfo->POS1;
        pPron->pronArray[PRON_B].POScount   = 1;
        //--- Set initial choice to Verb...
        pPron->POSchoice                    = pAbbrevInfo->POS2;
        pPron->hasAlt = true;
    }

    return hr;
} /* PolishDisambig */

/***********************************************************************************************
* ReadDisambig *
*--------------*
*   Description:
*       This function disambiguates the word Read - past tense vs. present...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ReadDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                    SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::ReadDisambig" );
    HRESULT hr = S_OK;
    BOOL fMatch = false;

    //--- Get prev item
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                TTSSentItem PrevItem = ItemList.GetPrev( TempPos );

                //--- Check for closest auxiliary
                while ( PrevItem.Words[0].eWordPartOfSpeech != MS_VAux  &&
                        PrevItem.Words[0].eWordPartOfSpeech != MS_Contr &&
                        TempPos )
                {
                    PrevItem = ItemList.GetPrev( TempPos );
                }

                if ( PrevItem.Words[0].eWordPartOfSpeech == MS_VAux )
                {
                    fMatch = true;
                    if ( wcsnicmp( PrevItem.Words[0].pWordText, L"have", 4 )    == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"has", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"had", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"am", 2 )      == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"ain't", 5 )   == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"are", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"aren't", 6 )  == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"be", 2 )      == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"is", 2 )      == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"was", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"were", 4 )    == 0 )
                    {
                        //--- Matched have or haven't (has or hasn't, had or hadn't) - go with "red"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        //--- The two pronunciations are exactly the same length, so this should never overwrite
                        //---   anything
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS2;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                    else
                    {
                        //--- Some other auxiliary - go with "reed"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        //--- The two pronunciations are exactly the same length, so this should never overwrite
                        //---   anything
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                }
                //--- Check for pronoun aux contractions
                else if ( PrevItem.Words[0].eWordPartOfSpeech == MS_Contr )
                {
                    fMatch = true;
                    const WCHAR *pApostrophe = wcsstr( PrevItem.Words[0].pWordText, L"'" );
                    if ( pApostrophe &&
                         wcsnicmp( pApostrophe, L"'ll", 3 ) == 0 )
                    {
                        //--- Matched an 'll form - go with "reed"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                    else
                    {
                        //--- Some other form - go with "red"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS2;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                }
                //--- Check for infinitival form
                else 
                {
                    TempPos = ListPos;
                    ItemList.GetPrev( TempPos );
                    ItemList.GetPrev( TempPos );
                    PrevItem = ItemList.GetPrev( TempPos );

                    if ( PrevItem.Words[0].ulWordLen == 2 &&
                         wcsnicmp( PrevItem.Words[0].pWordText, L"to", 2 ) == 0 )
                    {
                        fMatch = true;

                        //--- Matched infinitival form - go with "reed"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                }
            }
            //--- Sentence initial - go with "reed"
            else
            {
                fMatch = true;

                TempPos = ListPos;
                ItemList.GetPrev( TempPos );
                TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                //--- Insert pron into word text - RAID #4746
                ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                ReadItem.Words[0].pWordText = 
                    (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                    (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                    wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                    (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
					ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                }
            }
        }
    }

    if ( !fMatch )
    {
        TempPos = ListPos;
        ItemList.GetPrev( TempPos );
        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
        //--- Default - go with past tense...
        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS2;

        //--- Insert pron into word text - RAID #4746
        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
        ReadItem.Words[0].pWordText = 
            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
			ReadItem.Words[0].ulWordLen = ulNumChars + 2;
        }
    }

    return hr;
} /* ReadDisambig */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\duration.cpp ===
/******************************************************************************
* Duration.cpp *
*--------------*
*
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 04/28/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

//--- Additional includes
#include "stdafx.h"

#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif



//-----------------------------
// Data.cpp
//-----------------------------
extern const unsigned long    g_AlloFlags[];
extern const float  g_BoundryDurTbl[];
extern const float  g_BoundryStretchTbl[];





/*****************************************************************************
* CDuration::Pause_Insertion *
*----------------------------*
*   Description:
*   Duration Rule #1 - Pause Insertion
*       
********************************************************************** MC ***/
void CDuration::Pause_Insertion( long userDuration, long silBreak )
{
    SPDBG_FUNC( "CDuration::Pause_Insertion" );

    if( userDuration )
    {
        m_DurHold = ((float)userDuration / 1000);
        m_TotalDurScale = 1.0;
    }
    else if( silBreak )
    {
        m_DurHold = ((float)silBreak / 1000);
    }
    else
    {
        if( m_CurBoundary != NULL_BOUNDARY)
        {
            m_DurHold = g_BoundryDurTbl[(long)m_CurBoundary];
			//m_DurHold *= m_TotalDurScale;

			//----------------------------
			// Clip to limits
			//----------------------------
			if( m_DurHold > MAX_SIL_DUR )
			{
				m_DurHold = MAX_SIL_DUR;
			}
			/*else if( m_DurHold < MIN_ALLO_DUR )
			{
				m_DurHold = MIN_ALLO_DUR;
			}*/
        }
    }

} /* CDuration::Pause_Insertion */





/*****************************************************************************
* CDuration::PhraseFinal_Lengthen *
*---------------------------------*
*   Description:
*   Duration Rule #2 - Phrase-final Lengthening
*       
********************************************************************** MC ***/
void CDuration::PhraseFinal_Lengthen( long /*cellCount*/ )
{
    SPDBG_FUNC( "CDuration::PhraseFinal_Lengthen" );
	float		stretchGain;

    if( m_cur_SyllableType & TERM_END_SYLL)
    {
    
    
        if( (m_cur_Stress) && (m_cur_VowelFlag) )
        {
            stretchGain = g_BoundryStretchTbl[(long)m_NextBoundary];
			m_DurHold *= stretchGain;

			//----------------------------
			// Clip to limits
			//----------------------------
			if( m_DurHold > MAX_ALLO_DUR )
			{
				m_DurHold = MAX_ALLO_DUR;
			}
			else if( m_DurHold < MIN_ALLO_DUR )
			{
				m_DurHold = MIN_ALLO_DUR;
			}
        }
    }
} /* CDuration::PhraseFinal_Lengthen */


#define		EMPH_VOWEL_GAIN	1.0f
#define		EMPH_CONS_GAIN	1.25f
#define		EMPH_VOWEL_MIN	0.060f
#define		EMPH_CONS_MIN	0.020f
#define		EMPH_MIN_DUR	0.150f

/*****************************************************************************
* CDuration::Emphatic_Lenghen *
*-----------------------------*
*   Description:
*   Duration Rule #8 - Lengthening for emphasis
*       
********************************************************************** MC ***/
long CDuration::Emphatic_Lenghen( long lastStress )
{
    SPDBG_FUNC( "CDuration::Emphatic_Lenghen" );

    long            eFlag;
	bool			isEmph;

    eFlag = lastStress;
	if( m_cur_Stress & EMPHATIC_STRESS )
	{
		isEmph = true;
	}
	else
	{
		isEmph = false;
	}

    if( (m_cur_PhonCtrl & WORD_INITIAL_CONSONANT) || 
        ( m_cur_VowelFlag && (!isEmph)) )
    {
        eFlag = false;          // start of a new word OR non-emph vowel    
    }
    
    if( isEmph )
    {
        eFlag = true;           // continue lengthening until above condition is met    
    }
    
    if( eFlag )
    {
		

		/*if( m_DurHold < EMPH_MIN_DUR )
		{
			m_durationPad += EMPH_MIN_DUR - m_DurHold;
		}*/

		float		durDiff;
        if( m_cur_VowelFlag)
        {
			durDiff = (m_DurHold * EMPH_VOWEL_GAIN) - m_DurHold;
			if( durDiff <  EMPH_VOWEL_MIN )
			{
				durDiff = EMPH_VOWEL_MIN;
			}
        }
        else
        {
			durDiff = (m_DurHold * EMPH_CONS_GAIN) - m_DurHold;
			if( durDiff <  EMPH_CONS_MIN )
			{
				durDiff = EMPH_CONS_MIN;
			}
        }
		m_durationPad += durDiff;    // lengthen phon for emph    
    }

    return eFlag;
} /* CDuration::Emphatic_Lenghen */





/*****************************************************************************
* CDuration::AlloDuration *
*-------------------------*
*   Description:
*   Calculate durations
*       
********************************************************************** MC ***/
void CDuration::AlloDuration( CAlloList *pAllos, float rateRatio )
{
    SPDBG_FUNC( "CDuration::AlloDuration" );

    
    long        eFlag;
    CAlloCell   *pPrevCell, *pCurCell, *pNextCell, *pNext2Cell;
    long        numOfCells;
    long        userDuration, silBreak;
    
    numOfCells = pAllos->GetCount();

    if( numOfCells > 0 )
    {
        eFlag   = false;
		//------------------------------
		// Fill the pipeline
		//------------------------------
		pPrevCell = pAllos->GetHeadCell();
		pCurCell = pAllos->GetNextCell();
		pNextCell = pAllos->GetNextCell();
		pNext2Cell = pAllos->GetNextCell();

		//------------------------------
		// 1st allo is always SIL
		//------------------------------
        pPrevCell->m_ftDuration = pPrevCell->m_UnitDur = PITCH_BUF_RES;           // initial SIL    
		while( pCurCell )
        {
            //------------------
            // Current  
            //------------------
            m_cur_Phon = pCurCell->m_allo;
            m_cur_PhonCtrl = pCurCell->m_ctrlFlags;
            m_cur_SyllableType = m_cur_PhonCtrl & SYLLABLE_TYPE_FIELD;
            m_cur_Stress = m_cur_PhonCtrl & STRESS_FIELD;
            m_cur_PhonFlags = ::g_AlloFlags[m_cur_Phon];
            userDuration = pCurCell->m_user_Break;
            silBreak = pCurCell->m_Sil_Break;
            if( m_cur_PhonFlags & KVOWELF)
            {
                m_cur_VowelFlag = true;
            }
            else
            {
                m_cur_VowelFlag = false;
            }
            m_CurBoundary = pCurCell->m_TuneBoundaryType;
            m_NextBoundary = pCurCell->m_NextTuneBoundaryType;
            m_TotalDurScale = rateRatio * pCurCell->m_DurScale * pCurCell->m_ProsodyDurScale;
			m_DurHold = pCurCell->m_UnitDur;
			m_durationPad = 0;

			if( pCurCell->m_user_Emph > 0 )
			{
				m_cur_Stress |= EMPHATIC_STRESS;
			}
        
            //------------------
            // Prev  
            //------------------
            m_prev_Phon = pPrevCell->m_allo;
            m_prev_PhonCtrl = pPrevCell->m_ctrlFlags;
            m_prev_PhonFlags = ::g_AlloFlags[m_prev_Phon];
        
            //------------------
            // Next
            //------------------
            if( pNextCell )
            {
                m_next_Phon = pNextCell->m_allo;
                m_next_PhonCtrl = pNextCell->m_ctrlFlags;
            }
            else
            {
                m_next_Phon = _SIL_;
                m_next_PhonCtrl = 0;
            }
            m_next_PhonFlags = ::g_AlloFlags[m_next_Phon];
        
            //------------------
            // 2 phons ahead 
            //------------------
            if( pNext2Cell )
            {
                m_next2_Phon = pNext2Cell->m_allo;
                m_next2_PhonCtrl = pNext2Cell->m_ctrlFlags;
            }
            else
            {
                m_next2_Phon = _SIL_;
                m_next2_PhonCtrl = 0;
            }
            m_next2_PhonFlags = ::g_AlloFlags[m_next2_Phon];

        
            if( m_cur_Phon == _SIL_ )
            {
                //-------------------------------------------
                // #1 - Pause Insertion  
                //-------------------------------------------
                Pause_Insertion( userDuration, silBreak );
            }
            else
            {
                //-------------------------------------------
                // #2 - Phrase-final Lengthening 
                //-------------------------------------------
                PhraseFinal_Lengthen( numOfCells );
        
                //-------------------------------------------
                // #8  Lengthening for emphasis 
                //-------------------------------------------
                eFlag = Emphatic_Lenghen( eFlag );        
   
            }
        
            pCurCell->m_ftDuration = ((m_DurHold + m_durationPad) / m_TotalDurScale);

			//---------------------------------
			// Shift the pipeline once
			//---------------------------------
			pPrevCell	= pCurCell;
			pCurCell	= pNextCell;
			pNextCell	= pNext2Cell;
			pNext2Cell	= pAllos->GetNextCell();
        }
    }
} /* CDuration::AlloDuration */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\frontend.cpp ===
/*******************************************************************************
* Frontend.cpp *
*--------------*
*   Description:
*       This module is the main implementation file for the CFrontend class.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif
#ifndef SPDebug_h
#include "spdebug.h"
#endif
#ifndef FeedChain_H
#include "FeedChain.h"
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif
#include "sapi.h"

#include "StdSentEnum.h"


//-----------------------------
// Data.cpp
//-----------------------------
extern  const short   g_IPAToAllo[];
extern const float  g_RateScale[];


/*****************************************************************************
* CFrontend::CFrontend *
*----------------------*
*   Description:
*       
********************************************************************** MC ***/
CFrontend::CFrontend()
{
    SPDBG_FUNC( "CFrontend::CFrontend" );
    m_pUnits        = NULL;
    m_unitCount     = 0;
    m_CurUnitIndex  = 0;
    m_pAllos        = NULL;   
    m_pSrcObj       = NULL;
} /* CFrontend::CFrontend */


/*****************************************************************************
* CFrontend::~CFrontend *
*-----------------------*
*   Description:
*       
********************************************************************** MC ***/
CFrontend::~CFrontend()
{
    SPDBG_FUNC( "CFrontend::~CFrontend" );

    DisposeUnits();
    if( m_pAllos )
    {
        delete m_pAllos;
        m_pAllos = NULL;
    }
    DeleteTokenList();
} /* CFrontend::~CFrontend */

/*****************************************************************************
* CFrontend::CntrlToRatio *
*-------------------------*
*   Description:
*   Return rate ratio from control
*       
********************************************************************** MC ***/
float CFrontend::CntrlToRatio( long rateControl )
{
    SPDBG_FUNC( "CFrontend::CntrlToRatio" );
    float   rateRatio;

    if( rateControl < 0 )
    {
        //--------------------------------
        // DECREASE the rate
        //--------------------------------
        if( rateControl < MIN_USER_RATE )
        {
            rateControl = MIN_USER_RATE;        // clip to min
        }
        rateRatio = 1.0f / ::g_RateScale[0 - rateControl];
    }
    else
    {
        //--------------------------------
        // INCREASE the rate
        //--------------------------------
        if( rateControl > MAX_USER_RATE )
        {
            rateControl = MAX_USER_RATE;        // clip to max
        }
        rateRatio = ::g_RateScale[rateControl];
    }

    return rateRatio;
} /* CFrontend::CntrlToRatio */



/*****************************************************************************
* CFrontend::Init *
*-----------------*
*   Description:
*   Init voice dependent variables, call once when object is created+++
*       
********************************************************************** MC ***/
HRESULT CFrontend::Init( IMSVoiceData* pVoiceDataObj, CFeedChain *pSrcObj, MSVOICEINFO* pVoiceInfo )
{
    SPDBG_FUNC( "CFrontend::Init" );
    HRESULT hr = S_OK;
    
    m_pSrcObj   = pSrcObj;
    m_BasePitch = (float)pVoiceInfo->Pitch;
    m_pVoiceDataObj = pVoiceDataObj;
    m_ProsodyGain = ((float)pVoiceInfo->ProsodyGain) / 100.0f;
    m_SampleRate = (float)pVoiceInfo->SampleRate;

    // NOTE: move these to voice data?
	// m_VoiceWPM = pVoiceInfo->Rate;
	// m_PitchRange = pVoiceInfo->PitchRange;
    m_VoiceWPM		= 180;
	m_PitchRange	= 0.40f;       // +/- 0.5 octave


    m_RateRatio_API = m_RateRatio_PROSODY = 1.0f;

    return hr;        
} /* CFrontend::Init */





static ULONG IPA_to_Allo( WCHAR* pSrc, ALLO_CODE* pDest )
{
    ULONG       iIpa, iAllo, i;
    ULONG       gotMatch;           // for debugging

    iIpa = iAllo = 0;
    while( pSrc[iIpa] > 0 )
    {
        gotMatch = false;
        //-----------------------------------------
        // ...then search for single word IPA's
        //-----------------------------------------
        for( i = 0; i < NUMBER_OF_ALLO; i++ )
        {
            if( pSrc[iIpa] == g_IPAToAllo[i] )
            {
                pDest[iAllo] = (ALLO_CODE)i;
                gotMatch = true;
                break;
            }
        }

        if( gotMatch )
        {
            iAllo++;
        }
        /*else
        {
            // Should NEVER get here. Unsupported IPA unicode!
            // Ignore it and go on.
        }*/

        //----------------------------------
        // Clip at max length
        //----------------------------------
        if( iAllo >= (SP_MAX_PRON_LENGTH-1) )
        {
            iAllo = SP_MAX_PRON_LENGTH-1;
            break;
        }
        iIpa++;
    }
    return iAllo;
}




/*****************************************************************************
* CFrontend::AlloToUnit *
*-----------------------*
*   Description:
*   Transform ALLO stream into backend UNIT stream+++
*       
********************************************************************** MC ***/
HRESULT CFrontend::AlloToUnit( CAlloList *pAllos, UNITINFO *pu )
{
    SPDBG_FUNC( "CFrontend::AlloToUnit" );
    bool		bFirstPass;
    long		msPhon, attr;
    ULONG       numOfCells;
    CAlloCell   *pCurCell, *pNextCell;
    HRESULT		hr = S_OK;
    
	bFirstPass = true;
    numOfCells = pAllos->GetCount();
	pCurCell = pAllos->GetHeadCell();    
	pNextCell = pAllos->GetNextCell();
    while( pCurCell )
    {
        //--------------------------------------
        // Get next allo ID
        //--------------------------------------
        if( pNextCell )
        {
            pu->NextAlloID = (USHORT)pNextCell->m_allo;
        }
        else
        {
            pu->NextAlloID = _SIL_;
        }

        //--------------------------------------
        // Convert to Whistler phon code
        //--------------------------------------
        attr = 0;
        if( pCurCell->m_ctrlFlags & PRIMARY_STRESS )
        {
            attr |= ALLO_IS_STRESSED;
        }
        hr = m_pVoiceDataObj->AlloToUnit( (short)pCurCell->m_allo, attr, &msPhon );
		if( FAILED(hr) )
		{
			//------------------------
			// allo ID is invalid
			//------------------------
			break;
		}
		else
		{
			pu->PhonID = msPhon;
			pu->AlloID = (USHORT)pCurCell->m_allo;
			pu->flags = 0;
			pu->AlloFeatures = 0;
			pu->ctrlFlags = pCurCell->m_ctrlFlags;
			//--------------------------------------
			// Flag WORD boundary
			//--------------------------------------
			if( pCurCell->m_ctrlFlags & WORD_START )
			{
				pu->flags |= WORD_START_FLAG;
				//----------------------------------------------
				// Remember source word position and length
				//----------------------------------------------
				pu->srcPosition = pCurCell->m_SrcPosition;
				pu->srcLen = pCurCell->m_SrcLen;
			}
        
			//----------------------------------------------------
			// Flag SENTENCE boundary on 1st displayable word
			//----------------------------------------------------
			if( bFirstPass && (pCurCell->m_SentenceLen > 0) )
			{
				bFirstPass = false;
				pu->flags |= SENT_START_FLAG;
				//----------------------------------------------
				// Remember source word position and length
				//----------------------------------------------
				pu->sentencePosition = pCurCell->m_SentencePosition;
				pu->sentenceLen = pCurCell->m_SentenceLen;
			}

			pu->nKnots      = KNOTS_PER_PHON;
			/*for( k = 0; k < pu->nKnots; k++ )
			{
				pu->pTime[k]    = pCurCell->m_ftTime[k] * m_SampleRate;
				pu->pF0[k]      = pCurCell->m_ftPitch[k];
				pu->pAmp[k]     = pu->ampRatio;
			}*/

			//----------------------------
			// Controls and events
			//----------------------------
			pu->user_Volume = pCurCell->m_user_Volume;
			pu->pBMObj = (void*)pCurCell->m_pBMObj;
			pCurCell->m_pBMObj = NULL;
        
			//----------------------------------------
			// Pass features for viseme event
			//----------------------------------------
			if( pCurCell->m_ctrlFlags & PRIMARY_STRESS )
			{
				pu->AlloFeatures |= SPVFEATURE_STRESSED;
			}
			if( pCurCell->m_ctrlFlags & EMPHATIC_STRESS )
			{
				pu->AlloFeatures |= SPVFEATURE_EMPHASIS;
			}

			pu->duration = PITCH_BUF_RES;

			pu->silenceSource = pCurCell->m_SilenceSource;
			pu++;
		}
		pCurCell = pNextCell;
		pNextCell = pAllos->GetNextCell();
	}
	return hr;
} /* CFrontend::AlloToUnit */





/*****************************************************************************
* CFrontend::PrepareSpeech *
*--------------------------*
*   Description:
*   Prepare frontend for new speech
*       
********************************************************************** MC ***/
void    CFrontend::PrepareSpeech( IEnumSpSentence* pEnumSent, ISpTTSEngineSite *pOutputSite )
{
    SPDBG_FUNC( "CFrontend::PrepareSpeech" );

    m_pEnumSent = pEnumSent;
    m_SpeechState = SPEECH_CONTINUE;
    m_CurUnitIndex = m_unitCount = 0;
	m_HasSpeech = false;
	m_pOutputSite = pOutputSite;
	m_fInQuoteProsody = m_fInParenProsody = false;
	m_CurPitchOffs = 0;
	m_CurPitchRange = 1.0;
	m_RateRatio_PROSODY = 1.0f;
} /* CFrontend::PrepareSpeech */








/*****************************************************************************
* IsTokenPunct *
*--------------*
*   Description:
*   Return TRUE if char is , . ! or ?
*       
********************************************************************** MC ***/
bool fIsPunctuation( TTSSentItem Item )
{
    SPDBG_FUNC( "IsTokenPunct" );

    return ( Item.pItemInfo->Type == eCOMMA ||
             Item.pItemInfo->Type == eSEMICOLON ||
             Item.pItemInfo->Type == eCOLON ||
             Item.pItemInfo->Type == ePERIOD ||
             Item.pItemInfo->Type == eQUESTION ||
             Item.pItemInfo->Type == eEXCLAMATION );
} /* fIsPunctuation */




/*****************************************************************************
* CFrontend::ToBISymbols *
*------------------------*
*   Description:
*   Label each word with ToBI prosody notation+++
*       
********************************************************************** MC ***/
HRESULT CFrontend::ToBISymbols()
{
    SPDBG_FUNC( "CFrontend::ToBISymbols" );
    TOBI_PHRASE    *pTPhrase; 
    long			i, cPhrases;
    PROSODY_POS		prevPOS, curPOS;
    bool			possible_YNQ = false;
    long			cTok;
    CFEToken		*pTok, *pPrevTok, *pAuxTok;
	bool			hasEmph = false;
	SPLISTPOS		listPos;


	//----------------------------------
	// Get memory for phrase array
	//----------------------------------
	pAuxTok = NULL;			// To quiet the compiler
    cTok = m_TokList.GetCount();
	if( cTok )
	{
		pTPhrase = new TOBI_PHRASE[cTok];		// worse case: each token is a phrase
		if( pTPhrase )
		{
			//---------------------------------------------
			// Find sub-phrases from POS
			// For now, detect function/content boundaries
			//---------------------------------------------
			hasEmph = false;
			cPhrases	= 0;
			i = 0;
			listPos = m_TokList.GetHeadPosition();
			pTok = m_TokList.GetNext( listPos );
			prevPOS = pTok->m_posClass;
			while( pTok->phon_Str[0] == _SIL_ )
			{
				if( i >= (cTok-1) )
				{
					break;
				}
				i++;
				if( listPos != NULL )
				{
					pTok = m_TokList.GetNext( listPos );
				}
			}
			if( pTok->m_posClass == POS_AUX ) 
			{
				//---------------------------------
				// Could be a yes/no question
				//---------------------------------
				possible_YNQ = true;
				pAuxTok = pTok;
			}       
			pTPhrase[cPhrases].start = i;
			for( ; i < cTok; i++ )
			{
				curPOS = pTok->m_posClass;
				if( (curPOS != prevPOS) && (pTok->phon_Str[0] != _SIL_) )
				{
					pTPhrase[cPhrases].posClass = prevPOS;
					pTPhrase[cPhrases].end = i-1;
					cPhrases++;
					pTPhrase[cPhrases].start = i;
					prevPOS = curPOS;
				}
				if( pTok->user_Emph > 0 )
				{
					hasEmph = true;
				}
				if( listPos != NULL )
				{
					pTok = m_TokList.GetNext( listPos );
				}
			}
			//-------------------------------
			// Complete last phrase
			//-------------------------------
			pTPhrase[cPhrases].posClass = prevPOS;
			pTPhrase[cPhrases].end = i-1;
			cPhrases++;
        
			for( i = 0; i < cPhrases; i++ )
			{
				//-------------------------------------------------------
				// Sequence of function words, place a low tone 
				// on the LAST word in a func sequence,
				// if there are more than 1 words in the sequence.
				//-------------------------------------------------------
				if( ((pTPhrase[i].posClass == POS_FUNC) || (pTPhrase[i].posClass == POS_AUX)) && 
					(pTPhrase[i].end - pTPhrase[i].start) )
				{
					pTok = (CFEToken*)m_TokList.GetAt( m_TokList.FindIndex( pTPhrase[i].end ));
					if( pTok->m_Accent == K_NOACC )
					{
						pTok->m_Accent = K_LSTAR;
						pTok->m_Accent_Prom = 2;
						pTok->m_AccentSource = ACC_FunctionSeq;
					}
				}
            
				//-------------------------------------------------------
				// Sequence of content words, place a high or 
				// rising tone, of random prominence,
				// on the FIRST word in the content sequence
				//-------------------------------------------------------
				else if ( ((pTPhrase[i].posClass == POS_CONTENT) || (pTPhrase[i].posClass == POS_UNK)) )
				{
					pTok = (CFEToken*)m_TokList.GetAt( m_TokList.FindIndex( pTPhrase[i].start ));
					if( pTok->m_Accent == K_NOACC )
					{
						pTok->m_Accent = K_HSTAR;
						pTok->m_Accent_Prom = rand() % 5;
						pTok->m_AccentSource = ACC_ContentSeq;
					}
				}
			}
        
        
			delete pTPhrase;
        
			//-----------------------------------------
			// Now, insert the BOUNDARY tags
			//-----------------------------------------
			listPos = m_TokList.GetHeadPosition();
			pPrevTok = m_TokList.GetNext( listPos );
			for( i = 1; i < cTok; i++ )
			{
				pTok = m_TokList.GetNext( listPos );
				//--------------------------------
				// Place a terminal boundary
				//--------------------------------
				if( pTok->m_TuneBoundaryType != NULL_BOUNDARY )
				{
					switch( pTok->m_TuneBoundaryType )
					{
					case YN_QUEST_BOUNDARY:
						{
							pPrevTok->m_Accent = K_LSTAR;
							pPrevTok->m_Accent_Prom = 10;
							pPrevTok->m_Boundary = K_HMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 10;
							//-- Diagnostic
							if( pPrevTok->m_AccentSource == ACC_NoSource )
							{
								pPrevTok->m_AccentSource = ACC_YNQuest;
							}
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_YNQuest;
							}
							//-------------------------------------------------------
							// Accent an aux verb in initial position (possible ynq)
							//-------------------------------------------------------
							if( possible_YNQ )
							{
								pAuxTok->m_Accent = K_HSTAR;
								pAuxTok->m_Accent_Prom = 5;
								pAuxTok->m_AccentSource = ACC_InitialVAux;
							}
						}
						break;
					case WH_QUEST_BOUNDARY:
					case DECLAR_BOUNDARY:
					case EXCLAM_BOUNDARY:
						{
							if (pPrevTok->m_posClass == POS_CONTENT)
							{
								pPrevTok->m_Accent = K_HSTAR;
								pPrevTok->m_Accent_Prom = 4;
								//-- Diagnostic
								if( pPrevTok->m_AccentSource == ACC_NoSource )
								{
									pPrevTok->m_AccentSource = ACC_Period;
								}
							}
							pPrevTok->m_Boundary = K_LMINUSLPERC;
							pPrevTok->m_Boundary_Prom = 10;
							//--- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_Period;
							}
						}
						break;
					case PHRASE_BOUNDARY:
						{
							if (pPrevTok->m_posClass == POS_CONTENT)
							{
								pPrevTok->m_Accent = K_LHSTAR;
								pPrevTok->m_Accent_Prom = 10;
								//-- Diagnostic
								if( pPrevTok->m_AccentSource == ACC_NoSource )
								{
									pPrevTok->m_AccentSource = ACC_Comma;
								}
							}
							pPrevTok->m_Boundary = K_LMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 5;
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_Comma;
							}
						}
						break;
					case NUMBER_BOUNDARY:
						{
							pPrevTok->m_Boundary = K_LMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 5;
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = BND_NumberTemplate;
							}
						}
						break;
					default:
						{
							// Use comma for all other boundaries
							if (pPrevTok->m_posClass == POS_CONTENT)
							{
								pPrevTok->m_Accent = K_LHSTAR;
								pPrevTok->m_Accent_Prom = 10;
								//-- Diagnostic
								if( pPrevTok->m_AccentSource == ACC_NoSource )
								{
									pPrevTok->m_AccentSource = pTok->m_AccentSource;
								}
							}
							pPrevTok->m_Boundary = K_LMINUSHPERC;
							pPrevTok->m_Boundary_Prom = 5;
							//-- Diagnostic
							if( pPrevTok->m_BoundarySource == BND_NoSource )
							{
								pPrevTok->m_BoundarySource = pTok->m_BoundarySource;
							}
						}
						break;
					}
				}
				pPrevTok = pTok;
			}

			//--------------------------------------------
			// Loop through each word and increase 
			// pitch prominence if EMPHASIZED and
			// decrease prominence for all others
			//--------------------------------------------
			if( hasEmph )
			{
				SPLISTPOS listPos;

				pPrevTok = NULL;
				listPos = m_TokList.GetHeadPosition();
				while( listPos )
				{
					pTok = m_TokList.GetNext( listPos );
					//------------------------------
					// Is this word emphasized?
					//------------------------------
					if( pTok->user_Emph > 0 )
					{
						//------------------------------
						// Add my clever H*+L* tag
						//------------------------------
						pTok->m_Accent = K_HSTARLSTAR;
						pTok->m_Accent_Prom = 10;
						pTok->m_Boundary = K_NOBND;			// Delete any boundary tag here... 
						if( pPrevTok )
						{
							pPrevTok->m_Boundary = K_NOBND;	// ...or before
						}
					}
					else
					{
						//-----------------------------------
						// Is non-emphasized word accented?
						//-----------------------------------
						if( (pTok->m_Accent != K_NOACC) && (pTok->m_Accent_Prom > 5) )
						{
							//------------------------------
							// Then clip its prominence at 5
							//------------------------------
							pTok->m_Accent_Prom = 5;
						}
						//------------------------------
						// Is it a boundary?
						//------------------------------
						/*if( (pTok->m_Boundary != K_NOBND) && (pTok->m_Boundary_Prom > 5) )
						{
							//------------------------------
							// Then clip its prominence at 5
							//------------------------------
							pTok->m_Boundary_Prom = 5;
						}*/
					}
					pPrevTok = pTok;
				}
			}
		}
	}
    return S_OK;
} /* ToBISymbols */


/*****************************************************************************
* CFrontend::TokensToAllo *
*------------------------*
*   Description:
*   Transform TOKENS into ALLOS
*       
********************************************************************** MC ***/
HRESULT CFrontend::TokensToAllo( CFETokenList *pTokList, CAlloList *pAllo )
{
    SPDBG_FUNC( "CFrontend::TokToAllo" );
    CAlloCell   *pLastCell;
    long        i;
    long        cTok;
    CFEToken    *pCurToken, *pNextToken, *pPrevTok;
	SPLISTPOS	listPos;

    
    pLastCell = pAllo->GetTailCell();        // Get end (silence)
    if( pLastCell )
    {
		pPrevTok = NULL;
		listPos = pTokList->GetHeadPosition();
		pCurToken = pTokList->GetNext( listPos );
        cTok = pTokList->GetCount();
        for( i = 0; i < cTok; i++ )
        {
			//----------------------------
			// Get NEXT word
			//----------------------------
			if( i < (cTok -1) )
			{
				pNextToken = pTokList->GetNext( listPos );
			}
			else
			{
				pNextToken = NULL;
			}
			if( pAllo->WordToAllo( pPrevTok, pCurToken, pNextToken, pLastCell ) )
			{
				m_HasSpeech = true;
			}
			//----------------------------
			// Bump the pipeline
			//----------------------------
			pPrevTok	= pCurToken;
			pCurToken	= pNextToken;
        }
    }
            
    return S_OK;
    
} /* CFrontend::TokensToAllo */




/*****************************************************************************
* CFrontend::GetItemControls *
*----------------------------*
*   Description:
*   Set user control values from Sent Enum item.
********************************************************************** MC ***/
void CFrontend::GetItemControls( const SPVSTATE* pXmlState, CFEToken* pToken )
{
    SPDBG_FUNC( "CFrontend::GetItemControls" );

    pToken->user_Volume = pXmlState->Volume;
    pToken->user_Rate  = pXmlState->RateAdj;
    pToken->user_Pitch = pXmlState->PitchAdj.MiddleAdj;
    pToken->user_Emph  = pXmlState->EmphAdj;
    pToken->m_DurScale = CntrlToRatio( pToken->user_Rate );
    if( (pToken->m_DurScale * m_RateRatio_API * m_RateRatio_PROSODY) 
				< DISCRETE_BKPT )
    {
        //-- If the total rate is low enough, insert breaks between words
        pToken->m_TermSil = 0.050f / 
			(pToken->m_DurScale * m_RateRatio_API * m_RateRatio_PROSODY);
        pToken->m_DurScale = DISCRETE_BKPT;
    }
	else
	{
		pToken->m_TermSil = 0;
	}

} /* CFrontend::GetItemControls */




/*****************************************************************************
* CFrontend::GetPOSClass *
*------------------------*
*   Description:
*   Transform SAPI POS code to func/content/aux class.
********************************************************************** MC ***/
PROSODY_POS CFrontend::GetPOSClass( ENGPARTOFSPEECH sapiPOS )
{
    SPDBG_FUNC( "CFrontend::GetPOSClass" );
	PROSODY_POS		posClass;

	posClass = POS_UNK;
	switch( sapiPOS )
	{
	case MS_Noun:
	case MS_Verb:
	case MS_Adj:
	case MS_Adv:
	case MS_Interjection:
		{
			posClass = POS_CONTENT;
			break;
		}
	case MS_VAux:
		{
			posClass = POS_AUX;
			break;
		}
	case MS_Modifier:
	case MS_Function:
	case MS_Interr:
	case MS_Pron:
	case MS_ObjPron:
	case MS_SubjPron:
	case MS_RelPron:
	case MS_Conj:
	case MS_CConj:
	case MS_Det:
	case MS_Contr:
	case MS_Prep:
		{
			posClass = POS_FUNC;
			break;
		}
	}

	return posClass;
} /* CFrontend::GetPOSClass */



#define	QUOTE_HESITATION	100		// Number of msec
#define	PAREN_HESITATION	100		// Number of msec
#define	PAREN_HESITATION_TAIL	100		// Number of msec
#define	EMPH_HESITATION	1		// Number of msec

/*****************************************************************************
* CFrontend::StateQuoteProsody *
*------------------------------*
*   Description:
*       
********************************************************************** MC ***/
bool CFrontend::StateQuoteProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil )
{
    SPDBG_FUNC( "CFrontend::StateQuoteProsody" );
	bool		result = false;

	if( !m_fInParenProsody )
	{
		if( m_fInQuoteProsody )
		{
			//------------------------------
			// Stop quote prosody
			//------------------------------
			m_fInQuoteProsody = false;
			m_CurPitchOffs = 0.0f;
			m_CurPitchRange = 1.0f;
			if( fInsertSil )
			{
				(void)InsertSilenceAtTail( pWordTok, pSentItem, QUOTE_HESITATION );
				pWordTok->m_SilenceSource = SIL_QuoteEnd;
			}
		}
		else
		{
			//------------------------------
			// Begin quote prosody
			//------------------------------
			m_fInQuoteProsody = true;
			m_CurPitchOffs = 0.1f;
			m_CurPitchRange = 1.25f;
			if( fInsertSil )
			{
				(void)InsertSilenceAtTail( pWordTok, pSentItem, QUOTE_HESITATION );
				pWordTok->m_SilenceSource = SIL_QuoteStart;
			}
		}
		result = true;
	}
	return result;
} /* CFrontend::StateQuoteProsody */



/*****************************************************************************
* CFrontend::StartParenProsody *
*------------------------------*
*   Description:
*       
********************************************************************** MC ***/
bool CFrontend::StartParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil )
{
    SPDBG_FUNC( "CFrontend::StartParenProsody" );
	bool		result = false;

	if( (!m_fInParenProsody) && (!m_fInQuoteProsody) )
	{
		m_CurPitchOffs = -0.2f;
		m_CurPitchRange = 0.75f;
		m_fInParenProsody = true;
		m_RateRatio_PROSODY = 1.25f;
		if( fInsertSil )
		{
			(void)InsertSilenceAtTail( pWordTok, pSentItem, PAREN_HESITATION );
			pWordTok->m_SilenceSource = SIL_ParenStart;
		}
		result = true;
	}
	return result;
} /* CFrontend::StartParenProsody */


/*****************************************************************************
* CFrontend::EndParenProsody *
*----------------------------*
*   Description:
*       
********************************************************************** MC ***/
bool CFrontend::EndParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil )
{
    SPDBG_FUNC( "CFrontend::EndParenProsody" );
	bool		result = false;

	if( m_fInParenProsody )
	{
		m_fInParenProsody = false;
		m_CurPitchOffs = 0.0f;
		m_CurPitchRange = 1.0f;
		m_RateRatio_PROSODY = 1.0f;
		if( fInsertSil )
		{
			(void)InsertSilenceAtTail( pWordTok, pSentItem, PAREN_HESITATION_TAIL );
			pWordTok->m_SilenceSource = SIL_ParenStart;
		}
		result = true;
	}
	return result;
} /* CFrontend::EndParenProsody */





/*****************************************************************************
* CFrontend::InsertSilenceAtTail *
*--------------------------------*
*   Description:
*       
********************************************************************** MC ***/
SPLISTPOS CFrontend::InsertSilenceAtTail( CFEToken *pWordTok, TTSSentItem *pSentItem, long msec )
{
    SPDBG_FUNC( "CFrontend::InsertSilenceAtTail" );

	if( msec > 0 )
	{
		pWordTok->user_Break = msec;
	}
	pWordTok->phon_Len    = 1;
	pWordTok->phon_Str[0] = _SIL_;
	pWordTok->srcPosition = pSentItem->ulItemSrcOffset;
	pWordTok->srcLen      = pSentItem->ulItemSrcLen;
	pWordTok->tokStr[0]   = 0;        // There's no orth for Break
	pWordTok->tokLen      = 0;
	pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
	pWordTok->m_PitchRangeScale = m_CurPitchRange;
	pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;
	//----------------------------------
	// Advance to next token
	//----------------------------------
	return m_TokList.AddTail( pWordTok );
} /* CFrontend::InsertSilenceAtTail */



/*****************************************************************************
* CFrontend::InsertSilenceAfterPos  *
*-----------------------------------*
*   Description:
*	Insert silence token AFTER 'position'
*       
********************************************************************** MC ***/
SPLISTPOS CFrontend::InsertSilenceAfterPos( CFEToken *pWordTok, SPLISTPOS position )
{
    SPDBG_FUNC( "CFrontend::InsertSilenceAfterPos" );

	pWordTok->phon_Len		= 1;
	pWordTok->phon_Str[0]	= _SIL_;
	pWordTok->srcPosition	= 0;
	pWordTok->srcLen		= 0;
	pWordTok->tokStr[0]		= '+';      // punctuation
	pWordTok->tokStr[1]		= 0;                   // delimiter
	pWordTok->tokLen		= 1;
	pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
	pWordTok->m_PitchRangeScale = m_CurPitchRange;
	pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;
	pWordTok->m_DurScale	= 0;
	//----------------------------------
	// Advance to next token
	//----------------------------------
	return m_TokList.InsertAfter( position, pWordTok );
} /* CFrontend::InsertSilenceAfterPos */


/*****************************************************************************
* CFrontend::InsertSilenceBeforePos  *
*------------------------------------*
*   Description:
*	Insert silence token BEFORE 'position'
*       
********************************************************************** MC ***/
SPLISTPOS CFrontend::InsertSilenceBeforePos( CFEToken *pWordTok, SPLISTPOS position )
{
    SPDBG_FUNC( "CFrontend::InsertSilenceBeforePos" );

	pWordTok->phon_Len		= 1;
	pWordTok->phon_Str[0]	= _SIL_;
	pWordTok->srcPosition	= 0;
	pWordTok->srcLen		= 0;
	pWordTok->tokStr[0]		= '+';      // punctuation
	pWordTok->tokStr[1]		= 0;                   // delimiter
	pWordTok->tokLen		= 1;
	pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
	pWordTok->m_PitchRangeScale = m_CurPitchRange;
	pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;
	pWordTok->m_DurScale	= 0;
	//----------------------------------
	// Advance to next token
	//----------------------------------
	return m_TokList.InsertBefore( position, pWordTok );
} /* CFrontend::InsertSilenceBeforePos */






#define K_ACCENT_PROM	((rand() % 4) + 4)
#define K_DEACCENT_PROM 5
#define K_ACCENT		K_HSTAR
#define K_DEACCENT		K_NOACC



/*****************************************************************************
* CFrontend::ProsodyTemplates *
*-----------------------------*
*   Description:
*   Call prosody template function for supported item types.
*       
********************************************************************** MC ***/
void CFrontend::ProsodyTemplates( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::ProsodyTemplates" );
	long				cWordCount;
	CFEToken			*pClusterTok;

	switch( pSentItem->pItemInfo->Type )
	{
		//---------------------------------------
		// Numbers
		//---------------------------------------
        case eNUM_ROMAN_NUMERAL:
		case eNUM_ROMAN_NUMERAL_ORDINAL:
            {
                if ( ( (TTSRomanNumeralItemInfo*) pSentItem->pItemInfo )->pNumberInfo->Type != eDATE_YEAR )
                {
                    if ( ((TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo)->pIntegerPart )
                    {
                        DoIntegerTemplate( &clusterPos, 
	    								   (TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo, 
		    							   pSentItem->ulNumWords );
                    }

                    if ( ((TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo)->pDecimalPart )
                    {
                        DoNumByNumTemplate( &clusterPos, 
                                            ((TTSNumberItemInfo*)((TTSRomanNumeralItemInfo*)pSentItem->pItemInfo)->pNumberInfo)->pDecimalPart->ulNumDigits );
                    }
                }
            }
        break;

		case eNUM_CARDINAL:
		case eNUM_DECIMAL:
		case eNUM_ORDINAL:
		case eNUM_MIXEDFRACTION:
			{
                if ( ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pIntegerPart )
                {
    				cWordCount = DoIntegerTemplate( &clusterPos, 
	    											(TTSNumberItemInfo*) pSentItem->pItemInfo, 
		    										pSentItem->ulNumWords );
                }

                if( ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pDecimalPart )
                {
					//-----------------------------------------
					// Skip "point" string...
					//-----------------------------------------
					(void) m_TokList.GetNext( clusterPos );
					//-----------------------------------------
					// ...and do single digit prosody
					//-----------------------------------------
				    DoNumByNumTemplate( &clusterPos, 
                                        ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pDecimalPart->ulNumDigits );
                }

                if ( ( (TTSNumberItemInfo*) pSentItem->pItemInfo )->pFractionalPart )
                {
					//-----------------------------------------
					// Skip "and" string...
					//-----------------------------------------
					pClusterTok = m_TokList.GetNext( clusterPos );
 					if( pClusterTok->m_Accent == K_NOACC )
					{
						//--------------------------------------
						// Force POS for "and" to noun 
						//  so phrasing rules don't kick in!
						//--------------------------------------
						pClusterTok->m_Accent = K_DEACCENT;
						pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
						pClusterTok->POScode = MS_Noun;
						pClusterTok->m_posClass = POS_CONTENT;
					}
					//-----------------------------------------
					// ...and do fraction prosody
					//-----------------------------------------
    				cWordCount = DoFractionTemplate( &clusterPos, 
	    											(TTSNumberItemInfo*) pSentItem->pItemInfo, 
		    										pSentItem->ulNumWords );
                }
			}
        break;

		//---------------------------------------
		// Fraction
		//---------------------------------------
		case eNUM_FRACTION:
			{
    			cWordCount = DoFractionTemplate( &clusterPos, 
	    										(TTSNumberItemInfo*) pSentItem->pItemInfo, 
		    									pSentItem->ulNumWords );
			}
		break;

		//---------------------------------------
		// Money
		//---------------------------------------
		case eNUM_CURRENCY:
			{
				 DoCurrencyTemplate( clusterPos, pSentItem );
			}
		break;

		//---------------------------------------
		// Phone Numbers
		//---------------------------------------
		case eNUM_PHONENUMBER:
		case eNEWNUM_PHONENUMBER:
			{
				DoPhoneNumberTemplate( clusterPos, pSentItem );
			}
		break;

		//---------------------------------------
		// Time-of-Day
		//---------------------------------------
		case eTIMEOFDAY:
			{
				DoTODTemplate( clusterPos, pSentItem );
			}
		break;

		case eELLIPSIS:
			{
				CFEToken	*pWordTok;

				pWordTok = new CFEToken;
				if( pWordTok )
				{
					clusterPos = InsertSilenceAtTail( pWordTok, pSentItem, 0 );
					//clusterPos = m_TokList.GetTailPosition( );
					//clusterPos = InsertSilenceAfterPos( pWordTok, clusterPos );
					pWordTok->m_SilenceSource = SIL_Ellipsis;
					pWordTok->m_TuneBoundaryType = ELLIPSIS_BOUNDARY;
					pWordTok->m_BoundarySource = BND_Ellipsis;
				}
			}
		break;
	}

} /* CFrontend::ProsodyTemplates */




/*****************************************************************************
* CFrontend::DoTODTemplate *
*--------------------------*
*   Description:
*   Prosody template for time-of-day.
* 
*	TODO: Temp kludge - needs more info in TTSTimeOfDayItemInfo    
********************************************************************** MC ***/
void CFrontend::DoTODTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::DoTODTemplate" );
	TTSTimeOfDayItemInfo	*pTOD;
	CFEToken				*pWordTok;
	CFEToken				*pClusterTok;
	SPLISTPOS				curPos, nextPos, prevPos;


	curPos = nextPos = clusterPos;
	pTOD = (TTSTimeOfDayItemInfo*)&pSentItem->pItemInfo->Type;

	// Can't do 24 hr because there's no way to tell 
	// if it's 1 or 2 digits (18: vs 23:)
	if( !pTOD->fTwentyFourHour )
	{
		//-------------------------------------
		// Get HOUR token
		//-------------------------------------
		pClusterTok = m_TokList.GetNext( nextPos );
		//-------------------------------------
		// Accent hour
		//-------------------------------------
		pClusterTok->m_Accent = K_ACCENT;
		pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
		pClusterTok->m_AccentSource = ACC_TimeOFDay_HR;

		//---------------------------------
		// Insert SILENCE after hour
		//---------------------------------
		pWordTok = new CFEToken;
		if( pWordTok )
		{
			nextPos = InsertSilenceAfterPos( pWordTok, clusterPos );
			pWordTok->m_SilenceSource = SIL_TimeOfDay_HR;
			pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
			pWordTok->m_BoundarySource = BND_TimeOFDay_HR;
			pWordTok = NULL;
			//----------------------------
			// Skip last digit
			//----------------------------
			if( clusterPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
		}
		if( pTOD->fMinutes )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			//-------------------------------------
			// Accent 1st digit for minutes
			//-------------------------------------
			pClusterTok->m_Accent = K_ACCENT;
			pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
			pClusterTok->m_AccentSource = ACC_TimeOFDay_1stMin;
		}

		if( pTOD->fTimeAbbreviation )
		{
			curPos = prevPos = m_TokList.GetTailPosition( );
			pClusterTok = m_TokList.GetPrev( prevPos );
			pWordTok = new CFEToken;
			if( pWordTok )
			{
				prevPos = InsertSilenceBeforePos( pWordTok, prevPos );
				pWordTok->m_SilenceSource = SIL_TimeOfDay_AB;
				pWordTok->m_TuneBoundaryType = TOD_BOUNDARY;
				pWordTok->m_BoundarySource = BND_TimeOFDay_AB;
				pWordTok = NULL;
				//pClusterTok = m_TokList.GetNext( clusterPos );
				//pClusterTok = m_TokList.GetNext( clusterPos );
			}
			//-------------------------------------
			// Accent "M"
			//-------------------------------------
			pClusterTok = m_TokList.GetNext( curPos );
			pClusterTok->m_Accent = K_ACCENT;
			pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
			pClusterTok->m_AccentSource = ACC_TimeOFDay_M;
		}
	}
} /* CFrontend::DoTODTemplate */





CFEToken *CFrontend::InsertPhoneSilenceAtSpace( SPLISTPOS *pClusterPos, 
												BOUNDARY_SOURCE bndSrc, 
												SILENCE_SOURCE	silSrc )
{
	CFEToken		*pWordTok;
	SPLISTPOS		curPos, nextPos;

	curPos = nextPos = *pClusterPos;
	//---------------------------------
	// Insert SILENCE after area code
	//---------------------------------
	pWordTok = new CFEToken;
	if( pWordTok )
	{
		nextPos = InsertSilenceBeforePos( pWordTok, curPos );
		pWordTok->m_SilenceSource = silSrc;
		pWordTok->m_TuneBoundaryType = PHONE_BOUNDARY;
		pWordTok->m_BoundarySource = bndSrc;
		pWordTok->m_AccentSource = ACC_PhoneBnd_AREA;		// @@@@ ???
		pWordTok = NULL;
		//----------------------------
		// Skip last digit
		//----------------------------
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pWordTok = m_TokList.GetNext( nextPos );
		}
	}
	//pWordTok = m_TokList.GetNext( clusterPos );
	//-----------------------------------------
	// Filter and embedded silences
	//-----------------------------------------
	while( (pWordTok->phon_Str[0] == _SIL_) && (nextPos != NULL) )
	{
		curPos = nextPos;
		pWordTok = m_TokList.GetNext( nextPos );
	}
	*pClusterPos = curPos;

	return pWordTok;
}




void CFrontend::InsertPhoneSilenceAtEnd( BOUNDARY_SOURCE bndSrc, 
										 SILENCE_SOURCE	silSrc )
{
	CFEToken		*pWordTok;
	SPLISTPOS		curPos, nextPos;

	curPos = m_TokList.GetTailPosition( );
	//---------------------------------
	// Insert SILENCE after area code
	//---------------------------------
	pWordTok = new CFEToken;
	if( pWordTok )
	{
		nextPos = InsertSilenceAfterPos( pWordTok, curPos );
		pWordTok->m_SilenceSource = silSrc;
		pWordTok->m_TuneBoundaryType = PHONE_BOUNDARY;
		pWordTok->m_BoundarySource = bndSrc;
		pWordTok->m_AccentSource = ACC_PhoneBnd_AREA;		// @@@@ ???
	}
}








/*****************************************************************************
* CFrontend::DoPhoneNumberTemplate *
*----------------------------------*
*   Description:
*   Prosody template for phone numbers.
*       
********************************************************************** MC ***/
void CFrontend::DoPhoneNumberTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::DoPhoneNumberTemplate" );
	TTSPhoneNumberItemInfo	*pFone;
	CFEToken				*pClusterTok;
	long					cWordCount;
	SPLISTPOS				curPos, nextPos;

	curPos = nextPos = clusterPos;
	pFone = (TTSPhoneNumberItemInfo*)&pSentItem->pItemInfo->Type;

	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// COUNTRY CODE
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	if( pFone->pCountryCode )
	{
		//-------------------------------------
		// Skip "country" and...
		//-------------------------------------
		curPos = nextPos;
		pClusterTok = m_TokList.GetNext( nextPos );
		
		//-------------------------------------
		// ...skip "code"
		//-------------------------------------
		curPos = nextPos;
		pClusterTok = m_TokList.GetNext( nextPos );

		cWordCount = DoIntegerTemplate( &nextPos, 
										pFone->pCountryCode, 
										pSentItem->ulNumWords );
		pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_COUNTRY, SIL_Phone_COUNTRY );
	}
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// "One"
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	if( pFone->fOne )
	{
		//-------------------------------------
		// Skip "One"
		//-------------------------------------
		curPos = nextPos;
		pClusterTok = m_TokList.GetNext( nextPos );
		//-------------------------------------
		// and add silence
		//-------------------------------------
		pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_ONE, SIL_Phone_ONE );
		
	}
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// AREA CODE
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	if( pFone->pAreaCode )
	{

		if( (pFone->fIs800) && nextPos )
		{
			//--------------------------
			// Skip digit
			//--------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			//--------------------------
			// Skip "hundred"
			//--------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			if( nextPos )
			{
				pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_AREA, SIL_Phone_AREA );
			}
		}
		else
		{
			//-------------------------------------
			// Skip "area" and...
			//-------------------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			//-------------------------------------
			// ...skip "code"
			//-------------------------------------
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );

			DoNumByNumTemplate( &nextPos, pFone->pAreaCode->ulNumDigits );
			if( nextPos )
			{
				pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_AREA, SIL_Phone_AREA );
			}
		}
	}
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	//
	// Digits
	//
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
	unsigned long		i;

	for( i = 0; i < pFone->ulNumGroups; i++ )
	{
		DoNumByNumTemplate( &nextPos, pFone->ppGroups[i]->ulNumDigits );
		if( nextPos )
		{
			pClusterTok = InsertPhoneSilenceAtSpace( &nextPos, BND_Phone_DIGITS, SIL_Phone_DIGITS );
		}
	}
	InsertPhoneSilenceAtEnd( BND_Phone_DIGITS, SIL_Phone_DIGITS );
} /* CFrontend::DoPhoneNumberTemplate */

/*****************************************************************************
* CFrontend::DoCurrencyTemplate *
*-------------------------------*
*   Description:
*   Prosody template for currency.
*       
********************************************************************** MC ***/
void CFrontend::DoCurrencyTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem )
{
    SPDBG_FUNC( "CFrontend::DoCurrencyTemplate" );
	TTSCurrencyItemInfo		*pMoney;
	CFEToken				*pWordTok;
	CFEToken				*pClusterTok = NULL;
	long					cWordCount;
	SPLISTPOS				curPos, nextPos;

	pMoney = (TTSCurrencyItemInfo*)&pSentItem->pItemInfo->Type;

	curPos = nextPos = clusterPos;
	if( pMoney->pPrimaryNumberPart->Type != eNUM_CARDINAL )
	{
		return;
	}
	cWordCount = DoIntegerTemplate( &nextPos, 
									pMoney->pPrimaryNumberPart, 
									pSentItem->ulNumWords );
	curPos = nextPos;
	if( cWordCount > 1 )
	{
		if( pMoney->fQuantifier )
		{
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
			cWordCount--;
		}
	}
	if( cWordCount > 1 )
	{
		//---------------------------------
		// Insert SILENCE after "dollars"
		//---------------------------------
		pWordTok = new CFEToken;
		if( pWordTok )
		{
			nextPos = InsertSilenceAfterPos( pWordTok, curPos );
			pWordTok->m_SilenceSource = SIL_Currency_DOLLAR;
			pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
			pWordTok->m_BoundarySource = BND_Currency_DOLLAR;
			pWordTok = NULL;
			//----------------------------
			// Skip "dollar(s)"
			//----------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
		}
		if( pMoney->pSecondaryNumberPart != NULL )
		{
			//----------------------------
			// Skip SILENCE
			//----------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
			}
			cWordCount--;
			//----------------------------
			// Skip AND
			//----------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
 				if( pClusterTok->m_Accent == K_NOACC )
				{
					//--------------------------------------
					// Force POS for "and" to noun 
					//  so phrasing rules don't kick in!
					//--------------------------------------
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
					pClusterTok->POScode = MS_Noun;
					pClusterTok->m_posClass = POS_CONTENT;
				}
				pClusterTok = m_TokList.GetNext( nextPos );
			}
			cWordCount--;
			cWordCount = DoIntegerTemplate( &curPos, 
											pMoney->pSecondaryNumberPart, 
											cWordCount );
		}
	}
} /* CFrontend::DoCurrencyTemplate */





/*****************************************************************************
* CFrontend::DoNumByNumTemplate *
*---------------------------------*
*   Description:
*   Prosody template for RIGHT hand side of the decimal point.
*       
********************************************************************** MC ***/
void CFrontend::DoNumByNumTemplate( SPLISTPOS *pClusterPos, long cWordCount )
{
    SPDBG_FUNC( "CFrontend::DoNumByNumTemplate" );
	CFEToken			*pClusterTok;
	SPLISTPOS			curPos, nextPos;

	curPos = nextPos = *pClusterPos;
	while( cWordCount > 1 )
	{
		pClusterTok = NULL;
		//-------------------------------------------------------------
		// Right side of decimal point - add H* to every other word 
		//-------------------------------------------------------------
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
		}
		cWordCount--;

		if( pClusterTok )
		{
			pClusterTok->m_Accent = K_ACCENT;
			pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
			pClusterTok->m_AccentSource = ACC_NumByNum;
		}
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
		}
		cWordCount--;
	}
	if( cWordCount > 0 )
	{
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
		}
		cWordCount--;
	}
	*pClusterPos = nextPos;
} /* CFrontend::DoNumByNumTemplate */






/*****************************************************************************
* CFrontend::DoFractionTemplate *
*------------------------------*
*   Description:
*   Prosody template for RIGHT side of the decimal point.
*       
********************************************************************** MC ***/
long CFrontend::DoFractionTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount )
{
    SPDBG_FUNC( "CFrontend::DoFractionTemplate" );
	CFEToken				*pClusterTok;
	TTSFractionItemInfo	    *pFInfo;
	CFEToken				*pWordTok;

	pFInfo = pNInfo->pFractionalPart;

    //--- Do Numerator...
    if ( pFInfo->pNumerator->pIntegerPart )
    {
    	cWordCount = DoIntegerTemplate( pClusterPos, pFInfo->pNumerator, cWordCount );
    }
    if( pFInfo->pNumerator->pDecimalPart )
    {
		//-----------------------------------------
		// Skip "point" string...
		//-----------------------------------------
		(void) m_TokList.GetNext( *pClusterPos );
		//-----------------------------------------
		// ...and do single digit prosody
		//-----------------------------------------
		DoNumByNumTemplate( pClusterPos, pFInfo->pNumerator->pDecimalPart->ulNumDigits );
    }

    //--- Special case - a non-standard fraction (e.g. 1/4)
	if( !pFInfo->fIsStandard )
	{
		if( !*pClusterPos )
		{
			*pClusterPos = m_TokList.GetTailPosition( );
		}
		else
		{
			pClusterTok = m_TokList.GetPrev( *pClusterPos );
		}
	}

	pWordTok = new CFEToken;
	if( pWordTok )
	{
		*pClusterPos = InsertSilenceBeforePos( pWordTok, *pClusterPos );
		pWordTok->m_SilenceSource = SIL_Fractions_NUM;
		pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
		pWordTok->m_BoundarySource = BND_Frac_Num;
		pWordTok = NULL;
		//----------------------------
		// Skip numerator
		//----------------------------
		if( *pClusterPos != NULL )
		{
			pClusterTok = m_TokList.GetNext( *pClusterPos );
		}
	}

    //--- Do Denominator...
    if ( pFInfo->pDenominator->pIntegerPart )
    {
		//-----------------------------------------
		// Skip "over" string...
		//-----------------------------------------
		pClusterTok = m_TokList.GetNext( *pClusterPos );
 		if( pClusterTok->m_Accent == K_NOACC )
		{
			//--------------------------------------
			// Force POS for "and" to noun 
			//  so phrasing rules don't kick in!
			//--------------------------------------
			pClusterTok->m_Accent = K_DEACCENT;
			pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
			pClusterTok->POScode = MS_Noun;
			pClusterTok->m_posClass = POS_CONTENT;
		}
    	cWordCount = DoIntegerTemplate( pClusterPos, pFInfo->pDenominator, cWordCount );
    }
    if( pFInfo->pDenominator->pDecimalPart )
    {
		//-----------------------------------------
		// Skip "point" string...
		//-----------------------------------------
		(void) m_TokList.GetNext( *pClusterPos );
		//-----------------------------------------
		// ...and do single digit prosody
		//-----------------------------------------
		DoNumByNumTemplate( pClusterPos, pFInfo->pDenominator->pDecimalPart->ulNumDigits );
    }

	return cWordCount;
} /* CFrontend::DoFractionTemplate */




/*****************************************************************************
* CFrontend::DoIntegerTemplate *
*------------------------------*
*   Description:
*   Prosody template for LEFT hand side of the decimal point.
*       
********************************************************************** MC ***/
long CFrontend::DoIntegerTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount )
{
    SPDBG_FUNC( "CFrontend::DoIntegerTemplate" );
	long				i;
	CFEToken			*pClusterTok;
    CFEToken			*pWordTok = NULL;
	SPLISTPOS			curPos, nextPos;

	//------------------------------------------
	// Special currency hack...sorry
	//------------------------------------------
	if( pNInfo->pIntegerPart->fDigitByDigit )
	{
		DoNumByNumTemplate( pClusterPos, pNInfo->pIntegerPart->ulNumDigits );
		return cWordCount - pNInfo->pIntegerPart->ulNumDigits;
	}

	nextPos = curPos = *pClusterPos;
	pClusterTok = m_TokList.GetNext( nextPos );
	pClusterTok->m_Accent = K_DEACCENT;
	pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
	if( pNInfo->fNegative )
	{
		//---------------------------------
		// Skip "NEGATIVE"
		//---------------------------------
		if( nextPos != NULL )
		{
			curPos = nextPos;
			pClusterTok = m_TokList.GetNext( nextPos );
			pClusterTok->m_Accent = K_DEACCENT;
			pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
		}
		cWordCount--;
	}
	for( i = (pNInfo->pIntegerPart->lNumGroups -1); i >= 0; i-- )
	{
		//------------------------------------
		// Accent 1st digit in group
		//------------------------------------
		pClusterTok->m_Accent = K_ACCENT;
		pClusterTok->m_Accent_Prom = K_ACCENT_PROM;
		pClusterTok->m_AccentSource = ACC_IntegerGroup;


		if( pNInfo->pIntegerPart->Groups[i].fHundreds )
		{
			//---------------------------------
			// Skip "X HUNDRED"
			//---------------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
		}
		if( pNInfo->pIntegerPart->Groups[i].fTens )
		{
			//---------------------------------
			// Skip "X-TY"
			//---------------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
		}
		if( pNInfo->pIntegerPart->Groups[i].fOnes )
		{
			//---------------------------------
			// Skip "X"
			//---------------------------------
			if( nextPos != NULL )
			{
				curPos = nextPos;
				pClusterTok = m_TokList.GetNext( nextPos );
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
			}
			cWordCount--;
		}
		if( pNInfo->pIntegerPart->Groups[i].fQuantifier )
		{
			//---------------------------------
			// Insert SILENCE after quant
			//---------------------------------
			if( pWordTok == NULL )
			{
				pWordTok = new CFEToken;
			}
			if( pWordTok )
			{
				nextPos = InsertSilenceAfterPos( pWordTok, curPos );
				pWordTok->m_SilenceSource = SIL_Integer_Quant;
				pWordTok->m_TuneBoundaryType = NUMBER_BOUNDARY;
				pWordTok->m_BoundarySource = BND_IntegerQuant;
				pWordTok = NULL;
				if( pClusterTok->m_Accent == K_NOACC )
				{
					pClusterTok->m_Accent = K_DEACCENT;
					pClusterTok->m_Accent_Prom = K_DEACCENT_PROM;
				}
				if( nextPos != NULL )
				{
					//------------------------------
					// Skip inserted silence
					//------------------------------
					curPos = nextPos;
					pClusterTok = m_TokList.GetNext( nextPos );
				}
				if( nextPos != NULL )
				{
					//-----------------------------------
					// Skip quantifier string
					//-----------------------------------
					curPos = nextPos;
					pClusterTok = m_TokList.GetNext( nextPos );
				}
				cWordCount--;
			}
		}
	}

	*pClusterPos = curPos;
	return cWordCount;
} /* CFrontend::DoIntegerTemplate */






/*****************************************************************************
* CFrontend::GetSentenceTokens *
*------------------------------*
*   Description:
*   Collect Senence Enum tokens.
*   Copy tokens into 'm_TokList' and token count into 'm_cNumOfWords'
*   S_FALSE return means no more input sentences.+++
*       
********************************************************************** MC ***/
HRESULT CFrontend::GetSentenceTokens( DIRECTION eDirection )
{
    SPDBG_FUNC( "CFrontend::GetSentenceTokens" );
    HRESULT        eHR = S_OK;
    bool			fLastItem = false;
    IEnumSENTITEM  *pItemizer;
    TTSSentItem    sentItem;
    long           tokenIndex;
    CFEToken       *pWordTok;
    bool           lastWasTerm = false;
	bool			lastWasSil = true;
	TUNE_TYPE		defaultTune = PHRASE_BOUNDARY;
	long			cNumOfItems, cCurItem, cCurWord;
	SPLISTPOS		clusterPos, tempPos;

    m_cNumOfWords = 0;
    pWordTok = NULL;
	clusterPos = NULL;

    if ( eDirection == eNEXT )
    {
        eHR = m_pEnumSent->Next( &pItemizer );
    }
    else
    {
        eHR = m_pEnumSent->Previous( &pItemizer );
    }


    if( eHR == S_OK )
    {
        //--------------------------------------------
        // There's still another sentence to speak
        //--------------------------------------------
        tokenIndex = 0;

		CItemList& ItemList = ((CSentItemEnum*)pItemizer)->_GetList(); 
		cNumOfItems = (ItemList.GetCount()) -1;
		cCurItem = 0;
		
        //------------------------------------
        // Collect all sentence tokens
        //------------------------------------
        while( (eHR = pItemizer->Next( &sentItem )) == S_OK )
        {
			clusterPos = NULL;
            cCurWord = sentItem.ulNumWords;
            for ( ULONG i = 0; i < sentItem.ulNumWords; i++ )
            {
				//------------------------------
				// Always have a working token
				//------------------------------
				if( pWordTok == NULL )
				{
					pWordTok = new CFEToken;
				}
				if( pWordTok )
				{

					if( sentItem.pItemInfo->Type & eWORDLIST_IS_VALID )
					{
						//------------------------------------------
						// Get tag values (vol, rate, pitch, etc.)
						//------------------------------------------
						GetItemControls( sentItem.Words[i].pXmlState, pWordTok );

						//------------------------------------------
						// 
						//------------------------------------------
						
						//-------------------------------------
						// Switch on token type
						//-------------------------------------
						switch ( sentItem.Words[i].pXmlState->eAction )
						{
							case SPVA_Speak:
							case SPVA_SpellOut:
							{
								//----------------------------------
								// Speak this token
								//----------------------------------
								pWordTok->tokLen = sentItem.Words[i].ulWordLen;
								if( pWordTok->tokLen > (TOKEN_LEN_MAX -1) )
								{
									//-----------------------------------
									// Clip to max string length
									//-----------------------------------
									pWordTok->tokLen = TOKEN_LEN_MAX -1;
								}
								//--------------------------
								// Copy token string
								// Append C-string delimiter
								//--------------------------
								memcpy( &pWordTok->tokStr[0], &sentItem.Words[i].pWordText[0], 
										pWordTok->tokLen * sizeof(WCHAR) );
								pWordTok->tokStr[pWordTok->tokLen] = 0;        //string delimiter

								pWordTok->phon_Len = IPA_to_Allo( sentItem.Words[i].pWordPron, 
																	pWordTok->phon_Str );
								pWordTok->POScode = sentItem.Words[i].eWordPartOfSpeech;
								pWordTok->m_posClass = GetPOSClass( pWordTok->POScode );
								pWordTok->srcPosition = sentItem.ulItemSrcOffset;
								pWordTok->srcLen = sentItem.ulItemSrcLen;
								pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
								pWordTok->m_PitchRangeScale = m_CurPitchRange;
								pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;

								//----------------------------------
								// Advance to next token
								//----------------------------------
								tempPos = m_TokList.AddTail( pWordTok );
								if( clusterPos == NULL )
								{
									//--------------------------------------
									// Remember where currentitem started
									//--------------------------------------
									clusterPos = tempPos;
								}
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = false;
								lastWasSil = false;
								
								break;
							}

							case SPVA_Silence:
							{
								(void)InsertSilenceAtTail( pWordTok, &sentItem, sentItem.Words[i].pXmlState->SilenceMSecs );
								pWordTok->m_SilenceSource = SIL_XML;
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = false;
								break;
							}

							case SPVA_Pronounce:
							{
								pWordTok->tokStr[0] = 0;        // There's no orth for Pron types
								pWordTok->tokLen = 0;
								pWordTok->phon_Len = IPA_to_Allo( sentItem.Words[i].pXmlState->pPhoneIds, pWordTok->phon_Str );
								pWordTok->POScode = sentItem.Words[i].eWordPartOfSpeech;
								pWordTok->m_posClass = GetPOSClass( pWordTok->POScode );
								pWordTok->srcPosition = sentItem.ulItemSrcOffset;
								pWordTok->srcLen = sentItem.ulItemSrcLen;
								pWordTok->m_PitchBaseOffs = m_CurPitchOffs;
								pWordTok->m_PitchRangeScale = m_CurPitchRange;
								pWordTok->m_ProsodyDurScale = m_RateRatio_PROSODY;

								//----------------------------------
								// Advance to next token
								//----------------------------------
								tempPos = m_TokList.AddTail( pWordTok );
								if( clusterPos == NULL )
								{
									//--------------------------------------
									// Remember where currentitem started
									//--------------------------------------
									clusterPos = tempPos;
								}
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = false;
								lastWasSil = false;
								break;
							}

							case SPVA_Bookmark:
							{
								BOOKMARK_ITEM   *pMarker;
								//-------------------------------------------------
								// Create bookmark list if it's not already there
								//-------------------------------------------------
								if( pWordTok->pBMObj == NULL )
								{
									pWordTok->pBMObj = new CBookmarkList;
								}
								if( pWordTok->pBMObj )
								{
									//--------------------------------------------------------
									// Allocate memory for bookmark string
									// (add 1 to length for string delimiter)
									//--------------------------------------------------------
									pWordTok->tokLen = sentItem.Words[i].ulWordLen;
									pMarker = new BOOKMARK_ITEM;
									if (pMarker)
									{
										//----------------------------------------
										// We'll need the text ptr and length
										// when this bookmark event gets posted
										//----------------------------------------
										pMarker->pBMItem = (LPARAM)sentItem.pItemSrcText;
										//--- Punch NULL character into end of bookmark string for Event...
										WCHAR* pTemp = (WCHAR*) sentItem.pItemSrcText + sentItem.ulItemSrcLen;
										*pTemp = 0;

										//-----------------------------------
										// Add this bookmark to list
										//-----------------------------------
										pWordTok->pBMObj->m_BMList.AddTail( pMarker );
									}
								}
								break;
							}

							default:
							{
								SPDBG_DMSG1( "Unknown SPVSTATE eAction: %d\n", sentItem.Words[i].pXmlState->eAction );
								break;
							}
						}
					}
					else
					{
						//-----------------------------
						// Maybe token is punctuation
						//-----------------------------
						if ( fIsPunctuation(sentItem) )
						{
							TUNE_TYPE    bType = NULL_BOUNDARY;

							switch ( sentItem.pItemInfo->Type )
							{
								case eCOMMA:
								case eSEMICOLON:
								case eCOLON:
									if( !lastWasSil )
									{
										bType = PHRASE_BOUNDARY;
									}
									break;
								case ePERIOD:
									if( fLastItem )
									{
										bType = DECLAR_BOUNDARY;
									}
									else
									{
										defaultTune = DECLAR_BOUNDARY;
									}
									break;
								case eQUESTION:
									if( fLastItem )
									{
										bType = YN_QUEST_BOUNDARY;
									}
									else
									{
										defaultTune = YN_QUEST_BOUNDARY;
									}
									break;
								case eEXCLAMATION:
									if( fLastItem )
									{
										bType = EXCLAM_BOUNDARY;
									}
									else
									{
										defaultTune = EXCLAM_BOUNDARY;
									}
									break;
							}

							if( (bType != NULL_BOUNDARY) && (tokenIndex > 0) )
							{
								pWordTok->m_TuneBoundaryType = bType;

								pWordTok->phon_Len = 1;
								pWordTok->phon_Str[0] = _SIL_;
								pWordTok->srcPosition = sentItem.ulItemSrcOffset;
								pWordTok->srcLen = sentItem.ulItemSrcLen;
								pWordTok->tokStr[0] = sentItem.pItemSrcText[0]; // punctuation
								pWordTok->tokStr[1] = 0;                       // delimiter
								pWordTok->tokLen = 1;
								pWordTok->m_SilenceSource = SIL_Term;
								pWordTok->m_TermSil = 0;
								//----------------------------------
								// Advance to next token
								//----------------------------------
								tempPos = m_TokList.AddTail( pWordTok );
								if( clusterPos == NULL )
								{
									//--------------------------------------
									// Remember where currentitem started
									//--------------------------------------
									clusterPos = tempPos;
								}
								pWordTok = NULL;         // Get a new ptr next time
								tokenIndex++;
								lastWasTerm = true;
								lastWasSil = true;
							}
						}
						else
						{
							switch ( sentItem.pItemInfo->Type )
							{
								//case eSINGLE_QUOTE:
								case eDOUBLE_QUOTE:
									if( StateQuoteProsody( pWordTok, &sentItem, (!fLastItem) & (!lastWasSil) ) )
									{
										if( (!fLastItem) & (!lastWasSil) )
										{
											pWordTok = NULL;         // Get a new ptr next time
											tokenIndex++;
										}
										lastWasTerm = false;
										lastWasSil = true;
									}
									break;

								case eOPEN_PARENTHESIS:
								case eOPEN_BRACKET:
								case eOPEN_BRACE:
									if( StartParenProsody( pWordTok, &sentItem, !fLastItem ) )
									{
										if( !fLastItem )
										{
											pWordTok = NULL;         // Get a new ptr next time
											tokenIndex++;
										}
										lastWasTerm = false;
										lastWasSil = true;
									}
									break;

								case eCLOSE_PARENTHESIS:
								case eCLOSE_BRACKET:
								case eCLOSE_BRACE:
									if( EndParenProsody( pWordTok, &sentItem, !fLastItem ) )
									{
										if( !fLastItem )
										{
											pWordTok = NULL;         // Get a new ptr next time
											tokenIndex++;
										}
										lastWasTerm = false;
										lastWasSil = true;
									}
									break;
							}
						}
					}
				}    
				else
				{
					eHR = E_OUTOFMEMORY;
					break;
				}
				if( --cCurWord == 0 )
				{
					cCurItem++;
				}
				if( cCurItem == cNumOfItems )
				{
					fLastItem = true;
				}
			}
			
			//-------------------------------------
			// Tag special word clusters
			//-------------------------------------
			ProsodyTemplates( clusterPos, &sentItem );
			
		}

        pItemizer->Release();

        //------------------------------------------------------
        // Make sure sentence ends on termination
        //------------------------------------------------------
        if( !lastWasTerm )
        {
            //------------------------
            // Add a comma
            //------------------------
            if( pWordTok == NULL )
            {
                pWordTok = new CFEToken;
            }
            if( pWordTok )
            {
                pWordTok->m_TuneBoundaryType = defaultTune;
				pWordTok->m_BoundarySource = BND_ForcedTerm;
				pWordTok->m_SilenceSource = SIL_Term;
                pWordTok->phon_Len = 1;
                pWordTok->phon_Str[0] = _SIL_;
                pWordTok->srcPosition = sentItem.ulItemSrcOffset;
                pWordTok->srcLen = sentItem.ulItemSrcLen;
                pWordTok->tokStr[0] = '.';      // punctuation
                pWordTok->tokStr[1] = 0;                   // delimiter
                pWordTok->tokLen = 1;
               // pWordTok->m_BoundarySource = bndSource;
                //----------------------------------
                // Advance to next token
                //----------------------------------
				tempPos = m_TokList.AddTail( pWordTok );
				if( clusterPos == NULL )
				{
					//--------------------------------------
					// Remember where current item started
					//--------------------------------------
					clusterPos = tempPos;
				}
                pWordTok = NULL;         // Get a new ptr next time
                tokenIndex++;
            }
            else
            {
                //----------------------------------
                // Bail-out or we'll crash
                //----------------------------------
                eHR = E_OUTOFMEMORY;
            }
        }
        m_cNumOfWords = tokenIndex;
        if( eHR == S_FALSE )
        {
            //----------------------------------
            // Return only errors 
            //----------------------------------
            eHR = S_OK;
        }
    }
	else
	{
		eHR = eHR;		// !!!!
	}

    //-------------------------------
    // Cleanup memory allocation
    //-------------------------------
    if( pWordTok != NULL )
    {
        delete pWordTok;
    }

	//---------------------------------------------------
	// Get sentence position and length for SAPI events
	//---------------------------------------------------
	CalcSentenceLength();

    return eHR;
} /* CFrontend::GetSentenceTokens */





/*****************************************************************************
* CFrontend::CalcSentenceLength *
*-------------------------------*
*   Description:
*   Loop thru token list and sum the source char count.
*       
********************************************************************** MC ***/
void CFrontend::CalcSentenceLength()
{
	long		firstIndex, lastIndex, lastLen;
	bool		firstState;
	SPLISTPOS	listPos;
    CFEToken    *pWordTok, *pFirstTok = NULL;

	//---------------------------------------------
	// Find the 1st and last words in sentence
	//---------------------------------------------
	firstIndex = lastIndex = lastLen = 0;
	firstState = true;
	listPos = m_TokList.GetHeadPosition();
	while( listPos )
	{
		pWordTok = m_TokList.GetNext( listPos );
		//-------------------------------------------
		// Look at at displayable words only
		//-------------------------------------------
		if( pWordTok->srcLen > 0 )
		{
			if( firstState )
			{
				firstState = false;
				firstIndex = pWordTok->srcPosition;
				pFirstTok = pWordTok;
			}
			else
			{
				lastIndex = pWordTok->srcPosition;
				lastLen = pWordTok->srcLen;
			}
		}
	}
	//--------------------------------------------------
	// Calculate sentence length for head list item
	//--------------------------------------------------
	if( pFirstTok )
	{
		pFirstTok->sentencePosition = firstIndex;						// Sentence starts here...
		pFirstTok->sentenceLen = (lastIndex - firstIndex) + lastLen;	// ...and this is the length
	}
}



/*****************************************************************************
* CFrontend::DisposeUnits *
*-------------------------*
*   Description:
*   Delete memory allocated to 'm_pUnits'.
*   Clean-up memory for Bookmarks 
*       
********************************************************************** MC ***/
void CFrontend::DisposeUnits( )
{
    SPDBG_FUNC( "CFrontend::DisposeUnits" );
    ULONG   unitIndex;

    if( m_pUnits )
    {
        //-----------------------------------------
        // Clean-up Bookmark memory allocation
        //-----------------------------------------

        for( unitIndex = m_CurUnitIndex; unitIndex < m_unitCount; unitIndex++)
        {
            if( m_pUnits[unitIndex].pBMObj != NULL )
            {
                //---------------------------------------
                // Dispose bookmark list
                //---------------------------------------
                delete m_pUnits[unitIndex].pBMObj;
                m_pUnits[unitIndex].pBMObj = NULL;
            }
        }
        delete m_pUnits;
        m_pUnits = NULL;
    }
} /* CFrontend::DisposeUnits */



/*****************************************************************************
* CFrontend::ParseNextSentence *
*------------------------------*
*   Description:
*   Fill 'm_pUnits' array with next sentence.
*   If there's no more input text, 
*      return with 'm_SpeechState' set to SPEECH_DONE +++
*       
********************************************************************** MC ***/
HRESULT CFrontend::ParseSentence( DIRECTION eDirection )
{
    SPDBG_FUNC( "CFrontend::ParseNextSentence" );
    HRESULT hr = S_OK;
   
    //-----------------------------------------------------
    // If there's a previous unit array, free its memory
    //-----------------------------------------------------
    DisposeUnits();
    m_CurUnitIndex = 0;
    m_unitCount = 0;
    DeleteTokenList();
    m_pUnits = NULL;
    //-----------------------------------------------------
    // If there's a previous allo array, free its memory
    //-----------------------------------------------------
    if( m_pAllos )
    {
        delete m_pAllos;
        m_pAllos = NULL;
    }
    
    //-----------------------------------------------------
    // Fill token array with next sentence
    // Skip empty sentences.
    // NOTE: includes non-speaking items
    //-----------------------------------------------------
    do
    {
        hr = GetSentenceTokens( eDirection );
    } while( (hr == S_OK) && (m_cNumOfWords == 0) );

    if( hr == S_OK )
    {
        //--------------------------------------------
        // Prepare word emphasis
        //--------------------------------------------
		DoWordAccent();

        //--------------------------------------------
        // Word level prosodic lables
        //--------------------------------------------
        DoPhrasing();
        ToBISymbols();

        //--------------------------------------------
        // Convert tokens to allo list
        //--------------------------------------------
         m_pAllos = new CAlloList;
        if (m_pAllos == NULL)
        {
            //-----------------------
            // Out of memory
            //-----------------------
            hr = E_FAIL;
        }
        if(  SUCCEEDED(hr) )
        {
            //--------------------------------
            // Convert word to allo strteam
            //-------------------------------
            TokensToAllo( &m_TokList, m_pAllos );

            //----------------------------
            // Tag sentence syllables
            //----------------------------
            m_SyllObj.TagSyllables( m_pAllos );

           //--------------------------------------------
            // Dispose token array, no longer needed
            //--------------------------------------------
            DeleteTokenList();

            //--------------------------------------------
			// Create the unit array
			// NOTE: 
            //--------------------------------------------
			hr = UnitLookahead ();
			if( hr == S_OK )
			{
				//--------------------------------------------
				// Compute allo durations
				//--------------------------------------------
                UnitToAlloDur( m_pAllos, m_pUnits );
				m_DurObj.AlloDuration( m_pAllos, m_RateRatio_API );
				//--------------------------------------------
				// Modulate allo pitch
				//--------------------------------------------
				m_PitchObj.AlloPitch( m_pAllos, m_BasePitch, m_PitchRange );
			}

			
        }
        if( hr == S_OK )
        {
			AlloToUnitPitch( m_pAllos, m_pUnits );
        }
    }

    if( FAILED(hr) )
    {
        //------------------------------------------
        // Either the input text is dry or we failed.
        // Try to fail gracefully
        //      1 - Clean up memory
        //      2 - End the speech
        //------------------------------------------
        if( m_pAllos )
        {
            delete m_pAllos;
			m_pAllos = 0;
        }
        DeleteTokenList();
        DisposeUnits();
        m_SpeechState = SPEECH_DONE;
    }
    else if( hr == S_FALSE )
    {
        //---------------------------------
        // No more input text
        //---------------------------------
        hr = S_OK;
        m_SpeechState = SPEECH_DONE;
    }


    return hr;
} /* CFrontend::ParseNextSentence */



/*****************************************************************************
* CFrontend::UnitLookahead *
*--------------------------*
*   Description:
*       
********************************************************************** MC ***/
HRESULT CFrontend::UnitLookahead ()
{
    SPDBG_FUNC( "CFrontend::UnitLookahead" );
    HRESULT		hr = S_OK;
	UNIT_CVT	*pPhon2Unit = NULL;
	ULONG		i;

    m_unitCount = m_pAllos->GetCount();

    m_pUnits = new UNITINFO[m_unitCount];
    if( m_pUnits )
    {
		pPhon2Unit = new UNIT_CVT[m_unitCount];
		if( pPhon2Unit )
		{
            //--------------------------------------------
            // Convert allo list to unit array
            //--------------------------------------------
            memset( m_pUnits, 0, m_unitCount * sizeof(UNITINFO) );
            hr = AlloToUnit( m_pAllos, m_pUnits );

			if( SUCCEEDED(hr) )
			{
				//--------------------------------------------
				// Initialize UNIT_CVT
				//--------------------------------------------
				for( i = 0; i < m_unitCount; i++ )
				{
					pPhon2Unit[i].PhonID = m_pUnits[i].PhonID;
					pPhon2Unit[i].flags = m_pUnits[i].flags;
				}
				//--------------------------------------------
				// Compute triphone IDs
				//--------------------------------------------
				hr = m_pVoiceDataObj->GetUnitIDs( pPhon2Unit, m_unitCount );

				if( SUCCEEDED(hr) )
				{
					//--------------------------------------------
					// Copy UNIT_CVT to UNITINFO
					//--------------------------------------------
					for( i = 0; i < m_unitCount; i++ )
					{
						m_pUnits[i].UnitID      = pPhon2Unit[i].UnitID;
						m_pUnits[i].SenoneID    = pPhon2Unit[i].SenoneID;
						m_pUnits[i].duration    = pPhon2Unit[i].Dur;
						m_pUnits[i].amp         = pPhon2Unit[i].Amp;
						m_pUnits[i].ampRatio    = pPhon2Unit[i].AmpRatio;
						strcpy( m_pUnits[i].szUnitName, pPhon2Unit[i].szUnitName );
					}
				}
				else
				{
					//-----------------------
					// Can't get unit ID's
					//-----------------------
					delete m_pUnits;
					m_pUnits = NULL;
				}
			}
			else
			{
				//-----------------------
				// Can't convert allos
				//-----------------------
				delete m_pUnits;
				m_pUnits = NULL;
			}
		}
		else
		{
			//-----------------------
			// Out of memory
			//-----------------------
			delete m_pUnits;
			m_pUnits = NULL;
			hr = E_FAIL;
		}
    }
	else
	{
        //-----------------------
        // Out of memory
        //-----------------------
        hr = E_FAIL;
	}

	//------------------------------
	// Cleanup before exit
	//------------------------------
    if( pPhon2Unit )
    {
        delete pPhon2Unit;
    }


	return hr;
} /* CFrontend::UnitLookahead */


/*****************************************************************************
* CFrontend::UnitToAlloDur *
*--------------------------*
*   Description:
*       
********************************************************************** MC ***/
void    CFrontend::UnitToAlloDur( CAlloList *pAllos, UNITINFO *pu )
{
    SPDBG_FUNC( "CFrontend::UnitToAlloDur" );
    CAlloCell   *pCurCell;
    
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
        pCurCell->m_UnitDur = pu->duration;
        pu++;
		pCurCell = pAllos->GetNextCell();
    }
} /* CFrontend::UnitToAlloDur */



/*****************************************************************************
* CFrontend::AlloToUnitPitch *
*----------------------------*
*   Description:
*       
********************************************************************** MC ***/
void    CFrontend::AlloToUnitPitch( CAlloList *pAllos, UNITINFO *pu )
{
    SPDBG_FUNC( "CFrontend::AlloToUnitPitch" );
    ULONG       k;
    CAlloCell   *pCurCell;
    
	pCurCell = pAllos->GetHeadCell();
    while( pCurCell )
    {
        pu->duration = pCurCell->m_ftDuration;
        for( k = 0; k < pu->nKnots; k++ )
        {
            pu->pTime[k]    = pCurCell->m_ftTime[k] * m_SampleRate;
            pu->pF0[k]      = pCurCell->m_ftPitch[k];
            pu->pAmp[k]     = pu->ampRatio;
        }
        pu++;
		pCurCell = pAllos->GetNextCell();
    }
} /* CFrontend::AlloToUnitPitch */


/*****************************************************************************
* CAlloList::DeleteTokenList *
*----------------------------*
*   Description:
*   Remove every item in link list.
*       
********************************************************************** MC ***/
void CFrontend::DeleteTokenList()
{
    SPDBG_FUNC( "CFrontend::DeleteTokenList" );
    CFEToken   *pTok;

    while( !m_TokList.IsEmpty() )
    {
        pTok = (CFEToken*)m_TokList.RemoveHead();
        delete pTok;
    }

} /* CFrontend::DeleteTokenList */



/*****************************************************************************
* AdjustQuestTune *
*-----------------*
*   Description:
*   Adjust termination for either YN or WH sentence tune.
*       
********************************************************************** MC ***/
static void AdjustQuestTune( CFEToken *pTok, bool fIsYesNo )
{
    SPDBG_FUNC( "AdjustQuestTune" );
    if ( pTok->m_TuneBoundaryType > NULL_BOUNDARY )
    {
	if( (pTok->m_TuneBoundaryType == YN_QUEST_BOUNDARY) ||
        (pTok->m_TuneBoundaryType == WH_QUEST_BOUNDARY) )
		{
		//------------------------------------
		// Is this a yes/no question phrase
		//------------------------------------
		if( fIsYesNo )
			{
			//------------------------------------------
			// Put out a final yes/no question marker
			//------------------------------------------
			pTok->m_TuneBoundaryType = YN_QUEST_BOUNDARY;
			pTok->m_BoundarySource = BND_YNQuest;
			}
		else 
			{
		
			//------------------------------------------------------------------------
			// Use declarative phrase marker (for WH questions)
			//------------------------------------------------------------------------
			pTok->m_TuneBoundaryType = WH_QUEST_BOUNDARY;
			pTok->m_BoundarySource = BND_WHQuest;
			}
		}
    }
} /* AdjustQuestTune */


typedef enum
{
	p_Interj,
    P_Adv,
	P_Verb,
	P_Adj,
    P_Noun,
	PRIORITY_SIZE,
} CONTENT_PRIORITY;

#define	NO_POSITION	-1


/*****************************************************************************
* CFrontend::ExclamEmph *
*-----------------------*
*   Description:
*   Find a likely word to emph if sentence has exclamation
*       
********************************************************************** MC ***/
void    CFrontend::ExclamEmph()
{
    SPDBG_FUNC( "CFrontend::ExclamEmph" );
    CFEToken        *pCur_Tok;
	SPLISTPOS		listPos, targetPos, curPos, contentPos[PRIORITY_SIZE];
	long			cContent, cWords;
	long			i;

	for(i = 0; i < PRIORITY_SIZE; i++ )
	{
		contentPos[i] = (SPLISTPOS)NO_POSITION;
	}

	listPos = m_TokList.GetTailPosition();
	pCur_Tok = m_TokList.GetNext( listPos );

	//---------------------------------------------------
	// First, check last token fors an exclamation
	//---------------------------------------------------
	if( pCur_Tok->m_TuneBoundaryType == EXCLAM_BOUNDARY )
	{
		//-----------------------------------------------------
		// Then, see if there's only one content word
		// in the sentence
		//-----------------------------------------------------
		cContent = cWords = 0;
		listPos = m_TokList.GetHeadPosition();
		while( listPos )
		{
			curPos = listPos;
			pCur_Tok = m_TokList.GetNext( listPos );
			if( pCur_Tok->m_posClass == POS_CONTENT )
			{
				cContent++;
				cWords++;
				if( cContent == 1)
				{
					targetPos = curPos;
				}
				//--------------------------------------------------------
				// Fill the famous Azara Content Prominence Hierarchy (ACPH)
				//--------------------------------------------------------
				if( (pCur_Tok->POScode == MS_Noun) && (contentPos[P_Noun] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Noun] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Verb) && (contentPos[P_Verb] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Verb] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Adj) && (contentPos[P_Adj] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Adj] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Adv) && (contentPos[P_Adv] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[P_Adv] = curPos;
				}
				else if( (pCur_Tok->POScode == MS_Interjection) && (contentPos[p_Interj] == (SPLISTPOS)NO_POSITION) )
				{
					contentPos[p_Interj] = curPos;
				}
			}
			else if( pCur_Tok->m_posClass == POS_FUNC )
			{
				cWords++;
				if( cWords == 1)
				{
					targetPos = curPos;
				}
			}
		}

		//--------------------------------------------
		// If there's only one word or content word
		// then EMPHASIZE it
		//--------------------------------------------
		if( (cContent == 1) || (cWords == 1) )
		{
			pCur_Tok = m_TokList.GetNext( targetPos );
			pCur_Tok->user_Emph = 1;
		}
		else if( cContent > 1 )
		{
			for(i = 0; i < PRIORITY_SIZE; i++ )
			{
				if( contentPos[i] != (SPLISTPOS)NO_POSITION )
				{
					targetPos = contentPos[i];
					break;
				}
			}
			pCur_Tok = m_TokList.GetNext( targetPos );
			pCur_Tok->user_Emph = 1;
		}
	}
} //ExclamEmph



/*****************************************************************************
* CFrontend::DoWordAccent *
*-------------------------*
*   Description:
*   Prepare word for emphasis
*       
********************************************************************** MC ***/
void    CFrontend::DoWordAccent()
{
    SPDBG_FUNC( "CFrontend::DoWordAccent" );
    long            cNumOfWords;
    long            iCurWord;
    CFEToken        *pCur_Tok, *pNext_Tok, *pPrev_Tok, *pTempTok;
	SPLISTPOS		listPos;
    TUNE_TYPE       cur_Bnd, prev_Bnd;

    //-----------------------------
    // Initilize locals
    //-----------------------------
	cNumOfWords = m_TokList.GetCount();
	if( cNumOfWords > 0 )
	{
		ExclamEmph();
		prev_Bnd = PHRASE_BOUNDARY;			// Assume start of sentence
		//-------------------------------------
		// Fill the token pipeline
		//-------------------------------------
		listPos = m_TokList.GetHeadPosition();

		//-- Previous
		pPrev_Tok = NULL;

		//-- Current
		pCur_Tok = m_TokList.GetNext( listPos );

		//-- Next
		if( listPos )
		{
			pNext_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext_Tok = NULL;
		}

		//-----------------------------------
		// Step through entire word array
		//  (skip last)
		//-----------------------------------
		for( iCurWord = 0; iCurWord < (cNumOfWords -1); iCurWord++ )
		{
			cur_Bnd = pCur_Tok->m_TuneBoundaryType;
			if( pCur_Tok->user_Emph > 0 )
			{
				//-----------------------------------
				// Current word is emphasized
				//-----------------------------------
				if( prev_Bnd == NULL_BOUNDARY ) 
				{
					pTempTok = new CFEToken;
					if( pTempTok )
					{
						pTempTok->user_Break	  = EMPH_HESITATION;
						pTempTok->m_TuneBoundaryType = NULL_BOUNDARY;
						pTempTok->phon_Len = 1;
						pTempTok->phon_Str[0] = _SIL_;
						pTempTok->srcPosition = pCur_Tok->srcPosition;
						pTempTok->srcLen = pCur_Tok->srcLen;
						pTempTok->tokStr[0] = 0;        // There's no orth for Break
						pTempTok->tokLen = 0;
						pTempTok->m_TermSil = 0;
						pTempTok->m_SilenceSource = SIL_Emph;
						pTempTok->m_DurScale	= 0;
						if( pPrev_Tok )
						{
							//pTempTok->m_DurScale = pPrev_Tok->m_DurScale;
							pTempTok->m_ProsodyDurScale = pPrev_Tok->m_ProsodyDurScale;
							pTempTok->user_Volume = pPrev_Tok->user_Volume;
						}
						else
						{
							//pTempTok->m_DurScale = 1.0f;
							pTempTok->m_ProsodyDurScale = 1.0f;
						}

						m_TokList.InsertBefore( m_TokList.FindIndex( iCurWord ), pTempTok );
						pCur_Tok = pTempTok;
						m_cNumOfWords++;
						cNumOfWords++;
						iCurWord++;
					}
				}
			}
			//------------------------------
			// Shift the token pipeline
			//------------------------------
			prev_Bnd	= cur_Bnd;
			pPrev_Tok	= pCur_Tok;
			pCur_Tok	= pNext_Tok;
			if( listPos )
			{
				pNext_Tok = m_TokList.GetNext( listPos );
			}
			else
			{	
				pNext_Tok = NULL;
			}

		}
	}
} /* CFrontend::DoWordAccent */



/*****************************************************************************
* CFrontend::DoPhrasing *
*-----------------------*
*   Description:
*   Insert sub-phrase boundaries into word token array
*       
********************************************************************** MC ***/
void    CFrontend::DoPhrasing()
{
    SPDBG_FUNC( "CFrontend::DoPhrasing" );
    long            iCurWord;
    CFEToken        *pCur_Tok, *pNext_Tok, *pNext2_Tok, *pNext3_Tok, *pTempTok, *pPrev_Tok;
    ENGPARTOFSPEECH  cur_POS, next_POS, next2_POS, next3_POS, prev_POS;
    bool            fNext_IsPunct, fNext2_IsPunct, fNext3_IsPunct;
    bool            fIsYesNo, fMaybeWH, fHasDet, fInitial_Adv, fIsShortSent, fIsAlphaWH;
    TUNE_TYPE       cur_Bnd, prev_Punct;
    long            punctDistance;
    long            cNumOfWords;
	SPLISTPOS		listPos;
    BOUNDARY_SOURCE   bndNum;
    ACCENT_SOURCE	  accNum;
   
    //-----------------------------
    // Initialize locals
    //-----------------------------
	cNumOfWords = m_TokList.GetCount();
	if( cNumOfWords > 0 )
	{
		cur_Bnd			= NULL_BOUNDARY;
		prev_POS		= MS_Unknown;
		prev_Punct		= PHRASE_BOUNDARY;			// Assume start of sentence
		punctDistance	= 0;						// To quiet the compiler...
		fIsYesNo		= fMaybeWH = fHasDet = fIsAlphaWH = false;    // To quiet the compiler...
		fMaybeWH		= false;
		fInitial_Adv	= false;
		if (cNumOfWords <= 9) 
		{
			fIsShortSent = true;
		}
		else
		{
			fIsShortSent = false;
		}
    
		//-------------------------------------
		// Fill the token pipeline
		//-------------------------------------
		listPos = m_TokList.GetHeadPosition();
		//-- Previous
		pPrev_Tok = NULL;
		//-- Current
		pCur_Tok = m_TokList.GetNext( listPos );
		//-- Next
		if( listPos )
		{
			pNext_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext_Tok = NULL;
		}
		//-- Next 2
		if( listPos )
		{
			pNext2_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext2_Tok = NULL;
		}
		//-- Next 3
		if( listPos )
		{
			pNext3_Tok = m_TokList.GetNext( listPos );
		}
		else
		{
			pNext3_Tok = NULL;
		}

		//-----------------------------------
		// Step through entire word array
		//  (skip last)
		//-----------------------------------
		for( iCurWord = 0; iCurWord < (cNumOfWords -1); iCurWord++ )
		{
			bndNum = BND_NoSource;
			accNum = ACC_NoSource;

			if( (prev_Punct > NULL_BOUNDARY) && (prev_Punct < SUB_BOUNDARY_1) )
			{
				punctDistance = 1;
				fIsYesNo = true;
				fMaybeWH = false;
				fHasDet = false;
				fIsAlphaWH = false;
			}
			else
			{
				punctDistance++;
			}
			//------------------------------------
			// Process new word
			//------------------------------------
			cur_POS = pCur_Tok->POScode;
			cur_Bnd = NULL_BOUNDARY;
			//------------------------------------
			// Don't depend on POS to detect 
			// "WH" question
			//------------------------------------
			if( ((pCur_Tok->tokStr[0] == 'W') || (pCur_Tok->tokStr[0] == 'w')) &&
				((pCur_Tok->tokStr[1] == 'H') || (pCur_Tok->tokStr[1] == 'h')) )
			{
				fIsAlphaWH = true;
			}
			else
			{
				fIsAlphaWH = false;
			}
        
			//------------------------------------
			// Look ahead to NEXT word
			//------------------------------------
			next_POS = pNext_Tok->POScode;
			if( pNext_Tok->m_TuneBoundaryType != NULL_BOUNDARY )
			{
				fNext_IsPunct = true;
			}
			else
			{
				fNext_IsPunct = false;
			}
        
			//------------------------------------
			// Look ahead 2 positions
			//------------------------------------
			if( pNext2_Tok )
			{
				next2_POS = pNext2_Tok->POScode;
				if( pNext2_Tok->m_TuneBoundaryType != NULL_BOUNDARY )
				{
					fNext2_IsPunct = true;
				}
				else
				{
					fNext2_IsPunct = false;
				}
			}
			else
			{
				next2_POS = MS_Unknown;
				fNext2_IsPunct = false;
			}
        
			//------------------------------------
			// Look ahead 3 positions
			//------------------------------------
			if( pNext3_Tok )
			{
				next3_POS = pNext3_Tok->POScode;
				if( pNext3_Tok->m_TuneBoundaryType != NULL_BOUNDARY )
				{
					fNext3_IsPunct = true;
				}
				else
				{
					fNext3_IsPunct = false;
				}
			}
			else
			{
				next3_POS = MS_Unknown;
				fNext3_IsPunct = false;
			}
        
			//------------------------------------------------------------------------
			// Is phrase a yes/no question?
			//------------------------------------------------------------------------
			if( punctDistance == 1 )
			{
				if( (cur_POS == MS_Interr) || (fIsAlphaWH) )
				{
					//---------------------------------
					// It's a "WH" question
					//---------------------------------
					fIsYesNo = false;
				}
				else if( (cur_POS == MS_Prep) || (cur_POS == MS_Conj) || (cur_POS == MS_CConj) )
				{
					fMaybeWH = true;
				}
			}
			else if( (punctDistance == 2) && (fMaybeWH) && 
					 ((cur_POS == MS_Interr) || (cur_POS == MS_RelPron) || (fIsAlphaWH)) )
			{
				fIsYesNo = false;
			}

			//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
			// SUB_BOUNDARY_1: Insert boundary after sentence-initial adverb
			//
			// Reluctantly __the cat sat on the mat.
			//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
			if( fInitial_Adv )
			{
				cur_Bnd = SUB_BOUNDARY_1;
				fInitial_Adv = false;
				bndNum = BND_PhraseRule1;
				accNum = ACC_PhraseRule1;
			}
			else
			{

				if( (punctDistance == 1) && 
					(cur_POS == MS_Adv) && (next_POS == MS_Det) )
				// include
				//LEX_SUBJPRON // he
				//LEX_DPRON  // this
				//LEX_IPRON  // everybody
				//NOT LEX_PPRON  // myself 
				{
					fInitial_Adv = true;
				}
				else 
				{
					fInitial_Adv = false;
				}

				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before coordinating conjunctions
				// The cat sat on the mat __and cleaned his fur.
				//
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				if( (cur_POS == MS_CConj) &&
					(fHasDet == false) &&
					(punctDistance > 3) &&
					(next2_POS != MS_Conj) )
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule2;
					accNum = ACC_PhraseRule2;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before adverb
				// The cat sat on the mat __reluctantly.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if(    (cur_POS == MS_Adv) && 
					(punctDistance > 4) && 
					(next_POS != MS_Adj) )
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule3;
					accNum = ACC_PhraseRule3;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary after object pronoun
				// The cat sat with me__ on the mat.
				//
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (prev_POS == MS_ObjPron) && (punctDistance > 2))
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule4;
					accNum = ACC_PhraseRule4;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before subject pronoun or contraction
				// The cat sat on the mat _I see.
				// The cat sat on the mat _I'm sure.
				//
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ((cur_POS == MS_SubjPron) || (cur_POS == MS_Contr) ) && 
					(punctDistance > 3) && (prev_POS != MS_RelPron) && (prev_POS != MS_Conj))
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule5;
					accNum = ACC_PhraseRule5;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_2:Insert boundary before interr
				// The cat sat on the mat _how odd.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (cur_POS == MS_Interr) && (punctDistance > 4)  )
				{
					cur_Bnd = SUB_BOUNDARY_2;
					bndNum = BND_PhraseRule6;
					accNum = ACC_PhraseRule6;
				}
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after subject noun phrase followed by aux verb 
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary before vaux after noun phrase
				// The gray cat __should sit on the mat.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (punctDistance > 2) && 
					( ((prev_POS == MS_Noun) || (prev_POS == MS_Verb)) && (prev_POS != MS_VAux) ) && 
					(cur_POS == MS_VAux)
					)
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule7;
					accNum = ACC_PhraseRule7;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after MS_Interr
				// The gray cat __should sit on the mat.
				// SEE ABOVE???
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				/*else if( (prev_POS == MS_Noun) && ((next_POS != MS_RelPron) && 
					(next_POS != MS_VAux) && (next_POS != MS_RVAux) && 
					(next2_POS != MS_VAux) && (next2_POS != MS_RVAux)) && 
					(punctDistance > 4) && 
					((cur_POS == MS_VAux) || (cur_POS == MS_RVAux)))
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule8;
					accNum = ACC_PhraseRule8;
				}*/
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after MS_Interr
				// The cat sat on the mat _how odd.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( (prev_POS == MS_Noun) && (next_POS != MS_RelPron) && 
					(next_POS != MS_Conj) &&  
					(next_POS != MS_CConj) && (punctDistance > 3)  && (cur_POS == MS_Verb))
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule9;
					accNum = ACC_PhraseRule9;
				}
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_3:Insert boundary after MS_Interr
				// The cat sat on the mat _how odd.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				/*else if( (prev_POS == MS_Noun) && (cur_POS != MS_RelPron) && 
					(cur_POS != MS_RVAux) && (cur_POS != MS_CConj) && 
					(cur_POS != MS_Conj) && (punctDistance > 2) && 
					((punctDistance > 2) || (fIsShortSent)) && (cur_POS == MS_Verb))
				{
					cur_Bnd = SUB_BOUNDARY_3;
					bndNum = BND_PhraseRule10;
					accNum = ACC_PhraseRule10;
				}
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_4:Insert boundary before conjunction
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ((cur_POS == MS_Conj) && (punctDistance > 3) && 
					(fNext_IsPunct == false) && 
					(prev_POS != MS_Conj) && (prev_POS != MS_CConj) &&
					(fNext2_IsPunct == false)) ||
                
					( (prev_POS == MS_VPart) && (cur_POS != MS_Prep) && 
					(cur_POS != MS_Det) && 
					(punctDistance > 2) && 
					((cur_POS == MS_Noun) || (cur_POS == MS_Noun) || (cur_POS == MS_Adj))) ||
                
					( (cur_POS == MS_Interr) && (punctDistance > 2) && 
					(cur_POS == MS_SubjPron)) )
				{
					cur_Bnd = SUB_BOUNDARY_4;
					bndNum = BND_PhraseRule11;
					accNum = ACC_PhraseRule11;
				}
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_5:Insert boundary before relative pronoun
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ( (cur_POS == MS_RelPron) && (punctDistance >= 3)  && 
					(prev_POS != MS_Prep) && (next3_POS != MS_VAux) && 
					(next3_POS != MS_RVAux)  && 
					( (prev_POS == MS_Noun) || (prev_POS == MS_Verb) ) ) ||
                
					( (cur_POS == MS_Quant) && (punctDistance > 5) && 
					(prev_POS != MS_Adj) && (prev_POS != MS_Det) && 
					(prev_POS != MS_VAux) && (prev_POS != MS_RVAux) && 
					(prev_POS != MS_Det) && (next2_POS != MS_CConj) && 
					(fNext_IsPunct == false)))
				{
					cur_Bnd = SUB_BOUNDARY_5;
					bndNum = BND_PhraseRule12;
					accNum = ACC_PhraseRule12;
				}*/
            
            
            
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				// SUB_BOUNDARY_6:Silverman87-style, content/function tone group boundaries. 
				// Does trivial sentence-final function word look-ahead check.
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
				else if( ( (prev_POS == MS_Noun) || (prev_POS == MS_Verb) || (prev_POS == MS_Adj) || (prev_POS == MS_Adv)) 
					&& ((cur_POS != MS_Noun) && (cur_POS != MS_Verb) && (cur_POS != MS_Adj) && (cur_POS != MS_Adv))
					&& (fNext_IsPunct == false)) 
				{
					cur_Bnd = SUB_BOUNDARY_6;
					bndNum = BND_PhraseRule13;
					accNum = ACC_PhraseRule13;
				}
			}
			//------------------------------------------------------------------------
			// If phrasing was found, save it
			//------------------------------------------------------------------------
			if( (cur_Bnd != NULL_BOUNDARY) && (iCurWord > 0) &&
				//!(fNext_IsPunct) && 
				!(prev_Punct) &&
				(pCur_Tok->m_TuneBoundaryType == NULL_BOUNDARY) )
			{
				//pCur_Tok->m_TuneBoundaryType = cur_Bnd;
				pTempTok = new CFEToken;
				if( pTempTok )
				{
					pTempTok->m_TuneBoundaryType = cur_Bnd;
					pTempTok->phon_Len = 1;
					pTempTok->phon_Str[0] = _SIL_;
					pTempTok->srcPosition = pCur_Tok->srcPosition;
					pTempTok->srcLen = pCur_Tok->srcLen;
					pTempTok->tokStr[0] = '+';				// punctuation
					pTempTok->tokStr[1] = 0;                // delimiter
					pTempTok->tokLen = 1;
					pTempTok->m_TermSil = 0;
					pTempTok->m_DurScale	= 0;
					if( pPrev_Tok )
					{
						pPrev_Tok->m_AccentSource = accNum;
						pPrev_Tok->m_BoundarySource = bndNum;
						pPrev_Tok->m_Accent = K_LHSTAR;
					}
					pTempTok->m_SilenceSource = SIL_SubBound;
					if( pPrev_Tok )
					{
						//pTempTok->m_DurScale = pPrev_Tok->m_DurScale;
						pTempTok->m_ProsodyDurScale = pPrev_Tok->m_ProsodyDurScale;
						pTempTok->user_Volume = pPrev_Tok->user_Volume;
					}
					else
					{
						//pTempTok->m_DurScale = 1.0f;
						pTempTok->m_ProsodyDurScale = 1.0f;
					}

					m_TokList.InsertBefore( m_TokList.FindIndex( iCurWord ), pTempTok );
					pCur_Tok = pTempTok;
					m_cNumOfWords++;
					cNumOfWords++;
					iCurWord++;
				}
			}
			//-------------------------------
			// Process sentence punctuation
			//-------------------------------
			 AdjustQuestTune( pCur_Tok, fIsYesNo );
       
			//-------------------------------
			// Prepare for next word
			//-------------------------------
			prev_Punct = pCur_Tok->m_TuneBoundaryType;
			prev_POS = cur_POS;
			pPrev_Tok = pCur_Tok;

			//------------------------------
			// Shift the token pipeline
			//------------------------------
			pCur_Tok	= pNext_Tok;
			pNext_Tok	= pNext2_Tok;
			pNext2_Tok	= pNext3_Tok;
			if( listPos )
			{
				pNext3_Tok = m_TokList.GetNext( listPos );
			}
			else
			{	
				pNext3_Tok = NULL;
			}

			//------------------------------------------------------------------------
			// Keep track of when determiners encountered to help in deciding 
			// when to allow a strong 'and' boundary (SUB_BOUNDARY_2)
			//------------------------------------------------------------------------
			if( punctDistance > 2) 
			{
				fHasDet = false;
			}
			if( cur_POS == MS_Det )
			{
				fHasDet = true;
			}
		}
		//-------------------------------------
		// Process final sentence punctuation
		//-------------------------------------
		pCur_Tok = (CFEToken*)m_TokList.GetTail();
		AdjustQuestTune( pCur_Tok, fIsYesNo );
	}


} /* CFrontend::DoPhrasing */



/*****************************************************************************
* CFrontend::RecalcProsody *
*--------------------------*
*   Description:
*   In response to a real-time rate change, recalculate duration and pitch
*       
********************************************************************** MC ***/
void CFrontend::RecalcProsody()
{
    SPDBG_FUNC( "CFrontend::RecalcProsody" );
    UNITINFO*   pu;
    CAlloCell*  pCurCell;
    ULONG		k;

    //--------------------------------------------
    // Compute new allo durations
    //--------------------------------------------
	/*pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        //pCurCell->m_DurScale = 1.0;
		pCurCell = m_pAllos->GetNextCell();
    }*/
    m_DurObj.AlloDuration( m_pAllos, m_RateRatio_API );

    //--------------------------------------------
    // Modulate allo pitch
    //--------------------------------------------
    m_PitchObj.AlloPitch( m_pAllos, m_BasePitch, m_PitchRange );

    pu = m_pUnits;
	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        pu->duration = pCurCell->m_ftDuration;
        for( k = 0; k < pu->nKnots; k++ )

        {
            pu->pTime[k]    = pCurCell->m_ftTime[k] * m_SampleRate;
            pu->pF0[k]      = pCurCell->m_ftPitch[k];
            pu->pAmp[k]     = pu->ampRatio;
        }
        pu++;
		pCurCell = m_pAllos->GetNextCell();
    }
} /* CFrontend::RecalcProsody */


/*****************************************************************************
* CFrontend::NextData *
*---------------------*
*   Description:
*   This gets called from the backend when UNIT stream is dry.
*   Parse TOKENS to ALLOS to UNITS
*       
********************************************************************** MC ***/
HRESULT CFrontend::NextData( void **pData, SPEECH_STATE *pSpeechState )
{
    SPDBG_FUNC( "CFrontend::NextData" );
    bool    haveNewRate = false;
    HRESULT hr = S_OK;

    //-----------------------------------
    // First, check and see if SAPI has an action
    //-----------------------------------
	// Check for rate change
	long baseRateRatio;
	if( m_pOutputSite->GetActions() & SPVES_RATE )
	{
		hr = m_pOutputSite->GetRate( &baseRateRatio );
		if ( SUCCEEDED( hr ) )
		{
			if( baseRateRatio > SPMAX_VOLUME )
			{
				//--- Clip rate to engine maximum
				baseRateRatio = MAX_USER_RATE;
			}
			else if ( baseRateRatio < MIN_USER_RATE )
			{
				//--- Clip rate to engine minimum
				baseRateRatio = MIN_USER_RATE;
			}
			m_RateRatio_API = CntrlToRatio( baseRateRatio );
			haveNewRate = true;
		}
	}

    //---------------------------------------------
    // Async stop?
    //---------------------------------------------
    if( SUCCEEDED( hr ) && ( m_pOutputSite->GetActions() & SPVES_ABORT ) )
    {
        m_SpeechState = SPEECH_DONE;
    }

    //---------------------------------------------
    // Async skip?
    //---------------------------------------------
    if( SUCCEEDED( hr ) && ( m_pOutputSite->GetActions() & SPVES_SKIP ) )
    {
		SPVSKIPTYPE SkipType;
		long SkipCount = 0;

		hr = m_pOutputSite->GetSkipInfo( &SkipType, &SkipCount );

		if ( SUCCEEDED( hr ) && SkipType == SPVST_SENTENCE )
		{
			IEnumSENTITEM *pGarbage;
			//--- Skip Forwards
			if ( SkipCount > 0 )
			{
				long OriginalSkipCount = SkipCount;
				while ( SkipCount > 1 && 
						( hr = m_pEnumSent->Next( &pGarbage ) ) == S_OK )
				{
					SkipCount--;
					pGarbage->Release();
				}
				if ( hr == S_OK )
				{
					hr = ParseSentence( eNEXT );
					if ( SUCCEEDED( hr ) )
					{
						SkipCount--;
					}
				}
				else if ( hr == S_FALSE )
				{
					m_SpeechState = SPEECH_DONE;
				}
				SkipCount = OriginalSkipCount - SkipCount;
			}
			//--- Skip Backwards
			else if ( SkipCount < 0 )
			{
				long OriginalSkipCount = SkipCount;
				while ( SkipCount < -1 &&
						( hr = m_pEnumSent->Previous( &pGarbage ) ) == S_OK )
				{
					SkipCount++;
					pGarbage->Release();
				}
				if ( hr == S_OK )
				{
					hr = ParseSentence( ePREVIOUS );
                    // This case is different from the forward skip, needs to test that
                    // Parse sentence found something to parse!
					if ( SUCCEEDED( hr ) && m_SpeechState != SPEECH_DONE)
					{
						SkipCount++;
					}
				}
				else if ( hr == S_FALSE )
				{
					m_SpeechState = SPEECH_DONE;
				}
				SkipCount = OriginalSkipCount - SkipCount;
			}
			//--- Skip to beginning of this sentence
			else
			{
				m_CurUnitIndex = 0;
			}
			hr = m_pOutputSite->CompleteSkip( SkipCount );
		}
    }

    //---------------------------------------------
    // Make sure we're still speaking
    //---------------------------------------------
    if( SUCCEEDED( hr ) && m_SpeechState != SPEECH_DONE )
    {
        if( m_CurUnitIndex >= m_unitCount)
        {
            //-----------------------------------
            // Get next sentence from Normalizer
            //-----------------------------------
            hr = ParseSentence( eNEXT );
			//m_SpeechState = SPEECH_DONE;
        }
        else if( haveNewRate )
        {
            //-----------------------------------
            // Recalculate prosody to new rate
            //-----------------------------------
            RecalcProsody();
        }

		if( SUCCEEDED(hr) )
		{
			if( m_SpeechState != SPEECH_DONE )
			{
				//-----------------------------------
				// Get next phon
				//-----------------------------------
				m_pUnits[m_CurUnitIndex].hasSpeech = m_HasSpeech;
				*pData =( void*)&m_pUnits[m_CurUnitIndex];
				m_CurUnitIndex++;
			}
		}
    }
    //-------------------------------------------
    // Let client know if text input is dry
    //-------------------------------------------
    *pSpeechState = m_SpeechState;

    return hr;
} /* CFrontend::NextData */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\datenorm.cpp ===
#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

#pragma warning (disable : 4296)

/***********************************************************************************************
* IsNumericCompactDate *
*----------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a Date, and if so, which type.  
*
*   RegExp:
*       {[1-12]{'/' || '-' || '.'}[1-31]{'/' || '-' || '.'}[0-9999]} ||
*       {[1-31]{'/' || '-' || '.'}[1-12]{'/' || '-' || '.'}[0-9999]} ||
*       {[0-9999]{'/' || '-' || '.'}[1-12]{'/' || '-' || '.'}[1-31]}
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumericCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                            CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsNumericCompactDate" );

    HRESULT hr = S_OK;
    
    WCHAR *pFirstChunk = 0, *pSecondChunk = 0, *pThirdChunk = 0, *pLeftOver = 0, *pDelimiter = 0;
    ULONG ulFirst = 0;
    ULONG ulSecond = 0;
    ULONG ulThird = 0;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    bool bThree = false, bTwo = false;
    bool fMonthDayYear = false, fDayMonthYear = false, fYearMonthDay = false;

    //--- Max length of a string matching the regexp is 10 characters 
    if ( ulTokenLen > 10 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Get the preferred order of the compact Date 
        if ( Context != NULL )
        {
            if ( _wcsicmp( Context, L"Date_MDY" ) == 0 )
            {
                fMonthDayYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_DMY" ) == 0 )
            {
                fDayMonthYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_YMD" ) == 0 )
            {
                fYearMonthDay = true;
            }
            else
            {
                if ( m_eShortDateOrder & MONTH_DAY_YEAR )
                {
                    fMonthDayYear = true;
                }
                else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
                {
                    fDayMonthYear = true;
                }
                else
                {
                    fYearMonthDay = true;
                }
            }
        }
        else
        {
            if ( m_eShortDateOrder & MONTH_DAY_YEAR )
            {
                fMonthDayYear = true;
            }
            else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
            {
                fDayMonthYear = true;
            }
            else
            {
                fYearMonthDay = true;
            }
        }

        pFirstChunk = (WCHAR*) m_pNextChar;

        //----------------------------------------------
        // First Try To Get Three Numerical Values
        //----------------------------------------------

        ulFirst = my_wcstoul( pFirstChunk, &pSecondChunk );
        if ( pFirstChunk != pSecondChunk && 
             ( pSecondChunk - pFirstChunk ) <= 4 )
        {
            pDelimiter = pSecondChunk;
            if ( MatchDateDelimiter( &pSecondChunk ) )
            {
                ulSecond = my_wcstoul( pSecondChunk, &pThirdChunk );
                if ( pSecondChunk != pThirdChunk &&
                     ( pThirdChunk - pSecondChunk ) <= 4 )
                {
                    if ( *pThirdChunk == *pDelimiter &&
                         MatchDateDelimiter( &pThirdChunk ) )
                    {
                        ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                        if ( pThirdChunk != pLeftOver                               && 
                             pLeftOver == ( pFirstChunk + ulTokenLen ) &&
                             ( pLeftOver - pThirdChunk ) <= 4 )
                        {
                            //--- Successfully Matched { d+{'/' || '-' || '.'}d+{'/' || '-' || '.'}d+ } 
                            bThree = true;
                        }
                        else 
                        {
                            //--- Digit-String Delimiter Digit-String Delimiter non-digit cannot be a Date,
                            //--- nor can Digit-String Delimiter Digit-String Delimiter Digit-String String 
                            hr = E_INVALIDARG;
                        }
                    }
                    else
                    {
                        if ( pThirdChunk == m_pEndOfCurrItem )
                        {
                            //--- Successfully Matched { d+{'/' || '-' || '.'}d+ } 
                            bTwo = true;
                        }
                        else
                        {
                            //--- Digit-String Delimiter Digit-String non-delimiter cannot be a Date 
                            hr = E_INVALIDARG;
                        }
                    }
                }
            }
            else
            {
                //--- Digit-String followed by non-delimiter cannot be a Date 
                hr = E_INVALIDARG;
            }
        }

        //------------------------------------------------
        // Now Figure Out What To Do With The Values 
        //------------------------------------------------

        //--- Matched a Month, Day, and Year ---//
        if ( SUCCEEDED( hr ) && 
             bThree )
        {
            //--- Try to valiDate values 
            ULONG ulFirstChunkLength  = (ULONG)(pSecondChunk - pFirstChunk  - 1);
            ULONG ulSecondChunkLength = (ULONG)(pThirdChunk  - pSecondChunk - 1);
            ULONG ulThirdChunkLength  = (ULONG)(pLeftOver    - pThirdChunk);

            //--- Preferred order is Month Day Year 
            if (fMonthDayYear)
            {
                //--- Try Month Day Year, then Day Month Year, then Year Month Day 
                if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX ) && 
                     ( ulFirstChunkLength <= 3 )                    &&
                     ( DAYMIN <= ulSecond && ulSecond <= DAYMAX)    && 
                     ( ulSecondChunkLength <= 3 )                   &&
                     ( YEARMIN <= ulThird && ulThird <= YEARMAX)    && 
                     ( ulThirdChunkLength >= 2 ) )
                {
                    NULL;
                }
                else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )        && 
                          ( ulFirstChunkLength <= 3 )                       &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )      && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fMonthDayYear = false;
                    fDayMonthYear = true;
                }
                else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )      && 
                          ( ulFirstChunkLength >= 2 )                       &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( DAYMIN <= ulThird && ulThird <= DAYMAX )        && 
                          ( ulThirdChunkLength <= 3 ) )
                {
                    fMonthDayYear = false;
                    fYearMonthDay = true;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            } 
            //--- Preferred order is Day Month Year 
            else if ( fDayMonthYear )
            {
                //--- Try Day Month Year, then Month Day Year, then Year Month Day 
                if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )         && 
                     ( ulFirstChunkLength <= 3 )                        &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   && 
                     ( ulSecondChunkLength <= 3 )                       &&
                     ( YEARMIN <= ulThird && ulThird <= YEARMAX )       && 
                     ( ulThirdChunkLength >= 2 ) )
                {
                    NULL;
                }
                else if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX )    && 
                          ( ulFirstChunkLength <= 3 )                       &&
                          ( DAYMIN <= ulSecond && ulSecond <= DAYMAX )      && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )      && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fDayMonthYear = false;
                    fMonthDayYear = true;
                }                
                else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )      && 
                          ( ulFirstChunkLength >= 2 )                       &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( DAYMIN <= ulThird && ulThird <= DAYMAX )        && 
                          ( ulThirdChunkLength <= 3 ) )
                {
                    fDayMonthYear = false;
                    fYearMonthDay = true;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            //--- Preferred order is Year Month Day 
            else if (fYearMonthDay)
            {
                //--- Try Year Month Day, then Month Day Year, then Day Month Year 
                if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )      && 
                     ( ulFirstChunkLength >= 2 )                       &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                     ( ulSecondChunkLength <= 3 )                      &&
                     ( DAYMIN <= ulThird && ulThird <= DAYMAX )        && 
                     ( ulThirdChunkLength <= 3 ) )
                {
                    NULL;
                }
                else if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX )    && 
                          ( ulFirstChunkLength <= 3 )                       &&
                          ( DAYMIN <= ulSecond && ulSecond <= DAYMAX )      && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )      && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fYearMonthDay = false;
                    fMonthDayYear = true;
                }                
                else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )         && 
                          ( ulFirstChunkLength <= 3 )                        &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   && 
                          ( ulSecondChunkLength <= 3 )                       &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )       && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fYearMonthDay = false;
                    fDayMonthYear = true;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            //--- Fill out DateItemInfo structure appropriately.
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                    pItemNormInfo->Type = eDATE;
                    if ( fMonthDayYear )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulFirst;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pSecondChunk == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = ulSecondChunkLength;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pSecondChunk + 
                                                                                          ulSecondChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                    (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                            }
                        }
                    }
                    else if ( fDayMonthYear )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pFirstChunk == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = ulFirstChunkLength;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pFirstChunk + 
                                                                                          ulFirstChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                    (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                            }
                        }
                    }
                    else if ( fYearMonthDay )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pThirdChunk == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = ulThirdChunkLength;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pThirdChunk + 
                                                                                          ulThirdChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                    (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pFirstChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulFirstChunkLength;
                            }
                        }
                    }          
                }
            }
        }
        //--- Matched just a Month and Day, or a Month and Year ---//
        else if ( SUCCEEDED( hr ) &&
                  Context         &&
                  bTwo )
        {
            ULONG ulFirstChunkLength  = (ULONG)(pSecondChunk - pFirstChunk  - 1);
            ULONG ulSecondChunkLength = (ULONG)(pThirdChunk  - pSecondChunk);

            if ( _wcsicmp(Context, L"Date_MD") == 0 )
            {
                if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX )     && 
                     ( ulFirstChunkLength <= 2 )                        &&
                     ( DAYMIN <= ulSecond && ulSecond <= DAYMAX )       && 
                     ( ulSecondChunkLength <= 2 ) )
                {
                    //--- Successfully matched a month and day 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulFirst;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( pSecondChunk[0] == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pSecondChunk + 1;
                                ulSecondChunkLength--;
                            }
                            else 
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pSecondChunk;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver = ulSecondChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar  = 
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar + ulSecondChunkLength;
                        }
                    }

                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( _wcsicmp(Context, L"Date_DM") == 0 )
            {
                if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )         && 
                     ( ulFirstChunkLength <= 2 )                        &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   && 
                     ( ulSecondChunkLength <= 2 ) )
                {
                    //--- Successfully matched a month and day 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( m_pNextChar[0] == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pFirstChunk + 1;
                                ulFirstChunkLength--;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pFirstChunk;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver = ulFirstChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar  =
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar + ulFirstChunkLength;
                        }
                    }
                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( _wcsicmp(Context, L"Date_MY") == 0 )
            {
                if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX ) && 
                     ( ulFirstChunkLength <= 2 )                    &&
                     ( YEARMIN <= ulSecond && ulSecond <= YEARMAX ) &&
                     ( ulSecondChunkLength >= 2 ) )
                {
                    //--- Successfully matched a month and year 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex      = ulFirst;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear        = pSecondChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits  = ulSecondChunkLength;
                        }
                    }
                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( _wcsicmp(Context, L"Date_YM") == 0 )
            {
                if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )       && 
                     ( ulFirstChunkLength >= 2 )                        &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   &&
                     ( ulSecondChunkLength <= 2 ) )
                {
                    //--- Successfully matched a month and year 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex      = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear        = pFirstChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits  = ulFirstChunkLength;
                        }
                    }
                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            //--- not a date unless context specifies...
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    
    return hr;
} /* IsNumericCompactDate */

/***********************************************************************************************
* IsMonthStringCompactDate *
*--------------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a Date with a string for the month, and if so, which type.  
*
*   RegExp:
*       {[MonthString]{'/' || '-' || '.'}[1-31]{'/' || '-' || '.'}[0-9999]} ||
*       {[1-31]{'/' || '-' || '.'}[MonthString]{'/' || '-' || '.'}[0-9999]} ||
*       {[0-9999]{'/' || '-' || '.'}[MonthString]{'/' || '-' || '.'}[1-31]}
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsMonthStringCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                                CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "DateNorm.cpp IsMonthStringCompactDate" );

    HRESULT hr = S_OK;
    WCHAR *pFirstChunk = 0, *pSecondChunk = 0, *pThirdChunk = 0, *pLeftOver = 0;
    ULONG ulFirst = 0;
    ULONG ulSecond = 0;
    ULONG ulThird = 0;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    ULONG ulFirstChunkLength = 0, ulSecondChunkLength = 0, ulThirdChunkLength = 0;
    bool fMonthDayYear = false, fDayMonthYear = false, fYearMonthDay = false;

    //--- Max length of a Date matching this regexp is 17 characters 
    if ( ulTokenLen > 17 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Get preferred order of Month, Day, and Year for this user 
        if (Context != NULL)
        {
            if ( _wcsicmp( Context, L"Date_MDY" ) == 0 )
            {
                fMonthDayYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_DMY" ) == 0 )
            {
                fDayMonthYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_YMD" ) == 0 )
            {
                fYearMonthDay = true;
            }
            else
            {
                if ( m_eShortDateOrder & MONTH_DAY_YEAR )
                {
                    fMonthDayYear = true;
                }
                else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
                {
                    fDayMonthYear = true;
                }
                else
                {
                    fYearMonthDay = true;
                }
            }
        }
        else
        {
            if ( m_eShortDateOrder & MONTH_DAY_YEAR )
            {
                fMonthDayYear = true;
            }
            else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
            {
                fDayMonthYear = true;
            }
            else
            {
                fYearMonthDay = true;
            }
        }

        pFirstChunk = (WCHAR*) m_pNextChar;
        pSecondChunk = pFirstChunk;

        //--- Try MonthString-Day-Year format 
        if ( iswalpha( *pFirstChunk ) )
        {
            ulFirst = MatchMonthString( pSecondChunk, ulTokenLen );
            if ( ulFirst )
            {
                ulFirstChunkLength = (ULONG)(pSecondChunk - pFirstChunk);
                if ( MatchDateDelimiter( &pSecondChunk ) )
                {
                    pThirdChunk = pSecondChunk;
                    ulSecond = my_wcstoul( pSecondChunk, &pThirdChunk );
                    if ( pSecondChunk != pThirdChunk &&
                         pThirdChunk - pSecondChunk <= 2 )
                    {
                        ulSecondChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                        if ( MatchDateDelimiter( &pThirdChunk ) )
                        {
                            ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                            if ( pThirdChunk != pLeftOver &&
                                 pLeftOver - pThirdChunk <= 4 )
                            {
                                ulThirdChunkLength = (ULONG)(pLeftOver - pThirdChunk);
                                //--- May have matched a month, day and year - valiDate values 
                                if ( ( DAYMIN <= ulSecond && ulSecond <= DAYMAX ) &&
                                     ( ulSecondChunkLength <= 2 )                 &&               
                                     ( YEARMIN <= ulThird && ulThird <= YEARMAX ) &&
                                     ( ulThirdChunkLength >= 2 ) )
                                {
                                    //--- Successfully matched a month, day and year 
                                    fMonthDayYear = true;
                                    fDayMonthYear = false;
                                    fYearMonthDay = false;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                        else
                        {
                            if ( !Context ||
                                 ( Context &&
                                   _wcsicmp( Context, L"Date_MD" ) == 0 ) )
                            {
                                if ( ( DAYMIN <= ulSecond && ulSecond <= DAYMAX ) &&
                                     ( ulSecondChunkLength <= 2 ) )
                                {
                                    fMonthDayYear = true;
                                    fDayMonthYear = false;
                                    fYearMonthDay = false;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    fYearMonthDay = true;
                                    pFirstChunk   = pSecondChunk;
                                    ulFirstChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                                    ulSecond      = ulFirst;
                                    pThirdChunk   = NULL;
                                }
                            }
                            else if ( Context && 
                                      _wcsicmp( Context, L"Date_MY" ) == 0 )
                            {
                                if ( ( YEARMIN <= ulSecond && ulSecond <= YEARMAX ) &&
                                     ( ulSecondChunkLength <= 4 ) )
                                {
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    fYearMonthDay = true;
                                    pFirstChunk   = pSecondChunk;
                                    ulFirstChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                                    ulSecond      = ulFirst;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                    }
                    else if ( pSecondChunk != pThirdChunk &&
                              pThirdChunk - pSecondChunk <= 4 )
                    {
                        if ( ( YEARMIN <= ulSecond && ulSecond <= YEARMAX ) )
                        {
                            fMonthDayYear = false;
                            fDayMonthYear = false;
                            fYearMonthDay = true;
                            pFirstChunk   = pSecondChunk;
                            ulFirstChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                            ulSecond = ulFirst;
                            pThirdChunk   = NULL;
                        }
                        else
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        //--- Try Day-MonthString-Year and Year-MonthString-Day Formats 
        else if ( isdigit( *pFirstChunk ) )
        {
            ulFirst = my_wcstoul( pFirstChunk, &pSecondChunk );
            if ( pFirstChunk != pSecondChunk &&
                 pSecondChunk - pFirstChunk <= 4 )
            {
                ulFirstChunkLength = (ULONG)(pSecondChunk - pFirstChunk);
                if ( MatchDateDelimiter( &pSecondChunk ) )
                {
                    pThirdChunk = pSecondChunk;
                    ulSecond = MatchMonthString( pThirdChunk, ulTokenLen - ulFirstChunkLength );
                    if ( ulSecond )
                    {
                        ulSecondChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                        if ( MatchDateDelimiter( &pThirdChunk ) )
                        {
                            ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                            if ( pThirdChunk != pLeftOver &&
                                 pLeftOver - pThirdChunk <= 4 )
                            {
                                ulThirdChunkLength = (ULONG)(pLeftOver - pThirdChunk);
                                //--- May have matched a month, day, and year - valiDate values                                 
                                if ( fDayMonthYear || 
                                     fMonthDayYear )
                                {
                                    //--- Preferred format is Month Day Year, or Day Month Year - in either case 
                                    //---     Day Month Year is preferable to Year Month Day 
                                    if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )     && 
                                         ( ulFirstChunkLength <= 2 )                    &&
                                         ( YEARMIN <= ulThird && ulThird <= YEARMAX )   &&
                                         ( ulThirdChunkLength >= 2 ) )
                                    {
                                        //--- Successfully matched a day, month and year 
                                        fDayMonthYear = true;
                                        fMonthDayYear = false;
                                        fYearMonthDay = false;
                                    }
                                    else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )  &&
                                              ( ulFirstChunkLength >= 2 )                   &&
                                              ( DAYMIN <= ulThird && ulThird <= DAYMAX )    &&
                                              ( ulThirdChunkLength <= 2 ) )
                                    {
                                        //--- Successfully matched a year, month and day 
                                        fYearMonthDay = true;
                                        fMonthDayYear = false;
                                        fDayMonthYear = false;
                                    }
                                    else
                                    {
                                        hr = E_INVALIDARG;
                                    }
                                }
                                else // fYearMonthDay
                                {
                                    //--- Preferred format is Year Month Day 
                                    if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )   &&
                                         ( ulFirstChunkLength >= 2 )                    &&
                                         ( DAYMIN <= ulThird && ulThird <= DAYMAX )     &&
                                         ( ulThirdChunkLength <= 2 ) )
                                    {
                                        //--- Successfully matched a year, month, and day
                                        fYearMonthDay = true;
                                        fMonthDayYear = false;
                                        fDayMonthYear = false;
                                    }
                                    else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )    && 
                                              ( ulFirstChunkLength <= 2 )                   &&
                                              ( YEARMIN <= ulThird && ulThird <= YEARMAX )  &&
                                              ( ulThirdChunkLength >= 2 ) )
                                    {
                                        //--- Successfully matched a day, month, and year
                                        fDayMonthYear = true;
                                        fMonthDayYear = false;
                                        fYearMonthDay = false;
                                    }
                                    else
                                    {
                                        hr = E_INVALIDARG;
                                    }
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                        //--- Matched two - either Day-Monthstring or Year-Monthstring
                        else
                        {
                            if ( !Context ||
                                 ( Context &&
                                   _wcsicmp( Context, L"Date_DM" ) == 0 ) )
                            {
                                //--- Preferred format is Month Day Year, or Day Month Year - in either case 
                                //---     Day Month Year is preferable to Year Month Day 
                                if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )     && 
                                     ( ulFirstChunkLength <= 2 ) )
                                {
                                    //--- Successfully matched a day, month and year 
                                    fDayMonthYear = true;
                                    fMonthDayYear = false;
                                    fYearMonthDay = false;
                                    pThirdChunk   = NULL;
                                }
                                else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )  &&
                                          ( ulFirstChunkLength <= 4 ) )
                                {
                                    //--- Successfully matched a year, month and day 
                                    fYearMonthDay = true;
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else if ( Context &&
                                      _wcsicmp( Context, L"Date_YM" ) == 0 )
                            {
                                //--- Preferred format is Year Month Day 
                                if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )   &&
                                     ( ulFirstChunkLength <= 4 ) )
                                {
                                    //--- Successfully matched a year, month, and day
                                    fYearMonthDay = true;
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    pThirdChunk   = NULL;
                                }
                                else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )    && 
                                          ( ulFirstChunkLength <= 2 ) )
                                {
                                    //--- Successfully matched a day, month, and year
                                    fDayMonthYear = true;
                                    fMonthDayYear = false;
                                    fYearMonthDay = false;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Fill out DateItemInfo structure appropriately.
    if ( SUCCEEDED( hr ) )
    {
        pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
            pItemNormInfo->Type = eDATE;
            if ( fMonthDayYear )
            {
                ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulFirst;
                ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                            (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                    if ( ulSecondChunkLength == 2 )
                    {
                        if ( *pSecondChunk != L'0' )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 2;
                        }
                        else
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk + 1;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                        }
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pSecondChunk + 2;
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pSecondChunk;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver  = 1;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar   = pSecondChunk + 1;
                    }
                    if ( pThirdChunk )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear =
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                        }
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = NULL;
                    }
                }
            }
            else if ( fDayMonthYear )
            {
                ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                            (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                    if ( ulFirstChunkLength == 2 )
                    {
                        if ( *pFirstChunk != L'0' )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 2;
                        }
                        else
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk + 1;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                        }
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pFirstChunk + 2;
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pFirstChunk;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver  = 1;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar   = pFirstChunk + 1;
                    }
                    if ( pThirdChunk )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear =
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                        }
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = NULL;
                    }
                }
            }
            else if ( fYearMonthDay )
            {
                ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                if ( SUCCEEDED( hr ) )
                {
                    if ( pThirdChunk )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( ulThirdChunkLength == 2 )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pThirdChunk != L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 2;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pThirdChunk + 2;
                        }
                        else
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pThirdChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver  = 1;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar   = pThirdChunk + 1;
                        }
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = NULL;
                    }
                    ( (TTSDateItemInfo*) pItemNormInfo )->pYear =
                            (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pFirstChunk;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulFirstChunkLength;
                    }
                }
            }
            else
            {
                //--- should never get here.
                hr = E_UNEXPECTED;
            }
        }
    }
              
    return hr;
} /* IsMonthStringCompactDate */

/***********************************************************************************************
* IsLongFormDate_DMDY *
*---------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a long form Date.
*
*   RegExp:
*       [[DayString][,]?]? [MonthString][,]? [Day][,]? [Year]?
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsLongFormDate_DMDY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                           CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsLongFormDate_DMDY" );
    HRESULT hr = S_OK;
    WCHAR *pDayString = NULL, *pMonthString = NULL, *pDay = NULL, *pYear = NULL;
    ULONG ulDayLength = 0, ulYearLength = 0;
    long lDayString = -1, lMonthString = -1, lDay = 0, lYear = 0;
    const WCHAR *pStartChar = m_pNextChar, *pEndOfItem = m_pEndOfCurrItem, *pEndChar = m_pEndChar;
    const WCHAR *pTempEndChar = NULL, *pTempEndOfItem = NULL;
    const SPVTEXTFRAG* pFrag = m_pCurrFrag, *pTempFrag = NULL;
    const SPVSTATE *pDayStringXMLState = NULL, *pMonthStringXMLState = NULL, *pDayXMLState = NULL;
    const SPVSTATE *pYearXMLState = NULL;
    CItemList PostDayStringList, PostMonthStringList, PostDayList;
    BOOL fNoYear = false;

    //--- Try to match Day String
    pDayString   = (WCHAR*) pStartChar;
    lDayString   = MatchDayString( pDayString, (WCHAR*) pEndOfItem );

    //--- Failed to match a Day String
    if ( lDayString == 0 )
    {
        pDayString   = NULL;
    }
    //--- Matched a Day String, but it wasn't by itself or followed by a comma
    else if ( pDayString != pEndOfItem &&
              ( pDayString    != pEndOfItem - 1 ||
                *pEndOfItem != L',' ) )
    {
        hr = E_INVALIDARG;
    }
    //--- Matched a Day String - save XML State and move ahead in text
    else
    {
        pDayString         = (WCHAR*) pStartChar;
        pDayStringXMLState = &pFrag->State;

        pStartChar = pEndOfItem;
        if ( *pStartChar == L',' )
        {
            pStartChar++;
        }
        hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayStringList );
        if ( !pStartChar &&
             SUCCEEDED( hr ) )
        {
            hr = E_INVALIDARG;
        }
        else if ( pStartChar &&
                  SUCCEEDED( hr ) )
        {
            pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
        }
    }

    //--- Try to match Month String
    if ( SUCCEEDED( hr ) )
    {
        pMonthString = (WCHAR*) pStartChar;
        lMonthString = MatchMonthString( pMonthString, (ULONG)(pEndOfItem - pMonthString) );

        //--- Failed to match Month String, or Month String was not by itself...
        if ( !lMonthString ||
             ( pMonthString != pEndOfItem &&
               ( pMonthString  != pEndOfItem - 1 ||
                 *pMonthString != L',' ) ) )
        {
            hr = E_INVALIDARG;
        }
        //--- Matched a Month String - save XML State and move ahead in text
        else
        {
            pMonthString         = (WCHAR*) pStartChar;
            pMonthStringXMLState = &pFrag->State;

            pStartChar = pEndOfItem;
            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostMonthStringList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr = E_INVALIDARG;
            }
            else if ( pStartChar &&
                      SUCCEEDED( hr ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                //--- Strip trailing punctuation, etc. since the next token could be the last one if
                //--- this is just a Monthstring and Day...
                while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                        IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                        IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                        IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                {
                    if ( *(pEndOfItem - 1) != L',' )
                    {
                        fNoYear = true;
                    }
                    pEndOfItem--;
                }
            }
        }
    }

    //--- Try to match Day
    if ( SUCCEEDED( hr ) )
    {
        lDay = my_wcstoul( pStartChar, &pDay );
        //--- Matched a Day - save XML State and move ahead in text
        if ( ( DAYMIN <= lDay && lDay <= DAYMAX ) &&
             pDay - pStartChar <= 2               &&
             ( pDay == pEndOfItem                 || 
              ( pDay == (pEndOfItem - 1) && *pDay == L',' ) ) )
        {
            if ( pDay == pEndOfItem )
            {
                ulDayLength = (ULONG)(pEndOfItem - pStartChar);
            }
            else if ( pDay == pEndOfItem - 1 )
            {
                ulDayLength = (ULONG)((pEndOfItem - 1) - pStartChar);
            }
            pDay         = (WCHAR*) pStartChar;
            pDayXMLState = &pFrag->State;

            if ( !fNoYear )
            {
                //--- Save pointers, in case there is no year present
                pTempEndChar   = pEndChar;
                pTempEndOfItem = pEndOfItem;
                pTempFrag      = pFrag;

                if ( *pEndOfItem == L',' )
                {
                    pStartChar = pEndOfItem + 1;
                }
                else
                {
                    pStartChar = pEndOfItem;
                }
                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayList );
                if ( !pStartChar &&
                     SUCCEEDED( hr ) )
                {
                    fNoYear = true;
                    pYear   = NULL;
                }
                else if ( pStartChar &&
                          ( SUCCEEDED( hr ) ) )
                {
                    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    //--- Strip trailing punctuation, since the next token will be the last one
                    //--- if this is Monthstring, Day, Year
                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                    {
                        pEndOfItem--;
                    }
                }
            }
        }
        //--- Failed to match a day
        else if ( ( YEARMIN <= lDay && lDay <= YEARMAX ) &&
                  pDay - pStartChar <= 4                  &&
                  pDay == pEndOfItem )
        {
            //--- Successfully matched Month String and Year
            pYearXMLState = &pFrag->State;
            ulYearLength  = (ULONG)(pEndOfItem - pStartChar);
            pYear         = (WCHAR*) pStartChar;
            //--- Don't try to match a year again
            fNoYear       = true;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Try to match Year
    if ( SUCCEEDED( hr ) &&
         !fNoYear )
    {
        lYear = my_wcstoul( pStartChar, &pYear );
        //--- Matched a Year
        if ( ( YEARMIN <= lYear && lYear <= YEARMAX ) &&
             pYear - pStartChar <= 4                  &&
             pYear == pEndOfItem )
        {
            //--- Successfully matched Month String, Day, and Year (and possibly Day String)
            pYearXMLState = &pFrag->State;
            ulYearLength  = (ULONG)(pEndOfItem - pStartChar);
            pYear         = (WCHAR*) pStartChar;
        }
        else
        {
            //--- Failed to match Year - replace pointers with previous values
            pEndChar   = pTempEndChar;
            pEndOfItem = pTempEndOfItem;
            pFrag      = pTempFrag;
            pYear      = NULL;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof(TTSWord) );
        Word.eWordPartOfSpeech = MS_Unknown;

        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eDATE_LONGFORM;

            //--- Insert Day String, if present
            if ( pDayString )
            {
                Word.pXmlState  = pDayStringXMLState;
                Word.pWordText  = g_days[lDayString - 1].pStr;
                Word.ulWordLen  = g_days[lDayString - 1].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }

            //--- Insert Post Day String XML States
            while ( !PostDayStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayStringList.RemoveHead() ).Words[0] );
            }

            //--- Insert Month String
            Word.pXmlState  = pMonthStringXMLState;
            Word.pWordText  = g_months[lMonthString - 1].pStr;
            Word.ulWordLen  = g_months[lMonthString - 1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert Post Month String XML State
            while ( !PostMonthStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostMonthStringList.RemoveHead() ).Words[0] );
            }

            SPLISTPOS WordListPos = WordList.GetTailPosition();

            //--- Expand Day
            if ( ulDayLength == 1 )
            {
                NumberGroup Garbage;
                ExpandDigitOrdinal( *pDay, Garbage, WordList );
            }
            else if ( ulDayLength == 2 )
            {
                NumberGroup Garbage;
                ExpandTwoOrdinal( pDay, Garbage, WordList );
            }

            //--- Clean Up Day XML States
            WordList.GetNext( WordListPos );
            while ( WordListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( WordListPos );
                TempWord.pXmlState = pDayXMLState;
            }

            //--- Insert Post Day XML State
            while ( !PostDayList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayList.RemoveHead() ).Words[0] );
            }

            WordListPos = WordList.GetTailPosition();

            //--- Expand Year, if present
            if ( pYear )
            {
                TTSYearItemInfo TempYearInfo;
                TempYearInfo.pYear       = pYear;
                TempYearInfo.ulNumDigits = ulYearLength;
                hr = ExpandYear( &TempYearInfo, WordList );

                if ( SUCCEEDED( hr ) )
                {
                    //--- Clean Up Year XML States
                    WordList.GetNext( WordListPos );
                    while ( WordListPos )
                    {
                        TTSWord& TempWord  = WordList.GetNext( WordListPos );
                        TempWord.pXmlState = pYearXMLState;
                    }
                }
            }
            //--- Advance pointers
            m_pCurrFrag      = pFrag;
            m_pEndChar       = pEndChar;
            m_pEndOfCurrItem = pEndOfItem;
        }
    }

    return hr;
} /* IsLongFormDate_DMDY */

/***********************************************************************************************
* IsLongFormDate_DDMY *
*---------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a long form Date.
*
*   RegExp:
*       [[DayString][,]?]? [Day][,]? [MonthString][,]? [Year]?
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsLongFormDate_DDMY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                           CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsLongFormDate_DDMY" );
    HRESULT hr = S_OK;
    WCHAR *pDayString = NULL, *pMonthString = NULL, *pDay = NULL, *pYear = NULL;
    ULONG ulDayLength = 0, ulYearLength = 0;
    long lDayString = -1, lMonthString = -1, lDay = 0, lYear = 0;
    const WCHAR *pStartChar = m_pNextChar, *pEndOfItem = m_pEndOfCurrItem, *pEndChar = m_pEndChar;
    const WCHAR *pTempEndChar = NULL, *pTempEndOfItem = NULL;
    const SPVTEXTFRAG* pFrag = m_pCurrFrag, *pTempFrag = NULL;
    const SPVSTATE *pDayStringXMLState = NULL, *pMonthStringXMLState = NULL, *pDayXMLState = NULL;
    const SPVSTATE *pYearXMLState = NULL;
    CItemList PostDayStringList, PostMonthStringList, PostDayList;
    BOOL fNoYear = false;

    //--- Try to match Day String
    pDayString   = (WCHAR*) pStartChar;
    lDayString   = MatchDayString( pDayString, (WCHAR*) pEndOfItem );

    //--- Failed to match a Day String
    if ( lDayString == 0 )
    {
        pDayString   = NULL;
    }
    //--- Matched a Day String, but it wasn't by itself or followed by a comma
    else if ( pDayString != pEndOfItem &&
              ( pDayString    != pEndOfItem - 1 ||
                *pEndOfItem != L',' ) )
    {
        hr = E_INVALIDARG;
    }
    //--- Matched a Day String - save XML State and move ahead in text
    else
    {
        pDayString         = (WCHAR*) pStartChar;
        pDayStringXMLState = &pFrag->State;

        pStartChar = pEndOfItem;
        if ( *pStartChar == L',' )
        {
            pStartChar++;
        }
        hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayStringList );
        if ( !pStartChar &&
             SUCCEEDED( hr ) )
        {
            hr = E_INVALIDARG;
        }
        else if ( pStartChar &&
                  SUCCEEDED( hr ) )
        {
            pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
        }
    }

    //--- Try to match Day
    if ( SUCCEEDED( hr ) )
    {
        lDay = my_wcstoul( pStartChar, &pDay );
        //--- Matched a Day - save XML State and move ahead in text
        if ( ( DAYMIN <= lDay && lDay <= DAYMAX ) &&
             pDay - pStartChar <= 2               &&
             ( pDay == pEndOfItem                 || 
              ( pDay == (pEndOfItem - 1) && *pDay == L',' ) ) )
        {
            if ( pDay == pEndOfItem )
            {
                ulDayLength = (ULONG)(pEndOfItem - pStartChar);
            }
            else if ( pDay == pEndOfItem - 1 )
            {
                ulDayLength = (ULONG)((pEndOfItem - 1) - pStartChar);
            }
            pDay         = (WCHAR*) pStartChar;
            pDayXMLState = &pFrag->State;

            if ( *pEndOfItem == L',' )
            {
                pStartChar = pEndOfItem + 1;
            }
            else
            {
                pStartChar = pEndOfItem;
            }

            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr = E_INVALIDARG;
            }
            else if ( pStartChar &&
                      ( SUCCEEDED( hr ) ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                //--- Strip trailing punctuation, since the next token will be the last one
                //--- if this is Monthstring, Day, Year
                while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                        IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                        IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                        IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                {
                    if ( *(pEndOfItem - 1) != L',' )
                    {
                        fNoYear = true;
                    }
                    pEndOfItem--;
                }
            }
        }
        //--- Failed to match a day
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Try to match Month String
    if ( SUCCEEDED( hr ) )
    {
        pMonthString = (WCHAR*) pStartChar;
        lMonthString = MatchMonthString( pMonthString, (ULONG)(pEndOfItem - pMonthString) );

        //--- Failed to match Month String, or Month String was not by itself...
        if ( !lMonthString ||
             ( pMonthString != pEndOfItem &&
               ( pMonthString  != pEndOfItem - 1 ||
                 *pMonthString != L',' ) ) )
        {
            hr = E_INVALIDARG;
        }
        //--- Matched a Month String - save XML State and move ahead in text
        else
        {
            pMonthString         = (WCHAR*) pStartChar;
            pMonthStringXMLState = &pFrag->State;

            if ( !fNoYear )
            {
                //--- Save pointers, in case there is no year present
                pTempEndChar   = pEndChar;
                pTempEndOfItem = pEndOfItem;
                pTempFrag      = pFrag;

                if ( *pEndOfItem == L',' )
                {
                    pStartChar = pEndOfItem + 1;
                }
                else
                {
                    pStartChar = pEndOfItem;
                }

                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostMonthStringList );
                if ( !pStartChar &&
                     SUCCEEDED( hr ) )
                {
                    fNoYear = true;
                    pYear   = NULL;
                }
                else if ( pStartChar &&
                          SUCCEEDED( hr ) )
                {
                    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    //--- Strip trailing punctuation, etc. since the next token could be the last one if
                    //--- this is Day, Monthstring, Year
                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                    {
                        pEndOfItem--;
                    }
                }
            }
        }
    }

    //--- Try to match Year
    if ( SUCCEEDED( hr ) &&
         !fNoYear )
    {
        lYear = my_wcstoul( pStartChar, &pYear );
        //--- Matched a Year
        if ( ( YEARMIN <= lYear && lYear <= YEARMAX ) &&
             pYear - pStartChar <= 4                  &&
             pYear == pEndOfItem )
        {
            //--- Successfully matched Month String, Day, and Year (and possibly Day String)
            pYearXMLState = &pFrag->State;
            ulYearLength  = (ULONG)(pEndOfItem - pStartChar);
            pYear         = (WCHAR*) pStartChar;
        }
        else
        {
            //--- Failed to match Year - replace pointers with previous values
            pEndChar   = pTempEndChar;
            pEndOfItem = pTempEndOfItem;
            pFrag      = pTempFrag;
            pYear      = NULL;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof(TTSWord) );
        Word.eWordPartOfSpeech = MS_Unknown;

        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eDATE_LONGFORM;

            //--- Insert Day String, if present
            if ( pDayString )
            {
                Word.pXmlState  = pDayStringXMLState;
                Word.pWordText  = g_days[lDayString - 1].pStr;
                Word.ulWordLen  = g_days[lDayString - 1].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }

            //--- Insert Post Day String XML States
            while ( !PostDayStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayStringList.RemoveHead() ).Words[0] );
            }

            //--- Insert Month String
            Word.pXmlState  = pMonthStringXMLState;
            Word.pWordText  = g_months[lMonthString - 1].pStr;
            Word.ulWordLen  = g_months[lMonthString - 1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert Post Month String XML State
            while ( !PostMonthStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostMonthStringList.RemoveHead() ).Words[0] );
            }

            SPLISTPOS WordListPos = WordList.GetTailPosition();

            //--- Expand Day
            if ( ulDayLength == 1 )
            {
                NumberGroup Garbage;
                ExpandDigitOrdinal( *pDay, Garbage, WordList );
            }
            else if ( ulDayLength == 2 )
            {
                NumberGroup Garbage;
                ExpandTwoOrdinal( pDay, Garbage, WordList );
            }

            //--- Clean Up Day XML States
            WordList.GetNext( WordListPos );
            while ( WordListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( WordListPos );
                TempWord.pXmlState = pDayXMLState;
            }

            //--- Insert Post Day XML State
            while ( !PostDayList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayList.RemoveHead() ).Words[0] );
            }

            WordListPos = WordList.GetTailPosition();

            //--- Expand Year, if present
            if ( pYear )
            {
                TTSYearItemInfo TempYearInfo;
                TempYearInfo.pYear       = pYear;
                TempYearInfo.ulNumDigits = ulYearLength;
                hr = ExpandYear( &TempYearInfo, WordList );

                if ( SUCCEEDED( hr ) )
                {
                    //--- Clean Up Year XML States
                    WordList.GetNext( WordListPos );
                    while ( WordListPos )
                    {
                        TTSWord& TempWord  = WordList.GetNext( WordListPos );
                        TempWord.pXmlState = pYearXMLState;
                    }
                }
            }
            //--- Advance pointers
            m_pCurrFrag      = pFrag;
            m_pEndChar       = pEndChar;
            m_pEndOfCurrItem = pEndOfItem;
        }
    }

    return hr;
} /* IsLongFormDate_DMDY */

/***********************************************************************************************
* ExpandDate *
*------------*
*   Description:
*       Expands Items previously determined to be of type Date by IsNumericCompactDate, 
*   IsMonthStringCompactDate, or IsTwoValueDate.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandDate( TTSDateItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDate" );
    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Insert DayString, if present.
    if ( pItemInfo->ulDayIndex )
    {
        Word.pWordText  = g_days[pItemInfo->ulDayIndex - 1].pStr;
        Word.ulWordLen  = g_days[pItemInfo->ulDayIndex - 1].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    //--- Insert Month 
    Word.pWordText  = g_months[pItemInfo->ulMonthIndex - 1].pStr;
    Word.ulWordLen  = g_months[pItemInfo->ulMonthIndex - 1].Len;
    Word.pLemma     = Word.pWordText;
    Word.ulLemmaLen = Word.ulWordLen;
    WordList.AddTail( Word );

    //--- Expand Day, if present.
    if ( pItemInfo->pDay )
    {
        if ( pItemInfo->pDay->lLeftOver == 1 )
        {
            NumberGroup Garbage;
            ExpandDigitOrdinal( *pItemInfo->pDay->pStartChar, Garbage, WordList );
        }
        else if ( pItemInfo->pDay->lLeftOver == 2 )
        {
            NumberGroup Garbage;
            ExpandTwoOrdinal( pItemInfo->pDay->pStartChar, Garbage, WordList );
        }
    }

    //--- Expand Year, if present.
    if ( pItemInfo->pYear )
    {
        ExpandYear( pItemInfo->pYear, WordList );
    }
    return hr;
} /* ExpandDate_Standard */

/***********************************************************************************************
* ExpandYear *
*-------------*
*   Description:
*       Expands four digit strings into words in groups of two, and inserts them into Item List 
*   at ListPos.  Thus 1999 come out as "nineteen ninety nine" rather than "one thousand nine
*   hundred ninety nine"...
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandYear( TTSYearItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandYear" );

    // 1000 - 9999
    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    NumberGroup Garbage;

    switch ( pItemInfo->ulNumDigits )
    {
    case 2:

        //--- Expand as "two thousand" if the two digits are both zeroes.
        if ( pItemInfo->pYear[0] == L'0' &&
             pItemInfo->pYear[1] == L'0' )
        {
            //--- Insert "two".
            Word.pWordText  = g_ones[2].pStr;
            Word.ulWordLen  = g_ones[2].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert "thousand".
            Word.pWordText  = g_quantifiers[1].pStr;
            Word.ulWordLen  = g_quantifiers[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        //--- Expand as "oh number" if the first digit is zero.
        else if ( pItemInfo->pYear[0] == L'0' )
        {
            Word.pWordText  = g_O.pStr;
            Word.ulWordLen  = g_O.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            ExpandDigit( pItemInfo->pYear[1], Garbage, WordList );
        }
        //--- Otherwise just expand as a two digit cardinal number
        else
        {
            ExpandTwoDigits( pItemInfo->pYear, Garbage, WordList );
        }
        break;

    case 3:

        //--- Expand as a three digit cardinal number;
        ExpandThreeDigits( pItemInfo->pYear, Garbage, WordList );
        break;

    case 4:

        //--- If of form "[x]00[y]" expand as "x thousand y", or just "x thousand" if y is also zero.
        if ( pItemInfo->pYear[1] == L'0' &&
             pItemInfo->pYear[2] == L'0' &&
             pItemInfo->pYear[0] != L'0' )
        {
            //--- "x" 
            ExpandDigit( pItemInfo->pYear[0], Garbage, WordList );

            //--- "thousand".
            Word.pWordText  = g_quantifiers[1].pStr;
            Word.ulWordLen  = g_quantifiers[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- "y" 
            if ( pItemInfo->pYear[3] != L'0' )
            {
                ExpandDigit( pItemInfo->pYear[3], Garbage, WordList );
            }
        }
        // Otherwise...
        else
        {
            //--- Expand first two digits - e.g. "nineteen"
            ExpandTwoDigits( pItemInfo->pYear, Garbage, WordList );

            //--- Expand last two digits - e.g. "nineteen", "hundred", or "oh nine".
            if ( pItemInfo->pYear[2] != '0' )
            {
                //--- the tens is not zero - e.g. 1919 -> "nineteen nineteen" 
                ExpandTwoDigits( pItemInfo->pYear + 2, Garbage, WordList );
            }
            else if ( pItemInfo->pYear[3] == '0' )
            {
                //--- tens and ones are both zero - expand as "hundred", e.g. 1900 -> "nineteen hundred" 
                Word.pWordText  = g_quantifiers[0].pStr;
                Word.ulWordLen  = g_quantifiers[0].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            else
            {
                //--- just the tens is zero, expand as "oh x" - e.g. 1909 -> "nineteen oh nine", 
                //---   unless both thousands and hundreds were also zero - e.g. 0002 -> "two"
                if ( pItemInfo->pYear[0] != '0' ||
                     pItemInfo->pYear[1] != '0' )
                {
                    Word.pWordText  = g_O.pStr;
                    Word.ulWordLen  = g_O.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                ExpandDigit( pItemInfo->pYear[3], Garbage, WordList );
            }
        }
    }
    return hr;
} /* ExpandYear */

/***********************************************************************************************
* IsDecade *
*----------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a Decade.
*
*   RegExp:
*       { ddd0s || d0s || 'd0s || ddd0's || d0's }
*   
*   Types assigned:
*       Decade
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsDecade( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsDecade" );

    HRESULT hr = S_OK;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);

    if ( ulTokenLen < 3 ||
         ulTokenLen > 6 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        switch ( ulTokenLen )
        {

        case 6:
            if ( m_pNextChar[5] == L's'     &&
                 m_pNextChar[4] == L'\''     &&
                 m_pNextChar[3] == L'0'    &&
                 iswdigit( m_pNextChar[2] ) &&
                 iswdigit( m_pNextChar[1] ) &&
                 iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form ddd0's
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = m_pNextChar;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[2] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        case 5:
            if ( m_pNextChar[4] == L's'     &&
                 m_pNextChar[3] == L'0'     &&
                 iswdigit( m_pNextChar[2] ) &&
                 iswdigit( m_pNextChar[1] ) &&
                 iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form ddd0s
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = m_pNextChar;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[2] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        case 4:
            if ( m_pNextChar[3] == L's'     &&
                 m_pNextChar[2] == L'0'     &&
                 iswdigit( m_pNextChar[1] ) &&
                 m_pNextChar[0] == L'\'' )
            {
                //--- Decade of form 'd0s
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = NULL;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[1] - L'0';
                }
            }
            else if ( m_pNextChar[3] == L's'  &&
                      m_pNextChar[2] == L'\'' &&
                      m_pNextChar[1] == L'0'  &&
                      iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form d0's
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = NULL;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[0] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        case 3:
            if ( m_pNextChar[2] == L's' &&
                 m_pNextChar[1] == L'0' &&
                 iswdigit( m_pNextChar[0] ) )
            {
                //--- Decade of form d0s
                pItemNormInfo = (TTSDecadeItemInfo*) MemoryManager.GetMemory( sizeof(TTSDecadeItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDecadeItemInfo) );
                    pItemNormInfo->Type = eDECADE;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->pCentury = NULL;
                    ( (TTSDecadeItemInfo*) pItemNormInfo )->ulDecade = m_pNextChar[0] - L'0';
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            break;

        default:
            hr = E_INVALIDARG;
            break;
        }
    }            
    
    return hr;
} /* IsDecade */

/***********************************************************************************************
* ExpandDecade *
*--------------*
*   Description:
*       Expands Items previously determined to be of type Decade by IsDecade.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandDecade( TTSDecadeItemInfo* pItemInfo, CWordList& WordList )
{
    HRESULT hr = S_OK;
    BOOL fDone = false;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Four digit form 
    if ( pItemInfo->pCentury )
    {
        //--- Cover special cases first 

        //--- 00dds 
        if ( pItemInfo->pCentury[0] == '0' &&
             pItemInfo->pCentury[1] == '0' )
        {
            //--- 0000s - expand as "zeroes"
            if ( pItemInfo->ulDecade == 0 )
            {
                Word.pWordText  = g_Zeroes.pStr;
                Word.ulWordLen  = g_Zeroes.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                fDone = true;
            }
            //--- 00d0s 
            else 
            {
                // Just expand the decade part as we normally would
                NULL;
            }
        }
        //--- 0dd0s - expand as "d hundreds" or "d hundred [decade part]"
        else if ( pItemInfo->pCentury[0] == '0' )
        {
            //--- insert first digit
            Word.pWordText  = g_ones[ pItemInfo->pCentury[0] - L'0' ].pStr;
            Word.ulWordLen  = g_ones[ pItemInfo->pCentury[0] - L'0' ].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- 0d00s - expand as "d hundreds" 
            if ( SUCCEEDED( hr ) &&
                 pItemInfo->ulDecade == 0 )
            {
                Word.pWordText  = g_Hundreds.pStr;
                Word.ulWordLen  = g_Hundreds.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                fDone = true;
            }
            //--- 0dd0s - expand as "d hundred [decade part]"
            else if ( SUCCEEDED( hr ) )
            {
                Word.pWordText  = g_hundred.pStr;
                Word.ulWordLen  = g_hundred.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
        }
        //--- d000s, dd00s - expand as "d thousands" or "dd hundreds"
        else if ( pItemInfo->ulDecade == 0 )
        {
            //--- d000s - "d thousands" ( "thousands" will get inserted below )
            if ( pItemInfo->pCentury[1] == '0' )
            {
                Word.pWordText  = g_ones[ pItemInfo->pCentury[0] - L'0' ].pStr;
                Word.ulWordLen  = g_ones[ pItemInfo->pCentury[0] - L'0' ].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            //--- dd00s - "dd hundreds"
            else
            {
                NumberGroup Garbage;
                ExpandTwoDigits( pItemInfo->pCentury, Garbage, WordList );

                Word.pWordText  = g_Hundreds.pStr;
                Word.ulWordLen  = g_Hundreds.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                fDone = true;
            }
        }
        //--- Default case: ddd0s - expand as "dd [decade part]"
        else
        {
            NumberGroup Garbage;
            ExpandTwoDigits( pItemInfo->pCentury, Garbage, WordList );
        }
    }
    //--- Special case - 00s should expand as "two thousands"
    else if ( pItemInfo->ulDecade == 0 )
    {
        Word.pWordText  = g_ones[2].pStr;
        Word.ulWordLen  = g_ones[2].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    //--- Expand decade part, if necessary 
    if ( SUCCEEDED(hr) &&
         !fDone )
    {
        Word.pWordText  = g_Decades[ pItemInfo->ulDecade ].pStr;
        Word.ulWordLen  = g_Decades[ pItemInfo->ulDecade ].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    return hr;
} /* ExpandDecade */

/***********************************************************************************************
* MatchMonthString *
*------------------*
*   Description:
*       This is just a helper function - it returns the integer value of the month found in 
*   its WCHAR string parameter ("January" is 1, "February" 2, etc.) or zero if it finds no match.
*   It also checks three letter abbreviations - "Jan", "Feb", etc.
*   Note: This function does not do parameter validation. Assumed to be done by caller
*   (GetNumber should be called first to get the NumberInfo structure and valiDate parameters).
********************************************************************* AH **********************/
ULONG CStdSentEnum::MatchMonthString( WCHAR*& pMonth, ULONG ulLength )
{
    ULONG ulMonth = 0;

    //--- Check full months strings 
    for ( int i = 0; i < sp_countof(g_months); i++ )
    {
        if ( ulLength >= (ULONG) g_months[i].Len && 
             wcsnicmp( pMonth, g_months[i].pStr, g_months[i].Len ) == 0 )
        {
            ulMonth = i + 1;
            pMonth  = pMonth + g_months[i].Len;
            break;
        }
    }
    //--- Check month abbreviations 
    if ( !ulMonth )
    {
        for ( i = 0; i < sp_countof(g_monthAbbreviations); i++ )
        {
            if ( ulLength >= (ULONG) g_monthAbbreviations[i].Len &&
                 wcsnicmp( pMonth, g_monthAbbreviations[i].pStr, g_monthAbbreviations[i].Len ) == 0 ) 
            {
                if ( i > 8 )
                {
                    ulMonth = i;
                }
                else
                {
                    ulMonth = i + 1;
                }
                pMonth = pMonth + g_monthAbbreviations[i].Len;
                if ( *pMonth == L'.' )
                {
                    pMonth++;
                }
                break;
            }
        }
    }

    return ulMonth;
} /* MatchMonthString */

/***********************************************************************************************
* MatchDayString *
*----------------*
*   Description:
*       This is just a helper function - it returns the integer value of the day found in 
*   its WCHAR string parameter ("Monday" is 0, "Tuesday" 1, etc.) or -1 if it finds no match.
*   It also checks abbreviations - "Mon", "Tue", etc.
*   Note: This function does not do parameter validation. Assumed to be done by caller
********************************************************************* AH **********************/
ULONG CStdSentEnum::MatchDayString( WCHAR*& pDayString, WCHAR* pEndChar )
{
    ULONG ulDay = 0;

    //--- Check full day strings 
    for ( int i = 0; i < sp_countof(g_days); i++ )
    {
        if ( pEndChar - pDayString >= g_days[i].Len && 
             wcsnicmp( pDayString, g_days[i].pStr, g_days[i].Len ) == 0 )
        {
            ulDay = i + 1;
            pDayString = pDayString + g_days[i].Len;
            break;
        }
    }
    //--- Check month abbreviations 
    if ( !ulDay )
    {
        for ( i = 0; i < sp_countof(g_dayAbbreviations); i++ )
        {
            if ( pEndChar - pDayString >= g_dayAbbreviations[i].Len &&
                 wcsncmp( pDayString, g_dayAbbreviations[i].pStr, g_dayAbbreviations[i].Len ) == 0 )
            {
                switch (i)
                {
                //--- Mon, Tues
                case 0:
                case 1:
                    ulDay = i + 1;
                    break;
                //--- Tue, Wed, Thurs
                case 2:
                case 3:
                case 4:
                    ulDay = i;
                    break;
                //--- Thur, Thu
                case 5:
                case 6:
                    ulDay = 4;
                    break;
                //--- Fri, Sat, Sun
                case 7:
                case 8:
                case 9:
                    ulDay = i - 2;
                    break;
                }

                pDayString = pDayString + g_dayAbbreviations[i].Len;
                if ( *pDayString == L'.' )
                {
                    pDayString++;
                }
                break;
            }
        }
    }

    return ulDay;
} /* MatchDayString */

/***********************************************************************************************
* MatchDateDelimiter *
*--------------------*
*   Description:
*       This is just a helper function - it returns true or false based on whether the first
*   character in its parameter string is a valid Date Delimiter.  It also advances its parameter
*   string pointer one position (past the Date Delimiter) and replaces a valid delimiter with
*   a null terminator.
*   Note: This function does not do parameter validation. Assumed to be done by caller
*   (GetNumber should be called first to get the NumberInfo structure and valiDate parameters).
********************************************************************* AH **********************/
bool CStdSentEnum::MatchDateDelimiter( WCHAR** DateString )
{
    bool bIsDelimiter = false;

    if (DateString)
    {
        for (int i = 0; i < sp_countof(g_DateDelimiters); i++)
        {
            if (*DateString[0] == g_DateDelimiters[i])
            {
                bIsDelimiter = true;
                *DateString = *DateString + 1;
                break;
            }
        }
    }

    return bIsDelimiter;
} /* MatchDateDelimiter */

//------------End Of File-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\makefile.inc ===
SelfRegister :
!if defined(MAKEDLL)
	regsvr32 /s $(O)\$(TARGETNAME).dll
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\frontend.h ===
/******************************************************************************
* Frontend.h *
*------------*
*  This is the header file for the CFrontend implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** MC ****/
#ifndef Frontend_H
#define Frontend_H

#ifndef FeedChain_H
#include "FeedChain.h"
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#include "sapi.h"


//static const float DISCRETE_BKPT   = 0.6667f; 
static const float DISCRETE_BKPT   = 0.3333f; 

//-----------------------------------------
// Parse Next Sentence or Previous Sentence
//-----------------------------------------
enum DIRECTION
{
    eNEXT = 0,
    ePREVIOUS = 1,
};

//------------------------------------------------------
// Tag Values
//------------------------------------------------------
enum USER_VOLUME_VALUE
{   
    MIN_USER_VOL = 0,
    MAX_USER_VOL = 100,
    DEFAULT_USER_VOL = MAX_USER_VOL
};

enum USER_PITCH_VALUE
{   
    MIN_USER_PITCH = (-24),
    MAX_USER_PITCH = 24,
    DEFAULT_USER_PITCH = 0       // None
};

enum USER_EMPH_VALUE
{   
    MIN_USER_EMPH = (-10),
    MAX_USER_EMPH = 10,
    SAPI_USER_EMPH = 5,
    DEFAULT_USER_EMPH = 0        // None
};



//------------------------
// ToBI phrasing
//------------------------
typedef struct
{
    PROSODY_POS  posClass;
    long     start;
    long     end;
} TOBI_PHRASE;



class CFrontend: public CFeedChain
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    CFrontend( );
    ~CFrontend( );
    void PrepareSpeech( IEnumSpSentence* pEnumSent, ISpTTSEngineSite* pOutputSite );
    HRESULT Init( IMSVoiceData* pVoiceDataObj, CFeedChain *pSrcObj, MSVOICEINFO* pVoiceInfo );

private:
    HRESULT AlloToUnit( CAlloList *pAllos, UNITINFO *pu );
    HRESULT ParseSentence( DIRECTION eDirection );
    HRESULT TokensToAllo( CFETokenList *pTokList, CAlloList *pAllo );
    HRESULT GetSentenceTokens( DIRECTION eDirection );
    void GetItemControls( const SPVSTATE* pXmlState, CFEToken* pToken );
    void DisposeUnits( );
    void RecalcProsody();
    HRESULT ToBISymbols();
    void DoPhrasing();
    void DeleteTokenList();
	HRESULT UnitLookahead ();
	void AlloToUnitPitch( CAlloList *pAllos, UNITINFO *pu );
    void UnitToAlloDur( CAlloList *pAllos, UNITINFO *pu );
    float CntrlToRatio( long rateControl );
	PROSODY_POS GetPOSClass( ENGPARTOFSPEECH sapiPOS );
	bool StateQuoteProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	bool StartParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	bool EndParenProsody( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	bool EmphSetup( CFEToken *pWordTok, TTSSentItem *pSentItem, bool fInsertSil );
	SPLISTPOS InsertSilenceAtTail( CFEToken *pWordTok, TTSSentItem *pSentItem, long msec );
	SPLISTPOS InsertSilenceAfterPos( CFEToken *pWordTok, SPLISTPOS position );
	SPLISTPOS InsertSilenceBeforePos( CFEToken *pWordTok, SPLISTPOS position );
	void DoWordAccent();
	void ExclamEmph();
	void ProsodyTemplates( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	long DoIntegerTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount );
	void DoNumByNumTemplate( SPLISTPOS *pClusterPos, long cWordCount );
	void DoCurrencyTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	void DoPhoneNumberTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	void DoTODTemplate( SPLISTPOS clusterPos, TTSSentItem *pSentItem );
	long DoFractionTemplate( SPLISTPOS *pClusterPos, TTSNumberItemInfo *pNInfo, long cWordCount );
	CFEToken *InsertPhoneSilenceAtSpace( SPLISTPOS *pClusterPos, 
													BOUNDARY_SOURCE bndSrc, 
													SILENCE_SOURCE	silSrc );
	void InsertPhoneSilenceAtEnd( BOUNDARY_SOURCE bndSrc, 
								  SILENCE_SOURCE	silSrc );
	void CalcSentenceLength();

    //--------------------------------
    // CFeedChain methods
    //--------------------------------
    virtual HRESULT NextData( void**pData, SPEECH_STATE *pSpeechState ) ;
    
    //--------------------------------
    // Members
    //--------------------------------
    UNITINFO*       m_pUnits;
    ULONG           m_unitCount;
    ULONG           m_CurUnitIndex;
    SPEECH_STATE    m_SpeechState;
    
    CFeedChain      *m_pSrcObj;
    long            m_VoiceWPM;         // Voice defined speaking rate (wpm)
    float            m_RateRatio_API;         // API modulated speaking rate (ratio)
    float            m_CurDurScale;		// control tag (ratio)
    float            m_RateRatio_BKPT;        // Below this, add pauses (ratio)
    float            m_RateRatio_PROSODY;         // API modulated speaking rate (ratio)
    float           m_BasePitch;		// FROM VOICE: Baseline pitch in hz
	float			m_PitchRange;		// FROM VOICE: Pitch range in +/- octaves
	bool			m_HasSpeech;
    
    CFETokenList    m_TokList;
    long            m_cNumOfWords;
    
    CPitchProsody   m_PitchObj;
    IEnumSpSentence    *m_pEnumSent;
    CDuration       m_DurObj;
    CSyllableTagger m_SyllObj;
    IMSVoiceData*   m_pVoiceDataObj;
    float           m_ProsodyGain;
    float           m_SampleRate;
    CAlloList       *m_pAllos;
	bool			m_fInQuoteProsody;		// Special prosody mode
	bool			m_fInParenProsody;		// Special prosody mode
	float			m_CurPitchOffs;			// Pitch offset in octaves
	float			m_CurPitchRange;		// Pitch range scale (0 - 2.0)

	ISpTTSEngineSite *m_pOutputSite;
};



#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\morph.cpp ===
/*******************************************************************************
* morph.cpp *
*-----------*
*   Description:
*       This is the implementation of the CSMorph class, which attempts to find
*   pronunciations for morphologcical variants (which are not in the lexicon) of
*   root words (which are in the lexicon).
*-------------------------------------------------------------------------------
*  Created By: AH, based partly on code by MC                     Date: 08/16/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

// Additional includes...
#include "stdafx.h"
#include "morph.h"
#include "spttsengdebug.h"

/*****************************************************************************
* CSMorph::CSMorph *
*------------------*
*	Description:    Constructor - just sets the Master Lexicon pointer...
*		
********************************************************************** AH ***/
CSMorph::CSMorph( ISpLexicon *pMasterLex, HRESULT *phr ) 
{
    SPDBG_FUNC( "CSMorph::CSMorph" );
    SPDBG_ASSERT( phr != NULL );

    m_pMasterLex = pMasterLex;

    // Initialize the SuffixInfoTable - obtain lock to make sure this only happens once...
    g_SuffixInfoTableCritSec.Lock();
    if (!SuffixInfoTableInitialized)
    {
        CComPtr<ISpPhoneConverter> pPhoneConv;
        *phr = SpCreatePhoneConverter(1033, NULL, NULL, &pPhoneConv);

        for (int i = 0; i < sp_countof(g_SuffixInfoTable); i++)
        {
            *phr = pPhoneConv->PhoneToId(g_SuffixInfoTable[i].SuffixString, g_SuffixInfoTable[i].SuffixString);
            if ( FAILED( *phr ) )
            {
                break;
            }
        }

        if (SUCCEEDED(*phr))
        {
            *phr = pPhoneConv->PhoneToId(g_phonS, g_phonS);
            if (SUCCEEDED(*phr))
            {
                *phr = pPhoneConv->PhoneToId(g_phonZ, g_phonZ);
                if (SUCCEEDED(*phr))
                {
                    *phr = pPhoneConv->PhoneToId(g_phonAXz, g_phonAXz);
                    if (SUCCEEDED(*phr))
                    {
                        *phr = pPhoneConv->PhoneToId(g_phonT, g_phonT);
                        if (SUCCEEDED(*phr))
                        {
                            *phr = pPhoneConv->PhoneToId(g_phonD, g_phonD);
                            if (SUCCEEDED(*phr))
                            {
                                *phr = pPhoneConv->PhoneToId(g_phonAXd, g_phonAXd);
                                if (SUCCEEDED(*phr))
                                {
                                    *phr = pPhoneConv->PhoneToId(g_phonAXl, g_phonAXl);
                                    if ( SUCCEEDED( *phr ) )
                                    {
                                        *phr = pPhoneConv->PhoneToId(g_phonIY, g_phonIY);
                                        if ( SUCCEEDED( *phr ) )
                                        {
                                            *phr = pPhoneConv->PhoneToId(g_phonL, g_phonL);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (SUCCEEDED(*phr))
    {
        SuffixInfoTableInitialized = true;
    }
    g_SuffixInfoTableCritSec.Unlock();

} /* CSMorph::CSMorph */


/*****************************************************************************
* CSMorph::DoSuffixMorph *
*------------------------*
*	Description:    This is the only interface function of CSMorph - it 
*       takes the same arguments as a GetPronunciations() call, and does
*       basically the same thing.  
*		
********************************************************************** AH ***/
HRESULT CSMorph::DoSuffixMorph( const WCHAR *pwWord, WCHAR *pwRoot, LANGID LangID, DWORD dwFlags,
                                SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    SPDBG_FUNC( "CSMorph::DoSuffixMorph" );
    HRESULT hr = S_OK;
    SUFFIX_TYPE suffixCode;
    WCHAR TargWord[SP_MAX_WORD_LENGTH] = {0};
    long RootLen = 0;
    CSuffixList SuffixList;
    bool    bGotMorph, bNotDone, bLTS;

    if ( !pwWord || !pWordPronunciationList )
    {
        hr = E_POINTER;
    }

    else if ( SP_IS_BAD_WRITE_PTR( pwRoot )                        ||
              SPIsBadLexWord(pwWord)                               || 
              SPIsBadWordPronunciationList(pWordPronunciationList) || 
              LangID != 1033)
    {
        hr = E_INVALIDARG;
    }
    
    if (SUCCEEDED(hr)) 
    {        
        // INITIALIZE locals...
        suffixCode = NO_MATCH;
        bGotMorph = false;
        bNotDone = true;
        bLTS = false;

        wcscpy( TargWord, pwWord );           // Copy orth string...
        _wcsupr( TargWord );                  // ...and convert to uppercase
        RootLen = wcslen( TargWord );
        
        // Keep trying to match another suffix until a root word is matched in the lexicon, or
        // until some error condition is reached - no more suffix matches, etc.
        while ( !bGotMorph && bNotDone )
        {
            // Try to match a suffix...
            suffixCode = MatchSuffix( TargWord, &RootLen );
            // ...add it to the suffix list...
            if (suffixCode != NO_MATCH)
            {
                SuffixList.AddHead(&g_SuffixInfoTable[suffixCode]);
            }
            
            // ...and then behave appropriately.
            switch (suffixCode)
            {

                //------------------------------------------------------------
                // S - two special cases for +s suffix...
                //------------------------------------------------------------
            case S_SUFFIX:
                
                //--- Don't strip an S if it is preceded by another S...
                if ( TargWord[RootLen-1] == L'S' )
                {
                    bNotDone = false;
                    RootLen++;
                    SuffixList.RemoveHead();
                    if (!SuffixList.IsEmpty() && (dwFlags & eLEXTYPE_PRIVATE2))
                    {
                        hr = LTSLookup(pwWord, RootLen, pWordPronunciationList);
                        if (SUCCEEDED(hr))
                        {
                            bLTS = true;
                            bGotMorph = true;
                        }
                    }
                    else 
                    {
                        hr = SPERR_NOT_IN_LEX;
                    }
                    break; 
                }

                hr = LexLookup(TargWord, RootLen, dwFlags, pWordPronunciationList);
                if ( SUCCEEDED(hr) ) 
                {
                    bGotMorph = true;
                } 
                else if ( hr != SPERR_NOT_IN_LEX ) 
                {
                    bNotDone = false;
                }
                else if ( TargWord[RootLen - 1] == L'E' )
                {
                    hr = CheckYtoIEMutation(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if (SUCCEEDED(hr))
                    {
                        bGotMorph = true;
                    }
                    else if (hr != SPERR_NOT_IN_LEX)
                    {
                        bNotDone = false;
                    }
                    else
                    {
                        hr = LexLookup(TargWord, RootLen - 1, dwFlags, pWordPronunciationList);
                        if (SUCCEEDED(hr))
                        {
                            bGotMorph = true;
                        }
                        else if (hr != SPERR_NOT_IN_LEX)
                        {
                            bNotDone = false;
                        }
                    }
                }
                break;

                //------------------------------------------------------------
                // ICALLY_SUFFIX - special case, RAID #3201
                //------------------------------------------------------------
            case ICALLY_SUFFIX:
                hr = LexLookup( TargWord, RootLen + 2, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    bGotMorph = true;
                }
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                }
                else
                {
                    RootLen += 2;
                }
                break;

                //-------------------------------------------------------------
                // ILY_SUFFIX - special case, RAID #6571
                //-------------------------------------------------------------
            case ILY_SUFFIX:
                hr = CheckForMissingY( TargWord, RootLen, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    RootLen++;
                    bGotMorph = true;
                }
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                }
                break;

                //------------------------------------------------------------
                // ICISM_SUFFIX, ICIZE_SUFFIX - special case, RAID #6492
                //------------------------------------------------------------
            case ICISM_SUFFIX:
            case ICIZE_SUFFIX:
                hr = LexLookup( TargWord, RootLen + 2, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    bGotMorph = true;
                    for ( SPWORDPRONUNCIATION* pIterator = pWordPronunciationList->pFirstWordPronunciation;
                          pIterator; pIterator = pIterator->pNextWordPronunciation )
                    {
                        pIterator->szPronunciation[ wcslen( pIterator->szPronunciation ) - 1 ] = g_phonS[0];
                    }
                }
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                }
                else
                {
                    RootLen += 2;
                }
                break;

                //------------------------------------------------------------
                // NO_MATCH
                //------------------------------------------------------------
            case NO_MATCH:

                bNotDone = false;
                if (!SuffixList.IsEmpty() && (dwFlags & eLEXTYPE_PRIVATE2))
                {
                    hr = LTSLookup(pwWord, RootLen, pWordPronunciationList);
                    if (SUCCEEDED(hr))
                    {
                        bLTS = true;
                        bGotMorph = true;
                    }
                }
                else 
                {
                    hr = SPERR_NOT_IN_LEX;
                }
                break; 

                //----------------------------------------------------------------
                // ABLY - special case (for probably, etc.) RAID #3168
                //----------------------------------------------------------------
            case ABLY_SUFFIX:
                hr = CheckAbleMutation( TargWord, RootLen, dwFlags, pWordPronunciationList );
                if ( SUCCEEDED( hr ) )
                {
                    for ( SPWORDPRONUNCIATION *pIterator = pWordPronunciationList->pFirstWordPronunciation;
                          pIterator; pIterator = pIterator->pNextWordPronunciation )
                    {
                        if ( wcslen( pIterator->szPronunciation ) > 2 &&
                             wcscmp( ( pIterator->szPronunciation + 
                                       ( wcslen( pIterator->szPronunciation ) - 2 ) ),
                                     g_phonAXl ) == 0 )
                        {
                            wcscpy( ( pIterator->szPronunciation +
                                      ( wcslen( pIterator->szPronunciation ) - 2 ) ),
                                    g_phonL );
                        }
                    }
                    SuffixList.RemoveHead();
                    SuffixList.AddHead( &g_SuffixInfoTable[Y_SUFFIX] );
                    bGotMorph = true;
                    break;
                }   
                else if ( hr != SPERR_NOT_IN_LEX )
                {
                    bNotDone = false;
                    break;
                }
                //--- else no break - just continue on to default behavior...

                //------------------------------------------------------------
                // ALL OTHER SUFFIXES
                //------------------------------------------------------------
                
            default:

                // If applicable, try looking up the root with an added e first - this prevents things like
                // "taping" coming out as "tapping" rather than "tape +ing"
                // FIX BUG #2301, #3649 - ONLY Try with added e if the root does not end in o, e, w, or y
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) && 
                     (g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckForMissingE) &&
                     TargWord[RootLen-1] != L'O' &&
                     ( TargWord[RootLen-1] != L'E' || suffixCode == ED_SUFFIX ) &&
                     TargWord[RootLen-1] != L'W' &&
                     TargWord[RootLen-1] != L'Y' )
                {
                    hr = CheckForMissingE(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        RootLen++;
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                // Try looking up the root...
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) )
                {
                    hr = LexLookup(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                // If previous lookups failed, try looking up the root with a 'y' in place of the final 'i'...
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) && 
                     (g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckYtoIMutation) )
                {
                    hr = CheckYtoIMutation(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                // If previous lookups failed, try looking up the root with an undoubled ending...
                if ( (SUCCEEDED(hr) || hr == SPERR_NOT_IN_LEX) && 
                     (g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckDoubledMutation) )
                {
                    hr = CheckDoubledMutation(TargWord, RootLen, dwFlags, pWordPronunciationList);
                    if ( SUCCEEDED(hr) ) 
                    {
                        RootLen--;
                        bGotMorph = true;
                        break;
                    } 
                    else if ( hr != SPERR_NOT_IN_LEX ) 
                    {
                        bNotDone = false;
                        break;
                    }
                }

                //--- If previous lookups failed, try looking up the root with an added 'l'
                if ( ( SUCCEEDED( hr ) || hr == SPERR_NOT_IN_LEX ) &&
                     ( g_SuffixInfoTable[suffixCode].dwMorphSpecialCaseFlags & eCheckForMissingL ) )
                {
                    hr = CheckForMissingL( TargWord, RootLen, dwFlags, pWordPronunciationList );
                    if ( SUCCEEDED( hr ) )
                    {
                        RootLen++;
                        bGotMorph = true;
                        break;
                    }
                    else if ( hr != SPERR_NOT_IN_LEX )
                    {
                        bNotDone = false;
                        break;
                    }
                }

                break;

            } // switch (SuffixCode)
        } // while ( !bGotMorph && bNotDone )
        if ( SUCCEEDED(hr) && bGotMorph ) 
        {
            if (!SuffixList.IsEmpty())
            {
                //--- Copy found root word into out parameter, pwRoot
                wcsncpy( pwRoot, TargWord, RootLen );
                //--- Log info to debug file
                TTSDBG_LOGMORPHOLOGY( pwRoot, SuffixList, STREAM_MORPHOLOGY );
                if (bLTS)
                {
                    hr = AccumulateSuffixes_LTS( &SuffixList, pWordPronunciationList );
                }
                else
                {
                    hr = AccumulateSuffixes( &SuffixList, pWordPronunciationList );
                }
            }
        }
    }

    return hr;
} /* CSMorph::DoSuffixMorph */


/*****************************************************************************
* CSMorph::MatchSuffix *
*----------------------*
*	Description:    This function attempts to match a suffix in TargWord.
*		
********************************************************************** AH ***/
SUFFIX_TYPE CSMorph::MatchSuffix( WCHAR *TargWord, long *RootLen )
{
    SPDBG_FUNC( "CSMorph::MatchSuffix" );
    SUFFIX_TYPE suffixCode = NO_MATCH;
    long RootEnd = *RootLen - 1;
    const WCHAR *pTempSuffix = NULL;

    for (int i = 0; i < sp_countof(g_SuffixTable); i++) 
    {
        pTempSuffix = g_SuffixTable[i].Orth;
        while ( (TargWord[RootEnd] == *pTempSuffix) && (RootEnd > 1) && (suffixCode == NO_MATCH) )
        {
            RootEnd--;
            pTempSuffix++;
            if ( *pTempSuffix == '\0' )
            {
                suffixCode = g_SuffixTable[i].Type;
            }
        }
        if (suffixCode != NO_MATCH)
        {
            *RootLen = RootEnd + 1;
            break;
        }
        else
        {
            RootEnd = *RootLen - 1;
        }
    }

    return suffixCode;
} /* CSMorph::MatchSuffix */


/*****************************************************************************
* CSMorph::LexLookup *
*--------------------*
*	Description:    Try to look up the hypothesized root in the lexicon.
*		
********************************************************************** MC ***/
HRESULT CSMorph::LexLookup( const WCHAR *pOrth, long length, DWORD dwFlags, 
                            SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    SPDBG_FUNC( "CSMorph::LexLookup" );
    WCHAR  targRoot[SP_MAX_WORD_LENGTH];
    memset (targRoot, 0, SP_MAX_WORD_LENGTH * sizeof(WCHAR));
    HRESULT hr = SPERR_NOT_IN_LEX;
    
    //---------------------------------
    // Copy root candidate only...
    //---------------------------------
    for( long i = 0; i < length; i++ )
    {
        targRoot[i] = pOrth[i];
    }
    targRoot[i] = 0;    // Delimiter
    
    //---------------------------------
    // ...and look it up
    //---------------------------------
    if (dwFlags & eLEXTYPE_USER)
    {
        hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_USER, pWordPronunciationList );
    }
    if ((hr == SPERR_NOT_IN_LEX) && (dwFlags & eLEXTYPE_APP))
    {
        hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_APP, pWordPronunciationList );
    }
    if ((hr == SPERR_NOT_IN_LEX) && (dwFlags & eLEXTYPE_PRIVATE1))
    {
        hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_PRIVATE1, pWordPronunciationList );
    }

    return hr;
} /* CSMorph::LexLookup */


/*****************************************************************************
* CSMorph::LTSLookup *
*--------------------*
*	Description:    Try to get a pronunciation for the hypothesized root from 
*       the LTS lexicon...
*		
********************************************************************** AH ***/
HRESULT CSMorph::LTSLookup( const WCHAR *pOrth, long length, 
                            SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    SPDBG_FUNC( "CSMorph::LTSLookup" );
    WCHAR targRoot[SP_MAX_WORD_LENGTH];
    memset(targRoot, 0, SP_MAX_WORD_LENGTH * sizeof(WCHAR));
    HRESULT hr = S_OK;

    //-------------------------------
    // Copy root candidate only...
    //-------------------------------
    for ( long i = 0; i < length; i++ )
    {
        targRoot[i] = pOrth[i];
    }
    targRoot[i] = 0;

    //-------------------------------
    // ...and look it up
    //-------------------------------
    hr = m_pMasterLex->GetPronunciations( targRoot, 1033, eLEXTYPE_PRIVATE2, pWordPronunciationList );

    return hr;
} /* CSMorph::LTSLookup */


/*****************************************************************************
* CSMorph::AccumulateSuffixes *
*-----------------------------*
*	Description:    Append pronunciations of all the suffixes to the
*       retrieved pronunciation of the root word.
*   
*   First attempt a very strict derivation, where each suffix appended has
*   a "To" part of speech which matches the part of speech of the current
*   state of the entire word.  Ex:
*
*       govern (Verb) + ment (Verb -> Noun) + s (Noun -> Noun) -> governments (Noun)
*
*   If this fails, just accumulate all the pronunciations, and use all of
*   the "To" parts of speech of the last suffix.  Ex:
*
*       cat (Noun) + ing (Verb -> Verb, Verb -> Adj, Verb -> Noun) -> catting (Verb, Adj, Noun)
*		
********************************************************************** AH ***/
HRESULT CSMorph::AccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList ) 
{
    /********** Local Variable Declarations **********/
    SPWORDPRONUNCIATIONLIST *pTempWordPronunciationList;
    SPWORDPRONUNCIATION *pWordPronIterator = NULL, *pTempWordPronunciation = NULL;
    SPLISTPOS ListPos;
    SUFFIXPRON_INFO *SuffixPronInfo;
    ENGPARTOFSPEECH ActivePos[NUM_POS] = {MS_Unknown}, FinalPos[NUM_POS] = {MS_Unknown};
    WCHAR pBuffer[SP_MAX_PRON_LENGTH], pSuffixString[10];
    DWORD dwTotalSize = 0, dwNumActivePos = 0, dwNumFinalPos = 0;
    HRESULT hr = S_OK;
    bool bPOSMatch = false, bDerivedAWord = false;

    /********** Allocate enough space for the modified pronunciations **********/
    dwTotalSize = sizeof(SPWORDPRONUNCIATIONLIST) + 
        (NUM_POS * (sizeof(SPWORDPRONUNCIATION) + (SP_MAX_PRON_LENGTH * sizeof(WCHAR))));
    pTempWordPronunciationList = new SPWORDPRONUNCIATIONLIST;
    if ( !pTempWordPronunciationList )
    {
        hr = E_OUTOFMEMORY;
    }
    if ( SUCCEEDED( hr ) )
    {
        memset(pTempWordPronunciationList, 0, sizeof(SPWORDPRONUNCIATIONLIST));
        hr = ReallocSPWORDPRONList( pTempWordPronunciationList, dwTotalSize );
    }

    /************************************
     *  First Attempt Strict Derivation *
     ************************************/

    /********** Set Initial Values of prounciation list iterators **********/
    if (SUCCEEDED(hr))
    {
        pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
        pTempWordPronunciation = pTempWordPronunciationList->pFirstWordPronunciation;
    }

    /********** Iterate over pWordPronunciationList **********/
    while (SUCCEEDED(hr) && pWordPronIterator)
    {
        // Store the pronunciation in a buffer...
        wcscpy(pBuffer, pWordPronIterator->szPronunciation);

        // Initialize variables which are local to the next loop...
        bPOSMatch = true;
        ListPos = pSuffixList->GetHeadPosition();

        ActivePos[0] = (ENGPARTOFSPEECH)pWordPronIterator->ePartOfSpeech;
        dwNumActivePos = 1;

        /********** Iterate over the SuffixList **********/
        while ( SUCCEEDED(hr) && ListPos && bPOSMatch ) 
        {
            // Initialize variables which are local to the next loop...
            bPOSMatch = false;
            SuffixPronInfo = pSuffixList->GetNext( ListPos );
            wcscpy(pSuffixString, SuffixPronInfo->SuffixString);
            ENGPARTOFSPEECH NextActivePos[NUM_POS] = {MS_Unknown};
            DWORD dwNumNextActivePos = 0;
            
            /********** Iterate over the active parts of speech **********/
            for (DWORD j = 0; j < dwNumActivePos; j++)
            {
                /********** Iterate over the possible conversions of each suffix **********/
                for (short i = 0; i < SuffixPronInfo->NumConversions; i++)
                {
                    /********** Check POS compatability **********/
                    if (SuffixPronInfo->Conversions[i].FromPos == ActivePos[j])
                    {
                        if (!SearchPosSet(SuffixPronInfo->Conversions[i].ToPos, NextActivePos, dwNumNextActivePos))
                        {
                            NextActivePos[dwNumNextActivePos] = SuffixPronInfo->Conversions[i].ToPos;
                            dwNumNextActivePos++;

                            /********** One time only - concatenate pronunciation, and change POSMatch flag to true **********/
                            if (dwNumNextActivePos == 1)
                            {
                                bPOSMatch = true;

                                // Append suffix to the rest of the pronunciation...
                                // Special Cases...
                                if (pSuffixString[0] == g_phonS[0] && pSuffixString[1] == '\0')
                                {
                                    hr = Phon_SorZ( pBuffer, wcslen(pBuffer) - 1 );
                                }
                                else if (pSuffixString[0] == g_phonD[0] && pSuffixString[1] == '\0')
                                {
                                    hr = Phon_DorED( pBuffer, wcslen(pBuffer) - 1 );
                                }
                                // Default Case...
                                else
                                {
                                    if ( SuffixPronInfo == g_SuffixInfoTable + ICISM_SUFFIX ||
                                         SuffixPronInfo == g_SuffixInfoTable + ICIZE_SUFFIX )
                                    {
                                        pBuffer[ wcslen( pBuffer ) - 1 ] = g_phonS[0];
                                    }

                                    // Make sure we don't write past the end of the buffer...
                                    if ( wcslen(pBuffer) + wcslen(pSuffixString) <= SP_MAX_PRON_LENGTH )
                                    {
                                        wcscat(pBuffer, pSuffixString);
                                    }
                                    else
                                    {
                                        hr = E_FAIL;
                                    }
                                }
                            }
                        }
                    }
                } // for (short i = 0; i < SuffixPronInfo->NumConversions; i++)
            } // for (DWORD j = 0; j < dwNumActivePos; j++)

            /********** Update ActivePos values **********/
            for (DWORD i = 0; i < dwNumNextActivePos; i++)
            {
                ActivePos[i] = NextActivePos[i];
            }
            dwNumActivePos = dwNumNextActivePos;

        } // while ( SUCCEEDED(hr) && ListPos && bPOSMatch )

        /********** Check to see if any derivations have succeeded **********/
        if ( SUCCEEDED(hr) && bPOSMatch )
        {
            for (DWORD i = 0; i < dwNumActivePos; i++)
            {
                if (!SearchPosSet(ActivePos[i], FinalPos, dwNumFinalPos))
                {
                    // We have succeeded in deriving a word - add it to the temporary word pron list...
                    FinalPos[dwNumFinalPos] = ActivePos[i];
                    dwNumFinalPos++;
                    if ( bDerivedAWord )
                    {
                        // This is not the first successful pronunciation match - need to advance the iterator...
                        pTempWordPronunciation->pNextWordPronunciation = CreateNextPronunciation( pTempWordPronunciation );
                        pTempWordPronunciation = pTempWordPronunciation->pNextWordPronunciation;
                    }
                    bDerivedAWord = true;
                    pTempWordPronunciation->eLexiconType = (SPLEXICONTYPE)(pWordPronIterator->eLexiconType | eLEXTYPE_PRIVATE3);
                    pTempWordPronunciation->ePartOfSpeech = (SPPARTOFSPEECH) ActivePos[i];
                    pTempWordPronunciation->LangID = pWordPronIterator->LangID;
                    wcscpy(pTempWordPronunciation->szPronunciation, pBuffer);
                    pTempWordPronunciation->pNextWordPronunciation = NULL;
                }
            }
        }

        // Advance SPWORDPRONUNCIATIONLIST iterator...
        if (SUCCEEDED(hr))
        {
            pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
        }

    } // while (SUCCEEDED(hr) && pWordPronIterator)


    /****************************************
     * Did we succeed in deriving anything? *
     ****************************************/

    /**********************************************************
     * If so, copy it into pWordPronunciationList and return. *
     **********************************************************/
    if ( SUCCEEDED(hr) && bDerivedAWord )
    {
        // Copy successful words into pWordPronunciationList for eventual return to DoSuffixMorph() caller...
        hr = ReallocSPWORDPRONList(pWordPronunciationList, pTempWordPronunciationList->ulSize);
        if (SUCCEEDED(hr))
        {
            pWordPronIterator = pTempWordPronunciationList->pFirstWordPronunciation;
            pTempWordPronunciation = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
            while (SUCCEEDED(hr) && pWordPronIterator)
            {
                pTempWordPronunciation->eLexiconType = (SPLEXICONTYPE)(pWordPronIterator->eLexiconType);
                pTempWordPronunciation->ePartOfSpeech = pWordPronIterator->ePartOfSpeech;
                pTempWordPronunciation->LangID = pWordPronIterator->LangID;
                wcscpy(pTempWordPronunciation->szPronunciation, pWordPronIterator->szPronunciation);
                pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
                if (pWordPronIterator)
                {
                    pTempWordPronunciation->pNextWordPronunciation = CreateNextPronunciation( pTempWordPronunciation );
                    pTempWordPronunciation = pTempWordPronunciation->pNextWordPronunciation;
                }
                else
                {
                    pTempWordPronunciation->pNextWordPronunciation = NULL;
                }
            }
        }
    }
    /***************************************
     * If not, just do default derivation. *
     ***************************************/
    else if ( SUCCEEDED(hr) )
    {
        hr = DefaultAccumulateSuffixes( pSuffixList, pWordPronunciationList );
    }
    ::CoTaskMemFree(pTempWordPronunciationList->pvBuffer);
    delete pTempWordPronunciationList;

    return hr;
} /* CSMorph::AccumulateSuffixes */


/*****************************************************************************
* CSMorph::AccumulateSuffixes_LTS *
*---------------------------------*
*	Description:    Append pronunciations of all the suffixes to the
*       retrieved pronunciation of the root word.
*		
********************************************************************** AH ***/
HRESULT CSMorph::AccumulateSuffixes_LTS( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList ) 
{
    HRESULT hr = S_OK;
    SPWORDPRONUNCIATION *pTempWordPronunciation = NULL, *pOriginalWordPronunciation = NULL;
    DWORD dwTotalSize = 0, dwNumPos = 0;
    SUFFIXPRON_INFO *SuffixPronInfo;
    ENGPARTOFSPEECH PartsOfSpeech[NUM_POS] = {MS_Unknown};
    WCHAR pBuffer[SP_MAX_PRON_LENGTH];
    SPLEXICONTYPE OriginalLexType;
    LANGID OriginalLangID;
    WORD OriginalReservedField;

    /*** Get the original pronunciation ***/
    pOriginalWordPronunciation = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
    OriginalLexType = pOriginalWordPronunciation->eLexiconType;
    OriginalLangID  = pOriginalWordPronunciation->LangID;
    OriginalReservedField = pOriginalWordPronunciation->wReserved;

    /*** Get First Suffix ***/
    SuffixPronInfo = pSuffixList->RemoveHead();

    /*** Copy the pronunciation of the root ***/
    wcscpy( pBuffer, pOriginalWordPronunciation->szPronunciation );

    /*** Append the pronunciation of the first suffix ***/
    if ( SuffixPronInfo->SuffixString[0] == g_phonS[0] && 
         SuffixPronInfo->SuffixString[1] == 0 )
    {
        hr = Phon_SorZ( pBuffer, wcslen(pBuffer) - 1 );
    }
    else if ( SuffixPronInfo->SuffixString[0] == g_phonD[0] &&
              SuffixPronInfo->SuffixString[1] == 0 )
    {
        hr = Phon_DorED( pBuffer, wcslen(pBuffer) - 1 );
    }
    else if ( wcslen(pBuffer) + wcslen(SuffixPronInfo->SuffixString) <= SP_MAX_PRON_LENGTH )
    {
        if ( SuffixPronInfo == g_SuffixInfoTable + ICISM_SUFFIX ||
             SuffixPronInfo == g_SuffixInfoTable + ICIZE_SUFFIX )
        {
            pBuffer[ wcslen( pBuffer ) - 1 ] = g_phonS[0];
        }

        wcscat( pBuffer, SuffixPronInfo->SuffixString );
    }
    else
    {
        wcsncat( pBuffer, SuffixPronInfo->SuffixString,
                 SP_MAX_PRON_LENGTH - ( wcslen(pBuffer) + wcslen(SuffixPronInfo->SuffixString ) ) );
    }

    if ( SUCCEEDED( hr ) )
    {
        /*** Allocate enough space for all of the pronunciations ***/
        dwTotalSize = sizeof(SPWORDPRONUNCIATIONLIST) + 
                      ( NUM_POS * ( sizeof(SPWORDPRONUNCIATION) + (SP_MAX_PRON_LENGTH * sizeof(WCHAR) ) ) );
        hr = ReallocSPWORDPRONList( pWordPronunciationList, dwTotalSize );
    }

    if ( SUCCEEDED( hr ) )
    {
        /*** Build list of parts of speech ***/
        for ( int i = 0; i < SuffixPronInfo->NumConversions; i++ )
        {
            if ( !SearchPosSet( SuffixPronInfo->Conversions[i].ToPos, PartsOfSpeech, dwNumPos ) )
            {
                PartsOfSpeech[dwNumPos] = SuffixPronInfo->Conversions[i].ToPos;
                dwNumPos++;
            }
        }

        pTempWordPronunciation = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;

        /*** Build TempWordPronunciationList to send to AccumulateSuffixes ***/
        for ( i = 0; i < (int) dwNumPos; i++ )
        {
            if ( i > 0 )
            {
                pTempWordPronunciation->pNextWordPronunciation = CreateNextPronunciation( pTempWordPronunciation );
                pTempWordPronunciation = pTempWordPronunciation->pNextWordPronunciation;
            }
            pTempWordPronunciation->eLexiconType           = (SPLEXICONTYPE)(OriginalLexType | eLEXTYPE_PRIVATE3);
            pTempWordPronunciation->LangID                 = OriginalLangID;
            pTempWordPronunciation->wReserved              = OriginalReservedField;
            pTempWordPronunciation->ePartOfSpeech          = (SPPARTOFSPEECH)PartsOfSpeech[i];
            pTempWordPronunciation->pNextWordPronunciation = NULL;
            wcscpy(pTempWordPronunciation->szPronunciation, pBuffer);
        }
    }

    if ( SUCCEEDED( hr ) &&
         !pSuffixList->IsEmpty() )
    {
        /*** Pass accumulated list to AccumulateSuffixes ***/
        hr = AccumulateSuffixes( pSuffixList, pWordPronunciationList );
    }

    return hr;
} /* CSMorph::AccumulateSuffixes_LTS */

/*****************************************************************************
* CSMorph::DefaultAccumulateSuffixes *
*------------------------------------*
*	Description:    Append pronunciations of all the suffixes to the
*       retrieved pronunciation of the root word.
*   
*   Just accumulate all the pronunciations, and use all of
*   the "To" parts of speech of the last suffix.  Ex:
*
*       cat (Noun) + ing (Verb -> Verb, Verb -> Adj, Verb -> Noun) -> catting (Verb, Adj, Noun)
*		
********************************************************************** AH ***/
HRESULT CSMorph::DefaultAccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList )
{
    HRESULT hr = S_OK;
    ENGPARTOFSPEECH PartsOfSpeech[NUM_POS] = { MS_Unknown };
    SPWORDPRONUNCIATION *pWordPronIterator = NULL;
    WCHAR pBuffer[SP_MAX_PRON_LENGTH];
    SUFFIXPRON_INFO *SuffixPronInfo = NULL;
    SPLISTPOS ListPos;
    DWORD dwTotalSize = 0;
    int NumPOS = 0;
    SPLEXICONTYPE OriginalLexType;
    LANGID OriginalLangID;
    WORD OriginalReservedField;

    /*** Initialize pBuffer and OriginalXXX variables ***/
    ZeroMemory( pBuffer, sizeof( pBuffer ) );
    OriginalLexType = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->eLexiconType;
    OriginalLangID  = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->LangID;
    OriginalReservedField = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->wReserved;

    /****************************************************************
     *** Get Desired Pronunciation of result, and Parts of Speech ***
     ****************************************************************/

    //--- Get pronunciation of root word
    wcscpy( pBuffer, ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation->szPronunciation );

    //--- Loop through suffix list, appending pronunciations of suffixes to that of the root.
    ListPos = pSuffixList->GetHeadPosition();

    //--- List should never be empty at this point
    SPDBG_ASSERT( ListPos );
    while ( ListPos )
    {
        SuffixPronInfo = pSuffixList->GetNext( ListPos );
        if ( wcslen(pBuffer) + wcslen(SuffixPronInfo->SuffixString) < SP_MAX_PRON_LENGTH )
        {
            wcscat( pBuffer, SuffixPronInfo->SuffixString );
        }
    }
    
    //--- Get the "to" parts of speech of the last suffix
    for ( int i = 0; i < SuffixPronInfo->NumConversions; i++ )
    {
        PartsOfSpeech[i] = SuffixPronInfo->Conversions[i].ToPos;
    }
    NumPOS = i;

    /***********************************************************************************
     * Now put derived words into pWordPronunciationList for return from DoSuffixMorph *
     ***********************************************************************************/

    //--- First make sure there is enough room
    dwTotalSize = ( sizeof(SPWORDPRONUNCIATIONLIST) ) +
                  ( NumPOS * ( (wcslen(pBuffer) * sizeof(WCHAR)) + sizeof(SPWORDPRONUNCIATION) ) );                      
    hr = ReallocSPWORDPRONList( pWordPronunciationList, dwTotalSize );

    if ( SUCCEEDED( hr ) )
    {
        //--- Now add pronunciation once for each part of speech
        pWordPronIterator = pWordPronunciationList->pFirstWordPronunciation;
        for ( i = 0; i < NumPOS; i++ )
        {
            pWordPronIterator->eLexiconType  = (SPLEXICONTYPE) ( OriginalLexType |  eLEXTYPE_PRIVATE3 );
            pWordPronIterator->LangID        = OriginalLangID;
            pWordPronIterator->wReserved     = OriginalReservedField;
            pWordPronIterator->ePartOfSpeech = (SPPARTOFSPEECH)PartsOfSpeech[i];
            wcscpy( pWordPronIterator->szPronunciation, pBuffer );
            if ( i < NumPOS - 1 )
            {
                pWordPronIterator->pNextWordPronunciation = CreateNextPronunciation( pWordPronIterator );
                pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
            }
            else
            {
                pWordPronIterator->pNextWordPronunciation = NULL;
            }
        }
    }

    return hr;
}

/*****************************************************************************
* CSMorph::CheckForMissingE *
*---------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'e' 
*       e.g. make -> making
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckForMissingE( WCHAR *pOrth, long length, DWORD dwFlags, 
                                 SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    WCHAR   charSave;
    
    charSave = pOrth[length];			// save orig before we...
    pOrth[length] = L'E'; 				// ...end root with E
    hr = LexLookup( pOrth, length+1, dwFlags, pWordPronunciationList );
    if ( FAILED(hr) )
    {
        pOrth[length] = charSave;		// restore original char   
    }
    else if ( length > 0 &&
              pOrth[length - 1] == L'L' )
    {
        //--- Check for juggle -> juggler schwa deletion
        SPWORDPRONUNCIATION *pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
        while ( pWordPronIterator )
        {
            if ( wcslen( pWordPronIterator->szPronunciation ) >= 2 )
            {
                WCHAR *pLastTwoPhonemes = pWordPronIterator->szPronunciation + 
                    ( wcslen( pWordPronIterator->szPronunciation ) - 2 );
                if ( wcscmp( pLastTwoPhonemes, g_phonAXl ) == 0 )
                {
                    //--- Orthography ends in -le and pronunciation ends in -AXl, delete AX...
                    pLastTwoPhonemes[0] = pLastTwoPhonemes[1];
                    pLastTwoPhonemes[1] = 0;
                }
                pWordPronIterator = pWordPronIterator->pNextWordPronunciation;
            }
        }
    }
    return hr;
} /* CSMorph::CheckForMissingE */

/*****************************************************************************
* CSMorph::CheckForMissingY *
*---------------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'y' 
*       e.g. happy -> happily
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckForMissingY( WCHAR *pOrth, long length, DWORD dwFlags, 
                                   SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    WCHAR   charSave;
    
    charSave = pOrth[length];			// save orig before we...
    pOrth[length] = L'Y'; 				// ...end root with E
    hr = LexLookup( pOrth, length+1, dwFlags, pWordPronunciationList );
    if ( FAILED(hr) )
    {
        pOrth[length] = charSave;		// restore original char   
    }
    else 
    {
        //--- Delete IY at end of pronunciations ( e.g. happy + ily -> [ H AE 1 P (IY) ] + [ AX L IY ] )
        for ( SPWORDPRONUNCIATION *pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation; 
              pWordPronIterator; pWordPronIterator = pWordPronIterator->pNextWordPronunciation )
        {
            if ( pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] == g_phonIY[0] )
            {
                pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] = 0;
            }
        }
    }
    return hr;
} /* CSMorph::CheckForMissingY */

/*****************************************************************************
* CSMorph::CheckForMissingL *
*---------------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'l' 
*       e.g. chill -> chilly
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckForMissingL( WCHAR *pOrth, long length, DWORD dwFlags, 
                                   SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    WCHAR   charSave;
    
    charSave = pOrth[length];			// save orig before we...
    pOrth[length] = L'L'; 				// ...end root with E
    hr = LexLookup( pOrth, length+1, dwFlags, pWordPronunciationList );
    if ( FAILED(hr) )
    {
        pOrth[length] = charSave;		// restore original char   
    }
    else 
    {
        //--- Delete l at end of pronunciations ( e.g. chill +ly -> [ ch ih 1 (l) ] + [ l iy ] )
        for ( SPWORDPRONUNCIATION *pWordPronIterator = ((SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation; 
              pWordPronIterator; pWordPronIterator = pWordPronIterator->pNextWordPronunciation )
        {
            if ( pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] == g_phonL[0] )
            {
                pWordPronIterator->szPronunciation[ wcslen( pWordPronIterator->szPronunciation ) - 1 ] = 0;
            }
        }
    }
    return hr;
} /* CSMorph::CheckForMissingL */

/*****************************************************************************
* CSMorph::CheckYtoIMutation *
*---------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'y' to
*       an 'i'
*       e.g. steady + est -> steadiest
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckYtoIMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                    SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    
    if ( pOrth[length - 1] == L'I' )
    {
        pOrth[length - 1] = L'Y'; 				// end root with Y
        hr = LexLookup( pOrth, length, dwFlags, pWordPronunciationList );
        if ( FAILED(hr) )
        {
            pOrth[length - 1] = L'I';		    // restore I 
        }
    } 
    else 
    {
        hr = SPERR_NOT_IN_LEX;
    }
    return hr;
} /* CSMorph::CheckYtoIMutation */


/*****************************************************************************
* CSMorph::CheckDoubledMutation *
*----------------------*
*	Description:    Check Lexicon to see if the root word has a doubled 
*       consonant.
*       e.g. run + ing -> running
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckDoubledMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                       SPWORDPRONUNCIATIONLIST *pWordPronunciationList)
{
    HRESULT hr = S_OK;

    switch ( pOrth[length - 1] )
    {
        // Filter the vowels, which never double...
    case L'A':
    case L'E':
    case L'I':
    case L'O':
    case L'U':
    case L'Y':
        // Filter consonants which never double, or are doubled in roots...
    case L'F':
    case L'H':
    case L'K':
    case L'S':
    case L'W':
    case L'Z':
        hr = SPERR_NOT_IN_LEX;
        break;

    default:
		if(pOrth[length-1] == pOrth[length-2]) {
	        hr = LexLookup( pOrth, length - 1, dwFlags, pWordPronunciationList );
		    break;
		}
		else {
			hr = SPERR_NOT_IN_LEX;
			break;
		}
    }
    return hr;
} /* CSMorph::CheckDoubledMutation */

/*****************************************************************************
* CSMorph::CheckYtoIEMutation *
*---------------------*
*	Description:    Check Lexicon to see if the root word has lost an 'y' to
*       an 'ie'
*       e.g. company + s -> companies
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckYtoIEMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                    SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    
    if ( pOrth[length - 1] == L'E' && pOrth[length-2] == L'I' )
    {
        pOrth[length - 2] = L'Y'; 				// end root with Y
        hr = LexLookup( pOrth, length - 1, dwFlags, pWordPronunciationList );
        if ( FAILED(hr) )
        {
            pOrth[length - 2] = L'I';		    // restore I 
        }
    } 
    else 
    {
        hr = SPERR_NOT_IN_LEX;
    }
    return hr;
} /* CSMorph::CheckYtoIMutation */

/*****************************************************************************
* CSMorph::CheckAbleMutation *
*----------------------------*
*	Description:    Check Lexicon for special -able -> -ably cases (e.g.
*       probable -> probably )
*		
********************************************************************** AH ***/
HRESULT CSMorph::CheckAbleMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                    SPWORDPRONUNCIATIONLIST *pWordPronunciationList) 
{
    HRESULT hr = S_OK;
    
    //--- Look up word ending in -able
    pOrth[length+3] = L'E';
    hr = LexLookup( pOrth, length + 4, dwFlags, pWordPronunciationList );
    if ( FAILED( hr ) )
    {
        //--- restore "y"
        pOrth[length+3] = L'Y';
    }
    return hr;
} /* CSMorph::CheckAbleMutation */

/*****************************************************************************
* CSMorph::Phon_SorZ *
*--------------------*
*	Description:    Figure out what phoneme the S suffix should be - s, z, or 
*                   IXz
*		
********************************************************************** AH ***/
HRESULT CSMorph::Phon_SorZ( WCHAR *pPronunciation, long length )
{
    HRESULT hr = S_OK;

    if ( SUCCEEDED(hr) && pPronunciation[length] < sp_countof(g_PhonTable) ) 
    {
        if ( ((PHONTYPE)g_PhonTable[pPronunciation[length]] & ePALATALF) || 
             (pPronunciation[length] == g_phonS[0])           || 
             (pPronunciation[length] == g_phonZ[0]) )
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonAXz) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonAXz);
            }
        } 
        else if( ((PHONTYPE)g_PhonTable[pPronunciation[length]] & eCONSONANTF) && 
                 !((PHONTYPE)g_PhonTable[pPronunciation[length]] & eVOICEDF) )
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonZ) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonS);
            }
        }
        else
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonS) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonZ);
            }
        }
    }
    else 
    {
        hr = E_FAIL;
    }

    return hr;
} /* CSMorph::Phon_SorZ */

/*****************************************************************************
* CSMorph::Phon_DorED *
*---------------------*
*	Description:    Figure out what phoneme the D suffix should be - d, t,
*                   or AXd
*		
********************************************************************** AH ***/
HRESULT CSMorph::Phon_DorED( WCHAR *pPronunciation, long length )
{
    HRESULT hr = S_OK;

    if ( SUCCEEDED(hr) && pPronunciation[length] < sp_countof(g_PhonTable) ) 
    {
        if ( (pPronunciation[length] == g_phonT[0]) || (pPronunciation[length] == g_phonD[0]) )
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonAXd) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonAXd);
            }
        } 
        else if ((PHONTYPE)g_PhonTable[pPronunciation[length]] & eVOICEDF)
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonD) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonD);
            }
        }
        else 
        {
            if ( wcslen(pPronunciation) + wcslen(g_phonT) <= SP_MAX_PRON_LENGTH )
            {
                wcscat(pPronunciation, g_phonT);
            }
        }
    }
    else 
    {
        hr = E_FAIL;
    }

    return hr;
} /* CSMorph::Phon_DorED */

//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\miscnorm.cpp ===
/***********************************************************************************************
* MiscNorm.cpp *
*--------------*
*  Description:
*   These are miscallaneous functions used in normalization.
*-----------------------------------------------------------------------------------------------
*  Created by AH                                                                August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

/*****************************************************************************
* IsStateAndZipcode *
*-------------------*
*       This function checks to see if the next two tokens are a state
*   abbreviation and zipcode.
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::IsStateAndZipcode( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                         CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsStateAndZipcode" );
    HRESULT hr = S_OK;

    const StateStruct *pState = NULL;
    const WCHAR temp = *m_pEndOfCurrItem;
    *( (WCHAR*) m_pEndOfCurrItem ) = 0;

    //--- Try to match a state abbreviation
    pState = (StateStruct*) bsearch( (void*) m_pNextChar, (void*) g_StateAbbreviations, sp_countof( g_StateAbbreviations),
                                     sizeof( StateStruct ), CompareStringAndStateStruct );

    if ( pState )
    {
        *( (WCHAR*) m_pEndOfCurrItem ) = temp;

        const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfCurrItem = m_pEndOfCurrItem;
        const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;
        CItemList PostStateList;
        TTSItemInfo *pZipCodeInfo;
        
        m_pNextChar = m_pEndOfCurrItem;
        if ( *m_pNextChar == L',' || 
             *m_pNextChar == L';' )
        {
            m_pNextChar++;
        }

        hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostStateList );

        if ( !m_pNextChar &&
             SUCCEEDED( hr ) )
        {
            hr = E_INVALIDARG;
        }
        else if ( SUCCEEDED( hr ) )
        {
            m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
            while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) )  != eUNMATCHED ||
                    IsGroupEnding( *(m_pEndOfCurrItem - 1) )      != eUNMATCHED ||
                    IsQuotationMark( *(m_pEndOfCurrItem - 1) )    != eUNMATCHED ||
                    IsEOSItem( *(m_pEndOfCurrItem - 1) )          != eUNMATCHED )
            {
                m_pEndOfCurrItem--;
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = IsZipCode( pZipCodeInfo, L"ZIPCODE", MemoryManager );
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo = 
                    (TTSStateAndZipCodeItemInfo*) MemoryManager.GetMemory( sizeof( TTSStateAndZipCodeItemInfo ), 
                                                                           &hr );
                if ( SUCCEEDED( hr ) )
                {
                    pItemNormInfo->Type = eSTATE_AND_ZIPCODE;
                    ( (TTSStateAndZipCodeItemInfo*) pItemNormInfo )->pZipCode = (TTSZipCodeItemInfo*) pZipCodeInfo;

                    TTSWord Word;
                    ZeroMemory( &Word, sizeof( TTSWord ) );

                    //--- Some states have multi-word names 
                    const WCHAR *pNextPointer = NULL, *pPrevPointer = NULL;
                    ULONG ulLength = 0;

                    pNextPointer = pState->FullName.pStr;
                    do {
                        pPrevPointer = pNextPointer;
                        pNextPointer = wcschr(pPrevPointer, L' ');
                        if (pNextPointer)
                        {
                            ulLength = (ULONG)(pNextPointer - pPrevPointer);
                            pNextPointer++;
                        }
                        else
                        {
                            ulLength = wcslen(pPrevPointer);
                        }
                        Word.pXmlState          = &pTempFrag->State;
                        Word.pWordText          = pPrevPointer;
                        Word.ulWordLen          = ulLength;
                        Word.pLemma             = pPrevPointer;
                        Word.ulLemmaLen         = ulLength;
                        Word.eWordPartOfSpeech  = MS_Unknown;
                        WordList.AddTail( Word );

                    } while ( pNextPointer );
                    
                    while( !PostStateList.IsEmpty() )
                    {
                        WordList.AddTail( ( PostStateList.RemoveHead() ).Words[0] );
                    }

                    hr = ExpandZipCode( (TTSZipCodeItemInfo*) pZipCodeInfo, WordList );
                }
            }
            else
            {
                m_pNextChar      = pTempNextChar;
                m_pEndOfCurrItem = pTempEndOfCurrItem;
                m_pEndChar       = pTempEndChar;
                m_pCurrFrag      = pTempFrag;
                hr = E_INVALIDARG;
            }
        }
        m_pNextChar = pTempNextChar;
    }
    else
    {
        *( (WCHAR*) m_pEndOfCurrItem ) = temp;
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsStateAndZipcode */

/*****************************************************************************
* IsHyphenatedString *
*--------------------*
*       This function checks to see if the next token is a hyphenated string
*   consisting of two alpha words or numbers, or one of these and another
*   hyphenated string.
********************************************************************* AH ****/
HRESULT CStdSentEnum::IsHyphenatedString( const WCHAR* pStartChar, const WCHAR* pEndChar, 
                                          TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsHyphenatedString" );
    HRESULT hr = S_OK;
    TTSItemInfo *pFirstChunkInfo = NULL, *pSecondChunkInfo = NULL;

    const WCHAR* pHyphen = NULL, *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    for ( pHyphen = pStartChar; pHyphen < pEndChar; pHyphen++ )
    {
        if ( *pHyphen == L'-' )
        {
            break;
        }
    }

    if ( *pHyphen == L'-'       && 
         pHyphen > pStartChar   &&
         pHyphen < pEndChar - 1 )
    {        
        hr = IsAlphaWord( pStartChar, pHyphen, pFirstChunkInfo, MemoryManager );
        if ( hr == E_INVALIDARG )
        {
            m_pNextChar      = pStartChar;
            m_pEndOfCurrItem = pHyphen;
            hr = IsNumberCategory( pFirstChunkInfo, L"NUMBER", MemoryManager );
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = IsAlphaWord( pHyphen + 1, pEndChar, pSecondChunkInfo, MemoryManager );
            if ( hr == E_INVALIDARG )
            {
                m_pNextChar      = pHyphen + 1;
                m_pEndOfCurrItem = pEndChar;
                hr = IsNumberCategory( pSecondChunkInfo, L"NUMBER", MemoryManager );
            }
            if ( hr == E_INVALIDARG )
            {
                hr = IsHyphenatedString( pHyphen + 1, pEndChar, pSecondChunkInfo, MemoryManager );
            }
            if ( hr == E_INVALIDARG )
            {
                if ( pFirstChunkInfo->Type != eALPHA_WORD )
                {
                    delete ( (TTSNumberItemInfo*) pFirstChunkInfo )->pWordList;
                }
            }
        }
        m_pNextChar      = pTempNextChar;
        m_pEndOfCurrItem = pTempEndOfItem;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        pItemNormInfo = (TTSHyphenatedStringInfo*) MemoryManager.GetMemory( sizeof(TTSHyphenatedStringInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eHYPHENATED_STRING;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pFirstChunkInfo  = pFirstChunkInfo;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pSecondChunkInfo = pSecondChunkInfo;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pFirstChunk      = pStartChar;
            ( (TTSHyphenatedStringInfo*) pItemNormInfo )->pSecondChunk     = pHyphen + 1;
        }
    }

    return hr;
} /* IsHyphenatedString */

/*****************************************************************************
* ExpandHyphenatedString *
*------------------------*
*       This function expands hyphenated strings.
********************************************************************* AH ****/
HRESULT CStdSentEnum::ExpandHyphenatedString( TTSHyphenatedStringInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandHyphenatedString" );
    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( pItemInfo->pFirstChunkInfo->Type == eALPHA_WORD )
    {
        Word.pWordText  = pItemInfo->pFirstChunk;
        Word.ulWordLen  = (ULONG)(pItemInfo->pSecondChunk - pItemInfo->pFirstChunk - 1);
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }
    else
    {
        hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pFirstChunkInfo, WordList );
    }

    if ( SUCCEEDED( hr ) )
    {
        if ( pItemInfo->pSecondChunkInfo->Type == eALPHA_WORD )
        {
            Word.pWordText  = pItemInfo->pSecondChunk;
            Word.ulWordLen  = (ULONG)(m_pEndOfCurrItem - pItemInfo->pSecondChunk);
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else if ( pItemInfo->pSecondChunkInfo->Type == eHYPHENATED_STRING )
        {
            hr = ExpandHyphenatedString( (TTSHyphenatedStringInfo*) pItemInfo->pSecondChunkInfo, WordList );
        }
        else
        {
            hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pSecondChunkInfo, WordList );
        }
    }

    return hr;
} /* ExpandHyphenatedString */

/*****************************************************************************
* IsSuffix *
*----------*
*       This function checks to see if the next token is a suffix string 
*   consisting of a hyphen followed by alpha characters.
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::IsSuffix( const WCHAR* pStartChar, const WCHAR* pEndChar, 
                                TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsSuffix" );
    HRESULT hr = S_OK;

    if ( *pStartChar == L'-' )
    {
        const WCHAR *pIterator = pStartChar + 1;
        while ( pIterator < pEndChar &&
                iswalpha( *pIterator ) )
        {
            pIterator++;
        }

        if ( pIterator == pEndChar &&
             pIterator != ( pStartChar + 1 ) )
        {
            pItemNormInfo = (TTSSuffixItemInfo*) MemoryManager.GetMemory( sizeof( TTSSuffixItemInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo->Type = eSUFFIX;
                ( (TTSSuffixItemInfo*) pItemNormInfo )->pFirstChar = pStartChar + 1;
                ( (TTSSuffixItemInfo*) pItemNormInfo )->ulNumChars = (ULONG)( ( pEndChar - pStartChar ) - 1 );
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsSuffix */

/*****************************************************************************
* ExpandSuffix *
*--------------*
*       This function expands strings determined to by suffixes by IsSuffix
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::ExpandSuffix( TTSSuffixItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandSuffix" );
    HRESULT hr = S_OK;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    for ( ULONG i = 0; i < pItemInfo->ulNumChars; i++ )
    {
        Word.pWordText  = g_ANSICharacterProns[ pItemInfo->pFirstChar[i] ].pStr;
        Word.ulWordLen  = g_ANSICharacterProns[ pItemInfo->pFirstChar[i] ].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    return hr;
} /* ExpandSuffix */

/*****************************************************************************
* ExpandPunctuation *
*-------------------*
*       This function expands punctuation marks into words - e.g. '.' becomes
*   "period".  It actually just uses the same table that 
*   ExpandUnrecognizedString uses to look up string versions of characters.
********************************************************************* AH ****/
void CStdSentEnum::ExpandPunctuation( CWordList& WordList, WCHAR wc )
{
    const WCHAR *pPrevPointer = NULL, *pNextPointer = NULL;
    ULONG ulLength = 0;
    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    switch ( wc )
    {
    //--- Periods normally are pronounced as "dot", rather than "period".
    case L'.':
        Word.pWordText  = g_periodString.pStr;
        Word.ulWordLen  = g_periodString.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        break;

    default:
        //--- Some characters have multi-word names 
        pNextPointer = g_ANSICharacterProns[wc].pStr;
        do {
            pPrevPointer = pNextPointer;
            pNextPointer = wcschr(pPrevPointer, L' ');
            if (pNextPointer)
            {
                ulLength = (ULONG)(pNextPointer - pPrevPointer);
                pNextPointer++;
            }
            else
            {
                ulLength = wcslen(pPrevPointer);
            }
            Word.pXmlState          = &m_pCurrFrag->State;
            Word.pWordText          = pPrevPointer;
            Word.ulWordLen          = ulLength;
            Word.pLemma             = pPrevPointer;
            Word.ulLemmaLen         = ulLength;
            Word.eWordPartOfSpeech  = MS_Unknown;
            WordList.AddTail( Word );

        } while ( pNextPointer );

        break;
    }

} /* ExpandPunctuation */

/*****************************************************************************
* ExpandUnrecognizedString *
*--------------------------*
*       This function is where text ends up if it needs to be normalized, 
*   and wasn't recognized as anything (e.g. a number or a date).  Contiguous 
*   alpha characters are grouped together for lookup, contiguous digits are
*   expanded as numbers, and all other characters are expanded by name (e.g.
*   '(' -> "left parenthesis").
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::ExpandUnrecognizedString( CWordList& WordList, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandUnrecognizedString" );
    HRESULT hr = S_OK;

    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );

    const WCHAR *pCurr = m_pNextChar, *pPrev, *pEnd = m_pEndOfCurrItem;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const WCHAR *pPrevPointer = NULL, *pNextPointer = NULL;
    WCHAR Temp = 0;
    ULONG ulTempCount = 0;
    ULONG ulLength;
    bool bDone = false;

    //--- RAID 9143, 1/05/2001
    if ( _wcsnicmp( pCurr, L"AT&T", pEnd - pCurr ) == 0 )
    {
        //--- "A"
        Word.pXmlState         = &m_pCurrFrag->State;
        Word.pWordText         = pCurr;
        Word.ulWordLen         = 1;
        Word.pLemma            = Word.pWordText;
        Word.ulLemmaLen        = Word.ulWordLen;
        Word.eWordPartOfSpeech = MS_Unknown;
        WordList.AddTail( Word );

        //--- "T"
        Word.pWordText         = pCurr + 1;
        Word.pLemma            = Word.pWordText;
        WordList.AddTail( Word );

        //--- "And"
        Word.pWordText         = g_And.pStr;
        Word.ulWordLen         = g_And.Len;
        Word.pLemma            = Word.pWordText;
        Word.ulLemmaLen        = Word.ulWordLen;
        WordList.AddTail( Word );

        //--- "T"
        Word.pWordText         = pCurr + 3;
        Word.ulWordLen         = 1;
        Word.pLemma            = Word.pWordText;
        Word.ulLemmaLen        = Word.ulWordLen;
        WordList.AddTail( Word );
    }
    else
    {
        while (pCurr < pEnd && SUCCEEDED(hr) && !bDone)
        {
            pPrev = pCurr;

            //--- Special Case: alpha characters 
            if (iswalpha(*pCurr))
            {
                ulTempCount = 0;
                do {
                    pCurr++;
                } while (pCurr < pEnd && iswalpha(*pCurr));

                Word.pXmlState          = &m_pCurrFrag->State;
                Word.pWordText          = pPrev;
                Word.ulWordLen          = (ULONG)(pCurr - pPrev);
                Word.pLemma             = Word.pWordText;
                Word.ulLemmaLen         = Word.ulWordLen;
                Word.eWordPartOfSpeech  = MS_Unknown;
                WordList.AddTail( Word );
            }
            //--- Special Case: digits 
            else if (isdigit(*pCurr))
            {
                ulTempCount = 0;
                do {
                    pCurr++;
                } while (pCurr < pEnd && isdigit(*pCurr));

                TTSItemInfo* pGarbage;
                m_pNextChar      = pPrev;
                m_pEndOfCurrItem = pCurr;

                hr = IsNumber( pGarbage, L"NUMBER", MemoryManager, false );
                if ( SUCCEEDED( hr ) )
                {
                    hr = ExpandNumber( (TTSNumberItemInfo*) pGarbage, WordList );
                }

                m_pNextChar      = pTempNextChar;
                m_pEndOfCurrItem = pTempEndOfItem;
            }
            //--- Default Case 
            else if (0 <= *pCurr && *pCurr <= sp_countof(g_ANSICharacterProns) &&
                        g_ANSICharacterProns[*pCurr].Len != 0)
            {
                if ( ulTempCount == 0 )
                {
                    Temp = *pCurr;
                    ulTempCount++;
                }
                else if ( Temp == *pCurr )
                {
                    ulTempCount++;
                }
                else
                {
                    Temp = *pCurr;
                    ulTempCount = 1;
                }
             
                if ( ulTempCount < 4 )
                {
                    //--- Some characters have multi-word names 
                    pNextPointer = g_ANSICharacterProns[*pCurr].pStr;
                    do {
                        pPrevPointer = pNextPointer;
                        pNextPointer = wcschr(pPrevPointer, L' ');
                        if (pNextPointer)
                        {
                            ulLength = (ULONG )(pNextPointer - pPrevPointer);
                            pNextPointer++;
                        }
                        else
                        {
                            ulLength = wcslen(pPrevPointer);
                        }
                        Word.pXmlState          = &m_pCurrFrag->State;
                        Word.pWordText          = pPrevPointer;
                        Word.ulWordLen          = ulLength;
                        Word.pLemma             = pPrevPointer;
                        Word.ulLemmaLen         = ulLength;
                        Word.eWordPartOfSpeech  = MS_Unknown;
                        WordList.AddTail( Word );

                    } while (SUCCEEDED(hr) && pNextPointer);
                }

                pCurr++;
            }
            else // Character is not expandable
            {
                pCurr++;
            }
        }
    }

    return hr;
} /* ExpandUnrecognizedString */

/*****************************************************************************
* SpellOutString *
*----------------*
*       This function expands strings surrounded by the <SPElL> XML tag.  
*   It uses the same table to look up character expansions as 
*   ExpandUnrecognizedString, but ALL characters are expanded by name.
********************************************************************* AH ****/
HRESULT CStdSentEnum::SpellOutString( CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::SpellOutString" );
    HRESULT hr = S_OK;

    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );

    const WCHAR *pCurr = m_pNextChar, *pPrev, *pEnd = m_pEndOfCurrItem;
    const WCHAR *pPrevPointer = NULL, *pNextPointer = NULL;
    ULONG ulLength;
    bool bDone = false;

    while (pCurr < pEnd && SUCCEEDED(hr) && !bDone)
    {
        pPrev = pCurr;

        if ( 0 <= *pCurr                                && 
             *pCurr <= sp_countof(g_ANSICharacterProns) &&
             g_ANSICharacterProns[*pCurr].Len != 0 )
        {

            //--- Some characters have multi-word names 
            pNextPointer = g_ANSICharacterProns[*pCurr].pStr;
            do {
                pPrevPointer = pNextPointer;
                pNextPointer = wcschr(pPrevPointer, L' ');
                if (pNextPointer)
                {
                    ulLength = (ULONG)(pNextPointer - pPrevPointer);
                    pNextPointer++;
                }
                else
                {
                    ulLength = wcslen(pPrevPointer);
                }
                Word.pXmlState          = &m_pCurrFrag->State;
                Word.pWordText          = pPrevPointer;
                Word.ulWordLen          = ulLength;
                Word.pLemma             = pPrevPointer;
                Word.ulLemmaLen         = ulLength;
                Word.eWordPartOfSpeech  = MS_Unknown;
                WordList.AddTail( Word );

            } while (SUCCEEDED(hr) && pNextPointer);

            pCurr++;
        }
        else // Character is not expandable
        {
            pCurr++;
        }
    }

    return hr;
} /* SpellOutString */

//-----------End Of File-------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\mainnorm.cpp ===
/*******************************************************************************
* MainNorm.cpp *
*--------------*
*	Description:
*		
*-------------------------------------------------------------------------------
*  Created By: AH										  Date: 01/18/2000
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

/*****************************************************************************
* CStdSentEnum::Normalize *
*-------------------------*
*  
********************************************************************** AH ***/
HRESULT CStdSentEnum::Normalize( CItemList& ItemList, SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::Normalize" );
    HRESULT hr = S_OK;
    TTSItemInfo* pItemNormInfo = NULL;
    CWordList WordList;
    const SPVTEXTFRAG* pTempFrag = m_pCurrFrag;
    TTSSentItem& TempItem = ItemList.GetAt( ListPos );
    if ( TempItem.pItemInfo )
    {
        pItemNormInfo = TempItem.pItemInfo;
    }

    //--- Match the normalization category of the current token.
    if ( m_pCurrFrag->State.eAction == SPVA_Speak )
    {
        if ( !pItemNormInfo                         || 
             ( pItemNormInfo->Type != eABBREVIATION &&
               pItemNormInfo->Type != eINITIALISM ) )
        {
            hr = MatchCategory( pItemNormInfo, MemoryManager, WordList );
        }
    }
    //--- Action must be SPVA_SpellOut - assign eSPELLOUT as category
    else
    {
        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eSPELLOUT;
        }
    }

    if (SUCCEEDED(hr))
    {
        switch ( pItemNormInfo->Type )
        {

        //--- Alpha Word - just insert into the Item List.
        case eALPHA_WORD:
            {
                CSentItem Item;
                Item.pItemSrcText       = m_pNextChar;
                Item.ulItemSrcLen       = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                Item.ulItemSrcOffset    = pTempFrag->ulTextSrcOffset +
                                          (ULONG)( m_pNextChar - pTempFrag->pTextStart );
                Item.ulNumWords         = 1;
                Item.Words              = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( Item.Words, sizeof(TTSWord) );
                    Item.Words[0].pXmlState         = &pTempFrag->State;
                    Item.Words[0].pWordText         = m_pNextChar;
                    Item.Words[0].ulWordLen         = Item.ulItemSrcLen;
                    Item.Words[0].pLemma            = Item.Words[0].pWordText;
                    Item.Words[0].ulLemmaLen        = Item.Words[0].ulWordLen;
                    Item.Words[0].eWordPartOfSpeech = MS_Unknown;
                    Item.eItemPartOfSpeech          = MS_Unknown;
                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo*), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo->Type = eALPHA_WORD;
                        ItemList.SetAt( ListPos, Item );
                    }
                }
            }
            break;

        case eABBREVIATION:
        case eABBREVIATION_NORMALIZE:
        case eINITIALISM:
            break;

        //--- Multi-token categories have already been expanded into WordList, now just accumulate
        //---   words, and insert back into the Item List.
        case eNEWNUM_PHONENUMBER:
            //--- Special case - remove parentheses (of area code), if present in the item list
            {
                SPLISTPOS TempPos = ListPos;
                CSentItem Item = ItemList.GetPrev( TempPos );
                if ( TempPos )
                {
                    SPLISTPOS RemovePos = TempPos;
                    Item = ItemList.GetPrev( TempPos );
                    if ( Item.pItemInfo->Type == eOPEN_PARENTHESIS &&
                         ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode )
                    {
                        ItemList.RemoveAt( RemovePos );
                        m_pNextChar--;
                    }
                }
            }
        case eNUM_CURRENCY:
        case eNUM_CURRENCYRANGE:
        case eTIMEOFDAY:
        case eDATE_LONGFORM:
        case eSTATE_AND_ZIPCODE:
        case eTIME_RANGE:
            {
                //--- Set Item data, and add to ItemList.
                if ( SUCCEEDED( hr ) )
                {
                    CSentItem Item;
                    Item.pItemSrcText       = m_pNextChar;
                    Item.ulItemSrcLen       = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                    Item.ulItemSrcOffset    = pTempFrag->ulTextSrcOffset +
                                              (ULONG)( m_pNextChar - pTempFrag->pTextStart );
                    hr = SetWordList( Item, WordList, MemoryManager );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo = pItemNormInfo;
                        ItemList.SetAt( ListPos, Item );
                    }
                }
            }
            break;

        //--- Expand the single token, according to its normalization category.
        default:
            hr = ExpandCategory( pItemNormInfo, ItemList, ListPos, MemoryManager );
            break;
        }
    }

    return hr;
} /* Normalize */

/*****************************************************************************
* CStdSentEnum::MatchCategory *
*-----------------------------*
*  
********************************************************************** AH ***/
HRESULT CStdSentEnum::MatchCategory( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager,
                                     CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::MatchCategory" );
    SPDBG_ASSERT( m_pNextChar );

    HRESULT hr = E_INVALIDARG;

    //--- Context has been specified
    if ( m_pCurrFrag->State.Context.pCategory )
    {
        if ( wcsicmp( m_pCurrFrag->State.Context.pCategory, L"ADDRESS" ) == 0 )
        {
            hr = IsZipCode( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
        }
        else if ( wcsnicmp( m_pCurrFrag->State.Context.pCategory, L"DATE", 4 ) == 0 )
        {
            hr = IsNumericCompactDate( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            if ( hr == E_INVALIDARG )
            {
                hr = IsMonthStringCompactDate( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            }
        }
        else if ( wcsnicmp( m_pCurrFrag->State.Context.pCategory, L"TIME", 4 ) == 0 )
        {
            hr = IsTime( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
        }
        else if ( wcsnicmp( m_pCurrFrag->State.Context.pCategory, L"NUM", 3 ) == 0 )
        {
            hr = IsNumberCategory( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            if ( hr == E_INVALIDARG )
            {
                hr = IsRomanNumeral( pItemNormInfo, m_pCurrFrag->State.Context.pCategory, MemoryManager );
            }
        }
        else if ( wcsicmp( m_pCurrFrag->State.Context.pCategory, L"PHONE_NUMBER" ) == 0 )
        {
            hr = IsPhoneNumber( pItemNormInfo, L"PHONE_NUMBER", MemoryManager, WordList );
        }
    }
    //--- Default Context
    if ( hr == E_INVALIDARG )
    {
        //--- Do ALPHA Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsAlphaWord( m_pNextChar, m_pEndOfCurrItem, pItemNormInfo, MemoryManager );
            //--- Check ALPHA Exceptions
            if ( SUCCEEDED( hr ) )
            {
				hr = E_INVALIDARG;
                if ( hr == E_INVALIDARG )
                {
                    hr = IsLongFormDate_DMDY( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = IsLongFormDate_DDMY( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = IsStateAndZipcode( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = IsCurrency( pItemNormInfo, MemoryManager, WordList );
                }
                if ( hr == E_INVALIDARG )
                {
                    hr = S_OK;
                }
            }
        }
        //--- Do Multi-Token Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsLongFormDate_DMDY( pItemNormInfo, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsLongFormDate_DDMY( pItemNormInfo, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsCurrency( pItemNormInfo, MemoryManager, WordList );
        }
        //--- Do TIME Normalization check
        if ( hr == E_INVALIDARG )
        {
            hr = IsTimeRange( pItemNormInfo, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsTimeOfDay( pItemNormInfo, MemoryManager, WordList );
        }
        //--- Do NUMBER Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsPhoneNumber( pItemNormInfo, NULL, MemoryManager, WordList );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsNumberCategory( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsNumberRange( pItemNormInfo, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsCurrencyRange( pItemNormInfo, MemoryManager, WordList );
        }
        //--- Do DATE Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsNumericCompactDate( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsMonthStringCompactDate( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsDecade( pItemNormInfo, MemoryManager );
        }
        //--- Do TIME Normalization checks
        if ( hr == E_INVALIDARG )
        {
            hr = IsTime( pItemNormInfo, NULL, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsHyphenatedString( m_pNextChar, m_pEndOfCurrItem, pItemNormInfo, MemoryManager );
        }
        if ( hr == E_INVALIDARG )
        {
            hr = IsSuffix( m_pNextChar, m_pEndOfCurrItem, pItemNormInfo, MemoryManager );
        }
    }

    if ( hr == E_INVALIDARG &&
         !pItemNormInfo )
    {
        hr = S_OK;
        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eUNMATCHED;
        }
    }
    else if ( hr == E_INVALIDARG &&
              pItemNormInfo )
    {
        hr = S_OK;
    }

    return hr;
} /* MatchCategory */

/*****************************************************************************
* CStdSentEnum::ExpandCategory *
*------------------------------*
*  Expands previously matched items in the Item List into their normalized
* forms.
********************************************************************** AH ***/
HRESULT CStdSentEnum::ExpandCategory( TTSItemInfo*& pItemNormInfo, CItemList& ItemList, SPLISTPOS ListPos, 
                                      CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandCategory" );

    HRESULT hr = S_OK;
    CSentItem Item;
    CWordList WordList;
    
    Item.pItemSrcText = m_pNextChar;
    Item.ulItemSrcLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    Item.ulItemSrcOffset = m_pCurrFrag->ulTextSrcOffset +
                           (ULONG)( m_pNextChar - m_pCurrFrag->pTextStart );
    
    switch ( pItemNormInfo->Type )
    {

    case eNUM_ROMAN_NUMERAL:
        switch ( ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo->Type )
        {
        case eDATE_YEAR:
            hr = ExpandYear( (TTSYearItemInfo*) ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo, 
                             WordList );
            break;
        default:
            hr = ExpandNumber( (TTSNumberItemInfo*) ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo, 
                               WordList );
            break;
        }
        break;

    case eNUM_CARDINAL:
    case eNUM_ORDINAL:
    case eNUM_DECIMAL:
    case eNUM_FRACTION:
    case eNUM_MIXEDFRACTION:
        hr = ExpandNumber( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_PERCENT:
        hr = ExpandPercent( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_DEGREES:
        hr = ExpandDegrees( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_SQUARED:
        hr = ExpandSquare( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_CUBED:
        hr = ExpandCube( (TTSNumberItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_ZIPCODE:
        hr = ExpandZipCode( (TTSZipCodeItemInfo*) pItemNormInfo, WordList );
        break;

    case eNUM_RANGE:
        hr = ExpandNumberRange( (TTSNumberRangeItemInfo*) pItemNormInfo, WordList );
        break;

    case eDATE:
        hr = ExpandDate( (TTSDateItemInfo*) pItemNormInfo, WordList );
        break;

    case eDATE_YEAR:
        hr = ExpandYear( (TTSYearItemInfo*) pItemNormInfo, WordList );
        break;

    case eDECADE:
        hr = ExpandDecade( (TTSDecadeItemInfo*) pItemNormInfo, WordList );
        break;

    case eTIME:
        hr = ExpandTime( (TTSTimeItemInfo*) pItemNormInfo, WordList );
        break;

    case eHYPHENATED_STRING:
        hr = ExpandHyphenatedString( (TTSHyphenatedStringInfo*) pItemNormInfo, WordList );
        break;

    case eSUFFIX:
        hr = ExpandSuffix( (TTSSuffixItemInfo*) pItemNormInfo, WordList );
        break;

    case eSPELLOUT:
        hr = SpellOutString( WordList );
        break;

    case eUNMATCHED:
    default:
        hr = ExpandUnrecognizedString( WordList, MemoryManager );
        break;

    }

    //--- Set Item data, and add to ItemList.
    if ( SUCCEEDED( hr ) )
    {
        hr = SetWordList( Item, WordList, MemoryManager );
        if ( SUCCEEDED( hr ) )
        {
            Item.pItemInfo = pItemNormInfo;
            ItemList.SetAt( ListPos, Item );
        }
    }

    return hr;
} /* ExpandCategory */

/*****************************************************************************
* CStdSentEnum::DoUnicodeToAsciiMap *
*-----------------------------------*
*   Description:
*       Maps incoming strings to known values.
********************************************************************* AH ****/
HRESULT CStdSentEnum::DoUnicodeToAsciiMap( const WCHAR *pUnicodeString, ULONG ulUnicodeStringLength,
                                           WCHAR *pConvertedString )
{
    SPDBG_FUNC( "CSpVoice::DoUnicodeToAsciiMap" );
    HRESULT hr = S_OK;
    unsigned char *pBuffer = NULL;
    WCHAR *pWideCharBuffer = NULL;

    if ( pUnicodeString )
    {
        //--- Make copy of pUnicodeString 
        pWideCharBuffer = new WCHAR[ulUnicodeStringLength+1];
        if ( !pWideCharBuffer )
        {
            hr = E_OUTOFMEMORY;
        }
        if ( SUCCEEDED( hr ) )
        {
            wcsncpy( pWideCharBuffer, pUnicodeString, ulUnicodeStringLength );
            pWideCharBuffer[ulUnicodeStringLength] = 0;

            pBuffer = new unsigned char[ulUnicodeStringLength+1];
            if ( !pBuffer || !pWideCharBuffer )
            {
                hr = E_OUTOFMEMORY;
            }
            if ( SUCCEEDED(hr) )
            {
                pBuffer[ulUnicodeStringLength] = 0;
                if ( ulUnicodeStringLength > 0 ) 
                {
                    //--- Map WCHARs to ANSI chars 
                    if ( !WideCharToMultiByte( 1252, NULL, pWideCharBuffer, ulUnicodeStringLength, (char*) pBuffer, 
                                               ulUnicodeStringLength, &g_pFlagCharacter, NULL ) )
                    {
                        hr = E_UNEXPECTED;
                    }
                    //--- Use internal table to map ANSI to ASCII 
                    for (ULONG i = 0; i < ulUnicodeStringLength && SUCCEEDED(hr); i++)
                    {
                        pBuffer[i] = g_AnsiToAscii[pBuffer[i]];
                    }
                    //--- Map back to WCHARs 
                    for ( i = 0; i < ulUnicodeStringLength && SUCCEEDED(hr); i++ )
                    {
                        pConvertedString[i] = pBuffer[i];
                    }
                }
            }
        }
    }
    else
    {
        pConvertedString = NULL;
    }
    
    if (pBuffer)
    {
        delete [] pBuffer;
    }
    if (pWideCharBuffer)
    {
        delete [] pWideCharBuffer;
    }

    return hr;
} /* CStdSentEnum::DoUnicodeToAsciiMap */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\normdata.cpp ===
/******************************************************************************
* NormData.cpp *
*--------------*
*  This file stores the const data used in normalization
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 05/02/2000
*  All Rights Reserved
*
****************************************************************** AARONHAL ***/

#include "stdafx.h"
#include "stdsentenum.h"

//--- Constants used to map incoming ANSI characters to Ascii ones...
const char g_pFlagCharacter = 0x00;
const unsigned char g_AnsiToAscii[] = 
{
    /*** Control characters - map to whitespace ***/
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20,
    /*** ASCII displayables ***/
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,
    /*** Control character ***/
    0x20,
    /*** Euro symbol ***/
    0x80,
    /*** Control character ***/
    0x20,
    /*** Extended ASCII values ***/
    0x27,     // low single quote - map to single quote
    0x20,     // f-like character - map to space
    0x22,     // low double quote - map to double quote
    0x2C,     // elipsis - map to comma
    0x20,     // cross - map to space
    0x20,     // double cross - map to space
    0x5E,     // caret like accent - map to caret
    0x89,     // strange percent like sign
    0x53,     // S-hat - map to S
    0x27,     // left angle bracket like thing - map to single quote
    0x20,     // weird OE character - map to space
    0x20,     // control characters - map to space
    0x20,
    0x20,
    0x20,
    0x27,     // left single quote - map to single quote
    0x27,     // right single quote - map to single quote
    0x22,     // left double quote - map to double quote
    0x22,     // right double quote - map to double quote
    0x20,     // bullet - map to space
    0x2D,     // long hyphen - map to hyphen
    0x2D,     // even longer hyphen - map to hyphen
    0x7E,     // tilde-like thing - map to tilde
    0x99,     // TM
    0x73,     // s-hat - map to s
    0x27,     // right angle bracket like thing - map to single quote
    0x20,     // weird oe like character - map to space
    0x20,     // control character - map to space
    0x20,     // control character - map to space
    0x59,     // Y with umlaut like accent - map to Y
    0x20,     // space? - map to space
    0x20,     // upside-down exclamation point - map to space
    0xA2,     // cents symbol
    0xA3,     // pounds symbol
    0x20,     // generic currency symbol - map to space
    0xA5,     // yen symbol
    0x7C,     // broken bar - map to bar
    0x20,     // strange symbol - map to space 
    0x20,     // umlaut - map to space
    0xA9,     // copyright symbol
    0x20,     // strange a character - map to space
    0x22,     // strange <<-like character - map to double quote
    0x20,     // strange line-like character - map to space
    0x2D,     // hyphen-like character - map to hyphen
    0xAE,     // registered symbol
    0x20,     // high line - map to space
    0xB0,     // degree sign
    0xB1,     // plus-minus sign
    0xB2,     // superscript 2
    0xB3,     // superscript 3
    0xB4,     // single prime
    0x20,     // greek character - map to space
    0x20,     // paragraph symbol - map to space
    0x20,     // mid-height dot - map to space
    0x20,     // cedilla - map to space
    0xB9,     // superscript one
    0x20,     // circle with line - map to space
    0x22,     // strange >>-like character - map to double quote
    0xBC,     // vulgar 1/4
    0xBD,     // vulgar 1/2
    0xBE,     // vulgar 3/4
    0x20,     // upside-down question mark - map to space
    0x41,     // Accented uppercase As - map to A
    0x41,
    0x41,
    0x41,
    0x41,
    0x41,
    0x41,
    0x43,     // C with cedilla - map to C
    0x45,     // Accented uppercase Es - map to E
    0x45,
    0x45,
    0x45,
    0x49,     // Accented uppercase Is - map to I
    0x49,
    0x49,
    0x49,
    0x20,     // strange character - map to space
    0x4E,     // Accented uppercase N - map to N
    0x4F,     // Accented uppercase Os - map to O
    0x4F,
    0x4F,
    0x4F,
    0x4F,
    0x20,     // strange character - map to space
    0x4F,     // another O? - map to O
    0x55,     // Accented uppercase Us - map to U
    0x55,
    0x55,
    0x55,
    0x59,     // Accented uppercase Y - map to Y
    0x20,     // strange character - map to space
    0xDF,     // Beta
    0x61,     // Accented lowercase as - map to a
    0x61,
    0x61,
    0x61,
    0x61,
    0x61,
    0x61,
    0x63,     // c with cedilla - map to c
    0x65,     // Accented lowercase es - map to e
    0x65,
    0x65,
    0x65,
    0x69,    // Accented lowercase is - map to i
    0x69,
    0x69,
    0x69,
    0x75,    // eth - map to t
    0x6E,    // Accented lowercase n - map to n
    0x6F,    // Accented lowercase os - map to o
    0x6F,
    0x6F,
    0x6F,
    0x6F,
    0xF7,     // division symbol
    0x6F,     // another o? - map to o
    0x76,    // Accented lowercase us - map to u
    0x76,
    0x76,
    0x76,
    0x79,     // accented lowercase y - map to y
    0x20,     // strange character - map to space
    0x79,     // accented lowercase y - map to y
};

//--- Constants used by number normalization
const SPLSTR g_O            = DEF_SPLSTR( "o" );
const SPLSTR g_negative     = DEF_SPLSTR( "negative" );
const SPLSTR g_decimalpoint = DEF_SPLSTR( "point" );
const SPLSTR g_a            = DEF_SPLSTR( "a" );
const SPLSTR g_of           = DEF_SPLSTR( "of" );
const SPLSTR g_percent      = DEF_SPLSTR( "percent" );
const SPLSTR g_degree       = DEF_SPLSTR( "degree" );
const SPLSTR g_degrees      = DEF_SPLSTR( "degrees" );
const SPLSTR g_squared      = DEF_SPLSTR( "squared" );
const SPLSTR g_cubed        = DEF_SPLSTR( "cubed" );
const SPLSTR g_to           = DEF_SPLSTR( "to" );
const SPLSTR g_dash         = DEF_SPLSTR( "dash" );

const SPLSTR g_ones[] = 
{   
    DEF_SPLSTR( "zero"  ), 
    DEF_SPLSTR( "one"   ),
    DEF_SPLSTR( "two"   ), 
    DEF_SPLSTR( "three" ), 
    DEF_SPLSTR( "four"  ), 
    DEF_SPLSTR( "five"  ), 
    DEF_SPLSTR( "six"   ), 
    DEF_SPLSTR( "seven" ), 
    DEF_SPLSTR( "eight" ), 
    DEF_SPLSTR( "nine"  )
};

const SPLSTR g_tens[]  = 
{
    DEF_SPLSTR( "zero"    ),
    DEF_SPLSTR( "ten"     ), 
    DEF_SPLSTR( "twenty"  ), 
    DEF_SPLSTR( "thirty"  ), 
    DEF_SPLSTR( "forty"   ), 
    DEF_SPLSTR( "fifty"   ), 
    DEF_SPLSTR( "sixty"   ), 
    DEF_SPLSTR( "seventy" ), 
    DEF_SPLSTR( "eighty"  ), 
    DEF_SPLSTR( "ninety"  )
};

const SPLSTR g_teens[]  = 
{
    DEF_SPLSTR( "ten"       ), 
    DEF_SPLSTR( "eleven"    ), 
    DEF_SPLSTR( "twelve"    ), 
    DEF_SPLSTR( "thirteen"  ), 
    DEF_SPLSTR( "fourteen"  ), 
    DEF_SPLSTR( "fifteen"   ), 
    DEF_SPLSTR( "sixteen"   ), 
    DEF_SPLSTR( "seventeen" ), 
    DEF_SPLSTR( "eighteen"  ), 
    DEF_SPLSTR( "nineteen"  )
};

const SPLSTR g_onesOrdinal[]  = 
{
    DEF_SPLSTR( "zeroth"  ), 
    DEF_SPLSTR( "first"   ), 
    DEF_SPLSTR( "second"  ), 
    DEF_SPLSTR( "third"   ), 
    DEF_SPLSTR( "fourth"  ), 
    DEF_SPLSTR( "fifth"   ), 
    DEF_SPLSTR( "sixth"   ), 
    DEF_SPLSTR( "seventh" ), 
    DEF_SPLSTR( "eighth"  ), 
    DEF_SPLSTR( "ninth"   )
}; 

const SPLSTR g_tensOrdinal[]  = 
{
    DEF_SPLSTR( ""           ), 
    DEF_SPLSTR( "tenth"      ), 
    DEF_SPLSTR( "twentieth"  ), 
    DEF_SPLSTR( "thirtieth"  ), 
    DEF_SPLSTR( "fortieth"   ), 
    DEF_SPLSTR( "fiftieth"   ), 
    DEF_SPLSTR( "sixtieth"   ), 
    DEF_SPLSTR( "seventieth" ), 
    DEF_SPLSTR( "eightieth"  ), 
    DEF_SPLSTR( "ninetieth"  )
}; 

const SPLSTR g_teensOrdinal[]  =
{
    DEF_SPLSTR( "tenth"       ), 
    DEF_SPLSTR( "eleventh"    ), 
    DEF_SPLSTR( "twelfth"     ), 
    DEF_SPLSTR( "thirteenth"  ), 
    DEF_SPLSTR( "fourteenth"  ), 
    DEF_SPLSTR( "fifteenth"   ), 
    DEF_SPLSTR( "sixteenth"   ), 
    DEF_SPLSTR( "seventeenth" ),
    DEF_SPLSTR( "eighteenth"  ), 
    DEF_SPLSTR( "nineteenth"  )
};

const SPLSTR g_quantifiers[]  =
{
    DEF_SPLSTR( "hundred"  ), 
    DEF_SPLSTR( "thousand" ), 
    DEF_SPLSTR( "million"  ), 
    DEF_SPLSTR( "billion"  ), 
    DEF_SPLSTR( "trillion" ),
    DEF_SPLSTR( "quadrillion" )
};

const SPLSTR g_quantifiersOrdinal[]  =
{
    DEF_SPLSTR( "hundredth"  ), 
    DEF_SPLSTR( "thousandth" ), 
    DEF_SPLSTR( "millionth"  ), 
    DEF_SPLSTR( "billionth"  ), 
    DEF_SPLSTR( "trillionth" ),
    DEF_SPLSTR( "quadrillionth" )
};

//--- Constants used by currency normalization

WCHAR g_Euro[2] = { 0x0080, 0x0000 };

const CurrencySign g_CurrencySigns[] =
{
    { DEF_SPLSTR( "$" ),        DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "pounds" ),         DEF_SPLSTR( "pence" )       },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "yen" ),            DEF_SPLSTR( "sen" )         },
    { DEF_SPLSTR( "EUR" ),      DEF_SPLSTR( "euros" ),          DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "US$" ),      DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { { &g_Euro[0], 1 },        DEF_SPLSTR( "euros" ),          DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "euros" ),          DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "DM" ),       DEF_SPLSTR( "deutschemarks" ),  DEF_SPLSTR( "pfennigs" )    },
    { DEF_SPLSTR( "" ),        DEF_SPLSTR( "cents" ),          DEF_SPLSTR( "" )            },
    { DEF_SPLSTR( "USD" ),      DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "dol." ),     DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "schil." ),   DEF_SPLSTR( "schillings" ),     DEF_SPLSTR( "" )            },
    { DEF_SPLSTR( "dol" ),      DEF_SPLSTR( "dollars" ),        DEF_SPLSTR( "cents" )       },
    { DEF_SPLSTR( "schil" ),    DEF_SPLSTR( "schillings" ),     DEF_SPLSTR( "" )            }
};

const SPLSTR g_SingularPrimaryCurrencySigns[] =
{   
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "pound" ),
    DEF_SPLSTR( "yen" ),
    DEF_SPLSTR( "euro" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "euro" ),
    DEF_SPLSTR( "euro" ),
    DEF_SPLSTR( "deutschemark" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "schilling" ),
    DEF_SPLSTR( "dollar" ),
    DEF_SPLSTR( "schilling" )
};

const SPLSTR g_SingularSecondaryCurrencySigns[] =
{
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "penny" ),
    DEF_SPLSTR( "sen" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "pfennig" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "cent" ),
    DEF_SPLSTR( "" ),
};

//--- Constants used by date normalization

const WCHAR g_DateDelimiters[] = { '/', '-', '.' };

const SPLSTR g_months[]  =
{
    DEF_SPLSTR( "January"   ), 
    DEF_SPLSTR( "February"  ), 
    DEF_SPLSTR( "March"     ), 
    DEF_SPLSTR( "April"     ), 
    DEF_SPLSTR( "May"       ),
    DEF_SPLSTR( "June"      ),
    DEF_SPLSTR( "July"      ),
    DEF_SPLSTR( "August"    ),
    DEF_SPLSTR( "September" ),
    DEF_SPLSTR( "October"   ),
    DEF_SPLSTR( "November"  ),
    DEF_SPLSTR( "December"  )
};

const SPLSTR g_monthAbbreviations[] =
{
    DEF_SPLSTR( "jan" ),
    DEF_SPLSTR( "feb" ),
    DEF_SPLSTR( "mar" ),
    DEF_SPLSTR( "apr" ),
    DEF_SPLSTR( "may" ),
    DEF_SPLSTR( "jun" ),
    DEF_SPLSTR( "jul" ),
    DEF_SPLSTR( "aug" ),
    DEF_SPLSTR( "sept" ),
    DEF_SPLSTR( "sep" ),
    DEF_SPLSTR( "oct" ),
    DEF_SPLSTR( "nov" ),
    DEF_SPLSTR( "dec" )
};

const SPLSTR g_days[]    =
{
    DEF_SPLSTR( "Monday"    ),
    DEF_SPLSTR( "Tuesday"   ),
    DEF_SPLSTR( "Wednesday" ),
    DEF_SPLSTR( "Thursday"  ),
    DEF_SPLSTR( "Friday"    ),
    DEF_SPLSTR( "Saturday"  ),
    DEF_SPLSTR( "Sunday"    )
};

const SPLSTR g_dayAbbreviations[] =
{
    DEF_SPLSTR( "Mon"   ),
    DEF_SPLSTR( "Tues"   ),
    DEF_SPLSTR( "Tue"  ),
    DEF_SPLSTR( "Wed"   ),
    DEF_SPLSTR( "Thurs"  ),
    DEF_SPLSTR( "Thur" ),
    DEF_SPLSTR( "Thu" ),
    DEF_SPLSTR( "Fri"   ),
    DEF_SPLSTR( "Sat"   ),
    DEF_SPLSTR( "Sun"   ),
};

//--- Constants used by phone number normalization

const SPLSTR g_Area     = DEF_SPLSTR( "area" );
const SPLSTR g_Country  = DEF_SPLSTR( "country" );
const SPLSTR g_Code     = DEF_SPLSTR( "code" );

//--- Constants used by fraction normalization

const SPLSTR g_Half         = DEF_SPLSTR( "half" );
const SPLSTR g_Tenths       = DEF_SPLSTR( "tenths" );
const SPLSTR g_Hundredths   = DEF_SPLSTR( "hundredths" );
const SPLSTR g_Sixteenths   = DEF_SPLSTR( "sixteenths" );
const SPLSTR g_Over         = DEF_SPLSTR( "over" );

const SPLSTR g_PluralDenominators[]  = 
{
    DEF_SPLSTR( "" ), 
    DEF_SPLSTR( "" ), 
    DEF_SPLSTR( "halves"   ), 
    DEF_SPLSTR( "thirds"   ), 
    DEF_SPLSTR( "fourths"  ), 
    DEF_SPLSTR( "fifths"   ), 
    DEF_SPLSTR( "sixths"   ), 
    DEF_SPLSTR( "sevenths" ), 
    DEF_SPLSTR( "eighths"  ), 
    DEF_SPLSTR( "ninths"   )
}; 

//--- Constants used by time normalization

const SPLSTR g_A        = DEF_SPLSTR( "a" );
const SPLSTR g_M        = DEF_SPLSTR( "m" );
const SPLSTR g_P        = DEF_SPLSTR( "p" );
const SPLSTR g_OClock   = DEF_SPLSTR( "o'clock" );
const SPLSTR g_hundred  = DEF_SPLSTR( "hundred" );
const SPLSTR g_hours    = DEF_SPLSTR( "hours" );
const SPLSTR g_hour     = DEF_SPLSTR( "hour" );
const SPLSTR g_minutes  = DEF_SPLSTR( "minutes" );
const SPLSTR g_minute   = DEF_SPLSTR( "minute" );
const SPLSTR g_seconds  = DEF_SPLSTR( "seconds" );
const SPLSTR g_second   = DEF_SPLSTR( "second" );

//--- Default normalization table

const SPLSTR g_ANSICharacterProns[] =
{
    DEF_SPLSTR( "" ),   // NULL
    DEF_SPLSTR( "" ),   // Start of heading
    DEF_SPLSTR( "" ),   // Start of text
    DEF_SPLSTR( "" ),   // Break/End of text
    DEF_SPLSTR( "" ),   // End of transmission
    DEF_SPLSTR( "" ),   // Enquiry
    DEF_SPLSTR( "" ),   // Positive acknowledgement
    DEF_SPLSTR( "" ),   // Bell
    DEF_SPLSTR( "" ),   // Backspace
    DEF_SPLSTR( "" ),   // Horizontal tab
    DEF_SPLSTR( "" ),   // Line feed
    DEF_SPLSTR( "" ),   // Vertical tab
    DEF_SPLSTR( "" ),   // Form feed
    DEF_SPLSTR( "" ),   // Carriage return
    DEF_SPLSTR( "" ),   // Shift out
    DEF_SPLSTR( "" ),   // Shift in/XON (resume output)
    DEF_SPLSTR( "" ),   // Data link escape
    DEF_SPLSTR( "" ),   // Device control character 1
    DEF_SPLSTR( "" ),   // Device control character 2
    DEF_SPLSTR( "" ),   // Device control character 3
    DEF_SPLSTR( "" ),   // Device control character 4
    DEF_SPLSTR( "" ),   // Negative acknowledgement
    DEF_SPLSTR( "" ),   // Synchronous idle
    DEF_SPLSTR( "" ),   // End of transmission block
    DEF_SPLSTR( "" ),   // Cancel
    DEF_SPLSTR( "" ),   // End of medium
    DEF_SPLSTR( "" ),   // substitute/end of file
    DEF_SPLSTR( "" ),   // Escape
    DEF_SPLSTR( "" ),   // File separator
    DEF_SPLSTR( "" ),   // Group separator
    DEF_SPLSTR( "" ),   // Record separator
    DEF_SPLSTR( "" ),   // Unit separator
    DEF_SPLSTR( "" ),   // Space
    DEF_SPLSTR( "exclamation point" ),   
    DEF_SPLSTR( "double quote" ),
    DEF_SPLSTR( "number sign" ),
    DEF_SPLSTR( "dollars" ),
    DEF_SPLSTR( "percent" ),
    DEF_SPLSTR( "and" ),
    DEF_SPLSTR( "single quote" ),
    DEF_SPLSTR( "left parenthesis" ),
    DEF_SPLSTR( "right parenthesis" ),
    DEF_SPLSTR( "asterisk" ),
    DEF_SPLSTR( "plus" ),
    DEF_SPLSTR( "comma" ),
    DEF_SPLSTR( "hyphen" ),             
    DEF_SPLSTR( "dot" ),          
    DEF_SPLSTR( "slash" ),              
    DEF_SPLSTR( "zero" ),
    DEF_SPLSTR( "one" ),
    DEF_SPLSTR( "two" ),
    DEF_SPLSTR( "three" ),
    DEF_SPLSTR( "four" ),
    DEF_SPLSTR( "five" ),
    DEF_SPLSTR( "six" ),
    DEF_SPLSTR( "seven" ),
    DEF_SPLSTR( "eight" ),
    DEF_SPLSTR( "nine" ),
    DEF_SPLSTR( "colon" ),
    DEF_SPLSTR( "semicolon" ),
    DEF_SPLSTR( "less than" ),
    DEF_SPLSTR( "equals" ),
    DEF_SPLSTR( "greater than" ),
    DEF_SPLSTR( "question mark" ),
    DEF_SPLSTR( "at" ),
    DEF_SPLSTR( "a" ),
    DEF_SPLSTR( "b" ),
    DEF_SPLSTR( "c" ),
    DEF_SPLSTR( "d" ),
    DEF_SPLSTR( "e" ),
    DEF_SPLSTR( "f" ),
    DEF_SPLSTR( "g" ),
    DEF_SPLSTR( "h" ),
    DEF_SPLSTR( "i" ),
    DEF_SPLSTR( "j" ),
    DEF_SPLSTR( "k" ),
    DEF_SPLSTR( "l" ),
    DEF_SPLSTR( "m" ),
    DEF_SPLSTR( "n" ),
    DEF_SPLSTR( "o" ),
    DEF_SPLSTR( "p" ),
    DEF_SPLSTR( "q" ),
    DEF_SPLSTR( "r" ),
    DEF_SPLSTR( "s" ),
    DEF_SPLSTR( "t" ),
    DEF_SPLSTR( "u" ),
    DEF_SPLSTR( "v" ),
    DEF_SPLSTR( "w" ),
    DEF_SPLSTR( "x" ),
    DEF_SPLSTR( "y" ),
    DEF_SPLSTR( "z" ),
    DEF_SPLSTR( "left square bracket" ),
    DEF_SPLSTR( "backslash" ),
    DEF_SPLSTR( "right square bracket" ),
    DEF_SPLSTR( "circumflex accent" ),
    DEF_SPLSTR( "underscore" ),
    DEF_SPLSTR( "grave accent" ),
    DEF_SPLSTR( "a" ),
    DEF_SPLSTR( "b" ),
    DEF_SPLSTR( "c" ),
    DEF_SPLSTR( "d" ),
    DEF_SPLSTR( "e" ),
    DEF_SPLSTR( "f" ),
    DEF_SPLSTR( "g" ),
    DEF_SPLSTR( "h" ),
    DEF_SPLSTR( "i" ),
    DEF_SPLSTR( "j" ),
    DEF_SPLSTR( "k" ),
    DEF_SPLSTR( "l" ),
    DEF_SPLSTR( "m" ),
    DEF_SPLSTR( "n" ),
    DEF_SPLSTR( "o" ),
    DEF_SPLSTR( "p" ),
    DEF_SPLSTR( "q" ),
    DEF_SPLSTR( "r" ),
    DEF_SPLSTR( "s" ),
    DEF_SPLSTR( "t" ),
    DEF_SPLSTR( "u" ),
    DEF_SPLSTR( "v" ),
    DEF_SPLSTR( "w" ),
    DEF_SPLSTR( "x" ),
    DEF_SPLSTR( "y" ),
    DEF_SPLSTR( "z" ),
    DEF_SPLSTR( "left curly bracket" ),
    DEF_SPLSTR( "vertical line" ),
    DEF_SPLSTR( "right curly bracket" ),
    DEF_SPLSTR( "tilde" ),
    DEF_SPLSTR( "" ),                       // DELETE
    DEF_SPLSTR( "euros" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to comma
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to caret
    DEF_SPLSTR( "per thousand" ),
    DEF_SPLSTR( "" ),                       // maps to S
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // Control characters - map to space
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "" ),
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to hyphen
    DEF_SPLSTR( "" ),                       // maps to hyphen
    DEF_SPLSTR( "" ),                       // maps to tilde
    DEF_SPLSTR( "trademark" ),
    DEF_SPLSTR( "" ),                       // maps to s
    DEF_SPLSTR( "" ),                       // maps to single quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to Y
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "cents" ),
    DEF_SPLSTR( "pounds" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "yen" ),
    DEF_SPLSTR( "" ),                       // maps to |
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "copyright" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to hyphen
    DEF_SPLSTR( "registered trademark" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "degrees" ),
    DEF_SPLSTR( "plus minus" ),
    DEF_SPLSTR( "superscript two" ),
    DEF_SPLSTR( "superscript three" ),
    DEF_SPLSTR( "prime" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "times" ),                  // maps to space
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "superscript one" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to double quote
    DEF_SPLSTR( "one fourth" ),
    DEF_SPLSTR( "one half" ),
    DEF_SPLSTR( "three fourths" ),
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to A
    DEF_SPLSTR( "" ),                       // maps to C
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to E
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to I
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to N
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to O
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to U
    DEF_SPLSTR( "" ),                       // maps to Y
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "beta" ),
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to a
    DEF_SPLSTR( "" ),                       // maps to c
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to e
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to i
    DEF_SPLSTR( "" ),                       // maps to t
    DEF_SPLSTR( "" ),                       // maps to n
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "divided by" ),
    DEF_SPLSTR( "" ),                       // maps to o
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to u
    DEF_SPLSTR( "" ),                       // maps to y
    DEF_SPLSTR( "" ),                       // maps to space
    DEF_SPLSTR( "" ),                       // maps to y
};

//--- Constants used in decade normalization

const SPLSTR g_Decades[] =
{
    DEF_SPLSTR( "thousands" ),   // this will be handled as a special case - "two thousands"
    DEF_SPLSTR( "tens"      ),
    DEF_SPLSTR( "twenties"  ),
    DEF_SPLSTR( "thirties"  ),
    DEF_SPLSTR( "forties"   ),
    DEF_SPLSTR( "fifties"   ),
    DEF_SPLSTR( "sixties"   ),
    DEF_SPLSTR( "seventies" ),
    DEF_SPLSTR( "eighties"  ),
    DEF_SPLSTR( "nineties"  ),
};

const SPLSTR g_Zeroes = DEF_SPLSTR( "zeroes" );
const SPLSTR g_Hundreds = DEF_SPLSTR( "hundreds" );

//--- Miscellaneous constants

const StateStruct g_StateAbbreviations[] =
{
    { DEF_SPLSTR( "AA" ), DEF_SPLSTR( "Armed Forces" ) },
    { DEF_SPLSTR( "AE" ), DEF_SPLSTR( "Armed Forces" ) },
    { DEF_SPLSTR( "AK" ), DEF_SPLSTR( "Alaska" ) },
    { DEF_SPLSTR( "AL" ), DEF_SPLSTR( "Alabama" )  },
    { DEF_SPLSTR( "AP" ), DEF_SPLSTR( "Armed Forces" ) },
    { DEF_SPLSTR( "AR" ), DEF_SPLSTR( "Arkansas" ) },
    { DEF_SPLSTR( "AS" ), DEF_SPLSTR( "American Samoa" ) },
    { DEF_SPLSTR( "AZ" ), DEF_SPLSTR( "Arizona" )  },
    { DEF_SPLSTR( "CA" ), DEF_SPLSTR( "California" ) },
    { DEF_SPLSTR( "CO" ), DEF_SPLSTR( "Colorado" ) },
    { DEF_SPLSTR( "CT" ), DEF_SPLSTR( "Connecticut" ) },
    { DEF_SPLSTR( "DC" ), DEF_SPLSTR( "D C" ) },
    { DEF_SPLSTR( "DE" ), DEF_SPLSTR( "Deleware" ) },
    { DEF_SPLSTR( "FL" ), DEF_SPLSTR( "Florida" ) },
    { DEF_SPLSTR( "FM" ), DEF_SPLSTR( "Federated States Of Micronesia" ) },
    { DEF_SPLSTR( "GA" ), DEF_SPLSTR( "Georgia" ) },
    { DEF_SPLSTR( "GU" ), DEF_SPLSTR( "Guam" ) },
    { DEF_SPLSTR( "HI" ), DEF_SPLSTR( "Hawaii" ) },
    { DEF_SPLSTR( "IA" ), DEF_SPLSTR( "Iowa" ) },
    { DEF_SPLSTR( "ID" ), DEF_SPLSTR( "Idaho" ) },
    { DEF_SPLSTR( "IL" ), DEF_SPLSTR( "Illinois" ) },
    { DEF_SPLSTR( "IN" ), DEF_SPLSTR( "Indiana" ) },
    { DEF_SPLSTR( "KS" ), DEF_SPLSTR( "Kansas" ) },
    { DEF_SPLSTR( "KY" ), DEF_SPLSTR( "Kentucky" ) },
    { DEF_SPLSTR( "LA" ), DEF_SPLSTR( "Louisiana" ) },
    { DEF_SPLSTR( "MA" ), DEF_SPLSTR( "Massachusetts" ) },
    { DEF_SPLSTR( "MD" ), DEF_SPLSTR( "Maryland" ) },
    { DEF_SPLSTR( "ME" ), DEF_SPLSTR( "Maine" ) },
    { DEF_SPLSTR( "MH" ), DEF_SPLSTR( "Marshall Islands" ) },
    { DEF_SPLSTR( "MI" ), DEF_SPLSTR( "Michigan" ) },
    { DEF_SPLSTR( "MN" ), DEF_SPLSTR( "Minnesota" ) },
    { DEF_SPLSTR( "MO" ), DEF_SPLSTR( "Missouri" ) },
    { DEF_SPLSTR( "MP" ), DEF_SPLSTR( "Northern Mariana Islands" ) },
    { DEF_SPLSTR( "MS" ), DEF_SPLSTR( "Mississippi" ) },
    { DEF_SPLSTR( "MT" ), DEF_SPLSTR( "Montana" ) },
    { DEF_SPLSTR( "NC" ), DEF_SPLSTR( "North Carolina" ) },
    { DEF_SPLSTR( "ND" ), DEF_SPLSTR( "North Dakota" ) },
    { DEF_SPLSTR( "NE" ), DEF_SPLSTR( "Nebraska" ) },
    { DEF_SPLSTR( "NH" ), DEF_SPLSTR( "New Hampshire" ) },
    { DEF_SPLSTR( "NJ" ), DEF_SPLSTR( "New Jersey" ) },
    { DEF_SPLSTR( "NM" ), DEF_SPLSTR( "New Mexico" ) },
    { DEF_SPLSTR( "NV" ), DEF_SPLSTR( "Nevada" ) },
    { DEF_SPLSTR( "NY" ), DEF_SPLSTR( "New York" ) },
    { DEF_SPLSTR( "OH" ), DEF_SPLSTR( "Ohio" ) },
    { DEF_SPLSTR( "OK" ), DEF_SPLSTR( "Oklahoma" ) },
    { DEF_SPLSTR( "OR" ), DEF_SPLSTR( "Oregon" ) },
    { DEF_SPLSTR( "PA" ), DEF_SPLSTR( "Pennsylvania" ) },
    { DEF_SPLSTR( "PR" ), DEF_SPLSTR( "Puerto Rico" ) },
    { DEF_SPLSTR( "PW" ), DEF_SPLSTR( "Palau" ) },
    { DEF_SPLSTR( "RI" ), DEF_SPLSTR( "Rhode Island" ) },
    { DEF_SPLSTR( "SC" ), DEF_SPLSTR( "South Carolina" ) },
    { DEF_SPLSTR( "SD" ), DEF_SPLSTR( "South Dakota" ) },
    { DEF_SPLSTR( "TN" ), DEF_SPLSTR( "Tennessee" ) },
    { DEF_SPLSTR( "TX" ), DEF_SPLSTR( "Texas" ) },
    { DEF_SPLSTR( "UT" ), DEF_SPLSTR( "Utah" ) },
    { DEF_SPLSTR( "VA" ), DEF_SPLSTR( "Virginia" ) },
    { DEF_SPLSTR( "VI" ), DEF_SPLSTR( "Virgin Islands" ) },
    { DEF_SPLSTR( "VT" ), DEF_SPLSTR( "Vermont" ) },
    { DEF_SPLSTR( "WA" ), DEF_SPLSTR( "Washington" ) },
    { DEF_SPLSTR( "WI" ), DEF_SPLSTR( "Wisconsin" ) },
    { DEF_SPLSTR( "WV" ), DEF_SPLSTR( "West Virginia" ) },
    { DEF_SPLSTR( "WY" ), DEF_SPLSTR( "Wyoming" ) },
};

const SPVSTATE g_DefaultXMLState = 
{
    SPVA_Speak,     // SPVACTIONS
    0,              // LangID
    0,              // wReserved
    0,              // EmphAdj
    0,              // RateAdj
    100,            // Volume
    { 0, 0 },       // PitchAdj
    0,              // SilenceMSecs
    0,              // pPhoneIds
    SPPS_Unknown,   // POS
    { 0, 0, 0 }     // Context
};

const SPLSTR g_And = DEF_SPLSTR( "and" );

extern const SPLSTR g_comma = DEF_SPLSTR( "," );
extern const SPLSTR g_period = DEF_SPLSTR( "." );
extern const SPLSTR g_periodString = DEF_SPLSTR( "period" );
extern const SPLSTR g_slash = DEF_SPLSTR( "or" );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\miscdata.cpp ===
/******************************************************************************
* MiscData.cpp *
*--------------*
*  This file stores the const data used in various non-normalization front-end
*  code
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 05/02/2000
*  All Rights Reserved
*
****************************************************************** AARONHAL ***/

#include "stdafx.h"
#include"stdsentenum.h"

//--- Variable used to make sure initialization of pronunciations only happens once!
BOOL g_fAbbrevTablesInitialized = false;

//--- Helper function used to delete dynamically allocated memory (for the abbreviation
//    table) at DLL exit time...
void CleanupAbbrevTables( void ) 
{
    if ( g_fAbbrevTablesInitialized )
    {
        for ( ULONG i = 0; i < sp_countof( g_AbbreviationTable ); i++ )
        {
            if ( g_AbbreviationTable[i].pPron1 )
            {
                delete [] g_AbbreviationTable[i].pPron1;
            }
            if ( g_AbbreviationTable[i].pPron2 )
            {
                delete [] g_AbbreviationTable[i].pPron2;
            }
            if ( g_AbbreviationTable[i].pPron3 )
            {
                delete [] g_AbbreviationTable[i].pPron3;
            }
        }
        for ( i = 0; i < sp_countof( g_AmbiguousWordTable ); i++ )
        {
            if ( g_AmbiguousWordTable[i].pPron1 )
            {
                delete [] g_AmbiguousWordTable[i].pPron1;
            }
            if ( g_AmbiguousWordTable[i].pPron2 )
            {
                delete [] g_AmbiguousWordTable[i].pPron2;
            }
            if ( g_AmbiguousWordTable[i].pPron3 )
            {
                delete [] g_AmbiguousWordTable[i].pPron3;
            }
        }
        for ( i = 0; i < sp_countof( g_PostLexLookupWordTable ); i++ )
        {
            if ( g_PostLexLookupWordTable[i].pPron1 )
            {
                delete [] g_PostLexLookupWordTable[i].pPron1;
            }
            if ( g_PostLexLookupWordTable[i].pPron2 )
            {
                delete [] g_PostLexLookupWordTable[i].pPron2;
            }
            if ( g_PostLexLookupWordTable[i].pPron3 )
            {
                delete [] g_PostLexLookupWordTable[i].pPron3;
            }
        }
        if ( g_pOfA )
        {
            delete [] g_pOfA;
        }
        if ( g_pOfAn )
        {
            delete [] g_pOfAn;
        }
    }
}

const BrillPatch g_POSTaggerPatches [] =
{
    { MS_Adj, MS_Noun, CAP, MS_Unknown, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1T, MS_Adj, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, CAP, MS_Unknown, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Conj, MS_Adv, NEXT2T, MS_Conj, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, NEXT1T, MS_Verb, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1TNEXT1T, MS_Noun, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV2T, MS_Prep, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_SubjPron, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Pron, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Adv, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, NEXT1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1TNEXT1T, MS_Verb, MS_Adj, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1TNEXT1T, MS_Noun, MS_Verb, NULL, NULL },
    { MS_Noun, MS_Adj, NEXT1T, MS_Adj, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, NEXT1T, MS_CConj, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Adv, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Adj, NULL, NULL },
    { MS_Adv, MS_Prep, PREV1TNEXT1T, MS_Noun, MS_Prep, NULL, NULL },
    { MS_Adv, MS_Prep, PREV1TNEXT2T, MS_Verb, MS_Noun, NULL, NULL },
    { MS_Adj, MS_Adv, NEXT1T, MS_Adv, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, NEXT1T, MS_ObjPron, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Adj, PREV1TNEXT1T, MS_Prep, MS_Noun, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Interr, MS_Prep, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1TNEXT1T, MS_Adv, MS_Adj, NULL, NULL },
    { MS_Prep, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Conj, NEXT1T, MS_SubjPron, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Adj, MS_Prep, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT2T, MS_Interr, MS_Noun, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1TNEXT1T, MS_Unknown, MS_Verb, NULL, NULL },
    { MS_Adj, MS_Verb, PREV1TNEXT1T, MS_Verb, MS_Adj, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1TNEXT1T, MS_Unknown, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Prep, PREV1TNEXT2T, MS_Prep, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, PREV2TNEXT1T, MS_Verb, MS_Adj, NULL, NULL },
    { MS_Adv, MS_Prep, NEXT1T, MS_Noun, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV1TNEXT1T, MS_Conj, MS_Verb, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Prep, MS_Prep, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Pron, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Noun, MS_Verb, NULL, NULL },
    { MS_Adj, MS_Adv, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Noun, NEXT1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Adv, NEXT1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Noun, PREV1TNEXT1T, MS_Unknown, MS_Prep, NULL, NULL },
    { MS_Verb, MS_Noun, PREV2TNEXT1T, MS_Unknown, MS_Verb, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_SubjPron, MS_Unknown, NULL, NULL },
    { MS_Adj, MS_Verb, PREV1TNEXT1T, MS_Prep, MS_Adv, NULL, NULL },
    { MS_Adv, MS_Adj, PREV1TNEXT1T, MS_Conj, MS_Noun, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1TNEXT1T, MS_Prep, MS_Adj, NULL, NULL },
    { MS_Adv, MS_Prep, NEXT1T, MS_Verb, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Adj, NEXT1T, MS_Adj, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Conj, NEXT1T, MS_Pron, MS_Unknown, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Adv, MS_Unknown, NULL, NULL },
    { MS_Verb, MS_Noun, PREV2TNEXT1T, MS_CConj, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_VAux, MS_Unknown, NULL, NULL },
    { MS_Noun, MS_Verb, PREV1T, MS_Pron, MS_Unknown, NULL, NULL },
    { MS_Adv, MS_Adj, PREV2TNEXT1T, MS_Prep, MS_Noun, NULL, NULL },
    { MS_Noun, MS_Adj, PREV1TNEXT1T, MS_Adv, MS_Noun, NULL, NULL },
    { MS_Conj, MS_Adv, PREV1TNEXT1T, MS_Adv, MS_Adj, NULL, NULL },
    //--- Inserted by hand - convert "A" from Det to Noun after Det...
    { MS_Det, MS_Noun, CURRWPREV1T, MS_Det, MS_Unknown, L"a", NULL },
    { MS_Verb, MS_Adj, PREV1TNEXT1T, MS_Det, MS_Noun, NULL, NULL },
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
AbbrevRecord g_AbbreviationTable[] =
{
    { L"a",     L"EY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"amp",   L"AE 1 M P", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"app",   L"AE 1 P", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"apr",   L"EY 1 - P R AX L", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"apt",   L"ax - p aa 1 r t - m ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"assoc", L"ax - s ow 2 - s iy - ey 1 - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"asst",  L"ax - s ih 1 s - t ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"aug",   L"ao 1 - g ax s t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ave",   L"ae 1 v - ax - n uw 2", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"b",     L"B IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"bldg",  L"b ih 1 l - d ih ng", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"blvd",  L"b uh 1 l - ax - v aa 2 r d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"bu",    L"b uh 1 sh - ax l", MS_Noun, L"b uh 1 sh - ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Initial - never EOS
    { L"c",     L"s eh 1 l - s iy - ax s", MS_Noun, L"s iy 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"cal",   L"k ae 1 l - ax - r iy", MS_Noun, L"k ae 1 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    { L"cals",  L"k ae 1 l - ax - r iy Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ch",    L"ch ae 1 p - t er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"cl",    L"s eh 1 n - t ax - l iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"cm",    L"s eh 1 n - t ax - m iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"cms",   L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"cntr",  L"s eh 1 n - t er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"co",    L"k ah 1 m - p ax - n iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"cont",  L"k ax n - t ih 1 n - y uw D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"corp",  L"k ao 2 r - p ax - r ey 1 - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"ct",    L"k ao 1 r t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"ctr",   L"s eh 1 n - t er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
	//--- IfEOSNotAbbreviation
    { L"cu",    L"k y uw 1 - b ih k", MS_Noun, L"k y uw 1 - b ih k", MS_Noun, NULL, MS_Unknown, 1, 4 },
    //--- Initial - never EOS
    { L"d",     L"D IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"db",    L"d eh 1 s - ax - b ax l", MS_Noun, L"d eh 1 s - ax - b ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"dec",   L"d ih - s eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"deg",   L"d ih - g r iy 1", MS_Noun, L"d ih - g r iy 1 z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"dept",  L"d ih - p aa 1 r t - m ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"dist",  L"d ih 1 s - t r ax k t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"doc",   L"D AA 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"doz",   L"d ah 1 z - ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- DoctorDriveAbbreviation
    { L"dr",    L"d aa 1 k - t er", MS_Noun, L"D R AY 1 V", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- Initial - never EOS
    { L"e",     L"IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"ed",    L"eh 2 jh - ax - k ey 1 - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"esq",   L"eh 1 s - k w ay 2 r", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"est",   L"ax - s t ae 1 b - l ax sh T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"etc",   L"EH T & s eh 1 t - er - ax", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"ex",    L"ih g - z ae 1 m - p ax l", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"ext",   L"ih k - s t eh 1 n - sh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"f",     L"f ae 1 r - ax n - h ay 2 t", MS_Noun, L"eh 1 f", MS_Noun, NULL, MS_Unknown, 0, 3 },
    { L"feb",   L"f eh 1 b - r uw - eh 2 r - iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"fig",   L"f ih 1 g - y er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- IfEOSNotAbbreviation
    { L"figs",  L"f ih 1 g - y er Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- IfEOSNotAbbreviation
    { L"fl",    L"f l uw 1 - ih d", MS_Noun, L"f l uw 1 - ih d", MS_Noun, NULL, MS_Unknown, 1, 4 },
    { L"fn",    L"f uh 1 t - n ow 2 t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"freq",  L"f r iy 1 - k w ax n - s iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"fri",   L"f r ay 1 - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"ft",    L"F UH 1 T", MS_Noun, L"F IY 1 T", MS_Noun, L"F AO 1 R T", MS_Noun, 0, 0 },
    { L"fwd",   L"f ao 1 r - w er d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"g",     L"G R AE 1 M", MS_Noun, L"G R AE 1 M Z", MS_Noun, L"JH IY 1", MS_Noun, 1, 0 },
    //--- SingleOrPluralAbbreviation
    { L"gal",   L"g ae 1 l - ax n", MS_Noun, L"g ae 1 l - ax n Z", MS_Noun, L"G AE 1 L", MS_Noun, 0, 0 },
    //--- TITLE - never EOS
    { L"gen",   L"jh eh 1 n - er - ax l", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"gov",   L"g ah 1 v - er - n ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- Initial - never EOS
    { L"h",     L"EY 1 CH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"hr",    L"AW 1 ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"hrs",   L"AW 1 ER Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ht",    L"H AY 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"hwy",   L"h ay 1 w ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"hz",    L"H ER 1 T S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"i",     L"AY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"in",    L"IH 1 N CH", MS_Noun, L"IH 1 N CH AX Z", MS_Noun, L"IH 1 N", MS_Prep, 1, 0 },
    { L"inc",   L"ih n - k ao 1 r - p ax - r ey 2 - t AX D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"incl",  L"ih n - k l uw 1 - d AX D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"intl",  L"ih 2 n - t er - n ae 1 sh - ax - n ax l", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSAndLowercaseNotAbbreviation
    { L"is",    L"ay 1 - l ax n d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 2, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"j",     L"JH UW 1 L", MS_Noun, L"JH UW 1 L Z", MS_Noun, L"JH EY 1", MS_Noun, 1, 0 },
    //--- IfEOSNotAbbreviation
    { L"jan",   L"jh ae 1 n - y uw - eh 2 r - iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"jr",    L"jh uw 1 n - y er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"jul",   L"jh uh - l ay 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"jun",   L"JH UW 1 N", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"k",     L"k eh 1 l - v ax n", MS_Noun, L"k ey 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"kb",    L"k ih 1 l - ax - b ay 2 t", MS_Noun, L"k ih 1 l - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kcal",  L"k ih 1 l - ax - k ae 2 l - ax - r iy", MS_Noun, L"k ih 1 l - ax - k ae 2 l - ax - r iy Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kg",    L"k ih 1 l - ax - g r ae 2 m", MS_Noun, L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"kgs",   L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"khz",   L"k ih 1 l - ax - h er 2 t s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"kj",    L"k ih 1 l - ax - jh uw 2 l", MS_Noun, L"k ih 1 l - ax - jh uw 2 l z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"km",    L"k ih - l aa 1 m - ih - t er", MS_Noun, L"k ih - l aa 1 m - ih - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kw",    L"k ih 1 l - ax - w aa 2 t", MS_Noun, L"k ih 1 l - ax - w aa 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"l",     L"l iy 1 - t er", MS_Noun, L"l iy 1 - t er Z", MS_Noun, L"EH 1 L", MS_Noun, 1, 0 },
    //--- SingleOrPluralAbbreviation
    { L"lb",    L"P AW 1 N D", MS_Noun, L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"lbs",   L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"lg",    L"L AA 1 R JH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"ln",    L"l ey 1 n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Title - never EOS
    { L"lt",    L"l uw - t eh 1 n - ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"ltd",   L"l ih 1 m - ih - t AX D", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"m",     L"M IY 1 T ER", MS_Noun, L"M IY 1 T ER Z", MS_Noun, L"EH 1 M", MS_Noun, 1, 0 },
    //--- IfEOSNotAbbreviation???
    { L"mar",   L"M AA 1 R CH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"mb",    L"m eh 1 g - ax - b ay 2 t", MS_Noun, L"m eh 1 g - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mfg",   L"m ae 2 n - y ax - f ae 1 k - ch er - IH NG", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"mg",    L"m ih 1 l - ax - g r ae 2 m", MS_Noun, L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mgr",   L"m ae 1 n - ih - jh ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mgs",   L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mhz",   L"m eh 1 g - ax - h er 2 t s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"mi",    L"M AY 1 L", MS_Noun, L"M AY 1 L Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mic",   L"M AY 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"min",   L"m ih 1 n - ax t", MS_Noun, L"m ih 1 n - ax t S", MS_Noun, L"m ih 1 n - ax - m ax m", MS_Noun, 0, 0 },
    { L"misc",  L"m ih 2 s - ax - l ey 1 - n iy - ax s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"ml",    L"m ih 1 l - ax - l iy 2 - t er", MS_Noun, L"m ih 1 l - ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mm",    L"m ih 1 l - ax - m iy 2 - t er", MS_Noun, L"m ih 1 l - ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"mon",   L"m ah 1 n - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- TITLE - never EOS
    { L"mr",    L"M IH 1 S - T ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- TITLE - never EOS
    { L"mrs",   L"M IH 1 S - AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"ms",    L"M IH 1 Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"msec",  L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"msecs", L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mt",    L"M AW 1 N T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"mtn",   L"m aw 1 n - t ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"n",     L"EH 1 N", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSNotAbbreviation
    { L"no",    L"N UH 1 M - B ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"nov",   L"n ow - v eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"o",     L"OW 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"oct",   L"aa k - t ow 1 - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"op",    L"OW 1 - P AX S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"oz",    L"AW 1 N S", MS_Noun, L"AW 1 N - S AX Z", MS_Noun, L"AA 1 Z", MS_Noun, 0, 0 },
    { L"ozs",   L"AW 1 N - S AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- AbbreviationFollowedByDigit
    { L"p",     L"P EY 1 JH", MS_Noun, L"P IY 1", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- IfEOSNotAbbreviation
    { L"pg",    L"P EY 1 JH", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    { L"pgs",   L"P EY 1 - JH AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pkg",   L"p ae 1 k - ih jh", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pkwy",  L"p aa 1 r k - w ey 2", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pl",    L"P L EY 1 S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"pp",    L"P EY 1 - JH AX Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- TITLE - never EOS
    { L"pres",  L"p r eh 1 z - ax - d ax n t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- TITLE - never EOS
    { L"prof",  L"p r ax - f eh 1 - s ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"pt",    L"P OY 1 N T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"q",     L"K Y UW 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"qt",    L"k w ao 1 r t", MS_Noun, L"k w ao 1 r t Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Initial - never EOS
    { L"r",     L"AA 1 R", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"rd",    L"r ow 1 d", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rec",   L"R EH 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rep",   L"r eh 2 p - r ih - z eh 1 n - t ax - t ih v", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rt",    L"R UW 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"rte",    L"R UW 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"s",     L"EH 1 S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSAndLowercaseNotAbbreviation
    { L"sat",   L"s ae 1 t - er - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 2, -1 },
    //--- SingleOrPluralAbbreviation, IfEOSNotAbbreviation
    { L"sec",   L"s eh 1 k - ax n d", MS_Noun, L"s eh 1 k - ax n d z", MS_Noun, NULL, MS_Unknown, 1, 0 },
    //--- TITLE - never EOS
    { L"sen",   L"s eh 1 n - ax - t ER", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"sep",   L"s eh p - t eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"sept",  L"s eh p - t eh 1 m - b er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"sm",    L"S M AO 1 L", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 }, 
    { L"sq",    L"S K W EH 1 R", MS_Noun, L"S K W EH 1 R", MS_Noun, NULL, MS_Unknown, 0, 4 },
    //--- IfEOSNotAbbreviation
    { L"sr",    L"s iy 1 n - y er", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- DoctorDriveAbbreviation
    { L"st",    L"S EY 1 N T", MS_Noun, L"S T R IY 1 T", MS_Noun, NULL, MS_Unknown, 0, 1 },
    { L"ste",   L"s w iy 1 t", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- IfEOSNotAbbreviation
    { L"sun",   L"s ah 1 n - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 1, -1 },
    //--- Initial - never EOS
    { L"t",     L"T IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"tbsp",  L"t ey 1 - b ax l - s p uw 2 n", MS_Noun, L"t ey 1 - b ax l - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"tech",  L"T EH 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"thu",   L"th er 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"thur",  L"th er 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"thurs", L"th er 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"tsp",   L"t iy 1 - s p uw 2 n", MS_Noun, L"t iy 1 - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"tue",   L"t uw 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"tues",  L"t uw 1 z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"u",     L"Y UW 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"univ",  L"y uw 2 - n ax - v er 1 - s ih - t iy", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"v",     L"V IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    { L"ver",   L"v er 1 - zh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"vers",  L"v er 1 - zh ax n", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"vol",   L"v aa 1 l - y uw m", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"vs",    L"v er 1 - s ax s", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"w",     L"d ah 1 b - ax l - y uw", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- IfEOSAndLowercaseNotAbbreviation
    { L"wed",   L"w eh 1 n z - d ey", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 2, -1 },
    { L"wk",    L"W IY 1 K", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"wt",    L"W EY 1 T", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    { L"wy",    L"W EY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- Initial - never EOS
    { L"x",     L"EH 1 K S", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- Initial - never EOS
    { L"y",     L"W AY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
    //--- SingleOrPluralAbbreviation
    { L"yd",    L"Y AA 1 R D", MS_Noun, L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    { L"yds",   L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, 0, -1 },
    //--- SingleOrPluralAbbreviation
    { L"yr",    L"Y IY 1 R", MS_Noun, L"Y IY 1 R Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Initial - never EOS
    { L"z",     L"Z IY 1", MS_Noun, NULL, MS_Unknown, NULL, MS_Unknown, -1, -1 },
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
AbbrevRecord g_AmbiguousWordTable[] =
{
    //--- ADisambig
    { L"a",     L"EY 1", MS_Noun, L"AX", MS_Det, NULL, MS_Unknown, 0, 8 },
    //--- AllCapsAbbreviation
    { L"al",    L"EY 1 & EH 1 L", MS_Noun, L"AE 1 L", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"apr",   L"ey 1 & p iy 1 & aa 1 r", MS_Noun, L"ey 1 - p r ax l", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"as",    L"EY 1 & EH 1 S", MS_Noun, L"AE 1 Z", MS_Conj, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"bu",    L"b uh 1 sh - ax l", MS_Noun, L"b uh 1 sh - ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- DegreeAbbreviation
    { L"c",     L"s eh 1 l - s iy - ax s", MS_Noun, L"s iy 1", MS_Noun, NULL, MS_Unknown, 0, 6 },
    //--- SingleOrPluralAbbreviation
    { L"cal",   L"k ae 1 l - ax - r iy", MS_Noun, L"k ae 1 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"cl",    L"s eh 1 n - t ax - l iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"cm",    L"s eh 1 n - t ax - m iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"co",    L"S IY 1 & OW 1", MS_Noun, L"k ah 1 m - p ax - n iy", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"ct",    L"s iy 1 & t iy 1", MS_Noun, L"k ao 1 r t", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- MeasurementModifier
    { L"cu",    L"S IY 1 & Y UW 1", MS_Noun, L"k y uw 1 - b ih k", MS_Noun, NULL, MS_Unknown, 0, 7 },
    //--- SingleOrPluralAbbreviation
    { L"db",    L"d eh 1 s - ax - b ax l", MS_Noun, L"d eh 1 s - ax - b ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"deg",   L"d ih - g r iy 1", MS_Noun, L"d ih - g r iy 1 z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- DoctorDriveAbbreviation
    { L"dr",    L"d aa 1 k - t er", MS_Noun, L"D R AY 1 V", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- DegreeAbbreviation
    { L"f",     L"f ae 1 r - ax n - h ay 2 t", MS_Noun, L"eh 1 f", MS_Noun, NULL, MS_Unknown, 0, 6 },
    //--- AbbreviationFollowedByDigit
    { L"fig",   L"f ih 1 g - y er", MS_Noun, L"F IH 1 G", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- AbbreviationFollowedByDigit
    { L"figs",  L"f ih 1 g - y er Z", MS_Noun, L"F IH 1 G Z", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementModifier
    { L"fl",    L"eh 1 f & eh 1 l", MS_Noun, L"f l uw 1 - ih d", MS_Noun, NULL, MS_Unknown, 0, 7 },
    //--- SingleOrPluralAbbreviation
    { L"ft",    L"F UH 1 T", MS_Noun, L"F IY 1 T", MS_Noun, L"F AO 1 R T", MS_Noun, 0, 0 },
    //--- G, Gram, Grams
    { L"g",     L"G R AE 1 M", MS_Noun, L"G R AE 1 M Z", MS_Noun, L"JH IY 1", MS_Noun, 0, 5 },
    //--- DoctorDriveAbbreviation
    { L"gov",   L"g ah 1 v - er - n ER", MS_Noun, L"G AH 1 V", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- AllCapsAbbreviation
    { L"hi",    L"EY 1 CH & AY 1", MS_Noun, L"H AY 1", MS_Interjection, NULL, MS_Unknown, 0, 3 },
    //--- HR hour hours
    { L"hr",    L"AW 1 ER", MS_Noun, L"AW 1 ER Z", MS_Noun, L"EY 1 CH AA 1 R", MS_Noun, 0, 5 },
    //--- J, Joule, Joules
    { L"j",     L"JH UW 1 L", MS_Noun, L"JH UW 1 L Z", MS_Noun, L"JH EY 1", MS_Noun, 0, 5 },
    //--- DegreeAbbreviation
    { L"k",     L"k eh 1 l - v ax n", MS_Noun, L"k ey 1", MS_Noun, NULL, MS_Unknown, 0, 6 },
    //--- SingleOrPluralAbbreviation
    { L"kb",    L"k ih 1 l - ax - b ay 2 t", MS_Noun, L"k ih 1 l - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kcal",  L"k ih 1 l - ax - k ae 2 l - ax - r iy", MS_Noun, L"k ih 1 l - ax - k ae 2 l - ax - r iy Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kg",    L"k ih 1 l - ax - g r ae 2 m", MS_Noun, L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kj",    L"k ih 1 l - ax - jh uw 2 l", MS_Noun, L"k ih 1 l - ax - jh uw 2 l z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"km",    L"k ih - l aa 1 m - ih - t er", MS_Noun, L"k ih - l aa 1 m - ih - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"kw",    L"k ih 1 l - ax - w aa 2 t", MS_Noun, L"k ih 1 l - ax - w aa 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- L, Liter, Liters
    { L"l",     L"l iy 1 - t er", MS_Noun, L"l iy 1 - t er Z", MS_Noun, L"EH 1 L", MS_Noun, 0, 5 },
    //--- AllCapsAbbreviation
    { L"la",    L"EH 1 L & EY 1", MS_Noun, L"L AH 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"lb",    L"P AW 1 N D", MS_Noun, L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"lts",   L"eh 1 l & t iy 1 & eh 1 s", MS_Noun, L"l uw t eh 1 n ax n t s", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- M, Meter, Meters
    { L"m",     L"M IY 1 - T ER", MS_Noun, L"M IY 1 - T ER Z", MS_Noun, L"EH 1 M", MS_Noun, 0, 5 },
    //--- AllCapsAbbreviation
    { L"ma",    L"EH 1 M & AA 1", MS_Noun, L"M AA 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- March Mar
    { L"mar",   L"M AA 1 R CH", MS_Noun, L"M AA 1 R", MS_Verb, NULL, MS_Unknown, 0, 4 },
    //--- SingleOrPluralAbbreviation
    { L"mb",    L"m eh 1 g - ax - b ay 2 t", MS_Noun, L"m eh 1 g - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"me",    L"EH 1 M & IY 1", MS_Noun, L"M IY 1", MS_ObjPron, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"mg",    L"m ih 1 l - ax - g r ae 2 m", MS_Noun, L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mi",    L"M AY 1 L", MS_Noun, L"M AY 1 L Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"min",   L"m ih 1 n - ax t", MS_Noun, L"m ih 1 n - ax t S", MS_Noun, L"m ih 1 n - ax - m ax m", MS_Noun, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"ml",    L"m ih 1 l - ax - l iy 2 - t er", MS_Noun, L"m ih 1 l - ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mm",    L"m ih 1 l - ax - m iy 2 - t er", MS_Noun, L"m ih 1 l - ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mpg", L"m ay 1 l & p er 1 & g ae 1 l ax n", MS_Noun, L"m ay 1 l z & p er 1 & g ae 1 l ax n", MS_Noun, L"eh 1 m & p iy 1 & jh iy 1", MS_Noun, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"mph",   L"m ay 1 l & p er 1 & aw 1 er", MS_Noun, L"m ay 1 l z & p er 1 & aw 1 er", MS_Noun, L"eh 1 m & p iy 1 & ey 1 ch", MS_Noun, 0, 0 },
    //--- MS millisecond milliseconds
    { L"ms",    L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, L"eh 1 m & eh 1 s", MS_Noun, 0, 5 },
    //--- SingleOrPluralAbbreviation
    { L"msec",  L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"mt",    L"EH 1 M & T IY 1", MS_Noun, L"M AW 1 N T", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"oh",    L"OW 1 & EY 1 CH", MS_Noun, L"OW 1", MS_Interjection, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"or",    L"OW 1 & AA 1 R", MS_Noun, L"AO 1 R", MS_CConj, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"oz",    L"AW 1 N S", MS_Noun, L"AW 1 N S AX Z", MS_Noun, L"AA 1 Z", MS_Noun, 0, 0 },
    //--- AbbreviationFollowedByDigit
    { L"p",     L"P EY 1 JH", MS_Noun, L"P IY 1", MS_Noun, NULL, MS_Unknown, 0, 2 },
    //--- AllCapsAbbreviation
    { L"pa",    L"P IY 1 & EY 1", MS_Noun, L"P AA 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"pg",    L"P IY 1 & JH IY 1", MS_Noun, L"P EY 1 JH", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- AllCapsAbbreviation
    { L"po",    L"p iy 1 & ow 1", MS_Noun, L"p ow 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- PolishDisambig
    { L"polish", L"p ow 1 l - ax sh", MS_Adj, L"p aa 1 l - ih sh", MS_Verb, L"p aa 1 l - ih sh", MS_Noun, 0, 9 },
    //--- SingleOrPluralAbbreviation
    { L"qt",    L"K W AO 1 R T", MS_Noun, L"K W AO 1 R T Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- Saturday Sat
    { L"sat",   L"s ae 1 t - er - d ey", MS_Noun, L"S AE 1 T", MS_Verb, NULL, MS_Unknown, 0, 4 },
    //--- SEC Second Seconds
    { L"sec",   L"s eh 1 k - ax n d", MS_Noun, L"s eh 1 k - ax n d Z", MS_Noun, L"EH 1 S & IY 1 & S IY 1", MS_Noun, 0, 5 },
    //--- MeasurementModifier
    { L"sq",    L"S K W EH 1 R", MS_Noun, L"S K W EH 1 R", MS_Noun, NULL, MS_Unknown, 0, 7 },
	//--- AllCapsAbbreviation
    { L"sr",    L"EH 1 S & AA 1 R", MS_Noun, L"s iy 1 n - y er", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- DoctorDriveAbbreviation
    { L"st",    L"S EY 1 N T", MS_Noun, L"S T R IY 1 T", MS_Noun, NULL, MS_Unknown, 0, 1 },
    //--- SingleOrPluralAbbreviation
    { L"tbsp",  L"t ey 1 - b ax l - s p uw 2 n", MS_Noun, L"t ey 1 - b ax l - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"tsp",   L"t iy 1 - s p uw 2 n", MS_Noun, L"t iy 1 - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- AllCapsAbbreviation
    { L"us",    L"Y UW 1 & EH 1 S", MS_Noun, L"AH 1 S", MS_ObjPron, NULL, MS_Unknown, 0, 3 },
    //--- Wednesday Wed
    { L"wed",   L"w eh 1 n z - d ey", MS_Noun, L"W EH 1 D", MS_Verb, NULL, MS_Unknown, 0, 4 },
    //--- AllCapsAbbreviation
    { L"wy",    L"d ah 1 b - ax l - y uw & W AY 1", MS_Noun, L"W EY 1", MS_Noun, NULL, MS_Unknown, 0, 3 },
    //--- SingleOrPluralAbbreviation
    { L"yd",    L"Y AA 1 R D", MS_Noun, L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- SingleOrPluralAbbreviation
    { L"yr",    L"Y IY 1 R", MS_Noun, L"Y IY 1 R Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
AbbrevRecord g_PostLexLookupWordTable[] =
{
    //--- MeasurementDisambig
    { L"bu",    L"b uh 1 sh - ax l", MS_Noun, L"b uh 1 sh - ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"cal",   L"k ae 1 l - ax - r iy", MS_Noun, L"k ae 1 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"cl",    L"s eh 1 n - t ax - l iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"cm",    L"s eh 1 n - t ax - m iy 2 - t er", MS_Noun, L"s eh 1 n - t ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"db",    L"d eh 1 s - ax - b ax l", MS_Noun, L"d eh 1 s - ax - b ax l Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"deg",   L"d ih - g r iy 1", MS_Noun, L"d ih - g r iy 1 z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"ft",    L"F UH 1 T", MS_Noun, L"F IY 1 T", MS_Noun, L"F AO 1 R T", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"g",     L"G R AE 1 M", MS_Noun, L"G R AE 1 M Z", MS_Noun, L"JH IY 1", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"gal",   L"g ae 1 l - ax n", MS_Noun, L"g ae 1 l - ax n Z", MS_Noun, L"G AE 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"hr",    L"AW 1 ER", MS_Noun, L"AW 1 ER Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"in",    L"IH 1 N CH", MS_Noun, L"IH 1 N CH AX Z", MS_Noun, L"IH 1 N", MS_Prep, 0, 0 },
    //--- MeasurementDisambig
    { L"j",     L"JH UW 1 L", MS_Noun, L"JH UW 1 L Z", MS_Noun, L"JH EY 1", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"kb",    L"k ih 1 l - ax - b ay 2 t", MS_Noun, L"k ih 1 l - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"kcal",  L"k ih 1 l - ax - k ae 2 l - ax - r iy", MS_Noun, L"k ih 1 l - ax - k ae 2 l - ax - r iy Z", MS_Noun, L"K AE 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"kg",    L"k ih 1 l - ax - g r ae 2 m", MS_Noun, L"k ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"kj",    L"k ih 1 l - ax - jh uw 2 l", MS_Noun, L"k ih 1 l - ax - jh uw 2 l z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"km",    L"k ih - l aa 1 m - ih - t er", MS_Noun, L"k ih - l aa 1 m - ih - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"kw",    L"k ih 1 l - ax - w aa 2 t", MS_Noun, L"k ih 1 l - ax - w aa 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"l",     L"l iy 1 - t er", MS_Noun, L"l iy 1 - t er Z", MS_Noun, L"EH 1 L", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"lb",    L"P AW 1 N D", MS_Noun, L"P AW 1 N D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"m",     L"M IY 1 - T ER", MS_Noun, L"M IY 1 - T ER Z", MS_Noun, L"EH 1 M", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"mb",    L"m eh 1 g - ax - b ay 2 t", MS_Noun, L"m eh 1 g - ax - b ay 2 t S", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mg",    L"m ih 1 l - ax - g r ae 2 m", MS_Noun, L"m ih 1 l - ax - g r ae 2 m Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mi",    L"M AY 1 L", MS_Noun, L"M AY 1 L Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"min",   L"m ih 1 n - ax t", MS_Noun, L"m ih 1 n - ax t S", MS_Noun, L"m ih 1 n - ax - m ax m", MS_Noun, 0, 0 },
    //--- ReadDisambig
    { L"misread", L"m ih s - r iy 1 d", MS_Verb, L"m ih s - r eh 1 d", MS_Verb, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementDisambig
    { L"ml",    L"m ih 1 l - ax - l iy 2 - t er", MS_Noun, L"m ih 1 l - ax - l iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mm",    L"m ih 1 l - ax - m iy 2 - t er", MS_Noun, L"m ih 1 l - ax - m iy 2 - t er Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"mpg", L"m ay 1 l & p er 1 & g ae 1 l ax n", MS_Noun, L"m ay 1 l z & p er 1 & g ae 1 l ax n", MS_Noun, L"eh 1 m & p iy 1 & jh iy 1", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"mph",   L"m ay 1 l & p er 1 & aw 1 er", MS_Noun, L"m ay 1 l z & p er 1 & aw 1 er", MS_Noun, L"eh 1 m & p iy 1 & ey 1 ch", MS_Noun, 0, 0 },
    //--- MeasurementDisambig
    { L"msec",  L"m ih 2 l - ax - s eh 1 k - ax n d", MS_Noun, L"m ih 2 l - ax - s eh 1 k - ax n d Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"oz",    L"AW 1 N S", MS_Noun, L"AW 1 N S AX Z", MS_Noun, L"AA 1 Z", MS_Noun, 0, 0 },
    //--- ReadDisambig
    { L"proofread", L"p r uw 1 f - r iy 2 d", MS_Verb, L"p r uw 1 f - r eh 2 d", MS_Verb, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementDisambig
    { L"qt",    L"K W AO 1 R T", MS_Noun, L"K W AO 1 R T Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- ReadDisambig
    { L"read",  L"R IY 1 D", MS_Verb, L"R EH 1 D", MS_Verb, NULL, MS_Unknown, 0, 2 },
    //--- MeasurementDisambig
    { L"sec",   L"S EH 1 k - ax n d", MS_Noun, L"s eh 1 k - ax n d z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"tbsp",  L"t ey 1 - b ax l - s p uw 2 n", MS_Noun, L"t ey 1 - b ax l - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- TheDisambig
    { L"the",   L"DH IY 2", MS_Det, L"DH AX 2", MS_Det, NULL, MS_Unknown, 0, 1 },
    //--- MeasurementDisambig
    { L"tsp",   L"t iy 1 - s p uw 2 n", MS_Noun, L"t iy 1 - s p uw 2 n Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"yd",    L"Y AA 1 R D", MS_Noun, L"Y AA 1 R D Z", MS_Noun, NULL, MS_Unknown, 0, 0 },
    //--- MeasurementDisambig
    { L"yr",    L"Y IY 1 R", MS_Noun, L"Y IY 1 R Z", MS_Noun, NULL, MS_Unknown, 0, 0 },

};

WCHAR *g_pOfA = L"ah 2 v & ax 2 &";
WCHAR *g_pOfAn = L"ah 2 v & ax 2 n &";

const SentBreakDisambigFunc g_SentBreakDisambigTable[] = 
{
    CStdSentEnum::IsAbbreviationEOS,
    CStdSentEnum::IfEOSNotAbbreviation,
    CStdSentEnum::IfEOSAndLowercaseNotAbbreviation,
};

const PronDisambigFunc g_PronDisambigTable[] = 
{
    CStdSentEnum::SingleOrPluralAbbreviation,
    CStdSentEnum::DoctorDriveAbbreviation,
    CStdSentEnum::AbbreviationFollowedByDigit,
    CStdSentEnum::DegreeAbbreviation,
    CStdSentEnum::AbbreviationModifier,
};

const PronDisambigFunc g_AmbiguousWordDisambigTable[] =
{
    CStdSentEnum::SingleOrPluralAbbreviation,
    CStdSentEnum::DoctorDriveAbbreviation,
    CStdSentEnum::AbbreviationFollowedByDigit,
    CStdSentEnum::AllCapsAbbreviation,
    CStdSentEnum::CapitalizedAbbreviation,
    CStdSentEnum::SECAbbreviation,
    CStdSentEnum::DegreeAbbreviation,
	CStdSentEnum::AbbreviationModifier,
    CStdSentEnum::ADisambig,
    CStdSentEnum::PolishDisambig,
};

const PostLexLookupDisambigFunc g_PostLexLookupDisambigTable[] =
{
    CStdSentEnum::MeasurementDisambig,
    CStdSentEnum::TheDisambig,
    CStdSentEnum::ReadDisambig,
};

//--- IMPORTANT!!! This list must remain alphabetized for the binary search algorithm to work properly!!!
// This is an alphabetized list of all non-proper-noun words which
// appear within the list of the 200 most frequent first words
// in sentences in both the Brown and WSJ corpora.
const SPLSTR g_FirstWords[] =
{
DEF_SPLSTR( "A" ),
DEF_SPLSTR( "About" ),
DEF_SPLSTR( "According" ),
DEF_SPLSTR( "After" ),
DEF_SPLSTR( "Again" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "All" ),
DEF_SPLSTR( "Also" ),
DEF_SPLSTR( "Although" ),
DEF_SPLSTR( "Among" ),
DEF_SPLSTR( "An" ),
DEF_SPLSTR( "And" ),
DEF_SPLSTR( "Another" ),
DEF_SPLSTR( "Any" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Anyway" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Are" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "As" ),
DEF_SPLSTR( "At" ),
DEF_SPLSTR( "Back" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Because" ),
DEF_SPLSTR( "Before" ),
DEF_SPLSTR( "Besides" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Both" ),
DEF_SPLSTR( "But" ),
DEF_SPLSTR( "By" ),
DEF_SPLSTR( "Can" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Consequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Dear" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Despite" ),
DEF_SPLSTR( "Did" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Do" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Does" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Don't" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "During" ),
DEF_SPLSTR( "Each" ),
DEF_SPLSTR( "Early" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Even" ),
DEF_SPLSTR( "Every" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Finally" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "First" ),
DEF_SPLSTR( "Following" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "For" ),
DEF_SPLSTR( "Four" ),
DEF_SPLSTR( "From" ),
DEF_SPLSTR( "Further" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Furthermore" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Generally" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Given" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Go" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Great" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Had" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Have" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Having" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "He" ),
DEF_SPLSTR( "Her" ),
DEF_SPLSTR( "Here" ),
DEF_SPLSTR( "His" ),
DEF_SPLSTR( "How" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "However" ),
DEF_SPLSTR( "I" ),
DEF_SPLSTR( "If" ),
DEF_SPLSTR( "In" ),
DEF_SPLSTR( "Indeed" ),
DEF_SPLSTR( "Initially" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Instead" ),
DEF_SPLSTR( "Is" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "It" ),
DEF_SPLSTR( "Its" ),
DEF_SPLSTR( "Just" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Last" ),
DEF_SPLSTR( "Later" ),
DEF_SPLSTR( "Let" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Like" ),
DEF_SPLSTR( "Many" ),
DEF_SPLSTR( "Maybe" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Meanwhile" ),
DEF_SPLSTR( "More" ),
DEF_SPLSTR( "Moreover" ),
DEF_SPLSTR( "Most" ),
DEF_SPLSTR( "Much" ),
DEF_SPLSTR( "My" ),    // Added to fix bug #385
DEF_SPLSTR( "Neither" ),
DEF_SPLSTR( "Never" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nevertheless" ),
DEF_SPLSTR( "New" ),
DEF_SPLSTR( "Next" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "No" ),
DEF_SPLSTR( "None" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nonetheless" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nor" ),
DEF_SPLSTR( "Not" ),
DEF_SPLSTR( "Nothing" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Now" ),
DEF_SPLSTR( "Of" ),
DEF_SPLSTR( "On" ),
DEF_SPLSTR( "Once" ),
DEF_SPLSTR( "One" ),
DEF_SPLSTR( "Only" ),
DEF_SPLSTR( "Or" ),
DEF_SPLSTR( "Other" ),
DEF_SPLSTR( "Others" ),
DEF_SPLSTR( "Our" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Over" ),
DEF_SPLSTR( "People" ),
DEF_SPLSTR( "Perhaps" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Please" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Previous" ),                             // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Recent" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Right" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Second" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "See" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Several" ),
DEF_SPLSTR( "She" ),
DEF_SPLSTR( "Shortly" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Similarly" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Since" ),
DEF_SPLSTR( "So" ),
DEF_SPLSTR( "Some" ),
DEF_SPLSTR( "Sometimes" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Soon" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Still" ),
DEF_SPLSTR( "Subsequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Such" ),
DEF_SPLSTR( "Take" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "That" ),
DEF_SPLSTR( "The" ),
DEF_SPLSTR( "Their" ),
DEF_SPLSTR( "Then" ),
DEF_SPLSTR( "There" ),
DEF_SPLSTR( "Thereafter" ),                           // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Therefore" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "These" ),
DEF_SPLSTR( "They" ),
DEF_SPLSTR( "This" ),
DEF_SPLSTR( "Those" ),
DEF_SPLSTR( "Though" ),
DEF_SPLSTR( "Three" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Through" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Thus" ),
DEF_SPLSTR( "To" ),
DEF_SPLSTR( "Today" ),
DEF_SPLSTR( "Two" ),
DEF_SPLSTR( "Under" ),
DEF_SPLSTR( "Unlike" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Until" ),
DEF_SPLSTR( "Upon" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "We" ),
DEF_SPLSTR( "Well" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "What" ),
DEF_SPLSTR( "When" ),
DEF_SPLSTR( "Where" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Whether" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Which" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "While" ),
DEF_SPLSTR( "Who" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Why" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Will" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "With" ),
DEF_SPLSTR( "Within" ),
DEF_SPLSTR( "Without" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yes" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yet" ),
DEF_SPLSTR( "You" ),
DEF_SPLSTR( "Your" ),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\normdata.h ===
/******************************************************************************
* NormData.h *
*------------*
*   This file contains lists of data used in the normalization process.
*------------------------------------------------------------------------------
*   Copyright (C) 1999 Microsoft Corporation         Date: 08/11/99
*   All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef NormData_h
#define NormData_h

//  Abbrev.txt -- list of common abbreviations.  Words following the
//  abbreviations in this list will not start a sentence unless they are in
//  the list of common first words (frstwrds.txt)
//  The code handles all abbreviations containing single upper-case characters
//  followed by a period, such as A.A. and B.F.A., so they don't need to be
//  in the list.
//  Some abbreviations are confusable with actual words.  Where this may occur
//  regularly (with no., for example) a special case may need to be added in
//  the sentence separator code.
static const SPLSTR g_CommonAbbrev[] =
{
// L"A.A." ),
// L"A.A.S." ),
// L"A.B." ),
// L"A.B.A." ),
// L"A.C.T." ),
// L"A.D." ),
// L"A.F." ),         // "A.F. of L." ),
// L"A.G." ),
// L"A.H." ),
// L"A.M." ),
// L"A.P." ),
// L"A.R." ),
// L"A.S." ),
// L"A.S.P.C.A." ),
// L"A.S.S.R." ),
// L"A.U." ),
// L"A.U.C." ),
// L"A.h." ),
DEF_SPLSTR( "Adj." ),
DEF_SPLSTR( "Adjt." ),
DEF_SPLSTR( "Afg." ),
DEF_SPLSTR( "Afr." ),
DEF_SPLSTR( "Ala." ),
DEF_SPLSTR( "Alas." ),
DEF_SPLSTR( "Alb." ),
DEF_SPLSTR( "Ald." ),
DEF_SPLSTR( "Alg." ),
DEF_SPLSTR( "Alta." ),
DEF_SPLSTR( "Am." ),
DEF_SPLSTR( "Amer." ),
DEF_SPLSTR( "And." ),         // Andorra
DEF_SPLSTR( "Ang." ),
DEF_SPLSTR( "Angl." ),
DEF_SPLSTR( "Ant." ),
DEF_SPLSTR( "Apoc." ),
DEF_SPLSTR( "Apr." ),
DEF_SPLSTR( "Ar." ),
DEF_SPLSTR( "Arch." ),
DEF_SPLSTR( "Archbp." ),
DEF_SPLSTR( "Arg." ),
DEF_SPLSTR( "Ariz." ),
DEF_SPLSTR( "Ark." ),
DEF_SPLSTR( "Arm." ),
DEF_SPLSTR( "As." ),
DEF_SPLSTR( "Atl." ),
DEF_SPLSTR( "Att." ),
// "Att. Gen." ),
// "Atty." ),         // already in titles.txt
// "Atty. Gen." ),
DEF_SPLSTR( "Aug." ),
DEF_SPLSTR( "Aus." ),
DEF_SPLSTR( "Aust." ),
DEF_SPLSTR( "Austl." ),
DEF_SPLSTR( "Av." ),
DEF_SPLSTR( "Ave." ),                                 // PaulCa 4/15/99 (Bug 108)
// "B.A." ),
// "B.A.E." ),
DEF_SPLSTR( "B.A.Ed." ),
// "B.A.M." ),
// "B.A.S." ),
DEF_SPLSTR( "B.A.Sc." ),
// "B.A.T." ),
DEF_SPLSTR( "B.Ae.E." ),
DEF_SPLSTR( "B.Arch." ),
// "B.B.A." ),
// "B.C." ),
// "B.C.B.G." ),
// "B.C.E." ),
// "B.C.L." ),
DEF_SPLSTR( "B.Ch.E." ),
// "B.D." ),
// "B.D.S." ),
// "B.E." ),
DEF_SPLSTR( "B.Ed." ),
DEF_SPLSTR( "B.Eng." ),
DEF_SPLSTR( "B.Eng.Sci." ),
DEF_SPLSTR( "B.Engr." ),
// "B.F.A." ),
// "B.J." ),
// "B.L." ),
// "B.L.A." ),
// "B.L.S." ),
DEF_SPLSTR( "B.Lit." ),
DEF_SPLSTR( "B.Litt." ),
// "B.M." ),
// "B.M.E." ),
// "B.M.S." ),
DEF_SPLSTR( "B.Mus." ),
// "B.O.D." ),
// "B.P." ),
// "B.P.E." ),
DEF_SPLSTR( "B.Pd." ),
DEF_SPLSTR( "B.Ph." ),
DEF_SPLSTR( "B.Phil." ),
DEF_SPLSTR( "B.R.E." ),
// "B.S." ),
// "B.S.A." ),
// "B.S.A.A." ),
DEF_SPLSTR( "B.S.Arch." ),
DEF_SPLSTR( "B.S.Ch." ),
// "B.S.E.E." ),
DEF_SPLSTR( "B.S.Ec." ),
DEF_SPLSTR( "B.S.Ed." ),
// "B.S.F.S." ),
DEF_SPLSTR( "B.S.For." ),
// "B.S.N." ),
DEF_SPLSTR( "B.Sc." ),
// "B.T." ),
DEF_SPLSTR( "B.Th." ),
// "B.V.D." ),
// "B.V.M." ),
// "B.W.I." ),
DEF_SPLSTR( "Bab." ),
DEF_SPLSTR( "Bap." ),
DEF_SPLSTR( "Bapt." ),
DEF_SPLSTR( "Belg." ),
DEF_SPLSTR( "Benj." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Bhn." ),
DEF_SPLSTR( "Bhu." ),
DEF_SPLSTR( "Bib." ),
DEF_SPLSTR( "Bibl." ),
// "Bn." ),       // already in titles.txt
DEF_SPLSTR( "Bol." ),
DEF_SPLSTR( "Br." ),
DEF_SPLSTR( "Braz." ),
DEF_SPLSTR( "Brig." ),
DEF_SPLSTR( "Brit." ),
// "Bt." ),       // already in titles.txt
// "Btss." ),     // already in titles.txt
DEF_SPLSTR( "Bulg." ),
DEF_SPLSTR( "Bur." ),
// "C. of C." ),
// "C. of E." ),
// "C. of S." ),
// "C.A." ),
// "C.A.F." ),
// "C.A.G.S." ),
// "C.B.D." ),
// "C.C.A." ),
// "C.D." ),
// "C.E." ),
// "C.G." ),      // already in titles.txt
// "C.J." ),
// "C.L." ),
// "C.O." ),
// "C.P." ),
// "C.R." ),
// "C.S.A." ),
// "C.S.T." ),
// "C.V." ),
// "C.Z." ),
DEF_SPLSTR( "Calif." ),
DEF_SPLSTR( "Can." ),
DEF_SPLSTR( "Cant." ),
// "Capt." ),     // already in titles.txt
DEF_SPLSTR( "Card." ),
// "Cdr." ),      // already in titles.txt
DEF_SPLSTR( "Ch." ),
DEF_SPLSTR( "Ch.E." ),
DEF_SPLSTR( "Chas." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Chmn." ),
DEF_SPLSTR( "Chr." ),
DEF_SPLSTR( "Chron." ),
DEF_SPLSTR( "Cmd." ),
DEF_SPLSTR( "Cmdr." ),
DEF_SPLSTR( "Co." ),
// "Col." ),      // already in titles.txt
DEF_SPLSTR( "Colo." ),
// "Com." ),      // already in titles.txt
// "Comdr." ),    // already in titles.txt
DEF_SPLSTR( "Comdt." ),
DEF_SPLSTR( "Comm." ),
DEF_SPLSTR( "Comr." ),
DEF_SPLSTR( "Con." ),
DEF_SPLSTR( "Cong." ),
DEF_SPLSTR( "Conn." ),
DEF_SPLSTR( "Cons." ),
DEF_SPLSTR( "Const." ),
DEF_SPLSTR( "Conv." ),
DEF_SPLSTR( "Cop." ),
DEF_SPLSTR( "Copt." ),
DEF_SPLSTR( "Cor." ),
// "Cpl." ),      // already in titles.txt
// "Cpt." ),      // already in titles.txt
// "Ct." ),       // already in titles.txt
// "D.A." ),
// "D.B.A." ),
// "D.B.E." ),
DEF_SPLSTR( "D.Bib." ),
// "D.C." ),
// "D.C.L." ),
// "D.D." ),
// "D.D.S." ),
DEF_SPLSTR( "D.Ed." ),
// "D.F." ),      // already in titles.txt
// "D.F.A." ),
// "D.H." ),
// "D.H.L." ),
// "D.J." ),
// "D.L.S." ),
DEF_SPLSTR( "D.Lit." ),
DEF_SPLSTR( "D.Litt." ),                              // PaulCa 4/15/99 (Bug 108)
// "D.M.A." ),
// "D.M.D." ),
// "D.M.L." ),
// "D.O." ),
// "D.O.M." ),
// "D.P." ),
DEF_SPLSTR( "D.Ph." ),
DEF_SPLSTR( "D.Phil." ),
// "D.S." ),
DEF_SPLSTR( "D.Sc." ),                                // PaulCa 4/15/99 (Bug 108)
// "D.T." ),
// "D.V." ),
// "D.V.M." ),
DEF_SPLSTR( "Da." ),
DEF_SPLSTR( "Danl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Dec." ),
DEF_SPLSTR( "Del." ),
DEF_SPLSTR( "Dem." ),
DEF_SPLSTR( "Den." ),
DEF_SPLSTR( "Deut." ),
DEF_SPLSTR( "Dist." ),        // "Dist. Atty." ),
DEF_SPLSTR( "Div." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Divs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Dom." ),
DEF_SPLSTR( "Dor." ),
// "Dr." ),       // already in titles.txt
// "Drs." ),      // already in titles.txt
DEF_SPLSTR( "Dt." ),
// "Du." ),       // already in titles.txt
// "E.D." ),
// "E.E." ),
// "E.M." ),
// "E.Q." ),
// "E.T." ),
DEF_SPLSTR( "Ec." ),
DEF_SPLSTR( "Eccles." ),
DEF_SPLSTR( "Ecua." ),
DEF_SPLSTR( "Ed.M." ),
DEF_SPLSTR( "Edw." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Eng." ),
DEF_SPLSTR( "Engl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Ens." ),
DEF_SPLSTR( "Ep." ),
DEF_SPLSTR( "Eph." ),
DEF_SPLSTR( "Epis." ),
DEF_SPLSTR( "Episc." ),
DEF_SPLSTR( "Epist." ),
DEF_SPLSTR( "Esk." ),
// "Esq." ),      // already in titles.txt
DEF_SPLSTR( "Est." ),
DEF_SPLSTR( "Esth." ),
DEF_SPLSTR( "Eth." ),
DEF_SPLSTR( "Eur." ),
DEF_SPLSTR( "Ex." ),
// "Exc." ),      // already in titles.txt
DEF_SPLSTR( "Exch." ),
DEF_SPLSTR( "Exod." ),
DEF_SPLSTR( "Ezek." ),
// "F.A." ),
// "F.B." ),
// "F.D." ),
// "F.E.T." ),
// "F.F.A." ),
// "F.M." ),
// "F.O." ),
// "F.R.G." ),
DEF_SPLSTR( "Far." ),
DEF_SPLSTR( "Feb." ),
DEF_SPLSTR( "Fin." ),
DEF_SPLSTR( "Fla." ),
DEF_SPLSTR( "Flem." ),
// "Fr." ),       // already in titles.txt
DEF_SPLSTR( "Fri." ),
DEF_SPLSTR( "Fris." ),
// "Frl." ),      // already in titles.txt
DEF_SPLSTR( "Frs." ),
DEF_SPLSTR( "Ft." ),
// "G.A." ),
// "G.B." ),
// "G.C.B." ),
// "G.D." ),
// "G.D.R." ),
// "G.I." ),
// "G.M." ),
// "G.P." ),
// "G.T.C." ),
// "G.m.a.t." ),
DEF_SPLSTR( "Ga." ),
DEF_SPLSTR( "Gal." ),
// "Gen." ),      // already in titles.txt
DEF_SPLSTR( "Geo." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Ger." ),
DEF_SPLSTR( "Gib." ),
DEF_SPLSTR( "Gk." ),
DEF_SPLSTR( "Gn." ),
DEF_SPLSTR( "Goth." ),
// "Gov." ),      // already in titles.txt
DEF_SPLSTR( "Gr." ),
// "Gr. Brit." ),
DEF_SPLSTR( "Gt." ),          // "Gt. Brit."
DEF_SPLSTR( "Guat." ),
DEF_SPLSTR( "Guin." ),
// "H. Rept." ),
// "H. Res." ),
// "H.C." ),
// "H.C.F." ),
// "H.E." ),       // already in titles.txt
// "H.H." ),       // already in titles.txt
// "H.I." ),
// "H.I.H." ),    // already in titles.txt
// "H.I.M." ),    // already in titles.txt
// "H.L." ),
// "H.M." ),      // already in titles.txt
// "H.R." ),
// "H.R.E." ),
// "H.R.H." ),    // already in titles.txt
// "H.S.H." ),    // already in titles.txt
// "H.S.T." ),
// "H.V." ),
DEF_SPLSTR( "HH.D." ),
DEF_SPLSTR( "Hab." ),
DEF_SPLSTR( "Hag." ),
DEF_SPLSTR( "Heb." ),
DEF_SPLSTR( "Hebr." ),
DEF_SPLSTR( "Hind." ),
DEF_SPLSTR( "Hitt." ),
// "Hon." ),      // already in titles.txt
DEF_SPLSTR( "Hond." ),
DEF_SPLSTR( "Hos." ),
// "Hr." ),       // already in titles.txt
DEF_SPLSTR( "Hts." ),
DEF_SPLSTR( "Hung." ),
// "I.D." ),
// "I.N.R.I." ),
// "I.P.A." ),
// "I.R.A." ),
DEF_SPLSTR( "Ia." ),
DEF_SPLSTR( "Ice." ),
DEF_SPLSTR( "Icel." ),
DEF_SPLSTR( "Id." ),
DEF_SPLSTR( "Ill." ),
DEF_SPLSTR( "Ind." ),
DEF_SPLSTR( "Inf." ),
DEF_SPLSTR( "Inst." ),
DEF_SPLSTR( "Ion." ),
DEF_SPLSTR( "Ir." ),
DEF_SPLSTR( "Ire." ),
DEF_SPLSTR( "Is." ),
DEF_SPLSTR( "Isl." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Isr." ),
DEF_SPLSTR( "It." ),
DEF_SPLSTR( "Ital." ),
// "J.A." ),
// "J.A.G." ),
// "J.C.D." ),
// "J.C.S." ),
// "J.D." ),
// "J.P." ),
// "J.S.D." ),
DEF_SPLSTR( "Jam." ),
DEF_SPLSTR( "Jan." ),
DEF_SPLSTR( "Jas." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Jav." ),
DEF_SPLSTR( "Jb." ),
DEF_SPLSTR( "Jdt." ),
DEF_SPLSTR( "Jer." ),
DEF_SPLSTR( "Jg." ),
DEF_SPLSTR( "Jl." ),
DEF_SPLSTR( "Jm." ),
DEF_SPLSTR( "Jn." ),
DEF_SPLSTR( "Jos." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Jr." ),
DEF_SPLSTR( "Judg." ),
DEF_SPLSTR( "Jul." ),
DEF_SPLSTR( "Jun." ),
// "K.C." ),
// "K.G." ),
// "K.G.B." ),
DEF_SPLSTR( "Kan." ),
DEF_SPLSTR( "Kans." ),
DEF_SPLSTR( "Knt." ),
DEF_SPLSTR( "Kor." ),
DEF_SPLSTR( "Ky." ),
// "L.A." ),
// "L.C." ),
// "L.Cpl." ),    // already in titles.txt
// "L.I." ),
// "L.S." ),
DEF_SPLSTR( "LL.B." ),
DEF_SPLSTR( "LL.D." ),
DEF_SPLSTR( "LL.M." ),
DEF_SPLSTR( "La." ),
DEF_SPLSTR( "Lab." ),
DEF_SPLSTR( "Lam." ),
DEF_SPLSTR( "Lat." ),
// "Ld." ),       // already in titles.txt
DEF_SPLSTR( "Leb." ),
DEF_SPLSTR( "Lev." ),
DEF_SPLSTR( "Levit." ),
DEF_SPLSTR( "Lib." ),
DEF_SPLSTR( "Liech." ),
DEF_SPLSTR( "Lit.B." ),
DEF_SPLSTR( "Lit.D." ),
DEF_SPLSTR( "Lith." ),
DEF_SPLSTR( "Litt.B." ),
DEF_SPLSTR( "Litt.D." ),
// "Lt." ),       // already in titles.txt
// "Lt. Col." ),
// "Lt. Comdr." ),
// "Lt. Gen." ),
// "Lt. Gov." ),
DEF_SPLSTR( "Ltd." ),
DEF_SPLSTR( "Lux." ),
// "M. o. T." ),
// "M.A." ),
// "M.A.B.E." ),
// "M.A.E." ),
DEF_SPLSTR( "M.A.Ed." ),
// "M.A.L.S." ),
// "M.A.T." ),
DEF_SPLSTR( "M.Agr." ),
// "M.B.A." ),
// "M.C." ),
// "M.C.L." ),
// "M.D." ),
// "M.D.S." ),
DEF_SPLSTR( "M.Div." ),
// "M.E." ),
DEF_SPLSTR( "M.Ed." ),
// "M.F.A." ),
// "M.F.H." ),
// "M.H.L." ),
// "M.L.S." ),
// "M.M." ),      // already in titles.txt
// "M.P.A." ),
// "M.P.E." ),
// "M.R.E." ),
// "M.S." ),
// "M.S. in L.S." ),
// "M.S.N." ),
// "M.S.T." ),
// "M.S.T.S." ),
// "M.S.W." ),
DEF_SPLSTR( "M.Sc." ),
// "M.Sgt." ),    // already in titles.txt
// "M.T." ),
DEF_SPLSTR( "MM." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "MS." ),
DEF_SPLSTR( "MSS." ),
DEF_SPLSTR( "Macc." ),
DEF_SPLSTR( "Maced." ),
DEF_SPLSTR( "Mad." ),
DEF_SPLSTR( "Madag." ),
// "Maj." ),      // already in titles.txt
// "Maj. Gen." ),
DEF_SPLSTR( "Mal." ),
DEF_SPLSTR( "Man." ),
DEF_SPLSTR( "Mar." ),
DEF_SPLSTR( "Mart." ),
DEF_SPLSTR( "Mass." ),
DEF_SPLSTR( "Md." ),
// "Mdm." ),      // already in titles.txt
DEF_SPLSTR( "Me." ),
// "Med. Gr." ),
// "Med. Lat." ),
DEF_SPLSTR( "Medit." ),
// "Messrs." ),   // already in titles.txt
DEF_SPLSTR( "Mex." ),
// "Mgr." ),      // already in titles.txt
DEF_SPLSTR( "Mich." ),
DEF_SPLSTR( "Midn." ),
DEF_SPLSTR( "Minn." ),
DEF_SPLSTR( "Miss." ),
// "Mlle." ),     // already in titles.txt
// "Mlles." ),    // already in titles.txt
// "Mme." ),      // already in titles.txt
// "Mmes." ),     // already in titles.txt
DEF_SPLSTR( "Mo." ),
DEF_SPLSTR( "Mon." ),
DEF_SPLSTR( "Mont." ),
DEF_SPLSTR( "Mor." ),
DEF_SPLSTR( "Moz." ),
// "Mr." ),       // already in titles.txt
// "Mrs." ),      // already in titles.txt
// "Ms." ),       // already in titles.txt
DEF_SPLSTR( "Mses." ),
// "Msgr." ),     // already in titles.txt
DEF_SPLSTR( "Mss." ),
DEF_SPLSTR( "Mt." ),
DEF_SPLSTR( "Mtn." ),
DEF_SPLSTR( "Mts." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Mus.B." ),
DEF_SPLSTR( "Mus.D." ),
DEF_SPLSTR( "Mus.Dr." ),
DEF_SPLSTR( "Mus.M." ),
// "N.A." ),
// "N.B." ),
// "N.C." ),
// "N.D." ),
DEF_SPLSTR( "N.Dak." ),
// "N.E." ),
// "N.E.P." ),
// "N.F." ),
// "N.H." ),
DEF_SPLSTR( "N.Ire." ),
// "N.J." ),
// "N.M." ),
DEF_SPLSTR( "N.Mex." ),
// "N.P." ),
// "N.S." ),
// "N.S.P.C.A." ),
// "N.T." ),
// "N.W.T." ),
// "N.Y." ),
// "N.Y.C." ),
// "N.Z." ),
DEF_SPLSTR( "Na." ),
DEF_SPLSTR( "Nb." ),
DEF_SPLSTR( "Ne." ),
DEF_SPLSTR( "Neb." ),
DEF_SPLSTR( "Nebr." ),
DEF_SPLSTR( "Neh." ),
DEF_SPLSTR( "Nep." ),
DEF_SPLSTR( "Neth." ),
DEF_SPLSTR( "Nev." ),
// "New Test." ),
DEF_SPLSTR( "Newf." ),
DEF_SPLSTR( "Nfld." ),
DEF_SPLSTR( "Nic." ),
DEF_SPLSTR( "Nig." ),
DEF_SPLSTR( "Nor." ),
DEF_SPLSTR( "Norw." ),
DEF_SPLSTR( "Nos." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Nov." ),
DEF_SPLSTR( "Num." ),
// "O.B.E." ),
// "O.C." ),
// "O.D." ),
// "O.F.M." ),
// "O.K." ),
// "O.M." ),
// "O.N." ),
// "O.O.D." ),
// "O.P." ),
// "O.R." ),
// "O.S." ),
// "O.T." ),
DEF_SPLSTR( "OM." ),
DEF_SPLSTR( "Ob." ),
DEF_SPLSTR( "Obad." ),
DEF_SPLSTR( "Obs." ),
DEF_SPLSTR( "Oc." ),
DEF_SPLSTR( "Oct." ),
DEF_SPLSTR( "Okla." ),
DEF_SPLSTR( "Ont." ),
DEF_SPLSTR( "Op." ),
DEF_SPLSTR( "Ore." ),
DEF_SPLSTR( "Oxon." ),                                // PaulCa 4/15/99 (Bug 108)
// "P. S." ),
// "P.A." ),
// "P.B." ),
// "P.C." ),
// "P.D." ),
// "P.E." ),
// "P.E.I." ),
// "P.G." ),
// "P.M." ),
// "P.M.G." ),
// "P.P.S." ),
// "P.Q." ),
// "P.R." ),
// "P.S." ),
// "P.T." ),
// "P.W.A." ),
// "PFC." ),      // already in titles.txt
DEF_SPLSTR( "PP." ),
DEF_SPLSTR( "Pa." ),
DEF_SPLSTR( "Pac." ),
DEF_SPLSTR( "Pacif." ),
DEF_SPLSTR( "Pak." ),
DEF_SPLSTR( "Pal." ),
DEF_SPLSTR( "Par." ),
DEF_SPLSTR( "Parl." ),
DEF_SPLSTR( "Pd.B." ),
DEF_SPLSTR( "Pd.D." ),
DEF_SPLSTR( "Pd.M." ),
DEF_SPLSTR( "Penn." ),
DEF_SPLSTR( "Penna." ),
DEF_SPLSTR( "Pers." ),
DEF_SPLSTR( "Pet." ),
DEF_SPLSTR( "Pg." ),
DEF_SPLSTR( "Ph.B." ),
DEF_SPLSTR( "Ph.C." ),
DEF_SPLSTR( "Ph.D." ),
DEF_SPLSTR( "Ph.G." ),
DEF_SPLSTR( "Ph.M." ),
DEF_SPLSTR( "Phar.B." ),
DEF_SPLSTR( "Phar.D." ),
DEF_SPLSTR( "Phar.M." ),
DEF_SPLSTR( "Phil." ),
// "Phil. I." ),
// "Phil. Is." ),
DEF_SPLSTR( "Philem." ),
DEF_SPLSTR( "Pl." ),
DEF_SPLSTR( "Pol." ),
// "Pr." ),       // already in titles.txt
// "Pres." ),     // already in titles.txt
DEF_SPLSTR( "Presb." ),
DEF_SPLSTR( "Presby." ),
// "Prof." ),     // already in titles.txt
// "Profs." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Pros." ),        // "Pros. Atty."
DEF_SPLSTR( "Prot." ),
DEF_SPLSTR( "Prov." ),
DEF_SPLSTR( "Pvt." ),
// "Q. C." ),
// "Q.B." ),
// "Q.C." ),
// "Q.E.D." ),
// "Q.E.F." ),
// "Q.M." ),
DEF_SPLSTR( "Que." ),
// "R. A. F." ),
// "R. C." ),
// "R.A." ),      // already in titles.txt
// "R.A.M." ),
DEF_SPLSTR( "R.C.Ch." ),
// "R.C.P." ),
// "R.C.S." ),
// "R.E." ),
// "R.I." ),
// "R.I.P." ),
// "R.M.S." ),
// "R.P." ),
// "R.Q." ),
// "R.R." ),      // already in titles.txt
// "R.S." ),
// "R.S.F.S.R." ),
// "R.S.V.P." ),
// "R.V." ),
// "R.W." ),      // already in titles.txt
DEF_SPLSTR( "Ra." ),
DEF_SPLSTR( "Rd." ),
DEF_SPLSTR( "Re." ),
// "Rep." ),      // already in titles.txt
DEF_SPLSTR( "Rept." ),
DEF_SPLSTR( "Repub." ),
DEF_SPLSTR( "Res." ),
// "Rev." ),      // already in titles.txt
// "Rev. Ver." ),
DEF_SPLSTR( "Rm." ),
DEF_SPLSTR( "Rom." ),
DEF_SPLSTR( "Rt." ),
// "Rt. Hon." ),
// "Rt. Rev." ),
DEF_SPLSTR( "Rus." ),
DEF_SPLSTR( "Rv." ),
// "S. of Sol." ),
// "S.A." ),
DEF_SPLSTR( "S.Afr." ),
// "S.B." ),
// "S.C." ),
// "S.D." ),
DEF_SPLSTR( "S.Dak." ),
// "S.F.S.R." ),
// "S.G." ),
// "S.J." ),
// "S.J.D." ),
// "S.M." ),
// "S.M.Sgt." ),  // already in titles.txt
// "S.P.Q.R." ),
// "S.S." ),
// "S.S.R." ),
// "S.Sgt." ),    // already in titles.txt
DEF_SPLSTR( "Sab." ),
DEF_SPLSTR( "Sask." ),
DEF_SPLSTR( "Sat." ),
DEF_SPLSTR( "Sax." ),
DEF_SPLSTR( "Sc." ),
DEF_SPLSTR( "Sc.B." ),
DEF_SPLSTR( "Sc.D." ),
DEF_SPLSTR( "Scand." ),
DEF_SPLSTR( "Schil." ),       // Added 1/12/2000 by AaronHal to match currency abbreviations
DEF_SPLSTR( "Script." ),
DEF_SPLSTR( "Sec." ),
DEF_SPLSTR( "Sem." ),
// "Sen." ),      // already in titles.txt
DEF_SPLSTR( "Sept." ),
// "Sgt." ),      // already in titles.txt
// "Sgt.Maj." ),  // already in titles.txt
DEF_SPLSTR( "Sib." ),
DEF_SPLSTR( "Sic." ),
DEF_SPLSTR( "Sig." ),
DEF_SPLSTR( "Skr." ),
DEF_SPLSTR( "Skt." ),
DEF_SPLSTR( "Slav." ),
// "So." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Soc." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Sol." ),
DEF_SPLSTR( "Som." ),
DEF_SPLSTR( "Sp." ),
DEF_SPLSTR( "Span." ),
// "Sr." ),   // already in titles.txt
// "Sra." ),  // already in titles.txt
// "Srta." ), // already in titles.txt
// "St." ),   // already in titles.txt
// "St. Ex." ),
DEF_SPLSTR( "Ste." ),
DEF_SPLSTR( "Str." ),
DEF_SPLSTR( "Suff." ),
DEF_SPLSTR( "Sun." ),
DEF_SPLSTR( "Sup.Ct." ),
DEF_SPLSTR( "Sw." ),
DEF_SPLSTR( "Swaz." ),
DEF_SPLSTR( "Swe." ),
DEF_SPLSTR( "Swed." ),
DEF_SPLSTR( "Switz." ),
DEF_SPLSTR( "Syr." ),
// "T.B." ),
// "T.D." ),
// "T.F." ),
// "T.M." ),
// "T.S." ),
// "T.Sgt." ),// already in titles.txt
// "T.U." ),
DEF_SPLSTR( "Tanz." ),
DEF_SPLSTR( "Tas." ),
DEF_SPLSTR( "Tenn." ),
//"Test." ), Removed by AaronHal 2/4/2000 (Raid#2154)
DEF_SPLSTR( "Teut." ),
DEF_SPLSTR( "Tex." ),
DEF_SPLSTR( "Th." ),
DEF_SPLSTR( "Th.B." ),
DEF_SPLSTR( "Th.D." ),
DEF_SPLSTR( "Th.M." ),
DEF_SPLSTR( "Theo." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Thos." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Thur." ),
DEF_SPLSTR( "Thurs." ),
DEF_SPLSTR( "Tit." ),
DEF_SPLSTR( "Tu." ),
DEF_SPLSTR( "Tues." ),
DEF_SPLSTR( "Tun." ),
DEF_SPLSTR( "Tur." ),
// "U.A.E." ),
// "U.A.R." ),
// "U.K." ),
// "U.N." ),
// "U.S." ),
// "U.S.A." ),
// "U.S.C." ),
// "U.S.C.A." ),
// "U.S.M." ),
// "U.S.P." ),
// "U.S.S." ),
// "U.S.S.R." ),
DEF_SPLSTR( "Uni." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Univ." ),
DEF_SPLSTR( "Urug." ),
DEF_SPLSTR( "Ut." ),
// "V.A." ),  // already in titles.txt
// "V.Adm." ),// already in titles.txt
// "V.C." ),
// "V.F." ),
// "V.G." ),
// "V.I." ),
// "V.M.D." ),
// "V.P." ),
// "V.S." ),
DEF_SPLSTR( "Va." ),
DEF_SPLSTR( "Vat." ),
// "Ven." ),  // already in titles.txt
DEF_SPLSTR( "Venez." ),
DEF_SPLSTR( "Ver." ),
DEF_SPLSTR( "Viet." ),
// "Vis." ),  // already in titles.txt
// "Visct." ),// already in titles.txt
DEF_SPLSTR( "Vt." ),
DEF_SPLSTR( "Vul." ),
DEF_SPLSTR( "Vulg." ),
// "W.B." ),
// "W.C." ),
// "W.I." ),
DEF_SPLSTR( "W.Va." ),
// "W.W.I" ),                             // PaulCa 4/15/99 (Bug 108)
// "W.W.II" ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Wash." ),
DEF_SPLSTR( "Wed." ),
DEF_SPLSTR( "Wis." ),
DEF_SPLSTR( "Wm." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "Wyo." ),
// "Y.T." ),
DEF_SPLSTR( "Yug." ),
DEF_SPLSTR( "Yugo." ),
DEF_SPLSTR( "a.b." ),
DEF_SPLSTR( "a.c." ),
DEF_SPLSTR( "a.d." ),
DEF_SPLSTR( "a.d.c." ),
DEF_SPLSTR( "a.i." ),
DEF_SPLSTR( "a.k.a." ),
DEF_SPLSTR( "a.l.s." ),
DEF_SPLSTR( "a.m." ),
DEF_SPLSTR( "a.p." ),
DEF_SPLSTR( "a.s.a.p." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "a.u." ),
DEF_SPLSTR( "a.v." ),
DEF_SPLSTR( "a.w." ),
DEF_SPLSTR( "ab." ),
DEF_SPLSTR( "abb." ),
DEF_SPLSTR( "abbr." ),
DEF_SPLSTR( "abbrs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "abl." ),
DEF_SPLSTR( "abp." ),
DEF_SPLSTR( "abr." ),
DEF_SPLSTR( "abs." ),
DEF_SPLSTR( "abt." ),
DEF_SPLSTR( "ac." ),
DEF_SPLSTR( "acad." ),
DEF_SPLSTR( "acc." ),
DEF_SPLSTR( "acct." ),
DEF_SPLSTR( "accts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "acet." ),
DEF_SPLSTR( "ack." ),
DEF_SPLSTR( "acpt." ),
DEF_SPLSTR( "actg." ),
DEF_SPLSTR( "ad loc." ),
DEF_SPLSTR( "addl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "addn." ),
DEF_SPLSTR( "addnl." ),
DEF_SPLSTR( "adj." ),
DEF_SPLSTR( "adjs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "adjt." ),
DEF_SPLSTR( "adm." ),
// "admin." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "adv." ),
DEF_SPLSTR( "advs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "advt." ),
DEF_SPLSTR( "agcy." ),
DEF_SPLSTR( "agri." ),
DEF_SPLSTR( "agric." ),
DEF_SPLSTR( "agt." ),
DEF_SPLSTR( "al." ),
DEF_SPLSTR( "alc." ),
DEF_SPLSTR( "alg." ),
DEF_SPLSTR( "alky." ),
DEF_SPLSTR( "alt." ),
DEF_SPLSTR( "amt." ),
DEF_SPLSTR( "amts." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "an." ),
DEF_SPLSTR( "anat." ),
DEF_SPLSTR( "anc." ),
DEF_SPLSTR( "and." ),         // andante
DEF_SPLSTR( "anhydr." ),
DEF_SPLSTR( "anim." ),
DEF_SPLSTR( "ann." ),
DEF_SPLSTR( "anon." ),
DEF_SPLSTR( "ans." ),
DEF_SPLSTR( "anthrop." ),
DEF_SPLSTR( "antiq." ),
DEF_SPLSTR( "aor." ),
DEF_SPLSTR( "ap." ),
DEF_SPLSTR( "app." ),
DEF_SPLSTR( "appl." ),
DEF_SPLSTR( "approx." ),
DEF_SPLSTR( "appt." ),
DEF_SPLSTR( "apptd." ),
DEF_SPLSTR( "apt." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "apts." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "aq." ),
DEF_SPLSTR( "ar." ),
DEF_SPLSTR( "archit." ),
DEF_SPLSTR( "archt." ),
DEF_SPLSTR( "arg." ),
DEF_SPLSTR( "arr." ),
// "art." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "arty." ),
DEF_SPLSTR( "asg." ),
DEF_SPLSTR( "asgd." ),
DEF_SPLSTR( "asgmt." ),
DEF_SPLSTR( "assn." ),
DEF_SPLSTR( "assns." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "assoc." ),
DEF_SPLSTR( "assocs." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "asst." ),
DEF_SPLSTR( "asstd." ),
DEF_SPLSTR( "assts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "assy." ),
DEF_SPLSTR( "astrol." ),
DEF_SPLSTR( "astron." ),
//"at." ),                                  // at. no.; special case no longer handled
DEF_SPLSTR( "athl." ),
DEF_SPLSTR( "atm." ),
DEF_SPLSTR( "atmos." ),
DEF_SPLSTR( "att." ),
DEF_SPLSTR( "attn." ),
DEF_SPLSTR( "attrib." ),
DEF_SPLSTR( "atty." ),
DEF_SPLSTR( "attys." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "aud." ),
DEF_SPLSTR( "aug." ),
DEF_SPLSTR( "auth." ),
DEF_SPLSTR( "aux." ),
// "aux. v." ),
DEF_SPLSTR( "av." ),
DEF_SPLSTR( "avdp." ),
DEF_SPLSTR( "ave." ),
DEF_SPLSTR( "avg." ),
DEF_SPLSTR( "avn." ),
DEF_SPLSTR( "az." ),
DEF_SPLSTR( "b.c." ),
DEF_SPLSTR( "b.c.e." ),
DEF_SPLSTR( "b.f." ),
DEF_SPLSTR( "b.i.d." ),
DEF_SPLSTR( "b.m." ),
DEF_SPLSTR( "b.p." ),
DEF_SPLSTR( "b.y." ),
DEF_SPLSTR( "bact." ),
DEF_SPLSTR( "bal." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "bbl." ),
DEF_SPLSTR( "bd." ),
// "bd. ft." ),
DEF_SPLSTR( "bdle." ),
DEF_SPLSTR( "bdrm." ),
DEF_SPLSTR( "bds." ),
DEF_SPLSTR( "bef." ),
DEF_SPLSTR( "bg." ),
DEF_SPLSTR( "bhd." ),
DEF_SPLSTR( "bibl." ),
DEF_SPLSTR( "bibliog." ),
DEF_SPLSTR( "biog." ),
DEF_SPLSTR( "biol." ),
DEF_SPLSTR( "bk." ),
DEF_SPLSTR( "bkg." ),
DEF_SPLSTR( "bkgd." ),
DEF_SPLSTR( "bklr." ),
DEF_SPLSTR( "bkpg." ),
DEF_SPLSTR( "bkpt." ),
DEF_SPLSTR( "bks." ),
DEF_SPLSTR( "bl." ),
DEF_SPLSTR( "bld." ),
DEF_SPLSTR( "bldg." ),
DEF_SPLSTR( "bldr." ),
DEF_SPLSTR( "blk." ),
DEF_SPLSTR( "blvd." ),
DEF_SPLSTR( "bm." ),
DEF_SPLSTR( "bn." ),
DEF_SPLSTR( "bor." ),
DEF_SPLSTR( "bot." ),
DEF_SPLSTR( "boul." ),
DEF_SPLSTR( "bp." ),
DEF_SPLSTR( "br." ),
DEF_SPLSTR( "brev." ),
DEF_SPLSTR( "bro." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "bros." ),
DEF_SPLSTR( "bsh." ),
DEF_SPLSTR( "bsk." ),
DEF_SPLSTR( "btry." ),
DEF_SPLSTR( "bu." ),
DEF_SPLSTR( "bul." ),
DEF_SPLSTR( "bur." ),
DEF_SPLSTR( "bvt." ),
DEF_SPLSTR( "bx." ),
DEF_SPLSTR( "c.a." ),
DEF_SPLSTR( "c.c." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.c.s." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.d." ),
DEF_SPLSTR( "c.f." ),
DEF_SPLSTR( "c.f.i." ),
DEF_SPLSTR( "c.g." ),
DEF_SPLSTR( "c.h." ),
DEF_SPLSTR( "c.i.f." ),
DEF_SPLSTR( "c.l." ),
DEF_SPLSTR( "c.m." ),
DEF_SPLSTR( "c.o." ),
DEF_SPLSTR( "c.o.d." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.o.s." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.v." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "c.w.o." ),
DEF_SPLSTR( "ca." ),      // circa
DEF_SPLSTR( "cal." ),
DEF_SPLSTR( "calc." ),
DEF_SPLSTR( "canc." ),
// "cap." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cath." ),
DEF_SPLSTR( "caus." ),
DEF_SPLSTR( "cav." ),
DEF_SPLSTR( "cc." ),
DEF_SPLSTR( "cckw." ),
DEF_SPLSTR( "ccw." ),
DEF_SPLSTR( "cen." ),
DEF_SPLSTR( "cert." ),
DEF_SPLSTR( "certif." ),
DEF_SPLSTR( "certifs." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cet." ),   // "cet. par."
DEF_SPLSTR( "cf." ), // Moved from titles.txt 8/18/99 - edc
DEF_SPLSTR( "ch." ),
DEF_SPLSTR( "chan." ),
DEF_SPLSTR( "chap." ),  // chapter
// "chaps." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "char." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "chars." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "chem." ),
DEF_SPLSTR( "chg." ),
DEF_SPLSTR( "chl." ),
DEF_SPLSTR( "chm." ),
DEF_SPLSTR( "chron." ),
DEF_SPLSTR( "chronol." ),
DEF_SPLSTR( "cie." ),
DEF_SPLSTR( "cir." ),
DEF_SPLSTR( "circ." ),
DEF_SPLSTR( "circum." ),
DEF_SPLSTR( "cit." ),
DEF_SPLSTR( "civ." ),
DEF_SPLSTR( "ck." ),
DEF_SPLSTR( "cl." ),
DEF_SPLSTR( "cld." ),
DEF_SPLSTR( "clk." ),
DEF_SPLSTR( "clm." ),
DEF_SPLSTR( "cm." ),
DEF_SPLSTR( "cmd." ),
DEF_SPLSTR( "cmdg." ),
DEF_SPLSTR( "cml." ),
DEF_SPLSTR( "co." ),
DEF_SPLSTR( "col." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "coll." ),
DEF_SPLSTR( "collat." ),
DEF_SPLSTR( "colloq." ),
DEF_SPLSTR( "cols." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "com." ),
DEF_SPLSTR( "comd." ),
DEF_SPLSTR( "comdg." ),
DEF_SPLSTR( "coml." ),
DEF_SPLSTR( "comm." ),
DEF_SPLSTR( "comp." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "compar." ),
DEF_SPLSTR( "compd." ),
DEF_SPLSTR( "compt." ),
DEF_SPLSTR( "conc." ),
DEF_SPLSTR( "cond." ),
DEF_SPLSTR( "conf." ),
DEF_SPLSTR( "confed." ),
DEF_SPLSTR( "cong." ),
DEF_SPLSTR( "conj." ),
DEF_SPLSTR( "conjs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cons." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "consol." ),
DEF_SPLSTR( "const." ),
DEF_SPLSTR( "constr." ),
DEF_SPLSTR( "cont." ),
DEF_SPLSTR( "contd." ),
DEF_SPLSTR( "contemp." ),
DEF_SPLSTR( "contr." ),
DEF_SPLSTR( "contrib." ),
DEF_SPLSTR( "conv." ),
DEF_SPLSTR( "coop." ),
DEF_SPLSTR( "cop." ),
DEF_SPLSTR( "cor." ),
DEF_SPLSTR( "corol." ),
DEF_SPLSTR( "corp." ),
// "corps." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "corr." ),
DEF_SPLSTR( "correl." ),
DEF_SPLSTR( "cos." ),
DEF_SPLSTR( "cp." ),
DEF_SPLSTR( "cpd." ),
DEF_SPLSTR( "cr." ),
DEF_SPLSTR( "crim." ),
DEF_SPLSTR( "crit." ),
DEF_SPLSTR( "cs." ),
DEF_SPLSTR( "csk." ),
DEF_SPLSTR( "ct." ),
DEF_SPLSTR( "ctf." ),
DEF_SPLSTR( "ctg." ),
DEF_SPLSTR( "ctge." ),
DEF_SPLSTR( "ctn." ),
DEF_SPLSTR( "ctr." ),
DEF_SPLSTR( "cu." ),
DEF_SPLSTR( "cum." ),
// "cur." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "cv." ),
DEF_SPLSTR( "cvt." ),
DEF_SPLSTR( "cw." ),
DEF_SPLSTR( "cwt." ),
DEF_SPLSTR( "d.b.a." ),
DEF_SPLSTR( "d.b.h." ),
DEF_SPLSTR( "d.s." ),
DEF_SPLSTR( "d.s.p." ),
DEF_SPLSTR( "d.t." ),
DEF_SPLSTR( "dat." ),
DEF_SPLSTR( "dbl." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dble." ),
DEF_SPLSTR( "dd." ),
DEF_SPLSTR( "deb." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dec." ),
DEF_SPLSTR( "decd." ),
DEF_SPLSTR( "decl." ),
DEF_SPLSTR( "def." ),
DEF_SPLSTR( "deg." ),
DEF_SPLSTR( "del." ),
DEF_SPLSTR( "dely." ),
DEF_SPLSTR( "dem." ),
DEF_SPLSTR( "denom." ),
DEF_SPLSTR( "dep." ),
DEF_SPLSTR( "dept." ),
DEF_SPLSTR( "depts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "der." ),
DEF_SPLSTR( "deriv." ),
DEF_SPLSTR( "det." ),
DEF_SPLSTR( "dev." ),
DEF_SPLSTR( "dft." ),
DEF_SPLSTR( "dia." ),
DEF_SPLSTR( "diag." ),
DEF_SPLSTR( "diam." ),
DEF_SPLSTR( "dict." ),
DEF_SPLSTR( "dif." ),
DEF_SPLSTR( "diff." ),
DEF_SPLSTR( "dil." ),
DEF_SPLSTR( "dimin." ),
DEF_SPLSTR( "dipl." ),
DEF_SPLSTR( "dir." ),
DEF_SPLSTR( "dirs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dis." ),
// "disc." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "disp." ),
DEF_SPLSTR( "diss." ),
DEF_SPLSTR( "dissd." ),
DEF_SPLSTR( "dist." ),
DEF_SPLSTR( "distr." ),
DEF_SPLSTR( "div." ),
DEF_SPLSTR( "dk." ),
DEF_SPLSTR( "dlr." ),
DEF_SPLSTR( "dm." ),
DEF_SPLSTR( "dn." ),
DEF_SPLSTR( "doc." ),
DEF_SPLSTR( "dol." ),
DEF_SPLSTR( "dom." ),
DEF_SPLSTR( "doz." ),
DEF_SPLSTR( "dpt." ),
DEF_SPLSTR( "dr." ),
DEF_SPLSTR( "dup." ),
DEF_SPLSTR( "dupl." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dupls." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dups." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "dwt." ),
DEF_SPLSTR( "dy." ),
DEF_SPLSTR( "dz." ),
DEF_SPLSTR( "e.e." ),
DEF_SPLSTR( "e.g." ), // Moved from titles.txt - edc 8/18/99
DEF_SPLSTR( "e.o." ),
DEF_SPLSTR( "e.o.m." ),
DEF_SPLSTR( "e.p.t." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "e.s.p." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "e.t.a." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "e.t.d." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ea." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "eccl." ),
DEF_SPLSTR( "eccles." ),
DEF_SPLSTR( "ecol." ),
DEF_SPLSTR( "ed." ),
DEF_SPLSTR( "eds." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "educ." ),
DEF_SPLSTR( "eff." ),
DEF_SPLSTR( "el." ),
DEF_SPLSTR( "elec." ),
DEF_SPLSTR( "elem." ),
DEF_SPLSTR( "elev." ),
DEF_SPLSTR( "emer." ),
DEF_SPLSTR( "emp." ),
DEF_SPLSTR( "enc." ),
DEF_SPLSTR( "encl." ),
DEF_SPLSTR( "ency." ),
DEF_SPLSTR( "encyc." ),
DEF_SPLSTR( "encycl." ),
DEF_SPLSTR( "eng." ),
DEF_SPLSTR( "engr." ),
DEF_SPLSTR( "enl." ),
DEF_SPLSTR( "entom." ),
DEF_SPLSTR( "eq." ),
DEF_SPLSTR( "eqn." ),
DEF_SPLSTR( "eqns." ),
DEF_SPLSTR( "equip." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "equiv." ),
DEF_SPLSTR( "esp." ),
DEF_SPLSTR( "esq." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "est." ),
// "et al." ),
// "et seq." ),
// "et ux." ),
DEF_SPLSTR( "etc." ),
DEF_SPLSTR( "etym." ),
DEF_SPLSTR( "evan." ),
DEF_SPLSTR( "evang." ),
DEF_SPLSTR( "evap." ),
DEF_SPLSTR( "evg." ),
DEF_SPLSTR( "ex." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "exc." ),
DEF_SPLSTR( "exch." ),
DEF_SPLSTR( "excl." ),
// "exec." ),                             // PaulCa 4/15/99 (Bug 108)
// "execs." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "exp." ),
DEF_SPLSTR( "expt." ),
DEF_SPLSTR( "exptl." ),
DEF_SPLSTR( "exr." ),
DEF_SPLSTR( "exrx." ),
DEF_SPLSTR( "ext." ),
DEF_SPLSTR( "f.a." ),
DEF_SPLSTR( "f.a.a." ),
DEF_SPLSTR( "f.a.s." ),
DEF_SPLSTR( "f.c." ),
DEF_SPLSTR( "f.h.b." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "f.o.b." ),
DEF_SPLSTR( "f.r." ),
DEF_SPLSTR( "f.v." ),
DEF_SPLSTR( "fac." ),
DEF_SPLSTR( "fam." ),
DEF_SPLSTR( "fasc." ),
DEF_SPLSTR( "fcap." ),
DEF_SPLSTR( "fcp." ),
DEF_SPLSTR( "fcy." ),
DEF_SPLSTR( "fec." ),
// "fed." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "fem." ),
DEF_SPLSTR( "ff." ),
DEF_SPLSTR( "fgt." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "fict." ),
DEF_SPLSTR( "fig." ),                                 // special case
DEF_SPLSTR( "figs." ),                                // special case
DEF_SPLSTR( "fl." ),
DEF_SPLSTR( "fld." ),
DEF_SPLSTR( "fm." ),
DEF_SPLSTR( "fn." ),
DEF_SPLSTR( "fol." ),
DEF_SPLSTR( "fp." ),
DEF_SPLSTR( "fr." ),
DEF_SPLSTR( "freq." ),
DEF_SPLSTR( "frt." ),
DEF_SPLSTR( "ft." ),
DEF_SPLSTR( "fth." ),
DEF_SPLSTR( "furn." ),
DEF_SPLSTR( "fut." ),
DEF_SPLSTR( "fwd." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "g.m.b.h." ),
DEF_SPLSTR( "g.p.d." ),
DEF_SPLSTR( "g.p.m." ),
DEF_SPLSTR( "g.p.s." ),
DEF_SPLSTR( "ga." ),
// "gal." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "galv." ),
DEF_SPLSTR( "gaz." ),
DEF_SPLSTR( "gd." ),
DEF_SPLSTR( "gds." ),
DEF_SPLSTR( "gen." ),
DEF_SPLSTR( "genit." ),
DEF_SPLSTR( "genl." ),
DEF_SPLSTR( "geog." ),
DEF_SPLSTR( "geol." ),
DEF_SPLSTR( "geom." ),
DEF_SPLSTR( "ger." ),
DEF_SPLSTR( "gl." ),
DEF_SPLSTR( "gld." ),
DEF_SPLSTR( "gm." ),
DEF_SPLSTR( "gnd." ),
DEF_SPLSTR( "gov." ),
DEF_SPLSTR( "govt." ),
DEF_SPLSTR( "gr." ),
// "gr. wt." ),
DEF_SPLSTR( "gro." ),
DEF_SPLSTR( "gt." ),
DEF_SPLSTR( "gtd." ),
DEF_SPLSTR( "gtt." ),
DEF_SPLSTR( "guar." ),
DEF_SPLSTR( "gyn." ),
DEF_SPLSTR( "gynecol." ),
DEF_SPLSTR( "h.c." ),
DEF_SPLSTR( "h.q." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "h.r." ),
DEF_SPLSTR( "hab." ),     // "hab. corp." ),
DEF_SPLSTR( "hd." ),
DEF_SPLSTR( "hdbk." ),
DEF_SPLSTR( "hdkf." ),
DEF_SPLSTR( "hdlg." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hdqrs." ),
DEF_SPLSTR( "hdwe." ),
DEF_SPLSTR( "hf." ),
DEF_SPLSTR( "hgb." ),
DEF_SPLSTR( "hgt." ),
DEF_SPLSTR( "hgwy." ),
DEF_SPLSTR( "hist." ),
DEF_SPLSTR( "hld." ),
DEF_SPLSTR( "hm." ),
DEF_SPLSTR( "ho." ),
// "hon." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hor." ),
DEF_SPLSTR( "horol." ),
DEF_SPLSTR( "hort." ),
DEF_SPLSTR( "hosp." ),
DEF_SPLSTR( "hp." ),      // horsepower
DEF_SPLSTR( "hr." ),
DEF_SPLSTR( "ht." ),                                  // PaulCa 4/15/99 (Bug 108)
// "http." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hwy." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "hyd." ),
DEF_SPLSTR( "hypoth." ),
DEF_SPLSTR( "i.a." ),
DEF_SPLSTR( "i.d." ),
DEF_SPLSTR( "i.e." ),  // Moved from titles.txt - edc 8/18/99
DEF_SPLSTR( "i.q." ),
DEF_SPLSTR( "i.w." ),
DEF_SPLSTR( "ib." ),
DEF_SPLSTR( "ibid." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ichth." ),
DEF_SPLSTR( "ign." ),
DEF_SPLSTR( "illus." ),
DEF_SPLSTR( "imit." ),
DEF_SPLSTR( "immun." ),
DEF_SPLSTR( "in." ),      // inch
DEF_SPLSTR( "inbd." ),
DEF_SPLSTR( "inc." ),
DEF_SPLSTR( "incl." ),
DEF_SPLSTR( "incog." ),
DEF_SPLSTR( "incr." ),
DEF_SPLSTR( "ind." ),
DEF_SPLSTR( "indef." ),
DEF_SPLSTR( "indic." ),
DEF_SPLSTR( "indn." ),
DEF_SPLSTR( "indus." ),
DEF_SPLSTR( "inf." ),
DEF_SPLSTR( "infin." ),
DEF_SPLSTR( "infl." ),
DEF_SPLSTR( "infs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "inj." ),
DEF_SPLSTR( "inq." ),
DEF_SPLSTR( "ins." ),
DEF_SPLSTR( "insol." ),
DEF_SPLSTR( "insp." ),
DEF_SPLSTR( "inst." ),
DEF_SPLSTR( "instr." ),
// "int'l." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "int." ),
DEF_SPLSTR( "inter." ),
DEF_SPLSTR( "interj." ),
DEF_SPLSTR( "interp." ),
DEF_SPLSTR( "interrog." ),
DEF_SPLSTR( "intl." ),
DEF_SPLSTR( "intr." ),
// "intro." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "inv." ),
DEF_SPLSTR( "irid." ),
DEF_SPLSTR( "irreg." ),
DEF_SPLSTR( "isl." ),
DEF_SPLSTR( "isth." ),
DEF_SPLSTR( "ital." ),
DEF_SPLSTR( "jct." ),
DEF_SPLSTR( "jnr." ),
DEF_SPLSTR( "jnt." ),
DEF_SPLSTR( "jour." ),
DEF_SPLSTR( "jr." ),
DEF_SPLSTR( "jt." ),
DEF_SPLSTR( "jun." ),
DEF_SPLSTR( "junc." ),
DEF_SPLSTR( "juv." ),
DEF_SPLSTR( "jwlr." ),
DEF_SPLSTR( "kc." ),
DEF_SPLSTR( "km." ),
DEF_SPLSTR( "kmh." ),
DEF_SPLSTR( "kn." ),
DEF_SPLSTR( "kr." ),
DEF_SPLSTR( "kt." ),
DEF_SPLSTR( "l." ),      // liter
DEF_SPLSTR( "l.c." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "l.c.d." ),
DEF_SPLSTR( "l.c.m." ),
DEF_SPLSTR( "l.t." ),
DEF_SPLSTR( "lang." ),
DEF_SPLSTR( "langs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "lat." ),
DEF_SPLSTR( "lav." ),
DEF_SPLSTR( "lb." ),
DEF_SPLSTR( "lbs." ),
DEF_SPLSTR( "ld." ),
DEF_SPLSTR( "ldg." ),
DEF_SPLSTR( "lea." ),
DEF_SPLSTR( "lect." ),
DEF_SPLSTR( "lectr." ),
DEF_SPLSTR( "legis." ),
DEF_SPLSTR( "lg." ),
DEF_SPLSTR( "lge." ),
DEF_SPLSTR( "li." ),
DEF_SPLSTR( "lieut." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "lim." ),
DEF_SPLSTR( "lin." ),
DEF_SPLSTR( "ling." ),
DEF_SPLSTR( "liq." ),
// "lit." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "lith." ),
DEF_SPLSTR( "litho." ),
DEF_SPLSTR( "lithog." ),
DEF_SPLSTR( "ll." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "loc." ),
// "loc. cit." ),
// "long." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "loq." ),
DEF_SPLSTR( "lt." ),
DEF_SPLSTR( "ltd." ),
DEF_SPLSTR( "ltda." ),
DEF_SPLSTR( "lv." ),
DEF_SPLSTR( "lyr." ),
DEF_SPLSTR( "m.d." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "m.f." ),
DEF_SPLSTR( "m.m." ),
DEF_SPLSTR( "m.o." ),
DEF_SPLSTR( "m.o.m." ),
DEF_SPLSTR( "m.p.g." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "m.p.h." ),
DEF_SPLSTR( "m.s.l." ),
DEF_SPLSTR( "m.t." ),
DEF_SPLSTR( "m.y." ),
DEF_SPLSTR( "mach." ),
DEF_SPLSTR( "mag." ),
DEF_SPLSTR( "manuf." ),
DEF_SPLSTR( "manufac." ),
DEF_SPLSTR( "marg." ),
DEF_SPLSTR( "masc." ),
// "max." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mc." ),
DEF_SPLSTR( "mdse." ),
DEF_SPLSTR( "meas." ),
DEF_SPLSTR( "mech." ),
DEF_SPLSTR( "med." ),
DEF_SPLSTR( "mer." ),
DEF_SPLSTR( "metall." ),
DEF_SPLSTR( "metaph." ),
DEF_SPLSTR( "mfd." ),
DEF_SPLSTR( "mfg." ),
DEF_SPLSTR( "mfr." ),
DEF_SPLSTR( "mfrs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mg." ),     // milligram
DEF_SPLSTR( "mgmt." ),
DEF_SPLSTR( "mgr." ),
DEF_SPLSTR( "mgrs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mgt." ),
DEF_SPLSTR( "mhz." ),
DEF_SPLSTR( "mi." ),
DEF_SPLSTR( "mid." ),
DEF_SPLSTR( "min." ),
DEF_SPLSTR( "misc." ),
DEF_SPLSTR( "mk." ),
DEF_SPLSTR( "mkt." ),
DEF_SPLSTR( "mktg." ),
DEF_SPLSTR( "ml." ),  // milliliter
DEF_SPLSTR( "mm." ),
DEF_SPLSTR( "mngr." ),
DEF_SPLSTR( "mo." ),
DEF_SPLSTR( "mol." ),
DEF_SPLSTR( "mon." ),
DEF_SPLSTR( "morph." ),
DEF_SPLSTR( "mos." ),
DEF_SPLSTR( "mph." ),
DEF_SPLSTR( "msec." ),
DEF_SPLSTR( "msg." ),
DEF_SPLSTR( "mt." ),
DEF_SPLSTR( "mtg." ),
DEF_SPLSTR( "mtge." ),
DEF_SPLSTR( "mtgs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "mtn." ),
DEF_SPLSTR( "mts." ),
DEF_SPLSTR( "mus." ),
DEF_SPLSTR( "mxd." ),
DEF_SPLSTR( "myc." ),
DEF_SPLSTR( "mycol." ),
DEF_SPLSTR( "mythol." ),
DEF_SPLSTR( "n.b." ),
DEF_SPLSTR( "n.d." ),
DEF_SPLSTR( "n.e.s." ),
DEF_SPLSTR( "n.l." ),
DEF_SPLSTR( "n.m." ),
DEF_SPLSTR( "n.o.p." ),
DEF_SPLSTR( "n.o.s." ),
DEF_SPLSTR( "n.s." ),
DEF_SPLSTR( "n.s.f." ),
DEF_SPLSTR( "n.t.p." ),
DEF_SPLSTR( "n.wt." ),
DEF_SPLSTR( "nat." ),
DEF_SPLSTR( "natl." ),
DEF_SPLSTR( "naut." ),
DEF_SPLSTR( "nav." ),
DEF_SPLSTR( "ne." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "neg." ),
DEF_SPLSTR( "neur." ),
DEF_SPLSTR( "neurol." ),
DEF_SPLSTR( "neut." ),
DEF_SPLSTR( "no." ),                                  // special case handled in the code
DEF_SPLSTR( "nol." ),     // "nol. pros." ),
DEF_SPLSTR( "nom." ),
DEF_SPLSTR( "nos." ),
DEF_SPLSTR( "nt." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "nt.wt." ),
DEF_SPLSTR( "num." ),
DEF_SPLSTR( "numis." ),
DEF_SPLSTR( "nw." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "o.c." ),
DEF_SPLSTR( "o.d." ),
DEF_SPLSTR( "o.k." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "o.n.o." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "o.s." ),
DEF_SPLSTR( "o.t." ),
DEF_SPLSTR( "ob." ),
DEF_SPLSTR( "obj." ),
DEF_SPLSTR( "obl." ),
DEF_SPLSTR( "obs." ),
DEF_SPLSTR( "obstet." ),
DEF_SPLSTR( "oc." ),
DEF_SPLSTR( "occ." ),
DEF_SPLSTR( "occas." ),
DEF_SPLSTR( "oct." ),
DEF_SPLSTR( "op." ),
// L"op. cit." ),
DEF_SPLSTR( "opp." ),
DEF_SPLSTR( "opt." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "orch." ),
DEF_SPLSTR( "ord." ),
DEF_SPLSTR( "ordn." ),
DEF_SPLSTR( "org." ),
DEF_SPLSTR( "orig." ),
DEF_SPLSTR( "ornith." ),
DEF_SPLSTR( "orth." ),
DEF_SPLSTR( "otol." ),
DEF_SPLSTR( "oz" ),
DEF_SPLSTR( "oz." ),
DEF_SPLSTR( "p.a." ),
DEF_SPLSTR( "p.c." ),
DEF_SPLSTR( "p.d." ),
DEF_SPLSTR( "p.m." ),
DEF_SPLSTR( "p.n." ),
DEF_SPLSTR( "p.o." ),
DEF_SPLSTR( "p.o.e." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "p.p." ),
DEF_SPLSTR( "p.p.a." ),
DEF_SPLSTR( "p.q." ),
DEF_SPLSTR( "p.r." ),
DEF_SPLSTR( "p.r.n." ),
DEF_SPLSTR( "p.s." ),   // A bogus abbreviation for Post Scriptum. Also covers "P.S." and "P.s."
DEF_SPLSTR( "p.t." ),
DEF_SPLSTR( "p.t.o." ),
DEF_SPLSTR( "pam." ),
DEF_SPLSTR( "par." ),   // "cet. par."
DEF_SPLSTR( "paren." ),
DEF_SPLSTR( "parl." ),
// L"pat." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "patd." ),
// L"pats." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "payt." ),
DEF_SPLSTR( "pct." ),
DEF_SPLSTR( "pd." ),
DEF_SPLSTR( "per." ),
DEF_SPLSTR( "perp." ),
DEF_SPLSTR( "pers." ),
DEF_SPLSTR( "petr." ),
DEF_SPLSTR( "petrog." ),
DEF_SPLSTR( "pf." ),
DEF_SPLSTR( "pfd." ),
DEF_SPLSTR( "pfg." ),
DEF_SPLSTR( "pg." ),
DEF_SPLSTR( "ph." ),
DEF_SPLSTR( "phar." ),
DEF_SPLSTR( "pharm." ),
DEF_SPLSTR( "phil." ),
DEF_SPLSTR( "philos." ),
DEF_SPLSTR( "phon." ),
DEF_SPLSTR( "photog." ),
DEF_SPLSTR( "photom." ),
DEF_SPLSTR( "phr." ),
DEF_SPLSTR( "phren." ),
DEF_SPLSTR( "phys." ),
// L"phys. ed." ),
DEF_SPLSTR( "physiol." ),
DEF_SPLSTR( "pinx." ),
DEF_SPLSTR( "pizz." ),
DEF_SPLSTR( "pk." ),
DEF_SPLSTR( "pkg." ),
DEF_SPLSTR( "pkgs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pkt." ),
DEF_SPLSTR( "pl." ),
DEF_SPLSTR( "plf." ),
DEF_SPLSTR( "pln." ),
DEF_SPLSTR( "pls." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "plu." ),
DEF_SPLSTR( "pm." ),
DEF_SPLSTR( "pmk." ),
DEF_SPLSTR( "pmt." ),
DEF_SPLSTR( "pmts." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pneum." ),
DEF_SPLSTR( "pol." ),
DEF_SPLSTR( "polit." ),
DEF_SPLSTR( "por." ),
DEF_SPLSTR( "pos." ),
DEF_SPLSTR( "poss." ),
DEF_SPLSTR( "pp." ),
DEF_SPLSTR( "ppd." ),
DEF_SPLSTR( "pph." ),
DEF_SPLSTR( "ppt." ),
DEF_SPLSTR( "pptn." ),
DEF_SPLSTR( "pr." ),
DEF_SPLSTR( "prec." ),
DEF_SPLSTR( "pred." ),
DEF_SPLSTR( "pref." ),
DEF_SPLSTR( "prem." ),
// L"prep." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "prepd." ),
DEF_SPLSTR( "prepn." ),
DEF_SPLSTR( "preps." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pres." ),
DEF_SPLSTR( "pret." ),
DEF_SPLSTR( "prev." ),
DEF_SPLSTR( "prf." ),
DEF_SPLSTR( "prin." ),
DEF_SPLSTR( "priv." ),
DEF_SPLSTR( "prob." ),
DEF_SPLSTR( "probs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "proc." ),
// L"prod." ),                             // PaulCa 4/15/99 (Bug 108)
// L"prods." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "prof." ),
DEF_SPLSTR( "pron." ),
DEF_SPLSTR( "propr." ),
DEF_SPLSTR( "pros." ),
DEF_SPLSTR( "protec." ),
DEF_SPLSTR( "prov." ),
DEF_SPLSTR( "prox." ),
DEF_SPLSTR( "ps." ),  // A bogus abbreviation for Post Scriptum. Also covers "PS." and "Ps."
DEF_SPLSTR( "psec." ),
DEF_SPLSTR( "pseud." ),
DEF_SPLSTR( "psf." ),
DEF_SPLSTR( "pstg." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "psych." ),
DEF_SPLSTR( "psychol." ),
DEF_SPLSTR( "pt." ),
DEF_SPLSTR( "pta." ),
DEF_SPLSTR( "ptg." ),
DEF_SPLSTR( "pty." ),
// L"pub." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "publ." ),
// L"pubs." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "pwr." ),
DEF_SPLSTR( "pwt." ),
DEF_SPLSTR( "pxt." ),
DEF_SPLSTR( "pyro." ),
// L"q. t." ),
DEF_SPLSTR( "q.b." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "q.i.d." ),
DEF_SPLSTR( "q.p." ),
DEF_SPLSTR( "q.s." ),
DEF_SPLSTR( "q.t." ),
DEF_SPLSTR( "q.v." ),
DEF_SPLSTR( "ql." ),
DEF_SPLSTR( "qlty." ),
DEF_SPLSTR( "qn." ),
DEF_SPLSTR( "qq." ),
DEF_SPLSTR( "qq.v." ),
DEF_SPLSTR( "qr." ),
DEF_SPLSTR( "qrs." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "qt." ),
DEF_SPLSTR( "qto." ),
DEF_SPLSTR( "qtr." ),   //
DEF_SPLSTR( "qtrs." ),  // Noah 2.0, bug #70: the first two qtrs. of CY 95
DEF_SPLSTR( "qty." ),
DEF_SPLSTR( "qu." ),
DEF_SPLSTR( "qual." ),
DEF_SPLSTR( "quant." ),
DEF_SPLSTR( "quar." ),
DEF_SPLSTR( "ques." ),
DEF_SPLSTR( "quot." ),
DEF_SPLSTR( "r.h." ),
DEF_SPLSTR( "r.i.p." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "r.n." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "r.o.t.c." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rad." ),
DEF_SPLSTR( "rcpt." ),
DEF_SPLSTR( "rct." ),
DEF_SPLSTR( "rd." ),
DEF_SPLSTR( "rec." ),
// L"rec. sec." ),
DEF_SPLSTR( "recd." ),
DEF_SPLSTR( "recip." ),
DEF_SPLSTR( "recs." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rect." ),
// L"red." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ref." ),
DEF_SPLSTR( "refl." ),
// L"refs." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "reg." ),
DEF_SPLSTR( "regd." ),
DEF_SPLSTR( "regt." ),
DEF_SPLSTR( "rel." ),
DEF_SPLSTR( "rem." ),
DEF_SPLSTR( "rep." ),
DEF_SPLSTR( "repl." ),
// L"reps." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rept." ),
DEF_SPLSTR( "req." ),
DEF_SPLSTR( "reqd." ),
DEF_SPLSTR( "res." ),
DEF_SPLSTR( "resp." ),
DEF_SPLSTR( "ret." ),
DEF_SPLSTR( "rev." ),
DEF_SPLSTR( "rf." ),
DEF_SPLSTR( "rhbdr." ),
DEF_SPLSTR( "rheo." ),
DEF_SPLSTR( "rhet." ),
DEF_SPLSTR( "rhomb." ),
DEF_SPLSTR( "rit." ),
DEF_SPLSTR( "riv." ),
DEF_SPLSTR( "rm." ),
DEF_SPLSTR( "rms." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rnd." ),
DEF_SPLSTR( "ro." ),
DEF_SPLSTR( "rom." ),
DEF_SPLSTR( "rpt." ),
DEF_SPLSTR( "rt." ),
DEF_SPLSTR( "rte." ),
DEF_SPLSTR( "rtes." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "rul." ),
DEF_SPLSTR( "rwy." ),
DEF_SPLSTR( "ry." ),
DEF_SPLSTR( "s.a." ),
DEF_SPLSTR( "s.ap." ),
DEF_SPLSTR( "s.b." ),
DEF_SPLSTR( "s.d." ),
DEF_SPLSTR( "s.l." ),
DEF_SPLSTR( "s.l.a.n." ),
DEF_SPLSTR( "s.n." ),
DEF_SPLSTR( "s.o." ),
DEF_SPLSTR( "s.p." ),
DEF_SPLSTR( "s.p.a." ),
DEF_SPLSTR( "s.p.s." ),
DEF_SPLSTR( "s.t." ),
DEF_SPLSTR( "s.w.a.t." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "sanit." ),
DEF_SPLSTR( "satd." ),
DEF_SPLSTR( "sb." ),
DEF_SPLSTR( "sc." ),
DEF_SPLSTR( "sch." ),
DEF_SPLSTR( "sci." ),
DEF_SPLSTR( "scr." ),
DEF_SPLSTR( "sculp." ),
DEF_SPLSTR( "sd." ),
DEF_SPLSTR( "se." ),                                  // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "sec." ),
DEF_SPLSTR( "sect." ),                                // special case
DEF_SPLSTR( "secy." ),
DEF_SPLSTR( "sed." ),
DEF_SPLSTR( "sel." ),
DEF_SPLSTR( "sem." ),
DEF_SPLSTR( "sen." ),
DEF_SPLSTR( "sep." ),
DEF_SPLSTR( "sepd." ),
DEF_SPLSTR( "seq." ),
DEF_SPLSTR( "seqq." ),
DEF_SPLSTR( "ser." ),
DEF_SPLSTR( "serv." ),
DEF_SPLSTR( "sess." ),
DEF_SPLSTR( "sf." ),
DEF_SPLSTR( "sfz." ),
DEF_SPLSTR( "sgd." ),
DEF_SPLSTR( "sh." ),
DEF_SPLSTR( "shpt." ),
DEF_SPLSTR( "shpts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "shr." ),
DEF_SPLSTR( "sht." ),
DEF_SPLSTR( "sig." ),
// L"sing." ),                             // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "sk." ),
DEF_SPLSTR( "sl." ),
DEF_SPLSTR( "sld." ),
DEF_SPLSTR( "sm." ),
DEF_SPLSTR( "soc." ),
DEF_SPLSTR( "sol." ),
DEF_SPLSTR( "soln." ),
DEF_SPLSTR( "soph." ),
DEF_SPLSTR( "sou." ),
DEF_SPLSTR( "sp." ),
DEF_SPLSTR( "spec." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "specif." ),
DEF_SPLSTR( "spp." ),
DEF_SPLSTR( "spr." ),
DEF_SPLSTR( "spt." ),
DEF_SPLSTR( "sq." ),
DEF_SPLSTR( "sr." ),
DEF_SPLSTR( "ss." ),
DEF_SPLSTR( "ssp." ),
DEF_SPLSTR( "st." ),
DEF_SPLSTR( "sta." ),
DEF_SPLSTR( "stacc." ),
DEF_SPLSTR( "stat." ),
DEF_SPLSTR( "stbd." ),
DEF_SPLSTR( "std." ),
DEF_SPLSTR( "sten." ),
DEF_SPLSTR( "stenog." ),
DEF_SPLSTR( "ster." ),
DEF_SPLSTR( "stg." ),
DEF_SPLSTR( "stge." ),
DEF_SPLSTR( "stip." ),
DEF_SPLSTR( "stk." ),
DEF_SPLSTR( "stmt." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "stmts." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "str." ),
// L"sub." ),                              // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "subj." ),
DEF_SPLSTR( "subjs." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "subs." ),
DEF_SPLSTR( "subsp." ),
DEF_SPLSTR( "subst." ),
DEF_SPLSTR( "suf." ),
DEF_SPLSTR( "suff." ),
DEF_SPLSTR( "supp." ),
DEF_SPLSTR( "suppl." ),
DEF_SPLSTR( "supr." ),
DEF_SPLSTR( "supt." ),
DEF_SPLSTR( "supvr." ),
DEF_SPLSTR( "sur." ),
DEF_SPLSTR( "surg." ),
DEF_SPLSTR( "surr." ),
DEF_SPLSTR( "svgs." ),
DEF_SPLSTR( "sw." ),
DEF_SPLSTR( "syl." ),
DEF_SPLSTR( "syll." ),
DEF_SPLSTR( "sym." ),
DEF_SPLSTR( "syn." ),
DEF_SPLSTR( "synd." ),
DEF_SPLSTR( "syst." ),
DEF_SPLSTR( "t.b." ),
DEF_SPLSTR( "t.g." ),
DEF_SPLSTR( "t.i.d." ),
DEF_SPLSTR( "t.l." ),
DEF_SPLSTR( "t.l.o." ),
DEF_SPLSTR( "t.m." ),
DEF_SPLSTR( "t.o." ),
DEF_SPLSTR( "t.p." ),
DEF_SPLSTR( "tab." ),
DEF_SPLSTR( "tbs." ),
DEF_SPLSTR( "tbsp." ),
DEF_SPLSTR( "tchr." ),
DEF_SPLSTR( "tec." ),
DEF_SPLSTR( "tech." ),
DEF_SPLSTR( "technol." ),
DEF_SPLSTR( "tel." ),
DEF_SPLSTR( "teleg." ),
// L"temp." ),                             // PaulCa 4/15/99 (Bug 108)
// L"temps." ),                            // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ter." ),
DEF_SPLSTR( "terr." ),
DEF_SPLSTR( "tfr." ),
DEF_SPLSTR( "tgt." ),
DEF_SPLSTR( "theat." ),
DEF_SPLSTR( "theol." ),
DEF_SPLSTR( "therap." ),
DEF_SPLSTR( "therm." ),
DEF_SPLSTR( "tinct." ),
DEF_SPLSTR( "tk." ),
DEF_SPLSTR( "tkt." ),
DEF_SPLSTR( "tlr." ),
DEF_SPLSTR( "tn." ),
DEF_SPLSTR( "tng." ),
DEF_SPLSTR( "tnpk." ),
DEF_SPLSTR( "topog." ),
DEF_SPLSTR( "tp." ),
DEF_SPLSTR( "tpk." ),
DEF_SPLSTR( "tr." ),
DEF_SPLSTR( "trans." ),
DEF_SPLSTR( "transf." ),
DEF_SPLSTR( "transl." ),
DEF_SPLSTR( "transp." ),
DEF_SPLSTR( "trav." ),
DEF_SPLSTR( "treas." ),
DEF_SPLSTR( "trib." ),
DEF_SPLSTR( "trigon." ),
DEF_SPLSTR( "tripl." ),
DEF_SPLSTR( "trop." ),
DEF_SPLSTR( "trp." ),
DEF_SPLSTR( "tsp." ),
DEF_SPLSTR( "twp." ),
DEF_SPLSTR( "typ." ),
DEF_SPLSTR( "u.c." ),
DEF_SPLSTR( "u.p.s." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "u.s." ),
DEF_SPLSTR( "u.s.a." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "ult." ),
DEF_SPLSTR( "unan." ),
DEF_SPLSTR( "unb." ),
DEF_SPLSTR( "unbd." ),
DEF_SPLSTR( "univ." ),
DEF_SPLSTR( "unp." ),
DEF_SPLSTR( "uns." ),
DEF_SPLSTR( "urol." ),
DEF_SPLSTR( "usu." ),
DEF_SPLSTR( "util." ),
DEF_SPLSTR( "ux." ),
DEF_SPLSTR( "v.d." ),
DEF_SPLSTR( "v.i." ),
DEF_SPLSTR( "v.s." ),
DEF_SPLSTR( "v.v." ),
DEF_SPLSTR( "vac." ),
DEF_SPLSTR( "val." ),
DEF_SPLSTR( "var." ),
DEF_SPLSTR( "vars." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "vb." ),
DEF_SPLSTR( "vbs." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "veg." ),
DEF_SPLSTR( "vel." ),
DEF_SPLSTR( "ver." ),
DEF_SPLSTR( "vert." ),
DEF_SPLSTR( "veter." ),
DEF_SPLSTR( "vic." ),
DEF_SPLSTR( "vil." ),
DEF_SPLSTR( "vis." ),
DEF_SPLSTR( "viz." ),
DEF_SPLSTR( "vo." ),
DEF_SPLSTR( "voc." ),
DEF_SPLSTR( "vocab." ),
DEF_SPLSTR( "vol." ),
DEF_SPLSTR( "vols." ),                                // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "vou." ),
DEF_SPLSTR( "vs." ), // Moved from titles.txt - edc 8/18/99
DEF_SPLSTR( "vss." ),
DEF_SPLSTR( "vulg." ),
DEF_SPLSTR( "vv." ),
DEF_SPLSTR( "w.b." ),
DEF_SPLSTR( "w.f." ),                                 // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "w.g." ),
DEF_SPLSTR( "w.i." ),
DEF_SPLSTR( "w.l." ),
DEF_SPLSTR( "w.o.c." ),
DEF_SPLSTR( "w.p.m." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "wd." ),
DEF_SPLSTR( "wh." ),
DEF_SPLSTR( "whf." ),
DEF_SPLSTR( "whs." ),
DEF_SPLSTR( "whsle." ),
DEF_SPLSTR( "wid." ),
DEF_SPLSTR( "wk." ),
DEF_SPLSTR( "wkly." ),
DEF_SPLSTR( "wm." ),
DEF_SPLSTR( "wmk." ),
DEF_SPLSTR( "wpn." ),
DEF_SPLSTR( "wrnt." ),
DEF_SPLSTR( "wt." ),
DEF_SPLSTR( "x-div." ),
DEF_SPLSTR( "x-int." ),                               // PaulCa 4/15/99 (Bug 108)
DEF_SPLSTR( "yd." ),
DEF_SPLSTR( "yel." ),
DEF_SPLSTR( "yeo." ),
DEF_SPLSTR( "yr." ),
DEF_SPLSTR( "yrs." ),
DEF_SPLSTR( "zool." ),
};

// This is an alphabetized list of all non-proper-noun words which
// appear within the list of the 200 most frequent first words
// in sentences in both the Brown and WSJ corpora.
static const SPLSTR g_FirstWords[] =
{
DEF_SPLSTR( "A" ),
DEF_SPLSTR( "About" ),
DEF_SPLSTR( "According" ),
DEF_SPLSTR( "After" ),
DEF_SPLSTR( "Again" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "All" ),
DEF_SPLSTR( "Also" ),
DEF_SPLSTR( "Although" ),
//L"American" ),                             // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Among" ),
DEF_SPLSTR( "An" ),
DEF_SPLSTR( "And" ),
DEF_SPLSTR( "Another" ),
DEF_SPLSTR( "Any" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Anyway" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Are" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "As" ),
DEF_SPLSTR( "At" ),
DEF_SPLSTR( "Back" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Because" ),
DEF_SPLSTR( "Before" ),
DEF_SPLSTR( "Besides" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Both" ),
DEF_SPLSTR( "But" ),
DEF_SPLSTR( "By" ),
DEF_SPLSTR( "Can" ),                                  // PaulCa added 4/14/99 (Bug 107)
//L"Click" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Consequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Dear" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Despite" ),
DEF_SPLSTR( "Did" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Do" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Does" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Don't" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "During" ),
DEF_SPLSTR( "Each" ),
DEF_SPLSTR( "Early" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Even" ),
DEF_SPLSTR( "Every" ),                                // PaulCa added 4/14/99 (Bug 107)
//L"Executive" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Finally" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "First" ),
DEF_SPLSTR( "Following" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "For" ),
//L"Founded" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Four" ),
DEF_SPLSTR( "From" ),
DEF_SPLSTR( "Further" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Furthermore" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Generally" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Given" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Go" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Great" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Had" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Have" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Having" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "He" ),
DEF_SPLSTR( "Her" ),
DEF_SPLSTR( "Here" ),
DEF_SPLSTR( "His" ),
DEF_SPLSTR( "How" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "However" ),
DEF_SPLSTR( "I" ),
DEF_SPLSTR( "If" ),
DEF_SPLSTR( "In" ),
DEF_SPLSTR( "Indeed" ),
//L"Industrial" ),                           // PaulCa added 4/14/99 (Bug 107)
//L"Information" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Initially" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Instead" ),
DEF_SPLSTR( "Is" ),                                   // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "It" ),
DEF_SPLSTR( "Its" ),
DEF_SPLSTR( "Just" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"King" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Last" ),
DEF_SPLSTR( "Later" ),
DEF_SPLSTR( "Let" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Like" ),
//L"Little" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Many" ),
DEF_SPLSTR( "Maybe" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Meanwhile" ),
DEF_SPLSTR( "More" ),
DEF_SPLSTR( "Moreover" ),
DEF_SPLSTR( "Most" ),
DEF_SPLSTR( "Much" ),
DEF_SPLSTR( "My" ),    // Added to fix bug #385
DEF_SPLSTR( "Neither" ),
DEF_SPLSTR( "Never" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nevertheless" ),
DEF_SPLSTR( "New" ),
DEF_SPLSTR( "Next" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "No" ),
DEF_SPLSTR( "None" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nonetheless" ),                          // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Nor" ),
DEF_SPLSTR( "Not" ),
DEF_SPLSTR( "Nothing" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Now" ),
DEF_SPLSTR( "Of" ),
DEF_SPLSTR( "On" ),
DEF_SPLSTR( "Once" ),
DEF_SPLSTR( "One" ),
DEF_SPLSTR( "Only" ),
DEF_SPLSTR( "Or" ),
DEF_SPLSTR( "Other" ),
DEF_SPLSTR( "Others" ),
DEF_SPLSTR( "Our" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Over" ),
DEF_SPLSTR( "People" ),
DEF_SPLSTR( "Perhaps" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Please" ),                               // PaulCa added 4/14/99 (Bug 107)
//L"President" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Previous" ),                             // PaulCa added 4/14/99 (Bug 107)
//L"Public" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Recent" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Right" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Second" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "See" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Several" ),
DEF_SPLSTR( "She" ),
DEF_SPLSTR( "Shortly" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Similarly" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Since" ),
DEF_SPLSTR( "So" ),
DEF_SPLSTR( "Some" ),
DEF_SPLSTR( "Sometimes" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Soon" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"Special" ),                              // PaulCa added 4/14/99 (Bug 107)
//L"State" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Still" ),
DEF_SPLSTR( "Subsequently" ),                         // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Such" ),
DEF_SPLSTR( "Take" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "That" ),
DEF_SPLSTR( "The" ),
DEF_SPLSTR( "Their" ),
DEF_SPLSTR( "Then" ),
DEF_SPLSTR( "There" ),
DEF_SPLSTR( "Thereafter" ),                           // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Therefore" ),                            // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "These" ),
DEF_SPLSTR( "They" ),
DEF_SPLSTR( "This" ),
DEF_SPLSTR( "Those" ),
DEF_SPLSTR( "Though" ),
DEF_SPLSTR( "Three" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Through" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Thus" ),
DEF_SPLSTR( "To" ),
DEF_SPLSTR( "Today" ),
DEF_SPLSTR( "Two" ),
DEF_SPLSTR( "Under" ),
//L"United" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Unlike" ),                               // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Until" ),
DEF_SPLSTR( "Upon" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"Water" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "We" ),
DEF_SPLSTR( "Well" ),                                 // PaulCa added 4/14/99 (Bug 107)
//L"West" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "What" ),
DEF_SPLSTR( "When" ),
DEF_SPLSTR( "Where" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Whether" ),                              // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Which" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "While" ),
//L"White" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Who" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Why" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Will" ),                                 // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "With" ),
DEF_SPLSTR( "Within" ),
DEF_SPLSTR( "Without" ),                              // PaulCa added 4/14/99 (Bug 107)
//L"Women" ),                                // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yes" ),                                  // PaulCa added 4/14/99 (Bug 107)
DEF_SPLSTR( "Yet" ),
DEF_SPLSTR( "You" ),
DEF_SPLSTR( "Your" ),
};

// When the following abbreviations are followed by an uppercase word, 
// it is unlikely that the uppercase word starts a new sentence.
// 
static const SPLSTR g_Titles[] =
{
DEF_SPLSTR( "Adm." ),
DEF_SPLSTR( "Atty." ),
DEF_SPLSTR( "Bn." ),
DEF_SPLSTR( "Bt." ),
DEF_SPLSTR( "Btss." ),
DEF_SPLSTR( "C.G." ),
DEF_SPLSTR( "Capt." ),
DEF_SPLSTR( "Cdr." ),
DEF_SPLSTR( "Cf." ),  // See "cf." below
DEF_SPLSTR( "Chi." ), // Mr.(?) in India
DEF_SPLSTR( "Col." ),
DEF_SPLSTR( "Com." ),
DEF_SPLSTR( "Comdr." ),
DEF_SPLSTR( "Cpl." ),
DEF_SPLSTR( "Cpt." ),
DEF_SPLSTR( "Ct." ),
DEF_SPLSTR( "D.F." ),
DEF_SPLSTR( "Dr." ),
DEF_SPLSTR( "Drs." ),
DEF_SPLSTR( "Du." ),
DEF_SPLSTR( "E.g." ), // See "e.g." below
DEF_SPLSTR( "Esq." ),
DEF_SPLSTR( "Exc." ),
DEF_SPLSTR( "Fr." ),
DEF_SPLSTR( "Frl." ),
DEF_SPLSTR( "Gen." ),
DEF_SPLSTR( "Gov." ),
DEF_SPLSTR( "H.E." ),
DEF_SPLSTR( "H.H." ),
DEF_SPLSTR( "H.I.H." ),
DEF_SPLSTR( "H.I.M." ),
DEF_SPLSTR( "H.M." ),
DEF_SPLSTR( "H.R.H." ),
DEF_SPLSTR( "H.S.H." ),
DEF_SPLSTR( "Hon." ),
DEF_SPLSTR( "Hr." ),
DEF_SPLSTR( "I.e." ), // See "i.e." below
DEF_SPLSTR( "Km." ),  // Mr. or Ms. (?) in India
DEF_SPLSTR( "L.Cpl." ),
DEF_SPLSTR( "Ld." ),
DEF_SPLSTR( "Lt." ),
DEF_SPLSTR( "M.M." ),
DEF_SPLSTR( "M.Sgt." ),
DEF_SPLSTR( "Maj." ),
DEF_SPLSTR( "Mdm." ),
DEF_SPLSTR( "Messrs." ),
DEF_SPLSTR( "Mgr." ),
DEF_SPLSTR( "Mgrs." ),
DEF_SPLSTR( "Mlle." ),
DEF_SPLSTR( "Mlles." ),
DEF_SPLSTR( "Mme." ),
DEF_SPLSTR( "Mmes." ),
DEF_SPLSTR( "Mr." ),
DEF_SPLSTR( "Mrs." ),
DEF_SPLSTR( "Ms." ),
DEF_SPLSTR( "Msgr." ),
DEF_SPLSTR( "PFC." ),  // Private First Class // Sometimes used with a period
DEF_SPLSTR( "Pfc." ),
DEF_SPLSTR( "Pr." ),
DEF_SPLSTR( "Pres." ),
DEF_SPLSTR( "Prof." ),
DEF_SPLSTR( "R.A." ),
DEF_SPLSTR( "R.R." ),
DEF_SPLSTR( "R.W." ),
DEF_SPLSTR( "Rep." ),
DEF_SPLSTR( "Reps." ),
DEF_SPLSTR( "Rev." ),
DEF_SPLSTR( "S.M.Sgt." ),
DEF_SPLSTR( "S.Sgt." ),
DEF_SPLSTR( "Sen." ),
DEF_SPLSTR( "Sens." ),
DEF_SPLSTR( "Sgt." ),
DEF_SPLSTR( "Sgt.Maj." ),
DEF_SPLSTR( "Smt." ),     // Mr. or Ms. (?) in India
DEF_SPLSTR( "Sow." ),     // Mrs. or Ms. (?) in India
DEF_SPLSTR( "Sr." ),
DEF_SPLSTR( "Sra." ),
DEF_SPLSTR( "Srta." ),
DEF_SPLSTR( "St." ),
DEF_SPLSTR( "Supt." ),
DEF_SPLSTR( "T.Sgt." ),
DEF_SPLSTR( "V.A." ),
DEF_SPLSTR( "V.Adm." ),
DEF_SPLSTR( "Ven." ),
DEF_SPLSTR( "Vis." ),
DEF_SPLSTR( "Visct." ),
};

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\morph.h ===
/*******************************************************************************
* morph.h *
*---------*
*   Description:
*       This is the header file for the CSMorph implementation.  This class 
*   attempts to find pronunciations for morphological variants (which do not
*   occur in the lexicon) of root words (which do occur in the lexicon).  
*-------------------------------------------------------------------------------
*  Created By: AH                            Date: 08/16/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/
#ifndef Morph_h
#define Morph_h

#ifndef __spttseng_h__
#include "spttseng.h"
#endif

// Additional includes...
#include "stdafx.h"
#include "commonlx.h"

//== CONSTANTS ================================================================

#define MAX_POSCONVERSIONS 4
#define NUM_POS 5


/*** SUFFIX_TYPE **************************************************************
* This enumeration contains values for all of the suffixes which can be matched
* and accounted for by the CSMorph class.
*/
static const enum SUFFIX_TYPE
{
    S_SUFFIX = 0,
    ED_SUFFIX,
    ING_SUFFIX,
    APOSTROPHES_SUFFIX,
    APOSTROPHE_SUFFIX,
    ER_SUFFIX,
    EST_SUFFIX,
    OR_SUFFIX,
    MENT_SUFFIX,
    AGE_SUFFIX,
    LESS_SUFFIX,
    Y_SUFFIX,
    EDLY_SUFFIX,
    LY_SUFFIX,
    ABLE_SUFFIX,
    NESS_SUFFIX,
    ISM_SUFFIX,
    IZE_SUFFIX,
    IZ_SUFFIX,
    HOOD_SUFFIX,
    FUL_SUFFIX,
    LIKE_SUFFIX,
    WISE_SUFFIX,
    ISH_SUFFIX,
    ABLY_SUFFIX,
    SHIP_SUFFIX,
    ICALLY_SUFFIX,
    SOME_SUFFIX,
    ILY_SUFFIX,
    ICISM_SUFFIX,
    ICIZE_SUFFIX,
    NO_MATCH = -1,
};


/* SUFFIX_INFO, g_SuffixTable[] ***********************************************
* This table is used to map the orthographic forms of suffixes to their suffix
* types.  Each suffix is stored in reverse order for easier comparison with 
* the ends of strings...
*/
struct SUFFIX_INFO 
{
    WCHAR       Orth[10];
    SUFFIX_TYPE Type;
};

static const SUFFIX_INFO g_SuffixTable[] = 
{ 
    { L"RE",        ER_SUFFIX },
    { L"TSE",       EST_SUFFIX },
    { L"GNI",       ING_SUFFIX },
    { L"ELBA",      ABLE_SUFFIX },
    { L"ELBI",      ABLE_SUFFIX },
    { L"YLDE",      EDLY_SUFFIX },
    { L"YLBA",      ABLY_SUFFIX },
    { L"YLBI",      ABLY_SUFFIX },
    { L"YLLACI",    ICALLY_SUFFIX },
    { L"YLI",       ILY_SUFFIX },
    { L"YL",        LY_SUFFIX },
    { L"Y",         Y_SUFFIX },
    { L"TNEM",      MENT_SUFFIX },
    { L"RO",        OR_SUFFIX },
    { L"SSEN",      NESS_SUFFIX },
    { L"SSEL",      LESS_SUFFIX },
    { L"EZICI",     ICIZE_SUFFIX },
    { L"EZI",       IZE_SUFFIX },
    { L"ZI",        IZ_SUFFIX },
    { L"MSICI",     ICISM_SUFFIX },
    { L"MSI",       ISM_SUFFIX },
    { L"DE",        ED_SUFFIX },
    { L"S'",        APOSTROPHES_SUFFIX },
    { L"S",         S_SUFFIX },
    { L"'",         APOSTROPHE_SUFFIX },
    { L"EGA",       AGE_SUFFIX },
    { L"DOOH",      HOOD_SUFFIX },
    { L"LUF",       FUL_SUFFIX },
    { L"EKIL",      LIKE_SUFFIX },
    { L"ESIW",      WISE_SUFFIX },
    { L"HSI",       ISH_SUFFIX },
    { L"PIHS",      SHIP_SUFFIX },
    { L"EMOS",      SOME_SUFFIX },
};


/*** PHONTYPE *****************************************************************
* This enumeration creates flags which can be used to determine the relevant
* features of each phone.
*/
static const enum PHONTYPE
{	
    eCONSONANTF = (1<<0),
    eVOICEDF = (1<<1),
    ePALATALF = (1<<2),
};


/*** g_PhonTable[], g_PhonS, g_PhonZ *******************************************
* This table is used to map the internal values of phones to their types, which 
* are just clusters of features relevant to the necessary phonological rules.
* g_PhonS, g_PhonZ, g_PhonD, g_PhonT are just used to make the code a bit more
* readable.
*/
static const long g_PhonTable[] = 
{
    eCONSONANTF,                        // Default value - 0 is not a valid phone
    eCONSONANTF,                        // 1 is a syllable boundary - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 2 is an exclamation point - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 3 is a word boundary - treated as a consonant
    eCONSONANTF,                        // 4 is a comma - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 5 is a period - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 6 is a question mark - shouldn't ever occur at the end of a word
    eCONSONANTF,                        // 7 is a silence - shouldn't ever occur at the end of a word
    eVOICEDF,                           // 8 is primary stress - treat as a vowel since it should always be attached to a vowel nucleus
    eVOICEDF,                           // 9 is secondatry stress - see primary stress
    eVOICEDF,                           // 10 -> AA
    eVOICEDF,                           // 11 -> AE
    eVOICEDF,                           // 12 -> AH
    eVOICEDF,                           // 13 -> AO
    eVOICEDF,                           // 14 -> AW
    eVOICEDF,                           // 15 -> AX
    eVOICEDF,                           // 16 -> AY
    eCONSONANTF + eVOICEDF,             // 17 -> b
    eCONSONANTF + ePALATALF,            // 18 -> CH
    eCONSONANTF + eVOICEDF,             // 19 -> d
    eCONSONANTF + eVOICEDF,             // 20 -> DH
    eVOICEDF,                           // 21 -> EH
    eVOICEDF,                           // 22 -> ER
    eVOICEDF,                           // 23 -> EY
    eCONSONANTF,                        // 24 -> f
    eCONSONANTF + eVOICEDF,             // 25 -> g
    eCONSONANTF,                        // 26 -> h
    eVOICEDF,                           // 27 -> IH
    eVOICEDF,                           // 28 -> IY
    eCONSONANTF + eVOICEDF + ePALATALF, // 29 -> JH
    eCONSONANTF,                        // 30 -> k
    eCONSONANTF + eVOICEDF,             // 31 -> l
    eCONSONANTF + eVOICEDF,             // 32 -> m
    eCONSONANTF + eVOICEDF,             // 33 -> n
    eCONSONANTF + eVOICEDF,             // 34 -> NG
    eVOICEDF,                           // 35 -> OW
    eVOICEDF,                           // 36 -> OY
    eCONSONANTF,                        // 37 -> p
    eCONSONANTF + eVOICEDF,             // 38 -> r
    eCONSONANTF,                        // 39 -> s
    eCONSONANTF + ePALATALF,            // 40 -> SH
    eCONSONANTF,                        // 41 -> t
    eCONSONANTF,                        // 42 -> TH
    eVOICEDF,                           // 43 -> UH
    eVOICEDF,                           // 44 -> UW
    eCONSONANTF + eVOICEDF,             // 45 -> v
    eCONSONANTF + eVOICEDF,             // 46 -> w
    eCONSONANTF + eVOICEDF,             // 47 -> y
    eCONSONANTF + eVOICEDF,             // 48 -> z
    eCONSONANTF + eVOICEDF + ePALATALF, // 49 -> ZH
};

static WCHAR g_phonAXl[] = L" AX l";
static WCHAR g_phonAXz[] = L" AX z";
static WCHAR g_phonS[] = L" s";
static WCHAR g_phonZ[] = L" z";
static WCHAR g_phonD[] = L" d";
static WCHAR g_phonAXd[] = L" AX d";
static WCHAR g_phonT[] = L" t";
static WCHAR g_phonIY[] = L" IY";
static WCHAR g_phonL[] = L" l";

/*** struct POS_CONVERT *******************************************************
* This struct stores the From and To parts of speech for a suffix...
*/
struct POS_CONVERT
{
    ENGPARTOFSPEECH FromPos;
    ENGPARTOFSPEECH ToPos;
};

/*** MorphSpecialCaseFlags ****************************************************
* This enum allows DoSuffixMorph to be nearly completely table driven.  Each
* suffix has a MorphSpecialCaseFlags entry in the SuffixInfoTable which tells
* DoSuffixMorph which special case functions (check for missing E, etc.) need
* to be called if the initial lex lookup fails.
*/
typedef enum MorphSpecialCaseFlags
{
    eCheckForMissingE       = 1L << 0,
    eCheckYtoIMutation      = 1L << 1,
    eCheckDoubledMutation   = 1L << 2,
    eCheckForMissingY       = 1L << 3,
    eCheckForMissingL       = 1L << 4,
} MorphSpecialCaseFlags;

/*** struct SUFFIXPRON_INFO ***************************************************
* This struct stores the pronunciation of a suffix, as well as the POS 
* categories it takes as input and output.
*/
struct SUFFIXPRON_INFO 
{
    WCHAR SuffixString[SP_MAX_PRON_LENGTH];
    POS_CONVERT Conversions[MAX_POSCONVERSIONS];
    short NumConversions;
    DWORD dwMorphSpecialCaseFlags;
};

/*** bool SuffixInfoTableInitialized *******************************************
* This bool just lets threads know whether they are the first to use the 
* following table, and thus whether they need to initialize it or not.
*/
static bool SuffixInfoTableInitialized = false;

/*** SUFFIXPRON_INFO g_SuffixInfoTable *****************************************
* This table drives the DoSuffixMorph function, by storing the pronunciation, 
* conversions, number of conversions, and special case flags for each suffix...
*/
static SUFFIXPRON_INFO g_SuffixInfoTable [] =
{
/********************************************************************************************************/
/*    Pronunciation     *  Conversions  *   NumConversions * Special Case Flags      *   SuffixType      */
/********************************************************************************************************/
    { L" s",            { {MS_Verb,   MS_Verb}, 
                          {MS_Noun,   MS_Noun}  },    2,  0 },                          // S_SUFFIX
    { L" d",            { {MS_Verb,   MS_Verb}, 
                          {MS_Verb,   MS_Adj}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ED_SUFFIX
    { L" IH NG",        { {MS_Verb,   MS_Verb}, 
                          {MS_Verb,   MS_Adj},
                          {MS_Verb,   MS_Noun}  },    3,  eCheckForMissingE +
                                                          eCheckDoubledMutation   },    // ING_SUFFIX
    { L" s",            { {MS_Noun,   MS_Noun}  },    1,  0 },                          // APOSTROPHES_SUFFIX
    { L" s",            { {MS_Noun,   MS_Noun}  },    1,  0 },                          // APOSTROPHE_SUFFIX
    { L" ER",           { {MS_Verb,   MS_Noun},
                          {MS_Adj,    MS_Adj}, 
                          {MS_Adv,    MS_Adv}, 
                          {MS_Adj,    MS_Adv}   },    4,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ER_SUFFIX
    { L" AX s t",       { {MS_Adj,    MS_Adj}, 
                          {MS_Adv,    MS_Adv},
                          {MS_Adj,    MS_Adv}   },    3,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // EST_SUFFIX
    { L" ER",           { {MS_Verb,   MS_Noun}  },    1,  eCheckForMissingE +
                                                          eCheckDoubledMutation },      // OR_SUFFIX
    { L" m AX n t",     { {MS_Verb,   MS_Noun}  },    1,  eCheckYtoIMutation },         // MENT_SUFFIX
    { L" IH JH",        { {MS_Verb,   MS_Noun}  },    1,  eCheckForMissingE + 
                                                          eCheckDoubledMutation   },    // AGE_SUFFIX
    { L" l IH s",       { {MS_Noun,   MS_Adj}   },    1,  eCheckYtoIMutation      },    // LESS_SUFFIX
    { L" IY",           { {MS_Noun,   MS_Adj},
                          {MS_Adj,    MS_Adv}   },    2,  eCheckForMissingE +
                                                          eCheckDoubledMutation   },    // Y_SUFFIX
    { L" AX d l IY",    { {MS_Verb,   MS_Adj},
                          {MS_Verb,   MS_Adv}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // EDLY_SUFFIX
    { L" l IY",         { {MS_Noun,   MS_Adj},
                          {MS_Adj,    MS_Adv}   },    2,  eCheckForMissingL },          // LY_XUFFIX
    { L" AX - b AX l",  { {MS_Verb,   MS_Adj},
                          {MS_Noun,   MS_Adj}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ABLE_SUFFIX
    { L" n IH s",       { {MS_Adj,    MS_Noun}  },    1,  eCheckYtoIMutation      },    // NESS_SUFFIX
    { L" IH z AX m",    { {MS_Adj,    MS_Noun},
                          {MS_Noun,   MS_Noun}  },    2,  eCheckForMissingE       },    // ISM_SUFFIX
    { L" AY z",         { {MS_Noun,   MS_Verb}, 
                          {MS_Adj,    MS_Verb}  },    2,  eCheckForMissingE       },    // IZE_SUFFIX
    { L" AY z",         { {MS_Noun,   MS_Verb},
                          {MS_Adj,    MS_Verb}  },    2,  eCheckForMissingE       },    // IZ_SUFFIX
    { L" h UH d",       { {MS_Noun,   MS_Noun}  },    1,  0 },                          // HOOD_SUFFIX
    { L" f AX l",       { {MS_Noun,   MS_Adj},
                          {MS_Verb,   MS_Adj}   },    2,  0 } ,                         // FUL_SUFFIX
    { L" l AY k",       { {MS_Noun,   MS_Adj}   },    1,  0 },                          // LIKE_SUFFIX
    { L" w AY z",       { {MS_Noun,   MS_Adj}   },    1,  eCheckYtoIMutation },                        // WISE_SUFFIX
    { L" IH SH",        { {MS_Noun,   MS_Adj}   },    1,  eCheckForMissingE +
                                                          eCheckDoubledMutation   },    // ISH_SUFFIX
    { L" AX - b l IY",  { {MS_Verb,   MS_Adv},
                          {MS_Noun,   MS_Adv}   },    2,  eCheckForMissingE +
                                                          eCheckYtoIMutation +
                                                          eCheckDoubledMutation   },    // ABLY_SUFFIX
    { L" SH IH 2 p",    { {MS_Noun,   MS_Noun}  },    1,  0 },                          // SHIP_SUFFIX
    { L" L IY",         { {MS_Adj,    MS_Adv}   },    1,  0 },                          // ICALLY_SUFFIX
    { L" S AX M",       { {MS_Noun,   MS_Adj}   },    1,  eCheckYtoIMutation      },    // SOME_SUFFIX
    { L" AX L IY",      { {MS_Noun,   MS_Adv}   },    1,  eCheckDoubledMutation +
                                                          eCheckForMissingY       },    // ILY_SUFFIX
    { L" IH z AX m",    { {MS_Adj,    MS_Noun},
                          {MS_Noun,   MS_Noun}  },    2,  eCheckForMissingE       },    // ICISM_SUFFIX
    { L" AY z",         { {MS_Noun,   MS_Verb}, 
                          {MS_Adj,    MS_Verb}  },    2,  eCheckForMissingE       },    // ICIZE_SUFFIX
};

/*** CSuffixList **************************************************************
* This typedef just makes the code a little easier to read.  A CSuffixList is
* used to keep track of each of the suffixes which has been stripped from a
* word, so that their pronunciations can be concatenated with that of the root.
*/
typedef CSPList<SUFFIXPRON_INFO*, SUFFIXPRON_INFO*> CSuffixList;

/*** CComAutoCriticalSection g_SuffixInfoTableCritSec *************************
* This critical section is used to make sure the SuffixInfoTable only gets
* initialized once.
*/
static CComAutoCriticalSection g_SuffixInfoTableCritSec;

/*** CSMorph ******************************************************************
* This is the definition of the CSMorph class.
*/
class CSMorph
{
public:

    /*=== PUBLIC METHODS =====*/
    CSMorph( ISpLexicon *pMasterLex=0, HRESULT *hr=0 );

    /*=== INTERFACE METHOD =====*/
    HRESULT DoSuffixMorph( const WCHAR *pwWord, WCHAR *pwRoot, LANGID LangID, DWORD dwFlags,
                           SPWORDPRONUNCIATIONLIST *pWordPronunciationList );

private:


    /*=== PRIVATE METHODS =====*/
    SUFFIX_TYPE MatchSuffix( WCHAR *TargWord, long *RootLen );
    HRESULT LexLookup( const WCHAR *pOrth, long length, DWORD dwFlags, 
                       SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT LTSLookup( const WCHAR *pOrth, long length,
                       SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT AccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT AccumulateSuffixes_LTS( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT DefaultAccumulateSuffixes( CSuffixList *pSuffixList, SPWORDPRONUNCIATIONLIST *pWordPronunciationList );

    HRESULT CheckForMissingE( WCHAR *pOrth, long length, DWORD dwFlags,
                              SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckForMissingY( WCHAR *pOrth, long length, DWORD dwFlags,
                              SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT CheckForMissingL( WCHAR *pOrth, long length, DWORD dwFlags,
                              SPWORDPRONUNCIATIONLIST *pWordPronunciationList );
    HRESULT CheckYtoIMutation( WCHAR *pOrth, long length, DWORD dwFlags, 
                               SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckDoubledMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                  SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckYtoIEMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                                SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT CheckAbleMutation( WCHAR *pOrth, long length, DWORD dwFlags,
                               SPWORDPRONUNCIATIONLIST *pWordPronunciationList);
    HRESULT Phon_SorZ( WCHAR *pPronunciation, long length );
    HRESULT Phon_DorED( WCHAR *pPronunciation, long length ); 

    /*=== MEMBER DATA =====*/

    // Pointer to the Master Lexicon...
    ISpLexicon  *m_pMasterLex;
};

inline BOOL SearchPosSet( ENGPARTOFSPEECH Pos, const ENGPARTOFSPEECH *Set, ULONG Count )
{
    for( ULONG i = 0; i < Count; ++i )
    {
        if( Pos == Set[i] )
        {
            return true;
        }
    }
    return false;
}

#endif //--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by spttseng.rc
//
#define IDS_PROJNAME                    100
#define IDR_MSTTSENGINE                 101
#define IDR_MSVOICEDATA                 102
#define IDR_SPTTSENGUI                  103
#define IDD_TTS_ADV                     201
#define IDC_COMMA_PERIOD                201
#define IDC_PERIOD_COMMA                202
#define IDC_MDY                         203
#define IDC_DMY                         204
#define IDC_YMD                         205
#define IDRESTORE                       254

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         204
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\pitchprosody.cpp ===
/******************************************************************************
* PitchProsody.cpp *
*--------------------*
*
*  This is an implementation of the PitchProsody class.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 04/28/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

//--- Additional includes
#include "stdafx.h"

#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif


//-----------------------------
// Data.cpp
//-----------------------------
extern const float   g_PitchScale[];



//--------------------------------
// Interpolation direction
//--------------------------------
enum INTERP_DIR
{
    GOING_UP,
    GOING_DOWN,
};


#define M_PI		3.14159265358979323846
#define	MAX_ORDER		4096


class CFIRFilter 
{
public:
	//-------------------------------------------------
	// Methods
	//-------------------------------------------------
	void	Make_Filter( float freq1, long order, float srate );
	void	DoFilter (float *src, float *dst, long len);

	void	Design_Lowpass (float freq);
	//-------------------------------------------------
	// Member Variables
	//-------------------------------------------------
	float			m_Coeff[MAX_ORDER];
	float			m_SRate;
	long			m_Order;
	long			m_HalfOrder;
};




//-----------------------------------------------
// Design a low pass filter 
//-----------------------------------------------
void	CFIRFilter::Design_Lowpass (float freq)
{
	float		half_Filt[MAX_ORDER];
	double		w;
	long		i;
	
	
	//----------------------------------------------------------
	// generate one half of coefficients from sinc() function
	//----------------------------------------------------------
	w = 2.0 * M_PI * freq;
	half_Filt[0] = (float)(w / M_PI);
	for (i = 1; i <= m_HalfOrder; i++)
	{
		half_Filt[i] = (float)(sin(i * w) / (i * M_PI));
	}
	
	//----------------------------------------------------------
	// window with (half-)hamming window 
	//----------------------------------------------------------
	for (i = 0; i <= m_HalfOrder; i++)
	{
		half_Filt[i] *= (float)(0.54 + 0.46 * cos(i * M_PI / m_HalfOrder));
	}
	
	//----------------------------------------------------------
	// copy as symmetric filter
	//----------------------------------------------------------
	for (i = 0; i < m_Order; i++)
	{
		m_Coeff[i] = half_Filt[abs(m_HalfOrder - i)];
	}
	
}




//-----------------------------------------------
// Do the filtering
//-----------------------------------------------
void	CFIRFilter::DoFilter (float *src, float *dst, long len)
{
#define     kWakeSamples    1000;
	long			i,j;
	float			*sp;
	float			sum;
	long			lenAdj;
	
	lenAdj = len - m_Order;
	if (lenAdj >= 0)
	{
		for (i = 0; i < m_HalfOrder; i++) 
		{
			*dst++ = src[0];
		}
		
		for (i = 0; i < lenAdj; i++) 
		{
			sum = (float)0.0;
			sp = src + i;
			for (j = 0; j < m_Order; j++)
			{
				sum += ((float)*sp++) * m_Coeff[j];
			}
			*dst++ = sum;

		}
		
		for (i = 0; i < m_HalfOrder; i++) 
		{
			*dst++ = src[len-1];
		}
	}
}







void	CFIRFilter::Make_Filter( float freq1, long order, float srate )
{
	m_SRate		= srate;
	m_Order		= order;
	m_HalfOrder	= m_Order / 2;

	Design_Lowpass (freq1 / m_SRate);
}





/*****************************************************************************
* HzToOct *
*---------*
*   Description:
*   Convert liner freq ro exp pitch
*   0.69314718 is log of 2 
*   1.021975 is offset for middle C
*       
********************************************************************** MC ***/
float HzToOct( float cps)
{
    SPDBG_FUNC( "HzToOct" );

    return (float)(log(cps / 1.021975) / 0.69314718);
    
} /* HzToOct */

/*****************************************************************************
* OctToHz *
*---------*
*   Description:
*       Convert from exp pitch to linear freq
********************************************************************** MC ***/
float OctToHz( float oct)
{
    SPDBG_FUNC( "OctToHz" );

    return (float)(pow(2, oct) * 1.021975);
} /* OctToHz */



/*****************************************************************************
* CPitchProsody::DoPitchControl *
*-------------------------------*
*   Description:
*   Scale speech pitch to user control
*       
********************************************************************** MC ***/
float CPitchProsody::DoPitchControl( long pitchControl, float basePitch )
{
    SPDBG_FUNC( "CPitchProsody::DoPitchControl" );
    float   newPitch;

    if( pitchControl < 0 )
    {
        //--------------------------------
        // DECREASE the pitch
        //--------------------------------
        if( pitchControl < MIN_USER_PITCH )
        {
            pitchControl = MIN_USER_PITCH;        // clip to min
        }
        newPitch = (float)basePitch / g_PitchScale[0 - pitchControl];
    }
    else
    {
        //--------------------------------
        // INCREASE the pitch
        //--------------------------------
        if( pitchControl > MAX_USER_PITCH )
        {
            pitchControl = MAX_USER_PITCH;        // clip to max
        }
        newPitch = (float)basePitch * g_PitchScale[pitchControl];
    }
    return newPitch;
} /* CPitchProsody::DoPitchControl */





/*****************************************************************************
* CPitchProsody::SetDefaultPitch *
*--------------------------------*
*   Description:
*   Init pitch knots to monotone in case there's a failure in this object.
*       
********************************************************************** MC ***/
void CPitchProsody::SetDefaultPitch()
{
    SPDBG_FUNC( "CPitchProsody::SetDefaultPitch" );
    CAlloCell   *pCurCell;

	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        float       relTime, timeK;
        float       normalPitch;
        long        knot;

        normalPitch = pCurCell->m_Pitch_LO + ((pCurCell->m_Pitch_HI - pCurCell->m_Pitch_LO) / 2);
        timeK = pCurCell->m_ftDuration / KNOTS_PER_PHON;
        relTime = 0;
        for( knot = 0; knot < KNOTS_PER_PHON; knot++ )
        {
            pCurCell->m_ftPitch[knot] = normalPitch;
            pCurCell->m_ftTime[knot] = relTime;
            relTime += timeK;
        }
		pCurCell = m_pAllos->GetNextCell();
    }
} /* CPitchProsody::SetDefaultPitch */


/*****************************************************************************
* CPitchProsody::AlloPitch *
*--------------------------*
*   Description:
*   Tag pitch highlights
*       
********************************************************************** MC ***/
void CPitchProsody::AlloPitch( CAlloList *pAllos, float baseLine, float pitchRange )
{
    SPDBG_FUNC( "CAlloOps::AlloPitch" );
    CAlloCell   *pCurCell;
    bool        skipInitialSil;
    long        quantTotal, index;
    
    m_pAllos = pAllos;
    m_numOfCells = m_pAllos->GetCount();
    m_Tune_Style = DESCEND_TUNE;        // NOTE: maybe set from rules
    m_TotalDur = 0;
    quantTotal = 0;
    m_OffsTime = 0;
    skipInitialSil = true;


   //------------------------------
    // Calculate total duration
    // (exclude surrounding silence)
    //------------------------------
	index = 0;
	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        if( (skipInitialSil) && (pCurCell->m_allo == _SIL_) )
        {
            //---------------------------------
            // Skip leading silence
            //---------------------------------
            m_OffsTime += pCurCell->m_ftDuration;
        }
        else if( (index == (m_numOfCells -1)) && (pCurCell->m_allo == _SIL_) )
        {
            //---------------------------------
            // Skip term silence
            //---------------------------------
            break;
        }
        else
        {
            pCurCell->m_PitchBufStart = quantTotal;
            m_TotalDur += pCurCell->m_ftDuration;
            quantTotal = (long)(m_TotalDur / PITCH_BUF_RES);
            pCurCell->m_PitchBufEnd = quantTotal;
            skipInitialSil = false;
        }
		index++;
		pCurCell = pAllos->GetNextCell();
    }

    //------------------------------
    // Init pitch range
    //------------------------------
	pCurCell = m_pAllos->GetHeadCell();
    while( pCurCell )
    {
        float   hzVal, pitchK, rangeTemp;

        //---------------------------------------
        // Scale to possible pitch control
        //---------------------------------------
		rangeTemp = pitchRange * pCurCell->m_PitchRangeScale;
		
        hzVal = DoPitchControl( pCurCell->m_user_Pitch, baseLine );
        pitchK = HzToOct( hzVal ) + pCurCell->m_PitchBaseOffs;
        pCurCell->m_Pitch_HI = OctToHz( pitchK + rangeTemp );
        pCurCell->m_Pitch_LO = OctToHz( pitchK - rangeTemp );

		pCurCell = pAllos->GetNextCell();
    }

    //--------------------------------------------
    // In case we fail somewhere, set values to 
    // a known valid state (monotone).
    //--------------------------------------------
    SetDefaultPitch();

    if( m_TotalDur > 0 )
    {
        //--------------------------------------------
        // Generate pitch targets
        //--------------------------------------------
        PitchTrack();
    }

} /* CPitchProsody::AlloPitch */











/*****************************************************************************
* LineInterpContour  *
*--------------------*
*   Description:
*   Does linear interpolation over the pitch contour
*       
********************************************************************** MC ***/
void	LineInterpContour( long cNumOfPoints, float *pPoints )
{
    SPDBG_FUNC( "LineInterpContour" );
    long endAnch,startAnch, i;
    float bPoint1, ePoint1;
    
    
    //----------------------------------------------------
    // Scan forward from beginning to find 1st non-zero enrty
    // Use it as the START point.
    //----------------------------------------------------
    for( startAnch = 0; startAnch < cNumOfPoints; startAnch++ )
    {
        if( pPoints[startAnch] != 0 )
        {
            break;
        }
    }
    bPoint1 = pPoints[startAnch];
    
    
    //----------------------------------------------------
    // Scan back from end to find 1st non-zero enrty
    // Use it as the END point.
    //----------------------------------------------------
    for( endAnch = cNumOfPoints-1; endAnch >= 0; endAnch-- )
    {
        if( pPoints[endAnch] != 0 )
        {
            break;
        }
    }
    ePoint1 = pPoints[endAnch];
    
    
    long firstp = 0;
    long lastp = 0;
    
    while( firstp < cNumOfPoints )
    {
        //-------------------------------------------
        // Find beginning and end of current section
        //-------------------------------------------
        while( pPoints[firstp] != 0 )
        {
            if( ++firstp >= cNumOfPoints-1 ) 
            {
                break;
            }
        }
		if( firstp >= cNumOfPoints-1 )
		{
			//--------------------------------------
			// There's nothing to interpolate!
			//--------------------------------------
			break;
		}


        lastp = firstp+1;
        while( pPoints[lastp] == 0 )
        {
            if( ++lastp >= cNumOfPoints ) 
            {
				lastp = cNumOfPoints;
                break;
            }
        }
        lastp--;

        if( lastp >= firstp )
        {
            if( (lastp >= cNumOfPoints) || (firstp >= cNumOfPoints) ) 
            {
                break;
            }
            //-------------------------------------------
            // Do the interpolate
            //-------------------------------------------
            float bPoint,ePoint;
            if( firstp == 0 ) 
            {
                bPoint = bPoint1;
            }
            else 
            {
                bPoint = pPoints[firstp - 1];
            }
            
            if( lastp == cNumOfPoints-1 ) 
            {
                ePoint = ePoint1;
            }
            else 
            {
                ePoint = pPoints[lastp + 1];
            }
            
            float pointSpread = ePoint - bPoint;
            float timeSpread = (float) ((lastp - firstp)+2);
            float inc = pointSpread / timeSpread;
            float theBase = bPoint;
            for( i = firstp; i <= lastp; i++ )
            {
                theBase += inc;
                pPoints[i] = theBase;
            }
        }
        else 
        {
            pPoints[firstp] = pPoints[lastp+1];
        }
        firstp = lastp+1;
    }
} /* LineInterpContour */








/*****************************************************************************
* Interpolate2  *
*---------------*
*   Description:
*    Do a 2nd order interpolation, a little nicer than just linear
*       
********************************************************************** MC ***/
void Interpolate2( INTERP_DIR direction, float *m_theFitPoints, long theStart, long len, float theAmp, float theBase)
{
    SPDBG_FUNC( "Interpolate2" );
	long    midPoint = len / 2;
    long    i;

	theAmp -= theBase;

	for( i = theStart; i < theStart + len;i++ )
	{
		if (direction == GOING_UP)
		{
			if( i < theStart + midPoint )
			{
				m_theFitPoints[i] = theBase +
				(2 * theAmp) * ((((float)i - (float)theStart) / (float)len) * 
													(((float)i - (float)theStart) / (float)len));
			}
			else
			{
				m_theFitPoints[i] = (theBase + theAmp) - 
				((2 * theAmp) * ((1 - ((float)i - (float)theStart) / (float)len) * 
										(1 - ((float)i - (float)theStart) / (float)len)));
			}
		}
		else if( direction == GOING_DOWN ) 
		{

			if( i < theStart + midPoint )
			{
				m_theFitPoints[i] = theBase +
				theAmp - (2 * theAmp) * ((((float)i - (float)theStart) / (float)len) * 
													(((float)i - (float)theStart) / (float)len));
			}
			else
			{
				m_theFitPoints[i] = theBase + 
				(2 * theAmp) * ((1 - ((float)i - (float)theStart) / (float)len) * 
										(1 - ((float)i - (float)theStart) / (float)len));
			}
		} 
	}
} /* Interpolate2 */




/*****************************************************************************
* SecondOrderInterp  *
*--------------------*
*   Description:
*   Does 2nd order interpolation over the pitch contour
*       
********************************************************************** MC ***/
void SecondOrderInterp( long cNumOfPoints, float *pPoints )
{
    SPDBG_FUNC( "SecondOrderInterp" );
	long    endAnch,startAnch;
	float   bPoint1, ePoint1;


    //----------------------------------------------------
    // Scan forward from beginning to find 1st non-zero enrty
    // Use it as the START point.
    //----------------------------------------------------
    for( startAnch = 0; startAnch < cNumOfPoints; startAnch++ )
    {
        if( pPoints[startAnch] != 0 )
        {
            break;
        }
    }
    bPoint1 = pPoints[startAnch];
    
    
    //----------------------------------------------------
    // Scan back from end to find 1st non-zero enrty
    // Use it as the END point.
    //----------------------------------------------------
    for( endAnch = cNumOfPoints-1; endAnch >= 0; endAnch-- )
    {
        if( pPoints[endAnch] != 0 )
        {
            break;
        }
    }
    ePoint1 = pPoints[endAnch];


    long    firstp = 0;
	long    lastp = 0;

	while( firstp < cNumOfPoints-1 )
	{

        //------------------------------------------------
		// Find beginning and end of current section
        //------------------------------------------------
		while( pPoints[firstp] != 0 )
		{
			if( ++firstp >= cNumOfPoints-1 ) 
            {
                break;
            }
		}
		if( firstp >= cNumOfPoints-1 )
		{
			//--------------------------------------
			// There's nothing to interpolate!
			//--------------------------------------
			break;
		}

		lastp = firstp + 1;
		while( pPoints[lastp] == 0 )
		{
			if( ++lastp >= cNumOfPoints ) 
            {
				lastp = cNumOfPoints;
                break;
            }
		}
		lastp--;

		if( lastp >= firstp )
		{
			if( (lastp >= cNumOfPoints) || (firstp >= cNumOfPoints) ) 
            {
                break;
            }

            //--------------------------------
			// Do the interpolate
            //--------------------------------
			float   bPoint, ePoint;

			if( firstp == 0 ) 
            {
                bPoint = bPoint1;
            }
			else 
            {
                bPoint = pPoints[firstp - 1];
            }

            long    theIndex = lastp + 1;

			if( lastp == cNumOfPoints-1 ) 
            {
                ePoint = ePoint1;
            }
			else 
            {
                ePoint = pPoints[theIndex];
            }

            //--------------------------------
            // call the 2nd order routine
            //--------------------------------
            if( ePoint - bPoint > 0 )
            {
                Interpolate2( GOING_UP, pPoints, firstp, (lastp - firstp) + 1, ePoint, bPoint );
            }
            else
            {
                Interpolate2( GOING_DOWN, pPoints, firstp, (lastp - firstp) + 1, bPoint, ePoint );
            }

		}
		else 
        {
            pPoints[firstp] = pPoints[lastp+1];
        }

		firstp = lastp+1;
	}

	//---------------------------------
	// FIR Filter
	//---------------------------------
	/*CFIRFilter		filterObj;
	float			*pOrig;


    pOrig = new float[cNumOfPoints];
	memcpy( pOrig, pPoints, cNumOfPoints * sizeof(float));
	if( pOrig )
	{
		filterObj.Make_Filter(	5,		// Freq	
								10,		// order
								100		// SR 
								);
		filterObj.DoFilter( pOrig, pPoints, cNumOfPoints);
        delete pOrig;
	}*/

	//---------------------------------
	// IIR Filter
	//---------------------------------
#define kPointDelay		1

	float		filter_Out1, filter_In_Gain, filter_FB_Gain;
	float		lastPoint;
	long		i;

	//--------------------------------------------------
	// Skip filter if audio len less than delay
	//--------------------------------------------------
	if( cNumOfPoints > kPointDelay )
	{
		filter_In_Gain = 0.10f;
		filter_FB_Gain = 1.0f - filter_In_Gain;
		filter_Out1 = pPoints[0];
		for( i = 0; i < cNumOfPoints; i++ )
		{
			filter_Out1 = 	(filter_In_Gain * pPoints[i]) + (filter_FB_Gain * filter_Out1);
			pPoints[i] = filter_Out1;
		}
		for( i = kPointDelay; i < cNumOfPoints; i++ )
		{
			pPoints[i-kPointDelay] = pPoints[i];
		}
		i = (cNumOfPoints - kPointDelay) -1;
		lastPoint = pPoints[i++];
		for( ; i < cNumOfPoints; i++ )
		{
			pPoints[i] = lastPoint;
		}
	}
} /* SecondOrderInterp */

/*****************************************************************************
* CPitchProsody::NewTarget  *
*---------------------------*
*   Description:
*   Insert pitch target into 'm_pContBuf'
*       
********************************************************************** MC ***/
void CPitchProsody::NewTarget( long index, float value )
{
    SPDBG_FUNC( "CPitchProsody::NewTarget" );

    m_pContBuf[index] = value;

    //--- Debug Macro - add pitch to target list for later debugging output
    TTSDBG_ADDPITCHTARGET( m_OffsTime + (PITCH_BUF_RES * index), value, m_CurAccent );

} /* CPitchProsody::NewTarget */


/*****************************************************************************
* CPitchProsody::GetKnots *
*-------------------------*
*   Description:
*   Assign pitch knots based on entries in a contour buffer.
*       
********************************************************************** MC ***/
void CPitchProsody::GetKnots ()
{
    SPDBG_FUNC( "CPitchProsody::GetKnots" );
    CAlloCell   *pCurCell;
    float       distK, scale;
    float       pitchRange;
    long        knot, loc, index;
    bool        skipInitialSil;

    skipInitialSil = true;
	pCurCell = m_pAllos->GetHeadCell();
	index = 0;
    while( pCurCell )
    {
		if( index >= m_numOfCells-1 )
		{
			//-----------------------
			// Skip last allo
			//-----------------------
			break;
		}
        if( (!skipInitialSil) || (pCurCell->m_allo != _SIL_) )
        {
            pitchRange = pCurCell->m_Pitch_HI - pCurCell->m_Pitch_LO;
            distK = 1.0f / KNOTS_PER_PHON;
            scale = 0;
            for( knot = 0; knot < KNOTS_PER_PHON; knot++ )
            {
                loc = pCurCell->m_PitchBufStart + (long)((pCurCell->m_PitchBufEnd - pCurCell->m_PitchBufStart) * scale);
                pCurCell->m_ftPitch[knot] =  pCurCell->m_Pitch_LO + (m_pContBuf[loc] * pitchRange);
                pCurCell->m_ftTime[knot] = scale * pCurCell->m_ftDuration;
                scale += distK;
            }
            skipInitialSil = false;
        }
		pCurCell = m_pAllos->GetNextCell();
		index++;
    }
} /* CPitchProsody::GetKnots */


/*****************************************************************************
* CPitchProsody::PitchTrack  *
*----------------------------*
*   Description:
*   Tag pitch highlights
*       
********************************************************************** MC ***/
void CPitchProsody::PitchTrack()
{
    SPDBG_FUNC( "CPitchProsody::PitchTrack" );
    long        i;
    CAlloCell   *pCurCell, *pNextCell;
    bool        initialWord;      // 1st word in phrase
    long        wordCntDwn;
    float       curProm;          // Current accent prominence
    long        cNumOfPoints;
    float       *pRefBuf, *pCeilBuf, *pFloorBuf;
    float       lastProm;
    long        loc;
    float       value;

    pRefBuf = pCeilBuf = pFloorBuf = m_pContBuf = NULL;
    cNumOfPoints = (long)(m_TotalDur / PITCH_BUF_RES);
    pRefBuf = new float[cNumOfPoints];
    pCeilBuf = new float[cNumOfPoints];
    pFloorBuf = new float[cNumOfPoints];
    m_pContBuf = new float[cNumOfPoints];

    if( pRefBuf && pCeilBuf && pFloorBuf && m_pContBuf)
    {
        //--------------------------------------------
        // Initialize buffers to zero
        //--------------------------------------------
        for (i = 0; i < cNumOfPoints; i++)
        {
            pCeilBuf[i] = 0;
            pFloorBuf[i] = 0.00001f;
            pRefBuf[i] = 0;
            m_pContBuf[i] = 0;
        }

        //--------------------------------------------
        // Linear CEILING slope
        //--------------------------------------------
        if( m_Tune_Style == DESCEND_TUNE )
        {
            pCeilBuf[0] = 1.0;
            pCeilBuf[cNumOfPoints-1] = 0.70f;
            ::LineInterpContour( cNumOfPoints, pCeilBuf );
        }
        else if  (m_Tune_Style == ASCEND_TUNE)
        {
            pCeilBuf[0] = 0.9f;
            pCeilBuf[cNumOfPoints-1] = 1.0f;
            ::LineInterpContour( cNumOfPoints, pCeilBuf );
        }
        else if  (m_Tune_Style == FLAT_TUNE)
        {
           pCeilBuf[0] = 1.0f;
           pCeilBuf[cNumOfPoints-1] = 1.0f;
           ::LineInterpContour( cNumOfPoints, pCeilBuf );
        }

        //--------------------------------------------
        // Linear REFERENCE slope
        //--------------------------------------------
        pRefBuf[0] = (float) (pFloorBuf[0] + (pCeilBuf[0] - pFloorBuf[0]) * 0.33f);
        pRefBuf[cNumOfPoints-1] = (float) (pFloorBuf[0] + (pCeilBuf[cNumOfPoints-1] - pFloorBuf[cNumOfPoints-1]) * 0.33f);
        ::LineInterpContour( cNumOfPoints,pRefBuf );

        //--------------------------------------------
        // Final contour buffer
        //--------------------------------------------
        m_pContBuf[0] = pRefBuf[0];
        m_pContBuf[cNumOfPoints-1] = 0.0001f;		// Something very small


        long    iPrevBegin, iPrevEnd, iCurBegin; 
        long    iCurEnd, iNextBegin, iNextEnd;
		float	cCurLen;
        long	iCellindex;

        initialWord = true;
		iCellindex = 0;
		pCurCell = m_pAllos->GetHeadCell();
        while( pCurCell->m_allo == _SIL_ )
        {
            //---------------------------------
            // Skip leading silence
            //---------------------------------
            pCurCell = m_pAllos->GetNextCell();
			iCellindex++;
        }
        wordCntDwn  = 1;                // Skip 1st word
        lastProm = 0;
        iPrevBegin = iPrevEnd = 0;

		pNextCell = m_pAllos->GetNextCell();
        while( pCurCell )
        {
			if( iCellindex >= m_numOfCells-1 )
			{
				//-----------------------
				// Skip last allo
				//-----------------------
				break;
			}
            //-----------------------------------
            // Get CURRENT allo
            //-----------------------------------
            iCurBegin = pCurCell->m_PitchBufStart;
            iCurEnd = pCurCell->m_PitchBufEnd;
			cCurLen = (float)(iCurEnd - iCurBegin);
            curProm = pCurCell->m_Accent_Prom * (float)0.1;

            //-----------------------------------
            // Get NEXT allo
            //-----------------------------------
            iNextBegin = pNextCell->m_PitchBufStart;
            iNextEnd = pNextCell->m_PitchBufEnd;

            m_CurAccent = pCurCell->m_ToBI_Accent;
			//---------------------
			// Diagnostic
			//---------------------
            m_CurAccentSource = pCurCell->m_AccentSource;
            m_CurBoundarySource = pCurCell->m_BoundarySource;
            m_pCurTextStr = pCurCell->m_pTextStr;

            switch( pCurCell->m_ToBI_Accent )
            {
                case K_RSTAR:
                    break;

                case K_HSTAR:
                    {
                        if( !initialWord )        // We never add a 'leg' to a phrase-initial word
                        {
                            //----------------------------------------------
                            // Add a L leg to start to previous allo
                            //----------------------------------------------
                            if( iPrevBegin )
                            {
								loc = (long) ((iCurBegin + (cCurLen * 0.1f)));
						        value = ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);    // H*
                                value = pRefBuf[loc] + (value * 0.25f);    // L+H*
                                NewTarget( iPrevBegin, value );
                                //NewTarget( loc, value );
                            }
                        }
                        //----------------------------------------------
                        // Now plug in the H target
						//
						// If we're at a boundary, insert H at 
						// allo mid-point else insert at allo start
                        //----------------------------------------------
				        if( pCurCell->m_ToBI_Boundary != K_NOBND )
                        {
                            //---------------------------
                            // Insert H* at allo start 
                            //---------------------------
                            loc = (long) iCurBegin;
                        }
                        else 
                        {
                            //---------------------------
                            // Insert H* at allo mid-point 
                            //---------------------------
					        loc = (long) (iCurBegin + (cCurLen * K_HSTAR_OFFSET));
                        }
                        value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);    // H*
                        NewTarget( loc, value );
                    }
                    break;

            case K_LSTAR:
                {
					//------------------------------------
					// Insert L* at mid-point
					//------------------------------------
                    loc = (long) (iCurBegin + (cCurLen * 0.3f));
                    value = pRefBuf[loc] - ((pRefBuf[loc] - pFloorBuf[loc]) * curProm);   // L*
                    NewTarget( loc, value );
                }
                break;

            case K_LSTARH:
                {
					//----------------------------------------------
					// Insert L* at current start
					//----------------------------------------------
                    value = pRefBuf[iCurBegin] - ((pRefBuf[iCurBegin] - pFloorBuf[iCurBegin]) * curProm);   // L*+H
                    NewTarget( iCurBegin, value );
                    if( iNextBegin )
                    {
						//----------------------------------------------
						// Insert H at next end
						// set prom gain?
						//----------------------------------------------
                        value = pRefBuf[iNextEnd] - ((pRefBuf[iNextEnd] - pFloorBuf[iNextEnd])  * (curProm /* * .3 */ ));
                        NewTarget( iNextEnd, value );
                    }
                    lastProm = 0;
                }
                break;

            case K_LHSTAR:
                {
                    loc = (long) (iCurBegin + (cCurLen * 0.3f));
                    if( iPrevBegin )
                    {
						//----------------------------------------------
						// Insert L at previous start
						//----------------------------------------------
                        value = (pRefBuf[iPrevBegin] - ((pRefBuf[iPrevBegin] - pFloorBuf[iPrevBegin]) * (curProm * 0.3f)));    // L+H*
                        NewTarget( iPrevBegin, value );
                    }
					//----------------------------------------------
					// Insert H* at current mid-point
					//----------------------------------------------
                    value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);         // H*
                    NewTarget( loc, value );
                    lastProm = curProm;
                }
                break;

            case K_HSTARLSTAR:
                {
                    //value = pRefBuf[iCurBegin] + ((pCeilBuf[iCurBegin] - pRefBuf[iCurBegin]) * curProm);         // H*
                    value = pRefBuf[0] + ((pCeilBuf[0] - pRefBuf[0]) * curProm);         // H*
                    NewTarget( iCurBegin, value );

                    loc = (long) (iCurBegin + (cCurLen * 0.75f));
                    value = pRefBuf[loc] - ((pRefBuf[loc] - pFloorBuf[loc]) * curProm);   // L*
                    NewTarget( loc, value );
                    lastProm = curProm;
                }
                break;
            case K_DHSTAR:
                {
                    loc = (long) ( iCurBegin + (cCurLen * 0.0f) );
                    if( lastProm )
                    {
                        lastProm *= K_HDOWNSTEP_COEFF;
                        value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * lastProm);   // !H*
                        NewTarget( loc, value );
                    }
                    //-----------------------------------------
                    // no previous H*, treat !H* like an H*
                    //-----------------------------------------
                    else 
                    {
                        value = pRefBuf[loc] + ((pCeilBuf[loc] - pRefBuf[loc]) * curProm);      // H*
                        NewTarget( loc, value );
                        lastProm = curProm;
                    }
                }
                break;

            default:        // Unknown accent specfied
                break;
            }

            //-------------------------------------------------------------
            // if there's a boundary, fill in pitch value(s)
            // assume the boundary is set to correct (voiced) final phone
            //-------------------------------------------------------------
            curProm = pCurCell->m_Boundary_Prom * (float)0.1;
            m_CurAccent =(TOBI_ACCENT) pCurCell->m_ToBI_Boundary;
			//---------------------
			// Diagnostic
			//---------------------
            m_CurAccentSource = pCurCell->m_AccentSource;
            m_CurBoundarySource = pCurCell->m_BoundarySource;
            m_pCurTextStr = pCurCell->m_pTextStr;
            switch( pCurCell->m_ToBI_Boundary )
            {
                case K_LMINUS:
                    {
                        value = pRefBuf[iCurEnd] - ((pRefBuf[iCurEnd] - pFloorBuf[iCurEnd]) * curProm);			// L-
                        NewTarget( iCurEnd, value );
                    }
                    break;

                case K_HMINUS:
                    {
                        value = pRefBuf[iCurEnd] + ((pCeilBuf[iCurEnd] - pRefBuf[iCurEnd]) * curProm);			// H-
                        NewTarget( iCurEnd, value );
                    }
                    break;

                //case K_LPERC:
                //case K_HPERC:

                case K_LMINUSLPERC:
                    {
                        value = pFloorBuf[iCurEnd];
                        //NewTarget( iCurEnd, value );
                        NewTarget( iCurBegin, value );
                    }
                    break;

                case K_HMINUSHPERC:
                    {
                        value = pCeilBuf[iCurEnd];
                        NewTarget( iCurEnd, value );
                    }
                    break;

                case K_LMINUSHPERC:																// L-H%
                    {
                        //---------------------------------------
                        // comma continuation rise
                        //---------------------------------------
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						// L starts at middle of previous phon
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        loc = iPrevBegin + (iPrevEnd - iPrevBegin) / 2;
                        value = pRefBuf[loc] - ((pRefBuf[loc] - pFloorBuf[loc]) * curProm);         // L-
                        NewTarget( loc, value );
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
						// H at end of current phon
						//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                        value = pRefBuf[iCurEnd] + ((pCeilBuf[iCurEnd] - pRefBuf[iCurEnd]) * curProm);          // H%
                        NewTarget( iCurEnd, value );
                    }
                    break;

                case K_HMINUSLPERC:
                    {
                        //---------------------------------------
                        // accent extension followed by sharp drop
                        //---------------------------------------
                        value = pRefBuf[iCurBegin] + ((pCeilBuf[iCurBegin] - pRefBuf[iCurBegin]) * curProm);          // H-
                        NewTarget( iCurBegin, value );
                        value = pFloorBuf[iCurEnd];													// L%
                        //loc = iCurBegin + ((iCurEnd - iCurBegin) * 0.1f);
                        NewTarget( iCurEnd, value );
                    }
                    break;

                default:
                    break;
            }
            //----------------------------
            // Unflag initial word
            //----------------------------
            if( (initialWord) && (pCurCell->m_ctrlFlags & WORD_START) )
            {
                wordCntDwn--;
                if( wordCntDwn < 0 )
                {
                    initialWord = false;
                }
            }

            //----------------------------
            // Setup for next allo
            //----------------------------
            iPrevBegin = iCurBegin;
            iPrevEnd = iCurEnd;

			pCurCell	= pNextCell;
			pNextCell	= m_pAllos->GetNextCell();
			iCellindex++;
        }

        //--- Debug Macro - Log pitch data to stream
        TTSDBG_LOGTOBI;

        ::SecondOrderInterp( cNumOfPoints, m_pContBuf );
        GetKnots();
    }

    if( pRefBuf )
    {
        delete pRefBuf;
    }
    if( pCeilBuf )
    {
        delete pCeilBuf;
    }
    if( pFloorBuf )
    {
        delete pFloorBuf;
    }
    if( m_pContBuf )
    {
        delete m_pContBuf;
    }
} /* CPitchProsody::PitchTrack */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\numnorm.cpp ===
/***********************************************************************************************
* NumNorm.cpp *
*-------------*
*  Description:
*   These functions normalize ordinary ordinal and cardinal numbers
*-----------------------------------------------------------------------------------------------
*  Created by AH                                                                August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

/***********************************************************************************************
* IsNumberCategory *
*------------------*
*   Description:
*       Checks the next token in the text stream to determine if it is a number category -
*   percents, degrees, squared and cubed numbers, and plain old numbers get matched here.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumberCategory( TTSItemInfo*& pItemNormInfo, const WCHAR* Context,
                                        CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

    TTSItemInfo *pNumberInfo = NULL;
    hr = IsNumber( pNumberInfo, Context, MemoryManager );
    if ( SUCCEEDED( hr )                 &&
         pNumberInfo->Type != eDATE_YEAR &&
         ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar == m_pEndOfCurrItem - 1 )
    {
        if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'%' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_PERCENT;
        }
        else if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_DEGREES;
        }
        else if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_SQUARED;
        }
        else if ( *( ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar ) == L'' )
        {
            pItemNormInfo = pNumberInfo;
            pItemNormInfo->Type = eNUM_CUBED;
        }
        else
        {
            hr = E_INVALIDARG;
            delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
        }
    }
    else if ( SUCCEEDED( hr ) &&
              ( pNumberInfo->Type == eDATE_YEAR ||
                ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar == m_pEndOfCurrItem ) )
    {
        pItemNormInfo = pNumberInfo;
    }
    else if ( SUCCEEDED( hr ) )
    {
        hr = E_INVALIDARG;

        if ( pNumberInfo->Type != eDATE_YEAR )
        {
            delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
        }

        m_pNextChar      = pTempNextChar;
        m_pEndChar       = pTempEndChar;
        m_pEndOfCurrItem = pTempEndOfItem;
        m_pCurrFrag      = pTempFrag;
    }

    return hr;
} /* IsNumberCategory */

/***********************************************************************************************
* IsNumber *
*----------*
*   Description:
*       Checks the next token in the text stream to determine if it is a number.
*
*   RegExp:
*       [-]? { d+ || d(1-3)[,ddd]+ } { { .d+ } || { "st" || "nd" || "rd" || "th" } }?
*   It is actually a bit more complicated than this - for instance, the ordinal
*   strings may only follow certain digits (1st, 2nd, 3rd, 4-0th)...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                CSentItemMemory& MemoryManager, BOOL fMultiItem )
{
    SPDBG_FUNC( "CStdSentEnum::IsNumber" );

    HRESULT hr = S_OK;

    bool fNegative = false;
    TTSIntegerItemInfo*     pIntegerInfo        = NULL;
    TTSDigitsItemInfo*      pDecimalInfo        = NULL;
    TTSFractionItemInfo* pFractionInfo       = NULL;
    const SPVSTATE *pIntegerState = &m_pCurrFrag->State;
    CItemList PostIntegerList;
    ULONG ulOffset = 0, ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    WCHAR wcDecimalPoint;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

    if ( ulTokenLen )
    {
        //--- Set Separator and Decimal Point character preferences for this call
        if ( m_eSeparatorAndDecimal == COMMA_PERIOD )
        {
            wcDecimalPoint  = L'.';
        }
        else
        {
            wcDecimalPoint  = L',';
        }

        //--- Try to match the negative sign - [-]?
        if ( m_pNextChar[ulOffset] == L'-' )
        {
            fNegative = true;
            ulOffset++;
        }
    
        //--- Try to match the integral part
        hr = IsInteger( m_pNextChar + ulOffset, pIntegerInfo, MemoryManager );

        //--- Adjust ulOffset and hr...
        if ( SUCCEEDED( hr ) )
        {
            ulOffset += (ULONG)(pIntegerInfo->pEndChar - pIntegerInfo->pStartChar);
        }
        else if ( hr == E_INVALIDARG )
        {
            hr = S_OK;
            pIntegerInfo = NULL;
        }

        //--- Try to match a decimal part
        if ( ulOffset < ulTokenLen &&
             m_pNextChar[ulOffset] == wcDecimalPoint )
        {
            hr = IsDigitString( m_pNextChar + ulOffset + 1, pDecimalInfo, MemoryManager );
            if ( SUCCEEDED( hr ) )
            {
                ulOffset += pDecimalInfo->ulNumDigits + 1;

                //--- Check for special case - decimal number numerator...
                if ( ulOffset < ulTokenLen &&
                     m_pNextChar[ulOffset] == L'/' )
                {
                    pIntegerInfo = NULL;
                    pDecimalInfo = NULL;
                    fNegative ? ulOffset = 1 : ulOffset = 0;
                    hr = IsFraction( m_pNextChar + ulOffset, pFractionInfo, MemoryManager );
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( pFractionInfo->pVulgar )
                        {
                            ulOffset++;
                        }
                        else
                        {
                            ulOffset += (ULONG)(pFractionInfo->pDenominator->pEndChar - pFractionInfo->pNumerator->pStartChar);
                        }
                    }
                    else if ( hr == E_INVALIDARG )
                    {
                        hr = S_OK;
                    }
                }
            }
            else if ( hr == E_INVALIDARG )
            {
                hr = S_OK;
                pDecimalInfo = NULL;
            }
        }
        //--- Try to match an ordinal string
        else if ( pIntegerInfo          &&
                  ulOffset < ulTokenLen &&
                  isalpha( m_pNextChar[ulOffset] ) )
        {
            switch ( toupper( m_pNextChar[ulOffset] ) )
            {
            case 'S':
                //--- Must be of the form "...1st" but not "...11st" 
                if ( toupper( m_pNextChar[ulOffset+1] ) == L'T'  && 
                     m_pNextChar[ulOffset-1] == L'1'             &&
                     (ulOffset + 2) == ulTokenLen                &&
                     ( ulOffset == 1 ||
                       m_pNextChar[ulOffset-2] != L'1' ) )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            case 'N':
                //--- Must be of the form "...2nd" but not "...12nd" 
                if ( (ulOffset + 2) == ulTokenLen                &&
                     toupper(m_pNextChar[ulOffset+1]) == L'D'    &&
                     m_pNextChar[ulOffset-1] == L'2'             &&                
                     ( ulOffset == 1 ||
                       m_pNextChar[ulOffset-2] != L'1' ) )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            case 'R':
                //--- Must be of the form "...3rd" but not "...13rd" 
                if ( (ulOffset + 2) == ulTokenLen                &&
                     toupper(m_pNextChar[ulOffset+1]) == L'D'    &&
                     m_pNextChar[ulOffset-1] == L'3'             &&
                     ( ulOffset == 1 ||
                       m_pNextChar[ulOffset-2] != L'1' ) )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            case 'T':
                //--- Must be of the form "...[4-9]th" or "...[11-19]th" or "...[0]th" 
                if ( (ulOffset + 2) == ulTokenLen                 &&
                     toupper(m_pNextChar[ulOffset+1]) == L'H'     &&                
                     ( ( m_pNextChar[ulOffset-1] <= L'9' && m_pNextChar[ulOffset-1] >= L'4') ||
                       ( m_pNextChar[ulOffset-1] == L'0')                                    ||
                       ( ulOffset == 1 || m_pNextChar[ulOffset-2] == L'1') ) )
                {
                    ulOffset += 2;
                    pIntegerInfo->fOrdinal = true;
                }
                break;
            default:
                // Some invalid non-digit character found at the end of the string
                break;
            }
        }
        //--- Try to match a fraction
        else
        {
            //--- Try to match an attached fraction
            if ( ulOffset < ulTokenLen )
            {
                if ( m_pNextChar[ulOffset] == L'-' )
                {
                    ulOffset++;
                }
                hr = IsFraction( m_pNextChar + ulOffset, pFractionInfo, MemoryManager );
                if ( SUCCEEDED( hr ) )
                {
                    if ( pFractionInfo->pVulgar )
                    {
                        ulOffset++;
                    }
                    else
                    {
                        ulOffset += (ULONG)(pFractionInfo->pDenominator->pEndChar - pFractionInfo->pNumerator->pStartChar);
                    }
                }
                else if ( hr == E_INVALIDARG )
                {
                    hr = S_OK;
                }
            }
            //--- Try to match an unattached fraction
            else if ( fMultiItem )
            {
                pIntegerState = &m_pCurrFrag->State;

                //--- Advance in text
                m_pNextChar = m_pEndOfCurrItem;
                hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, 
                                            true, &PostIntegerList );
                if ( !m_pNextChar &&
                     SUCCEEDED( hr ) )
                {
                    m_pNextChar = pTempNextChar;
                    m_pEndChar  = pTempEndChar;
                    m_pCurrFrag = pTempFrag;
                }
                else if ( m_pNextChar &&
                          SUCCEEDED( hr ) )
                {
                    m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                    while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) )  != eUNMATCHED ||
                            IsGroupEnding( *(m_pEndOfCurrItem - 1) )      != eUNMATCHED ||
                            IsQuotationMark( *(m_pEndOfCurrItem - 1) )    != eUNMATCHED ||
                            IsEOSItem( *(m_pEndOfCurrItem - 1) )          != eUNMATCHED )
                    {
                        m_pEndOfCurrItem--;
                    }
                
                    hr = IsFraction( m_pNextChar, pFractionInfo, MemoryManager );

                    if ( FAILED( hr ) )
                    {
                        m_pNextChar      = pTempNextChar;
                        m_pEndChar       = pTempEndChar;
                        m_pEndOfCurrItem = pTempEndOfItem;
                        m_pCurrFrag      = pTempFrag;
                        if ( hr == E_INVALIDARG )
                        {
                            hr = S_OK;
                        }
                    }
                    else
                    {
                        ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                        if ( pFractionInfo->pVulgar )
                        {
                            ulOffset = 1;
                        }
                        else
                        {
                            ulOffset = (ULONG)(pFractionInfo->pDenominator->pEndChar - 
                                               pFractionInfo->pNumerator->pStartChar);
                        }                            
                    }
                }
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    //--- If we haven't processed the whole item yet, and it isn't part of a larger item --
    //---   e.g. a percent, a degrees number, or a square or cube -- then fail to match it 
    //---   as a number...
    if ( ulOffset != ulTokenLen &&
         !( ulTokenLen == ulOffset + 1 &&
            ( m_pNextChar[ulOffset] == L'%' ||
              m_pNextChar[ulOffset] == L'' ||
              m_pNextChar[ulOffset] == L'' ||
              m_pNextChar[ulOffset] == L'' ) ) )           
    {
        m_pNextChar         = pTempNextChar;
        m_pEndOfCurrItem    = pTempEndOfItem;
		m_pEndChar          = pTempEndChar;
		m_pCurrFrag         = pTempFrag;
		hr                  = E_INVALIDARG;
    }


    //--- Fill out pItemNormInfo...
    if ( SUCCEEDED( hr ) &&
         ( pIntegerInfo ||
           pDecimalInfo ||
           pFractionInfo ) )
    {
        //--- Reset m_pNextChar to handle the Mixed Fraction case...
        m_pNextChar = pTempNextChar;

        if ( pIntegerInfo                                           && 
             pIntegerInfo->pEndChar - pIntegerInfo->pStartChar == 4 &&
             !pIntegerInfo->fSeparators                             &&
             !pIntegerInfo->fOrdinal                                &&
             !pDecimalInfo                                          &&
             !pFractionInfo                                         &&
             !fNegative                                             &&
             ulOffset == ulTokenLen                                 &&
             ( !Context ||
               _wcsnicmp( Context, L"NUMBER", 6 ) != 0 ) )
        {
            pItemNormInfo = (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof( TTSYearItemInfo ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo->Type = eDATE_YEAR;
                ( (TTSYearItemInfo*) pItemNormInfo )->pYear = m_pNextChar;
                ( (TTSYearItemInfo*) pItemNormInfo )->ulNumDigits = 4;
            }
        }
        else
        {
            pItemNormInfo = (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( pItemNormInfo, sizeof( TTSNumberItemInfo ) );
                if ( pDecimalInfo )
                {
                    pItemNormInfo->Type = eNUM_DECIMAL;
                    if ( pIntegerInfo )
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pIntegerInfo->pEndChar +
                                                                           pDecimalInfo->ulNumDigits + 1;
                    }
                    else
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = m_pNextChar + pDecimalInfo->ulNumDigits + 1;
                        if ( fNegative )
                        {
                            ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar++;
                        }
                    }
                }
                else if ( pFractionInfo )
                {
                    if ( pFractionInfo->pVulgar )
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pFractionInfo->pVulgar + 1;
                    }
                    else
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar =
                                                            pFractionInfo->pDenominator->pEndChar;
                    }
                    if ( pIntegerInfo )
                    {
                        pItemNormInfo->Type = eNUM_MIXEDFRACTION;
                    }
                    else
                    {
                        pItemNormInfo->Type = eNUM_FRACTION;
                    }
                }
                else if ( pIntegerInfo )
                {
                    if ( pIntegerInfo->fOrdinal )
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pIntegerInfo->pEndChar + 2;
                        pItemNormInfo->Type = eNUM_ORDINAL;
                    }
                    else
                    {
                        ( (TTSNumberItemInfo*) pItemNormInfo )->pEndChar = pIntegerInfo->pEndChar;
                        pItemNormInfo->Type = eNUM_CARDINAL;
                    }                    
                }               
            }

            if ( SUCCEEDED( hr ) )
            {
                ( (TTSNumberItemInfo*) pItemNormInfo )->fNegative        = fNegative;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pIntegerPart     = pIntegerInfo;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pDecimalPart     = pDecimalInfo;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pFractionalPart  = pFractionInfo;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pStartChar       = m_pNextChar;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList        = new CWordList;
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    //--- Expand Number into WordList
    if ( SUCCEEDED( hr ) &&
         pItemNormInfo->Type != eDATE_YEAR )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );
        Word.pXmlState          = pIntegerState;
        Word.eWordPartOfSpeech  = MS_Unknown;

        //--- Insert "negative"
        if ( fNegative )
        {
            Word.pWordText  = g_negative.pStr;
            Word.ulWordLen  = g_negative.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( Word );
        }

        //--- Expand Integral Part
        if ( pIntegerInfo )
        {
            ExpandInteger( pIntegerInfo, Context, *( (TTSNumberItemInfo*) pItemNormInfo )->pWordList );
        }

        //--- Expand Decimal Part
        if ( pDecimalInfo )
        {
            //--- Insert "point"
            Word.pWordText  = g_decimalpoint.pStr;
            Word.ulWordLen  = g_decimalpoint.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( Word );

            ExpandDigits( pDecimalInfo, *( (TTSNumberItemInfo*) pItemNormInfo )->pWordList );
        }

        //--- Expand Fractional Part
        if ( pFractionInfo )
        {
            //--- Insert Post-Integer Non-Spoken XML States, if any
            while ( !PostIntegerList.IsEmpty() )
            {
                ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( ( PostIntegerList.RemoveHead() ).Words[0] );
            }

            //--- Insert "and", if also an integer part
            if ( pIntegerInfo )
            {
                Word.pXmlState  = &m_pCurrFrag->State;
                Word.pWordText  = g_And.pStr;
                Word.ulWordLen  = g_And.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                ( (TTSNumberItemInfo*) pItemNormInfo )->pWordList->AddTail( Word );
            }

            hr = ExpandFraction( pFractionInfo, *( (TTSNumberItemInfo*) pItemNormInfo )->pWordList );
        }
    }

    return hr;
} /* IsNumber */

/***********************************************************************************************
* ExpandNumber *
*--------------*
*   Description:
*       Expands Items previously determined to be of type NUM_CARDINAL, NUM_DECIMAL, or 
*   NUM_ORDINAL by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandNumber( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "NumNorm ExpandNumber" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    return hr;
} /* ExpandNumber */

/***********************************************************************************************
* ExpandPercent *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_PERCENT by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandPercent( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandPercent" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    Word.pWordText          = g_percent.pStr;
    Word.ulWordLen          = g_percent.Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    WordList.AddTail( Word );

    return hr;
} /* ExpandPercent */

/***********************************************************************************************
* ExpandDegree *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_DEGREES by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandDegrees( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDegrees" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( !pItemInfo->pDecimalPart       &&
         !pItemInfo->pFractionalPart    &&
         pItemInfo->pIntegerPart        &&
         pItemInfo->pIntegerPart->pEndChar - pItemInfo->pIntegerPart->pStartChar == 1 &&
         pItemInfo->pIntegerPart->pStartChar[0] == L'1' )
    {
        Word.pWordText  = g_degree.pStr;
        Word.ulWordLen  = g_degree.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
    }
    else if ( !pItemInfo->pIntegerPart   &&
              pItemInfo->pFractionalPart &&
              !pItemInfo->pFractionalPart->fIsStandard )
    {
        Word.pWordText  = g_of.pStr;
        Word.ulWordLen  = g_of.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );

        Word.pWordText  = g_a.pStr;
        Word.ulWordLen  = g_a.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );

        Word.pWordText  = g_degree.pStr;
        Word.ulWordLen  = g_degree.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
    }
    else
    {
        Word.pWordText  = g_degrees.pStr;
        Word.ulWordLen  = g_degrees.Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
    }

    WordList.AddTail( Word );

    return hr;
} /* ExpandDegrees */

/***********************************************************************************************
* ExpandSquare *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_SQUARED by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandSquare( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandSquare" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    Word.pWordText          = g_squared.pStr;
    Word.ulWordLen          = g_squared.Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    WordList.AddTail( Word );

    return hr;
} /* ExpandSquare */

/***********************************************************************************************
* ExpandCube *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_CUBED by IsNumber.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandCube( TTSNumberItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandCube" );

    HRESULT hr = S_OK;
    WordList.AddTail( pItemInfo->pWordList );
    delete pItemInfo->pWordList;

    TTSWord Word;
    ZeroMemory( &Word, sizeof( TTSWord ) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    Word.pWordText          = g_cubed.pStr;
    Word.ulWordLen          = g_cubed.Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    WordList.AddTail( Word );

    return hr;
} /* ExpandCube */

/***********************************************************************************************
* IsInteger *
*-----------*
*   Description:
*       Helper for IsNumber which matches the integer part...
*
*   RegExp:
*       { d+ || d(1-3)[,ddd]+ }
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsInteger( const WCHAR* pStartChar, TTSIntegerItemInfo*& pIntegerInfo, 
                                 CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    ULONG ulOffset = 0, ulCount = 0, ulTokenLen = (ULONG)(m_pEndOfCurrItem - pStartChar);
    BOOL fSeparators = false, fDone = false;
    WCHAR wcSeparator, wcDecimalPoint;

    if ( m_eSeparatorAndDecimal == COMMA_PERIOD )
    {
        wcSeparator  = L',';
        wcDecimalPoint = L'.';
    }
    else
    {
        wcSeparator  = L'.';
        wcDecimalPoint = L',';
    }

    //--- Check for first digit 
    if ( !isdigit(pStartChar[ulOffset]) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        ulCount++;
        ulOffset++;
    }

    //--- Check for separators
    ULONG i = ulOffset + 3;
    while ( SUCCEEDED( hr ) && 
            ulOffset < i    && 
            ulOffset < ulTokenLen )
    {
        if ( pStartChar[ulOffset] == wcSeparator )
        {
            //--- Found a separator 
            fSeparators = true;
            break;
        }
        else if ( !isdigit( pStartChar[ulOffset] ) &&
                  ( pStartChar[ulOffset] == wcDecimalPoint  ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'-'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    toupper( pStartChar[ulOffset] ) == L'S' ||
                    toupper( pStartChar[ulOffset] ) == L'N' ||
                    toupper( pStartChar[ulOffset] ) == L'R' ||
                    toupper( pStartChar[ulOffset] ) == L'T' ) )
        {
            fDone = true;
            break;
        }
        else if ( isdigit( pStartChar[ulOffset] ) )
        {
            //--- Just another digit 
            ulCount++;
            ulOffset++;
        }
        else
        {
            hr = E_INVALIDARG;
            break;
        }
    }

    if ( SUCCEEDED( hr ) && 
         !fDone          && 
         ulOffset < ulTokenLen )
    {
        if ( !fSeparators )
        {
            //--- No separators.  Pattern must be {d+} if this is indeed a number, so just count digits. 
            while ( isdigit( pStartChar[ulOffset] ) && 
                    ulOffset < ulTokenLen )
            {
                ulCount++;
                ulOffset++;
            }
            if ( ulOffset != ulTokenLen &&
                 !( pStartChar[ulOffset] == wcDecimalPoint  ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'-'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    toupper( pStartChar[ulOffset] ) == L'S' ||
                    toupper( pStartChar[ulOffset] ) == L'N' ||
                    toupper( pStartChar[ulOffset] ) == L'R' ||
                    toupper( pStartChar[ulOffset] ) == L'T' ) )
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            //--- Separators.  Pattern must be { d(1-3)[,ddd]+ }, so make sure the separators match up 
            while ( SUCCEEDED( hr )                     && 
                    pStartChar[ulOffset] == wcSeparator && 
                    ( ulOffset + 3 ) < ulTokenLen)
            {
                ulOffset++;
                for ( i = ulOffset + 3; SUCCEEDED( hr ) && ulOffset < i; ulOffset++ )
                {
                    if ( isdigit( pStartChar[ulOffset] ) )
                    {
                        ulCount++;
                    }
                    else // Some non-digit character found - abort!
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            if ( ulOffset != ulTokenLen && 
                 !( pStartChar[ulOffset] == wcDecimalPoint  ||
                    pStartChar[ulOffset] == L'%'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L'-'            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    pStartChar[ulOffset] == L''            ||
                    toupper( pStartChar[ulOffset] ) == L'S' ||
                    toupper( pStartChar[ulOffset] ) == L'N' ||
                    toupper( pStartChar[ulOffset] ) == L'R' ||
                    toupper( pStartChar[ulOffset] ) == L'T' ) )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        pIntegerInfo = (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo ), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pIntegerInfo, sizeof( TTSIntegerItemInfo ) );
            pIntegerInfo->fSeparators = fSeparators;
            pIntegerInfo->lLeftOver   = ulCount % 3;
            pIntegerInfo->lNumGroups  = ( ulCount - 1 ) / 3;
            pIntegerInfo->pStartChar  = pStartChar;
            pIntegerInfo->pEndChar    = pStartChar + ulOffset;
        }
    }

    return hr;
} /* IsInteger */

/***********************************************************************************************
* ExpandInteger *
*---------------*
*   Description:
*       
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandInteger( TTSIntegerItemInfo* pItemInfo, const WCHAR* Context, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandInteger" );

    //--- Local variable declarations and initialization
    BOOL bFinished = false;
    const WCHAR *pStartChar = pItemInfo->pStartChar, *pEndChar = pItemInfo->pEndChar;
    ULONG ulOffset = 0, ulTokenLen = (ULONG)(pEndChar - pStartChar), ulTemp = (ULONG)(pItemInfo->lNumGroups + 1);

    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Out of range integer, or integer beginning with one or more zeroes...
    if ( pStartChar[0] == L'0'                          || 
         ( Context &&
           _wcsicmp( Context, L"NUMBER_DIGIT" ) == 0 )   ||
         pItemInfo->lNumGroups >= sp_countof(g_quantifiers) )
    {
        pItemInfo->fDigitByDigit = true;
        pItemInfo->ulNumDigits   = 0;

        for ( ULONG i = 0; i < ulTokenLen; i++ )
        {
            if ( isdigit( pStartChar[i] ) )
            {
                ExpandDigit( pStartChar[i], pItemInfo->Groups[0], WordList );
                pItemInfo->ulNumDigits++;
            }
        }
    }
    //--- Expanding a number < 1000 
    else if ( pItemInfo->lNumGroups == 0 )
    {
        // 0th through 999th...
        if ( pItemInfo->fOrdinal )
        {
            switch ( pItemInfo->lLeftOver )
            {
            case 1:
                // 0th through 9th...
                ExpandDigitOrdinal( pStartChar[ulOffset], pItemInfo->Groups[0], WordList );
                break;
            case 2:
                // 10th through 99th...
                ExpandTwoOrdinal( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                break;
            case 0:
                // 100th through 999th...
                ExpandThreeOrdinal( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                break;
            case -1:
                ulTemp = 0;
                pItemInfo->lLeftOver = 0;
                break;
            }
        }
        // 0 through 999...
        else
        {
            switch ( pItemInfo->lLeftOver )
            {
            case 1:
                // 0 through 9...
                ExpandDigit( pStartChar[ulOffset], pItemInfo->Groups[0], WordList );
                ulOffset += 1;
                break;
            case 2:
                // 10 through 99...
                ExpandTwoDigits( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                ulOffset += 2;
                break;
            case 0:
                // 100 through 999...
                ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[0], WordList );
                ulOffset += 3;
                break;
            case -1:
                ulTemp = 0;
                pItemInfo->lLeftOver = 0;
                break;
            }
        }
    } 
    else
    {
        //--- 1000 through highest number covered, e.g. 1,234,567 

        //--- Expand first grouping, e.g. 1 million 
        //--- Expand digit group 
        switch ( pItemInfo->lLeftOver )
        {
        case 1:
            ExpandDigit( pStartChar[ulOffset], pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 1;
            break;
        case 2:
            ExpandTwoDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 2;
            break;
        case 0:
            ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
            break;
        } 
        //--- Special Case: rare ordinal cases - e.g. 1,000,000th 
        if ( pItemInfo->fOrdinal    &&
             Zeroes(pStartChar + ulOffset) )
        {
            //--- Insert ordinal quantifier 
            pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
            Word.pWordText  = g_quantifiersOrdinal[pItemInfo->lNumGroups].pStr;
            Word.ulWordLen  = g_quantifiersOrdinal[pItemInfo->lNumGroups--].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            bFinished = true;
        }
        //--- Default Case 
        else
        {
            //--- Insert quantifier
            pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
            Word.pWordText  = g_quantifiers[pItemInfo->lNumGroups].pStr;
            Word.ulWordLen  = g_quantifiers[pItemInfo->lNumGroups--].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }

        //--- Expand rest of groupings which need to be followed by a quantifier 
        while ( pItemInfo->lNumGroups > 0 && 
                !bFinished )
        {
            if ( pItemInfo->fSeparators )
            {
                ulOffset++;
            }
            //--- Expand digit group 
            ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
            //--- Special case: rare ordinal cases, e.g. 1,234,000th 
            if ( pItemInfo->fOrdinal    && 
                 Zeroes( pStartChar + ulOffset ) )
            {
                //--- Insert ordinal quantifier 
                pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
                Word.pWordText  = g_quantifiersOrdinal[pItemInfo->lNumGroups].pStr;
                Word.ulWordLen  = g_quantifiersOrdinal[pItemInfo->lNumGroups--].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                bFinished = true;
            }
            //--- Default Case 
            else if ( !ThreeZeroes( pStartChar + ulOffset - 3 ) )
            {
                //--- Insert quantifier
                pItemInfo->Groups[pItemInfo->lNumGroups].fQuantifier = true;
                Word.pWordText  = g_quantifiers[pItemInfo->lNumGroups].pStr;
                Word.ulWordLen  = g_quantifiers[pItemInfo->lNumGroups--].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            //--- Special Case: this grouping is all zeroes, e.g. 1,000,567 
            else
            {
                pItemInfo->lNumGroups--;
            }
        }

        //--- Expand final grouping, which requires no quantifier 
        if ( pItemInfo->fSeparators  && 
             !bFinished )
        {
            ulOffset++;
        }

        if ( pItemInfo->fOrdinal    &&
             !bFinished )
        {
            ExpandThreeOrdinal( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
        }
        else if ( !bFinished )
        {
            ExpandThreeDigits( pStartChar + ulOffset, pItemInfo->Groups[pItemInfo->lNumGroups], WordList );
            ulOffset += 3;
        }
    }
    pItemInfo->lNumGroups = (long) ulTemp;
} /* ExpandInteger */

/***********************************************************************************************
* IsDigitString *
*---------------*
*   Description:
*       Helper for IsNumber, IsPhoneNumber, etc. which matches a digit string...
*
*   RegExp:
*       d+
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsDigitString( const WCHAR* pStartChar, TTSDigitsItemInfo*& pDigitsInfo,
                                     CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    ULONG ulOffset = 0;

    while ( pStartChar + ulOffset < m_pEndOfCurrItem &&
            isdigit( pStartChar[ulOffset] ) )
    {
        ulOffset++;
    }

    if ( ulOffset )
    {
        pDigitsInfo = (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof( TTSDigitsItemInfo ), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pDigitsInfo, sizeof( pDigitsInfo ) );
            pDigitsInfo->pFirstDigit = pStartChar;
            pDigitsInfo->ulNumDigits = ulOffset;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsDigitString */

/***********************************************************************************************
* ExpandDigits *
*--------------*
*   Description:
*       Expands a string of digits, digit by digit.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandDigits( TTSDigitsItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDigits" );
    
    for ( ULONG i = 0; i < pItemInfo->ulNumDigits; i++ )
    {
        NumberGroup Garbage;
        ExpandDigit( pItemInfo->pFirstDigit[i], Garbage, WordList );
    }
} /* ExpandDigits */

/***********************************************************************************************
* IsFraction *
*------------*
*   Description:
*       Helper for IsNumber which matches a fraction...
*
*   RegExp:
*       { NUM_CARDINAL || NUM_DECIMAL } / { NUM_CARDINAL || NUM_DECIMAL }
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsFraction( const WCHAR* pStartChar, TTSFractionItemInfo*& pFractionInfo, 
                                  CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsFraction" );

    HRESULT hr = S_OK;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - pStartChar);

    if ( ulTokenLen )
    {
        //--- Check for Vulgar Fraction
        if ( pStartChar[0] == L'' ||
             pStartChar[0] == L'' ||
             pStartChar[0] == L'' )
        {
            pFractionInfo = (TTSFractionItemInfo*) MemoryManager.GetMemory( sizeof( TTSFractionItemInfo ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( pFractionInfo, sizeof( TTSFractionItemInfo ) );
                pFractionInfo->pVulgar      = pStartChar;
                pFractionInfo->pNumerator   = 
                    (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pFractionInfo->pNumerator, sizeof( TTSNumberItemInfo ) );
                    pFractionInfo->pDenominator = 
                        (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pFractionInfo->pDenominator, sizeof( TTSNumberItemInfo ) );
                        pFractionInfo->pNumerator->pIntegerPart =
                            (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( pFractionInfo->pNumerator->pIntegerPart, sizeof( TTSIntegerItemInfo ) );
                            pFractionInfo->pDenominator->pIntegerPart =
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo ), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( pFractionInfo->pDenominator->pIntegerPart, sizeof( TTSIntegerItemInfo ) );
                                pFractionInfo->fIsStandard                                  = false;
                                pFractionInfo->pNumerator->pIntegerPart->lLeftOver          = 1;
                                pFractionInfo->pNumerator->pIntegerPart->lNumGroups         = 1;
                                pFractionInfo->pNumerator->pIntegerPart->Groups[0].fOnes    = true;
                                pFractionInfo->pDenominator->pIntegerPart->lLeftOver        = 1;
                                pFractionInfo->pDenominator->pIntegerPart->lNumGroups       = 1;
                                pFractionInfo->pDenominator->pIntegerPart->Groups[0].fOnes  = true;
                            }
                        }
                    }
                }
            }
        }
        //--- Check for multi-character fraction
        else
        {
            TTSItemInfo *pNumeratorInfo = NULL, *pDenominatorInfo = NULL;
            const WCHAR* pTempNextChar = m_pNextChar, *pTempEndOfCurrItem = m_pEndOfCurrItem;
            m_pNextChar = pStartChar;
            m_pEndOfCurrItem = wcschr( pStartChar, L'/' );
            if ( !m_pEndOfCurrItem ||
                 m_pEndOfCurrItem >= pTempEndOfCurrItem )
            {
                hr = E_INVALIDARG;
            }

            //--- Try to get numerator
            if ( SUCCEEDED( hr ) )
            {
                hr = IsNumber( pNumeratorInfo, L"NUMBER", MemoryManager, false );
            }
            if ( SUCCEEDED( hr ) &&
                 pNumeratorInfo->Type != eNUM_MIXEDFRACTION &&
                 pNumeratorInfo->Type != eNUM_FRACTION      &&
                 pNumeratorInfo->Type != eNUM_ORDINAL )
            {
                if ( ( (TTSNumberItemInfo*) pNumeratorInfo )->pIntegerPart )
                {
                    m_pNextChar += ( (TTSNumberItemInfo*) pNumeratorInfo )->pIntegerPart->pEndChar -
                                   ( (TTSNumberItemInfo*) pNumeratorInfo )->pIntegerPart->pStartChar;
                }
                if ( ( (TTSNumberItemInfo*) pNumeratorInfo )->pDecimalPart )
                {
                    m_pNextChar += ( (TTSNumberItemInfo*) pNumeratorInfo )->pDecimalPart->ulNumDigits + 1;
                }
            }
            else if ( SUCCEEDED( hr ) )
            {
                delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
                hr = E_INVALIDARG;
            }
            m_pEndOfCurrItem = pTempEndOfCurrItem;

            //--- Try to get denominator
            if ( SUCCEEDED( hr ) &&
                 m_pNextChar[0] == L'/' )
            {
                m_pNextChar++;
                hr = IsNumber( pDenominatorInfo, L"NUMBER", MemoryManager, false );
                if ( SUCCEEDED( hr ) &&
                     pDenominatorInfo->Type != eNUM_MIXEDFRACTION &&
                     pDenominatorInfo->Type != eNUM_FRACTION      &&
                     pDenominatorInfo->Type != eNUM_ORDINAL )
                {
                    pFractionInfo = 
                        ( TTSFractionItemInfo*) MemoryManager.GetMemory( sizeof( TTSFractionItemInfo ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pFractionInfo, sizeof( TTSFractionItemInfo ) );
                        pFractionInfo->pNumerator   = (TTSNumberItemInfo*) pNumeratorInfo;
                        pFractionInfo->pDenominator = (TTSNumberItemInfo*) pDenominatorInfo;
                        pFractionInfo->pVulgar      = NULL;
                        pFractionInfo->fIsStandard  = false;
                    }
                }
                else if ( SUCCEEDED( hr ) )
                {
                    delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
                    delete ( (TTSNumberItemInfo*) pDenominatorInfo )->pWordList;
                    hr = E_INVALIDARG;
                }
                else
                {
                    delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
                }
            }
            else if ( SUCCEEDED( hr ) )
            {
                hr = E_INVALIDARG;
                delete ( (TTSNumberItemInfo*) pNumeratorInfo )->pWordList;
            }

            m_pNextChar = pTempNextChar;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsFraction */

/***********************************************************************************************
* ExpandFraction *
*----------------*
*   Description:
*       Expands Items previously determined to be of type NUM_FRACTION by IsFraction.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandFraction( TTSFractionItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandFraction" );

    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Special case - vulgar fractions ( , ,  )
    if ( pItemInfo->pVulgar )
    {
        if ( pItemInfo->pVulgar[0] == L'' )
        {
            Word.pWordText  = g_ones[1].pStr;
            Word.ulWordLen  = g_ones[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            Word.pWordText  = g_onesOrdinal[4].pStr;
            Word.ulWordLen  = g_onesOrdinal[4].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else if ( pItemInfo->pVulgar[0] == L'' )
        {
            Word.pWordText  = g_ones[1].pStr;
            Word.ulWordLen  = g_ones[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            Word.pWordText  = g_Half.pStr;
            Word.ulWordLen  = g_Half.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else
        {
            Word.pWordText  = g_ones[3].pStr;
            Word.ulWordLen  = g_ones[3].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            Word.pWordText  = g_PluralDenominators[4].pStr;
            Word.ulWordLen  = g_PluralDenominators[4].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
    }
    else
    {
        //--- Insert Numerator WordList
        WordList.AddTail( pItemInfo->pNumerator->pWordList );

        delete pItemInfo->pNumerator->pWordList;

        //--- Expand denominator ---//

        //--- If no decimal part, must check for special cases ( x/2 - x/9, x/10, x/100 )
        if ( !pItemInfo->pDenominator->pDecimalPart &&
             !pItemInfo->pNumerator->pDecimalPart   &&
             !pItemInfo->pDenominator->fNegative )
        {
            //--- Check for special cases - halves through ninths 
            if ( ( pItemInfo->pDenominator->pEndChar - 
                   pItemInfo->pDenominator->pStartChar ) == 1 &&
                 pItemInfo->pDenominator->pStartChar[0] != L'1' )
            { 
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    if ( pItemInfo->pDenominator->pStartChar[0] == L'2' )
                    {
                        Word.pWordText  = g_Half.pStr;
                        Word.ulWordLen  = g_Half.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );
                    }
                    else
                    {
                        ExpandDigitOrdinal( pItemInfo->pDenominator->pStartChar[0], 
                                            pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                    }
                }
                //--- Insert plural form of denominator 
                else 
                {
                    ULONG index     = pItemInfo->pDenominator->pStartChar[0] - L'0';
                    Word.pWordText  = g_PluralDenominators[index].pStr;
                    Word.ulWordLen  = g_PluralDenominators[index].Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            //--- Check for special case - tenths 
            else if ( ( pItemInfo->pDenominator->pEndChar -
                       pItemInfo->pDenominator->pStartChar ) == 2 &&
                      wcsncmp( pItemInfo->pDenominator->pStartChar, L"10", 2 ) == 0 )
            {
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    ExpandTwoOrdinal( pItemInfo->pDenominator->pStartChar, 
                                      pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                }
                //--- Insert plural form denominator 
                else
                {
                    Word.pWordText  = g_Tenths.pStr;
                    Word.ulWordLen  = g_Tenths.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            //--- Check for special case - sixteenths
            else if ( ( pItemInfo->pDenominator->pEndChar -
                       pItemInfo->pDenominator->pStartChar ) == 2 &&
                      wcsncmp( pItemInfo->pDenominator->pStartChar, L"16", 2 ) == 0 )
            {
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    ExpandTwoOrdinal( pItemInfo->pDenominator->pStartChar, 
                                      pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                }
                //--- Insert plural form denominator 
                else
                {
                    Word.pWordText  = g_Sixteenths.pStr;
                    Word.ulWordLen  = g_Sixteenths.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            //--- Check for special case - hundredths 
            else if ( ( pItemInfo->pDenominator->pEndChar - 
                        pItemInfo->pDenominator->pStartChar ) == 3 &&
                      wcsncmp( pItemInfo->pDenominator->pStartChar, L"100", 3 ) == 0 )
            {
                pItemInfo->fIsStandard = false;

                //--- Insert singular form of denominator 
                if ( ( pItemInfo->pNumerator->pEndChar -
                       pItemInfo->pNumerator->pStartChar ) == 1 &&
                     pItemInfo->pNumerator->pStartChar[0] == L'1' )
                {
                    ExpandThreeOrdinal( pItemInfo->pDenominator->pStartChar,
                                        pItemInfo->pDenominator->pIntegerPart->Groups[0], WordList );
                }
                //--- Insert plural form of denominator 
                else
                {
                    Word.pWordText  = g_Hundredths.pStr;
                    Word.ulWordLen  = g_Hundredths.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
            }
            else
            {
                pItemInfo->fIsStandard = true;
            }
        }
        else
        {
            pItemInfo->fIsStandard = true;
        }

        //--- Default case - Numerator "over" Denominator 
        if ( pItemInfo->fIsStandard )
        {
            //--- Insert "over" 
            Word.pWordText  = g_Over.pStr;
            Word.ulWordLen  = g_Over.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert denominator WordList
            WordList.AddTail( pItemInfo->pDenominator->pWordList );
        }

        delete pItemInfo->pDenominator->pWordList;
    }
    return hr;
} /* ExpandFraction */

/***********************************************************************************************
* ExpandDigit *
*-------------*
*   Description:
*       Expands single digits into words, and inserts them into WordList
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandDigit( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDigit" );
    SPDBG_ASSERT( isdigit(Number) );

    // 0-9
    ULONG Index = Number - L'0';
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.pWordText          = g_ones[Index].pStr;
    Word.ulWordLen          = g_ones[Index].Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    Word.eWordPartOfSpeech  = MS_Unknown;
    WordList.AddTail( Word );
    NormGroupInfo.fOnes = true;
} /* ExpandDigit */

/***********************************************************************************************
* ExpandTwo *
*-----------*
*   Description:
*       Expands two digit strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandTwoDigits( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandTwoDigits" );
    SPDBG_ASSERT( NumberString              &&
                  wcslen(NumberString) >= 2 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1]) ); 

    // 10-99
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';
    ULONG IndexTwo = NumberString[1] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 1 )
    {
        // 20-99, or 00-09
        if (IndexOne != 0)
        {
            Word.pWordText  = g_tens[IndexOne].pStr;
            Word.ulWordLen  = g_tens[IndexOne].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            NormGroupInfo.fTens = true;
        }
        if ( IndexTwo != 0 )
        {
            ExpandDigit( NumberString[1], NormGroupInfo, WordList );
            NormGroupInfo.fOnes = true;
        }
    } 
    else 
    {
        // 10-19
        Word.pWordText  = g_teens[IndexTwo].pStr;
        Word.ulWordLen  = g_teens[IndexTwo].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        NormGroupInfo.fOnes = true;
    }
} /* ExpandTwo */

/***********************************************************************************************
* ExpandThree *
*-------------*
*   Description:
*       Expands three digit strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandThreeDigits( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandThreeDigits" );
    SPDBG_ASSERT( NumberString              && 
                  wcslen(NumberString) >= 3 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1])  && 
                  isdigit(NumberString[2]) ); 

    // 100-999
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 0 )
    {
        // Take care of hundreds...
        ExpandDigit( NumberString[0], NormGroupInfo, WordList );
        Word.pWordText  = g_quantifiers[0].pStr;
        Word.ulWordLen  = g_quantifiers[0].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        NormGroupInfo.fHundreds = true;
        NormGroupInfo.fOnes = false;
    }
    
    // Take care of tens and ones...
    ExpandTwoDigits( NumberString + 1, NormGroupInfo, WordList );

} /* ExpandThree */

/***********************************************************************************************
* ExpandDigitOrdinal *
*--------------------*
*   Description:
*       Expands single digit ordinal strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandDigitOrdinal( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDigitOrdinal" );
    SPDBG_ASSERT( isdigit(Number) );

    // 0-9
    ULONG Index = Number - L'0';
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.pWordText          = g_onesOrdinal[Index].pStr;
    Word.ulWordLen          = g_onesOrdinal[Index].Len;
    Word.pLemma             = Word.pWordText;
    Word.ulLemmaLen         = Word.ulWordLen;
    Word.eWordPartOfSpeech  = MS_Unknown;
    WordList.AddTail( Word );
    NormGroupInfo.fOnes = true;
} /* ExpandDigitOrdinal */

/***********************************************************************************************
* ExpandTwoOrdinal *
*------------------*
*   Description:
*       Expands two digit ordinal strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandTwoOrdinal( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandTwoOrdinal" );
    SPDBG_ASSERT( NumberString              &&
                  wcslen(NumberString) >= 2 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1]) ); 

    // 10-99
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';
    ULONG IndexTwo = NumberString[1] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 1 )
    {
        // 20-99, or 00-09
        if (IndexOne != 0)
        {
            if ( IndexTwo != 0 )
            {
                Word.pWordText  = g_tens[IndexOne].pStr;
                Word.ulWordLen  = g_tens[IndexOne].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
                NormGroupInfo.fTens = true;
                ExpandDigitOrdinal( NumberString[1], NormGroupInfo, WordList );
                NormGroupInfo.fOnes = true;
            }
            else
            {
                Word.pWordText  = g_tensOrdinal[IndexOne].pStr;
                Word.ulWordLen  = g_tensOrdinal[IndexOne].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
        }
        else
        {
            ExpandDigitOrdinal( NumberString[1], NormGroupInfo, WordList );
        }
    } 
    else 
    {
        // 10-19
        Word.pWordText  = g_teensOrdinal[IndexTwo].pStr;
        Word.ulWordLen  = g_teensOrdinal[IndexTwo].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
        NormGroupInfo.fOnes = true;
    }
} /* ExpandTwoOrdinal */

/***********************************************************************************************
* ExpandThreeOrdinal *
*--------------------*
*   Description:
*       Expands three digit ordinal strings into words, and inserts them into WordList.
*
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
void CStdSentEnum::ExpandThreeOrdinal( const WCHAR *NumberString, NumberGroup& NormGroupInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandThreeDigits" );
    SPDBG_ASSERT( NumberString              && 
                  wcslen(NumberString) >= 3 && 
                  isdigit(NumberString[0])  && 
                  isdigit(NumberString[1])  && 
                  isdigit(NumberString[2]) ); 

    // 100-999
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    ULONG IndexOne = NumberString[0] - L'0';

    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    if ( IndexOne != 0 )
    {
        ExpandDigit( NumberString[0], NormGroupInfo, WordList );
        //--- Special case - x hundredth
        if ( Zeroes( NumberString + 1 ) )
        {
            Word.pWordText  = g_quantifiersOrdinal[0].pStr;
            Word.ulWordLen  = g_quantifiersOrdinal[0].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            NormGroupInfo.fHundreds = true;
            NormGroupInfo.fOnes = false;
        }
        //--- Default case - x hundred yth
        else
        {
            Word.pWordText  = g_quantifiers[0].pStr;
            Word.ulWordLen  = g_quantifiers[0].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            ExpandTwoOrdinal( NumberString + 1, NormGroupInfo, WordList );
            NormGroupInfo.fHundreds = true;
        }
    }
    //--- Special case - no hundreds
    else
    {
        ExpandTwoOrdinal( NumberString + 1, NormGroupInfo, WordList );
    }
} /* ExpandThreeOrdinal */

/***********************************************************************************************
* MatchQuantifier *
*-----------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a numerical quantifier.
********************************************************************* AH **********************/
int MatchQuantifier( const WCHAR*& pStartChar, const WCHAR*& pEndChar )
{
    int Index = -1;

    for (int i = 0; i < sp_countof(g_quantifiers); i++)
    {
        if ( pEndChar - pStartChar >= g_quantifiers[i].Len &&
             wcsnicmp( pStartChar, g_quantifiers[i].pStr, g_quantifiers[i].Len ) == 0 )
        {
            pStartChar += g_quantifiers[i].Len;
            Index = i;
            break;
        }
    }

    return Index;
} /* MatchQuantifier */

/***********************************************************************************************
* IsCurrency *
*------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a currency.  
*
*   RegExp:
*       { [CurrencySign] { d+ || d(1-3)[,ddd]+ } { [.]d+ }? } { [whitespace] [quantifier] }? ||
*       { { d+ || d(1-3)[,ddd]+ } { [.]d+ }? { [whitespace] [quantifier] }? [whitespace]? [CurrencySign] }
*
*   Types assigned:
*       NUM_CURRENCY
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsCurrency( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                  CWordList& WordList )
{
    SPDBG_FUNC( "NumNorm IsCurrency" );

    HRESULT hr = S_OK;

    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem, *pTempEndChar = m_pEndChar;
    const SPVTEXTFRAG* pTempFrag = m_pCurrFrag;

    const SPVSTATE *pNumberXMLState = NULL, *pSymbolXMLState = NULL, *pQuantifierXMLState = NULL;
    CItemList PostNumberList, PostSymbolList;
    int iSymbolIndex = -1, iQuantIndex = -1;    
    TTSItemInfo* pNumberInfo = NULL;
    BOOL fDone = false, fNegative = false;
    WCHAR wcDecimalPoint = ( m_eSeparatorAndDecimal == COMMA_PERIOD ? L'.' : L',' );

    //--- Try to match [CurrencySign] [Number] [Quantifier]
    NORM_POSITION ePosition = UNATTACHED;
    if ( m_pNextChar[0] == L'-' )
    {
        fNegative = true;
        m_pNextChar++;
    }
    iSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );
    if ( iSymbolIndex >= 0 &&
         ePosition == PRECEDING )
    {
        pSymbolXMLState = &m_pCurrFrag->State;

        //--- Skip any whitespace in between the currency sign and the number...
        hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostSymbolList );
    
        if ( !m_pNextChar )
        {
            hr = E_INVALIDARG;
        }

        if ( SUCCEEDED( hr ) )
        {
            m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
            while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                    IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                    IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                    IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
            {
                fDone = true;
                m_pEndOfCurrItem--;
            }
        }

        //--- Try to match a number string 
        if ( SUCCEEDED( hr ) )
        {
            hr = IsNumberCategory( pNumberInfo, L"NUMBER", MemoryManager );
            if ( SUCCEEDED( hr ) )
            {
                if ( pNumberInfo->Type != eNUM_CARDINAL &&
                     pNumberInfo->Type != eNUM_DECIMAL  &&
                     pNumberInfo->Type != eNUM_FRACTION &&
                     pNumberInfo->Type != eNUM_MIXEDFRACTION )
                {
                    hr = E_INVALIDARG;
                }
                else
                {
                    pNumberXMLState = &m_pCurrFrag->State;
                }
            }

            //--- Skip any whitespace in between the number and the quantifier...
            if ( !fDone &&
                 SUCCEEDED( hr ) )
            {
                const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar;
                const WCHAR *pTempEndOfItem = m_pEndOfCurrItem;
                const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

                m_pNextChar = m_pEndOfCurrItem;
                hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostNumberList );

                if ( m_pNextChar &&
                     SUCCEEDED( hr ) )
                {
                    m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                    while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
                    {
                        m_pEndOfCurrItem--;
                    }

                    //--- Try to match a quantifier
                    iQuantIndex = MatchQuantifier( m_pNextChar, m_pEndOfCurrItem );
                    if ( iQuantIndex >= 0 )
                    {
                        pQuantifierXMLState = &m_pCurrFrag->State;
                    }
                    else
                    {
                        m_pNextChar      = pTempNextChar;
                        m_pEndChar       = pTempEndChar;
                        m_pEndOfCurrItem = pTempEndOfItem;
                        m_pCurrFrag      = pTempFrag;
                    }
                }
                else
                {
                    m_pNextChar      = pTempNextChar;
                    m_pEndChar       = pTempEndChar;
                    m_pEndOfCurrItem = pTempEndOfItem;
                    m_pCurrFrag      = pTempFrag;
                }
            }
        }
    }
    //--- Try to match [Number] [CurrencySign] [Quantifier]
    else 
    {
        //--- Try to match a number string
        hr = IsNumberCategory( pNumberInfo, L"NUMBER", MemoryManager );
        if ( SUCCEEDED( hr ) )
        {
            if ( pNumberInfo->Type != eNUM_CARDINAL &&
                 pNumberInfo->Type != eNUM_DECIMAL  &&
                 pNumberInfo->Type != eNUM_FRACTION &&
                 pNumberInfo->Type != eNUM_MIXEDFRACTION )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                pNumberXMLState = &m_pCurrFrag->State;
            }
        }

        //--- Skip any whitespace and XML markup between the number and the currency sign
        if ( SUCCEEDED( hr ) )
        {
            m_pNextChar = m_pEndOfCurrItem;
            hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostNumberList );

            if ( !m_pNextChar )
            {
                hr = E_INVALIDARG;
            }

            if ( SUCCEEDED( hr ) )
            {
                m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                        IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                        IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                        IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
                {
                    m_pEndOfCurrItem--;
                    fDone = true;
                }
            }
        }

        //--- Try to match a Currency Sign
        if ( SUCCEEDED( hr ) )
        {
            iSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );
            if ( iSymbolIndex >= 0 )
            {
                pSymbolXMLState = &m_pCurrFrag->State;
            }

            //--- Skip any whitespace in between the currency sign and the quantifier
            if ( !fDone &&
                 iSymbolIndex >= 0 )
            {
                const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar;
                const WCHAR *pTempEndOfItem = m_pEndOfCurrItem;
                const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

                hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &PostSymbolList );

                if ( !m_pNextChar )
                {
                    m_pNextChar      = pTempNextChar;
                    m_pEndChar       = pTempEndChar;
                    m_pEndOfCurrItem = pTempEndOfItem;
                    m_pCurrFrag      = pTempFrag;
                    fDone = true;
                }

                if ( !fDone &&
                     SUCCEEDED( hr ) )
                {
                    m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );
                    while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
                    {
                        fDone = true;
                        m_pEndOfCurrItem--;
                    }

                    //--- Try to match quantifier
                    iQuantIndex = MatchQuantifier( m_pNextChar, m_pEndOfCurrItem );
                    if ( iQuantIndex >= 0 )
                    {
                        pQuantifierXMLState = &m_pCurrFrag->State;
                    }
                    else
                    {
                        m_pNextChar      = pTempNextChar;
                        m_pEndChar       = pTempEndChar;
                        m_pEndOfCurrItem = pTempEndOfItem;
                        m_pCurrFrag      = pTempFrag;
                    }
                }
            }
            else if ( iSymbolIndex < 0 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    //--- Successfully matched a currency!  Now expand it and fill out pItemNormInfo.
    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof(TTSWord) );
        Word.eWordPartOfSpeech = MS_Unknown;

        pItemNormInfo = (TTSCurrencyItemInfo*) MemoryManager.GetMemory( sizeof(TTSCurrencyItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            //--- Fill in known parts of pItemNormInfo
            ZeroMemory( pItemNormInfo, sizeof(TTSCurrencyItemInfo) );
            pItemNormInfo->Type = eNUM_CURRENCY;
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->fQuantifier           = iQuantIndex >= 0 ? true : false;
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart    = (TTSNumberItemInfo*) pNumberInfo;
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->lNumPostNumberStates  = PostNumberList.GetCount();
            ( (TTSCurrencyItemInfo*) pItemNormInfo )->lNumPostSymbolStates  = PostSymbolList.GetCount();

            //--- Need to determine whether this currency will have a primary and secondary part
            //---   (e.g. "ten dollars and fifty cents") or just a primary part (e.g. "ten point
            //---   five zero cents", "one hundred dollars").

            //--- First check whether the number is a cardinal, there is a quantifier present, or the
            //---   currency unit has no secondary (e.g. cents).  In any of these cases, we need do no
            //---   further checking.
            if ( pNumberInfo->Type == eNUM_DECIMAL &&
                 iQuantIndex       == -1                &&
                 g_CurrencySigns[iSymbolIndex].SecondaryUnit.Len > 0 )
            {
                WCHAR *pDecimalPoint = wcschr( ( (TTSNumberItemInfo*) pNumberInfo )->pStartChar, wcDecimalPoint );
                SPDBG_ASSERT( pDecimalPoint );

                if ( pDecimalPoint &&
                     ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar - pDecimalPoint == 3 )
                {
                    //--- We do have a secondary part!  Fix up PrimaryNumberPart appropriately,
                    //---   and fill in pSecondaryNumberPart.
                    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
                    const WCHAR *pTemp = ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar;
                    m_pNextChar      = ( (TTSNumberItemInfo*) pNumberInfo )->pStartChar;
                    m_pEndOfCurrItem = pDecimalPoint;
                    delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
                    
                    //--- m_pNextChar == m_pEndOfCurrItem when integer part is empty and non-negative, e.g. $.50
                    //---   Other case is empty and negative, e.g. $-.50
                    if ( m_pNextChar != m_pEndOfCurrItem &&
                         !( *m_pNextChar == L'-' &&
                             m_pNextChar == m_pEndOfCurrItem - 1 ) )
                    {
                        hr = IsNumber( pNumberInfo, L"NUMBER", MemoryManager, false );
                    }
                    else
                    {
                        pNumberInfo = (TTSNumberItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberItemInfo ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( pNumberInfo, sizeof( TTSNumberItemInfo ) );
                            if ( *m_pNextChar == L'-' )
                            {
                                ( (TTSNumberItemInfo*) pNumberInfo )->fNegative = true;
                            }
                            else
                            {
                                ( (TTSNumberItemInfo*) pNumberInfo )->fNegative = false;
                            }
                            ( (TTSNumberItemInfo*) pNumberInfo )->pStartChar = NULL;
                            ( (TTSNumberItemInfo*) pNumberInfo )->pEndChar   = NULL;
                            ( (TTSNumberItemInfo*) pNumberInfo )->pIntegerPart =
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof( TTSIntegerItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ( (TTSNumberItemInfo*) pNumberInfo )->pIntegerPart->fDigitByDigit = true;
                                ( (TTSNumberItemInfo*) pNumberInfo )->pIntegerPart->ulNumDigits   = 1;
                                ( (TTSNumberItemInfo*) pNumberInfo )->pWordList = new CWordList;

                                if ( ( (TTSNumberItemInfo*) pNumberInfo )->fNegative )
                                {
                                    Word.pXmlState  = pNumberXMLState;
                                    Word.pWordText  = g_negative.pStr;
                                    Word.ulWordLen  = g_negative.Len;
                                    Word.pLemma     = Word.pWordText;
                                    Word.ulLemmaLen = Word.ulWordLen;
                                    ( (TTSNumberItemInfo*) pNumberInfo )->pWordList->AddTail( Word );
                                }

                                Word.pWordText  = g_ones[0].pStr;
                                Word.ulWordLen  = g_ones[0].Len;
                                Word.pLemma     = Word.pWordText;
                                Word.ulLemmaLen = Word.ulWordLen;
                                ( (TTSNumberItemInfo*) pNumberInfo )->pWordList->AddTail( Word );
                            }
                        }
                    }

                    if ( SUCCEEDED( hr ) )
                    {
                        ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart = 
                                                                        (TTSNumberItemInfo*) pNumberInfo;
                        m_pNextChar      = m_pEndOfCurrItem + 1;
                        m_pEndOfCurrItem = pTemp;
                        
                        //--- If zeroes, don't pronounce them...
                        if ( m_pNextChar[0] != L'0' )
                        {
                            hr = IsNumber( pNumberInfo, L"NUMBER", MemoryManager, false );
                            if ( SUCCEEDED( hr ) )
                            {
                                ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart = 
                                                                        (TTSNumberItemInfo*) pNumberInfo;
                            }
                        }
                        else if ( m_pNextChar[1] != L'0' )
                        {
                            m_pNextChar++;
                            hr = IsNumber( pNumberInfo, L"NUMBER", MemoryManager, false );
                            if ( SUCCEEDED( hr ) )
                            {
                                ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart =
                                                                        (TTSNumberItemInfo*) pNumberInfo;
                            }
                        }
                    }
                    m_pNextChar      = pTempNextChar;
                    m_pEndOfCurrItem = pTempEndOfItem;
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                //--- Expand Primary number part
                if ( fNegative )
                {
                    ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->fNegative = true;
                    Word.pXmlState          = pNumberXMLState;
                    Word.eWordPartOfSpeech  = MS_Unknown;
                    Word.pWordText          = g_negative.pStr;
                    Word.ulWordLen          = g_negative.Len;
                    Word.pLemma             = Word.pWordText;
                    Word.ulLemmaLen         = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
                hr = ExpandNumber( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart, WordList );
            }

            //--- Clean up Number XML States
            SPLISTPOS WordListPos;
            if ( SUCCEEDED( hr ) )
            {
                WordListPos = WordList.GetHeadPosition();
                while ( WordListPos )
                {
                    TTSWord& TempWord = WordList.GetNext( WordListPos );
                    TempWord.pXmlState = pNumberXMLState;
                }
            
                //--- Insert PostNumber XML States
                while ( !PostNumberList.IsEmpty() )
                {
                    WordList.AddTail( ( PostNumberList.RemoveHead() ).Words[0] );
                }

                //--- If a quantifier is present, expand it
                if ( iQuantIndex >= 0 )
                { 
                    Word.pXmlState  = pQuantifierXMLState;
                    Word.pWordText  = g_quantifiers[iQuantIndex].pStr;
                    Word.ulWordLen  = g_quantifiers[iQuantIndex].Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                BOOL fFraction = false;
                //--- If a fractional unit with no quantifier, insert "of a"
                if ( iQuantIndex < 0                                          &&
                     !( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart &&
                     !( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pIntegerPart    &&
                     ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pFractionalPart  &&
                     !( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pFractionalPart->fIsStandard )
                {
                    fFraction = true;
                    Word.pXmlState  = pNumberXMLState;
                    Word.eWordPartOfSpeech = MS_Unknown;
                    Word.pWordText  = g_of.pStr;
                    Word.ulWordLen  = g_of.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );

                    Word.pWordText  = g_a.pStr;
                    Word.ulWordLen  = g_a.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                //--- Insert Main Currency Unit
                //--- Plural if not a fraction and either a quantifier is present or the integral part is not one.
                if ( !fFraction &&
                     ( iQuantIndex >= 0 ||
                       ( ( ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pEndChar -
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar != 1 ) ||
                           ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar[0] != L'1' ) &&
                         ( ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pEndChar -
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar != 2 ) ||
                           ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar[0] != L'-' ||
                           ( (TTSCurrencyItemInfo*) pItemNormInfo )->pPrimaryNumberPart->pStartChar[1] != L'1' ) ) ) )
                {                     
                    Word.pXmlState  = pSymbolXMLState;
                    Word.pWordText  = g_CurrencySigns[iSymbolIndex].MainUnit.pStr;
                    Word.ulWordLen  = g_CurrencySigns[iSymbolIndex].MainUnit.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }
                //--- ONLY "one" or "negative one" should precede this...
                else
                {
                    Word.pXmlState  = pSymbolXMLState;
                    Word.pWordText  = g_SingularPrimaryCurrencySigns[iSymbolIndex].pStr;
                    Word.ulWordLen  = g_SingularPrimaryCurrencySigns[iSymbolIndex].Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );
                }

                //--- Insert Post Symbol XML States
                while ( !PostSymbolList.IsEmpty() )
                {
                    WordList.AddTail( ( PostSymbolList.RemoveHead() ).Words[0] );
                }

                //--- Insert Secondary number part
                if ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart )
                {
                    Word.pXmlState  = pNumberXMLState;
                    Word.pWordText  = g_And.pStr;
                    Word.ulWordLen  = g_And.Len;
                    Word.pLemma     = Word.pWordText;
                    Word.ulLemmaLen = Word.ulWordLen;
                    WordList.AddTail( Word );

                    WordListPos = WordList.GetTailPosition();
                
                    hr = ExpandNumber( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart, WordList );

                    //--- Clean up number XML State
                    if ( SUCCEEDED( hr ) )
                    {
                        while ( WordListPos )
                        {
                            TTSWord& TempWord  = WordList.GetNext( WordListPos );
                            TempWord.pXmlState = pNumberXMLState;
                        }
                    }

                    //--- Insert secondary currency unit
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart->pEndChar -
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart->pStartChar == 1 &&
                             ( (TTSCurrencyItemInfo*) pItemNormInfo )->pSecondaryNumberPart->pStartChar[0] == L'1' )
                        {
                            Word.pXmlState  = pSymbolXMLState;
                            Word.pWordText  = g_SingularSecondaryCurrencySigns[iSymbolIndex].pStr;
                            Word.ulWordLen  = g_SingularSecondaryCurrencySigns[iSymbolIndex].Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                        else
                        {
                            Word.pXmlState  = pSymbolXMLState;
                            Word.pWordText  = g_CurrencySigns[iSymbolIndex].SecondaryUnit.pStr;
                            Word.ulWordLen  = g_CurrencySigns[iSymbolIndex].SecondaryUnit.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                    }
                }

                if ( SUCCEEDED( hr ) )
                {
                    m_pNextChar = pTempNextChar;
                }
            }
        }
    }
    else
    {
        if ( pNumberInfo )
        {
            delete ( (TTSNumberItemInfo*) pNumberInfo )->pWordList;
        }
        m_pNextChar      = pTempNextChar;
        m_pEndChar       = pTempEndChar;
        m_pEndOfCurrItem = pTempEndOfItem;
        m_pCurrFrag      = pTempFrag;
    }

    return hr;
} /* IsCurrency */


/***********************************************************************************************
* IsRomanNumeral *
*----------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a fraction.  
*
*   RegExp:
*       [M](0-3) { [CM] || [CD] || { [D]?[C](0-3) } } { [XC] || [XL] || { [L]?[X](0-3) } }
*           { [IX] || [IV] || { [V]?[I](0-3) }}
*
*   Types assigned:
*       NUM_ROMAN_NUMERAL
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsRomanNumeral( TTSItemInfo*& pItemNormInfo, const WCHAR* Context,
                                      CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "NumNorm IsRomanNumeral" );

    HRESULT hr = S_OK;
    ULONG ulValue = 0, ulIndex = 0, ulMaxOfThree = 0, ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);

    //--- Match Thousands - M(0-3) 
    while ( ulIndex < ulTokenLen         && 
            towupper( m_pNextChar[ulIndex] ) == L'M' && 
            ulMaxOfThree < 3 )
    {
        ulValue += 1000;
        ulMaxOfThree++;
        ulIndex++;
    }
    if ( ulMaxOfThree > 3 )
    {
        hr = E_INVALIDARG;
    }

    //--- Match Hundreds - { [CM] || [CD] || { [D]?[C](0-3) } } 
    if ( SUCCEEDED( hr ) )
    {
        ulMaxOfThree = 0;
        //--- Matched C first 
        if ( ulIndex < ulTokenLen &&
             towupper( m_pNextChar[ulIndex] ) == L'C' )
        {
            ulValue += 100;
            ulMaxOfThree++;
            ulIndex++;
            //--- Special Case - CM = 900 
            if ( ulIndex < ulTokenLen &&
                 towupper( m_pNextChar[ulIndex] ) == L'M' )
            {
                ulValue += 800;
                ulIndex++;
            }
            //--- Special Case - CD = 400 
            else if ( ulIndex < ulTokenLen &&
                      towupper( m_pNextChar[ulIndex] ) == L'D' )
            {
                ulValue += 300;
                ulIndex++;
            }
            //--- Default Case 
            else 
            {
                while ( ulIndex < ulTokenLen &&
                        towupper( m_pNextChar[ulIndex] ) == L'C' &&
                        ulMaxOfThree < 3 )
                {
                    ulValue += 100;
                    ulMaxOfThree++;
                    ulIndex++;
                }
                if ( ulMaxOfThree > 3 )
                {
                    hr = E_INVALIDARG;
                }
            }
        }
        //--- Matched D First 
        else if ( ulIndex < ulTokenLen &&
                  towupper( m_pNextChar[ulIndex] ) == L'D' )
        {
            ulValue += 500;
            ulIndex++;
            ulMaxOfThree = 0;
            //--- Match C's 
            while ( ulIndex < ulTokenLen &&
                    towupper( m_pNextChar[ulIndex] ) == L'C' &&
                    ulMaxOfThree < 3 )
            {
                ulValue += 100;
                ulIndex++;
                ulMaxOfThree++;
            }
            if ( ulMaxOfThree > 3 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    //--- Match Tens - { [XC] || [XL] || { [L]?[X](0-3) } } 
    if ( SUCCEEDED( hr ) )
    {
        ulMaxOfThree = 0;
        //--- Matched X First 
        if ( ulIndex < ulTokenLen &&
             towupper( m_pNextChar[ulIndex] ) == L'X' )
        {
            ulValue += 10;
            ulMaxOfThree++;
            ulIndex++;
            //--- Special Case - XC = 90 
            if ( ulIndex < ulTokenLen &&
                 towupper( m_pNextChar[ulIndex] ) == L'C' )
            {
                ulValue += 80;
                ulIndex++;
            }
            //--- Special Case - XL = 40 
            else if ( ulIndex < ulTokenLen &&
                      towupper( m_pNextChar[ulIndex] ) == 'L' )
            {
                ulValue += 30;
                ulIndex++;
            }
            //--- Default Case 
            else
            {
                while ( ulIndex < ulTokenLen &&
                        towupper( m_pNextChar[ulIndex] ) == L'X' &&
                        ulMaxOfThree < 3 )
                {
                    ulValue += 10;
                    ulMaxOfThree ++;
                    ulIndex++;
                }
                if ( ulMaxOfThree > 3 )
                {
                    hr = E_INVALIDARG;
                }
            }
        }
        //--- Matched L First 
        else if ( ulIndex < ulTokenLen &&
                  towupper( m_pNextChar[ulIndex] ) == L'L' )
        {
            ulValue += 50;
            ulIndex++;
            //--- Match X's 
            while ( ulIndex < ulTokenLen &&
                    towupper( m_pNextChar[ulIndex] ) == L'X' &&
                    ulMaxOfThree < 3 )
            {
                ulValue += 10;
                ulMaxOfThree++;
                ulIndex++;
            }
            if ( ulMaxOfThree > 3 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    //--- Match Ones - { [IX] || [IV] || { [V]?[I](0-3) } } 
    if ( SUCCEEDED( hr ) )
    {
        ulMaxOfThree = 0;
        //--- Matched I First 
        if ( ulIndex < ulTokenLen &&
             towupper( m_pNextChar[ulIndex] ) == L'I' )
        {
            ulValue += 1;
            ulMaxOfThree++;
            ulIndex++;
            //--- Special Case - IX = 9 
            if ( ulIndex < ulTokenLen &&
                 towupper( m_pNextChar[ulIndex] ) == L'X' )
            {
                ulValue += 8;
                ulIndex++;
            }
            //--- Special Case - IV = 4 
            else if ( ulIndex < ulTokenLen &&
                      towupper( m_pNextChar[ulIndex] ) == L'V' )
            {
                ulValue += 3;
                ulIndex++;
            }
            //--- Default Case 
            else
            {
                while ( ulIndex < ulTokenLen &&
                        towupper( m_pNextChar[ulIndex] ) == L'I' &&
                        ulMaxOfThree < 3 )
                {
                    ulValue += 1;
                    ulMaxOfThree++;
                    ulIndex++;
                }
                if ( ulMaxOfThree > 3 )
                {
                    hr = E_INVALIDARG;
                }
            }
        }
        //--- Matched V First 
        else if ( ulIndex < ulTokenLen &&
                  towupper( m_pNextChar[ulIndex] ) == L'V' )
        {
            ulValue += 5;
            ulIndex++;
            //--- Match I's 
            while ( ulIndex < ulTokenLen &&
                    towupper( m_pNextChar[ulIndex] ) == L'I' &&
                    ulMaxOfThree < 3 )
            {
                ulValue += 1;
                ulMaxOfThree++;
                ulIndex++;
            }
            if ( ulMaxOfThree > 3 )
            {
                hr = E_INVALIDARG;
            }
        }
    }

    if ( ulIndex != ulTokenLen )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Successfully matched a roman numeral! 

        WCHAR *tempNumberString;
        //--- Max value of ulValue is 3999, so the resultant string cannot be more than
        //---     four characters long (plus one for the comma, just in case) 
        tempNumberString = (WCHAR*) MemoryManager.GetMemory( 6 * sizeof(WCHAR), &hr );
        if ( SUCCEEDED( hr ) )
        {
            TTSItemInfo *pNumberInfo = NULL;
            _ltow( (long) ulValue, tempNumberString, 10 );

            const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
            
            m_pNextChar      = tempNumberString;
            m_pEndOfCurrItem = tempNumberString + wcslen( tempNumberString );

            hr = IsNumber( pNumberInfo, Context, MemoryManager, false );

            m_pNextChar      = pTempNextChar;
            m_pEndOfCurrItem = pTempEndOfItem;

            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo = 
                    (TTSRomanNumeralItemInfo*) MemoryManager.GetMemory( sizeof( TTSRomanNumeralItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ( (TTSRomanNumeralItemInfo*) pItemNormInfo )->pNumberInfo = pNumberInfo;
                }
                pItemNormInfo->Type = eNUM_ROMAN_NUMERAL;
            }
        }
    }
    
    return hr;
} /* IsRomanNumeral */

/***********************************************************************************************
* IsPhoneNumber *
*---------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a phone number.  
*
*   RegExp:
*       { ddd-dddd } || { ddd-ddd-dddd }     
*
*   Types assigned:
*       NUM_PHONENUMBER
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsPhoneNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager, 
                                     CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsPhoneNumber" );

    HRESULT hr = S_OK;
    const WCHAR *pCountryCode = NULL, *pAreaCode = NULL, *pGroups[4] = { NULL, NULL, NULL, NULL };
    const WCHAR *pStartChar = m_pNextChar, *pEndChar = m_pEndChar, *pEndOfItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pFrag = m_pCurrFrag;
    BOOL fMatchedLeftParen = false, fMatchedOne = false;
    ULONG ulCountryCodeLen = 0, ulAreaCodeLen = 0, ulNumGroups = 0, ulGroupLen[4] = { 0, 0, 0, 0 };
    CItemList PostCountryCodeList, PostOneList, PostAreaCodeList, PostGroupLists[4];
    const SPVSTATE *pCountryCodeState = NULL, *pOneState = NULL, *pAreaCodeState = NULL;
    const SPVSTATE *pGroupStates[4] = { NULL, NULL, NULL, NULL };
    const WCHAR *pDelimiter = NULL;

    const WCHAR *pTempEndChar = NULL;
    const SPVTEXTFRAG *pTempFrag = NULL;
    
    ULONG i = 0;

    //--- Try to match Country Code
    if ( pStartChar[0] == L'+' )
    {
        pStartChar++;
        i = 0;

        //--- Try to match d(1-3)
        while ( pEndOfItem > pStartChar + i &&
                iswdigit( pStartChar[i] ) &&
                i < 3 )
        {
            i++;
        }

        pCountryCode      = pStartChar;
        pCountryCodeState = &pFrag->State;
        ulCountryCodeLen  = i;

        //--- Try to match delimiter
        if ( i >= 1                      &&
             pEndOfItem > pStartChar + i &&
             MatchPhoneNumberDelimiter( pStartChar[i] ) )
        {
            pDelimiter = pStartChar + i;
            pStartChar += i + 1;
        }
        //--- Try to advance in text - whitespace counts as a delimiter...
        else if ( i >= 1 &&
                  pEndOfItem == pStartChar + i )
        {
            pStartChar += i;
            pCountryCodeState = &pFrag->State;

            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                        &PostCountryCodeList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr       = E_INVALIDARG;
            }
            else if ( SUCCEEDED( hr ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Try to match a "1"
    if ( SUCCEEDED( hr )        &&
         !pCountryCode          &&
         pStartChar[0] == L'1'  &&
         !iswdigit( pStartChar[1] ) )
    {
        pOneState   = &pFrag->State;
        fMatchedOne = true;
        pStartChar++;

        if ( pEndOfItem > pStartChar &&
             MatchPhoneNumberDelimiter( pStartChar[0] ) )
        {
            //--- If we've already hit a delimiter, make sure all others agree
            if ( pDelimiter )
            {
                if ( *pDelimiter != pStartChar[0] )
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                pDelimiter = pStartChar;
            }
            pStartChar++;
        }
        //--- Try to advance in text - whitespace counts as a delimiter...
        else if ( !pDelimiter &&
                  pEndOfItem == pStartChar )
        {
            pOneState = &pFrag->State;

            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                        &PostOneList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr       = E_INVALIDARG;
            }
            else if ( SUCCEEDED( hr ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }    

    //--- Try to match Area Code
    if ( SUCCEEDED( hr ) &&
         pStartChar < pEndOfItem )
    {
        i = 0;

        //--- Try to match a left parenthesis
        if ( ( pCountryCode ||
               fMatchedOne )    &&
             pStartChar[0] == L'(' )
        {
            pStartChar++;
            fMatchedLeftParen = true;
        }
        else if ( !pCountryCode                      &&
                  !fMatchedOne                       &&
                  pStartChar > pFrag->pTextStart &&
                  *( pStartChar - 1 ) == L'(' )
        {
            fMatchedLeftParen = true;
        }
        
        if ( fMatchedLeftParen )
        {
            //--- Try to match ddd?
            while ( pEndOfItem > pStartChar + i &&
                    iswdigit( pStartChar[i] ) &&
                    i < 3 )
            {
                i++;
            }

            pAreaCodeState  = &pFrag->State;
            pAreaCode       = pStartChar;
            ulAreaCodeLen   = i;

            if ( i < 2 )
            {
                //--- Failed to match at least two digits
                hr = E_INVALIDARG;
            }
            else
            {
                if ( pStartChar[i] != L')' )
                {
                    //--- Matched left parenthesis without corresponding right parenthesis
                    hr = E_INVALIDARG;
                }
                else if ( ( !( pCountryCode || fMatchedOne ) &&
                            pEndOfItem > pStartChar + i ) ||
                          ( ( pCountryCode || fMatchedOne )  &&
                            pEndOfItem > pStartChar + i + 1 ) )
                {
                    i++;
                    //--- Delimiter is optional with parentheses
                    if ( MatchPhoneNumberDelimiter( pStartChar[i] ) )
                    {
                        //--- If we've already hit a delimiter, make sure all others agree
                        if ( pDelimiter )
                        {
                            if ( *pDelimiter != pStartChar[i] )
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                        else
                        {
                            pDelimiter = pStartChar + i;
                        }
                        i++;
                    }
                    pStartChar += i;
                }
                //--- Try to advance in text - whitespace counts as a delimiter...
                else if ( !pDelimiter )
                {
                    pStartChar += i + 1;
                    pAreaCodeState = &pFrag->State;

                    hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                                &PostAreaCodeList );
                    if ( !pStartChar &&
                         SUCCEEDED( hr ) )
                    {
                        hr       = E_INVALIDARG;
                    }
                    else if ( SUCCEEDED( hr ) )
                    {
                        pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
        }
    }

    //--- Try to match main number part
    if ( SUCCEEDED( hr ) &&
         pStartChar < pEndOfItem )
    {
        //--- Try to match some groups of digits
        for ( int j = 0; SUCCEEDED( hr ) && j < 4; j++ )
        {
            i = 0;

            //--- Try to match a digit string
            while ( pEndOfItem > pStartChar + i &&
                    iswdigit( pStartChar[i] ) &&
                    i < 4 )
            {
                i++;
            }

            //--- Try to match a delimiter
            if ( i >= 2 )
            {
                pGroupStates[j] = &pFrag->State;
                ulGroupLen[j]   = i;
                pGroups[j]      = pStartChar;
                pStartChar     += i;

                if ( pEndOfItem > pStartChar + 1 &&
                     MatchPhoneNumberDelimiter( pStartChar[0] ) )
                {
                    //--- If we've already hit a delimiter, make sure all others agree
                    if ( pDelimiter )
                    {
                        if ( *pDelimiter != pStartChar[0] )
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    //--- Only allow a new delimiter to be matched on the first main number group...
                    //---   e.g. "+45 35 32 90.89" should not all match...
                    else if ( j == 0 )
                    {
                        pDelimiter = pStartChar;
                    }
                    else
                    {
                        pEndChar = pTempEndChar;
                        pFrag    = pTempFrag;
                        ulNumGroups = j;
                        break;
                    }
                    pStartChar++;
                }
                //--- Try to advance in text - whitespace counts as a delimiter...
                else if ( !pDelimiter &&
                          pEndOfItem == pStartChar )
                {
                    pGroupStates[j] = &pFrag->State;

                    pTempEndChar = pEndChar;
                    pTempFrag    = pFrag;

                    hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, 
                                                &PostGroupLists[j] );
                    if ( !pStartChar &&
                         SUCCEEDED( hr ) )
                    {
                        pEndChar = pTempEndChar;
                        pFrag    = pTempFrag;
                        ulNumGroups = j + 1;
                        break;
                    }
                    else if ( SUCCEEDED( hr ) )
                    {
                        pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    }
                }
                else if ( pEndOfItem == pStartChar + 1 )
                {
                    if ( IsGroupEnding( *pStartChar )       != eUNMATCHED  ||
                         IsQuotationMark( *pStartChar )     != eUNMATCHED  ||
                         IsMiscPunctuation( *pStartChar )   != eUNMATCHED  ||
                         IsEOSItem( *pStartChar )           != eUNMATCHED )
                    {
                        pEndOfItem--;
                        ulNumGroups = j + 1;
                        break;
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    while ( pEndOfItem != pStartChar )
                    {
                        if ( IsGroupEnding( *pEndOfItem )       != eUNMATCHED  ||
                             IsQuotationMark( *pEndOfItem )     != eUNMATCHED  ||
                             IsMiscPunctuation( *pEndOfItem )   != eUNMATCHED  ||
                             IsEOSItem( *pEndOfItem )           != eUNMATCHED )
                        {
                            pEndOfItem--;
                        }
                        else
                        {
                            break;
                        }
                    }
                    if ( pEndOfItem == pStartChar )
                    {
                        ulNumGroups = j + 1;
                        break;
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                        break;
                    }
                }
            }
            //--- Matched something like 206.709.8286.1 - definitely bad
            else if ( pDelimiter )
            {
                hr = E_INVALIDARG;
            }
            //--- Matched somethinge like 206 709 8286 1 - could be OK
            else
            {
                if ( pTempEndChar )
                {
                    pEndChar = pTempEndChar;
                    pFrag    = pTempFrag;
                }
                ulNumGroups = j;
                break;
            }
        }
        //--- Didn't hit either break statement
        if ( !ulNumGroups )
        {
            ulNumGroups = j;
        }
    }

    //--- Check for appropriate formats
    if ( SUCCEEDED( hr ) )
    {
        //--- Check for [1<sep>]?(ddd?)<sep>?ddd<sep>dddd? OR ddd<sep>dddd?
        if ( !pCountryCode      &&
             ulNumGroups == 2   &&
             ulGroupLen[0] == 3 &&
             ulGroupLen[1] >= 3 &&
             !( fMatchedOne && !pAreaCode ) )         
        {
            if ( ( !Context ||
                   _wcsicmp( Context, L"phone_number" ) != 0 ) &&
                 !pCountryCode &&
                 !pAreaCode    &&
                 !fMatchedOne  &&
                 ( pDelimiter ? (*pDelimiter == L'.') : 0 ) )
            {
                hr = E_INVALIDARG;
            }
        }
        //--- Check for [1<sep>]?ddd?<sep>ddd<sep>dddd?
        else if ( !pCountryCode             &&
                  !pAreaCode                &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] == 3        &&
                  ulGroupLen[2] >= 3 )
        {
            pAreaCode           = pGroups[0];
            ulAreaCodeLen       = ulGroupLen[0];
            pAreaCodeState      = pGroupStates[0];
            PostAreaCodeList.AddTail( &PostGroupLists[0] );
            pGroups[0]          = pGroups[1];
            ulGroupLen[0]       = ulGroupLen[1];
            pGroupStates[0]     = pGroupStates[1];
            PostGroupLists[0].RemoveAll();
            PostGroupLists[0].AddTail( &PostGroupLists[1] );
            pGroups[1]          = pGroups[2];
            ulGroupLen[1]       = ulGroupLen[2];
            pGroupStates[1]     = pGroupStates[2];
            PostGroupLists[1].RemoveAll();
            PostGroupLists[2].RemoveAll();
            ulNumGroups--;
        }
        //--- Check for (ddd?)<sep>?ddd?<sep>dd<sep>ddd?d?
        else if ( !pCountryCode             &&
                  !fMatchedOne              &&
                  pAreaCode                 &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] == 2        &&
                  ulGroupLen[2] >= 2 )
        {
            NULL;
        }
        //--- Check for +dd?d?<sep>ddd?<sep>ddd?<sep>ddd?d?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  !pAreaCode                &&
                  ulNumGroups == 4          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ( ulGroupLen[1] == 2 ||
                    ulGroupLen[1] == 3 )    &&
                  ulGroupLen[2] >= 2        &&
                  ulGroupLen[3] >= 2 )
        {
            pAreaCode           = pGroups[0];
            ulAreaCodeLen       = ulGroupLen[0];
            pAreaCodeState      = pGroupStates[0];
            PostAreaCodeList.AddTail( &PostGroupLists[0] );
            pGroups[0]          = pGroups[1];
            ulGroupLen[0]       = ulGroupLen[1];
            pGroupStates[0]     = pGroupStates[1];
            PostGroupLists[0].RemoveAll();
            PostGroupLists[0].AddTail( &PostGroupLists[1] );
            pGroups[1]          = pGroups[2];
            ulGroupLen[1]       = ulGroupLen[2];
            pGroupStates[1]     = pGroupStates[2];
            PostGroupLists[1].RemoveAll();
            PostGroupLists[1].AddTail( &PostGroupLists[2] );
            pGroups[2]          = pGroups[3];
            ulGroupLen[2]       = ulGroupLen[3];
            pGroupStates[2]     = pGroupStates[3];
            PostGroupLists[2].RemoveAll();
            PostGroupLists[3].RemoveAll();
            ulNumGroups--;
        }
        //--- Check for +dd?d?<sep>ddd?<sep>ddd?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  !pAreaCode                &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ( ulGroupLen[1] == 2 ||
                    ulGroupLen[1] == 3 )    &&
                  ulGroupLen[2] >= 2 )
        {
            pAreaCode           = pGroups[0];
            ulAreaCodeLen       = ulGroupLen[0];
            pAreaCodeState      = pGroupStates[0];
            PostAreaCodeList.AddTail( &PostGroupLists[0] );
            pGroups[0]          = pGroups[1];
            ulGroupLen[0]       = ulGroupLen[1];
            pGroupStates[0]     = pGroupStates[1];
            PostGroupLists[0].RemoveAll();
            PostGroupLists[0].AddTail( &PostGroupLists[1] );
            pGroups[1]          = pGroups[2];
            ulGroupLen[1]       = ulGroupLen[2];
            pGroupStates[1]     = pGroupStates[2];
            PostGroupLists[1].RemoveAll();
            PostGroupLists[2].RemoveAll();
            ulNumGroups--;
        }
        //--- Check for +dd?d?<sep>(ddd?)<sep>?ddd?<sep>ddd?d?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  pAreaCode                 &&
                  ulNumGroups == 3          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] >= 2        &&
                  ulGroupLen[2] >= 2 )
        {
            NULL;
        }
        //--- Check for +dd?d?<sep>(ddd?)<sep>?ddd?<sep>ddd?d?
        else if ( pCountryCode              &&
                  !fMatchedOne              &&
                  pAreaCode                 &&
                  ulNumGroups == 2          &&
                  ( ulGroupLen[0] == 2 ||
                    ulGroupLen[0] == 3 )    &&
                  ulGroupLen[1] >= 2 )
        {
            NULL;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Fill in pItemNormInfo
    if ( SUCCEEDED(hr) )
    {
        m_pEndOfCurrItem = pGroups[ulNumGroups-1] + ulGroupLen[ulNumGroups-1];
        m_pEndChar  = pEndChar;
        m_pCurrFrag = pFrag;

        pItemNormInfo = (TTSPhoneNumberItemInfo*) MemoryManager.GetMemory( sizeof(TTSPhoneNumberItemInfo),
                                                                                   &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pItemNormInfo, sizeof(TTSPhoneNumberItemInfo) );
            pItemNormInfo->Type = eNEWNUM_PHONENUMBER;

            //--- Fill in fOne
            if ( fMatchedOne )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->fOne = true;
            }

            //--- Fill in Country Code...
            if ( pCountryCode )
            {
                TTSItemInfo* pCountryCodeInfo;
                const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
                m_pNextChar      = pCountryCode;
                m_pEndOfCurrItem = pCountryCode + ulCountryCodeLen;

                hr = IsNumber( pCountryCodeInfo, L"NUMBER", MemoryManager, false );
                if ( SUCCEEDED( hr ) )
                {
                    ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pCountryCode = (TTSNumberItemInfo*) pCountryCodeInfo;
                }

                m_pNextChar      = pTempNextChar;
                m_pEndOfCurrItem = pTempEndOfItem;
            }

            //--- Fill in Area Code...
            if ( SUCCEEDED( hr ) &&
                 pAreaCode )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode = 
                    (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof( TTSDigitsItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode->ulNumDigits = ulAreaCodeLen;
                    ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode->pFirstDigit = pAreaCode;
                }
            }

            //--- Fill in Main Number...
            if ( SUCCEEDED( hr ) )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ulNumGroups = ulNumGroups;
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups = 
                    (TTSDigitsItemInfo**) MemoryManager.GetMemory( ulNumGroups * sizeof(TTSDigitsItemInfo*), &hr );

                for ( ULONG j = 0; SUCCEEDED( hr ) && j < ulNumGroups; j++ )
                {
                     ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j] = 
                        (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof( TTSDigitsItemInfo ), &hr );
                     if ( SUCCEEDED( hr ) )
                     {
                         ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j]->ulNumDigits = ulGroupLen[j];
                         ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j]->pFirstDigit = pGroups[j];
                     }
                }
            }
        }
    }

    //--- Expand Phone Number
    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );
        Word.eWordPartOfSpeech = MS_Unknown;
        SPLISTPOS ListPos;

        if ( pCountryCode )
        {
            //--- Insert "country"
            Word.pXmlState  = pCountryCodeState;
            Word.pWordText  = g_Country.pStr;
            Word.ulWordLen  = g_Country.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert "code" 
            Word.pWordText  = g_Code.pStr;
            Word.ulWordLen  = g_Code.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            ListPos = WordList.GetTailPosition();

            //--- Expand Country Code
            ExpandNumber( ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pCountryCode, WordList );

            //--- Clean up digits XML states...
            WordList.GetNext( ListPos );
            while ( ListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( ListPos );
                TempWord.pXmlState = pCountryCodeState;
            }

            //--- Insert Post Symbol XML States
            while ( !PostCountryCodeList.IsEmpty() )
            {
                WordList.AddTail( ( PostCountryCodeList.RemoveHead() ).Words[0] );
            }
        }

        if ( fMatchedOne )
        {
            //--- Insert "one"
            Word.pXmlState  = pOneState;
            Word.pWordText  = g_ones[1].pStr;
            Word.ulWordLen  = g_ones[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert PostOne XML States
            while ( !PostOneList.IsEmpty() )
            {
                WordList.AddTail( ( PostOneList.RemoveHead() ).Words[0] );
            }
        }

        if ( pAreaCode )
        {
            //--- Expand digits - 800 and 900 get expanded as one number, otherwise digit by digit 
            if ( ( pAreaCode[0] == L'8' ||
                   pAreaCode[0] == L'9' ) &&
                 pAreaCode[1] == L'0'     &&
                 pAreaCode[2] == L'0' )
            {
                ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->fIs800 = true;
                NumberGroup Garbage;

                ListPos = WordList.GetTailPosition();

                ExpandThreeDigits( pAreaCode, Garbage, WordList ); 

                //--- Clean up digits XML states...
                //--- List was possibly empty prior to inserting "eight hundred" or "nine hundred"...
                if ( !ListPos )
                {
                    ListPos = WordList.GetHeadPosition();
                }
                WordList.GetNext( ListPos );
                while ( ListPos )
                {
                    TTSWord& TempWord  = WordList.GetNext( ListPos );
                    TempWord.pXmlState = pAreaCodeState;
                }
            }
            else
            {
                //--- Insert "area"
                Word.pXmlState  = pAreaCodeState;
                Word.pWordText  = g_Area.pStr;
                Word.ulWordLen  = g_Area.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
        
                //--- Insert "code" 
                Word.pWordText  = g_Code.pStr;
                Word.ulWordLen  = g_Code.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );

                ListPos = WordList.GetTailPosition();

                ExpandDigits( ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->pAreaCode, WordList );

                //--- Clean up digits XML states...
                WordList.GetNext( ListPos );
                while ( ListPos )
                {
                    TTSWord& TempWord  = WordList.GetNext( ListPos );
                    TempWord.pXmlState = pAreaCodeState;
                }
            }
            //--- Insert PostAreaCode XML States
            while ( !PostAreaCodeList.IsEmpty() )
            {
                WordList.AddTail( ( PostAreaCodeList.RemoveHead() ).Words[0] );
            }
        }

        for ( ULONG j = 0; j < ulNumGroups; j++ )
        {
            ListPos = WordList.GetTailPosition();

            ExpandDigits( ( (TTSPhoneNumberItemInfo*) pItemNormInfo )->ppGroups[j], WordList );

            //--- Clean up digits XML states...
            //--- List was possibly empty prior to inserting "eight hundred" or "nine hundred"...
            if ( !ListPos )
            {
                ListPos = WordList.GetHeadPosition();
            }
            WordList.GetNext( ListPos );
            while ( ListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( ListPos );
                TempWord.pXmlState = pGroupStates[j];
            }

            //--- Insert Post Group XML States
            while ( !PostGroupLists[j].IsEmpty() )
            {
                WordList.AddTail( ( PostGroupLists[j].RemoveHead() ).Words[0] );
            }
        }
    }

    return hr;
} /* IsPhoneNumber */

/***********************************************************************************************
* IsZipCode *
*-----------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a zipcode.  
*
*   RegExp:
*       ddddd{-dddd}?   
*
*   Types assigned:
*       NUM_ZIPCODE
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsZipCode( TTSItemInfo*& pItemNormInfo, const WCHAR* Context,
                                 CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsZipCode" );

    HRESULT hr = S_OK;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    BOOL fLastFour = false;

    //--- length must be 5 or 10 
    if ( ulTokenLen != 5 && 
         ulTokenLen != 10 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- match 5 digits 
        for ( ULONG i = 0; i < 5; i++ )
        {
            if ( !iswdigit( m_pNextChar[i] ) )
            {
                hr = E_INVALIDARG;
                break;
            }
        }
        if ( SUCCEEDED(hr) && 
             i < ulTokenLen )
        {
            //--- match dash 
            if ( m_pNextChar[i] != L'-' )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                //--- match 4 digits 
                for ( i = 0; i < 4; i++ )
                {
                    if ( !iswdigit( m_pNextChar[i] ) )
                    {
                        hr = E_INVALIDARG;
                        break;
                    }
                }
                fLastFour = true;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        pItemNormInfo = (TTSZipCodeItemInfo*) MemoryManager.GetMemory( sizeof(TTSZipCodeItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pItemNormInfo, sizeof(TTSZipCodeItemInfo) );
            pItemNormInfo->Type = eNUM_ZIPCODE;
            ( (TTSZipCodeItemInfo*) pItemNormInfo )->pFirstFive = 
                (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof(TTSDigitsItemInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {   
                ( (TTSZipCodeItemInfo*) pItemNormInfo )->pFirstFive->ulNumDigits = 5;
                ( (TTSZipCodeItemInfo*) pItemNormInfo )->pFirstFive->pFirstDigit = m_pNextChar;
                if ( fLastFour )
                {
                    ( (TTSZipCodeItemInfo*) pItemNormInfo )->pLastFour = 
                        (TTSDigitsItemInfo*) MemoryManager.GetMemory( sizeof(TTSDigitsItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ( (TTSZipCodeItemInfo*) pItemNormInfo )->pLastFour->ulNumDigits = 4;
                        ( (TTSZipCodeItemInfo*) pItemNormInfo )->pLastFour->pFirstDigit = m_pNextChar + 6;
                    }
                }
            }
        }
    }

    return hr;
} /* IsZipCode */

/***********************************************************************************************
* ExpandZipCode *
*---------------*
*   Description:
*       Expands Items previously determined to be of type NUM_ZIPCODE by IsZipCode.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandZipCode( TTSZipCodeItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandZipCode" );

    HRESULT hr = S_OK;

    ExpandDigits( pItemInfo->pFirstFive, WordList );
    
    if ( pItemInfo->pLastFour )
    {
        //--- Insert "dash"
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );
        Word.pXmlState          = &m_pCurrFrag->State;
        Word.eWordPartOfSpeech  = MS_Unknown;
        Word.pWordText          = g_dash.pStr;
        Word.ulWordLen          = g_dash.Len;
        Word.pLemma             = Word.pWordText;
        Word.ulLemmaLen         = Word.ulWordLen;
        WordList.AddTail( Word );

        ExpandDigits( pItemInfo->pLastFour, WordList );
    }

    return hr;
} /* ExpandZipCode */

/***********************************************************************************************
* IsNumberRange *
*---------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a number range.
*
*   RegExp:
*       [Number]-[Number]  
*
*   Types assigned:
*       NUM_RANGE
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumberRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsNumberRange" );

    HRESULT hr = S_OK;
    TTSItemInfo *pFirstNumberInfo = NULL, *pSecondNumberInfo = NULL;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    const WCHAR *pHyphen = NULL;

    for ( pHyphen = m_pNextChar; pHyphen < m_pEndOfCurrItem; pHyphen++ )
    {
        if ( *pHyphen == L'-' )
        {
            break;
        }
    }

    if ( *pHyphen == L'-' &&
         pHyphen > m_pNextChar &&
         pHyphen < m_pEndOfCurrItem - 1 )
    {
        m_pEndOfCurrItem = pHyphen;
        hr = IsNumber( pFirstNumberInfo, NULL, MemoryManager );

        if ( SUCCEEDED( hr ) )
        {
            m_pNextChar      = pHyphen + 1;
            m_pEndOfCurrItem = pTempEndOfItem;
            hr = IsNumberCategory( pSecondNumberInfo, NULL, MemoryManager );					

			if ( SUCCEEDED( hr ) )
            {
                //--- Matched a number range!
                pItemNormInfo = 
                    (TTSNumberRangeItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberRangeItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    pItemNormInfo->Type = eNUM_RANGE;
                    ( (TTSNumberRangeItemInfo*) pItemNormInfo )->pFirstNumberInfo  = pFirstNumberInfo;
                    ( (TTSNumberRangeItemInfo*) pItemNormInfo )->pSecondNumberInfo = pSecondNumberInfo;
                }
            }
            else if ( pFirstNumberInfo->Type != eDATE_YEAR )
            {   
                delete ( (TTSNumberItemInfo*) pFirstNumberInfo )->pWordList;
            }
        }
        m_pNextChar      = pTempNextChar;
        m_pEndOfCurrItem = pTempEndOfItem;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* IsNumberRange */

/***********************************************************************************************
* ExpandNumberRange *
*-------------------*
*   Description:
*       Expands Items previously determined to be of type NUM_RANGE by IsNumberRange.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandNumberRange( TTSNumberRangeItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandNumberRange" );

    HRESULT hr = S_OK;

    //--- Expand first number (or year)...
    switch( pItemInfo->pFirstNumberInfo->Type )
    {
    case eDATE_YEAR:
        hr = ExpandYear( (TTSYearItemInfo*) pItemInfo->pFirstNumberInfo, WordList );
        break;
    default:
        hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pFirstNumberInfo, WordList );
        break;
    }

    //--- Insert "to"
    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof( TTSWord ) );

        Word.pXmlState          = &m_pCurrFrag->State;
        Word.eWordPartOfSpeech  = MS_Unknown;
        Word.pWordText          = g_to.pStr;
        Word.ulWordLen          = g_to.Len;
        Word.pLemma             = Word.pWordText;
        Word.ulLemmaLen         = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    //--- Expand second number (or year)...
    if ( SUCCEEDED( hr ) )
    {
        switch( pItemInfo->pSecondNumberInfo->Type )
        {
        case eDATE_YEAR:
            hr = ExpandYear( (TTSYearItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
            break;
		case eNUM_PERCENT:
			hr = ExpandPercent( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;			
		case eNUM_DEGREES:
			hr = ExpandDegrees( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;
		case eNUM_SQUARED:
			hr = ExpandSquare( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;
	    case eNUM_CUBED:
		    hr = ExpandCube( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
			break;
        default:
             hr = ExpandNumber( (TTSNumberItemInfo*) pItemInfo->pSecondNumberInfo, WordList );
            break;
        }
    }

    return hr;
} /* ExpandNumberRange */


/***********************************************************************************************
* IsCurrencyRange *
*-------------------*
*   Description:
*       Expands Items determined to be of type CURRENCY_RANGE
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsCurrencyRange( TTSItemInfo*& pItemInfo, CSentItemMemory& MemoryManager, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsCurrencyRange" );

    HRESULT hr = S_OK;
    TTSItemInfo *pFirstNumberInfo = NULL, *pSecondNumberInfo = NULL;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem, *pTempEndChar = m_pEndChar;
    const WCHAR *pHyphen = NULL;	
	CWordList TempWordList;
	NORM_POSITION ePosition = UNATTACHED;  //for currency sign checking
	int iSymbolIndex, iTempSymbolIndex = -1;
	WCHAR *tempNumberString;

	iSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );	
	
	if(iSymbolIndex < 0)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		for ( pHyphen = m_pNextChar; pHyphen < m_pEndOfCurrItem; pHyphen++ )
		{
			if ( *pHyphen == L'-' )
			{
				break;
			}
		}

		if ( !( *pHyphen == L'-' &&
			    pHyphen > m_pNextChar &&
			    pHyphen < m_pEndOfCurrItem - 1 ) )
		{
			hr = E_INVALIDARG;
		}
		else
		{			
			*( (WCHAR*)pHyphen) = L' ';  // Token must break at hyphen, or IsCurrency() will not work
			m_pNextChar      = pTempNextChar;
			m_pEndOfCurrItem = pHyphen;			
			NORM_POSITION temp = UNATTACHED;
			iTempSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, temp );
			if( iTempSymbolIndex >= 0 && iSymbolIndex != iTempSymbolIndex ) 
			{
				hr = E_INVALIDARG;
			}
			else   //--- Get both NumberInfos
			{
				hr = IsNumber( pFirstNumberInfo, L"NUMBER", MemoryManager, false );
				if( SUCCEEDED ( hr ) )
				{
					m_pNextChar = pHyphen + 1;
					m_pEndOfCurrItem = pTempEndOfItem;
					iTempSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, temp );
					hr = IsNumber( pSecondNumberInfo, L"NUMBER", MemoryManager, false );
				}
			}
			if( SUCCEEDED ( hr ) ) 
			{
			    //--- If both currency values are cardinal numbers, then the first number can be
			    //--- expanded without saying its currency ("$10-12" -> "ten to twelve dollars")
				if( pFirstNumberInfo->Type == eNUM_CARDINAL && pSecondNumberInfo->Type == eNUM_CARDINAL )
				{   
					ExpandNumber( (TTSNumberItemInfo*) pFirstNumberInfo, TempWordList );
				}
				else  // one or both values are non-cardinal numbers, so we must 
				{     // expand the first value as a full currency.
					m_pNextChar      = pTempNextChar;
					m_pEndOfCurrItem = pHyphen;

					if( ePosition == FOLLOWING ) 
					{
						if( iTempSymbolIndex < 0 )  // No symbol on first number item - need to fill a buffer
                        {						    // with currency symbol and value to pass to IsCurrency().
							ULONG ulNumChars = (long)(m_pEndOfCurrItem - m_pNextChar + g_CurrencySigns[iSymbolIndex].Sign.Len + 1);
							tempNumberString = (WCHAR*) MemoryManager.GetMemory( (ulNumChars) * sizeof(WCHAR), &hr );
							if ( SUCCEEDED( hr ) )
							{	
								ZeroMemory( tempNumberString, ( ulNumChars ) * sizeof( WCHAR ) );
								wcsncpy( tempNumberString, m_pNextChar, m_pEndOfCurrItem - m_pNextChar );
								wcscat( tempNumberString, g_CurrencySigns[iSymbolIndex].Sign.pStr );						
								m_pNextChar      = tempNumberString;
								m_pEndOfCurrItem = tempNumberString + wcslen( tempNumberString );
								m_pEndChar = m_pEndOfCurrItem;
							}                
						}
						else if( iTempSymbolIndex != iSymbolIndex )	// mismatched symbols
						{
							hr = E_INVALIDARG;
						}
					}
					if ( SUCCEEDED ( hr ) ) 
					{
						hr = IsCurrency( pFirstNumberInfo, MemoryManager, TempWordList );
						m_pEndChar = pTempEndChar;
					}
				}
			}

			if ( SUCCEEDED ( hr ) ) 
			{						
				TTSWord Word;
				ZeroMemory( &Word, sizeof( TTSWord ) );

				Word.pXmlState          = &m_pCurrFrag->State;
				Word.eWordPartOfSpeech  = MS_Unknown;
				Word.pWordText          = g_to.pStr;
				Word.ulWordLen          = g_to.Len;
				Word.pLemma             = Word.pWordText;
				Word.ulLemmaLen         = Word.ulWordLen;
				TempWordList.AddTail( Word );
		
				m_pNextChar = pHyphen + 1;
				m_pEndOfCurrItem = pTempEndOfItem;
					
				if( ePosition == PRECEDING ) 
				{
					iTempSymbolIndex = MatchCurrencySign( m_pNextChar, m_pEndOfCurrItem, ePosition );
					if( iTempSymbolIndex < 0 )  // No symbol on second number item
					{    // create temporary string from first currency sign and second number item
						ULONG ulNumChars = (long)(m_pEndOfCurrItem - m_pNextChar + g_CurrencySigns[iSymbolIndex].Sign.Len + 1);
						tempNumberString = (WCHAR*) MemoryManager.GetMemory( (ulNumChars) * sizeof(WCHAR), &hr );
						if ( SUCCEEDED( hr ) )
						{
							ZeroMemory( tempNumberString, ( ulNumChars ) * sizeof( WCHAR ) );
							wcsncpy( tempNumberString, g_CurrencySigns[iSymbolIndex].Sign.pStr, g_CurrencySigns[iSymbolIndex].Sign.Len );
							wcsncpy( tempNumberString+g_CurrencySigns[iSymbolIndex].Sign.Len, m_pNextChar, m_pEndOfCurrItem - m_pNextChar );
							m_pNextChar      = tempNumberString;
							m_pEndOfCurrItem = tempNumberString + wcslen( tempNumberString );
							m_pEndChar = m_pEndOfCurrItem;
						}                
					}
					else if( iTempSymbolIndex == iSymbolIndex )	// matched leading symbol on second number item
					{
						m_pNextChar = pHyphen + 1;
						m_pEndOfCurrItem = pTempEndOfItem;
					}
					else	// mismatched symbol
					{
						hr = E_INVALIDARG;
					}
				}
					
				if( SUCCEEDED(hr) ) 
				{
					hr = IsCurrency( pSecondNumberInfo, MemoryManager, TempWordList );						
					if ( SUCCEEDED( hr ) )
					{							
						//--- Matched a currency range!
						pItemInfo = 
							(TTSNumberRangeItemInfo*) MemoryManager.GetMemory( sizeof( TTSNumberRangeItemInfo ), &hr );
						if ( SUCCEEDED( hr ) )
						{
							pItemInfo->Type = eNUM_CURRENCYRANGE;
							( (TTSNumberRangeItemInfo*) pItemInfo )->pFirstNumberInfo  = pFirstNumberInfo;
							( (TTSNumberRangeItemInfo*) pItemInfo )->pSecondNumberInfo = pSecondNumberInfo;
			                //--- Copy temp word list to real word list if everything has succeeded...
							WordList.AddTail( &TempWordList );
						}
					}
				}
			}	
			*( (WCHAR*)pHyphen) = L'-';
		}
	}
	//Reset member variables regardless of failure or success
    m_pNextChar      = pTempNextChar;
    m_pEndOfCurrItem = pTempEndOfItem;
	m_pEndChar = pTempEndChar;
	
    return hr;
} /* IsCurrencyRange */

/***********************************************************************************************
* MatchCurrencySign *
*-------------------*
*   Description:
*       Helper function which tries to match a currency sign at the beginning of a string.
********************************************************************* AH **********************/
int MatchCurrencySign( const WCHAR*& pStartChar, const WCHAR*& pEndChar, NORM_POSITION& ePosition )
{
    int Index = -1;

    for (int i = 0; i < sp_countof(g_CurrencySigns); i++)
    {
        if ( pEndChar - pStartChar >= g_CurrencySigns[i].Sign.Len && 
             wcsnicmp( pStartChar, g_CurrencySigns[i].Sign.pStr, g_CurrencySigns[i].Sign.Len ) == 0 )
        {
            Index = i;
            pStartChar += g_CurrencySigns[i].Sign.Len;
            ePosition = PRECEDING;
            break;
        }
    }

    if ( Index == -1 )
    {
        for ( int i = 0; i < sp_countof(g_CurrencySigns); i++ )
        {
            if ( pEndChar - pStartChar >= g_CurrencySigns[i].Sign.Len &&
                 wcsnicmp( pEndChar - g_CurrencySigns[i].Sign.Len, g_CurrencySigns[i].Sign.pStr, g_CurrencySigns[i].Sign.Len ) == 0 )
            {
                Index = i;
                pEndChar -= g_CurrencySigns[i].Sign.Len;
                ePosition = FOLLOWING;
                break;
            }
        }
    }

    return Index;
} /* MatchCurrencySign */      

/***********************************************************************************************
* Zeroes *
*--------*
*   Description:
*       A helper function which simply determines if a number string contains only zeroes...
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
bool CStdSentEnum::Zeroes(const WCHAR *NumberString)
{
    bool bAllZeroes = true;
    for (ULONG i = 0; i < wcslen(NumberString); i++)
    {
        if (NumberString[i] != '0' && isdigit(NumberString[i]) )
        {
            bAllZeroes = false;
            break;
        }
        else if ( !isdigit( NumberString[i] ) && NumberString[i] != ',' )
        {
            break;
        }
    }
    return bAllZeroes;
} /* Zeroes */

/***********************************************************************************************
* ThreeZeroes *
*-------------*
*   Description:
*       A helper function which simply determines if a number string contains three zeroes...
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
bool CStdSentEnum::ThreeZeroes(const WCHAR *NumberString)
{
    bool bThreeZeroes = true;
    for (ULONG i = 0; i < 3; i++)
    {
        if (NumberString[i] != '0' && isdigit(NumberString[i]))
        {
            bThreeZeroes = false;
            break;
        }
    }
    return bThreeZeroes;
} /* ThreeZeroes */

//-----------End Of File-------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\reverbfx.cpp ===
/*******************************************************************************
* ReverbFX.cpp *
*-------------*
*   Description:
*       This module is the implementation file for the CReverbFX class.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

#include "stdafx.h"
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef ReverbFX_H
#include "ReverbFX.h"
#endif



/*****************************************************************************
* CReverbFX::DecibelToPercent *
*-----------------------------*
*   Description:
*   Converts Voltage percentage from dB
*       v = 10^(dB/20)      
*       
********************************************************************** MC ***/
REVERBL CReverbFX::DecibelToPercent( float flDecibel )
{
    SPDBG_FUNC( "CReverbFX::DecibelToPercent" );
    float    fltIntVol;
    
    if( flDecibel >= REVERB_MIN_DB )
    {
        fltIntVol = (float) pow( 10.0, (double)flDecibel / 20.0 );
    }
    else
    {
        fltIntVol = 0.0;
    }
    
#ifdef FLOAT_REVERB
    return fltIntVol;
#else
    fltIntVol = fltIntVol * REVERB_VOL_LEVELS;
    return (REVERBL)fltIntVol;
#endif
} /* CReverbFX::DecibelToPercent */




/*****************************************************************************
* CReverbFX::ClearReverb *
*------------------------*
*   Description:
*   Fills the delay line with silence.
*       
********************************************************************** MC ***/
void CReverbFX::ClearReverb( LP_Reverb_Mod mod )
{
    SPDBG_FUNC( "CReverbFX::ClearReverb" );
    long        i;
    REVERBT     *dPtr;
    
    dPtr = mod->psDelayBuffer;
    for( i = 0; i < mod->dwDelayBufferSize; i++ )
    {
        *dPtr++ = 0;
    }
} /* CReverbFX::ClearReverb */




/*****************************************************************************
* CReverbFX::AllocReverbModule *
*------------------------------*
*   Description:
*       
********************************************************************** MC ***/
short   CReverbFX::AllocReverbModule 
                    (
                     LP_Reverb_Mod  mod,
                     REVERBL        lGain,              // Gain of the amplifiers.
                     long           dwDelay,            // Length of the delay line.
                     long           dwDelayBufferSize   // Size of the delay buffer.
                    )
{
    SPDBG_FUNC( "CReverbFX::AllocReverbModule" );
    short       result;
    
    
    result = KREVERB_NOERROR;
    mod->lGain              = lGain;
    mod->dwDelay            = dwDelay;
    mod->dwDelayBufferSize  = dwDelayBufferSize;
    mod->psDelayBuffer      = new REVERBT[mod->dwDelayBufferSize];
    if( mod->psDelayBuffer == NULL )
    {
        result = KREVERB_MEMERROR;
    }
    else
    {
        mod->psDelayEnd = mod->psDelayBuffer + mod->dwDelayBufferSize;
        mod->psDelayOut = mod->psDelayBuffer;
        if( mod->dwDelayBufferSize == mod->dwDelay )
        {
            mod->psDelayIn  = mod->psDelayBuffer;
        }
        else
        {
            mod->psDelayIn  = mod->psDelayBuffer + mod->dwDelay;
        }
        ClearReverb( mod );
    }
    
    return result;
} /* CReverbFX::AllocReverbModule */




/*****************************************************************************
* CReverbFX::CreateReverbModules *
*--------------------------------*
*   Description:
*   Creates an array of reverb modules.
*       
********************************************************************** MC ***/
short CReverbFX::CreateReverbModules
                (
                 short          wModules,       // Number of modules to create.
                 LP_Reverb_Mod  *mods,
                 float *        pfltDelay,      // Array of delay values for the modules.
                 float *        pfltDB,         // Array of gain values for the modules.
                 float          fltSamplesPerMS // Number of samples per millisecond.
                 )
{
    SPDBG_FUNC( "CReverbFX::CreateReverbModules" );
    long        dwDelay, i;
    float       tempF;
    REVERBL     vol;
    short       result = KREVERB_NOERROR;
    
    
    if( wModules > 0 )
    {
        for( i = 0; i < wModules; i++ )
        {
            mods[i] = new Reverb_Mod;
            if( !mods[i] )
            {
                //---------------------------------------
                // Not enough memory
                //---------------------------------------
                result = KREVERB_MEMERROR;
                break;
            }
            else
            {
                tempF = *pfltDelay++ * fltSamplesPerMS;
                dwDelay = (long) tempF;
                if( dwDelay < 2 )
                    dwDelay = 2;                // @@@@
                vol = DecibelToPercent( *pfltDB++ );
                result = AllocReverbModule( mods[i], vol, dwDelay, dwDelay );
                if( result != KREVERB_NOERROR )
                    break;
            }
        }
    }
    
    return result;
} /* CReverbFX::CreateReverbModules */





  
/*****************************************************************************
* CReverbFX::DeleteReverbModules *
*--------------------------------*
*   Description:
*   Deletes an array of reverb modules.
*       
********************************************************************** MC ***/
void CReverbFX::DeleteReverbModules( )
{
    SPDBG_FUNC( "CReverbFX::DeleteReverbModules" );
    long    i;
    
    for( i = 0; i < KMAXREVBMODS; i++ )
    {
        if( m_Reverb_Mods[i] != NULL )
        {
            if( m_Reverb_Mods[i]->psDelayBuffer != NULL )
            {
                delete m_Reverb_Mods[i]->psDelayBuffer;
            }
            delete m_Reverb_Mods[i];
            m_Reverb_Mods[i] = NULL;
        }
    }
    
    if( m_pWorkBuf != NULL )
    {
        delete m_pWorkBuf;
        m_pWorkBuf = NULL;
    }
} /* CReverbFX::DeleteReverbModules */







/*****************************************************************************
* CReverbFX::GetReverbConfig *
*----------------------------*
*   Description:
*       
********************************************************************** MC ***/
LPREVERBCONFIG  CReverbFX::GetReverbConfig( REVERBTYPE dwReverbConfig )
{
    SPDBG_FUNC( "CReverbFX::GetReverbConfig" );
    LPREVERBCONFIG      pReverbConfig = NULL;
    
    switch( dwReverbConfig )
    {
    //-----------------------------
    // Hall
    //-----------------------------
    case REVERB_TYPE_HALL:
        {
            static float afltLeftDelay[]    = { (float)(float)(30.6),   (float)(20.83),     (float)(14.85),     (float)(10.98)  };
            static float afltLeftGain[]     = { (float)(-2.498),        (float)(-2.2533),   (float)(-2.7551),   (float)(-2.5828)    };
            
            static REVERBCONFIG reverbConfig =
            {
                (-17.0),            // Wet
                    (-2.0),             // Dry
                    4,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
        //-----------------------------
        // Stadium
        //-----------------------------
    case REVERB_TYPE_STADIUM:
        {
            static float afltLeftDelay[]    = { (float)(40.6*4),    (float)(27.65*4),   (float)(17.85*4),   (float)(10.98*4)    };
            static float afltLeftGain[]     = { (float)(-2.498),    (float)(-2.2533),   (float)(-2.7551),   (float)(-2.5828)    };
            
            static REVERBCONFIG reverbConfig =
            {
                (-3.0),             // Wet
                    (-5.0),             // Dry
                    4,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
    //-----------------------------
    // Church
    //-----------------------------
    case REVERB_TYPE_CHURCH:
        {
            static float afltLeftDelay[]    = { (float)(40.6*2),    (float)(27.65*2),   (float)(17.85*2),   (float)(10.98*2)    };
            static float afltLeftGain[]     = { (float)(-2.498),    (float)(-2.2533),   (float)(-2.7551),   (float)(-2.5828)    };
            
            static REVERBCONFIG reverbConfig =
            {
                (-5.0),             // Wet
                    (-5.0),             // Dry
                    4,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
        
    //-----------------------------
    // Bathtub
    //-----------------------------
    case REVERB_TYPE_BATHTUB:
        {
            static float afltLeftDelay[]    = { (float)(10.0)   };
            static float afltLeftGain[]     = { (float)(-0.5)   };
            
            static REVERBCONFIG reverbConfig =
            {
                (7.0),              // Wet
                    (9.0),              // Dry
                    1,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
    //-----------------------------
    // Room
    //-----------------------------
    case REVERB_TYPE_ROOM:
        {
            static float afltLeftDelay[]    = { (float)(10.6)       };
            static float afltLeftGain[]     = { (float)(-10.498)    };
            
            static REVERBCONFIG reverbConfig =
            {
                (0.0),              // Wet
                    (0.0),              // Dry
                    1,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
    //-----------------------------
    // Echo
    //-----------------------------
    case REVERB_TYPE_ECHO:
        {
            static float afltLeftDelay[]    = { (float)(400.6)  };
            static float afltLeftGain[]     = { (float)(-10.498)    };
            
            static REVERBCONFIG reverbConfig =
            {
                (-10.0),                // Wet
                    (0.0),              // Dry
                    1,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.0,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
    //-----------------------------
    // Sequencer
    //-----------------------------
    case REVERB_TYPE_ROBOSEQ:
        {
            static float afltLeftDelay[]    = { (float)(10.0)   };
            static float afltLeftGain[]     = { (float)(-0.5)   };
            
            static REVERBCONFIG reverbConfig =
            {
                (6.5),              // Wet
                    (9.0),              // Dry
                    1,
                    afltLeftDelay,
                    afltLeftGain,
                    (float)0.05,
            };
            
            pReverbConfig = &reverbConfig;
        }
        break;
        
    }
    
    return pReverbConfig;
} /* CReverbFX::GetReverbConfig */







/*****************************************************************************
* CReverbFX::Reverb_Init *
*------------------------*
*   Description:
*   Initialize a reverberator array.
*       
********************************************************************** MC ***/
short CReverbFX::Reverb_Init( REVERBTYPE reverbPreset, long nSamplesPerSec, long  stereoOut )
{
    SPDBG_FUNC( "CReverbFX::Reverb_Init" );
    short       result = KREVERB_NOERROR;
    float       fltSamplesPerMS;
    
    
    m_StereoOut = stereoOut;
    if( reverbPreset > REVERB_TYPE_OFF )
    {
        //----------------------------------------------
        // Get params from preset number
        //----------------------------------------------
        m_pReverbConfig = GetReverbConfig( reverbPreset );
        m_numOfMods     = m_pReverbConfig->numOfReflect;
        
        //----------------------------------------------
        // Convert dB's to linear gain
        //----------------------------------------------
        m_wetVolGain = DecibelToPercent( m_pReverbConfig->wetGain_dB );
        m_dryVolGain = DecibelToPercent( m_pReverbConfig->dryGain_dB );
        
        fltSamplesPerMS = (float)nSamplesPerSec / (float)1000.0;
        
        result = CreateReverbModules
            (
            (short)m_numOfMods,
            (LP_Reverb_Mod*)&m_Reverb_Mods,
            m_pReverbConfig->gain_ms_Array,
            m_pReverbConfig->gain_dB_Array,
            fltSamplesPerMS
            );
        if( result != KREVERB_NOERROR )
        {
            //--------------------------------
            // Failure! Not enough memory
            //--------------------------------
            return result;
        }
        
        if( m_pWorkBuf == NULL )
        {
            m_pWorkBuf = new REVERBT[m_dwWorkBufferSize];
            if( m_pWorkBuf == NULL )
            {
                //--------------------------------
                // Failure! Not enough memory
                //--------------------------------
                result = KREVERB_MEMERROR;
                return result;
            }
        }
    }
    else
    {
        DeleteReverbModules( );
        result = KREVERB_OFF;
    }
    return result;
} /* CReverbFX::Reverb_Init */










/*****************************************************************************
* CReverbFX::CReverbFX *
*----------------------*
*   Description:
*       
********************************************************************** MC ***/
CReverbFX::CReverbFX( void )
{
    SPDBG_FUNC( "CReverbFX::CReverbFX" );
    long            i;
    
    //--------------------------------
    // Initilize
    //--------------------------------
    m_dwWorkBufferSize  = KWORKBUFLEN;
    m_pWorkBuf          = NULL;
    m_wetVolGain        = 0;
    m_dryVolGain        = 0;
    m_numOfMods         = 0;
    m_Count             = 0;
    m_StereoOut         = false;
    for( i = 0; i < KMAXREVBMODS; i++ )
    {
        m_Reverb_Mods[i] = NULL;
    }
} /* CReverbFX::CReverbFX */




/*****************************************************************************
* CReverbFX::~CReverbFX *
*-----------------------*
*   Description:
*       
********************************************************************** MC ***/
CReverbFX::~CReverbFX( void )
{
    SPDBG_FUNC( "CReverbFX::~CReverbFX" );
    DeleteReverbModules( );
} /* CReverbFX::~CReverbFX */






//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// Run-time
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


/*****************************************************************************
* CReverbFX::CopyWithGain *
*-------------------------*
*   Description:
*   Copies audio buffer with gain
*       
********************************************************************** MC ***/
void CReverbFX::CopyWithGain 
                        (   REVERBT    *psDest,
                            REVERBT    *psSource,
                            long       dwSamples,
                            REVERBL    gain)
{   
    SPDBG_FUNC( "CReverbFX::CopyWithGain" );
    
    if( gain <= REVERB_VOL_OFF )
    {
        //----------------------------------------
        // Clear buffer, gain = 0
        //----------------------------------------
        memset( psDest, 0, sizeof(REVERBT) * dwSamples );
    }
    else if( gain == REVERB_VOL_UNITY )
    {
        //----------------------------------------
        // Copy buffer, gain = 1
        //----------------------------------------
        memcpy( psDest, psSource, sizeof(REVERBT) * dwSamples );
    }
    else
    {
        //----------------------------------------
        // Copy with gain
        //----------------------------------------
        while( dwSamples )
        {
#ifdef FLOAT_REVERB
            *psDest++ = (*psSource++) * gain;
#else
            *psDest++ = (short) (( (long)(*psSource++) * (long)gain) >> REVERB_VOL_SHIFT);
#endif
            dwSamples--;
        }
    }
} /* CReverbFX::CopyWithGain */






/*****************************************************************************
* CReverbFX::MixWithGain_MONO *
*-----------------------------*
*   Description:
*  (psDest * gain) + psSource -> psDest
*   Clipping is performed.
*       
********************************************************************** MC ***/
void CReverbFX::MixWithGain_MONO
                        (
                         REVERBT    *pWet,
                         REVERBT    *pDry,
                         short      *pDest,
                         long       dwSamples,
                         REVERBL    gain
                         )
{   
    SPDBG_FUNC( "CReverbFX::MixWithGain_MONO" );
    REVERBL     lSample;                    // long or float
    
    if( gain <= REVERB_VOL_OFF )
    {
        //----------------------------------
        // Do nothing...I guess
        //----------------------------------
    }
    else if( gain == REVERB_VOL_UNITY )
    {
        //----------------------------------
        // Don't apply any gain (= 1.0)
        //----------------------------------
        while( dwSamples )
        {
            lSample = (REVERBL)(*pWet++) + *pDry;
            //------------------------------------
            // Clip signal if overflow
            //------------------------------------
            if( lSample < -32768 )
            {
                lSample = -32768;
            }
            else if( lSample > 32767 )
            {
                lSample = 32767;
            }
            *pDest++ = (short)lSample;
            
            pDry++;
            dwSamples--;
        }
    }
    else
    {
        while( dwSamples )
        {
            //----------------------------------
            // Mix with gain on source audio
            //----------------------------------
#ifdef FLOAT_REVERB
            lSample =  ((*pDry) * gain) + *pWet++;
#else
            lSample = ((long)(*pDry * (long)(gain)) >> REVERB_VOL_SHIFT) + *pWet++;
#endif
            //------------------------------------
            // Clip signal if overflow
            //------------------------------------
            if( lSample < -32768 )
            {
                lSample = -32768;
            }
            else if( lSample > 32767 )
            {
                lSample = 32767;
            }
            *pDest++ = (short)lSample;
            
            pDry++;
            dwSamples--;
        }
    }
} /* CReverbFX::MixWithGain_MONO */






/*****************************************************************************
* CReverbFX::MixWithGain_STEREO *
*-------------------------------*
*   Description:
*       
********************************************************************** MC ***/
void CReverbFX::MixWithGain_STEREO
                            (
                             REVERBT    *pWet,
                             REVERBT    *pDry,
                             short      *pDest,
                             long       dwSamples,
                             REVERBL    gain
                             )
{   
    SPDBG_FUNC( "CReverbFX::MixWithGain_STEREO" );
    REVERBL     lSample, hold;      // long or float
    REVERBL     lSample_B;      // long or float
    
    if( gain <= REVERB_VOL_OFF )
    {
        //----------------------------------
        // Do nothing...I guess
        //----------------------------------
    }
    else if( gain == REVERB_VOL_UNITY )
    {
        //----------------------------------
        // Don't apply any gain (= 1.0)
        //----------------------------------
        while( dwSamples )
        {
            lSample = (REVERBL)(*pWet++) + (*pDry++);
            //------------------------------------
            // Clip signal if overflow
            //------------------------------------
            if( lSample < -32768 )
            {
                lSample = -32768;
            }
            else if( lSample > 32767 )
            {
                lSample = 32767;
            }
            *pDest++ = (short)lSample;
            *pDest++ = (short)(0 - (short)lSample);
            dwSamples--;
        }
    }
    else
    {
        while( dwSamples )
        {
            //----------------------------------
            // Mix with gain on source audio
            //----------------------------------
#ifdef FLOAT_REVERB
            hold = ((*pDry) * gain);
            lSample =  hold + *pWet;
            lSample_B =  hold - *pWet++;
            //lSample_B = 0 - lSample_B;
            //lSample_B = (0 - hold) - *pWet++;
#else
            lSample = ((long)(*pDry * (long)(gain)) >> REVERB_VOL_SHIFT) + *pWet;
            lSample_B = ((long)(*pDry * (long)(gain)) >> REVERB_VOL_SHIFT) - *pWet++;
#endif
            //------------------------------------
            // Clip signal if overflow
            //------------------------------------
            if( lSample < -32768 )
            {
                lSample = -32768;
            }
            else if( lSample > 32767 )
            {
                lSample = 32767;
            }
            *pDest++ = (short)lSample;
            
            if( lSample < -32768 )
            {
                lSample = -32768;
            }
            else if( lSample > 32767 )
            {
                lSample = 32767;
            }
            *pDest++ = (short)lSample_B;
            
            pDry++;
            dwSamples--;
        }
    }
} /* CReverbFX::MixWithGain_STEREO */







/*****************************************************************************
* CReverbFX::ProcessReverbModule *
*-------------------*
*   Description:
*   Process one delay buffer
*       
********************************************************************** MC ***/
void    CReverbFX::ProcessReverbModule
                     (
                     LP_Reverb_Mod  mod,
                     long           dwDestSamples,      // Number of samples to process.
                     REVERBT        *pSource,           // Source sample buffer.
                     REVERBT        *pDestination       // Destination sample buffer.
                     )
{
    SPDBG_FUNC( "CReverbFX::ProcessReverbModule" );
    REVERBT     sDelayOut;
    REVERBT     sDelayIn;
    REVERBT     *psDelayEnd;
    
    //(void) QueryPerformanceCounter (&g_StartTime );
    
    psDelayEnd = mod->psDelayBuffer + (long)((float)mod->dwDelayBufferSize * m_LenScale);
    dwDestSamples++;
    while( --dwDestSamples )
    {
        //----------------------------------------
        // Delay + current --> delay buffer
        //----------------------------------------
        sDelayOut   = *mod->psDelayOut;
#ifdef FLOAT_REVERB
        sDelayIn    = (sDelayOut * mod->lGain) + *pSource;
        //------------------------------------------------------------
        // Take this test out and you'll die in about 10 sec...
        //------------------------------------------------------------
        if( sDelayIn > 0) 
        {
            if( sDelayIn < 0.001 )
                sDelayIn = 0;
        }
        else if( sDelayIn > -0.001 )
        {
            sDelayIn = 0;
        }
#else
        sDelayIn    = ((sDelayOut * mod->lGain) >> REVERB_VOL_SHIFT) + *pSource;
#endif
        *mod->psDelayIn++ = sDelayIn;
        
        //----------------------------------------
        // Delay - (Delay + current) --> current 
        //----------------------------------------
#ifdef FLOAT_REVERB
        *pDestination = sDelayOut - (sDelayIn * mod->lGain);
#else
        *pDestination = sDelayOut - ((sDelayIn * mod->lGain) >> REVERB_VOL_SHIFT);
#endif
        
        //---------------------------------------
        // Wrap circular buffer ptrs
        //---------------------------------------
        if( mod->psDelayIn >= psDelayEnd )
        {
            mod->psDelayIn = mod->psDelayBuffer;
        }
        mod->psDelayOut++;
        if( mod->psDelayOut >= psDelayEnd )
        {
            mod->psDelayOut = mod->psDelayBuffer;
        }
        pSource++;
        pDestination++;
    }
    //(void) QueryPerformanceCounter (&g_EndTime);
    //g_LapseTime.QuadPart = (g_EndTime.QuadPart - g_StartTime.QuadPart);
} /* CReverbFX::ProcessReverbModule */




//----------------------------------------------------------------------------
// Applies an array of reverb modules to a block of samples.
//----------------------------------------------------------------------------
/*****************************************************************************
* CReverbFX::ProcessReverbBuffer *
*--------------------------------*
*   Description:
*   Applies an array of reverb modules to a block of samples.
*       
********************************************************************** MC ***/
void    CReverbFX::ProcessReverbBuffer 
                     (  REVERBT        *psSample,      // Samples to process (in/out).
                        long           dwSamples,      // Number of samples to process.
                        LP_Reverb_Mod  *mods           // Array of modules to apply.
                     )
{
    SPDBG_FUNC( "CReverbFX::ProcessReverbBuffer" );
    short   i;
    
    for (i = 0; i < KMAXREVBMODS; i++)
    {
        if( mods[i] != NULL )
        {
            ProcessReverbModule( mods[i], dwSamples, psSample, psSample );
        }
        else
            break;
    }
    
} /* CReverbFX::ProcessReverbBuffer */


/*****************************************************************************
* CReverbFX::Reverb_Process *
*---------------------------*
*   Description:
*       
********************************************************************** MC ***/
short CReverbFX::Reverb_Process( float *sampleBuffer, 
                                long dwSamplesRemaining, float audioGain )
{
    SPDBG_FUNC( "CReverbFX::Reverb_Process" );
    long    dwSamplesToProcess;
    short   *pOutBuffer;
    REVERBL totalWetGain, totalDryGain;

    if( m_numOfMods )
    {
        #ifdef FLOAT_REVERB
            totalWetGain = m_wetVolGain * audioGain;
            if (totalWetGain < REVERB_MIN_MIX)
                totalWetGain = REVERB_MIN_MIX;
            totalDryGain = m_dryVolGain * audioGain;
            if (totalDryGain < REVERB_MIN_MIX)
                totalDryGain = REVERB_MIN_MIX;
        #else
            totalWetGain = (REVERBL)(m_wetVolGain * audioGain * (float)REVERB_VOL_LEVELS);
            totalDryGain = (REVERBL)(m_dryVolGain * audioGain * (float)REVERB_VOL_LEVELS);
        #endif
        pOutBuffer = (short*)sampleBuffer;
        m_LenScale = (float)1.0 - (m_Count * m_pReverbConfig->seqIndex);
        
        while( dwSamplesRemaining > 0 )
        {
            //----------------------------------------------------------------------------
            // Process client's buffer using 'work buffer' chunks
            //----------------------------------------------------------------------------
            if( dwSamplesRemaining < m_dwWorkBufferSize )
            {
                dwSamplesToProcess = dwSamplesRemaining;
            }
            else
            {
                dwSamplesToProcess = m_dwWorkBufferSize;
            }
            
            //-----------------------------------------------------------------
            // Copy audio into WET buffer with wet gain
            //      sampleBuffer * totalWetGain --> m_pWorkBuf
            //-----------------------------------------------------------------
            CopyWithGain( m_pWorkBuf, sampleBuffer, dwSamplesToProcess, totalWetGain  );
            
            //-----------------------------------------------------------------
            // Perform reverb processing on the work buffer
            //-----------------------------------------------------------------
            ProcessReverbBuffer
                            (
                                m_pWorkBuf,
                                dwSamplesToProcess,
                                (LP_Reverb_Mod*)&m_Reverb_Mods
                            );
            
            //-----------------------------------------------------------------
            // Mix the dry with wet samples
            //     (sampleBuffer * totalDryGain) + m_pWorkBuf   --> sampleBuffer
            //-----------------------------------------------------------------
            if( m_StereoOut )
            {
                MixWithGain_STEREO( m_pWorkBuf, sampleBuffer, pOutBuffer, dwSamplesToProcess, totalDryGain );
                pOutBuffer += dwSamplesToProcess * 2;
            }
            else
            {
                MixWithGain_MONO( m_pWorkBuf, sampleBuffer, pOutBuffer, dwSamplesToProcess, totalDryGain );
                pOutBuffer += dwSamplesToProcess;
            }
            
            sampleBuffer        += dwSamplesToProcess;
            dwSamplesRemaining  -= dwSamplesToProcess;
        }
    }
    
    m_Count = (float)rand() / (float)4096;      // 0 - 32K -> 0 - 8
    
    return 0;
} /* CReverbFX::Reverb_Process */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\spttseng.cpp ===
/*******************************************************************************
* spttseng.cpp *
*--------------*
*   Description:
*       This module is the implementation file for the MS TTS DLL.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/
#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#ifndef __spttseng_h__
#include "spttseng.h"
#endif

#include "spttseng_i.c"

#ifndef TTSEngine_h
#include "TTSEngine.h"
#endif

#ifndef VoiceDataObj_h
#include "VoiceDataObj.h"
#endif

CSpUnicodeSupport g_Unicode;
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY( CLSID_MSVoiceData, CVoiceDataObj )
    OBJECT_ENTRY( CLSID_MSTTSEngine, CTTSEngine    )
END_OBJECT_MAP()

/*****************************************************************************
* DllMain *
*---------*
*   Description:
*       DLL Entry Point
********************************************************************** MC ***/
#ifdef _WIN32_WCE
extern "C"
BOOL WINAPI DllMain(HANDLE hInst, DWORD dwReason, LPVOID /*lpReserved*/)
{
    HINSTANCE hInstance = (HINSTANCE)hInst;
#else
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSTTSENGINELib);
        DisableThreadLibraryCalls(hInstance);
#ifdef _DEBUG
        // Turn on memory leak checking
        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag( tmpFlag );
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        CleanupAbbrevTables();
        _Module.Term();
    }
    return TRUE;    // ok
} /* DllMain */

/*****************************************************************************
* DllCanUnloadNow *
*-----------------*
*   Description:
*       Used to determine whether the DLL can be unloaded by OLE
********************************************************************** MC ***/
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} /* DllCanUnloadNow */

/*****************************************************************************
* DllGetClassObject *
*-------------------*
*   Description:
*       Returns a class factory to create an object of the requested type
********************************************************************** MC ***/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
} /* DllGetClassObject */

/*****************************************************************************
* DllRegisterServer *
*-------------------*
*   Description:
*       Adds entries to the system registry
********************************************************************** MC ***/
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
} /* DllRegisterServer */

/*****************************************************************************
* DllUnregisterServer *
*---------------------*
*   Description:
*        Removes entries from the system registry
********************************************************************** MC ***/
STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
} /* DllUnregisterServer */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\sentitemmemory.h ===
/******************************************************************************
* SentItemMemory.h *
*------------------*
*  This file defines and implements the CSentItemMemory class.  This class was
*  written to simplify memory management in the sentence enumerator.  The 
*  const SPVSTATE member of the SPVSENTITEM struct needs to be modified in the
*  sentence enumerator, both during normalization and during lexicon lookup.  
*  It was thus desireable to be able to free all of the memory which was 
*  dynamically created in the sentence enumerator at once, without having to,
*  for example, figure out which pronunciations were const (specified in the 
*  XML state) and which were dynamically created.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 12/6/99
*  All Rights Reserved
*
*********************************************************************** AKH ***/

struct MemoryChunk
{
    BYTE* pMemory;
    MemoryChunk* pNext;
};

class CSentItemMemory
{
public:

    CSentItemMemory( )
    {
        m_pHead = NULL;
        m_pCurr = NULL;
    }
    
    ~CSentItemMemory()
    {
        MemoryChunk *pIterator = m_pHead, *pTemp = 0;
        while (pIterator)
        {
            pTemp = pIterator->pNext;
            delete [] pIterator->pMemory;
            delete pIterator;
            pIterator = pTemp;
        }
    }

    void* GetMemory( ULONG ulBytes, HRESULT *hr )
    {
        void *Memory = 0;
        if (!m_pHead)
        {
            m_pHead = new MemoryChunk;
            if (m_pHead)
            {
                m_pHead->pNext = NULL;
                m_pHead->pMemory = new BYTE[ulBytes];
                if (m_pHead->pMemory)
                {
                    m_pCurr = m_pHead;
                    Memory = (void*) m_pHead->pMemory;
                }
                else
                {
                    *hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                *hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            m_pCurr->pNext = new MemoryChunk;
            if (m_pCurr->pNext)
            {
                m_pCurr = m_pCurr->pNext;
                m_pCurr->pNext = NULL;
                m_pCurr->pMemory = new BYTE[ulBytes];
                if (m_pCurr->pMemory)
                {
                    Memory = (void*) m_pCurr->pMemory;
                }
                else
                {
                    *hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                *hr = E_OUTOFMEMORY;
            }
        }
        return Memory;            
    }


private:

    MemoryChunk* m_pHead;
    MemoryChunk* m_pCurr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\reverbfx.h ===
/******************************************************************************
* ReverbFX.h *
*-------------*
*  This is the header file for the CReverbFX implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

#ifndef ReverbFX_H
#define ReverbFX_H

#ifndef __spttseng_h__
#include "spttseng.h"
#endif


//-------------------------------------------------------------
// Comment-out line below if you want 
//  integer math instead of floating point.
//
// NOTE:
//   Bathtub preset probably won't work
//   using integer math (overflow)
//-------------------------------------------------------------
#define FLOAT_REVERB    1

#ifdef FLOAT_REVERB
    #define REVERBT     float
    #define REVERBL     float
#else
    #define REVERBT     short
    #define REVERBL     long
#endif


#ifdef FLOAT_REVERB
    static const float REVERB_VOL_OFF     =  0.0;
    static const float REVERB_VOL_UNITY    =  1.0f;
    static const float REVERB_MIN_MIX      =  0.001f;
#else
    static const long REVERB_VOL_SHIFT    =  (16);
    static const long REVERB_VOL_LEVELS   =  65536;
    static const long REVERB_VOL_OFF      =  0;
    static const long REVERB_VOL_UNITY    =  REVERB_VOL_LEVELS;
#endif

static const float REVERB_MIN_DB       =  (-110.0);
static const long KMAXREVBMODS        =  5;

static const long KWORKBUFLEN         =  1024;



//-------------------------------------
// Reverb preset parametrs
//-------------------------------------
struct REVERBCONFIG
{
    float       wetGain_dB;             // WET gain (db)
    float       dryGain_dB;             // DRY gain (db)

    short       numOfReflect;           // Number of modules
    float       *gain_ms_Array;         // Array of delay values (ms)
    float       *gain_dB_Array;         // Array of gain values (db)
    float       seqIndex;               // "sequencer" fx
}; 
typedef struct REVERBCONFIG REVERBCONFIG, *LPREVERBCONFIG;



struct Reverb_Mod
{
    REVERBL     lGain;                  // Gain of the amplifiers.
    long        dwDelay;                // Length of the delay line.
    long        dwDelayBufferSize;      // Size of the delay buffer.
    REVERBT     *psDelayBuffer;         // Circular delay buffer, length dwDelay.
    REVERBT     *psDelayIn;             // Current input position in the delay.
    REVERBT     *psDelayOut;            // Current output position in the delay.
    REVERBT     *psDelayEnd;            // Location immediately following the buffer.
}; 
typedef struct Reverb_Mod Reverb_Mod, *LP_Reverb_Mod;


//----------------------------------
// Reverb error codes
//----------------------------------
static const long KREVERB_NOERROR     = 0;
static const long KREVERB_MEMERROR    = 1;
static const long KREVERB_OFF         = 2;


//-----------------------------------------
// ReverbFX Class
//-----------------------------------------
class CReverbFX
{
public:
    //----------------------------------
    // Initialization functions
    //----------------------------------
    CReverbFX( void );
    ~CReverbFX( void );

    short   Reverb_Init
                    (
                    REVERBTYPE reverbPreset,    // Configuration preset
                    long    nSamplesPerSec,     // SampleRate
                    long    stereoOut           // true = output is stero
                    );
private:
    REVERBL DecibelToPercent( float flDecibel );
    void    ClearReverb( LP_Reverb_Mod mod );
    short   AllocReverbModule 
                    (
                    LP_Reverb_Mod   mod,
                    REVERBL         lGain,              // Gain of the amplifiers.
                    long            dwDelay,            // Length of the delay line.
                    long            dwDelayBufferSize   // Size of the delay buffer.
                    );
    short   CreateReverbModules
                    (
                    short           wModules,           // Number of modules to create.
                    LP_Reverb_Mod   *mods,
                    float *         pfltDelay,          // Array of delay values for the modules.
                    float *         pfltDB,             // Array of gain values for the modules.
                    float           fltSamplesPerMS     // Number of samples per millisecond.
                    );
    void    DeleteReverbModules ();
    LPREVERBCONFIG  GetReverbConfig( REVERBTYPE dwReverbConfig );

    //----------------------------------
    // Run-time
    //----------------------------------
    void    CopyWithGain
                    (   
                    REVERBT     *psDest,
                    REVERBT     *psSource,
                    long        dwSamples,
                    REVERBL     gain
                    );
    void    MixWithGain_STEREO
                    (
                    REVERBT     *pWet,
                    REVERBT     *pDry,
                    short       *pDest,
                    long        dwSamples,
                    REVERBL     gain
                    );
    void    MixWithGain_MONO
                    (
                    REVERBT     *pWet,
                    REVERBT     *pDry,
                    short       *pDest,
                    long        dwSamples,
                    REVERBL     gain
                    );
    void    ProcessReverbModule
                    (
                    LP_Reverb_Mod   mod,
                    long            dwDestSamples,      // Number of samples to process.
                    REVERBT         *pSource,           // Source sample buffer.
                    REVERBT         *pDestination       // Destination sample buffer.
                    );
    void    ProcessReverbBuffer
                    (   
                    REVERBT         *psSample,      // Samples to process (in/out).
                    long            wSamples,       // Number of samples to process.
                    LP_Reverb_Mod   *mods           // Array of modules to apply.
                    );

public:
    short Reverb_Process( float *sampleBuffer, long dwSamplesRemaining, float audioGain );

private:
    //----------------------------------
    // Member Variables
    //----------------------------------
    long            m_StereoOut;
    long            m_dwWorkBufferSize;
    REVERBT         *m_pWorkBuf;
    REVERBL         m_wetVolGain;
    REVERBL         m_dryVolGain;
    long            m_numOfMods;
    LP_Reverb_Mod   m_Reverb_Mods[KMAXREVBMODS];

    LPREVERBCONFIG  m_pReverbConfig;

    float           m_Count;
    float           m_LenScale;
};
typedef CReverbFX *LP_CReverbFX;




#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\spttsengdebug.h ===
/*******************************************************************************
* SpTtsEngDebug.h *
*-----------------*
*   Description:
*       This header file contains debug output services for the TTS Engine
*-------------------------------------------------------------------------------
*  Copyright (C) 1998-2000 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
********************************************************************* AKH ******/

#ifndef spttsengdebug_h
#define spttsengdebug_h

#include "stdsentenum.h"
#include "feedchain.h"

//--- This enumeration is used to index the array of IStreams used to write stuff to the debug file
typedef enum
{
    STREAM_WAVE = 0,
    STREAM_EPOCH,
    STREAM_UNIT,
    STREAM_WAVEINFO,
    STREAM_TOBI,
    STREAM_SENTENCEBREAKS,
    STREAM_NORMALIZEDTEXT,
    STREAM_LEXLOOKUP,
    STREAM_POSPOSSIBILITIES,
    STREAM_MORPHOLOGY,
    STREAM_LASTTYPE
} STREAM_TYPE;

#ifdef _DEBUG

//--- This struct is used to log units...
#pragma pack (1)
typedef struct 
{
    char        name[8];
    long        phonID;
    long        unitID;
    long        cSamples;
	float		time;
    long        cEpochs;
    long        knots;
    long        flags;
	long		ctrlFlags;
    float       pTime[KNOTS_PER_PHON];
    float       pF0[KNOTS_PER_PHON];
    float       pAmp[KNOTS_PER_PHON];
	enum SILENCE_SOURCE		silenceSource;
} UNIT_STREAM;
#pragma pack ()

//--- This struct is just used as a helper to initialize the PRONRECORD to all zeroes
struct DebugPronRecord : PRONRECORD
{
public:
    DebugPronRecord() { ZeroMemory( (void*) this, sizeof( DebugPronRecord ) ); }
    DebugPronRecord& operator =( PRONRECORD InRecord )
    {
        memcpy( this, &InRecord, sizeof( PRONRECORD ) );
        return (*this);
    }
};

//--- This struct is used to replace the SPVCONTEXT struct for outputting to the debug streams -
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugContext
{
    WCHAR Category[32];
    WCHAR Before[32];
    WCHAR After[32];
public:
    DebugContext() { ZeroMemory( (void*) this, sizeof( DebugContext ) ); }
    DebugContext& operator =( SPVCONTEXT InContext )
    {
        if ( InContext.pCategory )
        {
            wcsncpy( Category, InContext.pCategory, 
                     wcslen(InContext.pCategory) > 31 ? 31 : wcslen(InContext.pCategory) );
        }
        if ( InContext.pBefore )
        {
            wcsncpy( Before, InContext.pBefore,
                     wcslen(InContext.pBefore) > 31 ? 31 : wcslen(InContext.pBefore) );
        }
        if ( InContext.pAfter )
        {
            wcsncpy( After, InContext.pAfter,
                     wcslen(InContext.pAfter) > 31 ? 31 : wcslen(InContext.pAfter) );
        }
        return (*this);
    }
};

//--- This struct is used to replace the SPVSTATE struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugState
{
    SPVACTIONS      eAction;
    LANGID          LangID;
    WORD            wReserved;
    long            EmphAdj;
    long            RateAdj;
    ULONG           Volume;
    SPVPITCH        PitchAdj;
    ULONG           SilenceMSecs;
    SPPHONEID       PhoneIds[64];
    ENGPARTOFSPEECH  ePartOfSpeech;
    DebugContext    Context;
public:
    DebugState() { ZeroMemory( (void*) this, sizeof( DebugState ) ); }
    DebugState& operator =( SPVSTATE InState )
    {
        eAction         = InState.eAction;
        LangID          = InState.LangID;
        wReserved       = InState.wReserved;
        EmphAdj         = InState.EmphAdj;
        RateAdj         = InState.RateAdj;
        Volume          = InState.Volume;
        PitchAdj        = InState.PitchAdj;
        SilenceMSecs    = InState.SilenceMSecs;
        ePartOfSpeech   = (ENGPARTOFSPEECH)InState.ePartOfSpeech;
        Context         = InState.Context;
        if ( InState.pPhoneIds )
        {
            wcsncpy( PhoneIds, InState.pPhoneIds,
                     wcslen(InState.pPhoneIds) > 63 ? 63 : wcslen(InState.pPhoneIds) );
        }
        return (*this);
    }
};

//--- This struct is used to replace the TTSWord struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugWord
{
    DebugState      XmlState;
    WCHAR           WordText[32];
    ULONG           ulWordLen;
    WCHAR           LemmaText[32];
    ULONG           ulLemmaLen;
    SPPHONEID       WordPron[64];
    ENGPARTOFSPEECH  eWordPartOfSpeech;
public:
    DebugWord() { ZeroMemory( (void*) this, sizeof( DebugWord ) ); }
    DebugWord& operator =( TTSWord InWord )
    {
        XmlState = *(InWord.pXmlState);
        if ( InWord.pWordText )
        {
            wcsncpy( WordText, InWord.pWordText, InWord.ulWordLen > 31 ? 31 : InWord.ulWordLen );
        }
        ulWordLen = InWord.ulWordLen;
        if ( InWord.pLemma )
        {
            wcsncpy( LemmaText, InWord.pLemma, InWord.ulLemmaLen > 31 ? 31 : InWord.ulLemmaLen );
        }
        ulLemmaLen = InWord.ulLemmaLen;
        if ( InWord.pWordPron )
        {
            wcsncpy( WordPron, InWord.pWordPron,
                wcslen( InWord.pWordPron ) > 63 ? 63 : wcslen( InWord.pWordPron ) );
        }
        eWordPartOfSpeech = InWord.eWordPartOfSpeech;
        return (*this);
    }
};

struct DebugItemInfo
{
    TTSItemType Type;
public:
    DebugItemInfo() { ZeroMemory( (void*) this, sizeof( DebugItemInfo ) ); }
    DebugItemInfo& operator =( TTSItemInfo InItemInfo )
    {
        Type = InItemInfo.Type;
        return (*this);
    }
};

//--- This struct is used to replace the TTSSentItem struct for outputting to the debug streams - 
//---   cannot have any pointers in a struct which we will output as binary data...
struct DebugSentItem
{
    WCHAR           ItemSrcText[32];
    ULONG           ulItemSrcLen;
    ULONG           ulItemSrcOffset;
    DebugWord       Words[32];
    ULONG           ulNumWords;
    ENGPARTOFSPEECH  eItemPartOfSpeech;
    DebugItemInfo   ItemInfo;
public:
    DebugSentItem() { ZeroMemory( (void*) this, sizeof( DebugSentItem ) ); }
    DebugSentItem& operator =( TTSSentItem InItem )
    {
        if ( InItem.pItemSrcText )
        {
            wcsncpy( ItemSrcText, InItem.pItemSrcText, InItem.ulItemSrcLen > 31 ? 31 : InItem.ulItemSrcLen );
        }
        ulItemSrcLen        = InItem.ulItemSrcLen;
        ulItemSrcOffset     = InItem.ulItemSrcOffset;
        for ( ULONG i = 0; i < InItem.ulNumWords && i < 32; i++ )
        {
            Words[i] = InItem.Words[i];
        }
        ulNumWords          = InItem.ulNumWords;
        eItemPartOfSpeech   = InItem.eItemPartOfSpeech;
        if ( InItem.pItemInfo )
        {
            ItemInfo            = *(InItem.pItemInfo);
        }
        return (*this);
    }
};

//--- This enumeration should correspond to the previous one, and is used to name the array of IStreams
//---   used to write stuff to the debug file
static const SPLSTR StreamTypeStrings[] =
{
    DEF_SPLSTR( "Wave"           ),
    DEF_SPLSTR( "Epoch"          ),
    DEF_SPLSTR( "Unit"           ),
    DEF_SPLSTR( "WaveInfo"       ),
    DEF_SPLSTR( "ToBI"           ),
    DEF_SPLSTR( "SentenceBreaks" ),
    DEF_SPLSTR( "NormalizedText" ),
    DEF_SPLSTR( "LexLookup"      ),
    DEF_SPLSTR( "PosPossibilities" ),
    DEF_SPLSTR( "Morphology" ),
};

//--- This const is just the storage mode with which the debug file and its associated streams are opened
static const DWORD STORAGE_MODE = ( STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE );


#define TEXT_LEN_MAX	20
//--- This struct is used to keep track of pitch information for outputting to the debug streams
struct PITCH_TARGET
{
    float   time;
    float   level;
    enum TOBI_ACCENT accent;

	//--- Diagnostic
	enum ACCENT_SOURCE		accentSource;		
	enum BOUNDARY_SOURCE	boundarySource;
	char					textStr[TEXT_LEN_MAX];
};

//--- This class implements most of the functionality required for TTS Debugging Support
class CTTSDebug
{
public:

    //=== Interface Functions ===//

    //--- Constructor - just sets all member variables to NULL
    CTTSDebug() 
    {
        m_pDebugFile = NULL;
        for ( int i = 0; i < STREAM_LASTTYPE; i++ )
        {
            m_pDebugStreams[i] = NULL;
        }
        m_fInitialized = false;
    }

    //--- Destructor - just closes the file
    ~CTTSDebug()
    {
        CloseDebugFile();
    }

    //--- OpenDebugFile - opens a file (path is obtained from the Key DebugFile in the voices registry
    //---   entry) and associated streams...
    void OpenDebugFile( WCHAR *pFileName )
    {
        HRESULT hr = S_OK;
        hr = StgCreateDocfile( pFileName, STORAGE_MODE, 0, &m_pDebugFile );
        if ( SUCCEEDED( hr ) )
        {
            for ( int i = 0; SUCCEEDED( hr ) && i < STREAM_LASTTYPE; i++ )
            {
                hr = m_pDebugFile->CreateStream( StreamTypeStrings[i].pStr, STORAGE_MODE, 0, 0, &m_pDebugStreams[i] );
            }
        }
        if ( FAILED( hr ) )
        {
            CloseDebugFile();
        }
        else
        {
            m_fInitialized = true;
        }
    }

    //--- CloseDebugFile - just closes the file and streams opened by OpenDebugFile
    void    CloseDebugFile( void )
    {
        if ( m_pDebugFile )
        {
            for ( int i = 0; i < STREAM_LASTTYPE; i++ )
            {
                if ( m_pDebugStreams[i] )
                {
                    m_pDebugStreams[i]->Release();
                    m_pDebugStreams[i] = NULL;
                }
            }
            m_pDebugFile->Release();
            m_pDebugFile = NULL;
            m_fInitialized = false;
        }
    }

    //--- AppendToStream - writes data to the Stream specified by Type
    void    AppendToStream( STREAM_TYPE Type, void *pData, ULONG cBytes )
    {
        HRESULT hr = S_OK;
        hr = m_pDebugStreams[Type]->Write( pData, cBytes, NULL );
    }




    //--- AddPitchToList - keeps track of pitch targets which will later be output to a debug stream
    void    AddPitchToList( float time, 
							float level, 
							TOBI_ACCENT accent,
							ACCENT_SOURCE		accentSource,
							BOUNDARY_SOURCE	boundarySource,
							char *pTextStr)
    {
        PITCH_TARGET        *pNewPitch, *pNextPitch;
        SPLISTPOS           curPosition, nextPosition;

        pNewPitch = new PITCH_TARGET;
        if( pNewPitch )
        {
            pNewPitch->time = time;
            pNewPitch->level = level;
            pNewPitch->accent = accent;
			if( pTextStr )
			{
				strcpy( pNewPitch->textStr, pTextStr );
			}
			else
			{
				// No string
				pNewPitch->textStr[0] = 0;
			}
			pNewPitch->accentSource = accentSource;
			pNewPitch->boundarySource = boundarySource;

           if( PitchTargetList.IsEmpty() )
            {
                PitchTargetList.AddHead( pNewPitch );
            }
            else
            {
                nextPosition = PitchTargetList.GetHeadPosition();
                while( nextPosition )
                {
                    curPosition = nextPosition;
                    pNextPitch = (PITCH_TARGET*)PitchTargetList.GetNext( nextPosition );
                    if( time < pNextPitch->time )
                    {
                        PitchTargetList.InsertBefore( curPosition, pNewPitch );
                        break;
                    }
                    if( nextPosition == NULL )
                    {
                        PitchTargetList.AddTail( pNewPitch );
                        break;
                    }
                }
            }
        }
    }

    //--- DeletePitchList - Cleans up pitch target list after it has been output to a debug stream
    void DeletePitchList()
    {
        PITCH_TARGET *pTarget;
        while ( !PitchTargetList.IsEmpty() )
        {
            pTarget = (PITCH_TARGET*)PitchTargetList.RemoveHead();
            delete pTarget;
        }
    }

    //--- IsInitialized - Just returns true or false based on whether OpenDebugFile has been called
    //---   and has succeeded...
    bool    IsInitialized() { return m_fInitialized; }

    //=== Member Variables ===//

private:
    IStorage    *m_pDebugFile;
    IStream     *m_pDebugStreams[STREAM_LASTTYPE];
    bool        m_fInitialized;
public:
    CSPList<PITCH_TARGET*,PITCH_TARGET*> PitchTargetList;
};

inline CTTSDebug *pTTSDebug()
{
    static CTTSDebug debug;
    return &debug;
}


#define TTSDBG_OPENFILE                                                                     \
    do                                                                                      \
    {                                                                                       \
        CSpDynamicString dstrTemp;                                                          \
        CComPtr<ISpObjectToken> cpVoiceToken;                                               \
        cpVoiceToken = ((CVoiceDataObj*)m_pVoiceDataObj)->GetVoiceToken();                  \
        if ( SUCCEEDED( cpVoiceToken->GetStringValue( L"DebugFile", &dstrTemp) ) )          \
        {                                                                                   \
            pTTSDebug()->OpenDebugFile( dstrTemp );                                         \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_CLOSEFILE                                                                    \
    pTTSDebug()->CloseDebugFile()

#define TTSDBG_LOGITEMLIST( ItemList, Stream )                                              \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            SPLISTPOS ListPos = ItemList.GetHeadPosition();                                 \
            DebugSentItem Item;                                                             \
            pTTSDebug()->AppendToStream( Stream, (void*) &Item, sizeof( Item ) );           \
            while ( ListPos )                                                               \
            {                                                                               \
                ZeroMemory( &Item, sizeof( Item ) );                                        \
                Item = ItemList.GetNext( ListPos );                                         \
                pTTSDebug()->AppendToStream( Stream, (void*) &Item, sizeof( Item ) );       \
            }                                                                               \
            pItemEnum->Reset();                                                             \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_LOGPOSPOSSIBILITIES( pProns, ulNumWords, Stream )                            \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            ULONG ulIndex = 0;                                                              \
            DebugPronRecord dbgRecord;                                                      \
            pTTSDebug()->AppendToStream( Stream, (void*) &dbgRecord,                        \
                                         sizeof( DebugPronRecord ) );                       \
            while ( ulIndex < ulNumWords )                                                  \
            {                                                                               \
                dbgRecord = pProns[ulIndex];                                                \
                pTTSDebug()->AppendToStream( Stream, (void*) &dbgRecord,                    \
                                             sizeof( DebugPronRecord ) );                   \
                ulIndex++;                                                                  \
            }                                                                               \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_LOGMORPHOLOGY( pwRoot, SuffixList, Stream )                                  \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            pTTSDebug()->AppendToStream( Stream, (void*) pwRoot,                            \
                                         SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );            \
            SPLISTPOS ListPos = SuffixList.GetHeadPosition();                               \
            SUFFIXPRON_INFO* pSuffixPron;                                                   \
            while ( ListPos )                                                               \
            {                                                                               \
                pSuffixPron = SuffixList.GetNext( ListPos );                                \
                pTTSDebug()->AppendToStream( Stream, (void*) pSuffixPron->SuffixString,     \
                                             SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );        \
            }                                                                               \
            WCHAR Delimiter[SP_MAX_WORD_LENGTH];                                            \
            ZeroMemory( Delimiter, SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );                  \
            pTTSDebug()->AppendToStream( Stream, (void*) Delimiter,                         \
                                         SP_MAX_WORD_LENGTH * sizeof( WCHAR ) );            \
        }                                                                                   \
    }                                                                                       \
    while (0)
                                             

#define TTSDBG_LOGWAVE                                                                      \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            if ( m_SpeechState == SPEECH_CONTINUE )                                         \
            {                                                                               \
                pTTSDebug()->AppendToStream( STREAM_WAVE, (void*)m_pSpeechBuf,              \
                                             m_cOutSamples_Frame * m_BytesPerSample );      \
            }                                                                               \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_ADDPITCHTARGET( time, level, accent)                                         \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            pTTSDebug()->AddPitchToList( time, level, accent, m_CurAccentSource, m_CurBoundarySource, m_pCurTextStr );                              \
        }                                                                                   \
    }                                                                                       \
    while (0)

#define TTSDBG_LOGTOBI                                                                      \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            SPLISTPOS       curPosition;                                                    \
            PITCH_TARGET    *pPitch;                                                        \
            curPosition = pTTSDebug()->PitchTargetList.GetHeadPosition();                   \
            while( curPosition )                                                            \
            {                                                                               \
                pPitch = (PITCH_TARGET*)pTTSDebug()->PitchTargetList.GetNext(curPosition);  \
                pTTSDebug()->AppendToStream( STREAM_TOBI, (void*)pPitch,                    \
                                             sizeof(PITCH_TARGET) );                        \
            }                                                                               \
            pTTSDebug()->DeletePitchList();                                                 \
        }                                                                                   \
    }                                                                                       \
    while (0)





#define TTSDBG_LOGSILEPOCH																		\
    do																							\
    {             																				\
        float	fEpoch;																			\
																								\
        if( pTTSDebug()->IsInitialized() )														\
        {																						\
			if( m_silMode )																		\
			{																					\
				fEpoch = (float)m_durationTarget;												\
				pTTSDebug()->AppendToStream( STREAM_EPOCH, (void*)&fEpoch, sizeof(float) );		\
			}                                                                                   \
		}																						\
    }																							\
    while (0)





#define TTSDBG_LOGEPOCHS																		\
    do																							\
    {             																				\
        if( pTTSDebug()->IsInitialized() )														\
        {																						\
			float	fEpoch;																		\
																								\
			if( OutSize > 1 )																	\
			{																					\
				fEpoch = (float)OutSize;														\
				pTTSDebug()->AppendToStream( STREAM_EPOCH, (void*)&fEpoch, sizeof(float) );		\
			}																					\
		}																						\
    }																							\
    while (0)



#define TTSDBG_LOGUNITS                                                                     \
    do                                                                                      \
    {                                                                                       \
        if ( pTTSDebug()->IsInitialized() )                                                 \
        {                                                                                   \
            UNIT_STREAM         us;                                                         \
                                                                                            \
            us.phonID   = pCurUnit->PhonID;                                                 \
            us.unitID   = pCurUnit->UnitID;                                                 \
            us.flags    = pCurUnit->flags;                                                  \
			us.ctrlFlags	= pCurUnit->ctrlFlags;                                          \
            us.cEpochs  = 1;                                                                \
            us.cSamples = m_durationTarget;                                                 \
            us.time     = (float)m_cOutSamples_Total / m_SampleRate;                        \
            us.knots    = KNOTS_PER_PHON;                                                   \
            for( i = 0; i < KNOTS_PER_PHON; i++ )                                           \
            {                                                                               \
                us.pTime[i] = pCurUnit->pTime[i];                                           \
                us.pF0[i]   = pCurUnit->pF0[i];                                             \
                us.pAmp[i]  = pCurUnit->pAmp[i];                                            \
            }                                                                               \
            strcpy( us.name, pCurUnit->szUnitName );										\
			us.silenceSource = pCurUnit->silenceSource;                                     \
            pTTSDebug()->AppendToStream( STREAM_UNIT, (void*)&us, sizeof(UNIT_STREAM) );    \
        }                                                                                   \
    }                                                                                       \
    while (0)

#else // _DEBUG

#define TTSDBG_OPENFILE
#define TTSDBG_CLOSEFILE
#define TTSDBG_LOGITEMLIST(ItemList, Stream)
#define TTSDBG_LOGWAVE
#define TTSDBG_ADDPITCHTARGET(time, level, accent)
#define TTSDBG_LOGTOBI
#define TTSDBG_LOGEPOCHS
#define TTSDBG_LOGSILEPOCH
#define TTSDBG_LOGUNITS
#define TTSDBG_LOGPOSPOSSIBILITIES( pProns, ulNumWords, Stream )
#define TTSDBG_LOGMORPHOLOGY( pwRoot, SuffixList, Stream )

#endif // _DEBUG
#endif // spttsengdebug_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3F7C4D2C_D007_11D2_B503_00C04F797396__INCLUDED_)
#define AFX_STDAFX_H__3F7C4D2C_D007_11D2_B503_00C04F797396__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <math.h>
#include <tchar.h>

#include <SPDDKHlp.h>
#include <SPCollec.h>
#include <spunicode.h>
//
//  String handling and conversion classes
//
/*** SPLSTR
*   This structure is for managing strings with known lengths
*/
struct SPLSTR
{
    WCHAR*  pStr;
    int     Len;
};
#define DEF_SPLSTR( s ) { L##s , sp_countof( s ) - 1 }

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3F7C4D2C_D007_11D2_B503_00C04F797396__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\timenorm.cpp ===
/***********************************************************************************************
* TimeNorm.cpp *
*-------------*
*  Description:
*   These functions normalize times of day and time measurements.
*-----------------------------------------------------------------------------------------------
*  Created by AH                                                                August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

#pragma warning (disable : 4296)

/***********************************************************************************************
* IsTimeOfDay *
*-------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a time of day.
* 
*   RegExp:
*       [01-09,1-12][:][00-09,10-59][TimeAbbreviation]?
*
*   Types assigned:
*       TIMEOFDAY
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsTimeOfDay( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager,
                                   CWordList& WordList, BOOL fMultiItem )
{
    SPDBG_FUNC( "CStdSentEnum::IsTimeOfDay" );

    HRESULT hr = S_OK;
    const WCHAR *pStartChar = m_pNextChar, *pEndOfItem = m_pEndOfCurrItem, *pEndChar = m_pEndChar;
    const SPVTEXTFRAG* pFrag = m_pCurrFrag;
    const SPVSTATE *pTimeXMLState = &pFrag->State, *pAbbreviationXMLState = NULL;
    CItemList PreAbbreviationList;
    BOOL fAdvancePointers = false;
    WCHAR *pHours = NULL, *pMinutes = NULL, *pAbbreviation = NULL;
    ULONG ulHours = 0, ulMinutes = 0;
    TIMEABBREVIATION TimeAbbreviation = UNDEFINED;
    TTSItemType ItemType = eUNMATCHED;

    //--- Max length of a string matching this regexp is 9 character 
    if ( pEndOfItem - pStartChar > 9 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        pHours = (WCHAR*) pStartChar;
        
        //--- Try to match a number for the hour of day - [01-09,1-12] 
        ulHours = my_wcstoul( pHours, &pMinutes );
        if ( pHours != pMinutes && 
             pMinutes - pHours <= 2 )
        {
            //--- Try to match the colon - [:] 
            if ( *pMinutes == ':' )
            {
                pMinutes++;
                //--- Try to match a number for the minutes - [00-09,10-59] 
                ulMinutes = my_wcstoul( pMinutes, &pAbbreviation );
                if ( pMinutes != pAbbreviation &&
                     pAbbreviation - pMinutes == 2 )
                {
                    //--- Verify that this is the end of the string 
                    if ( pAbbreviation == pEndOfItem )
                    {
                        //--- May have gotten hours and minutes - validate values 
                        if ( HOURMIN   <= ulHours   && ulHours   <= HOURMAX     &&
                             MINUTEMIN <= ulMinutes && ulMinutes <= MINUTEMAX )
                        {
                            //--- A successful match has been made, but peek ahead in text for Time Abbreviation
                            if ( fMultiItem )
                            {
                                pStartChar = pEndOfItem;
                                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, 
                                                            true, &PreAbbreviationList );
                                if ( pStartChar &&
                                     SUCCEEDED( hr ) )
                                {
								    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );

                                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                                            ( ( ItemType = IsEOSItem( *(pEndOfItem - 1) ) ) != eUNMATCHED &&
                                              ( ItemType != ePERIOD ||
                                                ( _wcsnicmp( pStartChar, L"am.", 3 ) == 0 &&
                                                  pStartChar + 3 == pEndOfItem ) ||
                                                ( _wcsnicmp( pStartChar, L"pm.", 3 ) == 0 &&
                                                  pStartChar + 3 == pEndOfItem ) ) ) )
                                    {
                                        pEndOfItem--;
                                    }
                                    pAbbreviation = (WCHAR*) pStartChar;

                                    if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                                           pAbbreviation + 2 == pEndOfItem )           ||
                                         ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                                           pAbbreviation + 4 == pEndOfItem ) )
                                    {
                                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                                        TimeAbbreviation        = AM;
                                        pAbbreviationXMLState   = &pFrag->State;
                                        fAdvancePointers        = true;
                                    }
                                    else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                                                pAbbreviation + 2 == pEndOfItem )           ||
                                              ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                                                pAbbreviation + 4 == pEndOfItem ) )
                                    {
                                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                                        TimeAbbreviation        = PM;
                                        pAbbreviationXMLState   = &pFrag->State;
                                        fAdvancePointers        = true;
                                    }
                                }
                            }
                        }
                        else // hours or minutes were out of range
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    //--- Check to see if the rest of the string is a time abbreviation - [TimeAbbreviation] 
                    else if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                                pAbbreviation + 2 == pEndOfItem ) ||
                              ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                                pAbbreviation + 4 == pEndOfItem ) )
						{
							//--- May have gotten hours and minutes and time abbreviation - validate values 
							if ( HOURMIN   <= ulHours   && ulHours   <= HOURMAX     &&
								MINUTEMIN <= ulMinutes && ulMinutes <= MINUTEMAX )
							{
								//--- A successful match has been made 
								TimeAbbreviation        = AM;
								pAbbreviationXMLState   = &pFrag->State;
							}
							else // hours or minutes were out of range
							{
								hr = E_INVALIDARG;
							}
						}
					//--- Check to see if the rest of the string is a time abbreviation - [TimeAbbreviation] 
					else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                                pAbbreviation + 2 == pEndOfItem ) ||
                              ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                                pAbbreviation + 4 == pEndOfItem ) )
					{
						//--- May have gotten hours and minutes and time abbreviation - validate values 
						if ( HOURMIN   <= ulHours   && ulHours   <= HOURMAX     &&
							MINUTEMIN <= ulMinutes && ulMinutes <= MINUTEMAX )
						{
							//--- A successful match has been made 
							pAbbreviationXMLState   = &pFrag->State;
							TimeAbbreviation        = PM;
						}
						else // hours or minutes were out of range
						{
							hr = E_INVALIDARG;
						}
					}
					else // string ended in invalid characters
					{
						hr = E_INVALIDARG;
					}
				} // failed to match a valid minutes string
                else
                {
                    hr = E_INVALIDARG;
                }
            } // failed to match the colon, could be just hours and a time abbreviation
            else if ( pMinutes < m_pEndOfCurrItem )
            {
                pAbbreviation = pMinutes;
                pMinutes      = NULL;                
                				
				
                //--- Check for TimeAbbreviation - [TimeAbbreviation] 
                if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                       pAbbreviation + 2 == pEndOfItem ) ||
                     ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                       pAbbreviation + 4 == pEndOfItem ) )
                {
                    //--- A successful match has been made - Hour AM 
                    pAbbreviationXMLState   = &pFrag->State;
                    TimeAbbreviation        = AM;
                }
                else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                            pAbbreviation + 2 == pEndOfItem ) ||
                          ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                            pAbbreviation + 4 == pEndOfItem ) )
                {
                    //--- A successful match has been made - Hour PM 
                    pAbbreviationXMLState   = &pFrag->State;
                    TimeAbbreviation        = PM;
                }
                else // failed to match a valid time abbreviation
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( fMultiItem )
            {
                //--- Set pMinutes to NULL, so we know later that we've got no minutes string...
                pMinutes      = NULL;                

                //--- Peek ahead in text for a time abbreviation
                pStartChar = pEndOfItem;
                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, 
                                            true, &PreAbbreviationList );
                if ( !pStartChar &&
                     SUCCEEDED( hr ) )
                {
                    hr = E_INVALIDARG;
                }
                else if ( pStartChar &&
                          SUCCEEDED( hr ) )
                {
                    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );

                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                            ( ( ItemType = IsEOSItem( *(pEndOfItem - 1) ) ) != eUNMATCHED &&
                              ItemType != ePERIOD ) )
                    {
                        pEndOfItem--;
                    }
                    pAbbreviation = (WCHAR*) pStartChar;

                    if ( ( _wcsnicmp( pAbbreviation, L"am", 2 )   == 0 &&
                           pAbbreviation + 2 == pEndOfItem )           ||
                         ( _wcsnicmp( pAbbreviation, L"a.m.", 4 ) == 0 &&
                           pAbbreviation + 4 == pEndOfItem ) )
                    {
                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                        TimeAbbreviation        = AM;
                        pAbbreviationXMLState   = &pFrag->State;
                        fAdvancePointers        = true;
                    }
                    else if ( ( _wcsnicmp( pAbbreviation, L"pm", 2 )   == 0 &&
                                pAbbreviation + 2 == pEndOfItem )           ||
                              ( _wcsnicmp( pAbbreviation, L"p.m.", 4 ) == 0 &&
                                pAbbreviation + 4 == pEndOfItem ) )
                    {
                        //--- Found a valid Time Abbreviation - [Hours:Minutes] [whitespace] [Abbrev]
                        TimeAbbreviation        = PM;
                        pAbbreviationXMLState   = &pFrag->State;
                        fAdvancePointers        = true;
                    }
                    //--- Failed to match a valid Time Abbreviation
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        } // failed to match a valid hours string
        else
        {
            hr = E_INVALIDARG;
        }

        //--- Successfully matched a Time Of Day!  Now expand it and fill out pItemNormInfo
        if ( SUCCEEDED( hr ) )
        {
            NumberGroup Garbage;
            TTSWord Word;
            ZeroMemory( &Word, sizeof(TTSWord) );
            Word.eWordPartOfSpeech = MS_Unknown;

            pItemNormInfo = (TTSTimeOfDayItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeOfDayItemInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                //--- Fill out known parts of pItemNormInfo
                ZeroMemory( pItemNormInfo, sizeof(TTSTimeOfDayItemInfo) );
                pItemNormInfo->Type                                          = eTIMEOFDAY;
                ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fMinutes          = pMinutes ? true : false;
                ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fTimeAbbreviation = TimeAbbreviation != UNDEFINED ? true : false;
                ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fTwentyFourHour   = false;
                
                //--- Expand the hours
                if ( !iswdigit( pHours[1] ) )
                {
                    ExpandDigit( pHours[0], Garbage, WordList );
                }
                else
                {
                    ExpandTwoDigits( pHours, Garbage, WordList );
                }

                //--- Expand the minutes
                if ( pMinutes )
                {
                    //--- Special case: A bare o'clock - 1:00, 2:00, etc. 
                    if ( wcsncmp( pMinutes, L"00", 2 ) == 0 )
                    {
                        WCHAR *pGarbage;
                        ULONG ulHours = my_wcstoul( pHours, &pGarbage );
                        //--- Under twelve is followed by "o'clock" 
                        if ( ulHours <= 12 )
                        {
                            Word.pWordText  = g_OClock.pStr;
                            Word.ulWordLen  = g_OClock.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                        //--- Over twelve is followed by "hundred hours" 
                        else
                        {
                            ( (TTSTimeOfDayItemInfo*) pItemNormInfo )->fTwentyFourHour = true;

                            Word.pWordText  = g_hundred.pStr;
                            Word.ulWordLen  = g_hundred.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );

                            Word.pWordText  = g_hours.pStr;
                            Word.ulWordLen  = g_hours.Len;
                            Word.pLemma     = Word.pWordText;
                            Word.ulLemmaLen = Word.ulWordLen;
                            WordList.AddTail( Word );
                        }
                    }
                    //--- Special Case: Minutes less than 10 - 1:05, 2:06, etc. 
                    else if ( pMinutes[0] == L'0' )
                    {
                        Word.pWordText  = g_O.pStr;
                        Word.ulWordLen  = g_O.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );

                        ExpandDigit( pMinutes[1], Garbage, WordList );
                    }
                    //--- Default Case 
                    else 
                    {
                        ExpandTwoDigits( pMinutes, Garbage, WordList );
                    }
                }

                //--- Clean up Time XML State
                SPLISTPOS WordListPos = WordList.GetHeadPosition();
                while ( WordListPos )
                {
                    TTSWord& TempWord  = WordList.GetNext( WordListPos );
                    TempWord.pXmlState = pTimeXMLState;
                }

                //--- Insert Pre-Abbreviation XML States
                while ( !PreAbbreviationList.IsEmpty() )
                {
                    WordList.AddTail( ( PreAbbreviationList.RemoveHead() ).Words[0] );
                }

                //--- Expand the Time Abbreviation
                //--- AM 
                if ( TimeAbbreviation == AM )
                {
                    //--- Ensure the letters are pronounced as nouns...
                    SPVSTATE* pNewState = (SPVSTATE*) MemoryManager.GetMemory( sizeof( SPVSTATE ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        memcpy( pNewState, pAbbreviationXMLState, sizeof( SPVSTATE ) );
                        pNewState->ePartOfSpeech = SPPS_Noun;

                        Word.pXmlState  = pNewState;
                        Word.pWordText  = g_A.pStr;
                        Word.ulWordLen  = g_A.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );

                        Word.pWordText  = g_M.pStr;
                        Word.ulWordLen  = g_M.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );
                    }
                }
                //--- PM 
                else if ( TimeAbbreviation == PM )
                {
                    //--- Ensure the letters are pronounced as nouns...
                    SPVSTATE* pNewState = (SPVSTATE*) MemoryManager.GetMemory( sizeof( SPVSTATE ), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        memcpy( pNewState, pAbbreviationXMLState, sizeof( SPVSTATE ) );
                        pNewState->ePartOfSpeech = SPPS_Noun;

                        Word.pXmlState  = pAbbreviationXMLState;
                        Word.pWordText  = g_P.pStr;
                        Word.ulWordLen  = g_P.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );

                        Word.pWordText  = g_M.pStr;
                        Word.ulWordLen  = g_M.Len;
                        Word.pLemma     = Word.pWordText;
                        Word.ulLemmaLen = Word.ulWordLen;
                        WordList.AddTail( Word );
                    }
                }

                //--- Update pointers, if necessary
                if ( fAdvancePointers )
                {
                    m_pCurrFrag      = pFrag;
                    m_pEndChar       = pEndChar;
                    m_pEndOfCurrItem = pEndOfItem;
                }
            }
        }
    }
    return hr;
} /* IsTimeOfDay */

/***********************************************************************************************
* IsTime *
*--------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a time.
* 
*   RegExp:
*       { d+ || d(1-3)[,ddd]+ }[:][00-09,10-59]{ [:][00-09,10-59] }?
*
*   Types assigned:
*       TIME_HRMIN, TIME_MINSEC, TIME_HRMINSEC
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsTime( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "TimeNorm IsTime" );

    HRESULT hr = S_OK;
    WCHAR *pFirstChunk = NULL, *pSecondChunk = NULL, *pThirdChunk = NULL, *pLeftOver = NULL;
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndOfItem = m_pEndOfCurrItem;
    ULONG ulSecond = 0, ulThird = 0;
    TTSItemInfo *pFirstChunkInfo = NULL;
    BOOL fNegative = false;

    pFirstChunk = (WCHAR*) m_pNextChar;
    
    //--- Try to match a number for the hours/minutes - { d+ } 
    if ( *pFirstChunk == L'-' )
    {
        pFirstChunk++;
        fNegative = true;
    }
    while ( *pFirstChunk == L'0' )
    {
        pFirstChunk++;
    }
    if ( *pFirstChunk == L':' )
    {
        pFirstChunk--;
    }
    pSecondChunk = wcschr( pFirstChunk, L':' );

    if ( pSecondChunk &&
         pFirstChunk  < pSecondChunk &&
         pSecondChunk < m_pEndOfCurrItem - 1 )
    {
        m_pNextChar      = pFirstChunk;
        m_pEndOfCurrItem = pSecondChunk;

        hr = IsNumberCategory( pFirstChunkInfo, L"NUMBER", MemoryManager );

        m_pNextChar      = pTempNextChar;
        m_pEndOfCurrItem = pTempEndOfItem;

        if ( SUCCEEDED( hr ) &&
             ( pFirstChunkInfo->Type == eNUM_DECIMAL ||
               pFirstChunkInfo->Type == eNUM_CARDINAL ) )
        {
            if ( fNegative )
            {
                ( (TTSNumberItemInfo*) pFirstChunkInfo )->fNegative = true;
                TTSWord Word;
                ZeroMemory( &Word, sizeof( TTSWord ) );
                Word.eWordPartOfSpeech  = MS_Unknown;
                Word.pXmlState          = &m_pCurrFrag->State;
                Word.pWordText          = g_negative.pStr;
                Word.ulWordLen          = g_negative.Len;
                Word.pLemma             = Word.pWordText;
                Word.ulLemmaLen         = Word.ulWordLen;
                ( (TTSNumberItemInfo*) pFirstChunkInfo )->pWordList->AddHead( Word );
            }

            pSecondChunk++;
            //--- Try to match a number for the minutes/seconds - [00-09,10-59] 
            ulSecond = my_wcstoul( pSecondChunk, &pThirdChunk );
            if ( pSecondChunk != pThirdChunk &&
                 pThirdChunk - pSecondChunk == 2 )
            {
                //--- Verify that this is the end of the string 
                if ( pThirdChunk == m_pEndOfCurrItem )
                {
                    //--- May have gotten hours and minutes or minutes and seconds - validate values 
                    if ( MINUTEMIN <= ulSecond && ulSecond <= MINUTEMAX )
                    {
                        //--- A successful match has been made 
                        //--- Default behavior here is to assume minutes and seconds 
                        if ( Context == NULL ||
                             _wcsicmp( Context, L"TIME_MS" ) == 0 )
                        {
                            //--- Successfully matched minutes and seconds.
                            pItemNormInfo = (TTSTimeItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeItemInfo),
                                                                                        &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( pItemNormInfo, sizeof(TTSTimeItemInfo) );
                                pItemNormInfo->Type = eTIME;

                                ( (TTSTimeItemInfo*) pItemNormInfo )->pMinutes = 
                                                                        (TTSNumberItemInfo*) pFirstChunkInfo;
                                if ( *pSecondChunk != L'0' )
                                {
                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pSecondChunk;
                                }
                                else
                                {
                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pSecondChunk + 1;
                                }
                            }
                        }
                        //--- If context overrides, values represent hours and minutes 
                        else if ( _wcsicmp( Context, L"TIME_HM" ) == 0 )
                        {
                            //--- Successfully matched hours and pMinutes->
                            pItemNormInfo = (TTSTimeItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeItemInfo),
                                                                                        &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( pItemNormInfo, sizeof(TTSTimeItemInfo) );
                                pItemNormInfo->Type = eTIME;
                                ( (TTSTimeItemInfo*) pItemNormInfo )->pHours = 
                                                                    (TTSNumberItemInfo*) pFirstChunkInfo;

                                TTSItemInfo* pMinutesInfo;

                                //--- Don't want "zero zero..." behavior of numbers - strip off beginning zeroes
                                if ( *pSecondChunk == L'0' )
                                {
                                    pSecondChunk++;
                                }

                                m_pNextChar      = pSecondChunk;
                                m_pEndOfCurrItem = pThirdChunk;

                                hr = IsNumber( pMinutesInfo, L"NUMBER", MemoryManager );

                                m_pNextChar      = pTempNextChar;
                                m_pEndOfCurrItem = pTempEndOfItem;

                                if ( SUCCEEDED( hr ) )
                                {
                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pMinutes = (TTSNumberItemInfo*) pMinutesInfo;
                                }
                            }
                        }
                        else
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    else // minutes or seconds were out of range
                    {
                        hr = E_INVALIDARG;
                    }
                }
                //--- Check for seconds - TIME_HRMINS 
                else
                {
                    //--- Try to match the colon 
                    if ( *pThirdChunk == L':' )
                    {
                        pThirdChunk++;
                        //--- Try to match a number for the seconds - [00-09,10-59] 
                        ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                        if ( pThirdChunk != pLeftOver &&
                             pLeftOver - pThirdChunk == 2 )
                        {
                            //--- Verify that this is the end of the string 
                            if ( pLeftOver == m_pEndOfCurrItem )
                            {
                                //--- May have gotten hours minutes and seconds - validate values 
                                if ( MINUTEMIN <= ulSecond && ulSecond <= MINUTEMAX &&
                                     SECONDMIN <= ulThird  && ulThird  <= SECONDMAX )
                                {
                                    //--- Successfully matched hours, minutes, and seconds.
                                    pItemNormInfo = (TTSTimeItemInfo*) MemoryManager.GetMemory( sizeof(TTSTimeItemInfo),
                                                                                                &hr );
                                    if ( SUCCEEDED( hr ) )
                                    {
                                        ZeroMemory( pItemNormInfo, sizeof(TTSTimeItemInfo) );
                                        pItemNormInfo->Type = eTIME;
                                        ( (TTSTimeItemInfo*) pItemNormInfo )->pHours = 
                                                                            (TTSNumberItemInfo*) pFirstChunkInfo;

                                        if ( SUCCEEDED( hr ) )
                                        {
                                            TTSItemInfo* pMinutesInfo;

                                            //--- Don't want "zero zero..." behavior of numbers - strip off beginning zeroes
                                            if ( ulSecond != 0 )
                                            {
                                                pSecondChunk += ( ( pThirdChunk - 1 ) - pSecondChunk ) - 
                                                                (ULONG)( log10( ulSecond ) + 1 );
                                            }
                                            else
                                            {
                                                pSecondChunk = pThirdChunk - 2;
                                            }

                                            m_pNextChar      = pSecondChunk;
                                            m_pEndOfCurrItem = pThirdChunk - 1;

                                            hr = IsNumber( pMinutesInfo, L"NUMBER", MemoryManager );

                                            m_pNextChar      = pTempNextChar;
                                            m_pEndOfCurrItem = pTempEndOfItem;

                                            if ( SUCCEEDED( hr ) )
                                            {
                                                ( (TTSTimeItemInfo*) pItemNormInfo )->pMinutes = 
                                                                            (TTSNumberItemInfo*) pMinutesInfo;
                                                if ( *pThirdChunk != L'0' )
                                                {
                                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pThirdChunk;
                                                }
                                                else
                                                {
                                                    ( (TTSTimeItemInfo*) pItemNormInfo )->pSeconds = pThirdChunk + 1;
                                                }
                                            }
                                        }
                                    }
                                }
                                else // minutes or seconds were out of range
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else // extra junk at end of string
                            {
                                hr = E_INVALIDARG;
                            }
                        } 
                        else // extra junk at end of string
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    else // failed to match a colon
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            else // failed to match a second number
            {
                hr = E_INVALIDARG;
            }
        }
        else // failed to match a colon
        {
            hr = E_INVALIDARG;
        }
    }
    else // failed to match a first number
    {
        hr = E_INVALIDARG;
    }

    if ( FAILED( hr ) )
    {
        if ( pFirstChunkInfo )
        {
            delete ( (TTSNumberItemInfo*) pFirstChunkInfo )->pWordList;
        }
    }

    return hr;
} /* IsTime */

/***********************************************************************************************
* ExpandTime *
*------------*
*   Description:
*       Expands Items previously determined to be of type TIME_HRMINSEC by IsTime.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandTime( TTSTimeItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandTime" );

    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //-------------------
    // Expand the hours
    //-------------------

    if ( pItemInfo->pHours )
    {
        //--- Expand Number 
        hr = ExpandNumber( pItemInfo->pHours, WordList );

        //--- Insert "hour" or "hours"
        if ( SUCCEEDED( hr ) )
        {
            if ( pItemInfo->pHours->pEndChar - pItemInfo->pHours->pStartChar == 1 &&
                 pItemInfo->pHours->pStartChar[0] == L'1' )
            {
                Word.pWordText  = g_hour.pStr;
                Word.ulWordLen  = g_hour.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            else
            {
                Word.pWordText  = g_hours.pStr;
                Word.ulWordLen  = g_hours.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }

        }

        //--- Insert "and"
        if ( SUCCEEDED( hr )                 &&
             pItemInfo->pMinutes->pStartChar  &&
             !pItemInfo->pSeconds )
        {
            Word.pWordText  = g_And.pStr;
            Word.ulWordLen  = g_And.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }            
    }
    
    //---------------------
    // Expand the minutes
    //---------------------

    if ( SUCCEEDED( hr ) &&
         pItemInfo->pMinutes )
    {
        //--- Expand Number 
        hr = ExpandNumber( pItemInfo->pMinutes, WordList );

        //--- Insert "minutes" 
        if ( SUCCEEDED( hr ) )
        {
            if ( pItemInfo->pMinutes->pEndChar - pItemInfo->pMinutes->pStartChar == 1 &&
                 pItemInfo->pMinutes->pStartChar[0] == L'1' )
            {
                Word.pWordText  = g_minute.pStr;
                Word.ulWordLen  = g_minute.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
            else
            {
                Word.pWordText  = g_minutes.pStr;
                Word.ulWordLen  = g_minutes.Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }
        }

        //--- Insert "and"
        if ( SUCCEEDED( hr ) &&
             pItemInfo->pSeconds )
        {
            Word.pWordText  = g_And.pStr;
            Word.ulWordLen  = g_And.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
    }

    //---------------------
    // Expand the seconds
    //---------------------

    if ( SUCCEEDED( hr ) &&
         pItemInfo->pSeconds )
    {
        //--- Expand Number
        NumberGroup Garbage;
        if ( iswdigit( pItemInfo->pSeconds[1] ) )
        {
            ExpandTwoDigits( pItemInfo->pSeconds, Garbage, WordList );
        }
        else
        {
            ExpandDigit( pItemInfo->pSeconds[0], Garbage, WordList );
        }

        //--- Insert "seconds" 
        if ( pItemInfo->pSeconds[0] == L'1' &&
             !iswdigit( pItemInfo->pSeconds[1] ) )
        {
            Word.pWordText  = g_second.pStr;
            Word.ulWordLen  = g_second.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        else
        {
            Word.pWordText  = g_seconds.pStr;
            Word.ulWordLen  = g_seconds.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
    }

    return hr;
} /* ExpandTime */

/***********************************************************************************************
* IsTimeRange *
*-------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a time range.
*
*   RegExp:
*       [TimeOfDay]-[TimeOfDay]  
*
*   Types assigned:
*       TIME_RANGE
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsTimeRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager,
                                   CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsTimeRange" );

    HRESULT hr = S_OK;
	CWordList TempWordList;
    TTSItemInfo *pFirstTimeInfo = NULL, *pSecondTimeInfo = NULL;
    const WCHAR *pHyphen = NULL;
    CItemList PreAbbreviationList;  // Needed for SkipWhitespace function calls
    BOOL fMultiItem = false;
									
    const WCHAR *pTempNextChar = m_pNextChar, *pTempEndChar = m_pEndChar, *pTempEndOfCurrItem = m_pEndOfCurrItem;
    const SPVTEXTFRAG *pTempFrag = m_pCurrFrag;

    for ( pHyphen = m_pNextChar; pHyphen < m_pEndOfCurrItem; pHyphen++ )
    {
        if ( *pHyphen == L'-' )
        {
            break;
        }
    }

	//--- Might be whitespace and time suffix before hyphen
	if( pHyphen == m_pEndOfCurrItem ) 
	{
		hr = SkipWhiteSpaceAndTags( pHyphen, m_pEndChar, m_pCurrFrag, MemoryManager, 
									true, &PreAbbreviationList );
        if ( pHyphen && SUCCEEDED( hr ) )
        {
            if ( ( _wcsnicmp( pHyphen, L"am", 2 )   == 0 &&
                   pHyphen[2] == L'-' )           ||
				 ( _wcsnicmp( pHyphen, L"pm", 2 )   == 0 &&
                   pHyphen[2] == L'-' ) )
            {
				pHyphen += 2;
                *( (WCHAR*) pHyphen ) = ' ';
                fMultiItem = true;
			}
            else if ( ( _wcsnicmp( pHyphen, L"a.m.", 4 ) == 0 &&
                        pHyphen[4] == L'-' )          ||
                      ( _wcsnicmp( pHyphen, L"p.m.", 4 ) == 0 &&
                        pHyphen[4] == L'-' ) )
            {
				pHyphen +=4;
                *( (WCHAR*) pHyphen ) = ' ';
                fMultiItem = true;
            }
			else 
			{
				hr = E_INVALIDARG;
			}
		}
		else 
        {
			hr = E_INVALIDARG;
		}		
	}

	if ( SUCCEEDED( hr ) ) 
	{
		//--- Position m_pEndOfCurrItem so it is at the end of the first token, or at the hyphen,
		//--- whichever comes first (this is necessary for IsTimeOfDay to work).        
		if( ( m_pNextChar < pHyphen ) && ( pHyphen < m_pEndOfCurrItem ) ) 
		{
			m_pEndOfCurrItem = pHyphen;
		}

        //--- Check for time of day
        hr = IsTimeOfDay( pFirstTimeInfo, MemoryManager, TempWordList, fMultiItem );

        //--- Check for just a number (hour)
		if ( hr == E_INVALIDARG && ( pHyphen <= m_pNextChar + 2 ) )
		{
            WCHAR *pTemp = NULL;
			int ulHours = my_wcstoul( m_pNextChar, &pTemp );

            if ( pTemp == pHyphen   &&
                 HOURMIN <= ulHours && 
                 ulHours <= HOURMAX )
			{		
				NumberGroup Garbage;
				if ( pTemp - m_pNextChar == 1 )
                {
                    ExpandDigit( m_pNextChar[0], Garbage, TempWordList );
                }
                else
                {
                    ExpandTwoDigits( m_pNextChar, Garbage, TempWordList );
                }
				hr = S_OK;
			}
		}

        if ( SUCCEEDED( hr ) )
        {
            //--- Insert "to"
            TTSWord Word;
            ZeroMemory( &Word, sizeof( TTSWord ) );

            Word.pXmlState          = &m_pCurrFrag->State;
            Word.eWordPartOfSpeech  = MS_Unknown;
            Word.pWordText          = g_to.pStr;
            Word.ulWordLen          = g_to.Len;
            Word.pLemma             = Word.pWordText;
            Word.ulLemmaLen         = Word.ulWordLen;
            TempWordList.AddTail( Word );

            m_pNextChar      = pHyphen + 1;
			m_pEndOfCurrItem = FindTokenEnd( m_pNextChar, m_pEndChar );

			//---Move m_pEndOfCurrItem back from any punctuation. ("4:30-5:30.")
			while ( IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED ||
                    IsGroupEnding( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED     ||
                    IsQuotationMark( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED   ||
                    IsEOSItem( *(m_pEndOfCurrItem - 1) ) != eUNMATCHED )
			{
				m_pEndOfCurrItem--;
			}

            hr = IsTimeOfDay( pSecondTimeInfo, MemoryManager, TempWordList );

            if ( SUCCEEDED( hr ) )
            {
                //--- Matched a time range!
                m_pNextChar      = pTempNextChar;
                m_pEndChar       = pTempEndChar;

                pItemNormInfo = 
                    (TTSTimeRangeItemInfo*) MemoryManager.GetMemory( sizeof( TTSTimeRangeItemInfo ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    pItemNormInfo->Type = eTIME_RANGE;
                    ( (TTSTimeRangeItemInfo*) pItemNormInfo )->pFirstTimeInfo = 
                                                                        (TTSTimeOfDayItemInfo*) pFirstTimeInfo;
                    ( (TTSTimeRangeItemInfo*) pItemNormInfo )->pSecondTimeInfo =
                                                                        (TTSTimeOfDayItemInfo*) pSecondTimeInfo;
                    //--- Copy temp word list to real word list if everything has succeeded...
					WordList.AddTail( &TempWordList );
                }
            }
        }
    }

	if ( !SUCCEEDED( hr ) ) 
    {	
        m_pNextChar = pTempNextChar;
        m_pEndChar  = pTempEndChar;
        m_pEndOfCurrItem = pTempEndOfCurrItem;
        m_pCurrFrag = pTempFrag;
        if ( fMultiItem )
        {
            *( (WCHAR*) pHyphen ) = L'-';
        }
    }

    return hr;
} /* IsTimeRange */
//-----------End Of File-------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\stdsentenum.h ===
/******************************************************************************
* StdSentEnum.h *
*---------------*
*  This is the header file for the CStdSentEnum implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef StdSentEnum_h
#define StdSentEnum_h

//--- Additional includes
#include "stdafx.h"
#include "spttseng.h"
#include "resource.h"
#include "SentItemMemory.h"
#include "morph.h"

//=== Constants ====================================================

typedef enum SEPARATOR_AND_DECIMAL
{
    PERIOD_COMMA = (1L << 0),
    COMMA_PERIOD = (1L << 1)
} SEPARATOR_AND_DECIMAL;

typedef enum SHORT_DATE_ORDER
{
    MONTH_DAY_YEAR = (1L << 0),
    DAY_MONTH_YEAR = (1L << 1),
    YEAR_MONTH_DAY = (1L << 2)
} SHORT_DATE_ORDER;

//--- Vowel WCHAR values - used to disambiguate pronunciations of certain words
const WCHAR g_Vowels[] = 
{
    0x0a,   // AA
    0x0b,   // AE
    0x0c,   // AH
    0x0d,   // AO
    0x0e,   // AW
    0x0f,   // AX
    0x10,   // AY
    0x15,   // EH
    0x16,   // ER
    0x17,   // EY
    0x1b,   // IH
    0x1c,   // IY
    0x23,   // OW
    0x24,   // OY
    0x2a,   // UH
    0x2b,   // UW
};

//--- Normalization constants - see NormData.cpp
extern const char g_pFlagCharacter;
extern const unsigned char g_AnsiToAscii[256];
extern const SPLSTR g_O;
extern const SPLSTR g_negative;
extern const SPLSTR g_decimalpoint;
extern const SPLSTR g_to;
extern const SPLSTR g_a;
extern const SPLSTR g_of;
extern const SPLSTR g_percent;
extern const SPLSTR g_degree;
extern const SPLSTR g_degrees;
extern const SPLSTR g_squared;
extern const SPLSTR g_cubed;
extern const SPLSTR g_ones[10];
extern const SPLSTR g_tens[10];
extern const SPLSTR g_teens[10];
extern const SPLSTR g_onesOrdinal[10]; 
extern const SPLSTR g_tensOrdinal[10];
extern const SPLSTR g_teensOrdinal[10];
extern const SPLSTR g_quantifiers[6];
extern const SPLSTR g_quantifiersOrdinal[6];
extern const SPLSTR g_dash;
extern WCHAR g_Euro[2];

struct CurrencySign
{
    SPLSTR Sign;
    SPLSTR MainUnit;
    SPLSTR SecondaryUnit;
};

struct StateStruct
{
    SPLSTR Abbreviation;
    SPLSTR FullName;
};

extern const StateStruct g_StateAbbreviations[63];
extern const CurrencySign g_CurrencySigns[14];
extern const SPLSTR g_SingularPrimaryCurrencySigns[14];
extern const SPLSTR g_SingularSecondaryCurrencySigns[14];
extern const WCHAR g_DateDelimiters[3];
extern const SPLSTR g_months[12];
extern const SPLSTR g_monthAbbreviations[13];
extern const SPLSTR g_days[7];
extern const SPLSTR g_dayAbbreviations[10];
extern const SPLSTR g_Area;
extern const SPLSTR g_Country;
extern const SPLSTR g_Code;
extern const SPLSTR g_Half;
extern const SPLSTR g_Tenths;
extern const SPLSTR g_Sixteenths;
extern const SPLSTR g_Hundredths;
extern const SPLSTR g_Over;
extern const SPLSTR g_PluralDenominators[10];
extern const SPLSTR g_A;
extern const SPLSTR g_M;
extern const SPLSTR g_P;
extern const SPLSTR g_OClock;
extern const SPLSTR g_hundred;
extern const SPLSTR g_hour;
extern const SPLSTR g_hours;
extern const SPLSTR g_minute;
extern const SPLSTR g_minutes;
extern const SPLSTR g_second;
extern const SPLSTR g_seconds;
extern const SPLSTR g_ANSICharacterProns[256];
extern const SPVSTATE g_DefaultXMLState;
extern const SPLSTR g_And;
extern const SPLSTR g_comma;
extern const SPLSTR g_period;
extern const SPLSTR g_periodString;
extern const SPLSTR g_slash;
extern const SPLSTR g_Decades[];
extern const SPLSTR g_Zeroes;
extern const SPLSTR g_Hundreds;

#define DAYMAX 31
#define DAYMIN 1
#define MONTHMAX 12
#define MONTHMIN 1
#define YEARMAX 9999
#define YEARMIN 0
#define HOURMIN 1
#define HOURMAX 23
#define MINUTEMIN 0
#define MINUTEMAX 59
#define SECONDMIN 0
#define SECONDMAX 59

//--- POS Tagger Constants - see MiscData.cpp

typedef enum TEMPLATETYPE
{
    PREV1T,
    NEXT1T,
    PREV2T,
    NEXT2T,
    PREV1OR2T,
    NEXT1OR2T,
    PREV1OR2OR3T,
    NEXT1OR2OR3T,
    PREV1TNEXT1T,
    PREV1TNEXT2T,
    PREV2TNEXT1T,
    NOTCAP,
    CAP,
    PREVNOTCAP,
    PREVCAP,
    PREV1W,
    NEXT1W,
    PREV2W,
    NEXT2W,
    PREV1OR2W,
    NEXT1OR2W,
    CURRWPREV1W,
    CURRWNEXT1W,
    CURRWPREV1T,
    CURRWNEXT1T,
    CURRW,
    PREV1WT,
    NEXT1WT,
    CURRWPREV1WT,
    CURRWNEXT1WT
} TEMPLATETYPE;

struct BrillPatch
{
    ENGPARTOFSPEECH eCurrentPOS;
    ENGPARTOFSPEECH eConvertToPOS;
    TEMPLATETYPE   eTemplateType;
    ENGPARTOFSPEECH eTemplatePOS1;
    ENGPARTOFSPEECH eTemplatePOS2;
    const WCHAR*   pTemplateWord1;
    const WCHAR*   pTemplateWord2;
};

extern const BrillPatch g_POSTaggerPatches [63];

//=== Class, Enum, Struct and Union Declarations ===================

typedef CSPList<TTSWord,TTSWord&> CWordList;
typedef CSPList<TTSSentItem,TTSSentItem&> CItemList;

//--- Structs used for normalization

typedef enum
{
    PRECEDING,
    FOLLOWING,
    UNATTACHED
} NORM_POSITION;

struct NumberGroup
{
    BOOL    fOnes;          // "one" through "nineteen"
    BOOL    fTens;          // "twenty" through "ninety"
    BOOL    fHundreds;      // "one hundred" through "nine hundred"
    BOOL    fQuantifier;    // "thousand" through "quadrillion"
};

struct TTSIntegerItemInfo
{
    long            lNumGroups;
    NumberGroup     Groups[6];
    BOOL            fOrdinal;
    BOOL            fDigitByDigit;
    ULONG           ulNumDigits;
    //--- Normalization internal only
    long            lLeftOver;
    BOOL            fSeparators;
    const WCHAR*    pStartChar;
    const WCHAR*    pEndChar;
};

struct TTSDigitsItemInfo : TTSItemInfo
{
    const WCHAR*    pFirstDigit;
    ULONG           ulNumDigits;
};

struct TTSNumberItemInfo;

struct TTSFractionItemInfo 
{
    BOOL                    fIsStandard;
    TTSNumberItemInfo*   pNumerator;
    TTSNumberItemInfo*   pDenominator;
    //--- Normalization internal only
    const WCHAR*            pVulgar;
};

struct TTSNumberItemInfo : TTSItemInfo
{
    BOOL                    fNegative;
    TTSIntegerItemInfo*     pIntegerPart;
    TTSDigitsItemInfo*      pDecimalPart;
    TTSFractionItemInfo* pFractionalPart;
    //--- Normalization internal only
    const WCHAR*            pStartChar;
    const WCHAR*            pEndChar;
    CWordList*              pWordList;
};    

struct TTSPhoneNumberItemInfo : TTSItemInfo
{
    //--- Country code members
    TTSNumberItemInfo*  pCountryCode;
    //--- Area code members
    TTSDigitsItemInfo*  pAreaCode;
    BOOL                fIs800;
    BOOL                fOne;
    //--- Main number members
    TTSDigitsItemInfo** ppGroups;
    ULONG               ulNumGroups;
};

struct TTSZipCodeItemInfo : TTSItemInfo
{
    TTSDigitsItemInfo*  pFirstFive;
    TTSDigitsItemInfo*  pLastFour;
};

struct TTSStateAndZipCodeItemInfo : TTSItemInfo
{
    TTSZipCodeItemInfo* pZipCode;
};

struct TTSCurrencyItemInfo : TTSItemInfo
{
    TTSNumberItemInfo*  pPrimaryNumberPart;
    TTSNumberItemInfo*  pSecondaryNumberPart;
    BOOL                fQuantifier;
    long                lNumPostNumberStates;
    long                lNumPostSymbolStates;
};

struct TTSYearItemInfo : TTSItemInfo
{
    const WCHAR*    pYear;
    ULONG           ulNumDigits;
};

struct TTSRomanNumeralItemInfo : TTSItemInfo
{
    TTSItemInfo*    pNumberInfo;
};

struct TTSDecadeItemInfo : TTSItemInfo
{
    const WCHAR*    pCentury;
    ULONG           ulDecade;
};

struct TTSDateItemInfo : TTSItemInfo
{
    ULONG               ulDayIndex;
    ULONG               ulMonthIndex;
    TTSIntegerItemInfo* pDay;
    TTSYearItemInfo*    pYear;
};

typedef enum
{
    AM,
    PM,
    UNDEFINED
} TIMEABBREVIATION;

struct TTSTimeOfDayItemInfo : TTSItemInfo
{
    BOOL    fTimeAbbreviation;
    BOOL    fTwentyFourHour;
    BOOL    fMinutes;
};

struct TTSTimeItemInfo : TTSItemInfo
{
    TTSNumberItemInfo*  pHours;
    TTSNumberItemInfo*  pMinutes;
    const WCHAR*        pSeconds;
};

struct TTSHyphenatedStringInfo : TTSItemInfo
{
    TTSItemInfo* pFirstChunkInfo;
    TTSItemInfo* pSecondChunkInfo;
    const WCHAR* pFirstChunk;
    const WCHAR* pSecondChunk;
};

struct TTSSuffixItemInfo : TTSItemInfo
{
    const WCHAR* pFirstChar;
    ULONG        ulNumChars;
};

struct TTSNumberRangeItemInfo : TTSItemInfo
{
    TTSItemInfo *pFirstNumberInfo;
    TTSItemInfo *pSecondNumberInfo;
};

struct TTSTimeRangeItemInfo : TTSItemInfo
{
    TTSTimeOfDayItemInfo *pFirstTimeInfo;
    TTSTimeOfDayItemInfo *pSecondTimeInfo;
};

struct AbbrevRecord 
{
    const WCHAR*    pOrth;
    WCHAR*          pPron1;
    ENGPARTOFSPEECH POS1;
    WCHAR*          pPron2;
    ENGPARTOFSPEECH POS2;
    WCHAR*          pPron3;
    ENGPARTOFSPEECH POS3;
    int             iSentBreakDisambig;
    int             iPronDisambig;
};

struct TTSAbbreviationInfo : TTSItemInfo
{
    const AbbrevRecord*   pAbbreviation;
};

//--- Structs used for Lex Lookup

typedef enum { PRON_A = 0, PRON_B = 1 };

struct PRONUNIT
{
    ULONG           phon_Len;
    WCHAR           phon_Str[SP_MAX_PRON_LENGTH];		// Allo string
    ULONG			POScount;
    ENGPARTOFSPEECH	POScode[POS_MAX];
};

struct PRONRECORD
{
    WCHAR           orthStr[SP_MAX_WORD_LENGTH];      // Orth text
    WCHAR           lemmaStr[SP_MAX_WORD_LENGTH];     // Root word
    ULONG		    pronType;                   // Pronunciation is lex or LTS
    PRONUNIT        pronArray[2];
    ENGPARTOFSPEECH	POSchoice;
    ENGPARTOFSPEECH XMLPartOfSpeech;
    bool			hasAlt;
    ULONG			altChoice;
    BOOL            fUsePron;
};

//--- Miscellaneous structs and typedefs

struct SentencePointer
{
    const WCHAR *pSentenceStart;
    const SPVTEXTFRAG *pSentenceFrag;
};

//=== Function Definitions ===========================================

// Misc Number Normalization functions and helpers
int MatchCurrencySign( const WCHAR*& pStartChar, const WCHAR*& pEndChar, NORM_POSITION& ePosition );

//=== Classes

/*** CSentenceStack *************************************************
*   This class is used to maintain a stack of sentences for the Skip
*   call to utilize.
*/
class CSentenceStack
{
  public:
    /*--- Methods ---*/
    CSentenceStack() { m_StackPtr = -1; }
    int GetCount( void ) { return m_StackPtr + 1; }
    virtual SentencePointer& Pop( void ) { SPDBG_ASSERT( m_StackPtr > -1 ); return m_Stack[m_StackPtr--]; }
    virtual HRESULT Push( const SentencePointer& val ) { ++m_StackPtr; return m_Stack.SetAtGrow( m_StackPtr, val ); }
    virtual void Reset( void ) { m_StackPtr = -1; }

  protected:
    /*--- Member data ---*/
    CSPArray<SentencePointer,SentencePointer>  m_Stack;
    int                                m_StackPtr;
};

/*** CSentItem
*   This object is a helper class
*/
class CSentItem : public TTSSentItem
{
  public:
    CSentItem() { memset( this, 0, sizeof(*this) ); }
    CSentItem( TTSSentItem& Other ) { memcpy( this, &Other, sizeof( Other ) ); }
};

/*** CSentItemEnum
*   This object is designed to be used by a single thread.
*/
class ATL_NO_VTABLE CSentItemEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IEnumSENTITEM
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSentItemEnum)
	    COM_INTERFACE_ENTRY(IEnumSENTITEM)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/
    void _SetOwner( IUnknown* pOwner ) { m_cpOwner = pOwner; }
    CItemList& _GetList( void ) { return m_ItemList; }
    CSentItemMemory& _GetMemoryManager( void ) { return m_MemoryManager; }

  /*=== Interfaces ====*/
  public:
    //--- IEnumSpSentence ----------------------------------------
	STDMETHOD(Next)( TTSSentItem *pItemEnum );
	STDMETHOD(Reset)( void );

  /*=== Member data ===*/
  private:
    CComPtr<IUnknown>   m_cpOwner;
    CItemList           m_ItemList;
    SPLISTPOS           m_ListPos;
    CSentItemMemory     m_MemoryManager;
};

/*** CStdSentEnum COM object
*/
class ATL_NO_VTABLE CStdSentEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IEnumSpSentence
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CStdSentEnum)
	    COM_INTERFACE_ENTRY(IEnumSpSentence)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    HRESULT FinalConstruct();
    void FinalRelease();

    /*--- Non interface methods ---*/
    HRESULT InitAggregateLexicon( void );
    HRESULT AddLexiconToAggregate( ISpLexicon *pAddLexicon, DWORD dwFlags );
    HRESULT InitMorphLexicon( void );

    //--- Abbreviation Sentence Breaking Disambiguation Functions
    HRESULT IsAbbreviationEOS( const AbbrevRecord* pAbbreviation, CItemList& ItemList, SPLISTPOS ItemPos, 
                               CSentItemMemory& MemoryManager, BOOL* pfIsEOS );
    HRESULT IfEOSNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList& ItemList, SPLISTPOS ItemPos,
                                  CSentItemMemory& MemoryManager, BOOL* pfIsEOS );
    HRESULT IfEOSAndLowercaseNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList& ItemList, SPLISTPOS ItemPos,
                                              CSentItemMemory& MemoryManager, BOOL* pfIsEOS );

    //--- Abbreviation Pronunciation Disambiguation Functions
    HRESULT SingleOrPluralAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                        CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT DoctorDriveAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                     CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT AbbreviationFollowedByDigit( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                         CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT AllCapsAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                 CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT CapitalizedAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                     CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT SECAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                             CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT DegreeAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                CItemList& ItemList, SPLISTPOS ListPos );
	HRESULT AbbreviationModifier( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                                CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT ADisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                       CItemList& ItemList, SPLISTPOS ListPos );
    HRESULT PolishDisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron,
                            CItemList& ItemList, SPLISTPOS ListPos );

    //--- Word Pronunciation Disambiguation Functions
    HRESULT MeasurementDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                 SPLISTPOS ListPos, CSentItemMemory& MemoryManager );
    HRESULT TheDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                         SPLISTPOS ListPos, CSentItemMemory& MemoryManager );
    HRESULT ReadDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                          SPLISTPOS ListPos, CSentItemMemory& MemoryManager );


  private:
    //--- Pronunciation Table init helper
    HRESULT InitPron( WCHAR** OriginalPron );

    //--- Sentence breaking helpers ---//
    HRESULT GetNextSentence( IEnumSENTITEM** pItemEnum );
    HRESULT AddNextSentItem( CItemList& ItemList, CSentItemMemory& MemoryManager, BOOL* pfIsEOS );
    HRESULT SkipWhiteSpaceAndTags( const WCHAR*& pStartChar, const WCHAR*& pEndChar, 
                                   const SPVTEXTFRAG*& pCurrFrag, CSentItemMemory& pMemoryManager, 
                                   BOOL fAddToItemList = false, CItemList* pItemList = NULL );
    const WCHAR* FindTokenEnd( const WCHAR* pStartChar, const WCHAR* pEndChar );

    //--- Lexicon and POS helpers ---//
    HRESULT DetermineProns( CItemList& ItemList, CSentItemMemory& MemoryManager );
    HRESULT Pronounce( PRONRECORD *pPron );

    //--- Normalization helpers ---//
    HRESULT Normalize( CItemList& ItemList, SPLISTPOS ListPos, CSentItemMemory& MemoryManager );
    HRESULT MatchCategory( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT ExpandCategory( TTSItemInfo*& pItemNormInfo, CItemList& ItemList, SPLISTPOS ListPos, 
                            CSentItemMemory& MemoryManager );
    HRESULT DoUnicodeToAsciiMap( const WCHAR *pUnicodeString, ULONG ulUnicodeStringLength,
                                 WCHAR *ppConvertedString );
    HRESULT IsAlphaWord( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo,
                         CSentItemMemory& MemoryManager );
    HRESULT IsInitialism( CItemList& ItemList, SPLISTPOS ItemPos, CSentItemMemory& MemoryManager,
                          BOOL* pfIsEOS );
    //--- Various Number Related Normalization helpers ---//
    HRESULT IsNumberCategory( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT IsNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager,
                      BOOL fMultiItem = true );
    HRESULT IsInteger( const WCHAR* pStartChar, TTSIntegerItemInfo*& pIntegerInfo, 
                       CSentItemMemory& MemoryManager );
    HRESULT IsDigitString( const WCHAR* pStartChar, TTSDigitsItemInfo*& pDigitsInfo,
                           CSentItemMemory& MemoryManager );
    HRESULT ExpandNumber( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandPercent( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandDegrees( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandSquare( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandCube( TTSNumberItemInfo* pItemInfo, CWordList& WordList );
    void ExpandInteger( TTSIntegerItemInfo* pItemInfo, const WCHAR* Context, CWordList &WordList );
    void ExpandDigit( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandTwoDigits( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandThreeDigits( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandDigitOrdinal( const WCHAR Number, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandTwoOrdinal( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandThreeOrdinal( const WCHAR* NumberString, NumberGroup& NormGroupInfo, CWordList& WordList );
    void ExpandDigits( TTSDigitsItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsFraction( const WCHAR* pStartChar, TTSFractionItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager );
    HRESULT ExpandFraction( TTSFractionItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsRomanNumeral( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT IsPhoneNumber( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT IsZipCode( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT ExpandZipCode( TTSZipCodeItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsCurrency( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                        CWordList& WordList );
    HRESULT IsNumberRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager );
    HRESULT ExpandNumberRange( TTSNumberRangeItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsCurrencyRange( TTSItemInfo*& pItemInfo, CSentItemMemory& MemoryManager, CWordList& WordList );

    //--- Date Related Normalization helpers ---//
    HRESULT IsNumericCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                  CSentItemMemory& MemoryManager );
    HRESULT IsMonthStringCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                      CSentItemMemory& MemoryManager );
    HRESULT IsLongFormDate_DMDY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT IsLongFormDate_DDMY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT ExpandDate( TTSDateItemInfo* pItemInfo, CWordList& WordList );
    HRESULT ExpandYear( TTSYearItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsDecade( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager );
    HRESULT ExpandDecade( TTSDecadeItemInfo* pItemInfo, CWordList& WordList );
    ULONG MatchMonthString( WCHAR*& pMonth, ULONG ulLength );
    ULONG MatchDayString( WCHAR*& pDayString, WCHAR* pEndChar );
    bool  MatchDateDelimiter( WCHAR **DateString );

    //--- Time Related Normalization helpers ---//
    HRESULT IsTimeOfDay( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList, BOOL fMultiItem = true );
    HRESULT IsTime( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, CSentItemMemory& MemoryManager );
    HRESULT ExpandTime( TTSTimeItemInfo* pItemInfo, CWordList& WordList );
    HRESULT IsTimeRange( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );

    //--- SPELL tag normalization helper
    HRESULT SpellOutString( CWordList& WordList );
    void ExpandPunctuation( CWordList& WordList, WCHAR wc );

    //--- Default normalization helper
    HRESULT ExpandUnrecognizedString( CWordList& WordList, CSentItemMemory& MemoryManager );

    //--- Misc. normalization helpers
    HRESULT IsStateAndZipcode( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, CWordList& WordList );
    HRESULT IsHyphenatedString( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo, 
                                CSentItemMemory& MemoryManager );
    HRESULT ExpandHyphenatedString( TTSHyphenatedStringInfo* pItemInfo, CWordList& WordList );
    HRESULT IsSuffix( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo,
                      CSentItemMemory& MemoryManager );
    HRESULT ExpandSuffix( TTSSuffixItemInfo* pItemInfo, CWordList& WordList );
    bool Zeroes( const WCHAR* );
    bool ThreeZeroes( const WCHAR* );
    bool IsPunctuation(const TTSSentItem *Item);

  /*=== Interfaces ====*/
  public:
    //--- IEnumSpSentence ----------------------------------------
	STDMETHOD(SetFragList)( const SPVTEXTFRAG* pTextFragList, DWORD dwFlags );
	STDMETHOD(Next)( IEnumSENTITEM **ppSentItemEnum );
    STDMETHOD(Previous)( IEnumSENTITEM **ppSentItemEnum );
	STDMETHOD(Reset)( void );

  //=== Data members ===
  private:
    CComPtr<ISpContainerLexicon>    m_cpAggregateLexicon;
    CComPtr<ISpPhoneConverter>      m_cpPhonemeConverter;
    CSMorph*                        m_pMorphLexicon;
    DWORD                           m_dwSpeakFlags;
    const SPVTEXTFRAG*              m_pTextFragList;
    const SPVTEXTFRAG*              m_pCurrFrag;
    const WCHAR*                    m_pNextChar;
    const WCHAR*                    m_pEndChar;
    const WCHAR*                    m_pEndOfCurrToken;
    const WCHAR*                    m_pEndOfCurrItem;
    CSentenceStack                  m_SentenceStack;
    SEPARATOR_AND_DECIMAL           m_eSeparatorAndDecimal;
    SHORT_DATE_ORDER                m_eShortDateOrder;
    static CComAutoCriticalSection  m_AbbrevTableCritSec;
};

//--- Structs and typedefs used for abbreviation stuff

typedef HRESULT (CStdSentEnum::* SentBreakDisambigFunc)(const AbbrevRecord*, CItemList& , SPLISTPOS, 
                                                        CSentItemMemory&, BOOL*);
typedef HRESULT (CStdSentEnum::* PronDisambigFunc) ( const AbbrevRecord*, PRONRECORD*, CItemList&, SPLISTPOS );
typedef HRESULT (CStdSentEnum::* PostLexLookupDisambigFunc) ( const AbbrevRecord*, CItemList&, SPLISTPOS, CSentItemMemory& );
extern AbbrevRecord g_AbbreviationTable[177];
extern const PronDisambigFunc g_PronDisambigTable[];
extern const SentBreakDisambigFunc g_SentBreakDisambigTable[];
extern AbbrevRecord g_AmbiguousWordTable[72];
extern const PronDisambigFunc g_AmbiguousWordDisambigTable[];
extern AbbrevRecord g_PostLexLookupWordTable[41];
extern const PostLexLookupDisambigFunc g_PostLexLookupDisambigTable[];
extern WCHAR *g_pOfA;
extern WCHAR *g_pOfAn;
extern BOOL g_fAbbrevTablesInitialized;
extern void CleanupAbbrevTables( void );

//--- First words table - used in sentence breaking
extern const SPLSTR g_FirstWords[163];

//
//=== Inlines
//

inline ULONG my_wcstoul( const WCHAR *pStartChar, WCHAR **ppEndChar )
{
    if ( iswdigit( *pStartChar ) )
    {
        return wcstoul( pStartChar, ppEndChar, 10 );
    }
    else
    {
        if ( ppEndChar )
        {
            *ppEndChar = (WCHAR*) pStartChar;
        }
        return 0;
    }
}

inline ENGPARTOFSPEECH ConvertItemTypeToPartOfSp( TTSItemType ItemType )
{
    switch ( ItemType )
    {
    case eOPEN_PARENTHESIS:
    case eOPEN_BRACKET:
    case eOPEN_BRACE:
        return MS_GroupBegin;

    case eCLOSE_PARENTHESIS:
    case eCLOSE_BRACKET:
    case eCLOSE_BRACE:
        return MS_GroupEnd;

    case eSINGLE_QUOTE:
    case eDOUBLE_QUOTE:
        return MS_Quotation;

    case ePERIOD:
    case eQUESTION:
    case eEXCLAMATION:
        return MS_EOSItem;

    case eCOMMA:
    case eCOLON:
    case eSEMICOLON:
    case eHYPHEN:
    case eELLIPSIS:
        return MS_MiscPunc;

    default:
        return MS_Unknown;
    }
}

inline bool MatchPhoneNumberDelimiter( const WCHAR wc )
{
    return ( wc == L' ' || wc == L'-' || wc == L'.' );
}   

inline bool NeedsToBeNormalized( const AbbrevRecord* pAbbreviation )
{
    if( !wcscmp( pAbbreviation->pOrth, L"jan" )   ||
        !wcscmp( pAbbreviation->pOrth, L"feb" )   ||
        !wcscmp( pAbbreviation->pOrth, L"mar" )   ||
        !wcscmp( pAbbreviation->pOrth, L"apr" )   ||
        !wcscmp( pAbbreviation->pOrth, L"jun" )   ||
        !wcscmp( pAbbreviation->pOrth, L"jul" )   ||
        !wcscmp( pAbbreviation->pOrth, L"aug" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sep" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sept" )  ||
        !wcscmp( pAbbreviation->pOrth, L"oct" )   ||
        !wcscmp( pAbbreviation->pOrth, L"nov" )   ||
        !wcscmp( pAbbreviation->pOrth, L"dec" )   ||
        !wcscmp( pAbbreviation->pOrth, L"mon" )   ||
        !wcscmp( pAbbreviation->pOrth, L"tue" )   ||
        !wcscmp( pAbbreviation->pOrth, L"tues" )  ||
        !wcscmp( pAbbreviation->pOrth, L"wed" )   ||
        !wcscmp( pAbbreviation->pOrth, L"thu" )   ||
        !wcscmp( pAbbreviation->pOrth, L"thur" )  ||
        !wcscmp( pAbbreviation->pOrth, L"thurs" ) ||
        !wcscmp( pAbbreviation->pOrth, L"fri" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sat" )   ||
        !wcscmp( pAbbreviation->pOrth, L"sun" ) )
    {
        return true;
    }
    else
    {
        return false;
    }
}

inline HRESULT SetWordList( CSentItem& Item, CWordList& WordList, CSentItemMemory& MemoryManager )
{
    HRESULT hr = S_OK;
    SPLISTPOS WordListPos = WordList.GetHeadPosition();
    Item.ulNumWords = WordList.GetCount();
    Item.Words = (TTSWord*) MemoryManager.GetMemory( Item.ulNumWords * sizeof(TTSWord), &hr );
    if ( SUCCEEDED( hr ) )
    {
        ULONG ulIndex = 0;
        while ( WordListPos )
        {
            SPDBG_ASSERT( ulIndex < Item.ulNumWords );
            Item.Words[ulIndex++] = WordList.GetNext( WordListPos );
        }
    }

    return hr;
}

inline int CompareStringAndSPLSTR( const void* _String, const void* _SPLSTR )
{
    int _StringLen = wcslen( (const WCHAR*) _String );
    int _SPLSTRLen = ( (const SPLSTR*) _SPLSTR )->Len;
    if ( _StringLen < _SPLSTRLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const SPLSTR*) _SPLSTR )->pStr, _StringLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return -1;
        }
    }
    else if ( _StringLen > _SPLSTRLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const SPLSTR*) _SPLSTR )->pStr, _SPLSTRLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return 1;
        }
    }
    else
    {
        return ( wcsnicmp( (const WCHAR*) _String , ( (const SPLSTR*) _SPLSTR )->pStr, _StringLen ) );
    }
}

inline int CompareStringAndStateStruct( const void* _String, const void* _StateStruct )
{
    int _StringLen = wcslen( (const WCHAR*) _String );
    int _StateStructLen = ( (const StateStruct*) _StateStruct )->Abbreviation.Len;
    if ( _StringLen < _StateStructLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const StateStruct*) _StateStruct )->Abbreviation.pStr, 
                               _StringLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return -1;
        }
    }
    else if ( _StringLen > _StateStructLen )
    {
        int Result = wcsnicmp( (const WCHAR*) _String , ( (const StateStruct*) _StateStruct )->Abbreviation.pStr, 
                               _StateStructLen );
        if ( Result != 0 )
        {
            return Result;
        }
        else
        {
            return 1;
        }
    }
    else
    {
        return ( wcsnicmp( (const WCHAR*) _String , ( (const StateStruct*) _StateStruct )->Abbreviation.pStr, 
                           _StringLen ) );
    }
}

inline int CompareStringAndAbbrevRecord( const void* _String, const void* _AbbrevRecord )
{
    return ( _wcsicmp( (const WCHAR*) _String, ( (const AbbrevRecord*) _AbbrevRecord )->pOrth ) );
}

inline int CompareWCHARAndWCHAR( const void *pWCHAR_1, const void *pWCHAR_2 )
{
    return ( *( (WCHAR*) pWCHAR_1) - *( (WCHAR*) pWCHAR_2) );
}

inline BOOL IsSpace( WCHAR wc )
{
    return ( ( wc == 0x20 ) || ( wc == 0x9 ) || ( wc == 0xD  ) ||
             ( wc == 0xA ) || ( wc == 0x200B ) );
}

inline BOOL IsCapital( WCHAR wc )
{
    return ( ( wc >= L'A' ) && ( wc <= L'Z' ) );
}

inline TTSItemType IsGroupBeginning( WCHAR wc )
{
    if ( wc == L'(' )
    {
        return eOPEN_PARENTHESIS;
    }
    else if ( wc == L'[' )
    {
        return eOPEN_BRACKET;
    }
    else if ( wc == L'{' )
    {
        return eOPEN_BRACE;
    }
    else
    {
        return eUNMATCHED;
    }
}

inline TTSItemType IsGroupEnding( WCHAR wc )
{
    if ( wc == L')' )
    {
        return eCLOSE_PARENTHESIS;
    }
    else if ( wc == L']' )
    {
        return eCLOSE_BRACKET;
    }
    else if ( wc == L'}' )
    {
        return eCLOSE_BRACE;
    }
    else
    {
        return eUNMATCHED;
    }    
}

inline TTSItemType IsQuotationMark( WCHAR wc )
{
    if ( wc == L'\'' )
    {
        return eSINGLE_QUOTE;
    }
    else if ( wc == L'\"' )
    {
        return eDOUBLE_QUOTE;
    }
    else
    {
        return eUNMATCHED;
    }
}

inline TTSItemType IsEOSItem( WCHAR wc )
{
    if ( wc == L'.' )
    {
        return ePERIOD;
    }
    else if ( wc == L'!' )
    {
        return eEXCLAMATION;
    }
    else if ( wc == L'?' )
    {
        return eQUESTION;
    }
    else
    {
        return eUNMATCHED;
    }
}

inline TTSItemType IsMiscPunctuation( WCHAR wc )
{
    if ( wc == L',' )
    {
        return eCOMMA;
    }
    else if ( wc == L';' )
    {
        return eSEMICOLON;
    }
    else if ( wc == L':' )
    {
        return eCOLON;
    }
    else if ( wc == L'-' )
    {
        return eHYPHEN;
    }
    else
    {
        return eUNMATCHED;
    }
}

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\stdsentenum.cpp ===
/*******************************************************************************
* StdSentEnum.cpp *
*-----------------*
*   Description:
*       This module is the main implementation file for the CStdSentEnum class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 03/19/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif
#include "spttsengdebug.h"
#include "SpAutoObjectLock.h"

//--- Locals 
CComAutoCriticalSection CStdSentEnum::m_AbbrevTableCritSec;

//=== CStdSentEnum ============================================================
//

/*****************************************************************************
* CStdSentEnum::InitPron *
*------------------------*
*   Description:
*       Inits pron tables
********************************************************************* AH ***/
HRESULT CStdSentEnum::InitPron( WCHAR** OriginalPron )
{
    HRESULT hr = S_OK;
    WCHAR *NewPron = NULL;

    NewPron = new WCHAR[ wcslen( *OriginalPron ) ];
    hr = m_cpPhonemeConverter->PhoneToId( *OriginalPron, NewPron );
    if ( SUCCEEDED( hr ) )
    {
        *OriginalPron = NewPron;
    }

    return hr;
} /* InitPron */

/*****************************************************************************
* CStdSentEnum::FinalConstruct *
*------------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CStdSentEnum::FinalConstruct()
{
    SPDBG_FUNC( "CStdSentEnum::FinalConstruct" );
    HRESULT hr = S_OK;
    m_dwSpeakFlags  = 0;
    m_pTextFragList = NULL;
    m_pMorphLexicon = NULL;
    m_eSeparatorAndDecimal = COMMA_PERIOD;
    m_eShortDateOrder      = MONTH_DAY_YEAR;
    /*** Create phone converter ***/
    if ( SUCCEEDED( hr ) )
    {
        hr = SpCreatePhoneConverter( 1033, NULL, NULL, &m_cpPhonemeConverter );
        m_AbbrevTableCritSec.Lock();
        if ( !g_fAbbrevTablesInitialized )
        {
            for ( ULONG i = 0; SUCCEEDED( hr ) && i < sp_countof( g_AbbreviationTable ); i++ )
            {
                if ( g_AbbreviationTable[i].pPron1 )
                {
                    hr = InitPron( &g_AbbreviationTable[i].pPron1 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AbbreviationTable[i].pPron2 )
                {
                    hr = InitPron( &g_AbbreviationTable[i].pPron2 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AbbreviationTable[i].pPron3 )
                {
                    hr = InitPron( &g_AbbreviationTable[i].pPron3 );
                }
            }
            for ( i = 0; SUCCEEDED( hr ) && i < sp_countof( g_AmbiguousWordTable ); i++ )
            {
                if ( g_AmbiguousWordTable[i].pPron1 )
                {
                    hr = InitPron( &g_AmbiguousWordTable[i].pPron1 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AmbiguousWordTable[i].pPron2 )
                {
                    hr = InitPron( &g_AmbiguousWordTable[i].pPron2 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_AmbiguousWordTable[i].pPron3 )
                {
                    hr = InitPron( &g_AmbiguousWordTable[i].pPron3 );
                }
            }
            for ( i = 0; SUCCEEDED( hr ) && i < sp_countof( g_PostLexLookupWordTable ); i++ )
            {
                if ( g_PostLexLookupWordTable[i].pPron1 )
                {
                    hr = InitPron( &g_PostLexLookupWordTable[i].pPron1 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_PostLexLookupWordTable[i].pPron2 )
                {
                    hr = InitPron( &g_PostLexLookupWordTable[i].pPron2 );
                }
                if ( SUCCEEDED( hr ) &&
                     g_PostLexLookupWordTable[i].pPron3 )
                {
                    hr = InitPron( &g_PostLexLookupWordTable[i].pPron3 );
                }
            }
            if ( SUCCEEDED( hr ) )
            {
                hr = InitPron( &g_pOfA );
                if ( SUCCEEDED( hr ) )
                {
                    hr = InitPron( &g_pOfAn );
                }
            }
        }
        if ( SUCCEEDED( hr ) )
        {
            g_fAbbrevTablesInitialized = true;
        }
        m_AbbrevTableCritSec.Unlock();
    }

    return hr;
} /* CStdSentEnum::FinalConstruct */

/*****************************************************************************
* CStdSentEnum::FinalRelease *
*----------------------------*
*   Description:
*       Destructor
********************************************************************* EDC ***/
void CStdSentEnum::FinalRelease()
{
    SPDBG_FUNC( "CStdSentEnum::FinalRelease" );

    if ( m_pMorphLexicon )
    {
        delete m_pMorphLexicon;
    }
    
} /* CStdSentEnum::FinalRelease */

/*****************************************************************************
* CStdSentEnum::SetFragList *
*---------------------------*
*   The text fragment list passed in is guaranteed to be valid for the lifetime
*   of this object. Each time this method is called, the sentence enumerator
*   should reset its state.
********************************************************************* EDC ***/
STDMETHODIMP CStdSentEnum::
    SetFragList( const SPVTEXTFRAG* pTextFragList, DWORD dwSpeakFlags )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::SetFragList" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_READ_PTR( pTextFragList ) || 
        ( dwSpeakFlags & SPF_UNUSED_FLAGS ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_dwSpeakFlags   = dwSpeakFlags;
        m_pTextFragList  = pTextFragList;

        //--- Reset state
        Reset();
    }

    return hr;
} /* CStdSentEnum::SetFragList */

/*****************************************************************************
* CStdSentEnum::Next *
*--------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CStdSentEnum::Next( IEnumSENTITEM **ppSentItemEnum )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::Next" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SPIsBadWritePtr( ppSentItemEnum, sizeof( IEnumSENTITEM* ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- If this is NULL then the enum needs to be reset
        if( m_pCurrFrag )
        {
            SentencePointer NewSentencePointer;
            NewSentencePointer.pSentenceFrag = m_pCurrFrag;
            NewSentencePointer.pSentenceStart = m_pNextChar;

            hr = GetNextSentence( ppSentItemEnum );
            if( hr == S_OK ) 
            {
                //--- Update Sentence Pointer List
                hr = m_SentenceStack.Push( NewSentencePointer );
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
} /* CStdSentEnum::Next */

/*****************************************************************************
* CStdSentEnum::Previous *
*--------------------*
*
********************************************************************* AH ****/
STDMETHODIMP CStdSentEnum::Previous( IEnumSENTITEM **ppSentItemEnum )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::Previous" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SPIsBadWritePtr( ppSentItemEnum, sizeof( IEnumSENTITEM* ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Don't care if m_pCurrFrag is NULL, as long as we have enough on the SentenceStack
        //---   to skip backwards...
        if( m_SentenceStack.GetCount() >= 2 )
        {
            //--- Get the previous Sentence from the Sentence List, and then remove the Current Sentence
            SentencePointer &PreviousSentence = m_SentenceStack.Pop();
            PreviousSentence = m_SentenceStack.Pop();

            //--- Reset the current frag and the current text pointer position
            m_pCurrFrag = PreviousSentence.pSentenceFrag;
            m_pNextChar = PreviousSentence.pSentenceStart;
            m_pEndChar  = m_pCurrFrag->pTextStart + m_pCurrFrag->ulTextLen;

            hr = GetNextSentence( ppSentItemEnum );
            if( hr == S_OK ) 
            {
                //--- Update Sentence Pointer List
                hr = m_SentenceStack.Push( PreviousSentence );
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
} /* CStdSentEnum::Previous */

/*****************************************************************************
* SkipWhiteSpaceAndTags *
*-----------------------*
*   Skips m_pNextChar ahead to the next non-whitespace character (skipping
*   ahead in the frag list, if necessary) or sets it to NULL if it hits the 
*   end of the frag list text...
********************************************************************* AH ****/
HRESULT CStdSentEnum::SkipWhiteSpaceAndTags( const WCHAR*& pStartChar, const WCHAR*& pEndChar, 
                                             const SPVTEXTFRAG*& pCurrFrag, CSentItemMemory& MemoryManager, 
                                             BOOL fAddToItemList, CItemList* pItemList )
{
    SPDBG_ASSERT( pStartChar <= pEndChar );
    HRESULT hr = S_OK;

    while ( pStartChar &&
            ( IsSpace( *pStartChar ) ||
              pStartChar == pEndChar ) )
    {
        //--- Skip whitespace
        while ( pStartChar < pEndChar &&
                IsSpace( *pStartChar ) ) 
        {
            ++pStartChar;
        }
        //--- Skip to next spoken frag, if necessary
        if ( pStartChar == pEndChar )
        {
            pCurrFrag = pCurrFrag->pNext;
            while ( pCurrFrag &&
                    pCurrFrag->State.eAction != SPVA_Speak &&
                    pCurrFrag->State.eAction != SPVA_SpellOut )
            {
                pStartChar = (WCHAR*) pCurrFrag->pTextStart;
                pEndChar   = (WCHAR*) pStartChar + pCurrFrag->ulTextLen;
                //--- Add non-spoken fragments, if fAddToItemList is true.
                if ( fAddToItemList )
                {
                    CSentItem Item;
                    Item.pItemSrcText    = pCurrFrag->pTextStart;
                    Item.ulItemSrcLen    = pCurrFrag->ulTextLen;
                    Item.ulItemSrcOffset = pCurrFrag->ulTextSrcOffset;
                    Item.ulNumWords      = 1;
                    Item.Words           = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( Item.Words, sizeof(TTSWord) );
                        Item.Words[0].pXmlState         = &pCurrFrag->State;
                        Item.Words[0].eWordPartOfSpeech = MS_Unknown;
                        Item.eItemPartOfSpeech          = MS_Unknown;
                        Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            Item.pItemInfo->Type = eWORDLIST_IS_VALID;
                            pItemList->AddTail( Item );
                        }
                    }
                }
                pCurrFrag = pCurrFrag->pNext;
            }
            if ( !pCurrFrag )
            {
                pStartChar = NULL;
                pEndChar   = NULL;
            }
            else
            {
                pStartChar  = (WCHAR*) pCurrFrag->pTextStart;
                pEndChar    = (WCHAR*) pStartChar + pCurrFrag->ulTextLen;
            }
        }
    }
    return hr;
} /* SkipWhiteSpaceAndTags */

/*****************************************************************************
* FindTokenEnd *
*--------------*
*   Returns the position of the first whitespace character after pStartChar,
*   or pEndChar, or the character after SP_MAX_WORD_LENGTH, whichever comes first.
********************************************************************* AH ****/
const WCHAR* CStdSentEnum::FindTokenEnd( const WCHAR* pStartChar, const WCHAR* pEndChar )
{
    SPDBG_ASSERT( pStartChar < pEndChar );
    ULONG ulNumChars = 1;
    const WCHAR *pPos = pStartChar;

    while ( pPos              &&
            pPos < pEndChar   &&
            !IsSpace( *pPos ) &&
            ulNumChars < SP_MAX_WORD_LENGTH )
    {
        pPos++;
        ulNumChars++;
    }

    return pPos;
} /* FindTokenEnd */

/*****************************************************************************
* CStdSentEnum::AddNextSentItem *
*-------------------------------*
*   Locates the next sentence item in the stream and adds it to the list.
*   Returns true if the last item added is the end of the sentence.  
********************************************************************* AH ****/
HRESULT CStdSentEnum::AddNextSentItem( CItemList& ItemList, CSentItemMemory& MemoryManager, BOOL* pfIsEOS )
{
    SPDBG_ASSERT( m_pNextChar && pfIsEOS );
    HRESULT hr = S_OK;
    BOOL fHitPauseItem = false;
    CSentItem Item;
    ULONG ulTrailItems = 0;
    TTSItemType ItemType = eUNMATCHED;
    *pfIsEOS = false;

    //--- Skip initial whitespace characters and XML markup (by skipping ahead in the frag list).
    hr = SkipWhiteSpaceAndTags( m_pNextChar, m_pEndChar, m_pCurrFrag, MemoryManager, true, &ItemList );

    //--- This will happen when we hit the end of the frag list
    if ( !m_pNextChar )
    {
        return S_OK;
    }

    //--- Find end of the next token (next whitespace character, hyphen, or m_pEndChar).
    m_pEndOfCurrToken = FindTokenEnd( m_pNextChar, m_pEndChar );

    //--- Get Primary Insert Position
    SPLISTPOS ItemPos = ItemList.AddTail( Item );

    //--- Try looking up this token in the User Lexicon...
    WCHAR Temp = *( (WCHAR*) m_pEndOfCurrToken );
    *( (WCHAR*) m_pEndOfCurrToken ) = 0;
    SPWORDPRONUNCIATIONLIST SPList;
    ZeroMemory( &SPList, sizeof( SPWORDPRONUNCIATIONLIST ) );

    hr = m_cpAggregateLexicon->GetPronunciations( m_pNextChar, 1033, eLEXTYPE_USER, &SPList );
    if( SPList.pvBuffer )
    {
        ::CoTaskMemFree( SPList.pvBuffer );
    }
    
    *( (WCHAR*) m_pEndOfCurrToken ) = Temp;

    if ( SUCCEEDED( hr ) )
    {
        Item.eItemPartOfSpeech = MS_Unknown;
        Item.pItemSrcText      = m_pNextChar;
        Item.ulItemSrcLen      = (ULONG) ( m_pEndOfCurrToken - m_pNextChar );
        Item.ulItemSrcOffset   = m_pCurrFrag->ulTextSrcOffset +
                                 (ULONG)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords        = 1;
        Item.Words              = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState         = &m_pCurrFrag->State;
            Item.Words[0].pWordText         = m_pNextChar;
            Item.Words[0].ulWordLen         = Item.ulItemSrcLen;
            Item.Words[0].pLemma            = Item.Words[0].pWordText;
            Item.Words[0].ulLemmaLen        = Item.Words[0].ulWordLen;
            Item.Words[0].eWordPartOfSpeech = MS_Unknown;
            Item.eItemPartOfSpeech          = MS_Unknown;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo*), &hr );
            if ( SUCCEEDED( hr ) )
            {
                Item.pItemInfo->Type = eALPHA_WORD;
                ItemList.SetAt( ItemPos, Item );
            }
        }
        m_pNextChar = m_pEndOfCurrToken;
    }
    //--- Not in the user lex - itemize, normalize, etc.
    else if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = S_OK;

        //--- convert text from Unicode to Ascii
        hr = DoUnicodeToAsciiMap( m_pNextChar, (ULONG)( m_pEndOfCurrToken - m_pNextChar ), (WCHAR*)m_pNextChar );

        if ( SUCCEEDED( hr ) )
        {
            //--- Find end of the next token (next whitespace character, hyphen, or m_pEndChar) 
            //---   AGAIN, since the mapping may have introduced new whitespace characters...
            m_pEndOfCurrToken = FindTokenEnd( m_pNextChar, m_pEndChar );

            //--- Insert lead items (group beginnings, quotation marks)
            while ( m_pNextChar < m_pEndOfCurrToken &&
                    ( ( ItemType = IsGroupBeginning( *m_pNextChar ) )    != eUNMATCHED ||
                      ( ItemType = IsQuotationMark( *m_pNextChar ) )     != eUNMATCHED ) )
            {
                CSentItem LeadItem;
                LeadItem.pItemSrcText       = m_pNextChar;
                LeadItem.ulItemSrcLen       = 1;
                LeadItem.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                              (ULONG)(( m_pNextChar - m_pCurrFrag->pTextStart ));
                LeadItem.ulNumWords         = 1;
                LeadItem.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( LeadItem.Words, sizeof(TTSWord) );
                    LeadItem.Words[0].pXmlState         = &m_pCurrFrag->State;
                    LeadItem.Words[0].eWordPartOfSpeech = ConvertItemTypeToPartOfSp( ItemType );
                    LeadItem.eItemPartOfSpeech          = ConvertItemTypeToPartOfSp( ItemType );
                    LeadItem.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        LeadItem.pItemInfo->Type = ItemType;
                        if ( m_dwSpeakFlags & SPF_NLP_SPEAK_PUNC ||
                             m_pCurrFrag->State.eAction == SPVA_SpellOut )
                        {
                            CWordList TempWordList;
                            ExpandPunctuation( TempWordList, *m_pNextChar );
                            hr = SetWordList( LeadItem, TempWordList, MemoryManager );
                            LeadItem.pItemInfo->Type = eUNMATCHED;
                        }
                        ItemList.InsertBefore( ItemPos, LeadItem );
                        m_pNextChar++;
                    }
                }
                ItemType = eUNMATCHED;
            }

            //--- Insert trail items (group endings, quotation marks, misc. punctuation, EOS Items)
            m_pEndOfCurrItem = m_pEndOfCurrToken;
            BOOL fAddTrailItem = true;
            BOOL fAbbreviation = false;
            while ( (m_pEndOfCurrItem - 1) >= m_pNextChar &&
                    fAddTrailItem )
            {
                fAddTrailItem = false;
                fAbbreviation = false;

                //--- Check group endings, quotation marks, misc. punctuation.
                if ( ( ItemType = IsGroupEnding( *(m_pEndOfCurrItem - 1) ) )       != eUNMATCHED ||
                     ( ItemType = IsQuotationMark( *(m_pEndOfCurrItem - 1) ) )     != eUNMATCHED ||
                     ( ItemType = IsMiscPunctuation( *(m_pEndOfCurrItem - 1) ) )   != eUNMATCHED )
                {
                    fAddTrailItem = true;
                    if ( ItemType == eCOMMA ||
                         ItemType == eCOLON ||
                         ItemType == eSEMICOLON )
                    {
                        fHitPauseItem = true;
                    }
                }
                //--- Check EOS Items, except periods preceded by alpha characters
                else if ( ( ItemType = IsEOSItem( *(m_pEndOfCurrItem - 1) ) ) != eUNMATCHED &&
                          ! ( ItemType == ePERIOD                     &&
                              ( m_pEndOfCurrItem - 2 >= m_pNextChar ) &&
                              ( iswalpha( *(m_pEndOfCurrItem - 2) ) ) ) )
                {
                    //--- Check for ellipses
                    if ( ItemType == ePERIOD )
                    {
                        if ( m_pEndOfCurrItem == m_pEndOfCurrToken                              &&
                             ( m_pEndOfCurrItem - 2 >= m_pNextChar )                            &&
                             ( ( ItemType = IsEOSItem( *(m_pEndOfCurrItem - 2) ) ) == ePERIOD ) &&
                             ( m_pEndOfCurrItem - 3 == m_pNextChar )                            &&
                             ( ( ItemType = IsEOSItem( *(m_pEndOfCurrItem - 3) ) ) == ePERIOD ) )
                        {
                            fAddTrailItem = true;
                            ItemType      = eELLIPSIS;
                        }
                        else
                        {
                            ItemType      = ePERIOD;
                            fAddTrailItem = true;
                            *pfIsEOS      = true;
                        }
                    }
                    else
                    {
                        fAddTrailItem   = true;
                        *pfIsEOS        = true;
                    }
                }
                //--- Period preceded by alpha character - determine whether it is EOS.
                else if ( ItemType == ePERIOD )
                {
                    //--- Is it an Initialism ( e.g. "e.g." )?  If so, only EOS if the next
                    //---   word is in the common first words list...
                    hr = IsInitialism( ItemList, ItemPos, MemoryManager, pfIsEOS );
                    if ( SUCCEEDED( hr ) )
                    {
                        if ( *pfIsEOS )
                        {
                            //--- Did we see a pause item earlier?  In that case, we should NOT listen to this 
                            //--- IsEOS decision from IsInitialism...
                            if ( fHitPauseItem )
                            {
                                *pfIsEOS = false;
                            }
                            else
                            {
                                fAddTrailItem = true;
                                fAbbreviation = true;
                            }
                        }
                    }
                    else if ( hr == E_INVALIDARG )
                    {
                        const WCHAR temp = (WCHAR) *( m_pEndOfCurrItem - 1 );
                        *( (WCHAR*) ( m_pEndOfCurrItem - 1 ) ) = 0;

                        const AbbrevRecord* pAbbrevRecord =
                            (AbbrevRecord*) bsearch( (void*) m_pNextChar, (void*) g_AbbreviationTable,
                                                     sp_countof( g_AbbreviationTable ), sizeof( AbbrevRecord ),
                                                     CompareStringAndAbbrevRecord );

                        *( (WCHAR*) ( m_pEndOfCurrItem - 1 ) ) = temp;

                        if ( pAbbrevRecord )
                        {
                            //--- Matched an abbreviation
                            if ( pAbbrevRecord->iSentBreakDisambig < 0 )
                            {
                                //--- Abbreviation will never end a sentence - just insert into ItemList
                                *pfIsEOS        = false;
                                hr              = S_OK;

                                Item.pItemSrcText       = m_pNextChar;
                                Item.ulItemSrcLen       = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
                                Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                                          (ULONG)( m_pNextChar - m_pCurrFrag->pTextStart );
                                Item.ulNumWords         = 1;
                                Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof( TTSWord ), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    ZeroMemory( Item.Words, sizeof( TTSWord ) );
                                    Item.Words[0].pXmlState  = &m_pCurrFrag->State;
                                    Item.Words[0].pWordText  = Item.pItemSrcText;
                                    Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
                                    Item.Words[0].pLemma     = Item.pItemSrcText;
                                    Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
                                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
                                    if ( SUCCEEDED( hr ) )
                                    {
                                        if ( NeedsToBeNormalized( pAbbrevRecord ) )
                                        {
                                            Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                                        }
                                        else
                                        {
                                            Item.pItemInfo->Type = eABBREVIATION;
                                        }
                                        ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbrevRecord;
                                        ItemList.SetAt( ItemPos, Item );
                                    }
                                }
                            }
                            else
                            {
                                //--- Need to do some disambiguation to determine whether,
                                //---   a) this is indeed an abbreviation (e.g. "Ed.")
                                //---   b) the period doubles as EOS
                                hr = ( this->*g_SentBreakDisambigTable[pAbbrevRecord->iSentBreakDisambig] ) 
                                                ( pAbbrevRecord, ItemList, ItemPos, MemoryManager, pfIsEOS );
                                if ( SUCCEEDED( hr ) )
                                {
                                    if ( *pfIsEOS )
                                    {
                                        if ( fHitPauseItem )
                                        {
                                            *pfIsEOS = false;
                                        }
                                        else
                                        {
                                            fAddTrailItem = true;
                                            fAbbreviation = true;
                                        }
                                    }
                                }
                            }
                        }

                        if ( hr == E_INVALIDARG )
                        {
                            //--- Just check for periods internal to the item - this catches stuff like
                            //---   10:30p.m.
                            for ( const WCHAR* pIterator = m_pNextChar; pIterator < m_pEndOfCurrItem - 1; pIterator++ )
                            {
                                if ( *pIterator == L'.' )
                                {
                                    *pfIsEOS = false;
                                    break;
                                }
                            }
                            //--- If all previous checks have failed, it is EOS.
                            if ( pIterator == ( m_pEndOfCurrItem - 1 ) &&
                                 !fHitPauseItem )
                            {
                                hr              = S_OK;
                                fAddTrailItem   = true;
                                *pfIsEOS        = true;
                            }
                            else if ( hr == E_INVALIDARG )
                            {
                                hr = S_OK;
                            }
                        }
                    }
                }

                //--- Add trail item.
                if ( fAddTrailItem )
                {
                    ulTrailItems++;
                    CSentItem TrailItem;
                    if ( ItemType == eELLIPSIS )
                    {
                        TrailItem.pItemSrcText      = m_pEndOfCurrItem - 3;
                        TrailItem.ulItemSrcLen      = 3;
                        TrailItem.ulItemSrcOffset   = m_pCurrFrag->ulTextSrcOffset +
                                                      (ULONG)( m_pEndOfCurrItem - m_pCurrFrag->pTextStart - 3 );
                    }
                    else
                    {
                        TrailItem.pItemSrcText       = m_pEndOfCurrItem - 1;
                        TrailItem.ulItemSrcLen       = 1;
                        TrailItem.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                                       (ULONG)( m_pEndOfCurrItem - m_pCurrFrag->pTextStart - 1 );
                    }
                    TrailItem.ulNumWords         = 1;
                    TrailItem.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( TrailItem.Words, sizeof(TTSWord) );
                        TrailItem.Words[0].pXmlState         = &m_pCurrFrag->State;
                        TrailItem.Words[0].eWordPartOfSpeech = ConvertItemTypeToPartOfSp( ItemType );
                        TrailItem.eItemPartOfSpeech          = ConvertItemTypeToPartOfSp( ItemType );
                        TrailItem.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            TrailItem.pItemInfo->Type = ItemType;
                            if ( m_dwSpeakFlags & SPF_NLP_SPEAK_PUNC ||
                                 ( m_pCurrFrag->State.eAction == SPVA_SpellOut &&
                                   !fAbbreviation ) )
                            {
                                CWordList TempWordList;
                                ExpandPunctuation( TempWordList, *(m_pEndOfCurrItem - 1) );
                                hr = SetWordList( TrailItem, TempWordList, MemoryManager );
                                TrailItem.pItemInfo->Type = eUNMATCHED;
                            }
                            ItemList.InsertAfter( ItemPos, TrailItem );
                            if ( !fAbbreviation )
                            {
                                if ( ItemType == eELLIPSIS )
                                {
                                    m_pEndOfCurrItem -= 3;
                                    ulTrailItems = 3;
                                }
                                else
                                {
                                    m_pEndOfCurrItem--;
                                }
                            }
                        }
                    }
                    ItemType = eUNMATCHED;
                    if ( fAbbreviation )
                    {
                        break;
                    }
                }
            }

            //--- Do Main Item Insertion
            if ( SUCCEEDED( hr ) &&
                 m_pNextChar == m_pEndOfCurrItem )
            {
                ItemList.RemoveAt( ItemPos );
            }
            else if ( SUCCEEDED( hr ) )
            {
                hr = Normalize( ItemList, ItemPos, MemoryManager );
            }

            //--- Advance m_pNextChar to m_pEndOfCurrItem + once for each trail item matched.
            if ( SUCCEEDED( hr ) )
            {
                if ( !fAbbreviation &&
                     m_pEndOfCurrItem + ulTrailItems != m_pEndOfCurrToken )
                {
                    //--- Multi-token item matched in Normalize()... Remove all previously matched trail items,
                    //--- as they were matched as part of the larger item...
                    m_pNextChar = m_pEndOfCurrItem;
                    Item = ItemList.GetNext( ItemPos );
                    while ( ItemPos )
                    {
                        SPLISTPOS RemovePos = ItemPos;
                        Item = ItemList.GetNext( ItemPos );
                        ItemList.RemoveAt( RemovePos );
                    }                 
                }
                else
                {
                    m_pNextChar = m_pEndOfCurrToken;
                }
            }
        }
    }

    return hr;
} /* CStdSentEnum::AddNextSentItem */

/*****************************************************************************
* CStdSentEnum::GetNextSentence *
*-------------------------------*
*   This method is used to create a sentence item enumerator and populate it
*   with items. If the SPF_NLP_PASSTHROUGH flag is set, each item is the block
*   of text between XML states. If the SPF_NLP_PASSTHROUGH flag is not set, each
*   item is an individual word that is looked up in the current lexicon(s).
********************************************************************* EDC ***/
HRESULT CStdSentEnum::GetNextSentence( IEnumSENTITEM** ppItemEnum )
{
    HRESULT hr = S_OK;
    ULONG ulNumItems = 0;
    const SPVTEXTFRAG* pPrevFrag = m_pCurrFrag;

    //--- Is there any work to do
    if( m_pCurrFrag == NULL ) return S_FALSE;

    //--- Create sentence enum
    CComObject<CSentItemEnum> *pItemEnum;
    hr = CComObject<CSentItemEnum>::CreateInstance( &pItemEnum );

    if( SUCCEEDED( hr ) )
    {
        pItemEnum->AddRef();
        pItemEnum->_SetOwner( GetControllingUnknown() );
        *ppItemEnum = pItemEnum;
    }

    if( SUCCEEDED( hr ) )
    {
        BOOL fSentDone = false;
        BOOL fGoToNextFrag = false;
        CItemList& ItemList = pItemEnum->_GetList();
        CSentItemMemory& MemoryManager = pItemEnum->_GetMemoryManager();

        while( SUCCEEDED(hr) && m_pCurrFrag && !fSentDone && ulNumItems < 50 )
        {
            ulNumItems++;
            if( m_pCurrFrag->State.eAction == SPVA_Speak ||
                m_pCurrFrag->State.eAction == SPVA_SpellOut )
            {
                hr = AddNextSentItem( ItemList, MemoryManager, &fSentDone );

                //--- Advance fragment?
                if( SUCCEEDED( hr ) && 
                    m_pNextChar     &&
                    m_pEndChar      &&
                    m_pNextChar >= m_pEndChar )
                {
                    fGoToNextFrag = true;
                }
            }
            else
            {
                //--- Add non spoken fragments
                CSentItem Item;
                Item.pItemSrcText    = m_pCurrFrag->pTextStart;
                Item.ulItemSrcLen    = m_pCurrFrag->ulTextLen;
                Item.ulItemSrcOffset = m_pCurrFrag->ulTextSrcOffset;
                Item.ulNumWords      = 1;
                Item.Words           = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( Item.Words, sizeof(TTSWord) );
                    Item.Words[0].pXmlState         = &m_pCurrFrag->State;
                    Item.Words[0].eWordPartOfSpeech = MS_Unknown;
                    Item.eItemPartOfSpeech          = MS_Unknown;
                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo->Type = eWORDLIST_IS_VALID;
                        ItemList.AddTail( Item );
                    }
                }
                fGoToNextFrag = true;
            }

            if( SUCCEEDED( hr ) && 
                fGoToNextFrag )
            {
                fGoToNextFrag = false;
                pPrevFrag = m_pCurrFrag;
                m_pCurrFrag = m_pCurrFrag->pNext;
                if( m_pCurrFrag )
                {
                    m_pNextChar = m_pCurrFrag->pTextStart;
                    m_pEndChar  = m_pNextChar + m_pCurrFrag->ulTextLen;
                }
                else
                {
                    m_pNextChar = NULL;
                    m_pEndChar  = NULL;
                }
            }
        } // end while

        //--- If no period has been added, add one now - this will happen if the text 
        //--- is ONLY XML markup...
        if ( SUCCEEDED(hr) && !fSentDone )
        {
            CSentItem EOSItem;
            EOSItem.pItemSrcText    = g_period.pStr;
            EOSItem.ulItemSrcLen    = g_period.Len;
            EOSItem.ulItemSrcOffset = pPrevFrag->ulTextSrcOffset + pPrevFrag->ulTextLen;
            EOSItem.ulNumWords      = 1;
            EOSItem.Words           = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( EOSItem.Words, sizeof(TTSWord) );
                EOSItem.Words[0].pXmlState          = &g_DefaultXMLState;
                EOSItem.Words[0].eWordPartOfSpeech  = MS_EOSItem;
                EOSItem.eItemPartOfSpeech           = MS_EOSItem;
                EOSItem.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    EOSItem.pItemInfo->Type = ePERIOD;
                    ItemList.AddTail( EOSItem );
                }
            }
        }

        //--- Output debugging information, if sentence breaks are desired
        TTSDBG_LOGITEMLIST( pItemEnum->_GetList(), STREAM_SENTENCEBREAKS );

        if( SUCCEEDED( hr ) )
        {
            hr = DetermineProns( pItemEnum->_GetList(), pItemEnum->_GetMemoryManager() );
        }

        pItemEnum->Reset();

        //--- Output debugging information, if POS or Pronunciations are desired
        TTSDBG_LOGITEMLIST( pItemEnum->_GetList(), STREAM_LEXLOOKUP );

    }
    return hr;
} /* CStdSentEnum::GetNextSentence */

/*****************************************************************************
* CStdSentEnum::Reset *
*---------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CStdSentEnum::Reset( void )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CStdSentEnum::Reset" );
    HRESULT hr = S_OK;
    m_pCurrFrag = m_pTextFragList;
    m_pNextChar = m_pCurrFrag->pTextStart;
    m_pEndChar  = m_pNextChar + m_pCurrFrag->ulTextLen;
    m_SentenceStack.Reset();
    return hr;
} /* CStdSentEnum::Reset */

/*****************************************************************************
* CStdSentEnum::InitAggregateLexicon *
*------------------------------------*
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::InitAggregateLexicon( void )
{
    return m_cpAggregateLexicon.CoCreateInstance(CLSID_SpLexicon);
}

/*****************************************************************************
* CStdSentEnum::AddLexiconToAggregate *
*-------------------------------------*
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::AddLexiconToAggregate( ISpLexicon *pAddLexicon, DWORD dwFlags )
{
    return m_cpAggregateLexicon->AddLexicon( pAddLexicon, dwFlags );
}

/*****************************************************************************
* CStdSentEnum::InitMorphLexicon *
*--------------------------------*
*
********************************************************************* AH ****/
HRESULT CStdSentEnum::InitMorphLexicon( void )
{
    HRESULT hr = S_OK;
    
    m_pMorphLexicon = new CSMorph( m_cpAggregateLexicon, &hr );

    return hr;
}

//
//=== CSentItemEnum =========================================================
//

/*****************************************************************************
* CSentItemEnum::Next *
*---------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CSentItemEnum::
    Next( TTSSentItem *pItemEnum )
{
    SPDBG_FUNC( "CSentItemEnum::Next" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SPIsBadWritePtr( pItemEnum, sizeof( TTSSentItem ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if ( m_ListPos )
        {
            *pItemEnum = m_ItemList.GetNext( m_ListPos );
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;
} /* CSentItemEnum::Next */

/*****************************************************************************
* CSentItemEnum::Reset *
*----------------------*
*
********************************************************************* EDC ***/
STDMETHODIMP CSentItemEnum::Reset( void )
{
    SPDBG_FUNC( "CSentItemEnum::Reset" );
    HRESULT hr = S_OK;
    m_ListPos = m_ItemList.GetHeadPosition();
    return hr;
} /* CSentItemEnum::Reset */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\tts\msttsdrv\engine\ttsengine.cpp ===
/*******************************************************************************
* TTSEngine.cpp *
*---------------*
*   Description:
*       This module is the main implementation file for the CTTSEngine class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include <stdio.h>
#include "TTSEngine.h"
#include "stdsentenum.h"
#include "VoiceDataObj.h"
#include "commonlx.h"

/*****************************************************************************
* CTTSEngine::FinalConstruct *
*----------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CTTSEngine::FinalConstruct()
{
    SPDBG_FUNC( "CTTSEngine::FinalConstruct" );
    HRESULT hr = S_OK;

    return hr;
} /* CTTSEngine::FinalConstruct */

/*****************************************************************************
* CTTSEngine::FinalRelease *
*--------------------------*
*   Description:
*       destructor
********************************************************************* EDC ***/
void CTTSEngine::FinalRelease()
{
    SPDBG_FUNC( "CTTSEngine::FinalRelease" );
} /* CTTSEngine::FinalRelease */

/*****************************************************************************
* CTTSEngine::VoiceInit *
*-----------------------*
*   Description:
*       This method is called by the voice data object during construction
*   to give the TTS driver object access to the voice unit data.
******************************************************************* PACOG ***/
STDMETHODIMP CTTSEngine::VoiceInit( IMSVoiceData* pVoiceData )
{
    SPDBG_FUNC( "CTTSEngine::VoiceInit" );
	HRESULT	hr = S_OK;

    //--- Create sentence enumerator and initialize
    CComObject<CStdSentEnum> *pSentEnum;
    hr = CComObject<CStdSentEnum>::CreateInstance( &pSentEnum );

    //--- Create aggregate lexicon
    if ( SUCCEEDED( hr ) )
    {
        hr = pSentEnum->InitAggregateLexicon();
    }

    //--- Get our voice token
    CComPtr<ISpObjectToken> cpVoiceToken;
    if (SUCCEEDED(hr))
    {
        cpVoiceToken = ((CVoiceDataObj*)pVoiceData)->GetVoiceToken();
    }

    //--- Create vendor lexicon and add to aggregate
    if (SUCCEEDED(hr))
    {
        CComPtr<ISpObjectToken> cpToken;
        hr = SpGetSubTokenFromToken(cpVoiceToken, L"Lex", &cpToken);

        CComPtr<ISpLexicon> cpCompressedLexicon;
        if (SUCCEEDED(hr))
        {
            hr = SpCreateObjectFromToken(cpToken, &cpCompressedLexicon);
        }

        if (SUCCEEDED(hr))
        {
            hr = pSentEnum->AddLexiconToAggregate(cpCompressedLexicon, eLEXTYPE_PRIVATE1);
        }
    }
    //--- Create LTS lexicon and add to aggregate
    if (SUCCEEDED(hr))
    {
        CComPtr<ISpObjectToken> cpToken;
        hr = SpGetSubTokenFromToken(cpVoiceToken, L"Lts", &cpToken);

        CComPtr<ISpLexicon> cpLTSLexicon;
        if (SUCCEEDED(hr))
        {
            hr = SpCreateObjectFromToken(cpToken, &cpLTSLexicon);
        }

        if (SUCCEEDED(hr))
        {
            hr = pSentEnum->AddLexiconToAggregate(cpLTSLexicon, eLEXTYPE_PRIVATE2);
        }
    }

    //--- Create morphology lexicon
    if ( SUCCEEDED( hr ) )
    {
        hr = pSentEnum->InitMorphLexicon();
    }

    //--- Set member sentence enumerator
    if ( SUCCEEDED( hr ) )
    {
        m_cpSentEnum = pSentEnum;
    }

    //--- Save voice data interface, do not AddRef or it will cause circular reference
    if( SUCCEEDED( hr ) )
    {
        m_pVoiceDataObj = pVoiceData;
	    hr = InitDriver();
    }

	return hr;
} /* CTTSEngine::VoiceInit */

/*****************************************************************************
* CTTSEngine::Speak *
*-------------------*
*   Description:
*       This method is supposed to speak the text observing the associated
*   XML state.
********************************************************************* EDC ***/
STDMETHODIMP CTTSEngine::
    Speak( DWORD dwSpeakFlags, REFGUID rguidFormatId,
           const WAVEFORMATEX * /* pWaveFormatEx ignored */,
           const SPVTEXTFRAG* pTextFragList,
           ISpTTSEngineSite* pOutputSite )
{
    SPDBG_FUNC( "CTTSEngine::Speak" );
    HRESULT hr = S_OK;

    //--- Early exit?
    if( ( rguidFormatId != SPDFID_WaveFormatEx && rguidFormatId != SPDFID_Text ) || SP_IS_BAD_INTERFACE_PTR( pOutputSite ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Debug Macro - open file for debugging output
        TTSDBG_OPENFILE;

        //--- Initialize sentence enumerator
        hr = m_cpSentEnum->SetFragList( pTextFragList, dwSpeakFlags );

        if( SUCCEEDED( hr ) )
        {

            //	The following code is here just for testing.
            //  It should be removed once all the tools accept the
            //  new way of outputing debug info.
            if( rguidFormatId == SPDFID_Text )
            {
                //--- Enumerate and write out all sentence items.
                IEnumSENTITEM *pItemEnum;
                TTSSentItem Item;

                //--- Write unicode signature
                static const WCHAR Signature = 0xFEFF;
                hr = pOutputSite->Write( &Signature, sizeof(Signature), NULL );

                while( (hr = m_cpSentEnum->Next( &pItemEnum) ) == S_OK )
                {
                    while( (hr = pItemEnum->Next( &Item )) == S_OK )
                    {
                        // Is there a valid normalized-word-list?
                        if ( Item.pItemInfo->Type & eWORDLIST_IS_VALID )
                        {
                            for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                            {
                                if ( Item.Words[i].pXmlState->eAction == SPVA_Speak ||
                                     Item.Words[i].pXmlState->eAction == SPVA_SpellOut )
                                {
                                    ULONG cb = Item.Words[i].ulWordLen * sizeof( WCHAR );
                                    hr = pOutputSite->Write( Item.Words[i].pWordText, cb, NULL );
                                    if( hr == S_OK ) 
                                    {
                                        //--- Insert space between items
                                        hr = pOutputSite->Write( L" ", sizeof( WCHAR ), NULL );
                                    }
                                }
                            }
                        }
                        else // no word list - just write the original text.
                        {
                            ULONG cb = Item.ulItemSrcLen * sizeof( WCHAR );
                            hr = pOutputSite->Write( Item.pItemSrcText, cb, NULL ); 
                            if ( SUCCEEDED(hr) )
                            {
                                //--- Insert space between items
                                hr = pOutputSite->Write( L" ", sizeof( WCHAR ), NULL );
                            }
                        }
                    }
                    pItemEnum->Release();

                    //--- Insert mark between sentences
                    if( SUCCEEDED( hr ) ) 
                    {
                        static const WCHAR CRLF[2] = { 0x000D, 0x000A };
                        hr = pOutputSite->Write( CRLF, 2*sizeof(WCHAR), NULL );
                    }
                }
                static const WCHAR ENDL = 0x0000;
                hr = pOutputSite->Write( &ENDL, sizeof(WCHAR), NULL );

            }
            else 
            {
                //--- Render the text
                m_FEObj.PrepareSpeech( m_cpSentEnum, pOutputSite );
                m_BEObj.PrepareSpeech( pOutputSite );

                do
      