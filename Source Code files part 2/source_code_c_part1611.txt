/
// Call:        GetCallbackPrivilegeFromRequest
//
// Returns:     NO_ERROR    - success
//
// Description: Will parse the callback request from the server and translate
//              the PPP callback privilege to what RAS understands.
//
DWORD
GetCallbackPrivilegeFromRequest(
    IN     PPP_CONFIG * pRequest,
    IN OUT DWORD *      lpdwCallbackPriv
)
{
    PPP_OPTION * pOption         = (PPP_OPTION *)(pRequest->Data);
    DWORD        dwRequestLength = WireToHostFormat16( pRequest->Length )
                                   - PPP_CONFIG_HDR_LEN;

    *lpdwCallbackPriv = 0;

    //
    // Walk the options
    //

    while( dwRequestLength > 0 )
    {
        if ( dwRequestLength < PPP_OPTION_HDR_LEN )
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        switch( pOption->Type )
        {
        case CBCP_TYPE_NO_CALLBACK:

            *lpdwCallbackPriv |= RASPRIV_NoCallback;
            break;

        case CBCP_TYPE_CALLEE_SET:

            *lpdwCallbackPriv |= RASPRIV_AdminSetCallback;
            break;

        case CBCP_TYPE_CALLER_SET:

            *lpdwCallbackPriv |= RASPRIV_CallerSetCallback;
            break;

        default:

            //
            // Ignore anything else.
            //

            break;
        }

        dwRequestLength = dwRequestLength - pOption->Length;
        pOption = (PPP_OPTION *)(((BYTE *)pOption) + pOption->Length);
    }

    //
    // We accept Callback privleges in the following order.
    // 1) Caller settable.
    // 2) Admin settable
    // 3) No callback
    //

    if ( *lpdwCallbackPriv & RASPRIV_CallerSetCallback )
    {
        *lpdwCallbackPriv = RASPRIV_CallerSetCallback;
    }
    else if ( *lpdwCallbackPriv & RASPRIV_AdminSetCallback )
    {
        *lpdwCallbackPriv = RASPRIV_AdminSetCallback;
    }
    else if ( *lpdwCallbackPriv & RASPRIV_NoCallback )
    {
        *lpdwCallbackPriv = RASPRIV_NoCallback;
    }
    else
    {
        //
        // If we could not translate to any RAS callback privlege we simply drop
        // this packet.
        //

        return( ERROR_PPP_INVALID_PACKET );
    }

    return( NO_ERROR );
}

//**
//
// Call:        MakeResponse
//
// Returns:     NO_ERROR    - success
//
// Description:
//
DWORD
MakeResponse(
    IN DWORD            fCallbackPrivilege,
    IN LPSTR            szCallbackNumber,
    IN DWORD            CallbackDelay,
    IN PPP_CONFIG *     pRequest,
    IN OUT PPP_CONFIG * pSendBuf,
    IN DWORD            cbSendBuf
)
{
    PPP_OPTION * pOption;
    DWORD        dwLength;

    if ( cbSendBuf < PPP_CONFIG_HDR_LEN )
    {
        return( ERROR_BUFFER_TOO_SMALL );
    }

    pOption = (PPP_OPTION *)(pSendBuf->Data);

    pSendBuf->Code = CBCP_CODE_Response;
    pSendBuf->Id   = pRequest->Id;

    if ( fCallbackPrivilege & RASPRIV_NoCallback )
    {
        dwLength = PPP_OPTION_HDR_LEN;

        if ( cbSendBuf < dwLength )
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        pOption->Type   = CBCP_TYPE_NO_CALLBACK;
        pOption->Length = (BYTE)dwLength;

    }
    else if ( fCallbackPrivilege & RASPRIV_CallerSetCallback )
    {
        dwLength = (DWORD)(PPP_OPTION_HDR_LEN + 3 + strlen( szCallbackNumber ));

        if ( cbSendBuf < dwLength )
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        pOption->Type   = CBCP_TYPE_CALLER_SET;
        pOption->Length = (BYTE)dwLength;

        *(pOption->Data)   = (BYTE)CallbackDelay;       // Callback Delay
        *(pOption->Data+1) = (BYTE)CBCP_PSTN_NUMBER;    // Number Type
        strcpy( pOption->Data+2, szCallbackNumber );    // Callback Address
    }
    else if ( fCallbackPrivilege & RASPRIV_AdminSetCallback )
    {
        dwLength = PPP_OPTION_HDR_LEN + 1;

        if ( cbSendBuf < dwLength )
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        pOption->Type   = CBCP_TYPE_CALLEE_SET;
        pOption->Length = (BYTE)dwLength;

        *(pOption->Data)= (BYTE)CallbackDelay;          // Callback Delay
    }
    else
    {
        return( ERROR_INVALID_PARAMETER );
    }

    dwLength += PPP_CONFIG_HDR_LEN;

    HostToWireFormat16( (WORD)dwLength, (PBYTE)(pSendBuf->Length) );

    return( NO_ERROR );
}

//**
//
// Call:        ValidateResponse
//
// Returns:     NO_ERROR                    - success
//              ERROR_PPP_INVALID_PACKET    - failure
//
// Description: Will validate the reponse from the client. If the response
//              is valid, then the callback information is returned in the
//              CbCPWorkBuf.
//
DWORD
ValidateResponse(
    IN PPP_CONFIG *      pReceiveBuf,
    IN CBCP_WORKBUFFER * pWorkBuf
)
{
    PPP_OPTION * pOption = (PPP_OPTION *)(pReceiveBuf->Data);

    if ( WireToHostFormat16( pReceiveBuf->Length ) !=
         pOption->Length + PPP_CONFIG_HDR_LEN )
    {
        return( ERROR_PPP_INVALID_PACKET );
    }

    switch( pOption->Type )
    {
    case CBCP_TYPE_NO_CALLBACK:

        if ( !( ( pWorkBuf->fCallbackPrivilege & RASPRIV_NoCallback )      ||
                ( pWorkBuf->fCallbackPrivilege & RASPRIV_CallerSetCallback ) ) )
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        pWorkBuf->fCallbackPrivilege = RASPRIV_NoCallback;

        break;

    case CBCP_TYPE_CALLEE_SET:

        if ( !(pWorkBuf->fCallbackPrivilege & RASPRIV_AdminSetCallback) )
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        pWorkBuf->fCallbackPrivilege = RASPRIV_AdminSetCallback;

        pWorkBuf->CallbackDelay = *(pOption->Data);

        break;

    case CBCP_TYPE_CALLER_SET:

        if ( !(pWorkBuf->fCallbackPrivilege & RASPRIV_CallerSetCallback) )
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        pWorkBuf->fCallbackPrivilege = RASPRIV_CallerSetCallback;

        pWorkBuf->CallbackDelay = *(pOption->Data);

        if ( strlen( pWorkBuf->szCallbackNumber ) <= MAX_CALLBACKNUMBER_SIZE )
        {
            strcpy( pWorkBuf->szCallbackNumber, pOption->Data+2 );
        }
        else
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        break;

    default:

        return( ERROR_PPP_INVALID_PACKET );

        break;
    }

    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rascbcp\rascbcp.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:    rascbcp.h
//
// Description: Co
//
// History:
//	            April 11,1994.	    NarenG		Created original version.
//
#ifndef _RASCBCP_H_
#define _RASCBCP_H_

#include <mprapi.h>
//
// CbCP packet codes from CbCP spec.
//

#define CBCP_CODE_Request   1
#define CBCP_CODE_Response  2
#define CBCP_CODE_Ack       3

#define MAX_CBCP_CODE       3

//
// Callback Option Types
//

#define CBCP_TYPE_NO_CALLBACK       1
#define CBCP_TYPE_CALLER_SET        2
#define CBCP_TYPE_CALLEE_SET        3
#define CBCP_TYPE_NUMBER_LIST       4

//
// Defines states within CBCP
//

typedef enum _CBCP_STATE
{
    CBCP_STATE_INITIAL,
    CBCP_STATE_WAIT_FOR_REQUEST,
    CBCP_STATE_WAIT_FOR_ACK,
    CBCP_STATE_WAIT_FOR_RESPONSE,
    CBCP_STATE_GET_CALLBACK_NUMBER,
    CBCP_STATE_DONE

} CBCP_STATE;

#define CBCP_PSTN_NUMBER    1

//
// Defines the WorkBuf stored for us by the PPP engine.
//

typedef struct _CBCP_WORKBUFFER
{
    BOOL            fServer;

    CBCP_STATE      State;

    PPP_CONFIG *    pRequest;

    PPP_CONFIG *    pResponse;

    DWORD           fCallbackPrivilege;

    CHAR            szCallbackNumber[ MAX_CALLBACKNUMBER_SIZE + 1];

    DWORD           CallbackDelay;


} CBCP_WORKBUFFER, *PCBCP_WORKBUFFER;


//
// Function Prototypes.
//

DWORD
CbCPBegin(
    OUT VOID**              ppWorkBuf,
    IN  VOID*               pInfo
);

DWORD
CbCPEnd(
    IN VOID*                pWorkBuf
);

DWORD
CbCPMakeMessage(
    IN  VOID*               pWorkBuf,
    IN  PPP_CONFIG*         pReceiveBuf,
    OUT PPP_CONFIG*         pSendBuf,
    IN  DWORD               cbSendBuf,
    OUT PPPAP_RESULT*       pResult,
    IN  PPPAP_INPUT*        pInput
);

DWORD
CbCPCMakeMessage(
    IN  CBCP_WORKBUFFER *   pCbCPWorkBuf,
    IN  PPP_CONFIG*         pReceiveBuf,
    OUT PPP_CONFIG*         pSendBuf,
    IN  DWORD               cbSendBuf,
    OUT PPPCB_RESULT*       pResult,
    IN  PPPCB_INPUT*        pInput
);

DWORD
CbCPSMakeMessage(
    IN  CBCP_WORKBUFFER *   pCbCPWorkBuf,
    IN  PPP_CONFIG*         pReceiveBuf,
    OUT PPP_CONFIG*         pSendBuf,
    IN  DWORD               cbSendBuf,
    OUT PPPCB_RESULT*       pResult,
    IN  PPPCB_INPUT*        pInput
);

DWORD
MakeRequest(
    IN     DWORD            fCallbackPrivilege,
    IN OUT PPP_CONFIG *     pSendBuf,
    IN     DWORD            cbSendBuf
);

DWORD
GetCallbackPrivilegeFromRequest(
    IN    PPP_CONFIG *      pRequest,
    IN OUT DWORD *          lpdwCallbackPriv
);

DWORD
MakeResponse(
    IN DWORD                RASCallbackPriv,
    IN LPSTR                szCallbackNumber,
    IN DWORD                ModemDelay,
    IN PPP_CONFIG *         pRequest,
    IN OUT PPP_CONFIG *     pSendBuf,
    IN DWORD                cbSendBuf
);

DWORD
ValidateResponse(
    IN PPP_CONFIG *         pReceiveBuf,
    IN CBCP_WORKBUFFER *    pCbCPWorkBuf
);

#endif // _RASCBCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\ceapcfg.cpp ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:

History:

*/

#include <eaptypeid.h>
#include "ceapcfg.h"

extern "C"
DWORD
InvokeServerConfigUI(
    IN  HWND    hWnd,
    IN  CHAR*   pszMachineName
);

extern "C"
DWORD
RasEapGetIdentity(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT WCHAR**         ppwszIdentityOut
);

extern "C"
DWORD
RasEapInvokeConfigUI(
    IN  DWORD       dwEapTypeId,
    IN  HWND        hwndParent,
    IN  DWORD       dwFlags,
    IN  BYTE*       pConnectionDataIn,
    IN  DWORD       dwSizeOfConnectionDataIn,
    OUT BYTE**      ppConnectionDataOut,
    OUT DWORD*      pdwSizeOfConnectionDataOut
);

extern "C"
DWORD 
RasEapFreeMemory(
    IN  BYTE*   pMemory
);

/*

Returns:

Notes:
    Implementation of IEAPProviderConfig::Initialize
    
*/

STDMETHODIMP
CEapCfg::Initialize(
    LPCOLESTR   pwszMachineName,
    DWORD       dwEapTypeId,
    ULONG_PTR*  puConnectionParam
)
{
    size_t      size;
    CHAR*       psz    = NULL;
    DWORD       dwErr   = NO_ERROR;

    *puConnectionParam = NULL;



    size = wcslen(pwszMachineName);
    

    psz = (CHAR*) LocalAlloc(LPTR, (size + 1)*sizeof(CHAR));

    if (NULL == psz)
    {
        dwErr = GetLastError();
        goto LDone;
    }

    if ( 0 == WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pwszMachineName,
                    -1,
                    psz,
                    size+1,
                    NULL,
                    NULL ) )
    {
        dwErr = GetLastError();
        goto LDone;
    }

    *puConnectionParam = (ULONG_PTR)psz;
    
    psz = NULL;

LDone:

    LocalFree(psz);

    return(HRESULT_FROM_WIN32(dwErr));
}

/*

Returns:

Notes:
    Implementation of IEAPProviderConfig::Uninitialize

*/

STDMETHODIMP
CEapCfg::Uninitialize(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam
)
{    
    LocalFree((VOID*)uConnectionParam);
    
    return(HRESULT_FROM_WIN32(NO_ERROR));
}

/*

Returns:

Notes:
    Implementation of IEAPProviderConfig::ServerInvokeConfigUI
        hWnd - handle to the parent window
        dwRes1 - reserved parameter (ignore)
        dwRes2 - reserved parameter (ignore)

*/

STDMETHODIMP
CEapCfg::ServerInvokeConfigUI(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam,
    HWND        hWnd,
    DWORD_PTR   dwRes1,
    DWORD_PTR   dwRes2
)
{
    CHAR*       pszMachineName;
    HRESULT     hr;
    DWORD       dwErr;


    pszMachineName = (CHAR*)uConnectionParam;

    if (NULL == pszMachineName)
    {
        dwErr = E_FAIL;
    }
    else
    {
        
        //Invoke configuration UI here.
        dwErr = InvokeServerConfigUI(hWnd, pszMachineName);
    }


    hr = HRESULT_FROM_WIN32(dwErr);

    return(hr);
}

/*

Returns:

Notes:
    Implementation of IEAPProviderConfig::RouterInvokeConfigUI

*/

STDMETHODIMP
CEapCfg::RouterInvokeConfigUI(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam,
    HWND        hwndParent,
    DWORD       dwFlags,
    BYTE*       pConnectionDataIn,
    DWORD       dwSizeOfConnectionDataIn,
    BYTE**      ppConnectionDataOut,
    DWORD*      pdwSizeOfConnectionDataOut
)
{
    DWORD       dwErr                       = NO_ERROR;
    BYTE*       pConnectionDataOut          = NULL;
    DWORD       dwSizeOfConnectionDataOut   = 0;

    *ppConnectionDataOut = NULL;
    *pdwSizeOfConnectionDataOut = 0;



    dwErr = RasEapInvokeConfigUI(
                dwEapTypeId,
                hwndParent,
                dwFlags,
                pConnectionDataIn,
                dwSizeOfConnectionDataIn,
                &pConnectionDataOut,
                &dwSizeOfConnectionDataOut);

    if (   (NO_ERROR == dwErr)
        && (0 != dwSizeOfConnectionDataOut))
    {
        *ppConnectionDataOut = (BYTE*)CoTaskMemAlloc(dwSizeOfConnectionDataOut);

        if (NULL == *ppConnectionDataOut)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto LDone;
        }

        CopyMemory(*ppConnectionDataOut, pConnectionDataOut,
            dwSizeOfConnectionDataOut);
        *pdwSizeOfConnectionDataOut = dwSizeOfConnectionDataOut;
    }

LDone:

    RasEapFreeMemory(pConnectionDataOut);

    return(HRESULT_FROM_WIN32(dwErr));
}

/*

Returns:

Notes:
    Implementation of IEAPProviderConfig::RouterInvokeCredentialsUI

*/

STDMETHODIMP
CEapCfg::RouterInvokeCredentialsUI(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam,
    HWND        hwndParent,
    DWORD       dwFlags,
    BYTE*       pConnectionDataIn,
    DWORD       dwSizeOfConnectionDataIn,
    BYTE*       pUserDataIn,
    DWORD       dwSizeOfUserDataIn,
    BYTE**      ppUserDataOut,
    DWORD*      pdwSizeOfUserDataOut
)
{


    return RasEapGetIdentity(
                            dwEapTypeId,
                            hwndParent,
                            dwFlags,
                            NULL,
                            NULL,
                            pConnectionDataIn,
                            dwSizeOfConnectionDataIn,
                            pUserDataIn,
                            dwSizeOfUserDataIn,
                            ppUserDataOut,
                            pdwSizeOfUserDataOut,
                            NULL
                            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasccp\rasccp.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    rasccp.h
//
// Description: Contains structure and contstants definitions.
//
// History:
//      Aprint 11,1994.         NarenG          Created original version.
//

#ifndef _RASCCP_
#define _RASCCP_

//
// CCP Option types
//

#define CCP_OPTION_OUI          0
#define CCP_OPTION_MSPPC        18
#define CCP_OPTION_MSNT31RAS    254
#define CCP_OPTION_MAX          254

#define CCP_N_MSPPC             1 
#define CCP_N_OUI               2
#define CCP_N_PUBLIC            4

typedef struct _CCP_OPTIONS
{
    DWORD                Negotiate;

    RAS_COMPRESSION_INFO CompInfo;

} CCP_OPTIONS, *PCCP_OPTIONS;

//
//  Local.Want:           Options to request.
//                        Contains desired value.
//                        Only non-default options need to be negotiated.
//                        Initially, all are default.
//  local.Work:           Options currently being negotiated.
//                        Value is valid only when negotiate bit is set.
//
//  Remote.Want:          Options to suggest by NAK if not present in REQ.
//                        Contains desired value.
//  Remote.Work:          Options currently being negotiated.
//                        Value is valid only when negotiate bit is set.
// 


typedef struct _CCP_SIDE
{
    CCP_OPTIONS Want;

    CCP_OPTIONS Work;

} CCP_SIDE, *PCCP_SIDE;

//
// CCP control block 
//

typedef struct _CCPCB
{
    HPORT    hPort;

    DWORD    dwDeviceType;
   
    BOOL     fServer;

    BOOL     fForceEncryption;

    BOOL     fDisableCompression;

    DWORD    fLastEncryptionBitSent;

    DWORD    fOldLastEncryptionBitSent;

    CCP_SIDE Local;

    CCP_SIDE Remote;

}CCPCB, *PCCPCB;

//
// Globals.
//
#ifdef CCPGLOBALS
#define GLOBALS
#define EXTERN
#else
#define EXTERN extern
#endif

//
// Trace ID
//

EXTERN DWORD DwCcpTraceId
#ifdef GLOBALS
    = 0
#endif
;

#define TRACE_RASCCP        (0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC)

#define DUMPW(X,Y)          TraceDumpExA(DwCcpTraceId,1,(LPBYTE)X,Y,4,1,NULL)
#define DUMPB(X,Y)          TraceDumpExA(DwCcpTraceId,1,(LPBYTE)X,Y,1,1,NULL)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasccp\rasccp.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    rasccp.c
//
// Description: Contains entry points to configure CCP.
//
// History:     April 11,1994.  NarenG          Created original version.
//
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>    // Win32 base API's
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <lmcons.h>
#include <raserror.h>
#include <rtutils.h>
#include <rasman.h>
#include <pppcp.h>
#define INCL_HOSTWIRE
#define INCL_ENCRYPT
#define INCL_RASAUTHATTRIBUTES
#include <ppputil.h>
#define CCPGLOBALS
#include <rasccp.h>

//**
//
// Call:        TraceCcp
//
// Description:
//
VOID   
TraceCcp(
    CHAR * Format, 
    ... 
) 
{
    va_list arglist;

    va_start(arglist, Format);

    TraceVprintfEx( DwCcpTraceId, TRACE_RASCCP, Format, arglist);

    va_end(arglist);
}

//**
//
// Call:        CcpInit
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
CcpInit(
    IN BOOL fInitialize
)
{
    if ( fInitialize )
    {
        DwCcpTraceId = TraceRegister("RASCCP");
    }
    else
    {
        TraceDeregister( DwCcpTraceId );
    }

    return( NO_ERROR );
}

//**
//
// Call:        CcpBegin
//
// Returns:     NO_ERROR        - Success
//              non-zero error  - Failure
//              
//
// Description: Called once before any other call to CCP is made. Allocate
//              a work buffer and initialize it.
//
DWORD
CcpBegin(
    IN OUT VOID** ppWorkBuf,
    IN     VOID*  pInfo
)
{
    CCPCB *                 pCcpCb;
    DWORD                   dwRetCode;
    RAS_AUTH_ATTRIBUTE *    pAttribute;
    RAS_AUTH_ATTRIBUTE *    pAttributeSend;
    RAS_AUTH_ATTRIBUTE *    pAttributeRecv;
    DWORD                   fEncryptionTypes    = 0;
    BOOL                    fDisableEncryption  = FALSE;
    DWORD                   dwConfigMask = 
                               ((PPPCP_INIT*)pInfo)->PppConfigInfo.dwConfigMask;

    *ppWorkBuf = LocalAlloc( LPTR, sizeof( CCPCB ) );

    if ( *ppWorkBuf == NULL )
    {
        return( GetLastError() );
    }

    pCcpCb                      = (CCPCB *)*ppWorkBuf;
    pCcpCb->fServer             = ((PPPCP_INIT*)pInfo)->fServer;
    pCcpCb->hPort               = ((PPPCP_INIT*)pInfo)->hPort;
    pCcpCb->dwDeviceType        = ((PPPCP_INIT*)pInfo)->dwDeviceType;
    pCcpCb->fForceEncryption    = FALSE;
    pCcpCb->fDisableCompression = !( dwConfigMask & PPPCFG_UseSwCompression );
    fDisableEncryption          = dwConfigMask & PPPCFG_DisableEncryption;

    if ( pCcpCb->fServer )
    {
        if ( RAS_DEVICE_TYPE( pCcpCb->dwDeviceType ) == RDT_Tunnel_L2tp )
        {
            //
            // Allow all types of MPPE, including No Encryption
            //

            fEncryptionTypes = ( MSTYPE_ENCRYPTION_40  |
                                 MSTYPE_ENCRYPTION_40F |
                                 MSTYPE_ENCRYPTION_56  |
                                 MSTYPE_ENCRYPTION_128 );
        }
        else
        {
            //
            // Is there an encryption policy attribute
            //

            pAttribute = RasAuthAttributeGetVendorSpecific(
                                          311,
                                          7,
                                          ((PPPCP_INIT *)pInfo)->pAttributes );

            if ( pAttribute != NULL )
            {
                //
                // See if we have to force encryption
                //

                if ( WireToHostFormat32( ((PBYTE)(pAttribute->Value))+6 ) == 2 )
                {
                    fDisableEncryption       = FALSE;
                    pCcpCb->fForceEncryption = TRUE;
                    TraceCcp("Will force encryption");
                }
            }

            //
            // Now find out what type of encryption is
            // permitted/disallowed/required
            //

            pAttribute = RasAuthAttributeGetVendorSpecific(
                                          311,
                                          8,
                                          ((PPPCP_INIT *)pInfo)->pAttributes );

            if ( pAttribute != NULL )
            {
                DWORD dwEncryptionTypes = 
                         WireToHostFormat32(((PBYTE)(pAttribute->Value))+6);

                if ( dwEncryptionTypes & 0x00000002 )
                {
                    fEncryptionTypes = MSTYPE_ENCRYPTION_40  | 
                                       MSTYPE_ENCRYPTION_40F;
                }

                if ( dwEncryptionTypes & 0x00000004 )
                {
                    fEncryptionTypes |= MSTYPE_ENCRYPTION_128;
                }

                if ( dwEncryptionTypes & 0x00000008 )
                {
                    fEncryptionTypes |= MSTYPE_ENCRYPTION_56;
                }

                if ( fEncryptionTypes == 0 )
                {
                    fDisableEncryption       = TRUE;
                    pCcpCb->fForceEncryption = FALSE;
                    TraceCcp("Will not force encryption: type not specified");
                }
            }
            else
            {
                fEncryptionTypes = ( MSTYPE_ENCRYPTION_40  |
                                     MSTYPE_ENCRYPTION_40F |
                                     MSTYPE_ENCRYPTION_56  |
                                     MSTYPE_ENCRYPTION_128 );
            }
        }

        TraceCcp("EncryptionTypes: 0x%x", fEncryptionTypes);
    }
    else
    {
        //
        // If client is forcing encryption 
        //

        if ( dwConfigMask & PPPCFG_RequireEncryption )
        {
            fEncryptionTypes         |= ( MSTYPE_ENCRYPTION_40  |
                                          MSTYPE_ENCRYPTION_40F |
                                          MSTYPE_ENCRYPTION_56 );
            fDisableEncryption       = FALSE;
            pCcpCb->fForceEncryption = TRUE;

            TraceCcp("Encryption");
        }

        if ( dwConfigMask & PPPCFG_RequireStrongEncryption )
        {
            //
            // If client is forcing strong encryption 
            //

            fEncryptionTypes         |= MSTYPE_ENCRYPTION_128;
            fDisableEncryption       = FALSE;
            pCcpCb->fForceEncryption = TRUE;

            TraceCcp("Strong encryption");
        }

        //
        // If we are not disabling encryption and we are not forcing encryption
        // either.
        //

        if ( ( !fDisableEncryption ) && ( fEncryptionTypes == 0 ) )
        {
            //
            // Allow these types
            //

            fDisableEncryption       = FALSE;
            pCcpCb->fForceEncryption = FALSE;
            fEncryptionTypes         = ( MSTYPE_ENCRYPTION_40  |
                                         MSTYPE_ENCRYPTION_40F |
                                         MSTYPE_ENCRYPTION_56  |
                                         MSTYPE_ENCRYPTION_128 );

            TraceCcp("Not disabling encryption; Not forcing encryption");
        }
    }

    //
    // Now check if we got encryption keys, if not then we disable encryption
    //

    pAttribute = RasAuthAttributeGetVendorSpecific( 
                                          311, 
                                          12, 
                                          ((PPPCP_INIT *)pInfo)->pAttributes );

    pAttributeSend = RasAuthAttributeGetVendorSpecific( 
                                          311, 
                                          16, 
                                          ((PPPCP_INIT *)pInfo)->pAttributes );


    pAttributeRecv = RasAuthAttributeGetVendorSpecific( 
                                          311, 
                                          17, 
                                          ((PPPCP_INIT *)pInfo)->pAttributes );

    if (   ( pAttribute == NULL )
        && (   ( pAttributeSend == NULL )
            || ( pAttributeRecv == NULL ) ) )
    {
        TraceCcp("No MPPE keys were obtained");

        if ( pCcpCb->fForceEncryption )
        {
            LocalFree( pCcpCb );

            return( ERROR_NO_LOCAL_ENCRYPTION );
        }

        fDisableEncryption         = TRUE;
        pCcpCb->fForceEncryption   = FALSE;
        fEncryptionTypes           = ( MSTYPE_ENCRYPTION_40  |
                                       MSTYPE_ENCRYPTION_40F |
                                       MSTYPE_ENCRYPTION_56  |
                                       MSTYPE_ENCRYPTION_128 );
    }

    //
    // Get Send and Recv compression information
    //

    dwRetCode = RasCompressionGetInfo( pCcpCb->hPort,
                                       &(pCcpCb->Local.Want.CompInfo),
                                       &(pCcpCb->Remote.Want.CompInfo) );
    if ( dwRetCode != NO_ERROR )
    {
        LocalFree( pCcpCb );

        return( dwRetCode );
    }

    TraceCcp("Send capabilites from NDISWAN = 0x%x", 
            pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType );

    TraceCcp("Receive capabilites from NDISWAN = 0x%x",
           pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType );

    TraceCcp("Send RCI_MacCompressionType = 0x%x",
            pCcpCb->Local.Want.CompInfo.RCI_MacCompressionType );

    TraceCcp("Receive RCI_MacCompressionType = 0x%x",
            pCcpCb->Remote.Want.CompInfo.RCI_MacCompressionType );

    //
    // Ignore NT31RAS capability.
    //

    if ( pCcpCb->Local.Want.CompInfo.RCI_MacCompressionType
                                                    == CCP_OPTION_MSNT31RAS )
    {
        pCcpCb->Local.Want.CompInfo.RCI_MacCompressionType = CCP_OPTION_MAX + 1;
    }

    if (pCcpCb->Remote.Want.CompInfo.RCI_MacCompressionType 
                                                    == CCP_OPTION_MSNT31RAS )
    {
        pCcpCb->Remote.Want.CompInfo.RCI_MacCompressionType = CCP_OPTION_MAX+1;
    }

    //
    // Set up local or send information.
    //

    pCcpCb->Local.Want.Negotiate = 0;

    if ( pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType != 0 )
    {
        pCcpCb->Local.Want.Negotiate = CCP_N_MSPPC;
    }

    if ( pCcpCb->Local.Want.CompInfo.RCI_MacCompressionType <= CCP_OPTION_MAX )
    {
        if ( pCcpCb->Local.Want.CompInfo.RCI_MacCompressionType ==
                                                                CCP_OPTION_OUI )
        {
            pCcpCb->Local.Want.Negotiate |= CCP_N_OUI;
        }
        else
        {
            pCcpCb->Local.Want.Negotiate |= CCP_N_PUBLIC;
        }
    }

    if ( pCcpCb->fForceEncryption )
    {
        //
        // Make sure NDISWAN supports the required encryption types
        //

        if ( !( pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType & 
                                                    fEncryptionTypes ))
        {
            LocalFree( pCcpCb );

            TraceCcp("Encryption type(s) 0x%x not supported locally", 
                   fEncryptionTypes );

            return( ERROR_NO_LOCAL_ENCRYPTION );
        }

        //
        // Turn off everything else
        //

        pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType &=
                                                    ( fEncryptionTypes   |
                                                      MSTYPE_HISTORYLESS |
                                                      MSTYPE_COMPRESSION );

        TraceCcp("Send Encryption is Forced 0x%x", 
                pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType );

        pCcpCb->Local.Want.Negotiate &= ~( CCP_N_PUBLIC | CCP_N_OUI );
    }

    if ( pCcpCb->fDisableCompression )
    {
        pCcpCb->Local.Want.Negotiate &= ( ~CCP_N_PUBLIC & ~CCP_N_OUI );

        pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType&=~MSTYPE_COMPRESSION;

        TraceCcp("Send Compression is Disabled");
    }

    if ( fDisableEncryption )
    {
        pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType &=
                                                ~( MSTYPE_ENCRYPTION_40  |
                                                   MSTYPE_ENCRYPTION_40F |
                                                   MSTYPE_ENCRYPTION_56  |
                                                   MSTYPE_ENCRYPTION_128 );

        TraceCcp("Send Encryption is Disabled 0x%x", fEncryptionTypes );
    }
    
    //
    // If we neither force nor disable any encryption types, then we set the
    // types allowed
    //

    if ( (!fDisableEncryption) && (!pCcpCb->fForceEncryption) )
    {
        DWORD dwEncryptionTypesAllowed = 
           pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType & fEncryptionTypes;

        pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType &=
                                                ~( MSTYPE_ENCRYPTION_40  |
                                                   MSTYPE_ENCRYPTION_40F |
                                                   MSTYPE_ENCRYPTION_56  |
                                                   MSTYPE_ENCRYPTION_128 );

        pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType |=
                                                     dwEncryptionTypesAllowed;

        TraceCcp("Send Encryption is Allowed 0x%x", dwEncryptionTypesAllowed );
    }

    pCcpCb->Local.Work = pCcpCb->Local.Want;

    //
    // If we do not want any compression or encryption on the local side
    // we do not send, or accept NAKs to, negotiate the MSPPC option
    //

    if ( ( pCcpCb->Local.Want.CompInfo.RCI_MSCompressionType &
                                                   ( MSTYPE_ENCRYPTION_40  |
                                                     MSTYPE_ENCRYPTION_40F |
                                                     MSTYPE_ENCRYPTION_56  |
                                                     MSTYPE_ENCRYPTION_128 |
                                                     MSTYPE_COMPRESSION    ) )
                                                                        == 0 )
    {
        pCcpCb->Local.Want.Negotiate &= ~CCP_N_MSPPC;

        TraceCcp("We do not want any compression or encryption on the local "
            "side");
    }

    //
    //  If we do not require encryption locally then do not request for it
    //

    if ( !( pCcpCb->fForceEncryption ) )
    {
        pCcpCb->Local.Work.CompInfo.RCI_MSCompressionType &=
                                                ~( MSTYPE_ENCRYPTION_40  |
                                                   MSTYPE_ENCRYPTION_40F |
                                                   MSTYPE_ENCRYPTION_56  |
                                                   MSTYPE_ENCRYPTION_128 );

        TraceCcp("We do not require encryption locally; we won't request for "
            "it");
    }

    //
    // Set up remote or receive information
    //

    pCcpCb->Remote.Want.Negotiate = 0;

    if (pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType != 0 )
    {
        pCcpCb->Remote.Want.Negotiate = CCP_N_MSPPC;
    }

    if ( pCcpCb->Remote.Want.CompInfo.RCI_MacCompressionType <= CCP_OPTION_MAX )
    {
        if ( pCcpCb->Remote.Want.CompInfo.RCI_MacCompressionType ==
                                                                CCP_OPTION_OUI )
        {
            pCcpCb->Remote.Want.Negotiate |= CCP_N_OUI;
        }
        else
        {
            pCcpCb->Remote.Want.Negotiate |= CCP_N_PUBLIC;
        }
    }

    if ( pCcpCb->fForceEncryption )
    {
        if ( !( pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType &
                                                   fEncryptionTypes ) )
        {
            TraceCcp("Encryption type(s) 0x%x not supported locally", 
                   fEncryptionTypes );

            LocalFree( pCcpCb );

            return( ERROR_NO_LOCAL_ENCRYPTION );
        }

        pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType &=
                                                    ( fEncryptionTypes   |
                                                      MSTYPE_HISTORYLESS |
                                                      MSTYPE_COMPRESSION );

        TraceCcp("Receive Encryption is Forced 0x%x", 
                pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType );

        pCcpCb->Remote.Want.Negotiate &= ~( CCP_N_PUBLIC | CCP_N_OUI );
    }

    if ( pCcpCb->fDisableCompression )
    {
        pCcpCb->Remote.Want.Negotiate &= ( ~CCP_N_PUBLIC & ~CCP_N_OUI );

        pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType&=~MSTYPE_COMPRESSION;

        TraceCcp("Receive Compression is disabled");
    }

    if ( fDisableEncryption )
    {
        pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType &= 
                                                ~( MSTYPE_ENCRYPTION_40  |
                                                   MSTYPE_ENCRYPTION_40F |
                                                   MSTYPE_ENCRYPTION_56  |
                                                   MSTYPE_ENCRYPTION_128 );

        TraceCcp("Receive Encryption is Disabled 0x%x", fEncryptionTypes );
    }

    //
    // If we neither force or disable any encryption types then we set the
    // types allowed
    //

    if ( (!fDisableEncryption) && (!pCcpCb->fForceEncryption) )
    {
        DWORD dwEncryptionTypesAllowed =
          pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType & fEncryptionTypes;

        pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType &=
                                                ~( MSTYPE_ENCRYPTION_40  |
                                                   MSTYPE_ENCRYPTION_40F |
                                                   MSTYPE_ENCRYPTION_56  |
                                                   MSTYPE_ENCRYPTION_128 );

        pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType |=
                                                     dwEncryptionTypesAllowed;

        TraceCcp("Receive Encryption is Allowed 0x%x", dwEncryptionTypesAllowed );
    }

    //
    // If we do not want to receive any compression or encryption from the 
    // remote side, we do not ACK, or accept CONFIG-REQs to, negotiate the 
    // MSPPC option
    //

    if ( ( pCcpCb->Remote.Want.CompInfo.RCI_MSCompressionType &
                                                   ( MSTYPE_ENCRYPTION_40  |
                                                     MSTYPE_ENCRYPTION_40F |
                                                     MSTYPE_ENCRYPTION_56  |
                                                     MSTYPE_ENCRYPTION_128 |
                                                     MSTYPE_COMPRESSION    ) )
                                                                        == 0 )
    {
        pCcpCb->Remote.Want.Negotiate &= ~CCP_N_MSPPC;

        TraceCcp("We do not want to receive any compression or encryption "
            "from the remote side");
    }

    if ( ( pCcpCb->Remote.Want.Negotiate == 0 ) &&
         ( pCcpCb->Local.Want.Negotiate == 0 ) )
    {
        TraceCcp("ERROR_PROTOCOL_NOT_CONFIGURED");

        LocalFree( pCcpCb );

        return( ERROR_PROTOCOL_NOT_CONFIGURED );
    }

    if ( pCcpCb->fForceEncryption )
    {
        TraceCcp("ForceEncryption");

        pCcpCb->Local.Want.CompInfo.RCI_Flags  = CCP_PAUSE_DATA;
        pCcpCb->Remote.Want.CompInfo.RCI_Flags = CCP_PAUSE_DATA;

        dwRetCode = RasCompressionSetInfo( pCcpCb->hPort,
                                           &(pCcpCb->Local.Want.CompInfo),
                                           &(pCcpCb->Remote.Want.CompInfo) );
        if ( dwRetCode != NO_ERROR )
        {
            LocalFree( pCcpCb );

            return( dwRetCode );
        }
    }

    return( NO_ERROR );
}

//**
//
// Call:        CcpEnd
//
// Returns:     NO_ERROR - Success
//
// Description: Frees the CCP work buffer.
//
DWORD
CcpEnd(
    IN VOID * pWorkBuf
)
{
    TraceCcp( "CcpEnd Called" );

    if ( pWorkBuf != NULL )
    {
            LocalFree( pWorkBuf );
    }

    return( NO_ERROR );
}


//**
//
// Call:        CcpReset
//
// Returns:     NO_ERROR - Success
//
// Description: Called to reset the state of CCP. Will re-initialize the work
//              buffer.
//
DWORD
CcpReset(
    IN VOID * pWorkBuf
)
{
    return( NO_ERROR );
}

//**
//
// Call:        CcpMakeOption
//
// Returns:     NO_ERROR - Success
//              ERROR_BUFFER_TOO_SMALL - Buffer passed in is not large enough.
//              ERROR_INVALID_PARAMETER - Option type not recognized.
//
// Description: This is not an entry point, it is an internal procedure called
//              to build a particular option.
//
DWORD
CcpMakeOption(
    IN CCP_OPTIONS * pOptionValues,
    IN DWORD         dwOptionType,
    IN PPP_OPTION *  pSendOption,
    IN DWORD         cbSendOption
)
{
    if ( cbSendOption < PPP_OPTION_HDR_LEN )
    {
        return( ERROR_BUFFER_TOO_SMALL );
    }

    pSendOption->Type = (BYTE)dwOptionType;

    switch( dwOptionType )
    {

    case CCP_OPTION_OUI:

        pSendOption->Length = (BYTE)( PPP_OPTION_HDR_LEN +
                        pOptionValues->CompInfo.RCI_MacCompressionValueLength);

        if ( pSendOption->Length > cbSendOption )
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        CopyMemory( pSendOption->Data,
                (PBYTE)&(pOptionValues->CompInfo.RCI_Info.RCI_Proprietary),
                pSendOption->Length - PPP_OPTION_HDR_LEN );

        break;

    case CCP_OPTION_MSPPC:

        pSendOption->Length = (BYTE)( PPP_OPTION_HDR_LEN + 4 );

        if ( pSendOption->Length > cbSendOption )
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        HostToWireFormat32( pOptionValues->CompInfo.RCI_MSCompressionType,
                            pSendOption->Data );

        break;

    default:

        //
        // Public compression type
        //

        pSendOption->Length = (BYTE)( PPP_OPTION_HDR_LEN +
                        pOptionValues->CompInfo.RCI_MacCompressionValueLength);

        if ( pSendOption->Length > cbSendOption )
        {
            return( ERROR_BUFFER_TOO_SMALL );
        }

        CopyMemory( pSendOption->Data,
                (PBYTE)&(pOptionValues->CompInfo.RCI_Info.RCI_Public),
                pSendOption->Length - PPP_OPTION_HDR_LEN );
        break;
    }

    return( NO_ERROR );

}

//**
//
// Call:        CcpCheckOption
//
// Returns:     NO_ERROR - Success
//              ERROR_NO_REMOTE_ENCRYPTION
//
// Description: This is not an entry point. Called to check to see if an option
//              value is valid and if it is the new value is saved in the
//              work buffer. One of the following is returned in *pdwRetCode: 
//              CONFIG_ACK, CONFIG_NAK, CONFIG_REJ.
//
DWORD
CcpCheckOption(
    IN CCPCB *      pCcpCb,
    IN CCP_SIDE *   pCcpSide,
    IN PPP_OPTION * pOption,
    OUT DWORD *     pdwRetCode,
    IN BOOL         fMakingResult
)
{
    DWORD fEncryptionTypes      = 0;  
    BOOL  fEncryptionRequested  = FALSE;
    DWORD dwError               = NO_ERROR;

    *pdwRetCode                 = CONFIG_ACK;

    switch( pOption->Type )
    {

    case CCP_OPTION_OUI:

        if ( pOption->Length < (PPP_OPTION_HDR_LEN + 4) )
        {
            dwError = ERROR_PPP_INVALID_PACKET;
            break;
        }

        if ( ( pCcpCb->fDisableCompression ) || ( pCcpCb->fForceEncryption ) )
        {
            *pdwRetCode = CONFIG_REJ;
            break;
        }

        if ( pCcpSide->Want.CompInfo.RCI_MacCompressionType != CCP_OPTION_OUI )
        {
            *pdwRetCode = CONFIG_REJ;
            break;
        }

        pCcpSide->Work.CompInfo.RCI_MacCompressionType = CCP_OPTION_OUI;

        pCcpSide->Work.CompInfo.RCI_MacCompressionValueLength
                        = pCcpSide->Want.CompInfo.RCI_MacCompressionValueLength;

        pCcpSide->Work.CompInfo.RCI_Info = pCcpSide->Want.CompInfo.RCI_Info;

        if ( pOption->Length != PPP_OPTION_HDR_LEN +
                        pCcpSide->Want.CompInfo.RCI_MacCompressionValueLength )
        {
            *pdwRetCode = CONFIG_NAK;
            break;
        }

        if ( memcmp( pOption->Data,
                     (PBYTE)&(pCcpSide->Want.CompInfo.RCI_Info.RCI_Proprietary),
                     pOption->Length - PPP_OPTION_HDR_LEN ) )
        {
            *pdwRetCode = CONFIG_NAK;
            break;
        }

        break;

    case CCP_OPTION_MSPPC:

        if ( pOption->Length != (PPP_OPTION_HDR_LEN + 4) )
        {
            dwError = ERROR_PPP_INVALID_PACKET;
            break;
        }

        pCcpSide->Work.CompInfo.RCI_MSCompressionType =
                                        WireToHostFormat32( pOption->Data );

        //
        // If remote guy wants compression but we do not want it, we NAK it
        //

        if ( ( pCcpCb->fDisableCompression ) &&
             ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                        MSTYPE_COMPRESSION ) )
        {
            pCcpSide->Work.CompInfo.RCI_MSCompressionType &=
                                                        ~MSTYPE_COMPRESSION;
            TraceCcp("Nak - Compression disabled" );

            *pdwRetCode = CONFIG_NAK;
        }

        //
        // If remote side wants do historyless, make sure we support it
        //

        if (pCcpSide->Work.CompInfo.RCI_MSCompressionType & MSTYPE_HISTORYLESS)
        {
            if ( !( pCcpSide->Want.CompInfo.RCI_MSCompressionType &
                                                            MSTYPE_HISTORYLESS))
            {
                pCcpSide->Work.CompInfo.RCI_MSCompressionType &=
                                                          (~MSTYPE_HISTORYLESS);
                *pdwRetCode = CONFIG_NAK;
            }
        }

        //
        // Get the encryption types that are to be forced or allowed
        //

        fEncryptionTypes = pCcpSide->Want.CompInfo.RCI_MSCompressionType &
                                                ( MSTYPE_ENCRYPTION_40F |
                                                  MSTYPE_ENCRYPTION_40  |
                                                  MSTYPE_ENCRYPTION_56  |
                                                  MSTYPE_ENCRYPTION_128 );

        //
        // Remember if the remote guy wants encryption or not
        //

        fEncryptionRequested = pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                ( MSTYPE_ENCRYPTION_40F |
                                                  MSTYPE_ENCRYPTION_40  |
                                                  MSTYPE_ENCRYPTION_56  |
                                                  MSTYPE_ENCRYPTION_128 );

        //
        // If we were offered 128 bit encryption
        //

        if ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                        MSTYPE_ENCRYPTION_128 )
        {
            //
            // If we support it
            //

            if ( fEncryptionTypes & MSTYPE_ENCRYPTION_128 )
            {
                //
                // If remote side offered any other type
                //

                if ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                ( MSTYPE_ENCRYPTION_40F |
                                                  MSTYPE_ENCRYPTION_40  |
                                                  MSTYPE_ENCRYPTION_56 ) )
                {
                    //
                    // Turn them off
                    //

                    pCcpSide->Work.CompInfo.RCI_MSCompressionType &=
                                                 ~( MSTYPE_ENCRYPTION_40F |
                                                    MSTYPE_ENCRYPTION_40  |
                                                    MSTYPE_ENCRYPTION_56 );

                    TraceCcp("Nak - Accepting 128 bit");

                    *pdwRetCode = CONFIG_NAK;
                }
            }
            else
            {
                //
                // we do not support it so turn it off
                //

                pCcpSide->Work.CompInfo.RCI_MSCompressionType &=
                                                        ~MSTYPE_ENCRYPTION_128;

                TraceCcp("Nak - 128 bit not supported");

                *pdwRetCode = CONFIG_NAK;
            }
        }

        //
        // If we were offered 40 variable bit encryption and we support it
        //

        if ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                        MSTYPE_ENCRYPTION_56 )
        {
            //
            // If we support it
            //

            if ( fEncryptionTypes & MSTYPE_ENCRYPTION_56 )
            {
                //
                // If remote side offered any other type
                //

                if ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                ( MSTYPE_ENCRYPTION_40F |
                                                  MSTYPE_ENCRYPTION_40 ) )
                {
                    //
                    // Turn them off
                    //

                    pCcpSide->Work.CompInfo.RCI_MSCompressionType &=
                                                 ~( MSTYPE_ENCRYPTION_40F |
                                                    MSTYPE_ENCRYPTION_40);
                    *pdwRetCode = CONFIG_NAK;
                }
            }
            else
            {
                //
                // we do not support it so turn it off
                //

                pCcpSide->Work.CompInfo.RCI_MSCompressionType &=
                                                    ~MSTYPE_ENCRYPTION_56;
                *pdwRetCode = CONFIG_NAK;
            }
        }

        //
        // If we were offered 40 bit encryption
        //

        if ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                        MSTYPE_ENCRYPTION_40F )
        {
            //
            // If we support it
            //

            if ( fEncryptionTypes & MSTYPE_ENCRYPTION_40F )
            {
                //
                // If the remote guy requested any other type
                //

                if ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                        MSTYPE_ENCRYPTION_40 )
                {
                    //
                    // Turn them off
                    //

                    pCcpSide->Work.CompInfo.RCI_MSCompressionType &=
                                                        ~MSTYPE_ENCRYPTION_40;

                    TraceCcp("Nak - Accepting 40 bit");

                    *pdwRetCode = CONFIG_NAK;
                }
            }
            else
            {
                //
                // we do not support it so turn it off
                //

                pCcpSide->Work.CompInfo.RCI_MSCompressionType &=
                                                        ~MSTYPE_ENCRYPTION_40F;

                TraceCcp("Nak - 40 bit not supported");

                *pdwRetCode = CONFIG_NAK;
            }
        }

        //
        // If we were offerred legacy 40 bit encryption
        //

        if ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                        MSTYPE_ENCRYPTION_40 )
        {
            //
            // If we don't support it then turn it off
            //

            if ( !( fEncryptionTypes & MSTYPE_ENCRYPTION_40 ) )
            {
                pCcpSide->Work.CompInfo.RCI_MSCompressionType &=
                                                        ~MSTYPE_ENCRYPTION_40;

                TraceCcp("Nak - legacy 40 bit not supported");

                *pdwRetCode = CONFIG_NAK;
            }
        }

        //
        // If we have turned all encryption off, or none was offered, but
        // we need to force encryption or remote side requested encryption,
        // then we we NAK with what we want or what we can do.
        //

        if ( ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                   ( MSTYPE_ENCRYPTION_40  |
                                                     MSTYPE_ENCRYPTION_40F |
                                                     MSTYPE_ENCRYPTION_56  |
                                                     MSTYPE_ENCRYPTION_128 ) )
                                                                        == 0 )
        {
            if ( ( pCcpCb->fForceEncryption ) || ( fEncryptionRequested ) )
            {
                //
                // Make sure we are going to support stuff we NAK
                //

                if ( fEncryptionTypes != 0 )
                {
                    if ( fMakingResult )
                    {
                        //
                        // If we are NAKing then we can only send one bit.
                        // Find out the strongest encryption we can NAK with
                        //

                        //
                        // Save the last bit we NAKed with so that in case this
                        // NAK turns out to be REJECT we can reset to this
                        // value.
                        //

                        pCcpCb->fOldLastEncryptionBitSent =
                                                pCcpCb->fLastEncryptionBitSent;

                        for(;;)
                        {
                            if ( pCcpCb->fLastEncryptionBitSent == 0 )
                            {
                                pCcpCb->fLastEncryptionBitSent =
                                                        MSTYPE_ENCRYPTION_128;
                            }
                            else if ( pCcpCb->fLastEncryptionBitSent ==
                                                        MSTYPE_ENCRYPTION_128 )
                            {
                                pCcpCb->fLastEncryptionBitSent =
                                                        MSTYPE_ENCRYPTION_56;
                            }
                            else if ( pCcpCb->fLastEncryptionBitSent ==
                                                        MSTYPE_ENCRYPTION_56 )
                            {
                                pCcpCb->fLastEncryptionBitSent =
                                                        MSTYPE_ENCRYPTION_40F;
                            }
                            else if ( pCcpCb->fLastEncryptionBitSent ==
                                                        MSTYPE_ENCRYPTION_40F )
                            {
                                pCcpCb->fLastEncryptionBitSent =
                                                        MSTYPE_ENCRYPTION_40;
                            }
                            else
                            {
                                //
                                // Cannot NAK with any encryption
                                //

                                pCcpCb->fLastEncryptionBitSent = 0;

                                if ( !pCcpCb->fForceEncryption ) 
                                {
                                    //
                                    // Give up only if we are not forcing
                                    // encryption.
                                    //
                
                                    *pdwRetCode = CONFIG_NAK;

                                    break;
                                }
                                else
                                {
                                    //
                                    // It is possible that the client did not 
                                    // receive our NAK's. Let us restart with 
                                    // the strongest encryption we can NAK with
                                    //
                                }
                            }


                            if ( pCcpCb->fLastEncryptionBitSent &
                                                            fEncryptionTypes )
                            {
                                pCcpSide->Work.CompInfo.RCI_MSCompressionType |=
                                                pCcpCb->fLastEncryptionBitSent;

                                *pdwRetCode = CONFIG_NAK;

                                break;
                            }
                        }
                    }
                    else if ( pCcpCb->fForceEncryption )
                    {
                        //
                        // We require encryption, but there is no common scheme 
                        // that both sides can agree on.
                        //

                        return( ERROR_NO_REMOTE_ENCRYPTION );
                    }
                    else
                    {
                        //
                        // If we are sending a request then we can send more
                        // than one bit
                        //

                        pCcpSide->Work.CompInfo.RCI_MSCompressionType
                                                         |= fEncryptionTypes;
                        *pdwRetCode = CONFIG_NAK;
                    }
                }
            }
        }

        //
        // Turn off any bits that we do not understand
        //

        if ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                  ~( MSTYPE_ENCRYPTION_40  |
                                                     MSTYPE_ENCRYPTION_40F |
                                                     MSTYPE_ENCRYPTION_56  |
                                                     MSTYPE_ENCRYPTION_128 |
                                                     MSTYPE_COMPRESSION    |
                                                     MSTYPE_HISTORYLESS ) )
        {
            pCcpSide->Work.CompInfo.RCI_MSCompressionType &=
                                                   ( MSTYPE_ENCRYPTION_40  |
                                                     MSTYPE_ENCRYPTION_40F |
                                                     MSTYPE_ENCRYPTION_56  |
                                                     MSTYPE_ENCRYPTION_128 |
                                                     MSTYPE_COMPRESSION    |
                                                     MSTYPE_HISTORYLESS );

            TraceCcp("Nak - unknown bits");

            *pdwRetCode = CONFIG_NAK;
        }

        if ( *pdwRetCode == CONFIG_NAK )
        {
            if ( ( pCcpSide->Work.CompInfo.RCI_MSCompressionType &
                                                   ( MSTYPE_ENCRYPTION_40  |
                                                     MSTYPE_ENCRYPTION_40F |
                                                     MSTYPE_ENCRYPTION_56  |
                                                     MSTYPE_ENCRYPTION_128 |
                                                     MSTYPE_COMPRESSION  ) )
                                                                        == 0 )
            {
                TraceCcp("Rej - No bits supported");

                *pdwRetCode = CONFIG_REJ;
            }
        }

        break;

    default:

        if ( pOption->Length < PPP_OPTION_HDR_LEN )
        {
            dwError = ERROR_PPP_INVALID_PACKET;
            break;
        }

        if ( ( pCcpCb->fDisableCompression ) || ( pCcpCb->fForceEncryption ) )
        {
            *pdwRetCode = CONFIG_REJ;
            break;
        }

        if ( pOption->Type != pCcpSide->Want.CompInfo.RCI_MacCompressionType )
        {
            *pdwRetCode = CONFIG_REJ;
            break;
        }

        pCcpSide->Work.CompInfo.RCI_MacCompressionType
                        = pCcpSide->Want.CompInfo.RCI_MacCompressionType;

        pCcpSide->Work.CompInfo.RCI_MacCompressionValueLength
                        = pCcpSide->Want.CompInfo.RCI_MacCompressionValueLength;

        pCcpSide->Work.CompInfo.RCI_Info = pCcpSide->Want.CompInfo.RCI_Info;

        if ( pOption->Length != PPP_OPTION_HDR_LEN +
                        pCcpSide->Want.CompInfo.RCI_MacCompressionValueLength )
        {
            *pdwRetCode = CONFIG_NAK;
            break;
        }

        if ( memcmp( pOption->Data,
                     (PBYTE)&(pCcpSide->Want.CompInfo.RCI_Info.RCI_Public),
                     pOption->Length - PPP_OPTION_HDR_LEN ) )
        {
            *pdwRetCode = CONFIG_NAK;
            break;
        }
    }

    return( dwError );
}

//**
//
// Call:        CcpBuildOptionList
//
// Returns:     NO_ERROR - Success
//              Non-zero returns from CcpMakeOption
//
// Description: This is not an entry point. Will build a list of options
//              either for a configure request or a configure result.
//
DWORD
CcpBuildOptionList(
    IN OUT BYTE *    pOptions,
    IN OUT DWORD *   pcbOptions,
    IN CCP_OPTIONS * CcpOptions,
    IN DWORD         Negotiate
)
{

    DWORD dwRetCode;
    DWORD cbOptionLength = *pcbOptions;

    if ( Negotiate & CCP_N_OUI )
    {
        if ( ( dwRetCode = CcpMakeOption(  CcpOptions,
                                        CCP_OPTION_OUI,
                                        (PPP_OPTION *)pOptions,
                                        cbOptionLength ) ) != NO_ERROR )
            return( dwRetCode );

        cbOptionLength -= ((PPP_OPTION*)pOptions)->Length;
        pOptions       += ((PPP_OPTION*)pOptions)->Length;
    }

    if ( Negotiate & CCP_N_PUBLIC )
    {
        if ( ( dwRetCode = CcpMakeOption(  CcpOptions,
                                        CCP_OPTION_MAX,
                                        (PPP_OPTION *)pOptions,
                                        cbOptionLength ) ) != NO_ERROR )
            return( dwRetCode );

        cbOptionLength -= ((PPP_OPTION*)pOptions)->Length;
        pOptions       += ((PPP_OPTION*)pOptions)->Length;
    }

    if ( Negotiate & CCP_N_MSPPC )
    {
        if ( ( dwRetCode = CcpMakeOption(  CcpOptions,
                                        CCP_OPTION_MSPPC,
                                        (PPP_OPTION *)pOptions,
                                        cbOptionLength ) ) != NO_ERROR )
            return( dwRetCode );

        cbOptionLength -= ((PPP_OPTION*)pOptions)->Length;
        pOptions       += ((PPP_OPTION*)pOptions)->Length;
    }

    *pcbOptions -= cbOptionLength;

    return( NO_ERROR );
}

//**
//
// Call:        CcpMakeConfigRequest
//
// Returns:     NO_ERROR - Success
//              Non-zero returns from CcpBuildOptionList
//
// Description: This is a entry point that is called to make a confifure
//              request packet.
//
DWORD
CcpMakeConfigRequest(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pSendConfig,
    IN DWORD        cbSendConfig
)
{
    CCPCB * pCcpCb   = (CCPCB*)pWorkBuffer;
    DWORD   dwRetCode;

    cbSendConfig -= PPP_CONFIG_HDR_LEN;

    dwRetCode = CcpBuildOptionList( pSendConfig->Data,
                                 &cbSendConfig,
                                 &(pCcpCb->Local.Work),
                                 pCcpCb->Local.Work.Negotiate );

    if ( dwRetCode != NO_ERROR )
        return( dwRetCode );

    pSendConfig->Code = CONFIG_REQ;

    HostToWireFormat16( (WORD)(cbSendConfig + PPP_CONFIG_HDR_LEN),
                        pSendConfig->Length);

    return( NO_ERROR );
}

//**
//
// Call:        CcpMakeConfigResult
//
// Returns:
//
// Description:
//
DWORD
CcpMakeConfigResult(
    IN  VOID *        pWorkBuffer,
    IN  PPP_CONFIG *  pRecvConfig,
    OUT PPP_CONFIG *  pSendConfig,
    IN  DWORD         cbSendConfig,
    IN  BOOL          fRejectNaks
)
{
    DWORD        OptionListLength;
    DWORD        NumOptionsInRequest = 0;
    DWORD        dwRetCode;
    DWORD        dwError;
    CCPCB *      pCcpCb      = (CCPCB*)pWorkBuffer;
    DWORD        ResultType  = CONFIG_ACK;
    PPP_OPTION * pRecvOption = (PPP_OPTION *)(pRecvConfig->Data);
    PPP_OPTION * pSendOption = (PPP_OPTION *)(pSendConfig->Data);
    LONG         lSendLength = cbSendConfig - PPP_CONFIG_HDR_LEN;
    LONG         lRecvLength = WireToHostFormat16( pRecvConfig->Length )
                               - PPP_CONFIG_HDR_LEN;

    //
    // Clear negotiate mask
    //

    pCcpCb->Remote.Work.Negotiate = 0;

    //
    // Process options requested by remote host
    //

    while( lRecvLength > 0 )
    {
        if ( ( lRecvLength -= pRecvOption->Length ) < 0 )
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        NumOptionsInRequest++;

        dwError = CcpCheckOption(pCcpCb, &(pCcpCb->Remote), pRecvOption, 
                        &dwRetCode, TRUE);

        if ( NO_ERROR != dwError )
        {
            return( dwError );
        }

        //
        // If we were building an ACK and we got a NAK or reject OR
        // we were building a NAK and we got a reject.
        //

        if ( (( ResultType == CONFIG_ACK ) && ( dwRetCode != CONFIG_ACK )) ||
             (( ResultType == CONFIG_NAK ) && ( dwRetCode == CONFIG_REJ )) )
        {
            ResultType  = dwRetCode;
            pSendOption = (PPP_OPTION *)(pSendConfig->Data);
            lSendLength = cbSendConfig - PPP_CONFIG_HDR_LEN;
        }

        //
        // Remember that we processed this option
        //

        if ( ( dwRetCode != CONFIG_REJ ) &&
             ( pRecvOption->Type <= CCP_OPTION_MAX ) )
        {
            switch( pRecvOption->Type )
            {

            case CCP_OPTION_OUI:
                pCcpCb->Remote.Work.Negotiate |= CCP_N_OUI;
                break;

            case CCP_OPTION_MSPPC:
                pCcpCb->Remote.Work.Negotiate |= CCP_N_MSPPC;
                break;

            default:
                pCcpCb->Remote.Work.Negotiate |= CCP_N_PUBLIC;
                break;
            }
        }

        //
        // Add the option to the list.
        //

        if ( dwRetCode == ResultType )
        {
            //
            // If this option is to be rejected, simply copy the
            // rejected option to the send buffer
            //

            if ( ( dwRetCode == CONFIG_REJ ) ||
                 ( ( dwRetCode == CONFIG_NAK ) && ( fRejectNaks ) ) )
            {
                CopyMemory( pSendOption, pRecvOption, pRecvOption->Length );

                lSendLength -= pSendOption->Length;

                pSendOption  = (PPP_OPTION *)
                               ( (BYTE *)pSendOption + pSendOption->Length );
            }
        }

        pRecvOption = (PPP_OPTION *)((BYTE*)pRecvOption + pRecvOption->Length);

    }

    //
    // If this was an NAK and we have cannot send any more NAKS then we
    // make this a REJECT packet
    //

    if ( ( ResultType == CONFIG_NAK ) && fRejectNaks )
        pSendConfig->Code = CONFIG_REJ;
    else
        pSendConfig->Code = (BYTE)ResultType;

    //
    // Remote wants no options, accept this
    //

    if ( NumOptionsInRequest == 0 )
    {
        // 
        // Accept no options only if we are not forcing encryption
        //

        if ( pCcpCb->fForceEncryption )
        {
            NumOptionsInRequest = 1;

            pCcpCb->Remote.Work.Negotiate = CCP_N_MSPPC;

            ResultType = CONFIG_NAK;
        }
    }

    //
    // If we are responding to the request with a NAK or an ACK then we make
    // that we choose only one option.
    //

    if ( ( ( ResultType == CONFIG_ACK ) || ( ResultType == CONFIG_NAK ) ) 
         && ( NumOptionsInRequest > 0 ) )
    {
        if ( pCcpCb->Remote.Work.Negotiate & CCP_N_MSPPC )
        {
            pCcpCb->Remote.Work.Negotiate = CCP_N_MSPPC;

            if ( ( dwRetCode = CcpMakeOption(  &(pCcpCb->Remote.Work),
                                            CCP_OPTION_MSPPC,
                                            pSendOption,
                                            lSendLength ) ) != NO_ERROR )
                return( dwRetCode );
        }
        else if ( pCcpCb->Remote.Work.Negotiate & CCP_N_OUI )
        {

            pCcpCb->Remote.Work.Negotiate = CCP_N_OUI;

            if ( ( dwRetCode = CcpMakeOption(  &(pCcpCb->Remote.Work),
                                            CCP_OPTION_OUI,
                                            pSendOption,
                                            lSendLength ) ) != NO_ERROR )
                return( dwRetCode );
        }
        else
        {
            pCcpCb->Remote.Work.Negotiate = CCP_N_PUBLIC;

            if ( ( dwRetCode = CcpMakeOption(  &(pCcpCb->Remote.Work),
                                            CCP_OPTION_MAX,
                                            pSendOption,
                                            lSendLength ) ) != NO_ERROR )
                return( dwRetCode );
        }

        if ( ( NumOptionsInRequest > 1 ) && ( ResultType == CONFIG_ACK ) )
        {
            pSendConfig->Code = CONFIG_NAK;
        }
        else
        {
            pSendConfig->Code = (BYTE)ResultType;
        }

        lSendLength -= pSendOption->Length;
    }

    //
    // If we are rejecting then we reset the current value to the old value
    //

    if ( pSendConfig->Code == CONFIG_REJ )
    {
        pCcpCb->fLastEncryptionBitSent = pCcpCb->fOldLastEncryptionBitSent;
    }
    else
    {
        pCcpCb->fOldLastEncryptionBitSent = pCcpCb->fLastEncryptionBitSent;
    }

    HostToWireFormat16( (WORD)(cbSendConfig - lSendLength),
                        pSendConfig->Length );

    return( NO_ERROR );
}

//**
//
// Call:        CcpConfigAckReceived
//
// Returns:
//
// Description:
//
DWORD
CcpConfigAckReceived(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pRecvConfig
)
{
    DWORD   dwRetCode;
    BYTE    ConfigReqSent[500];
    CCPCB * pCcpCb          = (CCPCB *)pWorkBuffer;
    DWORD   cbConfigReqSent = sizeof( ConfigReqSent );
    DWORD   dwLength        = WireToHostFormat16( pRecvConfig->Length )
                              - PPP_CONFIG_HDR_LEN;


    //
    // Get a copy of last request we sent
    //

    dwRetCode = CcpBuildOptionList( ConfigReqSent,
                                 &cbConfigReqSent,
                                 &(pCcpCb->Local.Work),
                                 pCcpCb->Local.Work.Negotiate );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    //
    // Overall buffer length should match
    //

    if ( dwLength != cbConfigReqSent )
    {
        return( ERROR_PPP_INVALID_PACKET );
    }

    //
    // Each byte should match
    //

    if ( memcmp( ConfigReqSent, pRecvConfig->Data, dwLength ) != 0 )
    {
        return( ERROR_PPP_INVALID_PACKET );
    }

    return( NO_ERROR );
}

//**
//
// Call:        CcpConfigNakReceived
//
// Returns:
//
// Description:
//
DWORD
CcpConfigNakReceived(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pRecvConfig
)
{
    DWORD        fAcceptableOptions = 0;
    DWORD        dwResult;
    DWORD        dwError;
    CCPCB *      pCcpCb         = (CCPCB *)pWorkBuffer;
    PPP_OPTION * pOption        = (PPP_OPTION*)(pRecvConfig->Data);
    DWORD        dwLastOption   = 0;
    LONG         lcbRecvConfig  = WireToHostFormat16( pRecvConfig->Length )
                                  - PPP_CONFIG_HDR_LEN;

    //
    //  First, process in order.  Then, process extra "important" options
    //

    while ( lcbRecvConfig > 0  )
    {
        if ( ( lcbRecvConfig -= pOption->Length ) < 0 )
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        //
        // Our requests are always sent out in order of increasing option type
        // values.
        //

        if ( pOption->Type < dwLastOption )
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        dwLastOption = pOption->Type;

        dwError = CcpCheckOption( pCcpCb, &(pCcpCb->Local), pOption,
                        &dwResult, FALSE);

        if ( NO_ERROR != dwError )
        {
            return( dwError );
        }

        //
        // Update the negotiation status. If we cannot accept this option,
        // then we will not send it again.
        //

        switch( pOption->Type )
        {

        case CCP_OPTION_OUI:

            if ( dwResult == CONFIG_REJ )
            {
                pCcpCb->Local.Work.Negotiate &= ~CCP_N_OUI;
            }

            if ( dwResult == CONFIG_ACK )
            {
                fAcceptableOptions |= CCP_N_OUI;
            }

            break;

        case CCP_OPTION_MSPPC:

            if ( dwResult == CONFIG_REJ )
            {
                pCcpCb->Local.Work.Negotiate &= ~CCP_N_MSPPC;
            }

            if ( dwResult == CONFIG_ACK )
            {
                fAcceptableOptions |= CCP_N_MSPPC;
            }

            break;

        default:

            if ( dwResult == CONFIG_REJ )
            {
                pCcpCb->Local.Work.Negotiate &= ~CCP_N_PUBLIC;
            }

            if ( dwResult == CONFIG_ACK )
            {
                fAcceptableOptions |= CCP_N_PUBLIC;
            }

            break;
        }

        pOption = (PPP_OPTION *)( (BYTE *)pOption + pOption->Length );
    }

    if ( pCcpCb->Local.Work.Negotiate == 0 )
    {
        if ( pCcpCb->fForceEncryption )
        {
            fAcceptableOptions = CCP_N_MSPPC;
        }
        else
        {
            fAcceptableOptions = 0;
        }
    }

    //
    // If there was more than one option that was acceptable give
    // preference to OUI, then to PUBLIC, then to MSPPC
    //

    if ( fAcceptableOptions & CCP_N_OUI )
    {
        pCcpCb->Local.Work.Negotiate = CCP_N_OUI;
    }
    else if ( fAcceptableOptions & CCP_N_PUBLIC )
    {
        pCcpCb->Local.Work.Negotiate = CCP_N_PUBLIC;
    }
    else if ( fAcceptableOptions & CCP_N_MSPPC )
    {
        pCcpCb->Local.Work.Negotiate = CCP_N_MSPPC;
    }

    return( NO_ERROR );
}

//**
//
// Call:        CcpConfigRejReceived
//
// Returns:
//
// Description:
//
DWORD
CcpConfigRejReceived(
    IN VOID *       pWorkBuffer,
    IN PPP_CONFIG * pRecvConfig
)
{
    DWORD        dwRetCode;
    CCPCB *      pCcpCb         = (CCPCB *)pWorkBuffer;
    PPP_OPTION * pOption        = (PPP_OPTION*)(pRecvConfig->Data);
    DWORD        dwLastOption   = 0;
    BYTE         ReqOption[500];
    LONG         lcbRecvConfig  = WireToHostFormat16( pRecvConfig->Length )
                                  - PPP_CONFIG_HDR_LEN;
    //
    // Process in order, checking for errors
    //

    while ( lcbRecvConfig > 0  )
    {
        if ( ( lcbRecvConfig -= pOption->Length ) < 0 )
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        //
        // The option should not have been modified in any way
        //

        if ( ( dwRetCode = CcpMakeOption( &(pCcpCb->Local.Work),
                                       pOption->Type,
                                       (PPP_OPTION *)ReqOption,
                                       sizeof( ReqOption ) ) ) != NO_ERROR )
            return( dwRetCode );

        if ( memcmp( ReqOption, pOption, pOption->Length ) != 0 )
        {
            return( ERROR_PPP_INVALID_PACKET );
        }

        dwLastOption = pOption->Type;

        //
        // The next configure request should not contain this option
        //

        if ( pOption->Type <= CCP_OPTION_MAX )
        {
            switch( pOption->Type )
            {

            case CCP_OPTION_OUI:
                pCcpCb->Local.Work.Negotiate &= ~CCP_N_OUI;
                break;

            case CCP_OPTION_MSPPC:
                pCcpCb->Local.Work.Negotiate &= ~CCP_N_MSPPC;
                break;

            default:
                pCcpCb->Local.Work.Negotiate &= ~CCP_N_PUBLIC;
                break;
            }

        }

        pOption = (PPP_OPTION *)( (BYTE *)pOption + pOption->Length );

    }

    if ( pCcpCb->Local.Work.Negotiate == 0 )
    {
        return( ERROR_PPP_NOT_CONVERGING );
    }

    return( NO_ERROR );
}

//**
//
// Call:        CcpThisLayerStarted
//
// Returns:
//
// Description:
//
DWORD
CcpThisLayerStarted(
    IN VOID * pWorkBuffer
)
{
    return( NO_ERROR );
}

//**
//
// Call:        CcpThisLayerFinished
//
// Returns:
//
// Description:
//
DWORD
CcpThisLayerFinished(
    IN VOID * pWorkBuffer
)
{
    return( NO_ERROR );
}

//**
//
// Call:        CcpThisLayerUp
//
// Returns:     None
//
// Description: Sets the framing parameters to what was negotiated.
//
DWORD
CcpThisLayerUp(
    IN VOID * pWorkBuffer
)
{
    DWORD                dwRetCode = NO_ERROR;
    CCPCB *              pCcpCb = (CCPCB *)pWorkBuffer;
    RAS_COMPRESSION_INFO RasCompInfoSend;
    RAS_COMPRESSION_INFO RasCompInfoRecv;

    if ( pCcpCb->Local.Work.Negotiate == CCP_N_MSPPC )
    {
        TraceCcp("CCP Send MSPPC bits negotiated = 0x%x",
               pCcpCb->Local.Work.CompInfo.RCI_MSCompressionType );

        pCcpCb->Local.Work.CompInfo.RCI_MacCompressionType = CCP_OPTION_MAX + 1;
    }
    else if ( pCcpCb->Local.Work.Negotiate == CCP_N_PUBLIC )
    {
        TraceCcp("CCP Send PUBLIC");

        pCcpCb->Local.Work.CompInfo.RCI_MSCompressionType = 0;

    }
    else if ( pCcpCb->Local.Work.Negotiate == CCP_N_OUI )
    {
        TraceCcp("CCP Send OUI");

        pCcpCb->Local.Work.CompInfo.RCI_MSCompressionType = 0;
    }

    if ( pCcpCb->Remote.Work.Negotiate == CCP_N_MSPPC )
    {
        TraceCcp("CCP Recv MSPPC bits negotiated = 0x%x",
                pCcpCb->Remote.Work.CompInfo.RCI_MSCompressionType );

        pCcpCb->Remote.Work.CompInfo.RCI_MacCompressionType = CCP_OPTION_MAX+1;
    }
    else if ( pCcpCb->Remote.Work.Negotiate == CCP_N_PUBLIC )
    {
        TraceCcp("CCP Recv PUBLIC");

        pCcpCb->Remote.Work.CompInfo.RCI_MSCompressionType = 0;
    }
    else if ( pCcpCb->Remote.Work.Negotiate == CCP_N_OUI )
    {
        TraceCcp("CCP Recv OUI");

        pCcpCb->Remote.Work.CompInfo.RCI_MSCompressionType = 0;
    }

    dwRetCode = RasCompressionGetInfo( pCcpCb->hPort,
                                       &RasCompInfoSend,
                                       &RasCompInfoRecv );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    CopyMemory( pCcpCb->Local.Work.CompInfo.RCI_LMSessionKey,
            RasCompInfoSend.RCI_LMSessionKey,
            MAX_SESSIONKEY_SIZE );

    CopyMemory( pCcpCb->Local.Work.CompInfo.RCI_UserSessionKey,
            RasCompInfoSend.RCI_UserSessionKey,
            MAX_USERSESSIONKEY_SIZE );

    CopyMemory( pCcpCb->Local.Work.CompInfo.RCI_Challenge,
            RasCompInfoSend.RCI_Challenge,
            MAX_CHALLENGE_SIZE );

    CopyMemory( pCcpCb->Local.Work.CompInfo.RCI_NTResponse,
            RasCompInfoSend.RCI_NTResponse,
            MAX_NT_RESPONSE_SIZE );

    pCcpCb->Local.Work.CompInfo.RCI_Flags = CCP_SET_COMPTYPE;

    CopyMemory( pCcpCb->Remote.Work.CompInfo.RCI_LMSessionKey,
            RasCompInfoRecv.RCI_LMSessionKey,
            MAX_SESSIONKEY_SIZE );

    CopyMemory( pCcpCb->Remote.Work.CompInfo.RCI_UserSessionKey,
            RasCompInfoRecv.RCI_UserSessionKey,
            MAX_USERSESSIONKEY_SIZE );

    CopyMemory( pCcpCb->Remote.Work.CompInfo.RCI_Challenge,
            RasCompInfoRecv.RCI_Challenge,
            MAX_CHALLENGE_SIZE );

    CopyMemory( pCcpCb->Remote.Work.CompInfo.RCI_NTResponse,
            RasCompInfoRecv.RCI_NTResponse,
            MAX_NT_RESPONSE_SIZE );

    pCcpCb->Remote.Work.CompInfo.RCI_Flags = CCP_SET_COMPTYPE;

    if ( pCcpCb->fServer )
    {
        pCcpCb->Local.Work.CompInfo.RCI_Flags  |= CCP_IS_SERVER;
        pCcpCb->Remote.Work.CompInfo.RCI_Flags |= CCP_IS_SERVER;
    }

    dwRetCode = RasCompressionSetInfo( pCcpCb->hPort,
                                       &(pCcpCb->Local.Work.CompInfo),
                                       &(pCcpCb->Remote.Work.CompInfo) );

    return( dwRetCode );

}

//**
//
// Call:        CcpThisLayerDown
//
// Returns:     NO_ERROR - Success
//              Non-zero return from RasPortSetFraming - Failure
//
// Description: Simply sets the framing parameters to the default values,
//              ie. ACCM = 0xFFFFFFFF, everything else is zeros.
//
DWORD
CcpThisLayerDown(
    IN VOID * pWorkBuffer
)
{
    CCPCB *              pCcpCb = (CCPCB *)pWorkBuffer;
    RAS_COMPRESSION_INFO CompInfo;

    ZeroMemory( &CompInfo, sizeof( CompInfo ) );

    CompInfo.RCI_Flags = CCP_SET_COMPTYPE;

    CompInfo.RCI_MSCompressionType  = 0;
    CompInfo.RCI_MacCompressionType = CCP_OPTION_MAX + 1;
    CopyMemory( CompInfo.RCI_LMSessionKey,
            pCcpCb->Local.Want.CompInfo.RCI_LMSessionKey,
            sizeof( CompInfo.RCI_LMSessionKey ) );

    CopyMemory( CompInfo.RCI_UserSessionKey,
            pCcpCb->Local.Want.CompInfo.RCI_UserSessionKey,
            sizeof( CompInfo.RCI_UserSessionKey ) );

    CopyMemory( CompInfo.RCI_Challenge,
            pCcpCb->Local.Want.CompInfo.RCI_Challenge,
            sizeof( CompInfo.RCI_Challenge ) );

    if ( pCcpCb->fForceEncryption )
    {
        pCcpCb->Local.Work.CompInfo.RCI_Flags  |= CCP_PAUSE_DATA;
        pCcpCb->Remote.Work.CompInfo.RCI_Flags |= CCP_PAUSE_DATA;
    }

    RasCompressionSetInfo( pCcpCb->hPort, &CompInfo, &CompInfo );

    return( NO_ERROR );
}

//**
//
// Call:        CcpGetNegotiatedInfo
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will return the type of compression and associated date 
//              negotiated for both directions.
//
DWORD
CcpGetNegotiatedInfo(
    IN  VOID *            pWorkBuffer,
    OUT PPP_CCP_RESULT *  pCcpResult 
)
{
    CCPCB * pCcpCb = (CCPCB *)pWorkBuffer;

    if ( pCcpCb->Local.Work.Negotiate == CCP_N_MSPPC )
    {
        pCcpResult->dwSendProtocol = CCP_OPTION_MSPPC;
        pCcpResult->dwSendProtocolData = 
                        pCcpCb->Local.Work.CompInfo.RCI_MSCompressionType;
    }
    else 
    {
        pCcpResult->dwSendProtocol = 
                        pCcpCb->Local.Work.CompInfo.RCI_MacCompressionType;
    }

    if ( pCcpCb->Remote.Work.Negotiate == CCP_N_MSPPC )
    {
        pCcpResult->dwReceiveProtocol = CCP_OPTION_MSPPC;
        pCcpResult->dwReceiveProtocolData =
                        pCcpCb->Remote.Work.CompInfo.RCI_MSCompressionType;
    }
    else 
    {
        pCcpResult->dwReceiveProtocol = 
                        pCcpCb->Remote.Work.CompInfo.RCI_MacCompressionType;
    }

    return( NO_ERROR );
}

//**
//
// Call:        CcpGetInfo
//
// Returns:     NO_ERROR                - Success
//              ERROR_INVALID_PARAMETER - Protocol id is unrecogized
//
// Description: This entry point is called for get all information for the
//              control protocol in this module.
//
DWORD
CcpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
)
{
    if ( dwProtocolId != PPP_CCP_PROTOCOL )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    ZeroMemory( pCpInfo, sizeof( PPPCP_INFO ) );

    pCpInfo->Protocol                   = PPP_CCP_PROTOCOL;
    lstrcpy(pCpInfo->SzProtocolName, "CCP");
    pCpInfo->Recognize                  = CODE_REJ + 1;
    pCpInfo->RasCpInit                  = CcpInit;
    pCpInfo->RasCpBegin                 = CcpBegin;
    pCpInfo->RasCpEnd                   = CcpEnd;
    pCpInfo->RasCpReset                 = CcpReset;
    pCpInfo->RasCpThisLayerStarted      = CcpThisLayerStarted;
    pCpInfo->RasCpThisLayerFinished     = CcpThisLayerFinished;
    pCpInfo->RasCpThisLayerUp           = CcpThisLayerUp;
    pCpInfo->RasCpThisLayerDown         = CcpThisLayerDown;
    pCpInfo->RasCpMakeConfigRequest     = CcpMakeConfigRequest;
    pCpInfo->RasCpMakeConfigResult      = CcpMakeConfigResult;
    pCpInfo->RasCpConfigAckReceived     = CcpConfigAckReceived;
    pCpInfo->RasCpConfigNakReceived     = CcpConfigNakReceived;
    pCpInfo->RasCpConfigRejReceived     = CcpConfigRejReceived;
    pCpInfo->RasCpGetNegotiatedInfo     = CcpGetNegotiatedInfo;

    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\ceapcfg.h ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _CEAPCFG_H_
#define _CEAPCFG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <rrascfg.h>    // IEAPProviderConfig declarations

#include "resource.h"

// Define this here so that our macros will expand correctly
#define IMPL

// External references
extern const CLSID  CLSID_EapCfg;

class ATL_NO_VTABLE CEapCfg :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CEapCfg, &CLSID_EapCfg>,
    public IEAPProviderConfig
{
public:
    CEapCfg()  {}

DECLARE_REGISTRY_RESOURCEID(IDR_EAPCFG)
DECLARE_NOT_AGGREGATABLE(CEapCfg)

BEGIN_COM_MAP(CEapCfg)
    COM_INTERFACE_ENTRY(IEAPProviderConfig)
END_COM_MAP()

public:
    // This is the declaration of the UI interface members.
    // See rrascfg.idl for the prototypes
    DeclareIEAPProviderConfigMembers(IMPL);
    
};

#endif // _CEAPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\debug.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** debug.h
** Debug and tracing macros
**
** 08/24/95 Steve Cobb
**
** To use TRACE/DUMP:
**
**     These calls encapsulate dynamically linking to the tracing utilities in
**     RTUTIL.DLL and provide shortcut macros to access them and to prevent
**     their inclusion in non-DBG builds (at least, when FREETRACE is 0).
**
**     Before calling any TRACE/DUMP macros call:
**         DEBUGINIT( "YOURMODULE" );
**
**     Use the TRACEx and DUMPx macros to print messages to the log as defined
**     by the associated RTUTIL.DLL routines.  Currently, this code is removed
**     from non-DBG builds.  A few examples:
**
**       TRACE("MyRoutine");
**       TRACE2("MyRoutine=%d,c=%s",dwErr,psz);
**
**     After done calling TRACE/DUMP macros call:
**         DEBUGTERM();
**
**     Static libraries can safely use TRACE/DUMP without calling DEBUGINIT
**     and DEBUGTERM.  If the caller sets up these in his module, the library
**     trace will appear as part of caller's module trace.
**
** To use ASSERT:
**
**     Use ASSERT to assert that a given expression is true, breaking in the
**     tracing console indicating the file and line number of the ASSERTION if
**     it fails.  It is not necessary to call DEBUGINIT and DEBUGTERM to use
**     ASSERT.  For example:
**
**         hwndOwner = GetParent( hwnd );
**         ASSERT(hwndOwner!=NULL);
*/

#ifndef _DEBUG_H_
#define _DEBUG_H_


#define FREETRACE 1


/*----------------------------------------------------------------------------
** Datatypes and global declarations (defined in debug.c)
**----------------------------------------------------------------------------
*/

#if (DBG || FREETRACE)

extern DWORD g_dwTraceId;

typedef DWORD (APIENTRY * TRACEREGISTEREXA)( LPCSTR, DWORD );
extern TRACEREGISTEREXA g_pTraceRegisterExA;

typedef DWORD (APIENTRY * TRACEDEREGISTERA)( DWORD );
extern TRACEDEREGISTERA g_pTraceDeregisterA;

typedef DWORD (APIENTRY * TRACEDEREGISTEREXA)( DWORD, DWORD );
extern TRACEDEREGISTEREXA g_pTraceDeregisterExA;

typedef DWORD (APIENTRY * TRACEPRINTFA)( DWORD, LPCSTR, ... );
extern TRACEPRINTFA g_pTracePrintfA;

typedef DWORD (APIENTRY * TRACEPRINTFEXA)( DWORD, DWORD, LPCSTR, ... );
extern TRACEPRINTFEXA g_pTracePrintfExA;

typedef DWORD (APIENTRY * TRACEDUMPEXA)( DWORD, DWORD, LPBYTE, DWORD, DWORD, BOOL, LPCSTR );
extern TRACEDUMPEXA g_pTraceDumpExA;

typedef VOID (APIENTRY * ROUTERASSERT)( PSTR, PSTR, DWORD, PSTR );
extern ROUTERASSERT g_pRouterAssert;

#endif // (DBG || FREETRACE)


/*----------------------------------------------------------------------------
** Macros
**----------------------------------------------------------------------------
*/

/* Debug macros.  This code does not appear in non-DBG builds unless FREETRACE
** is defined.
**
** The trailing number indicates the number of printf arguments in the format
** string.  The argument is converted before output so that the output file
** remains entirely ANSI.
*/
#if (DBG || FREETRACE)

#define TRACE(a) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a)
#define TRACE1(a,b) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b)
#define TRACE2(a,b,c) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c)
#define TRACE3(a,b,c,d)\
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d)
#define TRACE4(a,b,c,d,e) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e)
#define TRACE5(a,b,c,d,e,f) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e,f)
#define TRACE6(a,b,c,d,e,f,g) \
            if (g_dwTraceId!=-1) g_pTracePrintfA(g_dwTraceId,a,b,c,d,e,f,g)
#define TRACEX(l,a) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a)
#define TRACEX1(l,a,b) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b)
#define TRACEX2(l,a,b,c) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c)
#define TRACEX3(l,a,b,c,d)\
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d)
#define TRACEX4(l,a,b,c,d,e) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e)
#define TRACEX5(l,a,b,c,d,e,f) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e,f)
#define TRACEX6(l,a,b,c,d,e,f,h) \
            if (g_dwTraceId!=-1) g_pTracePrintfExA(g_dwTraceId,l,a,b,c,d,e,f,h)
#define DUMPB(p,c) \
            if (g_dwTraceId!=-1) g_pTraceDumpExA(g_dwTraceId,1,(LPBYTE)p,c,1,1,NULL)
#define DUMPDW(p,c) \
            if (g_dwTraceId!=-1) g_pTraceDumpExA(g_dwTraceId,1,(LPBYTE)p,c,4,1,NULL)
#if defined(ASSERT)
#undef ASSERT
#endif
#define ASSERT(a) \
            if ((g_dwTraceId!=-1) && !(a)) g_pRouterAssert(#a,__FILE__,__LINE__,NULL)
#define DEBUGINIT(s) \
            DebugInit(s)
#define DEBUGTERM() \
            DebugTerm()
#else

#define TRACE(a)
#define TRACE1(a,b)
#define TRACE2(a,b,c)
#define TRACE3(a,b,c,d)
#define TRACE4(a,b,c,d,e)
#define TRACE5(a,b,c,d,e,f)
#define TRACE6(a,b,c,d,e,f,g)
#define TRACEX(l,a)
#define TRACEX1(l,a,b)
#define TRACEX2(l,a,b,c)
#define TRACEX3(l,a,b,c,d)
#define TRACEX4(l,a,b,c,d,e)
#define TRACEX5(l,a,b,c,d,e,f)
#define TRACEX6(l,a,b,c,d,e,f,g)
#define DUMPB(p,c)
#define DUMPDW(p,c)
#if defined(ASSERT)
#undef ASSERT
#endif
#define ASSERT(a)
#define DEBUGINIT(s)
#define DEBUGTERM()

#endif


/*----------------------------------------------------------------------------
** Prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
DebugInit(
    IN CHAR* pszModule );

VOID
DebugTerm(
    void );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\ezlogon.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
// FILE
//
//    ezlogon.c
//
// SYNOPSIS
//
//    Defines the IAS wrapper around LsaLogonUser
//
// MODIFICATION HISTORY
//
//    08/15/1998    Original version.
//    09/09/1998    Fix AV when logon domain doesn't match user domain.
//    10/02/1998    NULL out handle when LsaLogonUser fails.
//    10/11/1998    Use SubStatus for STATUS_ACCOUNT_RESTRICTION.
//    10/22/1998    PIAS_LOGON_HOURS is now a mandatory parameter.
//    01/28/1999    Remove LogonDomainName check.
//    04/19/1999    Add IASPurgeTicketCache.
//
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <sha.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <dsgetdc.h>
#include <ntlsa.h>
#include <kerberos.h>
#include <windows.h>
#include <ezlogon.h>
#include <malloc.h>

//#include <iaslsa.h>


//#define NT_RESPONSE_LENGTH                     24
//#define LM_RESPONSE_LENGTH                     24


//////////
// Handle to the IAS Logon Process.
//////////
LSA_HANDLE theLogonProcess;

//////////
// The MSV1_0 authentication package.
//////////
ULONG theMSV1_0_Package;

CONST CHAR LOGON_PROCESS_NAME[] = "CHAP";
CONST CHAR TOKEN_SOURCE_NAME[TOKEN_SOURCE_LENGTH] = "CHAP";

// Number of milliseconds in a week.
#define MSEC_PER_WEEK (1000 * 60 * 60 * 24 * 7)

//////////
// Misc. global variables used for logons.
//////////
LSA_HANDLE theLogonProcess;      // The handle for the logon process.
ULONG theMSV1_0_Package;         // The MSV1_0 authentication package.
ULONG theKerberosPackage;        // The Kerberos authentication package.
STRING theOriginName;            // The origin of the logon requests.
TOKEN_SOURCE theSourceContext;   // The source context of the logon requests.

//////////
// Domain names.
//////////
WCHAR theAccountDomain [DNLEN + 1];   // Local account domain.
WCHAR theRegistryDomain[DNLEN + 1];   // Registry override for default domain.

//////////
// SID's
//////////
PSID theAccountDomainSid;
PSID theBuiltinDomainSid;

//////////
// UNC name of the local computer.
//////////
WCHAR theLocalServer[CNLEN + 3];

SECURITY_QUALITY_OF_SERVICE QOS =
{
   sizeof(SECURITY_QUALITY_OF_SERVICE),  // Length
   SecurityImpersonation,                // ImpersonationLevel
   SECURITY_DYNAMIC_TRACKING,            // ContextTrackingMode
   FALSE                                 // EffectiveOnly
};

OBJECT_ATTRIBUTES theObjectAttributes =
{
   sizeof(OBJECT_ATTRIBUTES),            // Length
   NULL,                                 // RootDirectory
   NULL,                                 // ObjectName
   0,                                    // Attributes
   NULL,                                 // SecurityDescriptor
   &QOS                                  // SecurityQualityOfService
};


/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASLogonInitialize
//
// DESCRIPTION
//
//    Registers the logon process.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLogonInitialize( VOID )
{
   DWORD status;
   BOOLEAN wasEnabled;
   LSA_STRING processName, packageName;
   PPOLICY_ACCOUNT_DOMAIN_INFO padi;
   LSA_OPERATIONAL_MODE opMode;
   DWORD cbData = 0;
   LSA_HANDLE hLsa;
   //////////
   // Enable SE_TCB_PRIVILEGE.
   //////////

   status = RtlAdjustPrivilege(
                SE_TCB_PRIVILEGE,
                TRUE,
                FALSE,
                &wasEnabled
                );
   if (!NT_SUCCESS(status)) { goto exit; }

   //////////
   // Register as a logon process.
   //////////

   RtlInitString(
       &processName,
       LOGON_PROCESS_NAME
       );

   status = LsaRegisterLogonProcess(
                &processName,
                &theLogonProcess,
                &opMode
                );
   if (!NT_SUCCESS(status)) { goto exit; }

   //////////
   // Lookup the MSV1_0 authentication package.
   //////////

   RtlInitString(
       &packageName,
       MSV1_0_PACKAGE_NAME
       );

   status = LsaLookupAuthenticationPackage(
                theLogonProcess,
                &packageName,
                &theMSV1_0_Package
                );
   if (!NT_SUCCESS(status)) { goto deregister; }

   //////////
   // Lookup the Kerberos authentication package.
   //////////

   RtlInitString(
       &packageName,
       MICROSOFT_KERBEROS_NAME_A
       );

   status = LsaLookupAuthenticationPackage(
                theLogonProcess,
                &packageName,
                &theKerberosPackage
                );
   if (!NT_SUCCESS(status)) { goto deregister; }

   //////////
   // Initialize the source context.
   //////////

   memcpy(theSourceContext.SourceName,
          TOKEN_SOURCE_NAME,
          TOKEN_SOURCE_LENGTH);
   status = NtAllocateLocallyUniqueId(
                &theSourceContext.SourceIdentifier
                );
   if (!NT_SUCCESS(status)) { goto deregister; }


   /////////
   /// Initialize the account domain and local domain
   ////////
  wcscpy(theLocalServer, L"\\\\");
  cbData = CNLEN + 1;
  if (!GetComputerNameW(theLocalServer + 2, &cbData))
  { return GetLastError(); }


  //////////
  // Open a handle to the LSA.
  //////////

  status = LsaOpenPolicy(
               NULL,
               &theObjectAttributes,
               POLICY_VIEW_LOCAL_INFORMATION,
               &hLsa
               );
  if (!NT_SUCCESS(status)) { goto deregister; }

  //////////
  // Get the account domain information.
  //////////

  status = LsaQueryInformationPolicy(
               hLsa,
               PolicyAccountDomainInformation,
               (PVOID*)&padi
               );
  LsaClose(hLsa);
  if (!NT_SUCCESS(status)) { goto deregister; }

  // Save the domain name.
  wcsncpy(theAccountDomain, padi->DomainName.Buffer, DNLEN);
  _wcsupr(theAccountDomain);
  
   return NO_ERROR;

deregister:
   LsaDeregisterLogonProcess(theLogonProcess);
   theLogonProcess = NULL;
//setup the logon domain for the machine
exit:
   return RtlNtStatusToDosError(status);
}

/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASLogonShutdown
//
// DESCRIPTION
//
//    Deregisters the logon process.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASLogonShutdown( VOID )
{
   LsaDeregisterLogonProcess(theLogonProcess);
   theLogonProcess = NULL;
}

/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASInitAuthInfo
//
// DESCRIPTION
//
//    Initializes the fields common to all MSV1_0_LM20* structs.
//
///////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
IASInitAuthInfo(
    IN PVOID AuthInfo,
    IN DWORD FixedLength,
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    OUT PBYTE* Data
    )
{
   PMSV1_0_LM20_LOGON logon;

   // Zero out the fixed data.
   memset(AuthInfo, 0, FixedLength);

   // Set Data to point just past the fixed struct.
   *Data = FixedLength + (PBYTE)AuthInfo;

   // This cast is safe since all LM20 structs have the same initial fields.
   logon = (PMSV1_0_LM20_LOGON)AuthInfo;

   // We always do Network logons.
   logon->MessageType = MsV1_0NetworkLogon;

   // Copy in the strings common to all logons.
   IASInitUnicodeString(logon->LogonDomainName, *Data, Domain);
   IASInitUnicodeString(logon->UserName,        *Data, UserName);
   IASInitUnicodeString(logon->Workstation,     *Data, L"");
}

/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASLogonUser
//
// DESCRIPTION
//
//    Wrapper around LsaLogonUser.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLogonUser(
    IN PVOID AuthInfo,
    IN ULONG AuthInfoLength,
    OUT PMSV1_0_LM20_LOGON_PROFILE *Profile,
    OUT PHANDLE Token
    )
{
   NTSTATUS status, SubStatus;
   PMSV1_0_LM20_LOGON_PROFILE ProfileBuffer;
   ULONG ProfileBufferLength;
   LUID LogonId;
   QUOTA_LIMITS Quotas;

   // Make sure the OUT arguments are NULL.
   *Token = NULL;
   ProfileBuffer = NULL;

   status = LsaLogonUser(
                theLogonProcess,
                &theOriginName,
                Network,
                theMSV1_0_Package,
                AuthInfo,
                AuthInfoLength,
                NULL,
                &theSourceContext,
                &ProfileBuffer,
                &ProfileBufferLength,
                &LogonId,
                Token,
                &Quotas,
                &SubStatus
                );

   if (!NT_SUCCESS(status))
   {
      // For account restrictions, we can get a more descriptive error
      // from the SubStatus.
      if (status == STATUS_ACCOUNT_RESTRICTION && !NT_SUCCESS(SubStatus))
      {
         status = SubStatus;
      }

      // Sometimes LsaLogonUser returns an invalid handle value on failure.
      *Token = NULL;
   }

   if (Profile)
   {
      // Return the profile if requested ...
      *Profile = ProfileBuffer;
   }
   else if (ProfileBuffer)
   {
      // ... otherwise free it.
      LsaFreeReturnBuffer(ProfileBuffer);
   }

   return RtlNtStatusToDosError(status);
}

//
// All MSCHAP Related stuff goes here
//
///////////////////////////////////////////////////////////////////////////////
//
// Various constants used for MS-CHAP v2
//
///////////////////////////////////////////////////////////////////////////////

UCHAR AuthMagic1[39] =
{
   0x4D, 0x61, 0x67, 0x69, 0x63, 0x20, 0x73, 0x65, 0x72, 0x76,
   0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6C, 0x69, 0x65,
   0x6E, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67,
   0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74
};

UCHAR AuthMagic2[41] =
{
   0x50, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B,
   0x65, 0x20, 0x69, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x6D, 0x6F,
   0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6F, 0x6E,
   0x65, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F,
   0x6E
};

UCHAR SHSpad1[40] =
{
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

UCHAR SHSpad2[40] =
{
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2
};

UCHAR KeyMagic1[27] =
{
   0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74,
   0x68, 0x65, 0x20, 0x4D, 0x50, 0x50, 0x45, 0x20, 0x4D,
   0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4B, 0x65, 0x79
};

UCHAR KeyMagic2[84] =
{
   0x4F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6C, 0x69,
   0x65, 0x6E, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2C, 0x20,
   0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
   0x65, 0x20, 0x73, 0x65, 0x6E, 0x64, 0x20, 0x6B, 0x65, 0x79,
   0x3B, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
   0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65,
   0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
   0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
   0x6B, 0x65, 0x79, 0x2E
};

UCHAR KeyMagic3[84] =
{
   0x4F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6C, 0x69,
   0x65, 0x6E, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2C, 0x20,
   0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
   0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
   0x6B, 0x65, 0x79, 0x3B, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68,
   0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73,
   0x69, 0x64, 0x65, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73,
   0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6E, 0x64, 0x20,
   0x6B, 0x65, 0x79, 0x2E
};


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASLogonMSCHAP
//
// DESCRIPTION
//
//    Performs MS-CHAP authentication against the NT SAM database.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLogonMSCHAP(
    PCWSTR UserName,
    PCWSTR Domain,
    PBYTE Challenge,
    PBYTE NtResponse,
    PBYTE LmResponse,
    PIAS_MSCHAP_PROFILE Profile,
    PHANDLE Token
    )
{
   DWORD status;
   ULONG authLength;
   PMSV1_0_LM20_LOGON authInfo;
   PBYTE data;
   PMSV1_0_LM20_LOGON_PROFILE logonProfile;
   DWORD len;

   // Calculate the length of the authentication info.
   authLength = sizeof(MSV1_0_LM20_LOGON) +
                (wcslen(Domain) + wcslen(UserName)) * sizeof(WCHAR) +
                (LmResponse ? LM_RESPONSE_LENGTH : 0) +
                (NtResponse ? NT_RESPONSE_LENGTH : 0);

   
    
    __try 
    {
       // Allocate a buffer on the stack.
       authInfo = (PMSV1_0_LM20_LOGON)_alloca(authLength);

    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) 
    {
        _resetstkoflw();
    }

   // Initialize the struct.
   IASInitAuthInfo(
       authInfo,
       sizeof(MSV1_0_LM20_LOGON),
       UserName,
       Domain,
       &data
       );

   /////////
   // Fill in the challenges and responses.
   /////////

   IASInitFixedArray(
       authInfo->ChallengeToClient,
       Challenge
       );

   if (NtResponse)
   {
      IASInitOctetString(
          authInfo->CaseSensitiveChallengeResponse,
          data,
          NtResponse,
          NT_RESPONSE_LENGTH
          );
   }
   else
   {
      memset(
          &authInfo->CaseSensitiveChallengeResponse,
          0,
          sizeof(authInfo->CaseSensitiveChallengeResponse)
          );
   }

   if (LmResponse)
   {
      IASInitOctetString(
          authInfo->CaseInsensitiveChallengeResponse,
          data,
          LmResponse,
          LM_RESPONSE_LENGTH
          );
   }
   else
   {
      memset(
          &authInfo->CaseInsensitiveChallengeResponse,
          0,
          sizeof(authInfo->CaseInsensitiveChallengeResponse)
          );
   }

   // Set the parameters.
   authInfo->ParameterControl = DEFAULT_PARAMETER_CONTROL;

   status = IASLogonUser(
                authInfo,
                authLength,
                &logonProfile,
                Token
                );
   
   if (status == NO_ERROR)
   {
      Profile->KickOffTime.QuadPart = logonProfile->KickOffTime.QuadPart;

      // NOTE Workaround for LSA IA64 WINBUG # 126930 6/13/2000 IA64: 
      //      LsaLogonUser succeeds but returns NULL LogonDomainName.

      if (logonProfile->LogonDomainName.Buffer)
      {
         wcsncpy(Profile->LogonDomainName,
                 logonProfile->LogonDomainName.Buffer,
                 DNLEN);
      }
      else
      {
         memset(Profile->LogonDomainName, 0, sizeof(Profile->LogonDomainName));
      }

      IASInitFixedArray(
          Profile->LanmanSessionKey,
          logonProfile->LanmanSessionKey
          );

      IASInitFixedArray(
          Profile->UserSessionKey,
          logonProfile->UserSessionKey
          );

      LsaFreeReturnBuffer(logonProfile);
   }

   return status;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASLogonMSCHAPv2
//
// DESCRIPTION
//
//    Performs MS-CHAP v2 authentication.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASLogonMSCHAPv2(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN PCSTR HashUserName,
    IN PBYTE Challenge,
    IN DWORD ChallengeLength,
    IN PBYTE Response,
    IN PBYTE PeerChallenge,
    OUT PIAS_MSCHAP_V2_PROFILE Profile,
    OUT PHANDLE Token
    )
{
   A_SHA_CTX context;
   BYTE digest[A_SHA_DIGEST_LEN], masterKey[A_SHA_DIGEST_LEN];
   BYTE computedChallenge[MSV1_0_CHALLENGE_LENGTH];
   IAS_MSCHAP_PROFILE v1profile;
   DWORD status;

   /////////
   // Compute the v2 challenge.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, PeerChallenge, 16);
   A_SHAUpdate(&context, Challenge, ChallengeLength);
   A_SHAUpdate(&context, (PBYTE)HashUserName, strlen(HashUserName));
   A_SHAFinal(&context, digest);
   memcpy(computedChallenge, digest, sizeof(computedChallenge));

   /////////
   // Authenticate the user.
   /////////

   status = IASLogonMSCHAP(
                UserName,
                Domain,
                computedChallenge,
                Response,
                NULL,
                &v1profile,
                Token
                );
   if (status != NO_ERROR) { return status; }

   /////////
   // Generate authenticator response.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, v1profile.UserSessionKey, 16);
   A_SHAUpdate(&context, Response, NT_RESPONSE_LENGTH);
   A_SHAUpdate(&context, AuthMagic1, sizeof(AuthMagic1));
   A_SHAFinal(&context, digest);

   A_SHAInit(&context);
   A_SHAUpdate(&context, digest, sizeof(digest));
   A_SHAUpdate(&context, computedChallenge, sizeof(computedChallenge));
   A_SHAUpdate(&context, AuthMagic2, sizeof(AuthMagic2));
   A_SHAFinal(&context, digest);

   memcpy(Profile->AuthResponse, digest, _AUTHENTICATOR_RESPONSE_LENGTH);

   /////////
   // Generate master key.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, v1profile.UserSessionKey, 16);
   A_SHAUpdate(&context, Response, NT_RESPONSE_LENGTH);
   A_SHAUpdate(&context, KeyMagic1, sizeof(KeyMagic1));
   A_SHAFinal(&context, masterKey);

   /////////
   // Generate receive key.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, masterKey, 16);
   A_SHAUpdate(&context, SHSpad1, sizeof(SHSpad1));
   A_SHAUpdate(&context, KeyMagic2, sizeof(KeyMagic2));
   A_SHAUpdate(&context, SHSpad2, sizeof(SHSpad2));
   A_SHAFinal(&context, digest);

   memcpy(Profile->RecvSessionKey, digest, MSV1_0_USER_SESSION_KEY_LENGTH);

   /////////
   // Generate send key.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, masterKey, 16);
   A_SHAUpdate(&context, SHSpad1, sizeof(SHSpad1));
   A_SHAUpdate(&context, KeyMagic3, sizeof(KeyMagic3));
   A_SHAUpdate(&context, SHSpad2, sizeof(SHSpad2));
   A_SHAFinal(&context, digest);

   memcpy(Profile->SendSessionKey, digest, MSV1_0_USER_SESSION_KEY_LENGTH);

   /////////
   // Copy the logon domain.
   /////////

   memcpy(
       Profile->LogonDomainName,
       v1profile.LogonDomainName,
       sizeof(Profile->LogonDomainName)
       );

   return NO_ERROR;
}

DWORD
WINAPI
IASGetSendRecvSessionKeys( PBYTE pbUserSessionKey,
                           DWORD dwUserSessionKeyLen,
                           PBYTE pbResponse,
                           DWORD dwResponseLen,
                           OUT PBYTE pbSendKey,
                           OUT PBYTE pbRecvKey
                         )
{
    DWORD   dwRetCode = NO_ERROR;
    A_SHA_CTX context;
    BYTE digest[A_SHA_DIGEST_LEN], masterKey[A_SHA_DIGEST_LEN];

   /////////
   // Generate master key.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, pbUserSessionKey, dwUserSessionKeyLen);
   A_SHAUpdate(&context, pbResponse, dwResponseLen);
   A_SHAUpdate(&context, KeyMagic1, sizeof(KeyMagic1));
   A_SHAFinal(&context, masterKey);

   /////////
   // Generate receive key.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, masterKey, 16);
   A_SHAUpdate(&context, SHSpad1, sizeof(SHSpad1));
   A_SHAUpdate(&context, KeyMagic2, sizeof(KeyMagic2));
   A_SHAUpdate(&context, SHSpad2, sizeof(SHSpad2));
   A_SHAFinal(&context, digest);

   memcpy(pbRecvKey, digest, MSV1_0_USER_SESSION_KEY_LENGTH);

   /////////
   // Generate send key.
   /////////

   A_SHAInit(&context);
   A_SHAUpdate(&context, masterKey, 16);
   A_SHAUpdate(&context, SHSpad1, sizeof(SHSpad1));
   A_SHAUpdate(&context, KeyMagic3, sizeof(KeyMagic3));
   A_SHAUpdate(&context, SHSpad2, sizeof(SHSpad2));
   A_SHAFinal(&context, digest);

    memcpy(pbSendKey, digest, MSV1_0_USER_SESSION_KEY_LENGTH);
    return dwRetCode;
}



#if 0
/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASCheckAccountRestrictions
//
// DESCRIPTION
//
//    Checks whether an account can be used for logon.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASCheckAccountRestrictions(
    IN PLARGE_INTEGER AccountExpires,
    IN PIAS_LOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER SessionTimeout
    )
{
   LARGE_INTEGER now;
   TIME_ZONE_INFORMATION tzi;
   SYSTEMTIME st;
   DWORD unit;
   LARGE_INTEGER KickoffTime;
   LARGE_INTEGER LogoffTime;
   ULONG LogoffUnitsIntoWeek;
   USHORT i;
   ULONG LogoffMsIntoWeek;
   ULONG MillisecondsPerUnit;
   ULONG DeltaMs;
   ULONG CurrentUnitsIntoWeek;
   LARGE_INTEGER Delta100Ns;

    _ASSERT(SessionTimeout != NULL);
   SessionTimeout->QuadPart = MAXLONGLONG;
   KickoffTime.QuadPart = MAXLONGLONG;
   LogoffTime.QuadPart = MAXLONGLONG;

   GetSystemTimeAsFileTime((LPFILETIME)&now);

   // An expiration time of zero means 'never'.
   if ((AccountExpires->QuadPart != 0) &&
       (AccountExpires->QuadPart < now.QuadPart))
      {
         return ERROR_ACCOUNT_EXPIRED;
      }

   // If LogonHours is empty, then we're done.
   if (LogonHours->UnitsPerWeek == 0)
   {
      return NO_ERROR;
   }

   // The LogonHours array does not account for bias.
   switch (GetTimeZoneInformation(&tzi))
   {
      case TIME_ZONE_ID_UNKNOWN:
      case TIME_ZONE_ID_STANDARD:
         // Bias is in minutes.
         now.QuadPart -= 60 * 10000000 * (LONGLONG)tzi.StandardBias;
         break;

      case TIME_ZONE_ID_DAYLIGHT:
         // Bias is in minutes.
         now.QuadPart -= 60 * 10000000 * (LONGLONG)tzi.DaylightBias;
         break;

      default:
         return ERROR_INVALID_LOGON_HOURS;
   }

   FileTimeToSystemTime(
       (LPFILETIME)&now,
       &st
       );

   // Number of milliseconds into the week.
   unit  = st.wMilliseconds +
           st.wSecond    * 1000 +
           st.wMinute    * 1000 * 60 +
           st.wHour      * 1000 * 60 * 60 +
           st.wDayOfWeek * 1000 * 60 * 60 * 24;

   // Convert this to 'units'.
   unit /= (MSEC_PER_WEEK / (DWORD)LogonHours->UnitsPerWeek);

   // Test the appropriate bit.
   if ((LogonHours->LogonHours[unit / 8 ] & (1 << (unit % 8))) == 0)
   {
      return ERROR_INVALID_LOGON_HOURS;
   }
   else
   {
      //
      // Determine the next time that the user is NOT supposed to be logged
      // in, and return that as LogoffTime.
      //
      i = 0;
      LogoffUnitsIntoWeek = unit;

      do 
      {
         ++i;
         LogoffUnitsIntoWeek = ( LogoffUnitsIntoWeek + 1 )
                               % LogonHours->UnitsPerWeek;
      }
      while ( ( i <= LogonHours->UnitsPerWeek) &&
              ( LogonHours->LogonHours[ LogoffUnitsIntoWeek / 8 ] &
              ( 0x01 << ( LogoffUnitsIntoWeek % 8 ) ) ) );

      if ( i > LogonHours->UnitsPerWeek ) 
      {
         //
         // All times are allowed, so there's no logoff
         // time.  Return forever for both LogoffTime and
         // KickoffTime.
         //
         LogoffTime.QuadPart = MAXLONGLONG;
         KickoffTime.QuadPart = MAXLONGLONG;
      } 
      else 
      {
         //
         // LogoffUnitsIntoWeek points at which time unit the
         // user is to log off.  Calculate actual time from
         // the unit, and return it.
         //
         // CurrentTimeFields already holds the current
         // time for some time during this week; just adjust
         // to the logoff time during this week and convert
         // to time format.
         //

         MillisecondsPerUnit = MSEC_PER_WEEK / LogonHours->UnitsPerWeek;
         LogoffMsIntoWeek = MillisecondsPerUnit * LogoffUnitsIntoWeek;

         if ( LogoffMsIntoWeek < unit ) 
         {
            DeltaMs = MSEC_PER_WEEK - ( unit - LogoffMsIntoWeek );
         } 
         else 
         {
            DeltaMs = LogoffMsIntoWeek - unit;
         }

         Delta100Ns.QuadPart = (LONGLONG) DeltaMs * 10000;

         LogoffTime.QuadPart = min(now.QuadPart +
                                   Delta100Ns.QuadPart,
                                   LogoffTime.QuadPart);
      }
      // Get the minimum of the three values
      KickoffTime.QuadPart = min(LogoffTime.QuadPart, KickoffTime.QuadPart);
      KickoffTime.QuadPart = min(KickoffTime.QuadPart, AccountExpires->QuadPart);

      // store the result
      SessionTimeout->QuadPart = KickoffTime.QuadPart;
   }
   return NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////// //
// FUNCTION
//
//    IASPurgeTicketCache
//
// DESCRIPTION
//
//    Purges the Kerberos ticket cache.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASPurgeTicketCache( VOID )
{
   KERB_PURGE_TKT_CACHE_REQUEST request;
   NTSTATUS status, subStatus;
   PVOID response;
   ULONG responseLength;

   memset(&request, 0, sizeof(request));
   request.MessageType = KerbPurgeTicketCacheMessage;

   response = NULL;
   responseLength = 0;
   subStatus = 0;

   status = LsaCallAuthenticationPackage(
                theLogonProcess,
                theKerberosPackage,
                &request,
                sizeof(request),
                &response,
                &responseLength,
                &subStatus
                );
   if (NT_SUCCESS(status))
   {
      LsaFreeReturnBuffer(response);
   }

   return RtlNtStatusToDosError(status);
}
#endif


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASGetDcName
//
// DESCRIPTION
//
//    Wrapper around DsGetDcNameW. Tries to do the right thing with regard
//    to NETBIOS and DNS names.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASGetDcName(
    IN LPCWSTR DomainName,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
{
   DWORD status;
   PDOMAIN_CONTROLLER_INFOW dci;

   if (!(Flags & DS_IS_DNS_NAME)) { Flags |= DS_IS_FLAT_NAME; }

   status = DsGetDcNameW(
                NULL,
                DomainName,
                NULL,
                NULL,
                Flags,
                DomainControllerInfo
                );

   if (status == NO_ERROR &&
       !(Flags & DS_IS_DNS_NAME) &&
       ((*DomainControllerInfo)->Flags & DS_DS_FLAG))
   {
      // It's an NT5 DC, so we need the DNS name of the server.
      Flags |= DS_RETURN_DNS_NAME;

      // We always want a cache hit here.
      Flags &= ~(ULONG)DS_FORCE_REDISCOVERY;

      if (!DsGetDcNameW(
               NULL,
               DomainName,
               NULL,
               NULL,
               Flags,
               &dci
               ))
      {
         NetApiBufferFree(*DomainControllerInfo);
         *DomainControllerInfo = dci;
      }
   }

   return status;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASChangePassword2
//
// DESCRIPTION
//
//    Performs V2 password change.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASChangePassword2(
   IN PCWSTR UserName,
   IN PCWSTR Domain,
   IN PBYTE OldNtHash,
   IN PBYTE OldLmHash,
   IN PBYTE NtEncPassword,
   IN PBYTE LmEncPassword,
   IN BOOL LmPresent
   )
{
   DWORD status;
   PDOMAIN_CONTROLLER_INFOW dci;
   UNICODE_STRING uniServerName, uniUserName;

   //////////
   // Get the name of the DC to connect to.
   //////////

   if (_wcsicmp(Domain, theAccountDomain) == 0)
   {
      //////////
      // Local domain, so use theLocalServer.
      //////////

      dci = NULL;

      RtlInitUnicodeString(
          &uniServerName,
          theLocalServer
          );
   }
   else
   {
      //////////
      // Remote domain, so use IASGetDcName.
      //////////

      status = IASGetDcName(
                   Domain,
                   DS_WRITABLE_REQUIRED,
                   &dci
                   );
      if (status != NO_ERROR) { goto exit; }

      RtlInitUnicodeString(
          &uniServerName,
          dci->DomainControllerName
          );
   }

   RtlInitUnicodeString(
       &uniUserName,
       UserName
       );

   status = SamiChangePasswordUser2(
                &uniServerName,
                &uniUserName,
                (PSAMPR_ENCRYPTED_USER_PASSWORD)NtEncPassword,
                (PENCRYPTED_NT_OWF_PASSWORD)OldNtHash,
                (BOOLEAN)LmPresent,
                (PSAMPR_ENCRYPTED_USER_PASSWORD)LmEncPassword,
                (PENCRYPTED_LM_OWF_PASSWORD)OldLmHash
                );
   status = RtlNtStatusToDosError(status);

   if (dci)
   {
      NetApiBufferFree(dci);
   }

exit:
   return status;
}



///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION
//
//    IASChangePassword3
//
// DESCRIPTION
//
//    Performs MS-CHAP v2 change password.
//
///////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
IASChangePassword3(
   IN PCWSTR UserName,
   IN PCWSTR Domain,
   IN PBYTE EncHash,
   IN PBYTE EncPassword
   )
{
   return IASChangePassword2(
              UserName,
              Domain,
              EncHash,
              NULL,
              EncPassword,
              NULL,
              FALSE
              );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\exports.cpp ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:
    Implementation of DLL Exports.

History:

*/

#include "ceapcfg.h"
#include <initguid.h>
#include <atlimpl.cpp>
#include "resource.h"

CComModule  _Module;
HINSTANCE   g_hInstance = NULL;

const IID IID_IEAPProviderConfig =  {0x66A2DB19,
                                    0xD706,
                                    0x11D0,
                                    {0xA3,0x7B,0x00,0xC0,0x4F,0xC9,0xDA,0x04}};
                                    


// Define the EAPTLS UI GUIDs here
const CLSID CLSID_EapCfg =          {0x2af6bcaa,
                                    0xf526,
                                    0x4803,
                                    {0xae,0xb8,0x57,0x77,0xce,0x38,0x66,0x47}};


BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_EapCfg, CEapCfg)
END_OBJECT_MAP()

/*

Returns:

Notes:
    
*/

extern "C"
HINSTANCE
GetHInstance(
    VOID
)
{
    return(g_hInstance);
}

extern "C"
HINSTANCE
GetRasDlgDLLHInstance(
    VOID
)
{
    static HINSTANCE hResourceModule = NULL;

    if ( !hResourceModule )
    {
        //
        // Change the name of this DLL as required for each service pack
        //

        hResourceModule = LoadLibrary ( "rasdlg.dll");
    }
    return(hResourceModule);
}
extern "C"
HINSTANCE
GetResouceDLLHInstance(
    VOID
)
{
    static HINSTANCE hResourceModule = NULL;

    if ( !hResourceModule )
    {
        //
        // Change the name of this DLL as required for each service pack
        //

        hResourceModule = LoadLibrary ( "xpsp1res.dll");
    }
    return(hResourceModule);
}
/*

Returns:

Notes:
    DLL Entry Point
    
*/

extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      /*lpReserved*/
)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }

    return(TRUE);
}

/*

Returns:

Notes:
    Used to determine whether the DLL can be unloaded by OLE
    
*/

STDAPI
DllCanUnloadNow(
    VOID
)
{
    if (0 == _Module.GetLockCount())
    {
        return(S_OK);
    }
    else
    {
        return(S_FALSE);
    }
}

/*

Returns:

Notes:
    Returns a class factory to create an object of the requested type
    
*/

STDAPI
DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv
)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}

/*

Returns:

Notes:
    Adds entries to the system registry. Registers object, typelib and all
    interfaces in typelib
    
*/

STDAPI
DllRegisterServer(
    VOID
)
{
    return(_Module.RegisterServer(FALSE /* bRegTypeLib */));
}

/*

Returns:

Notes:
    Removes entries from the system registry
    
*/

STDAPI
DllUnregisterServer(
    VOID
)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\ezlogon.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998, Microsoft Corp. All rights reserved.
//
// FILE
//
//    ezlogon.h
//
// SYNOPSIS
//
//    Describes the abbreviated IAS version of LsaLogonUser.
//
// MODIFICATION HISTORY
//
//    08/15/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _EZLOGON_H_
#define _EZLOGON_H_
#if _MSC_VER >= 1000
#pragma once
#endif

#include <ntmsv1_0.h>

#ifdef __cplusplus
extern "C" {
#endif


//////////
// These are defined here to avoid dependencies on the NT headers.
//////////

#define DEFAULT_PARAMETER_CONTROL \
(MSV1_0_DONT_TRY_GUEST_ACCOUNT | MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY | MSV1_0_DISABLE_PERSONAL_FALLBACK|MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT|MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT)

#define _AUTHENTICATOR_RESPONSE_LENGTH         20


typedef struct _IAS_MSCHAP_PROFILE {
    WCHAR LogonDomainName[DNLEN + 1];
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    LARGE_INTEGER KickOffTime;
} IAS_MSCHAP_PROFILE, *PIAS_MSCHAP_PROFILE;



typedef struct _IAS_MSCHAP_V2_PROFILE {
    WCHAR LogonDomainName[DNLEN + 1];
    UCHAR AuthResponse[_AUTHENTICATOR_RESPONSE_LENGTH];
    UCHAR RecvSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR SendSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    LARGE_INTEGER KickOffTime;
} IAS_MSCHAP_V2_PROFILE, *PIAS_MSCHAP_V2_PROFILE;

DWORD
WINAPI
IASLogonInitialize( VOID );

VOID
WINAPI
IASLogonShutdown( VOID );

VOID
WINAPI
IASInitAuthInfo(
    IN PVOID AuthInfo,
    IN DWORD FixedLength,
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    OUT PBYTE* Data
    );

DWORD
WINAPI
IASLogonUser(
    IN PVOID AuthInfo,
    IN ULONG AuthInfoLength,
    OPTIONAL OUT PMSV1_0_LM20_LOGON_PROFILE *Profile,
    OUT PHANDLE Token
    );

DWORD
WINAPI
IASLogonMSCHAPv2(
    IN PCWSTR UserName,
    IN PCWSTR Domain,
    IN PCSTR HashUserName,
    IN PBYTE Challenge,
    IN DWORD ChallengeLength,
    IN PBYTE Response,
    IN PBYTE PeerChallenge,
    OUT PIAS_MSCHAP_V2_PROFILE Profile,
    OUT PHANDLE Token
    );

DWORD
WINAPI
IASGetSendRecvSessionKeys( PBYTE pbUserSessionKey,
                           DWORD dwUserSessionKeyLen,
                           PBYTE pbResponse,
                           DWORD dwResponseLen,
                           OUT PBYTE pbSendKey,
                           OUT PBYTE pbRecvKey
                         );

DWORD
WINAPI
IASChangePassword3(
   IN PCWSTR UserName,
   IN PCWSTR Domain,
   IN PBYTE EncHash,
   IN PBYTE EncPassword
   );

///////////////////////////////////////////////////////////////////////////////
//
// Assorted macros to initialize self-relative logon information.
//
///////////////////////////////////////////////////////////////////////////////

// Copy a Unicode string into a UNICODE_STRING.
#define IASInitUnicodeString(str, buf, src) \
{ (str).Length = (USHORT)(wcslen(src) * sizeof(WCHAR)); \
  (str).MaximumLength = (str).Length; \
  (str).Buffer = (PWSTR)memcpy((buf), (src), (str).MaximumLength); \
  (buf) += (str).MaximumLength; }

// Copy a ANSI string into a STRING.
#define IASInitAnsiString(str, buf, src) \
{ (str).Length = (USHORT)(strlen(src) * sizeof(CHAR)); \
  (str).MaximumLength = (str).Length; \
  (str).Buffer = (PSTR)memcpy((buf), (src), (str).MaximumLength);  \
  (buf) += (str).MaximumLength; }

// Copy an octet string into a STRING.
#define IASInitOctetString(str, buf, src, srclen) \
{ (str).Length = (USHORT)(srclen); \
  (str).MaximumLength = (str).Length; \
  (str).Buffer = (PSTR)memcpy((buf), (src), (str).MaximumLength); \
  (buf) += (str).MaximumLength; }

// Copy an ANSI string into a UNICODE_STRING.
#define IASInitUnicodeStringFromAnsi(str, buf, src) \
{ (str).MaximumLength = (USHORT)(sizeof(WCHAR) * ((src).Length + 1)); \
  (str).Buffer = (PWSTR)(buf); \
  RtlAnsiStringToUnicodeString(&(str), &(src), FALSE); \
  (buf) += ((str).MaximumLength = (str).Length); }

// Copy a fixed-size array into a fixed-size array of the same size.
#define IASInitFixedArray(dst, src) \
{ memcpy((dst), (src), sizeof(dst)); }

#ifdef __cplusplus
}
#endif
#endif  // _EZLOGON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\eapchap.c ===
/********************************************************************/
/**          Copyright(c) 1985-1997 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    eapchap.c   
//
// Description: Will do MD5 CHAP for EAP. This module is a EAP wrapper
//              around CHAP
//
// History:     May 11,1997	    NarenG		Created original version.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <ntsamp.h>
#define SECURITY_WIN32
#include <security.h>   // For GetUserNameExW
#include <crypt.h>
#include <windows.h>
#include <lmcons.h>
#include <string.h>
#include <stdlib.h>
#include <rasman.h>
#include <pppcp.h>
#include <raserror.h>
#include <rtutils.h>
#include <md5.h>
#include <raseapif.h>
#include <eaptypeid.h>
#include <pppcp.h>
#define INCL_RASAUTHATTRIBUTES
#define INCL_PWUTIL
#define INCL_HOSTWIRE
#include <ppputil.h>
#include <raschap.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>
#include <mscat.h>
#include <ezlogon.h>
#include "resource.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define EAPTYPE_MD5Challenge            4
//
// We need to move this definition to pppcp.h
//
#define VENDOR_MICROSOFT                311


//
// Various states that EAPMSCHAPv2 can be in.
//
#define EAPMSCHAPv2STATE enum tagEAPMSCHAPv2STATE
EAPMSCHAPv2STATE
{
    EMV2_Initial,
    EMV2_RequestSend,
    EMV2_ResponseSend,
    EMV2_CHAPAuthSuccess,
    EMV2_CHAPAuthFail,
    EMV2_Success,
    EMV2_Failure
};


//
// These ids are pulled in from rasdlg.  Need them for the 
// change password dialog in case of winlogon scenario
//
#define DID_CP_ChangePassword2              109
#define CID_CP_EB_ConfirmPassword_RASDLG    1058
#define CID_CP_EB_OldPassword_RASDLG        1059
#define CID_CP_EB_Password_RASDLG           1060


//
// Reg Key for EAPMSCHAPv2
//

#define EAPMSCHAPv2_KEY                             "System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP\\26"
#define EAPMSCHAPv2_VAL_SERVER_CONFIG_DATA          "ServerConfigData"

//
//
// Flags for EAPMSChapv2
//
//

/*
** SaveUid and password
*/
#define EAPMSCHAPv2_FLAG_SAVE_UID_PWD               0x00000001
/*
** Use Winlogon Credentials
*/
#define EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS         0x00000002
/*
** Allow Change password - server side only.
*/
#define EAPMSCHAPv2_FLAG_ALLOW_CHANGEPWD            0x00000004
/*
** MACHINE Auth is happening
*/
#define EAPMSCHAPv2_FLAG_MACHINE_AUTH               0x00000008

#define EAPMSCHAPv2_FLAG_CALLED_WITHIN_WINLOGON     0x00000010

#define EAPMSCHAPv2_FLAG_8021x                      0x00000020

typedef struct _EAPMSCHAPv2_USER_PROPERTIES
{
    DWORD                   dwVersion;          //Version = 2
    DWORD                   fFlags;
    //This is a server config property. Tells the server
    //how many retris are allowed
    DWORD                   dwMaxRetries;
    CHAR                    szUserName[UNLEN+1];
    CHAR                    szPassword[PWLEN+1];
    CHAR                    szDomain[DNLEN+1];
    DWORD                   cbEncPassword;      //Number of bytes in encrypted password
    BYTE                    bEncPassword[1];    //Encrypted Password if any ...
}EAPMSCHAPv2_USER_PROPERTIES, *PEAPMSCHAPv2_USER_PROPERTIES;
//
// USER properties for EAPMSCHAPv2
//
typedef struct _EAPMSCHAPv2_USER_PROPERTIES_v1
{
    DWORD                   dwVersion;
    DWORD                   fFlags;
    //This is a server config property. Tells the server
    //how many retris are allowed
    DWORD                   dwMaxRetries;
    CHAR                    szUserName[UNLEN+1];
    CHAR                    szPassword[PWLEN+1];
    CHAR                    szDomain[DNLEN+1];
}EAPMSCHAPv2_USER_PROPERTIES_v1, *PEAPMSCHAPv2_USER_PROPERTIES_v1;



//
// CONNECTION properties for EAPMSCHAPv2
//

typedef struct _EAPMSCHAPv2_CONN_PROPERTIES
{
    DWORD                   dwVersion;
//This is the only field for now.  Maybe more will come in later.
    DWORD                   fFlags;
}EAPMSCHAPv2_CONN_PROPERTIES, * PEAPMSCHAPv2_CONN_PROPERTIES;


//
// Interactive UI for EAPMSCHAPv2
//

// Flag for retry password ui
#define EAPMSCHAPv2_INTERACTIVE_UI_FLAG_RETRY                   0x00000001
//
// flag indicating show the change password in case 
// the old password is provided
#define EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD              0x00000002
//
// flag indicating that change password was invoked in 
// winlogon context
//
#define EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD_WINLOGON     0x00000004

typedef struct _EAPMSCHAPv2_INTERACTIVE_UI
{
    DWORD                           dwVersion;
    DWORD                           fFlags;
    EAPMSCHAPv2_USER_PROPERTIES     UserProp;    
    CHAR                            szNewPassword[PWLEN+1];
}EAPMSCHAPv2_INTERACTIVE_UI, * PEAPMSCHAPv2_INTERACTIVE_UI;


#define EAPMSCHAPv2WB struct tagEAPMSCHAPv2WB
EAPMSCHAPv2WB
{     
    EAPMSCHAPv2STATE                EapState;
    DWORD                           fFlags;
    DWORD                           dwInteractiveUIOperation;
    BYTE                            IdToSend;
    BYTE                            IdToExpect;
    PEAPMSCHAPv2_INTERACTIVE_UI     pUIContextData;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp;
    CHAR                            szOldPassword[PWLEN+1];
    //We need to save this for auth purposes.
    WCHAR                           wszRadiusUserName[UNLEN+DNLEN+1];
    PEAPMSCHAPv2_CONN_PROPERTIES    pConnProp;
    CHAPWB         *                pwb;
    RAS_AUTH_ATTRIBUTE *            pUserAttributes;
    DWORD                           dwAuthResultCode;
};

//
// This structure is shared between retry and 
// logon dialog
//

typedef struct _EAPMSCHAPv2_LOGON_DIALOG 
{
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp;    
    HWND                            hWndUserName;
    HWND                            hWndPassword;
    HWND                            hWndDomain;
    HWND                            hWndSavePassword;
}EAPMSCHAPv2_LOGON_DIALOG, * PEAPMSCHAPv2_LOGON_DIALOG;


//
// This stuct is used for client config UI.
// 
typedef struct _EAPMSCHAPv2_CLIENTCONFIG_DIALOG
{
    PEAPMSCHAPv2_CONN_PROPERTIES     pConnProp;
}EAPMSCHAPv2_CLIENTCONFIG_DIALOG, * PEAPMSCHAPv2_CLIENTCONFIG_DIALOG;

typedef struct _EAPMSCHAPv2_SERVERCONFIG_DIALOG
{
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp;
    HWND                            hWndRetries;
}EAPMSCHAPv2_SERVERCONFIG_DIALOG, *PEAPMSCHAPv2_SERVERCONFIG_DIALOG;

typedef struct _EAPMSCHAPv2_CHANGEPWD_DIALOG
{
    PEAPMSCHAPv2_INTERACTIVE_UI     pInteractiveUIData;
    HWND                            hWndNewPassword;
    HWND                            hWndConfirmNewPassword;
    HWND                            hWndOldPassword;
}EAPMSCHAPv2_CHANGEPWD_DIALOG, *PEAPMSCHAPv2_CHANGEPWD_DIALOG;

DWORD
AllocateUserDataWithEncPwd ( EAPMSCHAPv2WB * pEapwb, DATA_BLOB * pDBPassword );

DWORD
EapMSCHAPv2Initialize(
    IN  BOOL    fInitialize
);

INT_PTR CALLBACK
LogonDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
RetryDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
ClientConfigDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
ServerConfigDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
ChangePasswordDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

HINSTANCE
GetHInstance(
    VOID
);

HINSTANCE
GetResouceDLLHInstance(
    VOID
);


HINSTANCE
GetRasDlgDLLHInstance(
    VOID
);

extern DWORD g_dwTraceIdChap;


DWORD
ReadUserData(
    IN  BYTE*                           pUserDataIn,
    IN  DWORD                           dwSizeOfUserDataIn,
    OUT PEAPMSCHAPv2_USER_PROPERTIES*   ppUserProp
);


DWORD
ReadConnectionData(
    IN  BOOL                            fWirelessConnection,
    IN  BYTE*                           pConnectionDataIn,
    IN  DWORD                           dwSizeOfConnectionDataIn,
    OUT PEAPMSCHAPv2_CONN_PROPERTIES*   ppConnProp
);


DWORD
ServerConfigDataIO(
    IN      BOOL    fRead,
    IN      CHAR*   pszMachineName,
    IN OUT  BYTE**  ppData,
    IN      DWORD   dwNumBytes
);



DWORD
EncodePassword(
    DWORD       cbPassword,  
    PBYTE       pbPassword, 
    DATA_BLOB * pDataBlobPassword)
{
    DWORD dwErr = NO_ERROR;
    DATA_BLOB DataBlobIn;

    if(NULL == pDataBlobPassword)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    if(     (0 == cbPassword)
        ||  (NULL == pbPassword))
    {
        //
        // nothing to encrypt. just return success
        //
        goto done;
    }

    ZeroMemory(pDataBlobPassword, sizeof(DATA_BLOB));
    
    DataBlobIn.cbData = cbPassword;
    DataBlobIn.pbData = pbPassword;

    if(!CryptProtectData(
            &DataBlobIn,
            NULL,
            NULL,
            NULL,
            NULL,
            CRYPTPROTECT_UI_FORBIDDEN |
            CRYPTPROTECT_LOCAL_MACHINE,
            pDataBlobPassword))
    {
        dwErr = GetLastError();
        goto done;
    }

done:

    return dwErr;    
}

DWORD
DecodePassword( 
    DATA_BLOB * pDataBlobPassword, 
    DWORD     * pcbPassword, 
    PBYTE     * ppbPassword)
{
    DWORD dwErr = NO_ERROR;
    DATA_BLOB DataOut;
    
    if(     (NULL == pDataBlobPassword)
        ||  (NULL == pcbPassword)
        ||  (NULL == ppbPassword))
    {   
        dwErr = E_INVALIDARG;
        goto done;
    }

    *pcbPassword = 0;
    *ppbPassword = NULL;

     if(    (NULL == pDataBlobPassword->pbData)
        ||  (0 == pDataBlobPassword->cbData))
    {
        //
        // nothing to decrypt. Just return success.
        //
        goto done;
    }
    

    ZeroMemory(&DataOut, sizeof(DATA_BLOB));

    if(!CryptUnprotectData(
                pDataBlobPassword,
                NULL,
                NULL,
                NULL,
                NULL,
                CRYPTPROTECT_UI_FORBIDDEN |
                CRYPTPROTECT_LOCAL_MACHINE,
                &DataOut))
    {
        dwErr = GetLastError();
        goto done;
    }

    *pcbPassword = DataOut.cbData;
    *ppbPassword = DataOut.pbData;

done:

    return dwErr;
}

VOID
FreePassword(DATA_BLOB *pDBPassword)
{
    if(NULL == pDBPassword)
    {
        return;
    }

    if(NULL != pDBPassword->pbData)
    {
        RtlSecureZeroMemory(pDBPassword->pbData, pDBPassword->cbData);
        LocalFree(pDBPassword->pbData);
    }

    ZeroMemory(pDBPassword, sizeof(DATA_BLOB));
}

//**
//
// Call:        MapEapInputToApInput
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
MapEapInputToApInput( 
    IN  PPP_EAP_INPUT*      pPppEapInput,
    OUT PPPAP_INPUT *       pInput
)
{
    pInput->fServer                     = pPppEapInput->fAuthenticator; 
    pInput->APDataSize                  = 1;   
    pInput->fAuthenticationComplete     = pPppEapInput->fAuthenticationComplete;
    pInput->dwAuthResultCode            = pPppEapInput->dwAuthResultCode;
    pInput->dwAuthError                 = NO_ERROR;
    pInput->pUserAttributes             = NULL;
    pInput->pAttributesFromAuthenticator= pPppEapInput->pUserAttributes;
    pInput->fSuccessPacketReceived      = pPppEapInput->fSuccessPacketReceived;
    pInput->dwInitialPacketId           = pPppEapInput->bInitialId;

    //
    // These are used only for MS-CHAP
    //

    pInput->pszOldPassword            = "";
    pInput->dwRetries                 = 0;   
}



//**
//
// Call:        MapApInputToEapInput
//
// Returns:     NONE
//              
//
// Description: $TODO: Put in the correct mapping here
//
VOID
MapApResultToEapOutput( 
    IN      PPPAP_RESULT *      pApResult,
    OUT     PPP_EAP_OUTPUT*      pPppEapOutput
)
{
    //
    //Action is already taken care of.  So dont set it here
    //
    pPppEapOutput->dwAuthResultCode = pApResult->dwError; 
    pPppEapOutput->pUserAttributes = pApResult->pUserAttributes;
}



//**
//
// Call:        EapChapBeginCommon
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Wrapper around ChapBegin
//
DWORD
EapChapBeginCommon(
	IN  DWORD				dwEapType,
    IN  BOOL                fUseWinLogon,
    IN  DWORD               dwRetries,
    IN  EAPMSCHAPv2WB  *    pWB,
    OUT VOID **             ppWorkBuffer,
    IN  PPP_EAP_INPUT *     pPppEapInput 
)
{
    PPPAP_INPUT     Input;
    DWORD           dwRetCode;
    PPP_EAP_INPUT*  pInput = (PPP_EAP_INPUT* )pPppEapInput;
    BYTE            bMD5 = 0x05;      
    BYTE            bMSChapNew = 0x81;
	BYTE			bInvalid = 0xFF;
    WCHAR *         pWchar = NULL;
    CHAR            szDomain[DNLEN+1];
    CHAR            szUserName[UNLEN+1];
    CHAR            szPassword[PWLEN+1];
    PPPAP_RESULT    ApResult;
    
    

    TRACE("EapChapBeginCommon");
    
    ZeroMemory( &Input, sizeof( PPPAP_INPUT ) );
    ZeroMemory( szDomain, sizeof( szDomain ) );
    ZeroMemory( szUserName, sizeof( szUserName ) );
    ZeroMemory( szPassword, sizeof( szPassword ) );
    ZeroMemory( &ApResult, sizeof(ApResult) );

    MapEapInputToApInput( pPppEapInput, &Input );

    if ( dwEapType == EAPTYPE_MD5Challenge )
    {
        Input.pAPData = &bMD5;
    }
    else if ( dwEapType == PPP_EAP_MSCHAPv2 )
    {
        Input.pAPData = &bMSChapNew;
    }
	else
		//Set the value to invalid type and let ChapBegin Fail
		Input.pAPData = &bInvalid;

    //
    // If we dont have to use winlogon or we have to do machine auth
    //
    
    if ( !fUseWinLogon ||
         ( pPppEapInput->fFlags & RAS_EAP_FLAG_MACHINE_AUTH )
       )
    {
        if ( NULL != pPppEapInput->pwszIdentity )
        {
            pWchar = wcschr( pPppEapInput->pwszIdentity, L'\\' );

            if ( pWchar == NULL )
            {
                if ( 0 == WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pPppEapInput->pwszIdentity,
                                -1,
                                szUserName,
                                UNLEN + 1,
                                NULL,
                                NULL ) )
                {
                    return( GetLastError() );
                }
            }
            else
            {
                *pWchar = 0;

                if ( 0 == WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pPppEapInput->pwszIdentity,
                                -1,
                                szDomain,
                                DNLEN + 1,
                                NULL,
                                NULL ) )
                {
                    return( GetLastError() );
                }

                *pWchar = L'\\';

                if ( 0 == WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pWchar + 1,
                                -1,
                                szUserName,
                                UNLEN + 1,
                                NULL,
                                NULL ) )
                {
                    return( GetLastError() );
                }
            }
        }
        if ( dwEapType == EAPTYPE_MD5Challenge )
        {
            if ( NULL != pPppEapInput->pwszPassword )
            {
                if ( 0 == WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pPppEapInput->pwszPassword,
                                -1,
                                szPassword,
                                PWLEN + 1,
                                NULL,
                                NULL ) )
                {
                    return( GetLastError() );
                }
            }
        }
        else
        {
            // if this is not a server then copy the user props
            if ( !pPppEapInput->fAuthenticator )
            {
                strncpy( szPassword, pWB->pUserProp->szPassword, PWLEN );
            }            
        }
    }
    else
    {
        
        if ( !pPppEapInput->fAuthenticator && 
             !(pPppEapInput->fFlags & RAS_EAP_FLAG_MACHINE_AUTH )
           )
        {
            //Set up the Luid for the logged on user
            TOKEN_STATISTICS TokenStats;
            DWORD            TokenStatsSize;
            if (!GetTokenInformation(pPppEapInput->hTokenImpersonateUser,
                                    TokenStatistics,
                                    &TokenStats,
                                    sizeof(TOKEN_STATISTICS),
                                    &TokenStatsSize))
            {
               dwRetCode = GetLastError();
               return dwRetCode;
            }
            //
            // "This will tell us if there was an API failure
            // (means our buffer wasn't big enough)"
            //
            if (TokenStatsSize > sizeof(TOKEN_STATISTICS))
            {
                dwRetCode = GetLastError();
                return dwRetCode;
            }

            Input.Luid = TokenStats.AuthenticationId;
        }
        
    }


    Input.dwRetries = dwRetries;
    Input.pszDomain   = szDomain;
    Input.pszUserName = szUserName;
    Input.pszPassword = szPassword;
    
    if ( (pPppEapInput->fFlags & RAS_EAP_FLAG_MACHINE_AUTH) )
        Input.fConfigInfo |= PPPCFG_MachineAuthentication;

        
    dwRetCode = ChapBegin( ppWorkBuffer, &Input );
    if ( NO_ERROR != dwRetCode )
        return dwRetCode;

    ZeroMemory( szPassword, sizeof( szPassword ) );
    if ( ! (Input.fServer) )
    {
        //if this is a client then call ChapMakeMessage to 
        //move the state from Initial to WaitForChallange
        dwRetCode = ChapMakeMessage(
                           *ppWorkBuffer,
                            NULL,
                            NULL,
                            0,
                            &ApResult,
                            &Input );
    }

    
    return( dwRetCode );
}

DWORD EapMSChapv2Begin ( 
    OUT VOID **             ppWorkBuffer,
    IN  PPP_EAP_INPUT *     pPppEapInput
)
{
    DWORD               dwRetCode = NO_ERROR;
    EAPMSCHAPv2WB  *    pWB = NULL;

    TRACE("EapChapBeginMSChapV2");

    //
    // Allocate a work buffer here and send it back as our
    // work buffer.
    //
    pWB = (EAPMSCHAPv2WB *)LocalAlloc(LPTR, sizeof(EAPMSCHAPv2WB) );
    if ( NULL == pWB )
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }
    
    if ( (pPppEapInput->fFlags & RAS_EAP_FLAG_MACHINE_AUTH) )
    {
        pWB->fFlags |= EAPMSCHAPv2_FLAG_MACHINE_AUTH;
    }
    if ( pPppEapInput->fAuthenticator )
    {
        dwRetCode = ServerConfigDataIO(TRUE /* fRead */, NULL /* pwszMachineName */,
                (BYTE**)&(pWB->pUserProp), 0);
    }
    else
    {
        dwRetCode = ReadUserData(   pPppEapInput->pUserData,
                            pPppEapInput->dwSizeOfUserData,
                            &(pWB->pUserProp)
                        );
    }

    if ( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }

    //
    // Check to see if we got password field set.  If so, we use that password
    // It means that the user has chosen to save the password.  If not, 
    // szpassword field should be empty.
    if ( !( pPppEapInput->fFlags & RAS_EAP_FLAG_8021X_AUTH ) )
    {
        if ( pPppEapInput->pwszPassword && 
            *(pPppEapInput->pwszPassword) && 
            wcscmp (pPppEapInput->pwszPassword, L"****************")  
        )
        {
            WideCharToMultiByte( CP_ACP,
                    0,
                    pPppEapInput->pwszPassword ,
                    -1,
                    pWB->pUserProp->szPassword,
                    PWLEN+1,
                    NULL,
                    NULL );

        }
    }
    dwRetCode = ReadConnectionData (    ( pPppEapInput->fFlags & RAS_EAP_FLAG_8021X_AUTH ),
                                        pPppEapInput->pConnectionData,
                                        pPppEapInput->dwSizeOfConnectionData,
                                        &(pWB->pConnProp )
                                   );
    if ( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }
    

	dwRetCode =  EapChapBeginCommon(	PPP_EAP_MSCHAPv2,
                                (pWB->pConnProp->fFlags & EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS ),
                                (pWB->pUserProp->dwMaxRetries ),
                                pWB,
								&pWB->pwb,
								pPppEapInput 
							  );
    if ( NO_ERROR != dwRetCode )
    {
        goto done;
    }
    if ( pPppEapInput->pwszIdentity )
    {         
        wcsncpy ( pWB->wszRadiusUserName, pPppEapInput->pwszIdentity, UNLEN+DNLEN );
    }

    *ppWorkBuffer = (PVOID)pWB;    

done:
    if ( NO_ERROR != dwRetCode )
    {
        if ( pWB )
        {
            LocalFree(pWB->pUserProp);
            LocalFree(pWB->pConnProp);
            LocalFree(pWB);
        }
    }

    return dwRetCode;
}


DWORD CheckCallerIdentity ( HANDLE hWVTStateData )
{
    DWORD                       dwRetCode         = ERROR_ACCESS_DENIED;
    PCRYPT_PROVIDER_DATA        pProvData         = NULL;
    PCCERT_CHAIN_CONTEXT        pChainContext     = NULL;
    PCRYPT_PROVIDER_SGNR        pProvSigner       = NULL;
    CERT_CHAIN_POLICY_PARA      chainpolicyparams;
    CERT_CHAIN_POLICY_STATUS    chainpolicystatus;

    if (!(pProvData = WTHelperProvDataFromStateData(hWVTStateData)))
    {        
        goto done;
    }

    if (!(pProvSigner = WTHelperGetProvSignerFromChain(pProvData, 0, FALSE, 0)))
    {
        goto done;
    }

    chainpolicyparams.cbSize = sizeof(CERT_CHAIN_POLICY_PARA);

    //
    //
    // We do want to test for microsoft test root flags. and dont care 
    // for revocation flags...
    //
    chainpolicyparams.dwFlags = CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG |
                                CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG |
                                CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;

    pChainContext = pProvSigner->pChainContext;


    if (!CertVerifyCertificateChainPolicy (
        CERT_CHAIN_POLICY_MICROSOFT_ROOT,
        pChainContext,
        &chainpolicyparams,
        &chainpolicystatus)) 
    {
        goto done;
    }
    else
    {
        if ( S_OK == chainpolicystatus.dwError )
        {
            dwRetCode = NO_ERROR;
        }
        else
        {
            //
            // Check the base policy to see if this 
            // is a Microsoft test root
            //
            if (!CertVerifyCertificateChainPolicy (
                CERT_CHAIN_POLICY_BASE,
                pChainContext,
                &chainpolicyparams,
                &chainpolicystatus)) 
            {
                goto done;
            }
            else
            {
                if ( S_OK == chainpolicystatus.dwError )
                {
                    dwRetCode = NO_ERROR;
                }
            }
            
        }
    }

done:
    return dwRetCode;
}


DWORD VerifyCallerTrust ( LPWSTR lpszCaller )
{
    DWORD                       dwRetCode = NO_ERROR;
    HRESULT                     hr = S_OK;
    WINTRUST_DATA               wtData;
    WINTRUST_FILE_INFO          wtFileInfo;
    WINTRUST_CATALOG_INFO       wtCatalogInfo;
    BOOL                        fRet = FALSE;
    HCATADMIN                   hCATAdmin = NULL;

    GUID                    guidPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    //
    // Following GUID is Mirosoft's Catalog System Root 
    //
    GUID                    guidCatSystemRoot = { 0xf750e6c3, 0x38ee, 0x11d1,{ 0x85, 0xe5, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } };
    HCATINFO                hCATInfo = NULL;
    CATALOG_INFO            CatInfo;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    BYTE                    bHash[40];
    DWORD                   cbHash = 40;

    if ( NULL == lpszCaller )
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
        goto done;
    }

    //
    //
    // Try and see if WinVerifyTrust will verify
    // the signature as a standalone file
    //
    //

    ZeroMemory ( &wtData, sizeof(wtData) );
    ZeroMemory ( &wtFileInfo, sizeof(wtFileInfo) );


    wtData.cbStruct = sizeof(wtData);
    wtData.dwUIChoice = WTD_UI_NONE;
    wtData.fdwRevocationChecks = WTD_REVOKE_NONE;
    wtData.dwStateAction = WTD_STATEACTION_VERIFY;
    wtData.dwUnionChoice = WTD_CHOICE_FILE;
    wtData.pFile = &wtFileInfo;

    wtFileInfo.cbStruct = sizeof( wtFileInfo );
    wtFileInfo.pcwszFilePath = lpszCaller;

    hr = WinVerifyTrust (   NULL, 
                            &guidPublishedSoftware, 
                            &wtData
                        );

    if ( ERROR_SUCCESS == hr )
    {   
        //
        // Check to see if this is indeed microsoft
        // signed caller
        //
        dwRetCode = CheckCallerIdentity( wtData.hWVTStateData);
        wtData.dwStateAction = WTD_STATEACTION_CLOSE;
        WinVerifyTrust(NULL, &guidPublishedSoftware, &wtData);
        goto done;

    }

    wtData.dwStateAction = WTD_STATEACTION_CLOSE;
    WinVerifyTrust(NULL, &guidPublishedSoftware, &wtData);

    //
    // We did not find the file was signed.
    // So check the system catalog to see if
    // the file is in the catalog and the catalog 
    // is signed
    //

    //
    // Open the file
    //
    hFile = CreateFileW (    lpszCaller,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                        );


    if ( INVALID_HANDLE_VALUE == hFile )
    {
        dwRetCode = GetLastError();
        goto done;

    }


    fRet = CryptCATAdminAcquireContext( &hCATAdmin,
                                        &guidCatSystemRoot,
                                        0
                                      );
    if ( !fRet )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    //
    // Get the hash of the file here
    //

    fRet = CryptCATAdminCalcHashFromFileHandle ( hFile, 
                                                 &cbHash,
                                                 bHash,
                                                 0
                                                );

    if ( !fRet )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    ZeroMemory(&CatInfo, sizeof(CatInfo));
    CatInfo.cbStruct = sizeof(CatInfo);

    ZeroMemory( &wtCatalogInfo, sizeof(wtCatalogInfo) );

    wtData.dwUnionChoice = WTD_CHOICE_CATALOG;
    wtData.dwStateAction = WTD_STATEACTION_VERIFY;
    wtData.pCatalog = &wtCatalogInfo;

    wtCatalogInfo.cbStruct = sizeof(wtCatalogInfo);

    wtCatalogInfo.hMemberFile = hFile;

    wtCatalogInfo.pbCalculatedFileHash = bHash;
    wtCatalogInfo.cbCalculatedFileHash = cbHash; 


    while ( ( hCATInfo = CryptCATAdminEnumCatalogFromHash ( hCATAdmin,
                                                            bHash,
                                                            cbHash,
                                                            0,
                                                            &hCATInfo
                                                          )
            )
          )
    {
        if (!(CryptCATCatalogInfoFromContext(hCATInfo, &CatInfo, 0)))
        {
            // should do something (??)
            continue;
        }

        wtCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

        hr = WinVerifyTrust (   NULL, 
                                &guidPublishedSoftware, 
                                &wtData
                            );

        if ( ERROR_SUCCESS == hr )
        {
            //
            // Verify that this file is trusted
            //

            dwRetCode = CheckCallerIdentity( wtData.hWVTStateData);
            wtData.dwStateAction = WTD_STATEACTION_CLOSE;
            WinVerifyTrust(NULL, &guidPublishedSoftware, &wtData);

            goto done;
        }
                                
    }

    //
    // File not found in any of the catalogs
    //
    dwRetCode = ERROR_ACCESS_DENIED;
                                                            

    

done:

    if ( hCATInfo )
    {
        CryptCATAdminReleaseCatalogContext( hCATAdmin, hCATInfo, 0 );
    }
    if ( hCATAdmin )
    {
        CryptCATAdminReleaseContext( hCATAdmin, 0 );
    }
    if ( hFile )
    {
        CloseHandle(hFile);
    }
    return dwRetCode;
}

#define PERFORM_CALLER_TRUST 0
DWORD
EapChapBegin(
    OUT VOID **             ppWorkBuffer,
    IN  PPP_EAP_INPUT *     pPppEapInput 
)
{
    void*                           callersAddress;
    DWORD                           dwRetCode;
    MEMORY_BASIC_INFORMATION        mbi;
    SIZE_T                          nbyte;
    DWORD                           nchar;
    wchar_t                         callersModule[MAX_PATH + 1];
#ifdef PERFORM_CALLER_TRUST 
    static BOOL                     fCallerTrusted = FALSE;
#else
    static BOOL                     fCallerTrusted = TRUE;
#endif
    //
    //Verify the caller first and then proceed with 
    //other business
    //
    //
    // This code is causing boot time perf issues
    // So this is removed until XPSP2
#if 0
    if ( !fCallerTrusted )
    {
        //
        //First Verify the caller and then 
        //proceed with initialization
        //

        callersAddress = _ReturnAddress();

        nbyte = VirtualQuery(
                 callersAddress,
                 &mbi,
                 sizeof(mbi)
                 );

        if (nbyte < sizeof(mbi))
        {
            dwRetCode = ERROR_ACCESS_DENIED;
            goto done;
        }

        nchar = GetModuleFileNameW(
                 (HMODULE)(mbi.AllocationBase),
                 callersModule,
                 MAX_PATH
                 );

        if (nchar == 0)
        {
            dwRetCode = GetLastError();
            goto done;
        }
        dwRetCode = VerifyCallerTrust(callersModule);
        if ( NO_ERROR != dwRetCode )
        {
            goto done;
        }
        fCallerTrusted = TRUE; 
    }

#endif
	dwRetCode =  EapChapBeginCommon(	EAPTYPE_MD5Challenge,
                                FALSE,
                                0,
                                NULL,
								ppWorkBuffer,
								pPppEapInput 
							  );
#if 0
done:
#endif
    return dwRetCode;
}

DWORD 
EapMSChapv2End ( IN VOID * pWorkBuf )
{
    DWORD               dwRetCode = NO_ERROR;
    EAPMSCHAPv2WB *     pWB = (EAPMSCHAPv2WB *)pWorkBuf;

    TRACE("EapMSChapv2End");

    if ( pWB )
    {
        dwRetCode = ChapEnd( pWB->pwb );

        LocalFree ( pWB->pUIContextData );
        LocalFree ( pWB->pUserProp );
        LocalFree ( pWB->pConnProp );
        if ( pWB->pUserAttributes )
            RasAuthAttributeDestroy(pWB->pUserAttributes);
        LocalFree( pWB );
    }

    return dwRetCode;
}

//**
//
// Call:        EapChapEnd
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Wrapper around ChapEnd.
//
DWORD
EapChapEnd(
    IN VOID* pWorkBuf 
)
{
    
    return( ChapEnd( pWorkBuf ) );
}

DWORD
GetIdentityFromUserName ( 
LPSTR lpszUserName,
LPSTR lpszDomain,
LPWSTR * ppwszIdentity
)
{
    DWORD   dwRetCode = NO_ERROR;
    DWORD   dwNumBytes;

    //domain+ user + '\' + null
    dwNumBytes = (strlen(lpszUserName) + strlen(lpszDomain) + 1 + 1) * sizeof(WCHAR);
    *ppwszIdentity = LocalAlloc ( LPTR, dwNumBytes);
    if ( NULL == *ppwszIdentity )
    {
        dwRetCode = ERROR_OUTOFMEMORY;
        goto LDone;
    }

    if ( *lpszDomain )
    {
        MultiByteToWideChar( CP_ACP,
                        0,
                        lpszDomain,
                        -1,
                        *ppwszIdentity,
                        dwNumBytes/sizeof(WCHAR) );
    
        wcscat( *ppwszIdentity, L"\\");
    }

    MultiByteToWideChar( CP_ACP,
                    0,
                    lpszUserName,
                    -1,
                    *lpszDomain? *ppwszIdentity + strlen(lpszDomain) + 1:*ppwszIdentity,
                    dwNumBytes/sizeof(WCHAR) - strlen(lpszDomain) );

LDone:
    return dwRetCode;
}
// Convert a number to a hex representation.
BYTE num2Digit(BYTE num)
{
   return (num < 10) ? num + '0' : num + ('A' - 10);
}
//
DWORD
ChangePassword ( IN OUT EAPMSCHAPv2WB * pEapwb, 
                 PPP_EAP_OUTPUT*        pEapOutput, 
                 PPPAP_INPUT*           pApInput)
{
    DWORD                   dwRetCode = NO_ERROR;
    RAS_AUTH_ATTRIBUTE *    pAttribute = NULL;    
    WCHAR                   wszUserName[UNLEN + DNLEN +1] = {0};
    LPWSTR                  lpwszHashUserName = NULL;
    CHAR                    szHashUserName[UNLEN+1] = {0};
    WCHAR                   wszDomainName[DNLEN +1] = {0};
    PBYTE                   pbEncHash = NULL;
    BYTE                    bEncPassword[550] = {0};
    HANDLE                  hAttribute;
    int                     i;


    //
    // check to see if change password attribute is present in 
    // User Attributes
    //
    
    pAttribute = RasAuthAttributeGetVendorSpecific( 
                                VENDOR_MICROSOFT, 
                                MS_VSA_CHAP2_CPW, 
                                pEapOutput->pUserAttributes );

    if ( NULL == pAttribute )
    {
        TRACE ( "no change password attribute");
        
        goto LDone;        
    }

    //Get encrypted Hash
    pbEncHash = (PBYTE)pAttribute->Value + 8;
    
    //
    // Get the user name and domain name
    //

    pAttribute = RasAuthAttributeGet (  raatUserName, 
                                        pEapOutput->pUserAttributes
                                     );

    if ( NULL == pAttribute )
    {
        //Need a better way of sending error
        TRACE ( "UserName missing");
        dwRetCode = ERROR_AUTHENTICATION_FAILURE;        
        goto LDone;
    }

    //
    // Convert the username to unicode
    //
    
    MultiByteToWideChar( CP_ACP,
                        0,
                        pAttribute->Value,
                        pAttribute->dwLength,
                        wszUserName,
                        UNLEN + DNLEN + 1 );


    //
    // Get the hash user name and domain name
    //
    
    lpwszHashUserName = wcschr ( wszUserName, '\\' );
    if ( lpwszHashUserName )
    {
        wcsncpy ( wszDomainName, wszUserName, lpwszHashUserName - wszUserName );
        
        lpwszHashUserName ++;
    }
    else
    {
        lpwszHashUserName = wszUserName;
    }
/*    
    //Convert hash user name to multibyte
    WideCharToMultiByte( CP_ACP,
            0,
            lpwszHashUserName,
            -1,
            szHashUserName,
            DNLEN+1,
            NULL,
            NULL );
*/
    //
    // Get encrypted password
    //

    pAttribute = RasAuthAttributeGetFirst( raatVendorSpecific,
                                           pEapOutput->pUserAttributes,
                                           &hAttribute );

    while ( pAttribute )
    {
        if ( *((PBYTE)pAttribute->Value + 4) == MS_VSA_CHAP_NT_Enc_PW )
        {
            //
            // check to see the sequence number and copy it 
            // proper place in our buffer.
            //
            switch ( WireToHostFormat16 ( (PBYTE) pAttribute->Value + 8 ) )
            {
            case 1:
                CopyMemory( bEncPassword, 
                            (PBYTE)pAttribute->Value + 10,
                            243
                          );
                break;
            case 2:
                CopyMemory( bEncPassword+ 243, 
                            (PBYTE)pAttribute->Value + 10,
                            243
                          );

                break;
            case 3:
                CopyMemory( bEncPassword+ 486, 
                            (PBYTE)pAttribute->Value + 10,
                            30
                          );
                break;
            default:
                TRACE("Invalid enc password attribute");
                break;
            }
        }
        //
        // Check to see if this is enc password
        // and also get the sequence number.
        //
        pAttribute = RasAuthAttributeGetNext( &hAttribute,
                                      raatVendorSpecific );
    }
    //
    // Call Change password function
    //

    dwRetCode = IASChangePassword3( lpwszHashUserName,
                                    wszDomainName,
                                    pbEncHash,
                                    bEncPassword
                                  );
    
LDone:
    return dwRetCode;
}

DWORD
AuthenticateUser ( IN OUT EAPMSCHAPv2WB *     pEapwb,
                   IN PPP_EAP_OUTPUT* pEapOutput, 
                   PPPAP_INPUT * pApInput
                   )
{
    
    DWORD                   dwRetCode = NO_ERROR;
    RAS_AUTH_ATTRIBUTE *    pAttribute = NULL;
    WCHAR                   wszUserName[UNLEN + DNLEN +1] = {0};
    WCHAR                   wszHashUserName[UNLEN+DNLEN+1] = {0};

    //Hash user name is taken from chapwb
    CHAR                    szHashUserName[UNLEN+1] = {0}; 

    WCHAR*                  lpszRover = NULL;

    WCHAR                   wszDomainName[DNLEN +1] = {0};
    //Format is Type + Length + identity + "S=" + 40 bytes response 
    UCHAR                   szAuthSuccessResponse[1+1+1+2+40] ={0}; 
    //Domain Name Type + Length+Domainname
    CHAR                    szDomainName[1+1+1+DNLEN+1] ={0};
    //MPPE Keys Type+Length+Salt+KeyLength+NTkey(16)+PAdding(15)
    BYTE                    bMPPEKey[1+1+2+1+16+15]={0};
    PBYTE                   pbChapChallenge = NULL;
    DWORD                   cbChallenge = 0;
    PBYTE                   pbResponse = NULL;    
    PBYTE                   pbPeerChallenge = NULL;
    IAS_MSCHAP_V2_PROFILE   Profile;
    HANDLE                  hToken = INVALID_HANDLE_VALUE;
    DWORD                   dwCurAttr = 0;
    DWORD                   dwCount=0;
    DWORD                   dwChapRetCode = NO_ERROR;
    //Type + 
    CHAR                    szChapError[64] = {0};
    
    TRACE("Authenticate User");
    //
    // Authenticate the user by calling the IASLogonUser function here
    // This is stolen from IAS.
    //


    //Extract the attribs from pUserAttributes
    //
    // We need following attribs 
    // raatUserName, 
    // MS_VSA_CHAP_Challenge
    // MS_VSA_CHAP2_Response
    // 
    //We dont use the user name got from EAP for auth.  We use the one got from 
    //Radius
#if 0
    pAttribute = RasAuthAttributeGet (  raatUserName, 
                                        pEapOutput->pUserAttributes
                                     );

    if ( NULL == pAttribute )
    {
        //Need a better way of sending error
        TRACE ( "UserName missing");
        dwRetCode = ERROR_AUTHENTICATION_FAILURE;        
        goto done;
    }
    


    //
    // Convert the username to unicode
    //
    
    MultiByteToWideChar( CP_ACP,
                        0,
                        pAttribute->Value,
                        pAttribute->dwLength,
                        wszUserName,
                        UNLEN + DNLEN + 1 );
    
#endif
    //Get the chap challenge and chap response

    pAttribute = RasAuthAttributeGetVendorSpecific( 
                                VENDOR_MICROSOFT, 
                                MS_VSA_CHAP_Challenge, 
                                pEapOutput->pUserAttributes );

    if ( NULL == pAttribute )
    {
        TRACE ( "Challenge missing");
        dwRetCode = ERROR_AUTHENTICATION_FAILURE;        
        goto done;        
    }

    pbChapChallenge = (PBYTE)pAttribute->Value + 6;
    cbChallenge = ((DWORD)(*((PBYTE)pAttribute->Value + 5))) - 2;

    pAttribute = RasAuthAttributeGetVendorSpecific( 
                                VENDOR_MICROSOFT, 
                                MS_VSA_CHAP2_Response, 
                                pEapOutput->pUserAttributes );

    

    if ( NULL == pAttribute )
    {
        //
        // Try and see if this is a change password response
        //
        pAttribute = RasAuthAttributeGetVendorSpecific( 
                                    VENDOR_MICROSOFT, 
                                    MS_VSA_CHAP2_CPW, 
                                    pEapOutput->pUserAttributes );

        if ( NULL == pAttribute )
        {
            TRACE("Response missing");
            dwRetCode = ERROR_AUTHENTICATION_FAILURE;
            goto done;
        }
        
        //
        // Setup response and peer challenge here
        //
        pbPeerChallenge = (PBYTE)pAttribute->Value + 8 + 16;
        pbResponse = (PBYTE)pAttribute->Value + 8 + 16 + 24;

    }
    else
    {

        //
        // Get the peer challenge and response from 
        // the VSA
        //
        pbPeerChallenge = (PBYTE)pAttribute->Value + 8;
        pbResponse = (PBYTE)pAttribute->Value + 8 + 16 + 8;
    }


    //
    // Get the hash user name and domain name
    //
    MultiByteToWideChar( CP_ACP,
                    0,
                    pEapwb->pwb->szUserName,
                    -1,
                    wszHashUserName,
                    UNLEN+DNLEN );

    
    //
    // Get the domain if any
    //

    lpszRover  = wcschr ( wszHashUserName, '\\' );
    if ( lpszRover  )
    {        
        lpszRover++;
    }
    else
    {
        lpszRover  = wszHashUserName;
    }
    
    
    //Convert hash user name to multibyte
    WideCharToMultiByte( CP_ACP,
            0,
            lpszRover,
            -1,
            szHashUserName,
            UNLEN+1,
            NULL,
            NULL );

    

    lpszRover = wcschr ( pEapwb->wszRadiusUserName, '\\');
    if ( lpszRover )
    {
        wcsncpy ( wszDomainName, pEapwb->wszRadiusUserName, lpszRover - pEapwb->wszRadiusUserName );
        lpszRover++;
    }
    else
    {
        lpszRover = pEapwb->wszRadiusUserName;
    }


    dwRetCode = IASLogonMSCHAPv2( (PCWSTR)lpszRover,
                                  (PCWSTR)wszDomainName,
                                  szHashUserName,
                                  pbChapChallenge,
                                  cbChallenge,
                                  pbResponse,
                                  pbPeerChallenge,
                                  &Profile,
                                  &hToken
                                );

    //
    // Map the return errors to correct errors
    // create a set of attributes to be sent back to raschap 
    //

    if ( NO_ERROR == dwRetCode )
    {

        //
        // Setup the authenticator attributes here
        // Following attributes will be send back.
        // 1. SendKey
        // 2. RecvKey
        // 3. AuthResponse
        // 4. MSCHAPDomain
        //
        pApInput->dwAuthResultCode = NO_ERROR;
        pApInput->fAuthenticationComplete = TRUE;

        pAttribute = RasAuthAttributeCreate ( 4 );
        if ( NULL == pAttribute )
        {
            TRACE("RasAuthAttributeCreate failed");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        for ( dwCurAttr = 0; dwCurAttr < 4; dwCurAttr ++ )
        {
            switch ( dwCurAttr )
            {
                case 0:
                    {
            
                        CHAR * p = szDomainName;

                        //
                        // Setup MSCHAP Domain name here
                        //
                        *p++ = (BYTE)MS_VSA_CHAP_Domain;
                        *p++ = (BYTE)wcslen(Profile.LogonDomainName)+1+1;
                        *p++ = 1;
                        WideCharToMultiByte( CP_ACP,
                                0,
                                Profile.LogonDomainName,
                                -1,
                                p,
                                DNLEN+1,
                                NULL,
                                NULL );
                        dwRetCode = RasAuthAttributeInsertVSA(
                                           dwCurAttr,
                                           pAttribute,
                                           VENDOR_MICROSOFT,
                                           (DWORD)szDomainName[1],
                                           szDomainName );

                        break;

                    }
                case 1:
                case 2:
                    {
                        //SEtup MPPE SEnd Key attributes here
                        PBYTE p = bMPPEKey;

                        ZeroMemory(bMPPEKey, sizeof(bMPPEKey) );

                        if ( dwCurAttr == 1 )
                            *p++ = (BYTE)MS_VSA_MPPE_Send_Key; //Type
                        else
                            *p++ = (BYTE)MS_VSA_MPPE_Recv_Key; //Type
                        *p++ = (BYTE)36;                   //Length
                        p++;p++;            //Salt is 0
                        *p++ = 16;            //Key Length
            
                        if ( dwCurAttr == 1 )
                            CopyMemory(p, Profile.SendSessionKey, 16 );
                        else
                            CopyMemory(p, Profile.RecvSessionKey, 16 );

                        dwRetCode = RasAuthAttributeInsertVSA(
                                           dwCurAttr,
                                           pAttribute,
                                           VENDOR_MICROSOFT,
                                           36,
                                           bMPPEKey );

                        break;
                    }
                case 3:
                    {
                        UCHAR * p = szAuthSuccessResponse;
                        *p++ = (BYTE)MS_VSA_CHAP2_Success;    //Type of attr
                        *p++ = (BYTE)45;  //Length of the VSA
                        *p++ = (BYTE)1;    //ID ignored by out implementation of MSCHAPv2
                        *p++ = 'S';
                        *p++ = '=';
            
                        for ( dwCount = 0; dwCount < 20; dwCount++ )
                        {
                            *p++ = num2Digit(Profile.AuthResponse[dwCount] >> 4);
                            *p++ = num2Digit(Profile.AuthResponse[dwCount] & 0xF);
                        }
                        //
                        // Setup the value field here
                        //
                        dwRetCode = RasAuthAttributeInsertVSA(
                                           dwCurAttr,
                                           pAttribute,
                                           VENDOR_MICROSOFT,
                                           45,
                                           szAuthSuccessResponse );
                        break;

                    }

                default:
                    break;

            }
            if ( NO_ERROR != dwRetCode )
            {
                TRACE("RasAuthAttributeInsetVSA failed");
                goto done;
            }

        }
    
        pApInput->pAttributesFromAuthenticator = pAttribute;
        //
        // Also save the attributes in the WB to send across later.
        //
        pEapwb->pUserAttributes = pAttribute;
        pEapwb->dwAuthResultCode = NO_ERROR;

        pApInput->fAuthenticationComplete = TRUE;
        pApInput->dwAuthResultCode = pApInput->dwAuthError = NO_ERROR;

    }
    else
    {
        //
        // Handle the failure by sending 
        //
        
        switch ( dwRetCode )
        {
            case ERROR_INVALID_LOGON_HOURS:
                dwChapRetCode  = ERROR_RESTRICTED_LOGON_HOURS;
                
                break;

            case ERROR_ACCOUNT_DISABLED:
                dwChapRetCode = ERROR_ACCT_DISABLED;
                
                break;

            case ERROR_PASSWORD_EXPIRED:
            case ERROR_PASSWORD_MUST_CHANGE:
                dwChapRetCode  = ERROR_PASSWD_EXPIRED;
                break;

            case ERROR_ILL_FORMED_PASSWORD:
            case ERROR_PASSWORD_RESTRICTION:
                dwChapRetCode  = ERROR_CHANGING_PASSWORD;
                break;

            default:
                dwChapRetCode = ERROR_AUTHENTICATION_FAILURE;
        }
        pAttribute = RasAuthAttributeCreate ( 1 );
        if ( NULL == pAttribute )
        {
            TRACE("RasAuthAttributeCreate failed");
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
        //Make a VSA out of this and send it back
        wsprintf ( &szChapError[3], "E=%lu R=0 V=3", dwChapRetCode );
        szChapError[0] = MS_VSA_CHAP_Error;
        szChapError[1] = 3 + strlen(&szChapError[3]);
        szChapError[2] = pEapwb->IdToExpect;
        dwRetCode = RasAuthAttributeInsertVSA(
                           0,
                           pAttribute,
                           VENDOR_MICROSOFT,
                           szChapError[1],
                           szChapError );
        pApInput->fAuthenticationComplete = TRUE;

        pApInput->pAttributesFromAuthenticator = pAttribute;
        pApInput->dwAuthError = NO_ERROR;
        pApInput->dwAuthResultCode = dwChapRetCode;
    }
        

    

done:
    if ( INVALID_HANDLE_VALUE != hToken )
        CloseHandle(hToken);
    if ( NO_ERROR != dwRetCode )
    {
        RasAuthAttributeDestroy(pAttribute);
        pApInput->pAttributesFromAuthenticator = NULL;
    }
    return dwRetCode;
}


DWORD
CallMakeMessageAndSetEAPState(
    IN      PVOID       pWorkBuf, 
    IN      PPP_CONFIG* pReceiveBuf,
    IN OUT  PPP_CONFIG* pSendBuf,
    IN      DWORD       cbSendBuf,
    PPPAP_RESULT *      pApResult,
    PPPAP_INPUT  *      pApInput,
    OUT PPP_EAP_OUTPUT* pEapOutput
)
{
    DWORD       dwRetCode = NO_ERROR;
    CHAPWB *    pwb = (CHAPWB *)pWorkBuf;

    dwRetCode = ChapMakeMessage(
                            pWorkBuf,
                            pReceiveBuf,
                            pSendBuf,
                            cbSendBuf,
                            pApResult,
                            pApInput );

    if ( dwRetCode != NO_ERROR )
    {
        goto done;
    }


    switch( pApResult->Action )
    {
    case APA_NoAction:
        pEapOutput->Action = EAPACTION_NoAction;
        break;

    case APA_Done:
        pEapOutput->Action = EAPACTION_Done;
        break;

    case APA_SendAndDone:
    case APA_Send:
        pEapOutput->Action = EAPACTION_Send;
        break;

    case APA_SendWithTimeout:

        pEapOutput->Action = ( pwb->fServer ) 
                                    ? EAPACTION_SendWithTimeout
                                    : EAPACTION_Send;
        break;

    case APA_SendWithTimeout2:

        pEapOutput->Action = ( pwb->fServer ) 
                                    ? EAPACTION_SendWithTimeoutInteractive
                                    : EAPACTION_Send;
        break;

    case APA_Authenticate:
        pEapOutput->pUserAttributes = pApResult->pUserAttributes;
        pEapOutput->Action          = EAPACTION_Authenticate;
        break;

    default:
        RTASSERT(FALSE);
        break;
    }

done:
    return dwRetCode;
}


DWORD 
EapMSChapv2SMakeMessage(
    IN  VOID*               pWorkBuf,
    IN  PPP_EAP_PACKET*     pReceivePacket,
    OUT PPP_EAP_PACKET*     pSendPacket,
    IN  DWORD               cbSendPacket,
    OUT PPP_EAP_OUTPUT*     pEapOutput,
    IN  PPP_EAP_INPUT*      pEapInput 
)
{
    DWORD                           dwRetCode = NO_ERROR;
    PPP_CONFIG *                    pReceiveBuf = NULL;
    PPP_CONFIG *                    pSendBuf    = NULL;
    DWORD                           cbSendBuf   = 1500;
    PPPAP_INPUT                     ApInput;
    PPPAP_RESULT                    ApResult;
    WORD                            cbPacket = 0;
    EAPMSCHAPv2WB *                 pEapwb = (EAPMSCHAPv2WB * ) pWorkBuf;
    TRACE("EapMSChapv2SMakeMessage");
    //
    //Do default processing here.
    //
    ZeroMemory( &ApResult, sizeof(ApResult) );

    if ( ( pSendBuf = LocalAlloc( LPTR, cbSendBuf ) ) == NULL )
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    
    if ( pEapInput != NULL )
    { 
        MapEapInputToApInput( pEapInput, &ApInput );
    }
    
    switch ( pEapwb->EapState )
    {
        case EMV2_Initial:
            TRACE("EMV2_Initial");
            //
            // This is the first time this has been invoked.
            // So we make a MACHAPv2 chap challenge and send
            // back a response
            //
            dwRetCode = CallMakeMessageAndSetEAPState(
                            pEapwb->pwb, 
                            pReceiveBuf,
                            pSendBuf,
                            cbSendBuf,
                            &ApResult,
                            ( pEapInput ? &ApInput : NULL ),
                            pEapOutput
                        );
            //
            // We got the CHAP Challenge now.  If all's fine
            // package the result back and send it to the client
            //
            //
            // Translate MSCHAPv2 packet to EAP packet
            //
            if ( NO_ERROR == dwRetCode && pSendBuf )
            {
                pSendPacket->Code = EAPCODE_Request;
                pEapwb->IdToExpect = pEapwb->IdToSend = 
                    pSendPacket->Id = pEapwb->pwb->bIdToSend;
                //
                // Length = sizeof Header + sizeof MSCHAP packet to send
                // This includes the first byte of                
                cbPacket = WireToHostFormat16( pSendBuf->Length );

                CopyMemory ( pSendPacket->Data+1, pSendBuf, cbPacket);

                cbPacket += sizeof(PPP_EAP_PACKET);

                HostToWireFormat16( cbPacket, pSendPacket->Length );

			    pSendPacket->Data[0] = (BYTE)PPP_EAP_MSCHAPv2;
                
                pEapwb->EapState = EMV2_RequestSend;
            }

            break;
        case EMV2_RequestSend:
            TRACE("EMV2_RequestSend");
            //
            // We should only get a response here.
            // If not discard this packet.
            //

            if ( NULL != pReceivePacket )
            {
                if ( pReceivePacket->Code != EAPCODE_Response )
                {
                    TRACE("Got unexpected packet.  Does not have response");
                    dwRetCode = ERROR_PPP_INVALID_PACKET;
                    break;
                }
                if ( pReceivePacket->Id != pEapwb->IdToExpect )
                {
                    TRACE("received packet id does not match");
                    dwRetCode = ERROR_PPP_INVALID_PACKET;
                    break;
                }
                //
                // Translate the packet received to
                // MSCHAP v2 format
                // 
                cbPacket = WireToHostFormat16(pReceivePacket->Length);
                
                if ( cbPacket > sizeof( PPP_EAP_PACKET ) )
                {
                    pReceiveBuf = (PPP_CONFIG *)( pReceivePacket->Data + 1);

                    dwRetCode = CallMakeMessageAndSetEAPState(
                                    pEapwb->pwb, 
                                    pReceiveBuf,
                                    pSendBuf,
                                    cbSendBuf,
                                    &ApResult,
                                    ( pEapInput ? &ApInput : NULL ),
                                    pEapOutput
                                );
                    if ( NO_ERROR == dwRetCode )
                    {
                        //Check to see if we are asked to authenticate
                        if ( pEapOutput->Action == EAPACTION_Authenticate )
                        {
                            //
                            // If we have come this far pEapInput cannot be NULL
                            // Or else it is a bug in the client.
                            //

                            //
                            // Check to see if this is a change password request
                            // If so first change tha password and then authenticate.
                            //

                            dwRetCode = ChangePassword (pEapwb, pEapOutput, &ApInput);
                            if ( NO_ERROR == dwRetCode )
                            {
                                //
                                // Now authenticate user
                                //
                                dwRetCode = AuthenticateUser (pEapwb, pEapOutput, &ApInput );
                            }
                            //
                            // We will get a set of auth attributes back 
                            // that we need to send back to the mschap
                            // protocol.
                            //
                            
                            dwRetCode = CallMakeMessageAndSetEAPState
                                                                (
                                                                    pEapwb->pwb, 
                                                                    pReceiveBuf,
                                                                    pSendBuf,
                                                                    cbSendBuf,
                                                                    &ApResult,
                                                                    &ApInput,
                                                                    pEapOutput

                                                                 );
                        }

                        //
                        // Check to see if auth was success or fail.
                        // If Auth was success then set state to EMV2_CHAPAuthSuccess
                        //

                        if ( NO_ERROR == dwRetCode && pSendBuf )
                        {
                            pSendPacket->Code = EAPCODE_Request;
                            pEapwb->IdToSend ++;
                            pEapwb->IdToExpect = pSendPacket->Id = pEapwb->IdToSend;
                            //
                            // Length = sizeof Header + sizeof MSCHAP packet to send
                            // This includes the first byte of                
                            cbPacket = WireToHostFormat16( pSendBuf->Length );

                            CopyMemory ( pSendPacket->Data+1, pSendBuf, cbPacket);

                            cbPacket += sizeof(PPP_EAP_PACKET);

                            HostToWireFormat16( cbPacket, pSendPacket->Length );

			                pSendPacket->Data[0] = (BYTE)PPP_EAP_MSCHAPv2;                
                
                            if ( pEapwb->pwb->result.dwError == NO_ERROR )
                            {
                                //
                                // We succeeded in auth
                                //
                                pEapwb->EapState = EMV2_CHAPAuthSuccess;
                                pEapOutput->Action = EAPACTION_SendWithTimeout;
                                
                            }
                            else
                            {
                                //
                                // Could be a retryable failure.  So we need to send
                                // with interactive timeout.
                                //
                                if ( pEapwb->pwb->result.fRetry )
                                {
                                    pEapwb->EapState = EMV2_RequestSend;
                                    pEapOutput->Action = EAPACTION_SendWithTimeoutInteractive;
                                }                                
                                else if ( pEapwb->pwb->result.dwError == ERROR_PASSWD_EXPIRED )
                                {
                                    if ( pEapwb->pUserProp->fFlags & EAPMSCHAPv2_FLAG_ALLOW_CHANGEPWD )
                                    {
                                        //
                                        // Check to see if this is allowed
                                        //
                                        pEapwb->EapState = EMV2_RequestSend;
                                        pEapOutput->Action = EAPACTION_SendWithTimeoutInteractive;                                        
                                    }
                                    else
                                    {
                                        pSendPacket->Code = EAPCODE_Failure;
                                        HostToWireFormat16 ( (WORD)4, pSendPacket->Length );
                                        pEapwb->EapState = EMV2_Failure;
                                        pEapOutput->dwAuthResultCode = pEapwb->pwb->result.dwError;
                                        pEapOutput->Action = EAPACTION_SendAndDone;
                                    }
                                }
                                else
                                {
                                    pSendPacket->Code = EAPCODE_Failure;
                                    HostToWireFormat16 ( (WORD)4, pSendPacket->Length );
                                    pEapwb->EapState = EMV2_Failure;
                                    pEapOutput->dwAuthResultCode = pEapwb->pwb->result.dwError;
                                    pEapOutput->Action = EAPACTION_SendAndDone;                                    
                                }
                            }   
                            
                        }
                    }
                }
                else
                {
                    //
                    //  We should never get an empty response in
                    //
                    dwRetCode = ERROR_PPP_INVALID_PACKET;                    
                }

            }
            else
            {
                dwRetCode = ERROR_PPP_INVALID_PACKET;
            }
            break;
        case EMV2_CHAPAuthSuccess:
            TRACE("EMV2_CHAPAuthSuccess");
            //
            // We should only get an response here indicating 
            // if the client could validate the server successfully.
            // Then we can send back a EAP_SUCCESS or EAP_FAIL.
            //
            if ( NULL != pReceivePacket )
            {
                if ( pReceivePacket->Code != EAPCODE_Response )
                {
                    dwRetCode = ERROR_PPP_INVALID_PACKET;
                    break;
                }

                if ( pReceivePacket->Id != pEapwb->IdToExpect )
                {
                    //Invalid packet id
                    dwRetCode = ERROR_PPP_INVALID_PACKET;
                    break;
                }

                //
                // Translate the packet received to
                // MSCHAP v2 format
                // 
                cbPacket = WireToHostFormat16(pReceivePacket->Length);
                if ( cbPacket == sizeof( PPP_EAP_PACKET ) + 1 )
                {
                    //
                    // Check to see if the data is CHAPCODE_Success
                    // or CHAPCode Fail and send appropriate packet
                    //
                    if ( *(pReceivePacket->Data+1) == CHAPCODE_Success )
                    {
                        //
                        //peer could auth successfully
                        //
                        pSendPacket->Code = EAPCODE_Success;
                    }
                    else
                    {
                        pSendPacket->Code = EAPCODE_Failure;
                    }
                    pEapwb->IdToSend++;

                    pEapwb->IdToExpect = 
                        pSendPacket->Id = pEapwb->IdToSend;

                    HostToWireFormat16( (WORD)4, pSendPacket->Length );

                    pEapwb->EapState = EMV2_Success;

                    //Set the Out attributes here
                    pEapOutput->pUserAttributes = pEapwb->pUserAttributes;
                    pEapOutput->dwAuthResultCode = pEapwb->dwAuthResultCode;

                    pEapOutput->Action = EAPACTION_SendAndDone;
                                                
                }
                else
                {
                    dwRetCode = ERROR_PPP_INVALID_PACKET;
                }
            }

            break;
        case EMV2_CHAPAuthFail:
            TRACE("EMV2_CHAPAuthFail");
            //
            // We could get a retry or a change password packet here
            // Again we should get only a EAPCODE_Response here...

            //
            //Got a response.  So send it to MSCHAP and see what happens
            //

            break;
        case EMV2_Success:
            TRACE("EMV2_Success");
            //
            // See the CS_Done state in raschap for this state to be here.
            //

            break;
        case EMV2_Failure:
            TRACE("EMV2_Failure");
            break;

        case EMV2_ResponseSend:
        default:
            TRACE1("Why is this EAPMschapv2 in this state? %d",pEapwb->EapState );
            break;
    }

done:
    if ( pSendBuf )
    {
        LocalFree(pSendBuf);
    }
    
    return dwRetCode;
}


DWORD
GetClientMPPEKeys ( EAPMSCHAPv2WB *pEapwb, PPPAP_RESULT * pApResult )
{
    DWORD   dwRetCode = NO_ERROR;
    BYTE    bRecvKey[16] = {0};
    BYTE    bSendKey[16] = {0};
    RAS_AUTH_ATTRIBUTE * pAttribute;
    RAS_AUTH_ATTRIBUTE * pSendRecvKeyAttr = NULL;
    //MPPE Keys Type+Length+Salt+KeyLength+NTkey(16)+PAdding(15)
    BYTE                    bMPPEKey[1+1+2+1+16+15]={0};

    TRACE("GetClientMPPEKeys");

    pEapwb->pUserAttributes = NULL;

    pAttribute = RasAuthAttributeGetVendorSpecific(
                            311, MS_VSA_CHAP_MPPE_Keys, 
                            pApResult->pUserAttributes);

    if ( NULL == pAttribute  )
    {
        TRACE("No User Session Key");
        dwRetCode = ERROR_NOT_FOUND;
        goto done;
    }

    dwRetCode = IASGetSendRecvSessionKeys( ((PBYTE)(pAttribute->Value))+6+8,
                                            16,
                                            pApResult->abResponse,
                                            24,
                                            bSendKey,
                                            bRecvKey
                         );

    if ( NO_ERROR != dwRetCode )
    {
        TRACE("Failed to generate send/recv keys");
        goto done;
    }

    pSendRecvKeyAttr = RasAuthAttributeCreate ( 2 );
    if ( NULL == pSendRecvKeyAttr )
    {
        TRACE("RasAuthAttributeCreate failed");
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    bMPPEKey[0] = MS_VSA_MPPE_Send_Key;
    bMPPEKey[1] = 36;
    bMPPEKey[4] = 16;
    CopyMemory(&bMPPEKey[5], bSendKey, 16 );

    dwRetCode = RasAuthAttributeInsertVSA(
                       0,
                       pSendRecvKeyAttr,
                       VENDOR_MICROSOFT,
                       36,
                       bMPPEKey );

    if ( NO_ERROR != dwRetCode )
    {
        TRACE("Failed to insert send key");
        goto done;
    }

    bMPPEKey[0] = MS_VSA_MPPE_Recv_Key;
    CopyMemory(&bMPPEKey[5], bRecvKey, 16 );
    
    dwRetCode = RasAuthAttributeInsertVSA(
                       1,
                       pSendRecvKeyAttr,
                       VENDOR_MICROSOFT,
                       36,
                       bMPPEKey );

    if ( NO_ERROR != dwRetCode )
    {
        TRACE("Failed to insert recv key");
        goto done;
    }

    pEapwb->pUserAttributes = pSendRecvKeyAttr;
done:
    if ( NO_ERROR != dwRetCode )
    {
        if ( pSendRecvKeyAttr )
            RasAuthAttributeDestroy(pSendRecvKeyAttr);
    }
    return dwRetCode;
}


DWORD 
EapMSChapv2CMakeMessage(
    IN  VOID*               pWorkBuf,
    IN  PPP_EAP_PACKET*     pReceivePacket,
    OUT PPP_EAP_PACKET*     pSendPacket,
    IN  DWORD               cbSendPacket,
    OUT PPP_EAP_OUTPUT*     pEapOutput,
    IN  PPP_EAP_INPUT*      pEapInput 
)
{
    DWORD               dwRetCode = NO_ERROR;
    PPP_CONFIG*         pReceiveBuf = NULL;
    PPP_CONFIG*         pSendBuf    = NULL;
    DWORD               cbSendBuf   = 1500;
    PPPAP_INPUT         ApInput;
    PPPAP_RESULT        ApResult;
    WORD                cbPacket = 0;
    EAPMSCHAPv2WB *     pEapwb = (EAPMSCHAPv2WB * ) pWorkBuf;
    TRACE("EapMSChapv2CMakeMessage");
    //
    //Do default processing here.
    //
    ZeroMemory( &ApResult, sizeof(ApResult) );

    if ( ( pSendBuf = LocalAlloc( LPTR, cbSendBuf ) ) == NULL )
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    
    if ( pEapInput != NULL )
    { 
        MapEapInputToApInput( pEapInput, &ApInput );
    }
    switch ( pEapwb->EapState )
    {
        case EMV2_Initial:
            TRACE("EMV2_Initial");
            //
            // We can oly get a request here...
            //
            if ( NULL != pReceivePacket )
            {
                if ( pReceivePacket->Code != EAPCODE_Request )
                {
                    dwRetCode = ERROR_PPP_INVALID_PACKET;
                    break;
                }
                //
                // Translate the packet received to
                // MSCHAP v2 format
                // 
                cbPacket = WireToHostFormat16(pReceivePacket->Length);
                
                if ( cbPacket > sizeof( PPP_EAP_PACKET ) )
                {
                    pReceiveBuf = (PPP_CONFIG *) (pReceivePacket->Data + 1);

                    dwRetCode = CallMakeMessageAndSetEAPState(
                                    pEapwb->pwb, 
                                    pReceiveBuf,
                                    pSendBuf,
                                    cbSendBuf,
                                    &ApResult,
                                    ( pEapInput ? &ApInput : NULL ),
                                    pEapOutput
                                );
            
                    // Translate MSCHAPv2 packet to EAP packet
                    //
                    if ( NO_ERROR == dwRetCode && pSendBuf )
                    {
                        pSendPacket->Code = EAPCODE_Response;

                        pEapwb->IdToExpect = pEapwb->IdToSend = 
                            pSendPacket->Id = pEapwb->pwb->bIdToSend;
                        //
                        // Length = sizeof Header + sizeof MSCHAP packet to send
                        // This includes the first byte of                
                        cbPacket = WireToHostFormat16( pSendBuf->Length );

                        CopyMemory ( pSendPacket->Data+1, pSendBuf, cbPacket);

                        cbPacket += sizeof(PPP_EAP_PACKET);

                        HostToWireFormat16( cbPacket, pSendPacket->Length );

			            pSendPacket->Data[0] = (BYTE)PPP_EAP_MSCHAPv2;
                
                        pEapwb->EapState = EMV2_ResponseSend;
                    }
                }
            }

            break;        
        case EMV2_ResponseSend:
            TRACE("EMV2_ResponseSend");
            //
            // We should get either a CHAP auth success or CHAP Auth fail here
            // for the initial challenge send out.
            //
            if ( NULL != pReceivePacket )
            {
                if ( pReceivePacket->Code != EAPCODE_Request &&
                     pReceivePacket->Code != EAPCODE_Failure 
                   )
                {
                    dwRetCode = ERROR_PPP_INVALID_PACKET;
                    break;
                }
                if ( pReceivePacket->Code == EAPCODE_Failure )
                {
                    TRACE("Got a Code Failure when expecting Response.  Failing Auth");
                    pEapwb->EapState = EMV2_Failure;
                    pEapOutput->Action = EAPACTION_Done;
                    pEapOutput->fSaveUserData = FALSE;
                    ZeroMemory ( pEapwb->pUserProp->szPassword, sizeof( pEapwb->pUserProp->szPassword ) );
                    pEapOutput->dwAuthResultCode = ERROR_AUTHENTICATION_FAILURE;
                    break;
                }
                //
                // Translate the packet received to
                // MSCHAP v2 format
                // 
                cbPacket = WireToHostFormat16(pReceivePacket->Length);
                
                if ( cbPacket > sizeof( PPP_EAP_PACKET ) )
                {
                    pReceiveBuf = (PPP_CONFIG *) (pReceivePacket->Data + 1);

                    dwRetCode = CallMakeMessageAndSetEAPState(
                                    pEapwb->pwb, 
                                    pReceiveBuf,
                                    pSendBuf,
                                    cbSendBuf,
                                    &ApResult,
                                    ( pEapInput ? &ApInput : NULL ),
                                    pEapOutput
                                );
                    //
                    // Translate MSCHAPv2 packet to EAP packet
                    //
                    if ( NO_ERROR == dwRetCode && pSendBuf )
                    {
                        if ( ApResult.dwError == NO_ERROR )
                        {
                            if ( ApResult.Action == APA_NoAction )
                            {
                                pEapOutput->Action = EAPACTION_NoAction;
                            
                                pEapOutput->dwAuthResultCode = NO_ERROR;    
                                break;
                            }
                            //
                            // We need to change MSCHAP keys to MPPE send recv keys
                            // This is needed because there is no way to pass the 
                            // MSCHAP challenge response back 
                            //
                            dwRetCode = GetClientMPPEKeys ( pEapwb, &ApResult );
                            if ( NO_ERROR != dwRetCode )
                            {
                                break;
                            }

                            //
                            //Client could successfully validate the server
                            //
                            pSendPacket->Code = EAPCODE_Response;
                            pEapwb->IdToSend ++;
                            //send the same id as received packet back
                            pEapwb->IdToExpect = pSendPacket->Id = pReceivePacket->Id;
                            //
                            // Length = sizeof Header + sizeof MSCHAP packet to send
                            // This includes the first byte of                
                            

                            * (pSendPacket->Data+1) = CHAPCODE_Success;

                            cbPacket = sizeof(PPP_EAP_PACKET) + 1;

                            HostToWireFormat16( cbPacket, pSendPacket->Length );

			                pSendPacket->Data[0] = (BYTE)PPP_EAP_MSCHAPv2;
                
                            pEapwb->EapState = EMV2_CHAPAuthSuccess;
                            //
                            // Set the out attributes and the response
                            //
                            pEapOutput->Action = EAPACTION_Send;
                            
                            pEapwb->dwAuthResultCode = ApResult.dwError; 
                        }
                        else
                        {
                            //
                            // Based on what MSCHAPV2 has send back
                            // we need to Invoke appropriate interactive UI
                            // Retry password or change password here.
                            // If both retry and change pwd are not
                            // applicable then just send a fail message.
                            // and wait for EAP_Failure message from server.
                            // And Auth state goes to CHAPAuthFailed
                            // 
                            // If this is a failure with rety then show 
                            // interactive UI.
                            if ( pEapwb->fFlags & EAPMSCHAPv2_FLAG_MACHINE_AUTH )
                            {
                                //
                                // This is a machine auth.  So we dont to show any
                                // retry or any of that stuff even though the server
                                // might have send such things back.
                                //
                                    pEapOutput->dwAuthResultCode = ERROR_AUTHENTICATION_FAILURE;
                                    pEapOutput->Action = EAPACTION_Done;
                                    pEapwb->EapState = EMV2_Failure;


                            }
                            else
                            {
                                if ( ApResult.fRetry )
                                {
                                    pEapOutput->fInvokeInteractiveUI = TRUE;
                                    //
                                    // Setup the UI Context data
                                    //
                                    pEapwb->pUIContextData = 
                                    (PEAPMSCHAPv2_INTERACTIVE_UI) LocalAlloc ( LPTR, 
                                            sizeof(EAPMSCHAPv2_INTERACTIVE_UI) );

                                    if ( NULL == pEapwb->pUIContextData )
                                    {                                    
                                        TRACE ("Error allocating memory for UI context data");
                                        dwRetCode = ERROR_OUTOFMEMORY;
                                        goto done;
                                    }
                                    pEapwb->pUIContextData->dwVersion = 1;
                                    pEapwb->pUIContextData->fFlags |= EAPMSCHAPv2_INTERACTIVE_UI_FLAG_RETRY;
                                    pEapwb->dwInteractiveUIOperation |= EAPMSCHAPv2_INTERACTIVE_UI_FLAG_RETRY;
                                    if ( pEapwb->pUserProp )
                                    {
                                        CopyMemory( &(pEapwb->pUIContextData->UserProp), 
                                                    pEapwb->pUserProp,
                                                    sizeof(EAPMSCHAPv2_USER_PROPERTIES)
                                                );
                                    }
                                    if ( pEapwb->pConnProp->fFlags & EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS )
                                    {
                                       //We are using winlogon creds
                                       // and this is a retryable failure
                                       // so copy over the username and domain
                                       // from chap wb to eapchap wb
				                        WCHAR * pWchar = NULL;
				                        pWchar = wcschr( pEapwb->wszRadiusUserName, L'\\' );

                                        if ( pWchar == NULL )
                                        {
                                            WideCharToMultiByte(
                                                            CP_ACP,
                                                            0,
                                                            pEapwb->wszRadiusUserName,
                                                            -1,
                                                            pEapwb->pUIContextData->UserProp.szUserName,
                                                            UNLEN + 1,
                                                            NULL,
                                                            NULL );
                                        }
                                        else
                                        {
                                            *pWchar = 0;

                                            WideCharToMultiByte(
                                                            CP_ACP,
                                                            0,
                                                            pEapwb->wszRadiusUserName,
                                                            -1,
                                                            pEapwb->pUIContextData->UserProp.szDomain,
                                                            DNLEN + 1,
                                                            NULL,
                                                            NULL );

                                            *pWchar = L'\\';

                                            WideCharToMultiByte(
                                                            CP_ACP,
                                                            0,
                                                            pWchar + 1,
                                                            -1,
                                                            pEapwb->pUIContextData->UserProp.szUserName,
                                                            UNLEN + 1,
                                                            NULL,
                                                            NULL );
                                        }

                                    }
                                    pEapOutput->Action = EAPACTION_NoAction;
                                    pEapOutput->pUIContextData = (PBYTE)pEapwb->pUIContextData;
                                    pEapOutput->dwSizeOfUIContextData = sizeof(EAPMSCHAPv2_INTERACTIVE_UI);
                                    pEapwb->EapState = EMV2_CHAPAuthFail;
                                }
                                else if ( ApResult.dwError == ERROR_PASSWD_EXPIRED )
                                {
                                    //
                                    // show the change password GUI.
                                    //

                                    pEapOutput->fInvokeInteractiveUI = TRUE;
                                    //
                                    // Setup the UI Context data
                                    //
                                    pEapwb->pUIContextData = 
                                    (PEAPMSCHAPv2_INTERACTIVE_UI) LocalAlloc ( LPTR, 
                                            sizeof(EAPMSCHAPv2_INTERACTIVE_UI) );

                                    if ( NULL == pEapwb->pUIContextData )
                                    {                                    
                                        TRACE ("Error allocating memory for UI context data");
                                        dwRetCode = ERROR_OUTOFMEMORY;
                                        goto done;
                                    }
                                    pEapwb->pUIContextData->dwVersion = 1;
                                    if ( pEapwb->pConnProp->fFlags & EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS )
                                    {
                                        //
                                        // Show the dialog with old pwd, new pwd and conf pwd
                                        //
                                        pEapwb->pUIContextData->fFlags |= EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD_WINLOGON;
                                        pEapwb->dwInteractiveUIOperation |= EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD_WINLOGON;
                                    }
                                    else
                                    {
                                        //
                                        // We have the old password.  So show the dialog with new pwd and conf pwd.
                                        //
                                        pEapwb->pUIContextData->fFlags |= EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD;
                                        pEapwb->dwInteractiveUIOperation |= EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD;
                                    }
                                    if ( pEapwb->pUserProp )
                                    {
                                        CopyMemory( &(pEapwb->pUIContextData->UserProp), 
                                                    pEapwb->pUserProp,
                                                    sizeof(EAPMSCHAPv2_USER_PROPERTIES)
                                                );
                                    }
                                    pEapOutput->Action = EAPACTION_NoAction;
                                    pEapOutput->pUIContextData = (PBYTE)pEapwb->pUIContextData;
                                    pEapOutput->dwSizeOfUIContextData = sizeof(EAPMSCHAPv2_INTERACTIVE_UI);
                                    pEapwb->EapState = EMV2_CHAPAuthFail;

                                }
                                else
                                {
                                    //
                                    // this is not a retryable failure
                                    // So we are done with Auth and failed.
                                    //
                                    pEapOutput->dwAuthResultCode = ApResult.dwError;
                                    pEapOutput->Action = EAPACTION_Done;
                                    pEapwb->EapState = EMV2_Failure;
                                }                            
                            }
                        }
                    }
                    else
                    {
                        // Something went wrong here.
                        TRACE1("Error returned by MSCHAPv2 protocol 0x%x", dwRetCode);
                    }
                }
                else
                {
                    dwRetCode = ERROR_PPP_INVALID_PACKET;
                    
                }
            }
            else
            {
                dwRetCode = ERROR_PPP_INVALID_PACKET;
            }
            break;
        case EMV2_CHAPAuthFail:
            TRACE("EMV2_CHAPAuthFail");
            //
            // We come here in case of a retryable
            // failure from chap and after we have popped 
            // interactive UI.
            //
            //
            // Check to see if we have got data from user
            //
            if ( pEapInput->fDataReceivedFromInteractiveUI )
            {
                //
                // Copy the new uid/pwd and then call chap make message again.
                // adjust our state
                LocalFree(pEapwb->pUIContextData);
                pEapwb->pUIContextData = NULL;
                LocalFree(pEapwb->pUserProp);
                pEapwb->pUserProp = (PEAPMSCHAPv2_USER_PROPERTIES)LocalAlloc(LPTR, 
                                    sizeof(EAPMSCHAPv2_USER_PROPERTIES) );
                if (NULL == pEapwb->pUserProp )
                {
                    TRACE("Failed to allocate memory for user props.");
                    dwRetCode = ERROR_OUTOFMEMORY;
                    break;
                }
                CopyMemory( pEapwb->pUserProp, 
                            &(((PEAPMSCHAPv2_INTERACTIVE_UI)(pEapInput->pDataFromInteractiveUI))->UserProp), 
                            sizeof(EAPMSCHAPv2_USER_PROPERTIES)
                          );

                //
                // Call into mschap here
                //
                ApInput.pszDomain   = pEapwb->pUserProp->szDomain;
                if ( ((PEAPMSCHAPv2_INTERACTIVE_UI)(pEapInput->pDataFromInteractiveUI))->fFlags & 
                        EAPMSCHAPv2_INTERACTIVE_UI_FLAG_RETRY 
                   )
                {
                    ApInput.pszUserName = pEapwb->pUserProp->szUserName;
                    ApInput.pszPassword = pEapwb->pUserProp->szPassword;
                }
                else
                {

                    if ( pEapwb->pConnProp->fFlags & EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS )
                    {
                        CopyMemory ( pEapwb->pUserProp->szPassword,
                                     ((PEAPMSCHAPv2_INTERACTIVE_UI)(pEapInput->pDataFromInteractiveUI))->UserProp.szPassword,
                                     PWLEN
                                   );                        
                    }

                    CopyMemory ( pEapwb->szOldPassword, 
                                pEapwb->pUserProp->szPassword,
                                PWLEN

                            );

                    CopyMemory ( pEapwb->pUserProp->szPassword, 
                                ((PEAPMSCHAPv2_INTERACTIVE_UI)(pEapInput->pDataFromInteractiveUI))->szNewPassword,
                                PWLEN
                               );
                    
                    ApInput.pszUserName = pEapwb->pUserProp->szUserName;
                    ApInput.pszPassword = pEapwb->pUserProp->szPassword;
                    ApInput.pszOldPassword = pEapwb->szOldPassword;
                }
                dwRetCode = CallMakeMessageAndSetEAPState(
                                pEapwb->pwb, 
                                pReceiveBuf,
                                pSendBuf,
                                cbSendBuf,
                                &ApResult,
                                ( pEapInput ? &ApInput : NULL ),
                                pEapOutput
                            );
                if ( NO_ERROR == dwRetCode && pSendBuf )
                {
                    pSendPacket->Code = EAPCODE_Response;
                    
                    
                    pSendPacket->Id = pEapwb->pwb->bIdToSend;
                    //
                    // Length = sizeof Header + sizeof MSCHAP packet to send
                    // This includes the first byte of                
                    cbPacket = WireToHostFormat16( pSendBuf->Length );

                    CopyMemory ( pSendPacket->Data+1, pSendBuf, cbPacket);

                    cbPacket += sizeof(PPP_EAP_PACKET);

                    HostToWireFormat16( cbPacket, pSendPacket->Length );

			        pSendPacket->Data[0] = (BYTE)PPP_EAP_MSCHAPv2;
            
                    pEapwb->EapState = EMV2_ResponseSend;
                    pEapOutput->dwAuthResultCode = ApResult.dwError;
                    pEapOutput->Action = EAPACTION_Send;

                }

            }
            else
            {
                TRACE("No Data received from interactive UI when expecting some");
                //Work around for PPP misbehavior.  We have invoked
                //interactive UI and ppp is sending stuff to us all the time...

                if ( !pEapwb->pUIContextData )
                {
                    pEapOutput->dwAuthResultCode = ApResult.dwError;
                    pEapOutput->Action = EAPACTION_Done;
                    pEapwb->EapState = EMV2_Failure;
                }
            }
            
            break;
        case EMV2_CHAPAuthSuccess:
            TRACE("EMV2_CHAPAuthSuccess");
            //We should get an EAPSUCCESS here
            if ( NULL != pReceivePacket )
            {
                if ( pReceivePacket->Code != EAPCODE_Success )
                {
                    dwRetCode = ERROR_PPP_INVALID_PACKET;
                    pEapwb->EapState = EMV2_Failure;
                    break;
                }
                if ( ( pEapwb->dwInteractiveUIOperation & 
                    EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD_WINLOGON 
                    ) ||
                    ( ( pEapwb->dwInteractiveUIOperation &
                    EAPMSCHAPv2_INTERACTIVE_UI_FLAG_RETRY ) &&
                      ( pEapwb->pConnProp->fFlags & 
                        EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS 
                      )
                    )
                   )
                {
                    //
                    // We need to plumb creds in winlogon.
                    //
                    dwRetCode = RasSetCachedCredentials ( pEapwb->pUserProp->szUserName,
                                                          pEapwb->pUserProp->szDomain,
                                                          pEapwb->pUserProp->szPassword
                                                        );
                    if ( NO_ERROR != dwRetCode )
                    {
                        TRACE1("RasSetCachedCredentials failed with error 0x%x", dwRetCode);
                        TRACE("Change password operation could not apply changes to winlogon.");
                        dwRetCode = NO_ERROR;
                    }
                    //since we entered this mode in winlogon mode
                    //wipe out the uid pwd if set
                    //
                    ZeroMemory ( pEapwb->pUserProp->szUserName, sizeof(pEapwb->pUserProp->szUserName) );
                    ZeroMemory ( pEapwb->pUserProp->szDomain, sizeof(pEapwb->pUserProp->szDomain) );

                }
                pEapwb->EapState = EMV2_Success;
                pEapOutput->Action = EAPACTION_Done;
                pEapOutput->fSaveUserData = TRUE;

                if ( pEapwb->pUserProp->szPassword[0] )
                {
                    DATA_BLOB   DBPassword;
                    //Encode the password to send back.
                    dwRetCode = EncodePassword( strlen(pEapwb->pUserProp->szPassword) + 1,
                                                pEapwb->pUserProp->szPassword,
                                                &(DBPassword)
                                              );

                    if ( NO_ERROR == dwRetCode )
                    {
                        AllocateUserDataWithEncPwd ( pEapwb, &DBPassword );
                        FreePassword ( &DBPassword );
                    }
                    else
                    {
                        TRACE1("EncodePassword failed with errror 0x%x.", dwRetCode);
                        dwRetCode = NO_ERROR;
                    }

                }
                RtlSecureZeroMemory ( pEapwb->pUserProp->szPassword, sizeof( pEapwb->pUserProp->szPassword ) );
                LocalFree ( pEapOutput->pUserData );
                pEapOutput->pUserData = (PBYTE)pEapwb->pUserProp;                    
                pEapOutput->dwSizeOfUserData = 
					sizeof( EAPMSCHAPv2_USER_PROPERTIES) + pEapwb->pUserProp->cbEncPassword -1 ;
                pEapOutput->pUserAttributes = pEapwb->pUserAttributes;
                pEapOutput->dwAuthResultCode = pEapwb->dwAuthResultCode;
            }
            else
            {
                dwRetCode = ERROR_PPP_INVALID_PACKET;
            }
            break;
        case EMV2_Success:
            TRACE("EMV2_Success");
            break;
        case EMV2_Failure:
            TRACE("EMV2_Failure");
            break;
        case EMV2_RequestSend:
        default:
            TRACE1("Why is this EAPMschapv2 in this state? %d", pEapwb->EapState);
            break;
    }
    
done:
    if ( pSendBuf )
    {
        LocalFree(pSendBuf);
    }

    return dwRetCode;
}


//**
//
// Call:        EapMSChapv2MakeMessage
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: 
//

DWORD 
EapMSChapv2MakeMessage(
    IN  VOID*               pWorkBuf,
    IN  PPP_EAP_PACKET*     pReceivePacket,
    OUT PPP_EAP_PACKET*     pSendPacket,
    IN  DWORD               cbSendPacket,
    OUT PPP_EAP_OUTPUT*     pEapOutput,
    IN  PPP_EAP_INPUT*      pEapInput 
)
{
    DWORD           dwRetCode = NO_ERROR;    
    EAPMSCHAPv2WB * pwb = (EAPMSCHAPv2WB *)pWorkBuf;

    TRACE("EapMSChapv2MakeMessage");
    //
    // There may not be a real pressing need to split
    // this function but it is just cleaner.

    if ( pwb->pwb->fServer )
    {
        dwRetCode = EapMSChapv2SMakeMessage (   pWorkBuf,
                                    pReceivePacket,
                                    pSendPacket,
                                    cbSendPacket,
                                    pEapOutput,
                                    pEapInput 
                                );

    }
    else
    {
        dwRetCode = EapMSChapv2CMakeMessage (   pWorkBuf,
                                    pReceivePacket,
                                    pSendPacket,
                                    cbSendPacket,
                                    pEapOutput,
                                    pEapInput 
                                );
    }

    return dwRetCode;

}



//**
//
// Call:        EapChapMakeMessage
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
EapChapMakeMessage(
    IN  VOID*               pWorkBuf,
    IN  PPP_EAP_PACKET*     pReceivePacket,
    OUT PPP_EAP_PACKET*     pSendPacket,
    IN  DWORD               cbSendPacket,
    OUT PPP_EAP_OUTPUT*     pEapOutput,
    IN  PPP_EAP_INPUT*      pEapInput 
)
{
    DWORD           dwRetCode;
    PPP_CONFIG*     pReceiveBuf = NULL;
    PPP_CONFIG*     pSendBuf    = NULL;
    DWORD           cbSendBuf   = 1500;
    PPPAP_INPUT     ApInput;
    PPPAP_RESULT    ApResult;
    CHAPWB *        pwb = (CHAPWB *)pWorkBuf;

    ZeroMemory( &ApResult, sizeof(ApResult) );

    if ( ( pSendBuf = LocalAlloc( LPTR, cbSendBuf ) ) == NULL )
    {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Convert EAP to CHAP packet.
    //

    if ( pReceivePacket != NULL )
    {
        WORD cbPacket = WireToHostFormat16( pReceivePacket->Length );

        if ( ( pReceiveBuf = LocalAlloc( LPTR, cbPacket ) ) == NULL )
        {
            LocalFree( pSendBuf );

            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        switch( pReceivePacket->Code )
        {
        case EAPCODE_Request:

            //
            // CHAP challenge code
            //

            pReceiveBuf->Code = 1;

            //
            // Length is EAP length - 1 for type
            //

            cbPacket--;             

            break;

        case EAPCODE_Response:

            //
            // CHAP response code
            //

            pReceiveBuf->Code = 2;  

            //
            // Length is EAP length - 1 for type
            //

            cbPacket--;             

            break;

        case EAPCODE_Success:

            //
            // CHAP success code
            //

            pReceiveBuf->Code = 3;  
			
            break;

        case EAPCODE_Failure:

            //
            // CHAP failure code
            //

            pReceiveBuf->Code = 4;  

            break;

        default:

            //
            // Unknown code
            //

            LocalFree( pSendBuf );

            LocalFree( pReceiveBuf );

            return( ERROR_PPP_INVALID_PACKET );
        }

        //
        // Set the Id
        //

        pReceiveBuf->Id = pReceivePacket->Id;

        //
        // Set the length
        //

        HostToWireFormat16( (WORD)cbPacket, pReceiveBuf->Length );

        if ( cbPacket > PPP_EAP_PACKET_HDR_LEN )
        {
            if ( ( pReceivePacket->Code == EAPCODE_Request ) ||
                 ( pReceivePacket->Code == EAPCODE_Response ) )
            {
                //
                // Do not copy EAP type
                //

                CopyMemory( pReceiveBuf->Data, 
                            pReceivePacket->Data+1, 
                            cbPacket - PPP_EAP_PACKET_HDR_LEN );
            }
            else
            {
                //
                // As per the EAP spec, there shouldn't be any data but
                // copy it anyway if there is.
                //

                CopyMemory( pReceiveBuf->Data, 
                            pReceivePacket->Data, 
                            cbPacket - PPP_EAP_PACKET_HDR_LEN );
            }
        }
    }

    if ( pEapInput != NULL )
    { 
        MapEapInputToApInput( pEapInput, &ApInput );

        //
        // On the client side, if we received an indication that a success
        // packet was received, then simply create a success packet and
        // pass it in
        //

        if ( pEapInput->fSuccessPacketReceived )
        {
            if ( ( pReceiveBuf = LocalAlloc( LPTR, 4 ) ) == NULL )
            {
                LocalFree( pSendBuf );

                return( ERROR_NOT_ENOUGH_MEMORY );

            }

            pReceiveBuf->Code = 3;  // CHAP success code

            pReceiveBuf->Id = pwb->bIdExpected;

            HostToWireFormat16( (WORD)4, pReceiveBuf->Length );
        }
    }

    dwRetCode = ChapMakeMessage(
                            pWorkBuf,
                            pReceiveBuf,
                            pSendBuf,
                            cbSendBuf,
                            &ApResult,
                            ( pEapInput == NULL ) ? NULL : &ApInput );

    if ( dwRetCode != NO_ERROR )
    {
        LocalFree( pSendBuf );
        LocalFree( pReceiveBuf );
        return( dwRetCode );
    }

    //
    // Convert ApResult to pEapOutput
    //

    switch( ApResult.Action )
    {
    case APA_NoAction:
        pEapOutput->Action = EAPACTION_NoAction;
        break;

    case APA_Done:
        pEapOutput->Action = EAPACTION_Done;
        break;

    case APA_SendAndDone:
        pEapOutput->Action = EAPACTION_SendAndDone;
        break;

    case APA_Send:
        pEapOutput->Action = EAPACTION_Send;
        break;

    case APA_SendWithTimeout:

        pEapOutput->Action = ( pwb->fServer ) 
                                    ? EAPACTION_SendWithTimeout
                                    : EAPACTION_Send;
        break;

    case APA_SendWithTimeout2:

        pEapOutput->Action = ( pwb->fServer ) 
                                    ? EAPACTION_SendWithTimeoutInteractive
                                    : EAPACTION_Send;
        break;

    case APA_Authenticate:
        pEapOutput->pUserAttributes = ApResult.pUserAttributes;
        pEapOutput->Action          = EAPACTION_Authenticate;
        break;

    default:
        RTASSERT(FALSE);
        break;
    }

    switch( pEapOutput->Action )
    {
    case EAPACTION_SendAndDone:
    case EAPACTION_Send:
    case EAPACTION_SendWithTimeout:
    case EAPACTION_SendWithTimeoutInteractive:
    {
        //
        // Convert CHAP to EAP packet
        // Length is CHAP length + 1 for EAP type
        //

        WORD cbPacket = WireToHostFormat16( pSendBuf->Length );

        switch( pSendBuf->Code )
        {
        case 1: // CHAPCODE_Challenge
            pSendPacket->Code = EAPCODE_Request;
            cbPacket++;     // Add one octect for EAP type
            break;

        case 2: // CHAPCODE_Response
            pSendPacket->Code = EAPCODE_Response;
            cbPacket++;     // Add one octect for EAP type
            break;

        case 3: // CHAPCODE_Success
            pSendPacket->Code = EAPCODE_Success;
            break;

        case 4: // CHAPCODE_Failure
            pSendPacket->Code = EAPCODE_Failure;
            break;

        default:
            RTASSERT( FALSE );
            break;
        }

        pSendPacket->Id = pSendBuf->Id;

        //
        // Need to copy the payload and the EAP type in the data field
        //

        if ( ( pSendPacket->Code == EAPCODE_Request ) ||
             ( pSendPacket->Code == EAPCODE_Response ) )
        {
            HostToWireFormat16( (WORD)cbPacket, pSendPacket->Length );
			*pSendPacket->Data = EAPTYPE_MD5Challenge;     // EAPTYPE_MD5Challenge;

            //
            // If there is a payload, copy it
            //

            if ( ( cbPacket - 1 ) > PPP_CONFIG_HDR_LEN )
            {
                CopyMemory( pSendPacket->Data+1,    
                            pSendBuf->Data, 
                            cbPacket - 1 - PPP_CONFIG_HDR_LEN );
            }
        }
        else
        {
			//
			// Success or failure should not have any data bytes.
			//

			HostToWireFormat16( (WORD)4, pSendPacket->Length );			
        }

        //
        // Fall thru...
        //
    }

    default:

        pEapOutput->dwAuthResultCode = ApResult.dwError;

        break;
    }
    
    LocalFree( pSendBuf );

    if ( pReceiveBuf != NULL )
    {
        LocalFree( pReceiveBuf );
    }

    return( dwRetCode );
}





//**
//
// Call:        EapChapInitialize
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD   
EapChapInitialize(   
    IN  BOOL        fInitialize 
)
{

    return ChapInit( fInitialize );
}

//**
//
// Call:        RasEapGetInfo
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD 
RasEapGetInfo(
    IN  DWORD           dwEapTypeId,
    OUT PPP_EAP_INFO*   pEapInfo
)
{
    if ( dwEapTypeId != PPP_EAP_MSCHAPv2  && 
         dwEapTypeId != EAPTYPE_MD5Challenge
       )
    {
        //
        // We support 4 (MD5) eap type
        //
        //
        // and now we support MSCHAP V2 also
        //
        //

        return( ERROR_NOT_SUPPORTED );
    }

    ZeroMemory( pEapInfo, sizeof( PPP_EAP_INFO ) );

    //
    // Fill in the required information
    //

    pEapInfo->dwEapTypeId       = dwEapTypeId;
    
    if ( dwEapTypeId == EAPTYPE_MD5Challenge )         //MD5 CHAP
    {
        pEapInfo->RasEapInitialize  = EapChapInitialize;
        pEapInfo->RasEapBegin       = EapChapBegin;
        pEapInfo->RasEapEnd         = EapChapEnd;
        pEapInfo->RasEapMakeMessage = EapChapMakeMessage;
    }
    else
    {
        pEapInfo->RasEapInitialize  = EapMSCHAPv2Initialize;
        pEapInfo->RasEapBegin       = EapMSChapv2Begin;
        pEapInfo->RasEapEnd         = EapMSChapv2End;
        pEapInfo->RasEapMakeMessage = EapMSChapv2MakeMessage;

    }

    return( NO_ERROR );
}

DWORD
RasEapGetCredentials(
                    DWORD   dwTypeId,
                    VOID *  pWorkBuf,
                    VOID ** ppCredentials)
{
    RASMAN_CREDENTIALS *pCreds = NULL;
    DWORD dwRetCode = NO_ERROR;
    EAPMSCHAPv2WB *pWB = (EAPMSCHAPv2WB *)pWorkBuf;

    if(PPP_EAP_MSCHAPv2 != dwTypeId)
    {
        dwRetCode = E_NOTIMPL;
        goto done;
    }

    if(NULL == pWorkBuf)
    {
        dwRetCode = E_INVALIDARG;
        goto done;
    }

    //
    // Retrieve the password and return. Its important that
    // the allocation below is made from process heap.
    //
    pCreds = LocalAlloc(LPTR, sizeof(RASMAN_CREDENTIALS));
    if(NULL == pCreds)
    {
        dwRetCode = GetLastError();
        goto done;
    }

    (VOID) StringCchCopyA(pCreds->szUserName, UNLEN, pWB->pwb->szUserName);
    (VOID) StringCchCopyA(pCreds->szDomain, DNLEN, pWB->pwb->szDomain);
    DecodePw( pWB->pwb->chSeed, pWB->pwb->szPassword );

    //
    // Convert the password to unicode
    //
    if(!MultiByteToWideChar(CP_ACP,
                            0,
                            pWB->pwb->szPassword,
                            -1,
                            pCreds->wszPassword,
                            PWLEN))
    {
        TRACE("RasEapGetCredentials: multibytetowidechar failed");
    }

    EncodePw(pWB->pwb->chSeed, pWB->pwb->szPassword);

done:
    *ppCredentials = (VOID *) pCreds;
    return dwRetCode;
}


DWORD
ReadConnectionData(
    IN  BOOL                            fWireless,
    IN  BYTE*                           pConnectionDataIn,
    IN  DWORD                           dwSizeOfConnectionDataIn,
    OUT PEAPMSCHAPv2_CONN_PROPERTIES*   ppConnProp
)
{
    DWORD                           dwErr       = NO_ERROR;
    PEAPMSCHAPv2_CONN_PROPERTIES    pConnProp   = NULL;
    
    TRACE("ReadConnectionData");
    RTASSERT(NULL != ppConnProp);
    
    if ( dwSizeOfConnectionDataIn < sizeof(EAPMSCHAPv2_CONN_PROPERTIES) )
    {        
        pConnProp = LocalAlloc(LPTR, sizeof(EAPMSCHAPv2_CONN_PROPERTIES));

        if (NULL == pConnProp)
        {
            dwErr = GetLastError();
            TRACE1("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }
        //This is a new structure
        pConnProp->dwVersion = 1;
        if ( fWireless )
        {
            //Set the use winlogon default flag
            pConnProp->fFlags = EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS;
        }

    }
    else
    {
        RTASSERT(NULL != pConnectionDataIn);

        //
        //Check to see if this is a version 0 structure
        //If it is a version 0 structure then we migrate it to version1
        //
        
        pConnProp = LocalAlloc(LPTR, dwSizeOfConnectionDataIn);

        if (NULL == pConnProp)
        {
            dwErr = GetLastError();
            TRACE1("LocalAlloc failed and returned %d", dwErr);
            goto LDone;
        }

        // If the user has mucked with the phonebook, we mustn't be affected.
        // The size must be correct.
        
        CopyMemory(pConnProp, pConnectionDataIn, dwSizeOfConnectionDataIn);

    }

    *ppConnProp = pConnProp;
    pConnProp = NULL;

LDone:
    
    LocalFree(pConnProp);

    return(dwErr);
}


DWORD
AllocateUserDataWithEncPwd ( EAPMSCHAPv2WB * pEapwb, DATA_BLOB * pDBPassword )
{
	DWORD							dwRetCode = NO_ERROR;
	PEAPMSCHAPv2_USER_PROPERTIES	pUserProp = NULL;

	TRACE("AllocateUserDataWithEncPwd");

	pUserProp = LocalAlloc ( LPTR, sizeof( EAPMSCHAPv2_USER_PROPERTIES) + pDBPassword->cbData  - 1 );
	if ( NULL == pUserProp )
	{
		TRACE("LocalAlloc failed");
		dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
		goto LDone;
	}
	//
	// Set the fields here
	//
	pUserProp->dwVersion = pEapwb->pUserProp->dwVersion;
    pUserProp->fFlags = pEapwb->pUserProp->fFlags;
    pUserProp->dwMaxRetries = pEapwb->pUserProp->dwMaxRetries;
    strncpy ( pUserProp->szUserName, pEapwb->pUserProp->szUserName, UNLEN );
    strncpy ( pUserProp->szPassword, pEapwb->pUserProp->szPassword, PWLEN );
    strncpy ( pUserProp->szDomain, pEapwb->pUserProp->szDomain, DNLEN );
	pUserProp->cbEncPassword = pDBPassword->cbData;
	CopyMemory (pUserProp->bEncPassword, 
				pDBPassword->pbData, 
				pDBPassword->cbData 
			   );
	LocalFree ( pEapwb->pUserProp );
	pEapwb->pUserProp = pUserProp;
	
LDone:
	return dwRetCode;
}

DWORD
ReadUserData(
    IN  BYTE*                           pUserDataIn,
    IN  DWORD                           dwSizeOfUserDataIn,
    OUT PEAPMSCHAPv2_USER_PROPERTIES*   ppUserProp
)
{
    DWORD                           dwRetCode = NO_ERROR;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp = NULL;
	DATA_BLOB						DBPassword;
	DWORD							cbPassword = 0;
	PBYTE							pbPassword = NULL;

    TRACE("ReadUserData");

    RTASSERT(NULL != ppUserProp);
    if (dwSizeOfUserDataIn < sizeof(EAPMSCHAPv2_USER_PROPERTIES_v1))
    {
        pUserProp = LocalAlloc(LPTR, sizeof(EAPMSCHAPv2_USER_PROPERTIES));

        if (NULL == pUserProp)
        {
            dwRetCode = GetLastError();
            TRACE1("LocalAlloc failed and returned %d", dwRetCode);
            goto LDone;
        }

        pUserProp->dwVersion = 1;
    }
    else
    {
		DWORD dwSizeToAllocate = dwSizeOfUserDataIn;

        RTASSERT(NULL != pUserDataIn);

		if ( dwSizeOfUserDataIn == sizeof( EAPMSCHAPv2_USER_PROPERTIES_v1 ) )
		{
			//This is the old struct so allocation new number of bytes.
			dwSizeToAllocate = sizeof( EAPMSCHAPv2_USER_PROPERTIES );
		}
        pUserProp = LocalAlloc(LPTR, dwSizeToAllocate);

        if (NULL == pUserProp)
        {
            dwRetCode = GetLastError();
            TRACE1("LocalAlloc failed and returned %d", dwRetCode);
            goto LDone;
        }

        CopyMemory(pUserProp, pUserDataIn, dwSizeOfUserDataIn);
		pUserProp->dwVersion = 2;
		if ( pUserProp->cbEncPassword )
		{
			
			// We have the encrypted password.
			DBPassword.cbData = pUserProp->cbEncPassword;
			DBPassword.pbData = pUserProp->bEncPassword;

			DecodePassword(	&(DBPassword),
							&cbPassword,
							&pbPassword
							);
			if ( cbPassword )
			{
				CopyMemory ( pUserProp->szPassword,
							 pbPassword,
							 cbPassword
						    );
			}
		}

    }

    *ppUserProp = pUserProp;
    pUserProp = NULL;

LDone:

    LocalFree(pUserProp);

    return dwRetCode;
}

DWORD
OpenEapEAPMschapv2RegistryKey(
    IN  LPSTR  pszMachineName,
    IN  REGSAM samDesired,
    OUT HKEY*  phKeyEapMschapv2
)
{
    HKEY    hKeyLocalMachine = NULL;
    BOOL    fHKeyLocalMachineOpened     = FALSE;
    BOOL    fHKeyEapMschapv2Opened           = FALSE;

    LONG    lRet;
    DWORD   dwErr                       = NO_ERROR;

    RTASSERT(NULL != phKeyEapMschapv2);

    lRet = RegConnectRegistry(pszMachineName, HKEY_LOCAL_MACHINE,
                &hKeyLocalMachine);
    if (ERROR_SUCCESS != lRet)
    {
        dwErr = lRet;
        TRACE2("RegConnectRegistry(%s) failed and returned %d",
            pszMachineName ? pszMachineName : "NULL", dwErr);
        goto LDone;
    }
    fHKeyLocalMachineOpened = TRUE;

    lRet = RegOpenKeyEx(hKeyLocalMachine, EAPMSCHAPv2_KEY, 0, samDesired,
                phKeyEapMschapv2);
    if (ERROR_SUCCESS != lRet)
    {
        dwErr = lRet;
        TRACE2("RegOpenKeyEx(%s) failed and returned %d",
            EAPMSCHAPv2_KEY, dwErr);
        goto LDone;
    }
    fHKeyEapMschapv2Opened = TRUE;

LDone:

    if (   fHKeyEapMschapv2Opened
        && (ERROR_SUCCESS != dwErr))
    {
        RegCloseKey(*phKeyEapMschapv2);
    }

    if (fHKeyLocalMachineOpened)
    {
        RegCloseKey(hKeyLocalMachine);

    }

    return(dwErr);
}

DWORD
ServerConfigDataIO(
    IN      BOOL    fRead,
    IN      CHAR*   pszMachineName,
    IN OUT  BYTE**  ppData,
    IN      DWORD   dwNumBytes
)
{
    HKEY                            hKeyEapMschapv2;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp;
    BOOL                            fHKeyEapMsChapv2Opened   = FALSE;
    BYTE*                           pData               = NULL;
    DWORD                           dwSize = 0;

    LONG                            lRet;
    DWORD                           dwType;
    DWORD                           dwErr               = NO_ERROR;

    RTASSERT(NULL != ppData);

    dwErr = OpenEapEAPMschapv2RegistryKey(pszMachineName,
                fRead ? KEY_READ : KEY_WRITE, &hKeyEapMschapv2);
    if (ERROR_SUCCESS != dwErr)
    {
        goto LDone;
    }
    fHKeyEapMsChapv2Opened = TRUE;

    if (fRead)
    {
        lRet = RegQueryValueEx(hKeyEapMschapv2, EAPMSCHAPv2_VAL_SERVER_CONFIG_DATA, NULL,
                &dwType, NULL, &dwSize);

        if (   (ERROR_SUCCESS != lRet)
            || (REG_BINARY != dwType)
            || (sizeof(EAPMSCHAPv2_USER_PROPERTIES) != dwSize))
        {
            pData = LocalAlloc(LPTR, sizeof(EAPMSCHAPv2_USER_PROPERTIES));

            if (NULL == pData)
            {
                dwErr = GetLastError();
                TRACE1("LocalAlloc failed and returned %d", dwErr);
                goto LDone;
            }

            pUserProp = (EAPMSCHAPv2_USER_PROPERTIES*)pData;
            pUserProp->dwVersion = 1;
        }
        else
        {
            pData = LocalAlloc(LPTR, dwSize);

            if (NULL == pData)
            {
                dwErr = GetLastError();
                TRACE1("LocalAlloc failed and returned %d", dwErr);
                goto LDone;
            }

            lRet = RegQueryValueEx(hKeyEapMschapv2, EAPMSCHAPv2_VAL_SERVER_CONFIG_DATA,
                    NULL, &dwType, pData, &dwSize);

            if (ERROR_SUCCESS != lRet)
            {
                dwErr = lRet;
                TRACE2("RegQueryValueEx(%s) failed and returned %d",
                    EAPMSCHAPv2_VAL_SERVER_CONFIG_DATA, dwErr);
                goto LDone; 
            }
            
        }

        pUserProp = (EAPMSCHAPv2_USER_PROPERTIES*)pData;                

        *ppData = pData;
        pData = NULL;
    }
    else
    {
        lRet = RegSetValueEx(hKeyEapMschapv2, EAPMSCHAPv2_VAL_SERVER_CONFIG_DATA, 0,
                REG_BINARY, *ppData, dwNumBytes);

        if (ERROR_SUCCESS != lRet)
        {
            dwErr = lRet;
            TRACE2("RegSetValueEx(%s) failed and returned %d",
                EAPMSCHAPv2_VAL_SERVER_CONFIG_DATA, dwErr);
            goto LDone; 
        }
    }

LDone:

    if (fHKeyEapMsChapv2Opened)
    {
        RegCloseKey(hKeyEapMschapv2);
    }

    LocalFree(pData);

    return(dwErr);
}


DWORD
InvokeServerConfigUI ( 
HWND hWnd, 
LPSTR pszMachineName
)
{

    return ERROR_CALL_NOT_IMPLEMENTED;

#if 0
    DWORD                               dwRetCode = NO_ERROR;
    INT_PTR                             nRet = 0;
    EAPMSCHAPv2_SERVERCONFIG_DIALOG     EapServerConfig;
    
    BOOL                                fLocal = FALSE;


    if (0 == *pszMachineName)
    {
        fLocal = TRUE;
    }

    //Read the information from registry here
    dwRetCode = ServerConfigDataIO(TRUE /* fRead */, fLocal ? NULL : pszMachineName,
                (BYTE**)&(EapServerConfig.pUserProp), 0);

    if (NO_ERROR != dwRetCode)
    {
        goto LDone;
    }

    //Show the server config UI here
    nRet = DialogBoxParam(
                GetResouceDLLHInstance(),
                MAKEINTRESOURCE(IDD_DIALOG_SERVER_CONFIG),
                hWnd,
                ServerConfigDialogProc,
                (LPARAM)&EapServerConfig);

    if (-1 == nRet)
    {
        dwRetCode = GetLastError();
        goto LDone;
    }
    else if (IDOK != nRet)
    {
        dwRetCode = ERROR_CANCELLED;
        goto LDone;
    }    

    //Read the information from registry here
    dwRetCode = ServerConfigDataIO(FALSE/* fRead */, fLocal ? NULL : pszMachineName,
                (BYTE**)&(EapServerConfig.pUserProp), sizeof(EAPMSCHAPv2_USER_PROPERTIES));

LDone:

    return dwRetCode;
#endif
}


BOOL FFormatMachineIdentity1 ( LPWSTR lpszMachineNameRaw, LPWSTR * lppszMachineNameFormatted )
{
    BOOL        fRetVal = FALSE;
    LPWSTR      lpwszPrefix = L"host/";

    RTASSERT(NULL != lpszMachineNameRaw );
    RTASSERT(NULL != lppszMachineNameFormatted );
    
    //
    // Prepend host/ to the UPN name
    //

    *lppszMachineNameFormatted = 
        (LPWSTR)LocalAlloc ( LPTR, ( wcslen ( lpszMachineNameRaw ) + wcslen ( lpwszPrefix ) + 2 )  * sizeof(WCHAR) );
    if ( NULL == *lppszMachineNameFormatted )
    {
        goto done;
    }
    
    wcscpy( *lppszMachineNameFormatted, lpwszPrefix );
    wcscat ( *lppszMachineNameFormatted, lpszMachineNameRaw ); 
        
    fRetVal = TRUE;
    
done:
    return fRetVal;
}


BOOL FFormatMachineIdentity ( LPWSTR lpszMachineNameRaw, LPWSTR * lppszMachineNameFormatted )
{
    BOOL        fRetVal = TRUE;
    LPWSTR      s1 = lpszMachineNameRaw;
    LPWSTR      s2 = NULL;

    RTASSERT(NULL != lpszMachineNameRaw );
    RTASSERT(NULL != lppszMachineNameFormatted );
    //Need to add 2 more chars.  One for NULL and other for $ sign
    *lppszMachineNameFormatted = (LPWSTR )LocalAlloc ( LPTR, (wcslen(lpszMachineNameRaw) + 2)* sizeof(WCHAR) );
    if ( NULL == *lppszMachineNameFormatted )
    {
		return FALSE;
    }
    //find the first "." and that is the identity of the machine.
    //the second "." is the domain.
    //check to see if there at least 2 dots.  If not the raw string is 
    //the output string
    
    while ( *s1 )
    {
        if ( *s1 == '.' )
        {
            if ( !s2 )      //First dot
                s2 = s1;
            else            //second dot
                break;
        }
        s1++;
    }
    //can perform several additional checks here
    
    if ( *s1 != '.' )       //there are no 2 dots so raw = formatted
    {
        wcscpy ( *lppszMachineNameFormatted, lpszMachineNameRaw );
        goto done;
    }
    if ( s1-s2 < 2 )
    {
        wcscpy ( *lppszMachineNameFormatted, lpszMachineNameRaw );
        goto done;
    }
    memcpy ( *lppszMachineNameFormatted, s2+1, ( s1-s2-1) * sizeof(WCHAR));
    memcpy ( (*lppszMachineNameFormatted) + (s1-s2-1) , L"\\", sizeof(WCHAR));
    wcsncpy ( (*lppszMachineNameFormatted) + (s1-s2), lpszMachineNameRaw, s2-lpszMachineNameRaw );
    


    
done:
	
	//Append the $ sign no matter what...
    wcscat ( *lppszMachineNameFormatted, L"$" );
    //upper case the identity
    _wcsupr ( *lppszMachineNameFormatted );
    return fRetVal;
}

DWORD
GetLocalMachineName ( 
    OUT WCHAR ** ppLocalMachineName
)
{
    DWORD       dwRetCode = NO_ERROR;
    WCHAR   *   pLocalMachineName = NULL;
    DWORD       dwLocalMachineNameLen = 0;

    if ( !GetComputerNameExW ( ComputerNameDnsFullyQualified,
                              pLocalMachineName,
                              &dwLocalMachineNameLen
                            )
       )
    {
        dwRetCode = GetLastError();
        if ( ERROR_MORE_DATA != dwRetCode )
            goto LDone;
        dwRetCode = NO_ERROR;
    }

    pLocalMachineName = (WCHAR *)LocalAlloc( LPTR, (dwLocalMachineNameLen * sizeof(WCHAR)) + sizeof(WCHAR) );
    if ( NULL == pLocalMachineName )
    {
        dwRetCode = GetLastError();
        goto LDone;
    }

    if ( !GetComputerNameExW ( ComputerNameDnsFullyQualified,
                              pLocalMachineName,
                              &dwLocalMachineNameLen
                            )
       )
    {
        dwRetCode = GetLastError();
        goto LDone;
    }

    *ppLocalMachineName = pLocalMachineName;

    pLocalMachineName = NULL;

LDone:

    LocalFree(pLocalMachineName);

    return dwRetCode;
}


DWORD
RasEapGetIdentity(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT WCHAR**         ppwszIdentityOut
)
{
    DWORD                           dwRetCode = NO_ERROR;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp = NULL;
    PEAPMSCHAPv2_CONN_PROPERTIES    pConnProp = NULL;
    EAPMSCHAPv2_LOGON_DIALOG        EapMsChapv2LogonDialog;    
    INT_PTR                         nRet = 0;
    LPWSTR                          lpwszLocalMachineName = NULL;
    RASCREDENTIALSW                 RasCredentials;
    CHAR                            szOldPwd[PWLEN+1]= {0};
    BOOL                            fShowUI = TRUE;



    TRACE("RasEapGetIdentity");

    RTASSERT(NULL != ppUserDataOut);
    RTASSERT(NULL != pdwSizeOfUserDataOut);
    
    
    
    *ppUserDataOut = NULL;

    ZeroMemory( &EapMsChapv2LogonDialog, 
                sizeof(EapMsChapv2LogonDialog) );

    //
    // Read User data first
    //

    dwRetCode = ReadUserData (  pUserDataIn,
                                dwSizeOfUserDataIn,
                                &pUserProp
                            );
    if ( NO_ERROR != dwRetCode )
    {
        goto LDone;
    }

    //
    // ReadConnectionData and see if we have been setup to use winlogon 
    // credentials.  If so, just call to get user id and send back 
    // information.
    //
    
    
    dwRetCode = ReadConnectionData ( ( dwFlags & RAS_EAP_FLAG_8021X_AUTH ),
                                     pConnectionDataIn,
                                     dwSizeOfConnectionDataIn,
                                     &pConnProp
                                   );

    if ( NO_ERROR != dwRetCode )
    {
        TRACE("Error reading connection properties");
        goto LDone;
    }
    
    //MAchine Auth
    if ( (dwFlags & RAS_EAP_FLAG_MACHINE_AUTH) )
    {

        //Send the identity back as domain\machine$
        dwRetCode = GetLocalMachineName(&lpwszLocalMachineName );
        if ( NO_ERROR != dwRetCode )
        {
            TRACE("Failed to get computer name");
            goto LDone;
        }

        if ( ! FFormatMachineIdentity1 ( lpwszLocalMachineName, 
                                        ppwszIdentityOut )
           )
        {
            TRACE("Failed to format machine identity");
        }
        
        *ppUserDataOut = (PBYTE)pUserProp;
        *pdwSizeOfUserDataOut = sizeof(EAPMSCHAPv2_USER_PROPERTIES);

        pUserProp = NULL;
        goto LDone;
    }

    if ( !(pConnProp->fFlags & EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS) &&
         dwFlags & RAS_EAP_FLAG_NON_INTERACTIVE
        )
	{
        if ( (dwFlags & RAS_EAP_FLAG_8021X_AUTH ) )
		{
			// Wireless case - If there is no username or password cached
			// we need to show the interactive UI
			if( !pUserProp->szUserName[0] ||				
				!pUserProp->cbEncPassword
			 )
			{
				TRACE("Passed non interactive mode when interactive mode expected.");
				dwRetCode = ERROR_INTERACTIVE_MODE;
				goto LDone;
			}
		}
		else
		{
			//VPN case
			dwRetCode = ERROR_INTERACTIVE_MODE;
			goto LDone;
		}
    }

    

    //User Auth
    if (  pConnProp->fFlags & EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS )
    {
        WCHAR wszUserName[UNLEN + DNLEN + 2];
        DWORD dwNumChars = UNLEN + DNLEN;

        if ( dwFlags & RAS_EAP_FLAG_LOGON)
        {
            //
            // This is not allowed.
            //
            dwRetCode = ERROR_INVALID_MSCHAPV2_CONFIG;
            goto LDone;

        }

        //Get currently logged on user name for identity
        if (!GetUserNameExW(NameSamCompatible, wszUserName, &dwNumChars))
        {
            dwRetCode =  GetLastError();
            TRACE1("GetUserNameExW failed and returned %d", dwRetCode );
            goto LDone;
        }

        *ppwszIdentityOut = (WCHAR *)LocalAlloc(LPTR, 
                           dwNumChars * sizeof(WCHAR) + sizeof(WCHAR) );

        if ( NULL == *ppwszIdentityOut )
        {
            TRACE("Failed to allocate memory for identity");
            dwRetCode = ERROR_OUTOFMEMORY;
            goto LDone;
        }
        CopyMemory(*ppwszIdentityOut, wszUserName, dwNumChars * sizeof(WCHAR) );
        //All other fields in user prop remains blank
        

    }
    else
    {

        EapMsChapv2LogonDialog.pUserProp = pUserProp;

        //
        // Show the logon dialog for credentials
        //
        // if Machine Auth flag is passed in, we dont show
        // the logon dialog.  If Get Credentials from winlogon
        // is passed in dont show logon dialog.  else show
        // logon dialog.

        //
        // Check to see if we have the password saved in LSA
        // It should not matter if it is not.
        if ( !(dwFlags & RAS_EAP_FLAG_LOGON ) )
        {
#if 0
            ZeroMemory(&RasCredentials, sizeof(RasCredentials));
            RasCredentials.dwSize = sizeof(RasCredentials);
            RasCredentials.dwMask = RASCM_Password;

            dwRetCode  = RasGetCredentialsW(pwszPhonebook, pwszEntry,
                        &RasCredentials);

            if (   (dwRetCode == NO_ERROR)
                && (RasCredentials.dwMask & RASCM_Password))
            {
                //Set the password
                WideCharToMultiByte(
                                CP_ACP,
                                0,
                                RasCredentials.szPassword,
                                -1,
                                pUserProp->szPassword,
                                PWLEN + 1,
                                NULL,
                                NULL );
            strncpy (szOldPwd, pUserProp->szPassword, PWLEN );

            }
            dwRetCode = NO_ERROR;
#endif
        }
        else
        {
            EapMsChapv2LogonDialog.pUserProp->fFlags |= EAPMSCHAPv2_FLAG_CALLED_WITHIN_WINLOGON;
            if ( pUserProp->fFlags & EAPMSCHAPv2_FLAG_SAVE_UID_PWD )
                pUserProp->fFlags &= ~EAPMSCHAPv2_FLAG_SAVE_UID_PWD;
        }
        if ( dwFlags &  RAS_EAP_FLAG_8021X_AUTH )
        {
            EapMsChapv2LogonDialog.pUserProp->fFlags |= EAPMSCHAPv2_FLAG_8021x;
        }

        //We have a username and password.  So no need to show 
        //the UI in case of 8021x

        if ( (dwFlags & RAS_EAP_FLAG_8021X_AUTH ) &&
             pUserProp->szUserName[0] &&             
             pUserProp->cbEncPassword
           )
        {
            fShowUI = FALSE;
        }

        if ( fShowUI )
        {
            nRet = DialogBoxParam(
                      GetResouceDLLHInstance(),
                      MAKEINTRESOURCE(IDD_DIALOG_LOGON),
                      hwndParent,
                      LogonDialogProc,
                      (LPARAM)&EapMsChapv2LogonDialog);

           if (-1 == nRet)
           {
               dwRetCode = GetLastError();
               goto LDone;
           }
           else if (IDOK != nRet)
           {
               dwRetCode = ERROR_CANCELLED;
               goto LDone;
           }    
        }

        if ( !(dwFlags & RAS_EAP_FLAG_ROUTER ) )
        {
            
            //
            // Setup the identity parameter here
            //
            dwRetCode = GetIdentityFromUserName (   pUserProp->szUserName,
                                                    pUserProp->szDomain,
                                                    ppwszIdentityOut
                                                );
            if ( NO_ERROR != dwRetCode )
            {
                goto LDone;
            }
        }
    
    }
#if 0
    if ( !(dwFlags & RAS_EAP_FLAG_LOGON ) )
    {
        ZeroMemory(&RasCredentials, sizeof(RasCredentials));
        RasCredentials.dwSize = sizeof(RasCredentials);
        RasCredentials.dwMask = RASCM_Password;
        
        if ( pUserProp->fFlags & EAPMSCHAPv2_FLAG_SAVE_UID_PWD )
        {
            //
            // Check to see if the new password is different from the old one
            //
            if ( strcmp ( szOldPwd, pUserProp->szPassword ) )
            {
                //
                //  There is a new password for us to save.  
                //

                MultiByteToWideChar( CP_ACP,
                                0,
                                pUserProp->szPassword,
                                -1,
                                RasCredentials.szPassword,
                                sizeof(RasCredentials.szPassword)/sizeof(WCHAR) );

                RasSetCredentialsW(pwszPhonebook, pwszEntry, &RasCredentials, 
                    FALSE /* fClearCredentials */);
            }
        }
        else
        {
            RasSetCredentialsW(pwszPhonebook, pwszEntry, &RasCredentials, 
                TRUE /* fClearCredentials */);
        }
    }
#endif

    *ppUserDataOut = (PBYTE)pUserProp;
    *pdwSizeOfUserDataOut = sizeof(EAPMSCHAPv2_USER_PROPERTIES);

    pUserProp = NULL;

LDone:
    if ( lpwszLocalMachineName )
        LocalFree(lpwszLocalMachineName);

    LocalFree(pUserProp);
    return dwRetCode;
}

DWORD 
RasEapInvokeConfigUI(
    IN  DWORD       dwEapTypeId,
    IN  HWND        hwndParent,
    IN  DWORD       dwFlags,
    IN  BYTE*       pConnectionDataIn,
    IN  DWORD       dwSizeOfConnectionDataIn,
    OUT BYTE**      ppConnectionDataOut,
    OUT DWORD*      pdwSizeOfConnectionDataOut
)
{
    DWORD                               dwRetCode = NO_ERROR;
    EAPMSCHAPv2_CLIENTCONFIG_DIALOG     ClientConfigDialog;
    INT_PTR                             nRet;
    
    TRACE("RasEapInvokeConfigUI");

    *ppConnectionDataOut = NULL;
    *pdwSizeOfConnectionDataOut = 0;
    //
    // In case of Router there is nothing to configure
    //
    if ( dwFlags & RAS_EAP_FLAG_ROUTER )
    {
        CHAR    szMessage[512] = {0};
        CHAR    szHeader[64] = {0};
        //
        // Load resource from res file
        //

        LoadString( GetResouceDLLHInstance(),
                    IDS_NO_ROUTER_CONFIG,
                    szMessage,
                    sizeof(szMessage)-1
                  );
        LoadString( GetResouceDLLHInstance(),
                    IDS_MESSAGE_HEADER,
                    szHeader,
                    sizeof(szHeader)-1
                  );

        MessageBox (hwndParent, 
                      szMessage,
                      szHeader,
                      MB_OK
                     );
        goto LDone;
    }
    //
    // If we are a client, read connection data and call 
    // the dialog to do the config.
    //
    dwRetCode = ReadConnectionData ( ( dwFlags & RAS_EAP_FLAG_8021X_AUTH ),
                                     pConnectionDataIn,
                                     dwSizeOfConnectionDataIn,
                                     &(ClientConfigDialog.pConnProp)
                                   );
    if ( NO_ERROR != dwRetCode )
    {
        TRACE("Error reading conn prop");
        goto LDone;
    }

    //
    // Call in the dialog to show connection props
    //
    
    nRet = DialogBoxParam(
                GetResouceDLLHInstance(),
                MAKEINTRESOURCE(IDD_DIALOG_CLIENT_CONFIG),
                hwndParent,
                ClientConfigDialogProc,
                (LPARAM)&ClientConfigDialog);

    if (-1 == nRet)
    {
        dwRetCode = GetLastError();
        goto LDone;
    }
    else if (IDOK != nRet)
    {
        dwRetCode = ERROR_CANCELLED;
        goto LDone;
    }    
    //
    // Setup the out parameters in the ppDataFromInteractiveUI
    // so that we can send the new uid/pwd back
    //

    * ppConnectionDataOut = LocalAlloc( LPTR, sizeof(EAPMSCHAPv2_CONN_PROPERTIES) );
    if ( NULL == * ppConnectionDataOut )
    {
        TRACE("Error allocating memory for pConnectionDataOut");
        dwRetCode = ERROR_OUTOFMEMORY;
        goto LDone;
    }
    CopyMemory( *ppConnectionDataOut, 
                ClientConfigDialog.pConnProp, 
                sizeof(EAPMSCHAPv2_CONN_PROPERTIES)
              );
    * pdwSizeOfConnectionDataOut = sizeof(EAPMSCHAPv2_CONN_PROPERTIES);

LDone:
    LocalFree(ClientConfigDialog.pConnProp);
    return dwRetCode;
}



DWORD 
RasEapFreeMemory(
    IN  BYTE*   pMemory
)
{
    LocalFree(pMemory);
    return(NO_ERROR);
}

DWORD
RasEapInvokeInteractiveUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hWndParent,
    IN  BYTE*           pUIContextData,
    IN  DWORD           dwSizeofUIContextData,
    OUT BYTE**          ppDataFromInteractiveUI,
    OUT DWORD*          pdwSizeOfDataFromInteractiveUI
)
{
    DWORD dwRetCode = NO_ERROR;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp = NULL;
    PEAPMSCHAPv2_INTERACTIVE_UI     pEapMschapv2InteractiveUI = NULL;
    EAPMSCHAPv2_CHANGEPWD_DIALOG    EapMsChapv2ChangePwdDialog;
    EAPMSCHAPv2_LOGON_DIALOG        EapMsChapv2LogonDialog;    
    INT_PTR                         nRet = 0;
    
    TRACE("RasEapInvokeInteractiveUI");
    RTASSERT(NULL != pUIContextData);
    RTASSERT(dwSizeofUIContextData == sizeof(EAPMSCHAPv2_INTERACTIVE_UI));
    
    * ppDataFromInteractiveUI = NULL;
    * pdwSizeOfDataFromInteractiveUI = 0;

    pEapMschapv2InteractiveUI = (PEAPMSCHAPv2_INTERACTIVE_UI)pUIContextData;

    if ( pEapMschapv2InteractiveUI->fFlags & EAPMSCHAPv2_INTERACTIVE_UI_FLAG_RETRY )
    {
        ZeroMemory( &EapMsChapv2LogonDialog, 
                    sizeof(EapMsChapv2LogonDialog) );

        EapMsChapv2LogonDialog.pUserProp = 
            &(pEapMschapv2InteractiveUI->UserProp);

        //
        // Show the retry dialog for credentials
        //

        nRet = DialogBoxParam(
                    GetResouceDLLHInstance(),
                    MAKEINTRESOURCE(IDD_DIALOG_RETRY_LOGON),
                    hWndParent,
                    RetryDialogProc,
                    (LPARAM)&EapMsChapv2LogonDialog);

        if (-1 == nRet)
        {
            dwRetCode = GetLastError();
            goto LDone;
        }
        else if (IDOK != nRet)
        {
            dwRetCode = ERROR_CANCELLED;
            goto LDone;
        }    
        //
        // Setup the out parameters in the ppDataFromInteractiveUI
        // so that we can send the new uid/pwd back
        //

        * ppDataFromInteractiveUI = LocalAlloc( LPTR, sizeof(EAPMSCHAPv2_INTERACTIVE_UI) );
        if ( NULL == * ppDataFromInteractiveUI )
        {
            TRACE("Error allocating memory for pDataFromInteractiveUI");
            dwRetCode = ERROR_OUTOFMEMORY;
            goto LDone;
        }
        CopyMemory ( *ppDataFromInteractiveUI,
                     pEapMschapv2InteractiveUI,
                     sizeof( EAPMSCHAPv2_INTERACTIVE_UI )
                   );

        pEapMschapv2InteractiveUI = (PEAPMSCHAPv2_INTERACTIVE_UI)*ppDataFromInteractiveUI;

        CopyMemory( &(pEapMschapv2InteractiveUI->UserProp), 
                    EapMsChapv2LogonDialog.pUserProp, 
                    sizeof(EAPMSCHAPv2_USER_PROPERTIES)
                  );
        * pdwSizeOfDataFromInteractiveUI = sizeof(EAPMSCHAPv2_INTERACTIVE_UI);

    }
    else if ( ( pEapMschapv2InteractiveUI->fFlags & EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD )||
               ( pEapMschapv2InteractiveUI->fFlags & EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD_WINLOGON )
            )
    {
        //
        // Change password
        //
        ZeroMemory( &EapMsChapv2ChangePwdDialog,
                    sizeof(EapMsChapv2ChangePwdDialog)
                  );

        EapMsChapv2ChangePwdDialog.pInteractiveUIData = (PEAPMSCHAPv2_INTERACTIVE_UI)pUIContextData;
        //
        // Show the retry dialog for credentials
        //
        if ( pEapMschapv2InteractiveUI->fFlags & EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD )
        {
            nRet = DialogBoxParam(
                        GetResouceDLLHInstance(),
                        MAKEINTRESOURCE(IDD_DIALOG_CHANGE_PASSWORD),
                        hWndParent,
                        ChangePasswordDialogProc,
                        (LPARAM)&EapMsChapv2ChangePwdDialog);
        }
        else
        {
            //
            // We need to get this dialog from rasdlg because
            // in XPSP1 no more resources can be added.
            //
            nRet = DialogBoxParam(
                        GetRasDlgDLLHInstance(),
                        MAKEINTRESOURCE(DID_CP_ChangePassword2),
                        hWndParent,
                        ChangePasswordDialogProc,
                        (LPARAM)&EapMsChapv2ChangePwdDialog);

        }
        if (-1 == nRet)
        {
            dwRetCode = GetLastError();
            goto LDone;
        }
        else if (IDOK != nRet)
        {
            dwRetCode = ERROR_CANCELLED;
            goto LDone;
        }    
        //
        // Setup the out parameters in the ppDataFromInteractiveUI
        // so that we can send the new uid/pwd back
        //

        * ppDataFromInteractiveUI = LocalAlloc( LPTR, sizeof(EAPMSCHAPv2_INTERACTIVE_UI) );
        if ( NULL == * ppDataFromInteractiveUI )
        {
            TRACE("Error allocating memory for pDataFromInteractiveUI");
            dwRetCode = ERROR_OUTOFMEMORY;
            goto LDone;
        }
        CopyMemory( *ppDataFromInteractiveUI, 
                    EapMsChapv2ChangePwdDialog.pInteractiveUIData, 
                    sizeof(EAPMSCHAPv2_INTERACTIVE_UI)
                  );
        * pdwSizeOfDataFromInteractiveUI = sizeof(EAPMSCHAPv2_INTERACTIVE_UI);
    }
LDone:
    return dwRetCode;
}


DWORD
EapMSCHAPv2Initialize(
    IN  BOOL    fInitialize
)
{
    static  DWORD   dwRefCount = 0;
    DWORD           dwRetCode = NO_ERROR;

    if ( fInitialize )
    {
        //Initialize
        if (0 == dwRefCount)
        {
            dwRetCode = IASLogonInitialize();
        }
        dwRefCount ++;
    }
    else
    {
        dwRefCount --;
        if (0 == dwRefCount)
        {
            IASLogonShutdown();
        }
    }
    dwRetCode = ChapInit( fInitialize );    
    return dwRetCode;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
// All the dialogs required for EAPMSCHAPv2 go here.  Move into it's own file later.
////////////////////////////////////////////////////////////////////////////////////////////////////////

static const DWORD g_adwHelp[] =
{
    0,         0
};



VOID
ContextHelp(
    IN  const   DWORD*  padwMap,
    IN          HWND    hWndDlg,
    IN          UINT    unMsg,
    IN          WPARAM  wParam,
    IN          LPARAM  lParam
)
{
    return;
}

BOOL
LogonInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    PEAPMSCHAPv2_LOGON_DIALOG       pMSCHAPv2LogonDialog;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp;

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);


    pMSCHAPv2LogonDialog = (PEAPMSCHAPv2_LOGON_DIALOG)lParam;
    pUserProp = pMSCHAPv2LogonDialog->pUserProp;
    
    pMSCHAPv2LogonDialog->hWndUserName = 
        GetDlgItem(hWnd, IDC_EDIT_USERNAME);

    pMSCHAPv2LogonDialog->hWndPassword = 
        GetDlgItem(hWnd, IDC_EDIT_PASSWORD);

    pMSCHAPv2LogonDialog->hWndDomain = 
        GetDlgItem(hWnd, IDC_EDIT_DOMAIN);

    pMSCHAPv2LogonDialog->hWndSavePassword = 
        GetDlgItem(hWnd, IDC_CHECK_SAVE_UID_PWD);


    //Setup upper limit on text boxes
    SendMessage(pMSCHAPv2LogonDialog->hWndUserName,
                EM_LIMITTEXT,
                UNLEN,
                0L
               );

    SendMessage(pMSCHAPv2LogonDialog->hWndPassword,
                EM_LIMITTEXT,
                PWLEN,
                0L
               );

    SendMessage(pMSCHAPv2LogonDialog->hWndDomain,
                EM_LIMITTEXT,
                DNLEN,
                0L
               );

    if ( pUserProp->fFlags  & EAPMSCHAPv2_FLAG_CALLED_WITHIN_WINLOGON )
    {
        EnableWindow ( pMSCHAPv2LogonDialog->hWndSavePassword, FALSE );
    }
    else if ( pUserProp->fFlags & EAPMSCHAPv2_FLAG_8021x )
    {
        ShowWindow ( pMSCHAPv2LogonDialog->hWndSavePassword, SW_HIDE );
    }
    else
    {
        if ( pUserProp->fFlags & EAPMSCHAPv2_FLAG_SAVE_UID_PWD )
        {
            CheckDlgButton(hWnd, IDC_CHECK_SAVE_UID_PWD, BST_CHECKED);
        }
    }

    if ( pUserProp->szUserName[0] )
    {
        SetWindowText(  pMSCHAPv2LogonDialog->hWndUserName,
                        pUserProp->szUserName
                     );                      
    }

    if ( pUserProp->szPassword[0] )
    {
        SetWindowText(  pMSCHAPv2LogonDialog->hWndPassword,
                        pUserProp->szPassword
                     );                      
    }

    if ( pUserProp->szDomain[0] )
    {
        SetWindowText(  pMSCHAPv2LogonDialog->hWndDomain,
                        pUserProp->szDomain
                     );                      
    }

    if ( !pUserProp->szUserName[0] )
    {
        SetFocus(pMSCHAPv2LogonDialog->hWndUserName);
    }
    else
    {
        SetFocus(pMSCHAPv2LogonDialog->hWndPassword);
    }
        
    

    return FALSE;

}

BOOL
LogonCommand(
    IN  PEAPMSCHAPv2_LOGON_DIALOG  pMSCHAPv2LogonDialog,
    IN  WORD                wNotifyCode,
    IN  WORD                wId,
    IN  HWND                hWndDlg,
    IN  HWND                hWndCtrl
)
{
    BOOL                            fRetVal = FALSE;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp = pMSCHAPv2LogonDialog->pUserProp;
    switch(wId)
    {
        case IDC_CHECK_SAVE_UID_PWD:
            if ( pUserProp->fFlags & EAPMSCHAPv2_FLAG_SAVE_UID_PWD )
            {

                //
                // We got the creds from rasman.  So toggle the display
                //
                if ( BST_CHECKED == 
                    IsDlgButtonChecked ( hWndDlg,  IDC_CHECK_SAVE_UID_PWD )
                )
                {                
                    SetWindowText( pMSCHAPv2LogonDialog->hWndPassword,
                                pUserProp->szPassword
                                );            
                }
                else
                {
                    
                    SetWindowText( pMSCHAPv2LogonDialog->hWndPassword,
                                ""                            
                                );
                }
            }
            break;
        case IDOK:
            //
            //grab info from the fields and set it in 
            //the logon dialog structure
            //
            GetWindowText( pMSCHAPv2LogonDialog->hWndUserName,
                           pUserProp->szUserName,
                           UNLEN+1
                         );

            GetWindowText( pMSCHAPv2LogonDialog->hWndPassword,
                           pUserProp->szPassword,
                           PWLEN+1
                         );

            GetWindowText ( pMSCHAPv2LogonDialog->hWndDomain,
                            pUserProp->szDomain,
                            DNLEN+1
                          );
    
            if ( !(pUserProp->fFlags  & EAPMSCHAPv2_FLAG_CALLED_WITHIN_WINLOGON )
&& !(pUserProp->fFlags & EAPMSCHAPv2_FLAG_8021x) )
            {
                if ( BST_CHECKED == 
                    IsDlgButtonChecked ( hWndDlg,  IDC_CHECK_SAVE_UID_PWD )
                )
                {
                    pUserProp->fFlags |= EAPMSCHAPv2_FLAG_SAVE_UID_PWD;
                }
                else
                {
                    pUserProp->fFlags &= ~EAPMSCHAPv2_FLAG_SAVE_UID_PWD;
                }
            }
            else if ( pUserProp->fFlags & EAPMSCHAPv2_FLAG_8021x )
            {
                pUserProp->fFlags |= EAPMSCHAPv2_FLAG_SAVE_UID_PWD;
            }
        case IDCANCEL:

            EndDialog(hWndDlg, wId);
            fRetVal = TRUE;
            break;
        default:
            break;
    }

    return fRetVal;
}


INT_PTR CALLBACK
LogonDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    PEAPMSCHAPv2_LOGON_DIALOG pMSCHAPv2LogonDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(LogonInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_COMMAND:

        pMSCHAPv2LogonDialog = (PEAPMSCHAPv2_LOGON_DIALOG)GetWindowLongPtr(hWnd, DWLP_USER);

        return(LogonCommand(pMSCHAPv2LogonDialog, 
                            HIWORD(wParam), 
                            LOWORD(wParam),
                            hWnd, 
                            (HWND)lParam)
                           );
    }

    return(FALSE);
}




BOOL
RetryInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    PEAPMSCHAPv2_LOGON_DIALOG       pMSCHAPv2LogonDialog;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp;

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);


    pMSCHAPv2LogonDialog = (PEAPMSCHAPv2_LOGON_DIALOG)lParam;
    pUserProp = pMSCHAPv2LogonDialog->pUserProp;
    
    pMSCHAPv2LogonDialog->hWndUserName = 
        GetDlgItem(hWnd, IDC_RETRY_USERNAME);

    pMSCHAPv2LogonDialog->hWndPassword = 
        GetDlgItem(hWnd, IDC_RETRY_PASSWORD);

    pMSCHAPv2LogonDialog->hWndDomain = 
        GetDlgItem(hWnd, IDC_RETRY_DOMAIN);


    //Setup upper limit on text boxes
    SendMessage(pMSCHAPv2LogonDialog->hWndUserName,
                EM_LIMITTEXT,
                UNLEN,
                0L
               );

    SendMessage(pMSCHAPv2LogonDialog->hWndPassword,
                EM_LIMITTEXT,
                PWLEN,
                0L
               );

    SendMessage(pMSCHAPv2LogonDialog->hWndDomain,
                EM_LIMITTEXT,
                DNLEN,
                0L
               );

    if ( pUserProp->fFlags & EAPMSCHAPv2_FLAG_SAVE_UID_PWD )
    {
        CheckDlgButton(hWnd, IDC_CHECK_SAVE_UID_PWD, BST_CHECKED);
    }

    if ( pUserProp->szUserName[0] )
    {
        SetWindowText(  pMSCHAPv2LogonDialog->hWndUserName,
                        pUserProp->szUserName
                     );                      
    }

    if ( pUserProp->szPassword[0] )
    {
        SetWindowText(  pMSCHAPv2LogonDialog->hWndPassword,
                        pUserProp->szPassword
                     );                      
    }

    if ( pUserProp->szDomain[0] )
    {
        SetWindowText(  pMSCHAPv2LogonDialog->hWndDomain,
                        pUserProp->szDomain
                     );                      
    }


    SetFocus(pMSCHAPv2LogonDialog->hWndUserName);
    

    return FALSE;

}

BOOL
RetryCommand(
    IN  PEAPMSCHAPv2_LOGON_DIALOG  pMSCHAPv2LogonDialog,
    IN  WORD                wNotifyCode,
    IN  WORD                wId,
    IN  HWND                hWndDlg,
    IN  HWND                hWndCtrl
)
{
    BOOL                            fRetVal = FALSE;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp = pMSCHAPv2LogonDialog->pUserProp;
    switch(wId)
    {
        case IDC_CHECK_SAVE_UID_PWD:
            
            if ( BST_CHECKED == 
                  IsDlgButtonChecked ( hWndDlg,  IDC_CHECK_SAVE_UID_PWD )
               )
            {
                pUserProp->fFlags |= EAPMSCHAPv2_FLAG_SAVE_UID_PWD;
            }
            else
            {
                pUserProp->fFlags &= ~EAPMSCHAPv2_FLAG_SAVE_UID_PWD;
            }
            break;
        case IDOK:
            //
            //grab new password from the dialog and set it in 
            //the logon dialog structure
            //

            GetWindowText( pMSCHAPv2LogonDialog->hWndPassword,
                           pUserProp->szPassword,
                           PWLEN+1
                         );                            

        case IDCANCEL:

            EndDialog(hWndDlg, wId);
            fRetVal = TRUE;
            break;
        default:
            break;
    }

    return fRetVal;
}


INT_PTR CALLBACK
RetryDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    PEAPMSCHAPv2_LOGON_DIALOG pMSCHAPv2LogonDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(RetryInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_COMMAND:

        pMSCHAPv2LogonDialog = (PEAPMSCHAPv2_LOGON_DIALOG)GetWindowLongPtr(hWnd, DWLP_USER);

        return(RetryCommand(pMSCHAPv2LogonDialog, 
                            HIWORD(wParam), 
                            LOWORD(wParam),
                            hWnd, 
                            (HWND)lParam)
                           );
    }

    return(FALSE);
}


///
/// Client configuration dialog
///

BOOL
ClientConfigInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    PEAPMSCHAPv2_CLIENTCONFIG_DIALOG pClientConfigDialog;
    PEAPMSCHAPv2_CONN_PROPERTIES    pConnProp;

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);


    pClientConfigDialog = (PEAPMSCHAPv2_CLIENTCONFIG_DIALOG)lParam;
    pConnProp = pClientConfigDialog->pConnProp;
    

    if ( pConnProp ->fFlags & EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS )
    {
        CheckDlgButton(hWnd, IDC_CHK_USE_WINLOGON, BST_CHECKED);
    }

    return FALSE;

}

BOOL
ClientConfigCommand(
    IN  PEAPMSCHAPv2_CLIENTCONFIG_DIALOG pClientConfigDialog,
    IN  WORD                wNotifyCode,
    IN  WORD                wId,
    IN  HWND                hWndDlg,
    IN  HWND                hWndCtrl
)
{
    BOOL                            fRetVal = FALSE;
    PEAPMSCHAPv2_CONN_PROPERTIES    pConnProp = pClientConfigDialog->pConnProp;
    switch(wId)
    {
        case IDC_CHK_USE_WINLOGON:
            
            if ( BST_CHECKED == 
                  IsDlgButtonChecked ( hWndDlg,  IDC_CHK_USE_WINLOGON )
               )
            {
                pConnProp->fFlags |= EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS;
            }
            else
            {
                pConnProp->fFlags &= ~EAPMSCHAPv2_FLAG_USE_WINLOGON_CREDS;
            }
            break;
        case IDOK:
        case IDCANCEL:

            EndDialog(hWndDlg, wId);
            fRetVal = TRUE;
            break;
        default:
            break;
    }

    return fRetVal;
}


INT_PTR CALLBACK
ClientConfigDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    PEAPMSCHAPv2_CLIENTCONFIG_DIALOG pClientConfigDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(ClientConfigInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_COMMAND:

        pClientConfigDialog = (PEAPMSCHAPv2_CLIENTCONFIG_DIALOG)GetWindowLongPtr(hWnd, DWLP_USER);

        return(ClientConfigCommand(pClientConfigDialog, 
                            HIWORD(wParam), 
                            LOWORD(wParam),
                            hWnd, 
                            (HWND)lParam)
                           );
    }

    return(FALSE);
}


//// Server Configuration
//
BOOL
ServerConfigInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    PEAPMSCHAPv2_SERVERCONFIG_DIALOG pServerConfigDialog;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp;
    CHAR                            szRetries[10] = {0};

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);


    pServerConfigDialog = (PEAPMSCHAPv2_SERVERCONFIG_DIALOG)lParam;
    pUserProp = pServerConfigDialog->pUserProp;

    pServerConfigDialog->hWndRetries = 
        GetDlgItem(hWnd, IDC_EDIT_RETRIES);
    
    SendMessage(pServerConfigDialog->hWndRetries ,
                EM_LIMITTEXT,
                2,
                0L
               );

    if ( pUserProp->fFlags & EAPMSCHAPv2_FLAG_ALLOW_CHANGEPWD )
    {
        CheckDlgButton(hWnd, IDC_CHECK_ALLOW_CHANGEPWD, BST_CHECKED);
    }

    SetWindowText(  pServerConfigDialog->hWndRetries,
                    _ltoa(pUserProp->dwMaxRetries, szRetries, 10)
                 );                      


    return FALSE;

}


BOOL
ServerConfigCommand(
    IN  PEAPMSCHAPv2_SERVERCONFIG_DIALOG pServerConfigDialog,
    IN  WORD                wNotifyCode,
    IN  WORD                wId,
    IN  HWND                hWndDlg,
    IN  HWND                hWndCtrl
)
{
    BOOL                            fRetVal = FALSE;
    PEAPMSCHAPv2_USER_PROPERTIES    pUserProp = pServerConfigDialog->pUserProp;
    
    switch(wId)
    {
        case IDC_CHECK_ALLOW_CHANGEPWD:
            
            if ( BST_CHECKED == 
                  IsDlgButtonChecked ( hWndDlg,  IDC_CHECK_ALLOW_CHANGEPWD )
               )
            {
                pUserProp->fFlags |= EAPMSCHAPv2_FLAG_ALLOW_CHANGEPWD;
            }
            else
            {
                pUserProp->fFlags &= ~EAPMSCHAPv2_FLAG_ALLOW_CHANGEPWD;
            }
            fRetVal = TRUE;
            break;
        case IDOK:
            {
                CHAR    szRetries[10] = {0};
                //
                // Get the new value for retries
                //
                GetWindowText ( pServerConfigDialog->hWndRetries,
                                szRetries,
                                9
                              );
                pUserProp->dwMaxRetries = atol(szRetries);
                                
            }
        case IDCANCEL:

            EndDialog(hWndDlg, wId);
            fRetVal = TRUE;
            break;
        default:
            break;
    }

    return fRetVal;
}


INT_PTR CALLBACK
ServerConfigDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    PEAPMSCHAPv2_SERVERCONFIG_DIALOG pServerConfigDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(ServerConfigInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_COMMAND:

        pServerConfigDialog = (PEAPMSCHAPv2_SERVERCONFIG_DIALOG)GetWindowLongPtr(hWnd, DWLP_USER);

        return(ServerConfigCommand(pServerConfigDialog, 
                            HIWORD(wParam), 
                            LOWORD(wParam),
                            hWnd, 
                            (HWND)lParam)
                           );
    }

    return(FALSE);
}




//// Change Password Dialog
//

BOOL
ChangePasswordInitDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    PEAPMSCHAPv2_CHANGEPWD_DIALOG pChangePwdDialog;


    SetWindowLongPtr(hWnd, DWLP_USER, lParam);



    pChangePwdDialog = (PEAPMSCHAPv2_CHANGEPWD_DIALOG)lParam;
    
    if ( pChangePwdDialog->pInteractiveUIData->fFlags & EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD )
    {
        pChangePwdDialog->hWndNewPassword = 
            GetDlgItem(hWnd, IDC_NEW_PASSWORD);

        pChangePwdDialog->hWndConfirmNewPassword =
            GetDlgItem(hWnd, IDC_CONFIRM_NEW_PASSWORD);

        SetWindowText(  pChangePwdDialog->hWndNewPassword,
                        ""                    
                    );
    }
    else
    {
        pChangePwdDialog->hWndNewPassword = 
            GetDlgItem(hWnd, CID_CP_EB_Password_RASDLG);

        pChangePwdDialog->hWndConfirmNewPassword =
            GetDlgItem(hWnd, CID_CP_EB_ConfirmPassword_RASDLG);

        pChangePwdDialog->hWndOldPassword = 
            GetDlgItem(hWnd,CID_CP_EB_OldPassword_RASDLG);

        SetWindowText ( pChangePwdDialog->hWndOldPassword,
                        ""
                      );
        SetFocus( pChangePwdDialog->hWndOldPassword );
    }

    SendMessage ( pChangePwdDialog->hWndNewPassword,
                  EM_LIMITTEXT,
                  PWLEN-1,
                  0L
                );

    SendMessage ( pChangePwdDialog->hWndConfirmNewPassword,
                  EM_LIMITTEXT,
                  PWLEN-1,
                  0L
                );

    
    SetWindowText(  pChangePwdDialog->hWndNewPassword,
                    ""                    
                 );

    SetWindowText(  pChangePwdDialog->hWndConfirmNewPassword,
                    ""                    
                 );

    return FALSE;

}


BOOL
ChangePasswordCommand(
    IN  PEAPMSCHAPv2_CHANGEPWD_DIALOG pChangePwdDialog,
    IN  WORD                wNotifyCode,
    IN  WORD                wId,
    IN  HWND                hWndDlg,
    IN  HWND                hWndCtrl
)
{
    BOOL                            fRetVal = FALSE;
      
    switch(wId)
    {
        case IDOK:
            {
                CHAR    szOldPassword[PWLEN+1] = {0};
                CHAR    szNewPassword[PWLEN+1] = {0};
                CHAR    szConfirmNewPassword[PWLEN+1] = {0};
                CHAR    szMessage[512] = {0};
                CHAR    szHeader[64] = {0};
                LoadString( GetResouceDLLHInstance(),
                            IDS_MESSAGE_HEADER,
                            szHeader,
                            sizeof(szHeader)-1
                          );
                if ( pChangePwdDialog->pInteractiveUIData->fFlags & 
                     EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD_WINLOGON 
                   )
                {
                    GetWindowText ( pChangePwdDialog->hWndOldPassword,
                                    szOldPassword,
                                    PWLEN
                                );

                }

                
                //
                // Get the new value for retries
                //
                GetWindowText ( pChangePwdDialog->hWndNewPassword,
                                szNewPassword,
                                PWLEN
                              );

                GetWindowText ( pChangePwdDialog->hWndConfirmNewPassword,
                                szConfirmNewPassword,
                                PWLEN
                              );

                if ( szNewPassword[0] == 0 )
                {
                    //
                    // Load resource from res file
                    //

                    LoadString( GetResouceDLLHInstance(),
                                IDS_PASSWORD_REQUIRED,
                                szMessage,
                                sizeof(szMessage)-1
                              );

                    MessageBox (hWndDlg, 
                                  szMessage,
                                  szHeader,
                                  MB_OK
                                 );
                    break;
                }
                if ( pChangePwdDialog->pInteractiveUIData->fFlags & 
                     EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD_WINLOGON 
                   )
                {
                    if ( szOldPassword[0] == 0 )
                    {
                        LoadString( GetResouceDLLHInstance(),
                                    IDS_PASSWORD_REQUIRED,
                                    szMessage,
                                    sizeof(szMessage)-1
                                );

                        MessageBox (hWndDlg, 
                                    szMessage,
                                    szHeader,
                                    MB_OK
                                    );
                        break;
                    }
                }

                if ( strncmp ( szNewPassword, szConfirmNewPassword, PWLEN ) )
                {
                    LoadString( GetResouceDLLHInstance(),
                                IDS_PASSWORD_MISMATCH,
                                szMessage,
                                sizeof(szMessage)-1
                              );

                    MessageBox (hWndDlg, 
                                  szMessage,
                                  szHeader,
                                  MB_OK
                                 );
                    break;
                }
                if ( pChangePwdDialog->pInteractiveUIData->fFlags & 
                     EAPMSCHAPv2_INTERACTIVE_UI_FLAG_CHANGE_PWD_WINLOGON 
                   )
                {
                    //Save the old paswword.
                    CopyMemory ( pChangePwdDialog->pInteractiveUIData->UserProp.szPassword,
                                szOldPassword,
                                PWLEN
                            );
                }

                CopyMemory ( pChangePwdDialog->pInteractiveUIData->szNewPassword,
                             szNewPassword,
                             PWLEN
                           );
                //fall thru                
            }
        case IDCANCEL:

            EndDialog(hWndDlg, wId);
            fRetVal = TRUE;
            break;
        default:
            break;
    }

    return fRetVal;
}


INT_PTR CALLBACK
ChangePasswordDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    PEAPMSCHAPv2_CHANGEPWD_DIALOG pChangePwdDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(ChangePasswordInitDialog(hWnd, lParam));

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
        ContextHelp(g_adwHelp, hWnd, unMsg, wParam, lParam);
        break;
    }

    case WM_COMMAND:

        pChangePwdDialog = (PEAPMSCHAPv2_CHANGEPWD_DIALOG)GetWindowLongPtr(hWnd, DWLP_USER);

        return(ChangePasswordCommand(pChangePwdDialog, 
                            HIWORD(wParam), 
                            LOWORD(wParam),
                            hWnd, 
                            (HWND)lParam)
                           );
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\raschap.c ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** raschap.c
** Remote Access PPP Challenge Handshake Authentication Protocol
** Core routines
**
** 11/05/93 Steve Cobb
**
**
** ---------------------------------------------------------------------------
** Regular
** Client                             Server
** ---------------------------------------------------------------------------
**
**                                 <- Challenge (SendWithTimeout,ID)
** Response (SendWithTimeout,ID)   ->
**                                 <- Result (OK:SendAndDone, ID)
**
** ---------------------------------------------------------------------------
** Retry logon
** Client                             Server
** ---------------------------------------------------------------------------
**
**                                 <- Challenge (SendWithTimeout,ID)
** Response (SendWithTimeout,ID)   ->
**                                 <- Result (Fail:SendWithTimeout2,ID,R=1)
**                                      R=1 implies challenge of last+23
** Response (SendWithTimeout,++ID) ->
**   to last challenge+23
**   or C=xxxxxxxx if present
**       e.g. Chicago server
**                                 <- Result (Fail:SendAndDone,ID,R=0)
**
** ---------------------------------------------------------------------------
** Change password
** Client                             Server
** ---------------------------------------------------------------------------
**
**                                 <- Challenge (SendWithTimeout,ID)
** Response (SendWithTimeout,ID)   ->
**                                 <- Result (Fail:SendWithTimeout2,ID,R=1,V=2)
**                                      E=ERROR_PASSWD_EXPIRED
** ChangePw (SendWithTimeout,++ID) ->
**   to last challenge
**                                 <- Result (Fail:SendAndDone,ID,R=0)
**
** Note: Retry is never allowed after Change Password.  Change Password may
**       occur on a retry.  ChangePw2 is sent if Result included V=2 (or
**       higher), while ChangePw1 is sent if V<2 or is not provided.
**
** ---------------------------------------------------------------------------
** ChangePw1 packet
** ---------------------------------------------------------------------------
**
**   1-octet  : Code (=CHAP_ChangePw1)
**   1-octet  : Identifier
**   2-octet  : Length (=72)
**  16-octets : New LM OWF password encrypted with challenge
**  16-octets : Old LM OWF password encrypted with challenge
**  16-octets : New NT OWF password encrypted with challenge
**  16-octets : Old NT OWF password encrypted with challenge
**   2-octets : New password length in bytes
**   2-octets : Flags (1=NT forms present)
**
** Note: Encrypting with the challenge is not good because it is not secret
**       from line snoopers.  This bug got ported to NT 3.5 from AMB.  It is
**       fixed in the V2 packet where everything depends on knowledge of the
**       old NT OWF password, which is a proper secret.
**
** ---------------------------------------------------------------------------
** ChangePw2 packet
** ---------------------------------------------------------------------------
**
**   1-octet  : Code (=CHAP_ChangePw2)
**   1-octet  : Identifier
**   2-octet  : Length (=1070)
** 516-octets : New password encrypted with old NT OWF password
**  16-octets : Old NT OWF password encrypted with new NT OWF password
** 516-octets : New password encrypted with old LM OWF password
**  16-octets : Old LM OWF password encrypted with new NT OWF password
**  24-octets : LM challenge response
**  24-octets : NT challenge response
**   2-octet  : Flags
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <ntsamp.h>
#include <crypt.h>
#include <windows.h>
#include <lmcons.h>
#include <string.h>
#include <stdlib.h>
#include <rasman.h>
#include <pppcp.h>
#include <raserror.h>
#include <rtutils.h>
#include <rasauth.h>
#define INCL_PWUTIL
#define INCL_HOSTWIRE
#define INCL_CLSA
#define INCL_RASAUTHATTRIBUTES
#define INCL_MISC
#include <ppputil.h>
#define RASCHAPGLOBALS
#include "sha.h"
#include "raschap.h"



/*---------------------------------------------------------------------------
** External entry points
**---------------------------------------------------------------------------
*/

DWORD
ChapInit(
    IN  BOOL        fInitialize )

    /* Called to initialize/uninitialize this CP. In the former case,
    ** fInitialize will be TRUE; in the latter case, it will be FALSE.
    */
{
    DWORD dwRetCode;

    if ( fInitialize )
    {
        if (0 == g_dwRefCount)
        {
            g_dwTraceIdChap = TraceRegisterA( "RASCHAP" );

            if ( g_hLsa == INVALID_HANDLE_VALUE )
            {
                if ( ( dwRetCode = InitLSA() ) != NO_ERROR )
                {
                    return( dwRetCode );
                }

            }

            //
            // Get the computer name for local identification to send in 
            // chap challenges
            // 

            {
                DWORD dwLength = sizeof( szComputerName );

                if ( !GetComputerNameA( szComputerName, &dwLength ) )
                {
                    return( GetLastError() );
                }
                
            }

            ChapChangeNotification();
        }

        g_dwRefCount++;
    }
    else
    {
        g_dwRefCount--;

        if (0 == g_dwRefCount)
        {
            if ( g_dwTraceIdChap != INVALID_TRACEID )
            {
                TraceDeregisterA( g_dwTraceIdChap );

                g_dwTraceIdChap = INVALID_TRACEID;
            }

            if ( g_hLsa != INVALID_HANDLE_VALUE )
            {
                EndLSA();

                g_hLsa = INVALID_HANDLE_VALUE;
            }
        }
    }

    return(NO_ERROR);
}

DWORD
ChapChangeNotification(
    VOID
)
{
    return( NO_ERROR );
}

DWORD APIENTRY
RasCpEnumProtocolIds(
    OUT DWORD* pdwProtocolIds,
    OUT DWORD* pcProtocolIds )

    /* RasCpEnumProtocolIds entry point called by the PPP engine by name.  See
    ** RasCp interface documentation.
    */
{
    TRACE("RasCpEnumProtocolIds");

    pdwProtocolIds[ 0 ] = (DWORD )PPP_CHAP_PROTOCOL;
    *pcProtocolIds = 1;
    return 0;
}

DWORD
RasCpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pInfo )

    /* ChapGetInfo entry point called by the PPP engine.  See RasCp
    ** interface documentation.
    */
{
    memset( pInfo, '\0', sizeof(*pInfo) );
    lstrcpy( pInfo->SzProtocolName, "CHAP" );

    pInfo->Protocol                 = (DWORD )PPP_CHAP_PROTOCOL;
    pInfo->Recognize                = MAXCHAPCODE + 1;
    pInfo->RasCpInit                = ChapInit;
    pInfo->RasCpBegin               = ChapBegin;
    pInfo->RasCpEnd                 = ChapEnd;
    pInfo->RasApMakeMessage         = ChapMakeMessage;
    pInfo->RasCpChangeNotification  = ChapChangeNotification;

    return 0;
}


DWORD
ChapBegin(
    OUT VOID** ppWorkBuf,
    IN  VOID*  pInfo )

    /* RasCpBegin entry point called by the PPP engine thru the passed
    ** address.  See RasCp interface documentation.
    */
{
    DWORD        dwErr;
    PPPAP_INPUT* pInput = (PPPAP_INPUT* )pInfo;
    CHAPWB*      pwb;

    TRACE2("ChapBegin(fS=%d,bA=0x%x)",pInput->fServer,*(pInput->pAPData));

    if ( ( *(pInput->pAPData) != PPP_CHAP_DIGEST_MSEXT ) &&
         ( *(pInput->pAPData) != PPP_CHAP_DIGEST_MD5 )   &&
         ( *(pInput->pAPData) != PPP_CHAP_DIGEST_MSEXT_NEW ) )
    {
        TRACE("Bogus digest");
        return ERROR_INVALID_PARAMETER;
    }

    /* Allocate work buffer.
    */
    if (!(pwb = (CHAPWB* )LocalAlloc( LPTR, sizeof(CHAPWB) )))
        return ERROR_NOT_ENOUGH_MEMORY;

    pwb->fServer = pInput->fServer;
    pwb->hport = pInput->hPort;
    pwb->bAlgorithm = *(pInput->pAPData);
    pwb->fConfigInfo = pInput->fConfigInfo;
	pwb->chSeed = GEN_RAND_ENCODE_SEED;

    if (pwb->fServer)
    {
        pwb->dwTriesLeft = pInput->dwRetries;

        pwb->hPort = pInput->hPort;

        pwb->dwInitialPacketId = pInput->dwInitialPacketId;
    }
    else
    {
        if ((dwErr = StoreCredentials( pwb, pInput )) != 0)
        {
            LocalFree( (HLOCAL )pwb);
            return dwErr;
        }

        pwb->Luid = pInput->Luid;
    }

    pwb->state = CS_Initial;

    /* Register work buffer with engine.
    */
    *ppWorkBuf = pwb;
    TRACE("ChapBegin done.");
    return 0;
}


DWORD
ChapEnd(
    IN VOID* pWorkBuf )

    /* RasCpEnd entry point called by the PPP engine thru the passed address.
    ** See RasCp interface documentation.
    */
{
    TRACE("ChapEnd");

    if ( pWorkBuf != NULL )
    {
        CHAPWB* pwb = (CHAPWB* )pWorkBuf;

        if ( pwb->pUserAttributes != NULL )
        {
            RasAuthAttributeDestroy( pwb->pUserAttributes );
        }

        if ( pwb->pMPPEKeys != NULL )
        {
            RasAuthAttributeDestroy( pwb->pMPPEKeys );
        }

        /* Nuke any credentials in memory.
        */
        ZeroMemory( pWorkBuf, sizeof(CHAPWB) );

        LocalFree( (HLOCAL )pWorkBuf );
    }

    return 0;
}


DWORD
ChapMakeMessage(
    IN  VOID*         pWorkBuf,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput )

    /* RasApMakeMessage entry point called by the PPP engine thru the passed
    ** address.  See RasCp interface documentation.
    */
{
    CHAPWB* pwb = (CHAPWB* )pWorkBuf;

    TRACE1("ChapMakeMessage,RBuf=%p",pReceiveBuf);

    return
        (pwb->fServer)
            ? ChapSMakeMessage(
                  pwb, pReceiveBuf, pSendBuf, cbSendBuf, pResult, pInput )
            : ChapCMakeMessage(
                  pwb, pReceiveBuf, pSendBuf, cbSendBuf, pResult, pInput );
}


/*---------------------------------------------------------------------------
** Internal routines
**---------------------------------------------------------------------------
*/

VOID
ChapExtractMessage(
    IN  PPP_CONFIG*   pReceiveBuf,
    IN  BYTE          bAlgorithm,
    OUT PPPAP_RESULT* pResult )
{
    WORD    cbPacket;
    DWORD   dwNumBytes;
    CHAR*   pszReplyMessage         = NULL;
    DWORD   cbMessage;
    CHAR    szBuf[ MAXINFOLEN + 1 ];
    CHAR*   pszValue;

    cbPacket = WireToHostFormat16(pReceiveBuf->Length);

    if (PPP_CONFIG_HDR_LEN >= cbPacket)
    {
        goto LDone;
    }

    cbMessage = min( cbPacket - PPP_CONFIG_HDR_LEN, MAXINFOLEN );
    CopyMemory( szBuf, pReceiveBuf->Data, cbMessage );
    szBuf[ cbMessage ] = '\0';

    if (PPP_CHAP_DIGEST_MD5 == bAlgorithm)
    {
        pszValue = szBuf;
        dwNumBytes = cbMessage;
    }
    else
    {
        pszValue = strstr(szBuf, "M=");

        if (pszValue == NULL)
        {
            dwNumBytes = 0;
        }
        else
        {
            //
            // Eat the "M="
            //

            pszValue += 2;

            dwNumBytes = strlen(pszValue);
        }
    }

    if (0 == dwNumBytes)
    {
        goto LDone;
    }

    //
    // One more for the terminating NULL.
    //

    pszReplyMessage = LocalAlloc(LPTR, dwNumBytes + 1);

    if (NULL == pszReplyMessage)
    {
        TRACE("LocalAlloc failed. Cannot extract server's message.");
        goto LDone;
    }

    CopyMemory(pszReplyMessage, pszValue, dwNumBytes);

    LocalFree(pResult->szReplyMessage);

    pResult->szReplyMessage = pszReplyMessage;

    pszReplyMessage = NULL;

LDone:

    LocalFree(pszReplyMessage);

    return;
}

BOOL
IsSuccessPacketValid(
    IN  CHAPWB*       pwb,
    IN  PPP_CONFIG*   pReceiveBuf
)
{
    A_SHA_CTX   SHAContext1;
    A_SHA_CTX   SHAContext2;
    BYTE        SHADigest1[A_SHA_DIGEST_LEN];
    BYTE        SHADigest2[A_SHA_DIGEST_LEN];
    DWORD       cbSignature;
    CHAR        szBuf[ MAXINFOLEN + 2];
    CHAR*       pszValue;
    DWORD       dwLength = WireToHostFormat16( pReceiveBuf->Length );
    BYTE        bSignature[sizeof(SHADigest2)];

    if ( dwLength < PPP_CONFIG_HDR_LEN )
    {
        return( FALSE );
    }

    cbSignature = min( dwLength - PPP_CONFIG_HDR_LEN, MAXINFOLEN );
    CopyMemory( szBuf, pReceiveBuf->Data, cbSignature );
    szBuf[ cbSignature ] = szBuf[ cbSignature + 1 ] = '\0';

    pszValue = strstr( szBuf, "S=" );

    if ( pszValue == NULL )
    {
        return( FALSE );
    }
    else
    {
        CHAR* pchIn = pszValue + 2;
        CHAR* pchOut = (CHAR* )bSignature;
        INT   i;

        ZeroMemory( bSignature, sizeof( bSignature ) );

        for (i = 0; i < sizeof( bSignature ) + sizeof( bSignature ); ++i)
        {
            BYTE bHexCharValue = HexCharValue( *pchIn++ );

            if (bHexCharValue == 0xFF)
                break;

            if (i & 1)
                *pchOut++ += bHexCharValue;
            else
                *pchOut = bHexCharValue << 4;
        }
    }

    A_SHAInit( &SHAContext1 );

    A_SHAUpdate( &SHAContext1, (PBYTE)&(pwb->keyUser), sizeof( pwb->keyUser) );

    A_SHAUpdate( &SHAContext1,
                 pwb->abResponse + LM_RESPONSE_LENGTH,
                 NT_RESPONSE_LENGTH );

    A_SHAUpdate( &SHAContext1,
                 "Magic server to client signing constant",
                 strlen( "Magic server to client signing constant" ) );

    A_SHAFinal( &SHAContext1, SHADigest1 );

    A_SHAInit( &SHAContext2 );

    A_SHAUpdate( &SHAContext2, SHADigest1, sizeof( SHADigest1 ) );

    A_SHAUpdate( &SHAContext2, pwb->abComputedChallenge, 8 );

    A_SHAUpdate( &SHAContext2,
                 "Pad to make it do more than one iteration",
                 strlen( "Pad to make it do more than one iteration" ) );

    A_SHAFinal( &SHAContext2, SHADigest2 );

    if ( memcmp( SHADigest2, bSignature, sizeof( SHADigest2 ) ) != 0 )
    {
        TRACE(("CHAP: Signature received...\n"));
        DUMPB(bSignature,(WORD)sizeof( SHADigest2 ) );

        TRACE(("CHAP: Signature should be...\n"));
        DUMPB( SHADigest2,(WORD)sizeof( SHADigest2 ) );

        return( FALSE );
    }

    return( TRUE );
}

DWORD
ChapCMakeMessage(
    IN  CHAPWB*       pwb,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput )

    /* Client side "make message" entry point.  See RasCp interface
    ** documentation.
    */
{
    DWORD dwErr;

    TRACE("ChapCMakeMessage...");

    switch (pwb->state)
    {
        case CS_Initial:
        {
            TRACE("CS_Initial");

            /* Tell engine we're waiting for the server to initiate the
            ** conversation.
            */
            pResult->Action = APA_NoAction;
            pwb->state = CS_WaitForChallenge;
            break;
        }

        case CS_WaitForChallenge:
        case CS_Done:
        {
            TRACE1("CS_%s",(pwb->state==CS_Done)?"Done":"WaitForChallenge");

            /*
            ** Should not receive Timeouts in this state. If we do simply
            ** ignore it.
            */

            if (!pReceiveBuf)
            {
                pResult->Action = APA_NoAction;
                break;
            }

            /* Note: Done state is same as WaitForChallenge per CHAP spec.
            ** Must be ready to respond to new Challenge at any time during
            ** Network Protocol phase.
            */

            if (pReceiveBuf->Code != CHAPCODE_Challenge)
            {
                /* Everything but a Challenge is garbage at this point, and is
                ** silently discarded.
                */
                pResult->Action = APA_NoAction;
                break;
            }

            if ((dwErr = GetChallengeFromChallenge( pwb, pReceiveBuf )))
            {
                TRACE1("GetChallengeFromChallenge=%d",dwErr);
                return dwErr;
            }

            /* Build a Response to the Challenge and send it.
            */
            pwb->fNewChallengeProvided = FALSE;
            pwb->bIdToSend = pwb->bIdExpected = pReceiveBuf->Id;

            if ((dwErr = MakeResponseMessage(
                    pwb, pSendBuf, cbSendBuf, FALSE )) != 0)
            {
                TRACE1("MakeResponseMessage(WC)=%d",dwErr);
                return dwErr;
            }

            pResult->Action = APA_SendWithTimeout;
            pResult->bIdExpected = pwb->bIdExpected;
            pwb->state = CS_ResponseSent;
            break;
        }

        case CS_ResponseSent:
        case CS_ChangePw1Sent:
        case CS_ChangePw2Sent:
        {
            TRACE1("CS_%sSent",
                    (pwb->state==CS_ResponseSent)
                        ?"Response"
                        :(pwb->state==CS_ChangePw1Sent)
                            ?"ChangePw1"
                            :"ChangePw2");

            if (!pReceiveBuf)
            {
                /* Timed out, resend our message.
                */
                if (pwb->state == CS_ResponseSent)
                {
                    if ((dwErr = MakeResponseMessage(
                            pwb, pSendBuf, cbSendBuf, TRUE )) != 0)
                    {
                        TRACE1("MakeResponseMessage(RS)=%d",dwErr);
                        return dwErr;
                    }
                }
                else if (pwb->state == CS_ChangePw1Sent)
                {
                    if ((dwErr = MakeChangePw1Message(
                            pwb, pSendBuf, cbSendBuf )) != 0)
                    {
                        TRACE1("MakeChangePw1Message(CPS)=%d",dwErr);
                        return dwErr;
                    }
                }
                else // if (pwb->state == CS_ChangePw2Sent)
                {
                    if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT )
                    {
                        if ((dwErr = MakeChangePw2Message(
                                    pwb, pSendBuf, cbSendBuf )) != 0)
                        {
                            TRACE1("MakeChangePw2Message(CPS)=%d",dwErr);
                            return dwErr;
                        }
                    }
                    else
                    {
                        if ((dwErr = MakeChangePw3Message(
                                        pwb, pSendBuf, cbSendBuf, TRUE )) != 0)
                        {
                            TRACE1("MakeChangePw3Message(CPS)=%d",dwErr);
                            return dwErr;
                        }
                    }
                }

                pResult->Action = APA_SendWithTimeout;
                pResult->bIdExpected = pwb->bIdExpected;
                break;
            }

            TRACE("Message received...");
            DUMPB(pReceiveBuf,(WORD)(((BYTE*)pReceiveBuf)[3]));

            if (pReceiveBuf->Code == CHAPCODE_Challenge)
            {
                /* Restart when new challenge is received, per CHAP spec.
                */
                pwb->state = CS_WaitForChallenge;
                return ChapCMakeMessage(
                    pwb, pReceiveBuf, pSendBuf, cbSendBuf, pResult, NULL );
            }

            if (pReceiveBuf->Id != pwb->bIdExpected)
            {
                /* Received a packet out of sequence.  Silently discard it.
                */
                TRACE2("Got ID %d when expecting %d",
                        pReceiveBuf->Id,pwb->bIdExpected);
                pResult->Action = APA_NoAction;
                break;
            }

            ChapExtractMessage( pReceiveBuf, pwb->bAlgorithm, pResult );

            if ( pReceiveBuf->Code == CHAPCODE_Success )
            {
                /* Passed authentication.
                **
                ** Get the session key for encryption.
                */
                if ( ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT ) ||
                     ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW ) )
                {
                    if ( !pwb->fSessionKeysObtained )
                    {
                        DecodePw( pwb->chSeed, pwb->szPassword );
                        CGetSessionKeys(
                            pwb->szPassword, &pwb->keyLm, &pwb->keyUser );
                        EncodePw( pwb->chSeed, pwb->szPassword );

                        pwb->fSessionKeysObtained = TRUE;
                    }

                    if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW )
                    {
                        if ( !IsSuccessPacketValid( pwb, pReceiveBuf ) )
                        {
                            pwb->state       = CS_Done;
                            pResult->dwError = 
                                            ERROR_UNABLE_TO_AUTHENTICATE_SERVER;
                            pResult->fRetry  = FALSE;
                            pResult->Action  = APA_Done;
                            break;
                        }
                    }

                    if ( pwb->pMPPEKeys == NULL )
                    {
                        //
                        // We set up the MPPE key attribute to be passed to
                        // the PPP engine
                        //

                        BYTE MPPEKeys[6+8+16];

                        pwb->pMPPEKeys = RasAuthAttributeCreate( 1 );

                        if ( pwb->pMPPEKeys == NULL )
                        {
                            return( GetLastError() );
                        }

                        HostToWireFormat32( 311, MPPEKeys );    // Vendor Id
                        MPPEKeys[4] = 12;                       // Vendor Type
                        MPPEKeys[5] = 24;                       // Vendor Length

                        CopyMemory( MPPEKeys+6, &(pwb->keyLm), 8 );

                        CopyMemory( MPPEKeys+6+8, &(pwb->keyUser), 16 );

                        dwErr = RasAuthAttributeInsert(
                                           0,
                                           pwb->pMPPEKeys,
                                           raatVendorSpecific,
                                           FALSE,
                                           6+8+16,
                                           MPPEKeys );

                        if ( dwErr != NO_ERROR )
                        {
                            return( dwErr );
                        }
                    }

                    pResult->pUserAttributes = pwb->pMPPEKeys;

                    CopyMemory( pResult->abResponse,
                                pwb->abResponse+LM_RESPONSE_LENGTH, 
                                NT_RESPONSE_LENGTH );

                    CopyMemory( pResult->abChallenge,
                                ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW )
                                    ? pwb->abComputedChallenge
                                    : pwb->abChallenge,
                                sizeof( pResult->abChallenge ) );
                }

                pResult->Action     = APA_Done;
                pResult->dwError    = 0;
                pResult->fRetry     = FALSE;
                pwb->state          = CS_Done;
                strcpy( pResult->szUserName, pwb->szUserName );

                TRACE("Done :)");
            }
            else if (pReceiveBuf->Code == CHAPCODE_Failure)
            {
                DWORD dwVersion = 1;

                /* Failed authentication.
                */
                if ( ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT ) ||
                     ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW ) )
                {
                    GetInfoFromFailure(
                        pwb, pReceiveBuf,
                        &pResult->dwError, &pResult->fRetry, &dwVersion );
                }
                else
                {
                    pResult->dwError = ERROR_AUTHENTICATION_FAILURE;
                    pResult->fRetry = 0;
                }

                pResult->Action = APA_Done;

                if (pResult->dwError == ERROR_PASSWD_EXPIRED)
                {
                    pwb->state = (dwVersion < 2) ? CS_ChangePw1 : CS_ChangePw2;
                    pwb->bIdToSend = pReceiveBuf->Id + 1;
                    pwb->bIdExpected = pwb->bIdToSend;
                    TRACE3("ChangePw(%d) :| ex=%d ts=%d",
                            dwVersion,pwb->bIdExpected,pwb->bIdToSend);
                }
                else if (pResult->fRetry)
                {
                    pwb->state                  = CS_Retry;
                    pwb->bIdToSend              = pReceiveBuf->Id + 1;
                    pwb->bIdExpected            = pwb->bIdToSend;
                    pwb->fSessionKeysObtained   = FALSE;
                    TRACE2("Retry :| ex=%d ts=%d",
                            pwb->bIdExpected,pwb->bIdToSend);
                }
                else
                {
                    pwb->state = CS_Done;
                    TRACE("Done :(");
                }
            }
            else
            {
                /* Received a CHAPCODE_* besides CHAPCODE_Challenge,
                ** CHAPCODE_Success, and CHAPCODE_Failure.  The engine filters
                ** all non-CHAPCODEs.  Shouldn't happen, but silently discard
                ** it.
                */
                ASSERT(!"Bogus pReceiveBuf->Code");
                pResult->Action = APA_NoAction;
                break;
            }

            break;
        }

        case CS_Retry:
        case CS_ChangePw1:
        case CS_ChangePw2:
        {
            TRACE1("CS_%s",
                    (pwb->state==CS_Retry)
                        ?"Retry"
                        :(pwb->state==CS_ChangePw1)
                            ?"ChangePw1"
                            :"ChangePw2");

            if (pReceiveBuf)
            {
                if (pReceiveBuf->Code == CHAPCODE_Challenge)
                {
                    /* Restart when new challenge is received, per CHAP spec.
                    */
                    pwb->state = CS_WaitForChallenge;
                    return ChapCMakeMessage(
                        pwb, pReceiveBuf, pSendBuf, cbSendBuf, pResult, NULL );
                }
                else
                {
                    /* Silently discard.
                    */
                    pResult->Action = APA_NoAction;
                    break;
                }
            }

            if (!pInput)
            {
                pResult->Action = APA_NoAction;
                break;
            }

            if ((dwErr = StoreCredentials( pwb, pInput )) != 0)
                return dwErr;

            if (pwb->state == CS_Retry)
            {
                /* Build a response to the challenge and send it.
                */
                if (!pwb->fNewChallengeProvided)
                {
                    /* Implied challenge of old challenge + 23.
                    */
                    pwb->abChallenge[ 0 ] += 23;
                }

                if ((dwErr = MakeResponseMessage(
                        pwb, pSendBuf, cbSendBuf, FALSE )) != 0)
                {
                    return dwErr;
                }

                pwb->state = CS_ResponseSent;
            }
            else if (pwb->state == CS_ChangePw1)
            {
                /* Build a response to the NT35-style password expired
                ** notification and send it.
                */
                if ((dwErr = MakeChangePw1Message(
                        pwb, pSendBuf, cbSendBuf )) != 0)
                {
                    return dwErr;
                }

                pwb->state = CS_ChangePw1Sent;
            }
            else // if (pwb->state == CS_ChangePw2)
            {
                if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT )
                {
                    /* Build a response to the NT351-style password expired
                    ** notification and send it.
                    */
                    if ((dwErr = MakeChangePw2Message(
                                    pwb, pSendBuf, cbSendBuf )) != 0)
                    {
                        return dwErr;
                    }
                }
                else
                {
                    if ((dwErr = MakeChangePw3Message(
                                    pwb, pSendBuf, cbSendBuf, FALSE )) != 0)
                    {
                        return dwErr;
                    }
                }

                pwb->state = CS_ChangePw2Sent;
            }

            pResult->Action = APA_SendWithTimeout;
            pResult->bIdExpected = pwb->bIdExpected;
            break;
        }
    }

    return 0;
}


DWORD
GetChallengeFromChallenge(
    OUT CHAPWB*     pwb,
    IN  PPP_CONFIG* pReceiveBuf )

    /* Fill work buffer challenge array and length from that received in the
    ** received Challenge message.
    **
    ** Returns 0 if successful, or ERRORBADPACKET if the packet is
    ** misformatted in any way.
    */
{
    WORD cbPacket = WireToHostFormat16( pReceiveBuf->Length );

    if (cbPacket < PPP_CONFIG_HDR_LEN + 1)
        return ERRORBADPACKET;

    pwb->cbChallenge = *pReceiveBuf->Data;

    if (cbPacket < PPP_CONFIG_HDR_LEN + 1 + pwb->cbChallenge)
        return ERRORBADPACKET;

    memcpy( pwb->abChallenge, pReceiveBuf->Data + 1, pwb->cbChallenge );
    return 0;
}


DWORD
GetCredentialsFromResponse(
    IN  PPP_CONFIG* pReceiveBuf,
    IN  BYTE        bAlgorithm,
    OUT CHAR*       pszIdentity,
    OUT BYTE*       pbResponse )

    /* Fill caller's 'pszUserName' and 'pbResponse' buffers with
    ** the username, and response in the Response packet.  Caller's
    ** buffers should be at least UNLEN+DNLEN+1, and MSRESPONSELEN bytes long,
    ** respectively.  'BAlgorithm' is the CHAP algorithm code for either
    ** MS-CHAP or MD5.
    **
    ** Returns 0 if successful, or ERRORBADPACKET if the packet is
    ** misformatted in any way.
    */
{
    BYTE  cbIdentity;
    CHAR* pchIdentity;
    BYTE* pcbResponse;
    CHAR* pchResponse;
    WORD  cbPacket;

    cbPacket = WireToHostFormat16( pReceiveBuf->Length );

    /* Extract the response.
    */
    if (cbPacket < PPP_CONFIG_HDR_LEN + 1)
        return ERRORBADPACKET;

    pcbResponse = pReceiveBuf->Data;
    pchResponse = pcbResponse + 1;

    ASSERT(MSRESPONSELEN<=255);
    ASSERT(MD5RESPONSELEN<=255);

    if ( ( ( ( bAlgorithm == PPP_CHAP_DIGEST_MSEXT ) ||
             ( bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW ) )
                && *pcbResponse != MSRESPONSELEN )
        || ( ( bAlgorithm == PPP_CHAP_DIGEST_MD5 )
              && ( *pcbResponse != MD5RESPONSELEN ) )
        || ( cbPacket < ( PPP_CONFIG_HDR_LEN + 1 + *pcbResponse ) ) )
    {
        return ERRORBADPACKET;
    }

    memcpy( pbResponse, pchResponse, *pcbResponse );

    /* Parse out username 
    */
    pchIdentity = pchResponse + *pcbResponse;
    cbIdentity = (BYTE) (((BYTE* )pReceiveBuf) + cbPacket - pchIdentity);

    /* Extract the username.
    */
    ASSERT(cbIdentity<=(UNLEN+DNLEN+1));
    memcpy( pszIdentity, pchIdentity, cbIdentity );
    pszIdentity[ cbIdentity ] = '\0';

    return 0;
}


DWORD
GetInfoFromChangePw1(
    IN  PPP_CONFIG* pReceiveBuf,
    OUT CHANGEPW1*  pchangepw1 )

    /* Loads caller's '*pchangepw' buffer with the information from the
    ** version 1 change password packet.
    **
    ** Returns 0 if successful, or ERRORBADPACKET if the packet is
    ** misformatted in any way.
    */
{
    WORD cbPacket = WireToHostFormat16( pReceiveBuf->Length );

    TRACE("GetInfoFromChangePw1...");

    if (cbPacket < ( PPP_CONFIG_HDR_LEN + sizeof(CHANGEPW1) ) )
        return ERRORBADPACKET;

    CopyMemory( pchangepw1, pReceiveBuf->Data, sizeof(CHANGEPW1) );

    TRACE("GetInfoFromChangePw done(0)");
    return 0;
}


DWORD
GetInfoFromChangePw2(
    IN  PPP_CONFIG* pReceiveBuf,
    OUT CHANGEPW2*  pchangepw2,
    OUT BYTE*       pResponse )

    /* Loads caller's '*pchangepw2' buffer with the information from the
    ** version 2 change password packet, and caller's 'pResponse' buffer with
    ** the challenge response data from 'pchangepw2'.
    **
    ** Returns 0 if successful, or ERRORBADPACKET if the packet is
    ** misformatted in any way.
    */
{
    WORD cbPacket = WireToHostFormat16( pReceiveBuf->Length );
    WORD wFlags;

    TRACE("GetInfoFromChangePw2...");

    if (cbPacket < ( PPP_CONFIG_HDR_LEN + sizeof(CHANGEPW2) ) )
        return ERRORBADPACKET;

    CopyMemory( pchangepw2, pReceiveBuf->Data, sizeof(CHANGEPW2) );

    CopyMemory( pResponse, pchangepw2->abLmResponse, LM_RESPONSE_LENGTH );
    CopyMemory( pResponse + LM_RESPONSE_LENGTH, pchangepw2->abNtResponse,
                NT_RESPONSE_LENGTH );

    wFlags = WireToHostFormat16( pchangepw2->abFlags );
    pResponse[ LM_RESPONSE_LENGTH + NT_RESPONSE_LENGTH ] =
        (wFlags & CPW2F_UseNtResponse);

    TRACE("GetInfoFromChangePw2 done(0)");
    return 0;
}

DWORD
GetInfoFromChangePw3(
    IN  PPP_CONFIG* pReceiveBuf,
    OUT CHANGEPW3*  pchangepw3,
    OUT BYTE*       pResponse )

    /* Loads caller's '*pchangepw3' buffer with the information from the
    ** version 3 change password packet, and caller's 'pResponse' buffer with
    ** the challenge response data from 'pchangepw3'.
    **
    ** Returns 0 if successful, or ERRORBADPACKET if the packet is
    ** misformatted in any way.
    */
{
    WORD cbPacket = WireToHostFormat16( pReceiveBuf->Length );
    WORD wFlags;

    TRACE("GetInfoFromChangePw3...");

    if ( cbPacket < ( PPP_CONFIG_HDR_LEN + sizeof( CHANGEPW3 ) ) )
        return ERRORBADPACKET;

    memcpy( pchangepw3, pReceiveBuf->Data, sizeof(CHANGEPW3) );

    memcpy( pResponse, pchangepw3->abPeerChallenge, 16 );
    memcpy( pResponse + 16, pchangepw3->abNTResponse, 16 );

    pResponse[ 16 + 16 ] = 0;

    TRACE("GetInfoFromChangePw3 done(0)");
    return 0;
}

VOID
GetInfoFromFailure(
    IN  CHAPWB*     pwb,
    IN  PPP_CONFIG* pReceiveBuf,
    OUT DWORD*      pdwError,
    OUT BOOL*       pfRetry,
    OUT DWORD*      pdwVersion )

    /* Returns the RAS error number, retry flag, version number, and new
    ** challenge (sets challenge info in pwb) out of the Message portion of
    ** the Failure message buffer 'pReceiveBuf' or 0 if none.  This call
    ** applies to Microsoft extended CHAP Failure messages only.
    **
    ** Format of the message text portion of the result is a string of any of
    ** the following separated by a space.
    **
    **     "E=dddddddddd"
    **     "R=b"
    **     "C=xxxxxxxxxxxxxxxx"
    **     "V=v"
    **
    ** where
    **
    **     'dddddddddd' is the decimal error code (need not be 10 digits).
    **
    **     'b' is a boolean flag <0/1> that is set if a retry is allowed.
    **
    **     'xxxxxxxxxxxxxxxx' is 16-hex digits representing a new challenge to
    **     be used in place of the previous challenge + 23.  This is useful
    **     for pass-thru authentication where server may be unable to deal
    **     with the implicit challenge.  (Win95 guys requested it).
    **
    **     'v' is a version code where 2 indicates NT 3.51 level support.  'v'
    **     is assumed 1, i.e. NT 3.5 level support, if missing.
    */
{
#define MAXINFOLEN 1500

    WORD  cbPacket = WireToHostFormat16( pReceiveBuf->Length );
    WORD  cbError;
    CHAR  szBuf[ MAXINFOLEN + 2 ];
    CHAR* pszValue;

    TRACE("GetInfoFromFailure...");

    *pdwError = ERROR_AUTHENTICATION_FAILURE;
    *pfRetry = 0;
    *pdwVersion = 2;

    if (cbPacket <= PPP_CONFIG_HDR_LEN)
        return;

    /* Copy message to double-NUL-terminated 'szBuf' for convenient safe
    ** strstr value scanning.  For convenience, we assume that information
    ** appearing beyond 1500 bytes in the packet in not interesting.
    */
    cbError = min( cbPacket - PPP_CONFIG_HDR_LEN, MAXINFOLEN );
    memcpy( szBuf, pReceiveBuf->Data, cbError );
    szBuf[ cbError ] = szBuf[ cbError + 1 ] = '\0';

    pszValue = strstr( szBuf, "E=" );
    if (pszValue)
        *pdwError = (DWORD )atol( pszValue + 2 );

    *pfRetry = (strstr( szBuf, "R=1" ) != NULL);

    pszValue = strstr( szBuf, "V=" );
    if (pszValue)
        *pdwVersion = (DWORD )atol( pszValue + 2 );

    pszValue = strstr( szBuf, "C=" );
    pwb->fNewChallengeProvided = (pszValue != NULL);
    if (pwb->fNewChallengeProvided)
    {
        CHAR* pchIn = pszValue + 2;
        CHAR* pchOut = (CHAR* )pwb->abChallenge;
        INT   i;

        memset( pwb->abChallenge, '\0', sizeof(pwb->abChallenge) );

        for (i = 0; i < pwb->cbChallenge + pwb->cbChallenge; ++i)
        {
            BYTE bHexCharValue = HexCharValue( *pchIn++ );

            if (bHexCharValue == 0xFF)
                break;

            if (i & 1)
                *pchOut++ += bHexCharValue;
            else
                *pchOut = bHexCharValue << 4;
        }

        TRACE1("'C=' challenge provided,bytes=%d...",pwb->cbChallenge);
        DUMPB(pwb->abChallenge,pwb->cbChallenge);
    }

    TRACE3("GetInfoFromFailure done,e=%d,r=%d,v=%d",*pdwError,*pfRetry,*pdwVersion);
}


BYTE
HexCharValue(
    IN CHAR ch )

    /* Returns the integer value of hexidecimal character 'ch' or 0xFF if 'ch'
    ** is not a hexidecimal character.
    */
{
    if (ch >= '0' && ch <= '9')
        return (BYTE )(ch - '0');
    else if (ch >= 'A' && ch <= 'F')
        return (BYTE )(ch - 'A'+ 10);
    else if (ch >= 'a' && ch <= 'f')
        return (BYTE )(ch - 'a' + 10);
    else
        return 0xFF;
}

DWORD
MakeChallengeMessage(
    IN  CHAPWB*     pwb,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf )

    /* Builds a Challenge packet in caller's 'pSendBuf' buffer.  'cbSendBuf'
    ** is the length of caller's buffer.  'pwb' is the address of the work
    ** buffer associated with the port.
    */
{
    DWORD dwErr;
    WORD  wLength;
    BYTE* pcbChallenge;
    BYTE* pbChallenge;

    TRACE("MakeChallengeMessage...");

    if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT )
    {
        ASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+1+MSV1_0_CHALLENGE_LENGTH);

        /* Fill in the challenge.
        */
        pwb->cbChallenge = (BYTE )MSV1_0_CHALLENGE_LENGTH;
        if ((dwErr = GetChallenge( pwb->abChallenge )) != 0)
            return dwErr;
    }
    else if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW )
    {
        ASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+1+16);

        /* Fill in the challenge.
        */
        pwb->cbChallenge = (BYTE )16;

        if ((dwErr = (DWORD )GetChallenge( pwb->abChallenge )) != 0)
            return dwErr;

        if ((dwErr = (DWORD )GetChallenge( pwb->abChallenge+8 )) != 0)
            return dwErr;
    }
    else    
    {
        ASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+1+16);

        /* Fill in the challenge.
        */
        pwb->cbChallenge = (BYTE )16;
        if ((dwErr = GetChallenge( pwb->abChallenge )) != 0)
            return dwErr;

        GetSystemTimeAsFileTime( (FILETIME*)(pwb->abChallenge+8));
    }

    pcbChallenge = pSendBuf->Data;
    *pcbChallenge = pwb->cbChallenge;

    pbChallenge = pcbChallenge + 1;
    CopyMemory( pbChallenge, pwb->abChallenge, pwb->cbChallenge );

    //
    // Insert local identifcation at the end of the challenge
    //

    strcpy( pbChallenge + pwb->cbChallenge, szComputerName );

    /* Fill in the header.
    */
    pSendBuf->Code = (BYTE )CHAPCODE_Challenge;
    pSendBuf->Id = pwb->bIdToSend;

    wLength = (WORD )(PPP_CONFIG_HDR_LEN + 1 
                        + pwb->cbChallenge + strlen( szComputerName) );

    HostToWireFormat16( wLength, pSendBuf->Length );

    DUMPB(pSendBuf,wLength);
    return 0;
}


DWORD
MakeChangePw1Message(
    IN  CHAPWB*     pwb,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf )

    /* Builds a ChangePw1 response packet in caller's 'pSendBuf' buffer.
    ** 'cbSendBuf' is the length of caller's buffer.  'pwb' is the address of
    ** the work buffer associated with the port.
    **
    ** Returns 0 if successful, or a non-0 error code.
    */
{
    DWORD dwErr;
    WORD  wPwLength;

    TRACE("MakeChangePw1Message...");
    ASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+sizeof(CHANGEPW1));

    (void )cbSendBuf;

    if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW )
    {
        return( ERROR_NOT_SUPPORTED );
    }

    if ( !( pwb->fConfigInfo & PPPCFG_UseLmPassword ) )
    {
        return( ERROR_NOT_SUPPORTED );
    }

    DecodePw( pwb->chSeed, pwb->szOldPassword );
    DecodePw( pwb->chSeed, pwb->szPassword );

    dwErr =
        GetEncryptedOwfPasswordsForChangePassword(
           pwb->szOldPassword,
           pwb->szPassword,
           (PLM_SESSION_KEY )pwb->abChallenge,
           (PENCRYPTED_LM_OWF_PASSWORD )pwb->changepw.v1.abEncryptedLmOwfOldPw,
           (PENCRYPTED_LM_OWF_PASSWORD )pwb->changepw.v1.abEncryptedLmOwfNewPw,
           (PENCRYPTED_NT_OWF_PASSWORD )pwb->changepw.v1.abEncryptedNtOwfOldPw,
           (PENCRYPTED_NT_OWF_PASSWORD )pwb->changepw.v1.abEncryptedNtOwfNewPw);

    wPwLength = (UCHAR) strlen( pwb->szPassword );

    EncodePw( pwb->chSeed, pwb->szOldPassword );
    EncodePw( pwb->chSeed, pwb->szPassword );

    if (dwErr != 0)
        return dwErr;

    HostToWireFormat16( wPwLength, pwb->changepw.v1.abPasswordLength );
    HostToWireFormat16( CPW1F_UseNtResponse, pwb->changepw.v1.abFlags );
    CopyMemory( pSendBuf->Data, &pwb->changepw.v1, sizeof(CHANGEPW1) );

    /* Fill in the header.
    */
    pSendBuf->Code = (BYTE )CHAPCODE_ChangePw1;
    pSendBuf->Id = pwb->bIdToSend;
    HostToWireFormat16(
        PPP_CONFIG_HDR_LEN + sizeof(CHANGEPW1), pSendBuf->Length );

    TRACE("MakeChangePw1Message done(0)");
    return 0;
}


DWORD
MakeChangePw2Message(
    IN  CHAPWB*     pwb,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf )

    /* Builds a ChangePw2 response packet in caller's 'pSendBuf' buffer.
    ** 'cbSendBuf' is the length of caller's buffer.  'pwb' is the address of
    ** the work buffer associated with the port.
    **
    ** Returns 0 if successful, or a non-0 error code.
    */
{
    DWORD    dwErr;
    BOOLEAN  fLmPresent;
    BYTE     fbUseNtResponse;
    BYTE     bRandomNumber[MSV1_0_CHALLENGE_LENGTH];

    TRACE("MakeChangePw2Message...");
    ASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+sizeof(CHANGEPW2));

    (void )cbSendBuf;

    DecodePw( pwb->chSeed, pwb->szOldPassword );
    DecodePw( pwb->chSeed, pwb->szPassword );

    dwErr =
        GetEncryptedPasswordsForChangePassword2(
            pwb->szOldPassword,
            pwb->szPassword,
            (SAMPR_ENCRYPTED_USER_PASSWORD* )
                pwb->changepw.v2.abNewEncryptedWithOldNtOwf,
            (ENCRYPTED_NT_OWF_PASSWORD* )
                pwb->changepw.v2.abOldNtOwfEncryptedWithNewNtOwf,
            (SAMPR_ENCRYPTED_USER_PASSWORD* )
                pwb->changepw.v2.abNewEncryptedWithOldLmOwf,
            (ENCRYPTED_NT_OWF_PASSWORD* )
                pwb->changepw.v2.abOldLmOwfEncryptedWithNewNtOwf,
            &fLmPresent );

    if (dwErr == 0)
    {
        BOOL fEmptyUserName = (pwb->szUserName[ 0 ] == '\0');

        pwb->fSessionKeysObtained = FALSE;

        dwErr =
            GetChallengeResponse(
				g_dwTraceIdChap,
                pwb->szUserName,
                pwb->szPassword,
                &pwb->Luid,
                pwb->abChallenge,
                ( pwb->fConfigInfo & PPPCFG_MachineAuthentication ),
                pwb->changepw.v2.abLmResponse,
                pwb->changepw.v2.abNtResponse,
                &fbUseNtResponse,
                (PBYTE )&pwb->keyLm,
                (PBYTE )&pwb->keyUser );

        if (dwErr == 0 && fEmptyUserName)
            pwb->fSessionKeysObtained = TRUE;
    }

    EncodePw( pwb->chSeed, pwb->szOldPassword );
    EncodePw( pwb->chSeed, pwb->szPassword );

    if (dwErr != 0)
        return dwErr;

    if ( !( pwb->fConfigInfo & PPPCFG_UseLmPassword ) )
    {
        //
        // Zero out all the LM password stuff since this has been cracked
        //

        ZeroMemory( pwb->changepw.v2.abNewEncryptedWithOldLmOwf,
                    sizeof( pwb->changepw.v2.abNewEncryptedWithOldLmOwf ) );

        ZeroMemory( pwb->changepw.v2.abOldLmOwfEncryptedWithNewNtOwf,
                    sizeof( pwb->changepw.v2.abOldLmOwfEncryptedWithNewNtOwf ));

        ZeroMemory( pwb->changepw.v2.abLmResponse,
                    sizeof( pwb->changepw.v2.abLmResponse ) );

        HostToWireFormat16( CPW2F_UseNtResponse, pwb->changepw.v2.abFlags );
    }
    else
    {
        WORD wf = 0;

        if (fLmPresent)
            wf |= CPW2F_LmPasswordPresent;

        if (fbUseNtResponse)
            wf |= CPW2F_UseNtResponse;

        HostToWireFormat16( wf, pwb->changepw.v2.abFlags );
    }

    memcpy( pSendBuf->Data, &pwb->changepw.v2, sizeof(CHANGEPW2) );

    /* Fill in the header.
    */
    pSendBuf->Code = (BYTE )CHAPCODE_ChangePw2;
    pSendBuf->Id = pwb->bIdToSend;
    HostToWireFormat16(
        PPP_CONFIG_HDR_LEN + sizeof(CHANGEPW2), pSendBuf->Length );

    TRACE("MakeChangePw2Message done(0)");
    return 0;
}

DWORD
MakeChangePw3Message(
    IN  CHAPWB*     pwb,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf,
    IN  BOOL        fTimeout )

    /* Builds a ChangePw3 response packet in caller's 'pSendBuf' buffer.
    ** 'cbSendBuf' is the length of caller's buffer.  'pwb' is the address of
    ** the work buffer associated with the port.
    **
    ** Returns 0 if successful, or a non-0 error code.
    */
{
    DWORD    dwErr;
    BOOLEAN  fLmPresent;
    BYTE     fbUseNtResponse;
    BYTE     bRandomNumber[16];
    SAMPR_ENCRYPTED_USER_PASSWORD abNewEncryptedWithOldLmOwf;
    ENCRYPTED_NT_OWF_PASSWORD abOldLmOwfEncryptedWithNewNtOwf;

    TRACE("MakeChangePw3Message...");
    ASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+sizeof(CHANGEPW2));

    (void )cbSendBuf;

    DecodePw( pwb->chSeed, pwb->szOldPassword );
    DecodePw( pwb->chSeed, pwb->szPassword );

    dwErr =
        GetEncryptedPasswordsForChangePassword2(
            pwb->szOldPassword,
            pwb->szPassword,
            (SAMPR_ENCRYPTED_USER_PASSWORD* )
                pwb->changepw.v3.abEncryptedPassword,
            (ENCRYPTED_NT_OWF_PASSWORD* )
                pwb->changepw.v3.abEncryptedHash,
            &abNewEncryptedWithOldLmOwf,
            &abOldLmOwfEncryptedWithNewNtOwf,
            &fLmPresent );

    if (dwErr == 0)
    {
        BOOL fEmptyUserName = (pwb->szUserName[ 0 ] == '\0');
        A_SHA_CTX   SHAContext;
        BYTE        SHADigest[A_SHA_DIGEST_LEN];

        //
        // Get 16 byte random number and generate a new challenge if this is 
        // not a timeout
        //

        if ( !fTimeout )
        {
            if ((dwErr = (DWORD )GetChallenge( bRandomNumber )) != 0)
                return dwErr;

            if ((dwErr = (DWORD )GetChallenge( bRandomNumber+8 )) != 0)
                return dwErr;
        }
        else
        {
            CopyMemory( bRandomNumber,
                        pwb->changepw.v3.abPeerChallenge,
                        sizeof( bRandomNumber ) );
        }

        A_SHAInit( &SHAContext );

        A_SHAUpdate( &SHAContext, bRandomNumber, sizeof( bRandomNumber ) );

        A_SHAUpdate( &SHAContext, pwb->abChallenge, pwb->cbChallenge );

        A_SHAUpdate( &SHAContext, pwb->szUserName, strlen(pwb->szUserName));

        A_SHAFinal( &SHAContext, SHADigest );

        CopyMemory( pwb->abComputedChallenge, SHADigest, 8 );

        pwb->fSessionKeysObtained = FALSE;

        dwErr =
            GetChallengeResponse(
				g_dwTraceIdChap,
                pwb->szUserName,
                pwb->szPassword,
                &pwb->Luid,
                pwb->abComputedChallenge,
                ( pwb->fConfigInfo & PPPCFG_MachineAuthentication ),
                pwb->changepw.v3.abPeerChallenge,
                pwb->changepw.v3.abNTResponse,
                &fbUseNtResponse,
                (PBYTE )&pwb->keyLm,
                (PBYTE )&pwb->keyUser );

        if (dwErr == 0 && fEmptyUserName)
            pwb->fSessionKeysObtained = TRUE;
    }

    EncodePw( pwb->chSeed, pwb->szOldPassword );
    EncodePw( pwb->chSeed, pwb->szPassword );

    if (dwErr != 0)
        return dwErr;

    ZeroMemory( pwb->changepw.v3.abPeerChallenge,
                sizeof( pwb->changepw.v3.abPeerChallenge ) );

    HostToWireFormat16( 0, pwb->changepw.v3.abFlags );

    //
    // We are doing new MS-CHAP so fill the LM response field with an
    // 16 byte random number
    //

    CopyMemory( pwb->changepw.v3.abPeerChallenge,
                bRandomNumber,
                sizeof( bRandomNumber ));

    //
    // Also copy the NtResponse into pwb->abResponse since this will be
    // used by the IsSuccessPakcetValid call.
    //

    CopyMemory( pwb->abResponse + LM_RESPONSE_LENGTH,
                pwb->changepw.v3.abNTResponse,
                NT_RESPONSE_LENGTH );

    CopyMemory( pSendBuf->Data, &pwb->changepw.v3, sizeof( CHANGEPW3 ) );

    /* Fill in the header.
    */
    pSendBuf->Code = (BYTE )CHAPCODE_ChangePw3;
    pSendBuf->Id = pwb->bIdToSend;
    HostToWireFormat16(
        PPP_CONFIG_HDR_LEN + sizeof(CHANGEPW3), pSendBuf->Length );

    TRACE("MakeChangePw3Message done(0)");
    return 0;
}


DWORD
MakeResponseMessage(
    IN  CHAPWB*     pwb,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf,
    IN  BOOL        fTimeout )

    /* Builds a Response packet in caller's 'pSendBuf' buffer.  'cbSendBuf' is
    ** the length of caller's buffer.  'pwb' is the address of the work
    ** buffer associated with the port.
    **
    ** Returns 0 if successful, or a non-0 error code.
    */
{
    DWORD dwErr;
    WORD  wLength;
    BYTE* pcbResponse;
    BYTE* pbResponse;
    CHAR* pszName;
    CHAR  szUserName[ UNLEN + 1 ] = {0};

    TRACE("MakeResponseMessage...");

    (void )cbSendBuf;

    /* Fill in the response.
    */
    if ( ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT ) ||
         ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW ) )
    {
        BYTE bRandomNumber[16];
        BOOL fEmptyUserName = (pwb->szUserName[ 0 ] == '\0');

        /* Microsoft extended CHAP.
        */
        ASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+1+MSRESPONSELEN+UNLEN+1+DNLEN);
        ASSERT(MSRESPONSELEN<=255);

        DecodePw( pwb->chSeed, pwb->szPassword );

        if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW )
        {
            A_SHA_CTX   SHAContext;
            BYTE        SHADigest[A_SHA_DIGEST_LEN];

            szUserName[ 0 ] = '\0';

            //
            // If we do not have a username since we are dialing out using
            // the windows' password we get the username now by doing an
            // extra call to get challenge response
            //
/*
            if ( lstrlenA( pwb->szUserName ) == 0 && 
                 !(pwb->fConfigInfo & PPPCFG_MachineAuthentication)
               )
*/
            if ( lstrlenA( pwb->szUserName ) == 0 )
            {
                BYTE abLmResponse[ LM_RESPONSE_LENGTH ];
                BYTE abNtResponse[ NT_RESPONSE_LENGTH ];
                BYTE bUseNtResponse;
                LM_SESSION_KEY keyLm;
                USER_SESSION_KEY keyUser;

                dwErr =
                    GetChallengeResponse(
						g_dwTraceIdChap,
                        szUserName,
                        pwb->szPassword,
                        &pwb->Luid,
                        pwb->abChallenge,
                        ( pwb->fConfigInfo & PPPCFG_MachineAuthentication ),
                        abLmResponse,
                        abNtResponse,
                        &bUseNtResponse,
                        (PBYTE )&keyLm,
                        (PBYTE )&keyUser );

                if ( dwErr != NO_ERROR )
                {
                    return( dwErr );
                }
            }
            else
            {
                strncpy( szUserName, pwb->szUserName, UNLEN );
            }

            //
            // Get 16 byte random number and generate a new challenge if this
            // is not a timeout
            //

            if ( !fTimeout )
            {
                if ((dwErr = (DWORD )GetChallenge( bRandomNumber )) != 0)
                {
                    return dwErr;
                }

                if ((dwErr = (DWORD )GetChallenge( bRandomNumber+8 )) != 0)
                {
                    return dwErr;
                }
            }
            else
            {
                CopyMemory( bRandomNumber,
                            pwb->abResponse, 
                            sizeof(bRandomNumber) );
            }
            {
    
                CHAR szUserNameWoDomain[ UNLEN + DNLEN + 2 ];
                CHAR szDomain[ DNLEN + 1 ];


	            //
				//This sucks but the only hacky way of 
				//doing it without major change...  Must look at it for BC
				//
 	           ExtractUsernameAndDomain( szUserName, 
    	                                 szUserNameWoDomain,     
        	                             szDomain );			   
    
 	            A_SHAInit( &SHAContext );
	
    	        A_SHAUpdate( &SHAContext, bRandomNumber, sizeof( bRandomNumber ) );
	
    	        A_SHAUpdate( &SHAContext, pwb->abChallenge, pwb->cbChallenge );
	
    	        A_SHAUpdate( &SHAContext, szUserNameWoDomain, strlen( szUserNameWoDomain));
   
    	        A_SHAFinal( &SHAContext, SHADigest );
	
    	        CopyMemory( pwb->abComputedChallenge, SHADigest, 8 );

    	   }
        }

        pwb->fSessionKeysObtained = FALSE;

        if ( fEmptyUserName )
        {
            szUserName[ 0 ] = '\0';
        }
        else
        {
            strncpy( szUserName, pwb->szUserName, UNLEN );
        }

        dwErr = GetChallengeResponse(
				g_dwTraceIdChap,
                szUserName,
                pwb->szPassword,
                &pwb->Luid,
                ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW )
                    ? pwb->abComputedChallenge
                    : pwb->abChallenge,
                ( pwb->fConfigInfo & PPPCFG_MachineAuthentication ),
                pwb->abResponse,
                pwb->abResponse + LM_RESPONSE_LENGTH,
                pwb->abResponse + LM_RESPONSE_LENGTH + NT_RESPONSE_LENGTH,
                (PBYTE )&pwb->keyLm,
                (PBYTE )&pwb->keyUser );

        TRACE1("GetChallengeResponse=%d",dwErr);
		//
		//check to see if the domain name in the same as
		//local computer name.  If so strip it out
		//
		{
            CHAR szUserNameWoDomain[ UNLEN + DNLEN + 2 ];
            CHAR szDomain[ DNLEN + 1 ];

	        //
			//This sucks but the only hacky way of 
			//doing it without major change...  Must look at it for BC
			//
 	       ExtractUsernameAndDomain( szUserName, 
    	                             szUserNameWoDomain,     
        	                         szDomain );
			//if the domain name is local machine name
		   //dont send it across.
			if ( !lstrcmpi ( szDomain, szComputerName ) )
			{
				strncpy ( szUserName, szUserNameWoDomain, UNLEN );
			}
			//
			//Also, if use winlogon is specified
			//and we have a domain in the username, 
			//and domain in domain name then
			//strip the domain in username
			//
			if ( fEmptyUserName )	//winlogon specified
			{
				if ( szDomain[0] != '\0' &&
					 pwb->szDomain[ 0 ] != '\0'
					)	
				{
					//
					//we have a domain in username
					//and a domain passed in by the user
					//
					strncpy ( szUserName, szUserNameWoDomain, UNLEN );
				}
			}
		}
        EncodePw( pwb->chSeed, pwb->szPassword );

        if (dwErr != 0)
            return dwErr;

        if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW )
        {
            ZeroMemory( pwb->abResponse, LM_RESPONSE_LENGTH );

            CopyMemory(pwb->abResponse, bRandomNumber, sizeof(bRandomNumber));

            *(pwb->abResponse+LM_RESPONSE_LENGTH+NT_RESPONSE_LENGTH) = 0;
        }
        else
        {
            if ( !( pwb->fConfigInfo & PPPCFG_UseLmPassword ) )
            {
                //
                // Zero out all the LM password stuff since this has been 
                // cracked
                //

                ZeroMemory( pwb->abResponse, LM_RESPONSE_LENGTH );
            }
        }

        if (fEmptyUserName || pwb->fConfigInfo & PPPCFG_MachineAuthentication )
            pwb->fSessionKeysObtained = TRUE;

        pwb->cbResponse = MSRESPONSELEN;
    }
    else
    {
        /* MD5 CHAP.
        */
        MD5_CTX md5ctx;

        ASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+1+MD5RESPONSELEN+UNLEN+1+DNLEN);
        ASSERT(MD5RESPONSELEN<=255);

        DecodePw( pwb->chSeed, pwb->szPassword );

        MD5Init( &md5ctx );
        MD5Update( &md5ctx, &pwb->bIdToSend, 1 );
        MD5Update( &md5ctx, pwb->szPassword, strlen( pwb->szPassword ) );
        MD5Update( &md5ctx, pwb->abChallenge, pwb->cbChallenge );
        MD5Final( &md5ctx );

        EncodePw( pwb->chSeed, pwb->szPassword );

        pwb->cbResponse = MD5RESPONSELEN;
        memcpy( pwb->abResponse, md5ctx.digest, MD5RESPONSELEN );

        strncpy( szUserName, pwb->szUserName, UNLEN );
    }

    pcbResponse = pSendBuf->Data;
    *pcbResponse = pwb->cbResponse;
    pbResponse = pcbResponse + 1;
    memcpy( pbResponse, pwb->abResponse, *pcbResponse );

    /* Fill in the Name in domain\username format.  When domain is "", no "\"
    ** is sent (to facilitate connecting to foreign systems which use a simple
    ** string identifier).  Otherwise when username is "", the "\" is sent,
    ** i.e. "domain\".  This form will currently fail, but could be mapped to
    ** some sort of "guest" access in the future.
    */
    pszName = pbResponse + *pcbResponse;
    pszName[ 0 ] = '\0';

    if (pwb->szDomain[ 0 ] != '\0')
    {
        strcpy( pszName, pwb->szDomain );
        strcat( pszName, "\\" );
    }

    strcat( pszName, szUserName );

    /* Fill in the header.
    */
    pSendBuf->Code = (BYTE )CHAPCODE_Response;
    pSendBuf->Id = pwb->bIdToSend;

    wLength =
        (WORD )(PPP_CONFIG_HDR_LEN + 1 + *pcbResponse + strlen( pszName ));
    HostToWireFormat16( wLength, pSendBuf->Length );

    DUMPB(pSendBuf,wLength);
    return 0;
}


VOID
ChapMakeResultMessage(
    IN  CHAPWB*     pwb,
    IN  DWORD       dwError,
    IN  BOOL        fRetry,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf )

    /* Builds a result packet (Success or Failure) in caller's 'pSendBuf'
    ** buffer.  'cbSendBuf' is the length of caller's buffer.  'dwError'
    ** indicates whether a Success or Failure should be generated, and for
    ** Failure the failure code to include.  'fRetry' indicates if the client
    ** should be told he can retry.
    **
    ** Format of the message text portion of the result is:
    **
    **     "E=dddddddddd R=b C=xxxxxxxxxxxxxxxx V=v"
    **
    ** where
    **
    **     'dddddddddd' is the decimal error code (need not be 10 digits).
    **
    **     'b' is a boolean flag that is set if a retry is allowed.
    **
    **     'xxxxxxxxxxxxxxxx' is 16 hex digits representing a new challenge
    **     value.
    **
    **     'v' is our version level supported, currently 2.
    **
    ** Note: C=xxxxxxxxxxxxxxxxx not currently provided on server-side.  To
    **       provide what's needed for this routine, add the following two
    **       parameters to this routine and enable the #if 0 code.
    **
    **       IN BYTE* pNewChallenge,
    **       IN DWORD cbNewChallenge,
    */
{
    CHAR* pchMsg;
    WORD  wLength;
    CHAR* pszReplyMessage   = NULL;
    DWORD dwNumBytes;
    DWORD dwExtraBytes;
    RAS_AUTH_ATTRIBUTE* pAttribute;

    ASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+35);

    /* Fill in the header and message.  The message is only used if
    ** unsuccessful in which case it is the decimal RAS error code in ASCII.
    */
    pSendBuf->Id = pwb->bIdToSend;
    pchMsg = pSendBuf->Data;

    if (dwError == 0)
    {
        pSendBuf->Code = CHAPCODE_Success;
        if (pwb->bAlgorithm == PPP_CHAP_DIGEST_MD5)
        {
            wLength = PPP_CONFIG_HDR_LEN;
        }
        else if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT )
        {
            wLength = PPP_CONFIG_HDR_LEN;
        }
        else
        {
            wLength = PPP_CONFIG_HDR_LEN;

            //
            // Search for MS-CHAP2-Success attributes
            //

            pAttribute = RasAuthAttributeGetVendorSpecific( 
                                        311, 
                                        26, 
                                        pwb->pAttributesFromAuthenticator );

            if (   ( pAttribute != NULL )
                && ( ((BYTE*)(pAttribute->Value))[5] == 45 ) )
            {
                CopyMemory(pSendBuf->Data, (BYTE*)(pAttribute->Value) + 7, 42);
                wLength += 42;
            }
        }
    }
    else
    {
        pSendBuf->Code = CHAPCODE_Failure;

        if (pwb->bAlgorithm == PPP_CHAP_DIGEST_MD5)
        {
            wLength = PPP_CONFIG_HDR_LEN;
        }
        else
        {
            CHAR*                psz = pchMsg;

            strcpy( psz, "E=" );
            psz += 2;
            _ltoa( (long )dwError, (char* )psz, 10 );
            psz = strchr( psz, '\0' );

            strcat( psz,
                    (dwError != ERROR_PASSWD_EXPIRED && fRetry)
                        ? " R=1 " : " R=0 " );
            psz = strchr( psz, '\0' );

            //
            // Search for MS-CHAP Error attributes
            //

            pAttribute = RasAuthAttributeGetVendorSpecific( 
                                        311, 
                                        2, 
                                        pwb->pAttributesFromAuthenticator );

            if ( pAttribute != NULL )
            {
                //
                // If one was sent then use the C= portion onwards in the
                // response
                //

                CHAR    chErrorBuffer[150];
                CHAR*   pszValue;
                DWORD   cbError = (DWORD)*(((PBYTE)(pAttribute->Value))+5);

                //
                // Leave one byte for NULL terminator
                //

                if ( cbError > sizeof( chErrorBuffer ) - 1  )
                {
                    cbError = sizeof( chErrorBuffer ) - 1;
                }

                ZeroMemory( chErrorBuffer, sizeof( chErrorBuffer ) );

                CopyMemory( chErrorBuffer,
                            (CHAR *)((PBYTE)(pAttribute->Value) + 7),
                            cbError );

                if ( ( pszValue = strstr( chErrorBuffer, "C=" ) ) != NULL )
                {
                    strcat( psz, pszValue );
                }
                else
                {
                    if ( ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW ) &&
                         ( ( fRetry ) || ( dwError == ERROR_PASSWD_EXPIRED ) ) )
                    {
                        CHAR* pszHex = "0123456789ABCDEF";
                        INT   i;
                        BYTE * pNewChallenge;

                        strcat( psz, "C=" );

                        if ( !(pwb->fNewChallengeProvided ) )
                        {
                            (DWORD )GetChallenge( pwb->abChallenge );

                            (DWORD )GetChallenge( pwb->abChallenge+8 );

                            pwb->fNewChallengeProvided = TRUE;
                        }

                        psz = strchr( psz, '\0' );

                        pNewChallenge = pwb->abChallenge;

                        for (i = 0; i < pwb->cbChallenge; ++i)
                        {
                            *psz++ = pszHex[ *pNewChallenge / 16 ];
                            *psz++ = pszHex[ *pNewChallenge % 16 ];
                            ++pNewChallenge;
                        }

                        *psz = '\0';

                        strcat( psz, " V=3" );
                    }

                    if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT )
                    {
                        if (( pszValue=strstr( chErrorBuffer, "V=" ) ) != NULL )
                        {
                            strcat( psz, " " );

                            strcat( psz, pszValue );
                        }
                    }
                }
            }
            else
            {
                if ( dwError == ERROR_PASSWD_EXPIRED )
                {
                    if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT )
                    {
                        strcat( psz, " V=2" );
                    }
                    else
                    {
                        strcat( psz, " V=3" );
                    }

                    psz = strchr( psz, '\0' );
                }
            }

            wLength = (WORD)(PPP_CONFIG_HDR_LEN + strlen( pchMsg ));
        }
    }

    pszReplyMessage = RasAuthAttributeGetConcatString(
                        raatReplyMessage, pwb->pAttributesFromAuthenticator,
                        &dwNumBytes );

    if (   ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT )
        || ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW ) )
    {
        //
        // For the string "M="
        //

        dwExtraBytes = 2;
    }
    else
    {
        dwExtraBytes = 0;
    }

    if (NULL != pszReplyMessage)
    {
        if (wLength + dwNumBytes > cbSendBuf)
        {
            dwNumBytes = cbSendBuf - wLength;
        }

        if (wLength + dwNumBytes + dwExtraBytes > cbSendBuf)
        {
            if (dwNumBytes > dwExtraBytes)
            {
                //
                // For the string "M="
                //

                dwNumBytes -= dwExtraBytes;
            }
            else
            {
                //
                // If we cannot insert "M=", we will not insert the reply 
                // message.
                //

                dwNumBytes = 0;
            }
        }

        if (dwNumBytes)
        {
            if (dwExtraBytes)
            {
                CopyMemory((BYTE*)pSendBuf + wLength, "M=", dwExtraBytes);
            }

            CopyMemory((BYTE*)pSendBuf + wLength + dwExtraBytes,
                        pszReplyMessage, dwNumBytes);

            wLength += (WORD)(dwNumBytes + dwExtraBytes);
        }
    }

    LocalFree(pszReplyMessage);

    HostToWireFormat16( wLength, pSendBuf->Length );
    DUMPB(pSendBuf,wLength);
}


DWORD
ChapSMakeMessage(
    IN  CHAPWB*       pwb,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput )

    /* Server side "make message" entry point.  See RasCp interface
    ** documentation.
    */
{
    DWORD dwErr = 0;

    switch (pwb->state)
    {
        case CS_Initial:
        {
            TRACE("CS_Initial...");
            pwb->bIdToSend = (BYTE)(pwb->dwInitialPacketId++);
            pwb->bIdExpected = pwb->bIdToSend;

            if ((dwErr = MakeChallengeMessage(
                    pwb, pSendBuf, cbSendBuf )) != 0)
            {
                return dwErr;
            }

            pResult->Action = APA_SendWithTimeout;
            pwb->result.bIdExpected = pwb->bIdExpected;
            pwb->state = CS_ChallengeSent;
            break;
        }

        case CS_ChallengeSent:
        case CS_Retry:
        case CS_ChangePw:
        {
            TRACE1("CS_%s...",(pwb->state==CS_Retry)
                ?"Retry"
                :(pwb->state==CS_ChallengeSent)?"ChallengeSent":"ChangePw");

            if (!pReceiveBuf)
            {
                //
                // Ignore this event if in these states
                //

                if ( ( pInput != NULL ) && ( pInput->fAuthenticationComplete ) )
                {
                    pResult->Action = APA_NoAction;
                    break;
                }

                if (pwb->state != CS_ChallengeSent)
                {
                    ChapMakeResultMessage(
                        pwb, pwb->result.dwError, pwb->result.fRetry,
                        pSendBuf, cbSendBuf );

                    *pResult = pwb->result;
                    break;
                }

                /* Timeout waiting for a Response message.  Send a new
                ** Challenge.
                */
                pwb->state = CS_Initial;
                return ChapSMakeMessage(
                    pwb, pReceiveBuf, pSendBuf, cbSendBuf, pResult, NULL );
            }

            if ((pwb->state == CS_ChangePw
                    && pReceiveBuf->Code != CHAPCODE_ChangePw1
                    && pReceiveBuf->Code != CHAPCODE_ChangePw2
                    && pReceiveBuf->Code != CHAPCODE_ChangePw3)
                || (pwb->state != CS_ChangePw
                    && pReceiveBuf->Code != CHAPCODE_Response)
                || pReceiveBuf->Id != pwb->bIdExpected)
            {
                /* Not the packet we're looking for, wrong code or sequence
                ** number.  Silently discard it.
                */
                TRACE2("Got ID %d when expecting %d",
                        pReceiveBuf->Id,pwb->bIdExpected);
                pResult->Action = APA_NoAction;
                break;
            }

            if (pwb->state == CS_ChangePw)
            {
                if (pReceiveBuf->Code == CHAPCODE_ChangePw1)
                {
                    if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW )
                    {
                        return( ERROR_AUTHENTICATION_FAILURE );
                    }

                    /* Extract encrypted passwords and options from received
                    ** packet.
                    */
                    if ((dwErr = GetInfoFromChangePw1(
                            pReceiveBuf, &pwb->changepw.v1 )) != 0)
                    {
                        /* The packet is corrupt.  Silently discard it.
                        */
                        TRACE("Corrupt packet");
                        pResult->Action = APA_NoAction;
                        break;
                    }

                    /* Change the user's password.
                    */
                    {
                        WORD wPwLen =
                            WireToHostFormat16(
                                pwb->changepw.v1.abPasswordLength );
                        WORD wFlags =
                            WireToHostFormat16( pwb->changepw.v1.abFlags )
                                & CPW1F_UseNtResponse;

                        if ( MakeChangePasswordV1RequestAttributes(
                                pwb,
                                pReceiveBuf->Id,
                                pwb->szUserName,
                                pwb->abChallenge,
                                (PENCRYPTED_LM_OWF_PASSWORD )
                                    pwb->changepw.v1.abEncryptedLmOwfOldPw,
                                (PENCRYPTED_LM_OWF_PASSWORD )
                                    pwb->changepw.v1.abEncryptedLmOwfNewPw,
                                (PENCRYPTED_NT_OWF_PASSWORD )
                                    pwb->changepw.v1.abEncryptedNtOwfOldPw,
                                (PENCRYPTED_NT_OWF_PASSWORD )
                                    pwb->changepw.v1.abEncryptedNtOwfNewPw,
                                wPwLen, wFlags,
                                pwb->cbChallenge,
                                pwb->abChallenge ) != NO_ERROR )
                        {
                            dwErr = pwb->result.dwError =
                                ERROR_CHANGING_PASSWORD;
                        }

                        *(pwb->abResponse + LM_RESPONSE_LENGTH +
                              NT_RESPONSE_LENGTH) = TRUE;
                    }
                }
                else if ( pReceiveBuf->Code == CHAPCODE_ChangePw2 )
                {
                    /* Extract encrypted passwords and options from received
                    ** packet.
                    */
                    if ((dwErr = GetInfoFromChangePw2(
                            pReceiveBuf, &pwb->changepw.v2,
                            pwb->abResponse )) != 0)
                    {
                        /* The packet is corrupt.  Silently discard it.
                        */
                        TRACE("Corrupt packet");
                        pResult->Action = APA_NoAction;
                        break;
                    }

                    if ( dwErr == NO_ERROR )
                    {
                        /* Change the user's password.
                        */

                        if ( MakeChangePasswordV2RequestAttributes(
                            pwb,
                            pReceiveBuf->Id,
                            pwb->szUserName,
                            (SAMPR_ENCRYPTED_USER_PASSWORD* )
                               pwb->changepw.v2.abNewEncryptedWithOldNtOwf,
                            (ENCRYPTED_NT_OWF_PASSWORD* )
                               pwb->changepw.v2.abOldNtOwfEncryptedWithNewNtOwf,
                            (SAMPR_ENCRYPTED_USER_PASSWORD* )
                               pwb->changepw.v2.abNewEncryptedWithOldLmOwf,
                            (ENCRYPTED_NT_OWF_PASSWORD* )
                               pwb->changepw.v2.abOldLmOwfEncryptedWithNewNtOwf,
                            pwb->cbChallenge,
                            pwb->abChallenge,
                            pwb->abResponse,
                            WireToHostFormat16( pwb->changepw.v2.abFlags )
                         ) != NO_ERROR )
                        {
                            dwErr = pwb->result.dwError =
                                                    ERROR_CHANGING_PASSWORD;
                        }
                    }
                }
                else if ( pReceiveBuf->Code == CHAPCODE_ChangePw3 )
                {
                    /* Extract encrypted passwords and options from received
                    ** packet.
                    */
                    if ((dwErr = GetInfoFromChangePw3(
                                pReceiveBuf, &pwb->changepw.v3,
                                pwb->abResponse )) != 0)
                    {
                        /* The packet is corrupt.  Silently discard it.
                        */
                        TRACE("Corrupt packet");
                        pResult->Action = APA_NoAction;
                        break;
                    }

                    /* Change the user's password.
                    */

                    if ( MakeChangePasswordV3RequestAttributes(
                            pwb,
                            pReceiveBuf->Id,
                            pwb->szUserName,
                            &pwb->changepw.v3,
                            pwb->cbChallenge,
                            pwb->abChallenge
                         ) != NO_ERROR )
                    {
                        dwErr = pwb->result.dwError = ERROR_CHANGING_PASSWORD;
                    }
                }
                else
                {
                    /* The packet is corrupt.  Silently discard it.
                    */
                    TRACE("Corrupt packet");
                    pResult->Action = APA_NoAction;
                    break;
                }

                if ( dwErr == 0 )
                {
                    pResult->pUserAttributes = pwb->pUserAttributes;
                    pResult->Action          = APA_Authenticate;
                    pwb->state        = CS_WaitForAuthenticationToComplete1;
                }
                else
                {
                    pwb->result.bIdExpected = pwb->bIdToSend = pwb->bIdExpected;
                    pwb->result.Action = APA_SendAndDone;
                    pwb->result.fRetry = FALSE;
                    pwb->state = CS_Done;
                }

                break;
            }
            else
            {
                /* Extract user's credentials from received packet.
                */
                if ((dwErr = GetCredentialsFromResponse(
                        pReceiveBuf, pwb->bAlgorithm,
                        pwb->szUserName, pwb->abResponse )) != 0)
                {
                    if (dwErr == ERRORBADPACKET)
                    {
                        /* The packet is corrupt.  Silently discard it.
                        */
                        TRACE("Corrupt packet");
                        pResult->Action = APA_NoAction;
                        break;
                    }
                }

                if ( ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT ) ||
                     ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW ) )
                {
                    /* Update to the implied challenge if processing a retry.
                    */
                    if ( ( pwb->state == CS_Retry ) &&
                         ( !pwb->fNewChallengeProvided ) )
                        pwb->abChallenge[ 0 ] += 23;

                    /* Check user's credentials with the system, recording the
                    ** outcome in the work buffer in case the result packet
                    ** must be regenerated later.
                    */
                    if ((dwErr = MakeAuthenticationRequestAttributes(
                            pwb,
                            TRUE,
                            pwb->bAlgorithm,
                            pwb->szUserName,
                            pwb->abChallenge,
                            pwb->cbChallenge,
                            pwb->abResponse,
                            MSRESPONSELEN,
                            pReceiveBuf->Id )) != 0)
                    {
                        return dwErr;
                    }
                }
                else
                {
                    /* Check user's credentials with the system, recording the
                    ** outcome in the work buffer in case the result packet
                    ** must be regenerated later.
                    */
                    if ((dwErr = MakeAuthenticationRequestAttributes(
                            pwb,
                            FALSE,
                            pwb->bAlgorithm,
                            pwb->szUserName,
                            pwb->abChallenge,
                            pwb->cbChallenge,
                            pwb->abResponse,
                            MD5RESPONSELEN,
                            pReceiveBuf->Id )) != 0)
                    {
                        return dwErr;
                    }
                }

                strcpy( pwb->result.szUserName, pwb->szUserName );

                pResult->pUserAttributes = pwb->pUserAttributes;
                pResult->Action          = APA_Authenticate;
                pwb->state = CS_WaitForAuthenticationToComplete2;
            }

            break;
        }

        case CS_WaitForAuthenticationToComplete1:
        case CS_WaitForAuthenticationToComplete2:
        {
            if ( pInput != NULL )
            {
                if ( pInput->fAuthenticationComplete )
                {
                    strcpy( pResult->szUserName, pwb->result.szUserName );

                    if ( pInput->dwAuthError != NO_ERROR )
                    {
                        return( pInput->dwAuthError );
                    }
                }
                else
                {
                    pResult->Action = APA_NoAction;
                    break;
                }

                pwb->pAttributesFromAuthenticator = 
                                    pInput->pAttributesFromAuthenticator;

                if ( pInput->dwAuthResultCode != NO_ERROR )
                {
                    if ( ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT ) ||
                         ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW ) )
                    {
                        dwErr = GetErrorCodeFromAttributes( pwb );

                        if ( dwErr != NO_ERROR )
                        {
                            return( dwErr );
                        }
                    }
                    else
                    {
                        pwb->result.dwError = pInput->dwAuthResultCode;
                    }
                }
                else
                {
                    pwb->result.dwError = NO_ERROR;
                }
            }
            else
            {
                pResult->Action = APA_NoAction;
                break;
            }
            
            if ( pwb->state == CS_WaitForAuthenticationToComplete1 )
            {
                pwb->result.bIdExpected = pwb->bIdToSend = pwb->bIdExpected;
                pwb->result.Action      = APA_SendAndDone;
                pwb->result.fRetry      = FALSE;
                pwb->state              = CS_Done;
            }
            else
            {
                pwb->bIdToSend = pwb->bIdExpected;

                TRACE2("Result=%d,Tries=%d",pwb->result.dwError,
                        pwb->dwTriesLeft);

                if (pwb->result.dwError == ERROR_PASSWD_EXPIRED)
                {
                    pwb->fNewChallengeProvided = FALSE;
                    pwb->dwTriesLeft        = 0;
                    ++pwb->bIdExpected;
                    pwb->result.bIdExpected = pwb->bIdExpected;
                    pwb->result.Action      = APA_SendWithTimeout2;
                    pwb->result.fRetry      = FALSE;
                    pwb->state              = CS_ChangePw;
                }
                else if (pwb->bAlgorithm == PPP_CHAP_DIGEST_MD5
                         || pwb->result.dwError != ERROR_AUTHENTICATION_FAILURE
                         || pwb->dwTriesLeft == 0)
                {
                    /* Passed or failed in a non-retry-able manner.
                    */
                    pwb->result.Action  = APA_SendAndDone;
                    pwb->result.fRetry  = FALSE;
                    pwb->state          = CS_Done;
                }
                else
                {
                    /* Retry-able failure.
                    */
                    pwb->fNewChallengeProvided = FALSE;
                    --pwb->dwTriesLeft;
                    ++pwb->bIdExpected;
                    pwb->result.bIdExpected = pwb->bIdExpected;
                    pwb->result.Action      = APA_SendWithTimeout2;
                    pwb->result.fRetry      = TRUE;
                    pwb->state              = CS_Retry;
                }
            }
        }

        /* ...fall thru...
        */

        case CS_Done:
        {
            TRACE("CS_Done...");

            //
            // If we received a packet or the back-end authenticator completed
            //

            if ( ( pReceiveBuf != NULL ) ||
                 ( ( pInput != NULL ) && ( pInput->fAuthenticationComplete ) ) )
            {
                /* Build the Success or Failure packet.  The same packet sent in
                ** response to the first Response message with this ID is sent
                ** regardless of any change in credentials (per CHAP spec).
                */
                ChapMakeResultMessage(
                    pwb, pwb->result.dwError,
                    pwb->result.fRetry, pSendBuf, cbSendBuf );

                *pResult = pwb->result;

                CopyMemory( pResult->abResponse,
                            pwb->abResponse+LM_RESPONSE_LENGTH, 
                            NT_RESPONSE_LENGTH );

                CopyMemory( pResult->abChallenge,
                            pwb->abChallenge, 
                            sizeof( pResult->abChallenge ) );

                break;
            }
            else
            {
                pResult->Action = APA_NoAction;

                break;
            }
        }
    }

    return 0;
}


DWORD
StoreCredentials(
    OUT CHAPWB*      pwb,
    IN  PPPAP_INPUT* pInput )

    /* Transfer credentials from 'pInput' format to 'pwb' format.
    **
    ** Returns 0 if successful, false otherwise.
    */
{
    /* Validate credential lengths.  The credential strings will never be
    ** NULL, but may be "".
    */
    if (strlen( pInput->pszUserName ) > UNLEN
        || strlen( pInput->pszDomain ) > DNLEN
        || strlen( pInput->pszPassword ) > PWLEN
        || strlen( pInput->pszOldPassword ) > PWLEN)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If are doing MS-CHAP V2, then we need to parse the username field if no
    // domain was supplied. 
    // Bug# 310113 RAS: "domain\username" syntax fails to authenticate
    //

    if ( pwb->bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW )
    {
        //
        // If there is no domain, then parse the username to see if it contains the 
        // domain field. 
        //
    
        if ( strlen( pInput->pszDomain ) == 0 )
        {
            if ( ExtractUsernameAndDomain( pInput->pszUserName, 
                                           pwb->szUserName,     
                                           pwb->szDomain ) != NO_ERROR )
            {   
                strcpy( pwb->szUserName, pInput->pszUserName );
                strcpy( pwb->szDomain,   pInput->pszDomain );
            }
        }
        else
        {
            strcpy( pwb->szUserName, pInput->pszUserName );
            strcpy( pwb->szDomain,   pInput->pszDomain );
        }
    }
    else
    {
        strcpy( pwb->szUserName, pInput->pszUserName );
        strcpy( pwb->szDomain,   pInput->pszDomain );
    }

    strcpy( pwb->szPassword, pInput->pszPassword );
    strcpy( pwb->szOldPassword, pInput->pszOldPassword );
    EncodePw( pwb->chSeed, pwb->szPassword );
    EncodePw( pwb->chSeed, pwb->szOldPassword );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\ntauth.c ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** ntauth.c
** Remote Access PPP Challenge Handshake Authentication Protocol
** NT Authentication routines
**
** These routines are specific to the NT platform.
**
** 11/05/93 Steve Cobb (from MikeSa's AMB authentication code)
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>

#include <crypt.h>
#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <string.h>
#include <stdlib.h>

#include <rasman.h>
#include <rasppp.h>
#include <pppcp.h>
#include <rtutils.h>
#include <rasauth.h>
#define INCL_CLSA
#define INCL_RASAUTHATTRIBUTES
#define INCL_HOSTWIRE
#define INCL_MISC
#include <ppputil.h>
#include "sha.h"
#include "raschap.h"

//**
//
// Call:        MakeChangePasswordV1RequestAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
MakeChangePasswordV1RequestAttributes(
    IN  CHAPWB*                     pwb,
    IN  BYTE                        bId,
    IN  PCHAR                       pchIdentity,
    IN  PBYTE                       Challenge,
    IN  PENCRYPTED_LM_OWF_PASSWORD  pEncryptedLmOwfOldPassword,
    IN  PENCRYPTED_LM_OWF_PASSWORD  pEncryptedLmOwfNewPassword,
    IN  PENCRYPTED_NT_OWF_PASSWORD  pEncryptedNtOwfOldPassword,
    IN  PENCRYPTED_NT_OWF_PASSWORD  pEncryptedNtOwfNewPassword,
    IN  WORD                        LenPassword,
    IN  WORD                        wFlags,
    IN  DWORD                       cbChallenge, 
    IN  BYTE *                      pbChallenge
)
{
    DWORD                   dwRetCode;
    BYTE                    MsChapChangePw1[72+6];
    BYTE                    MsChapChallenge[MAXCHALLENGELEN+6];

    if ( pwb->pUserAttributes != NULL )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;
    }

    //
    // Allocate the appropriate amount
    //

    if ( ( pwb->pUserAttributes = RasAuthAttributeCreate( 3 ) ) == NULL )
    {
        return( GetLastError() );
    }

    dwRetCode = RasAuthAttributeInsert( 0,
                                        pwb->pUserAttributes,
                                        raatUserName,
                                        FALSE,
                                        strlen( pchIdentity ),
                                        pchIdentity  );

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    //
    // Build vendor specific attribute for MS-CHAP challenge
    //

    HostToWireFormat32( 311, MsChapChallenge );         // Vendor Id
    MsChapChallenge[4] = 11;                            // Vendor Type
    MsChapChallenge[5] = 2+(BYTE)cbChallenge;           // Vendor Length

    CopyMemory( MsChapChallenge+6, pbChallenge, cbChallenge );

    dwRetCode = RasAuthAttributeInsert( 1,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        cbChallenge+6,
                                        MsChapChallenge);

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    //
    // Insert change password attribute
    //

    HostToWireFormat32( 311, MsChapChangePw1 );     // Vendor Id
    MsChapChangePw1[4] = 3;                         // Vendor Type
    MsChapChangePw1[5] = 72;                        // Vendor Length
    MsChapChangePw1[6] = 5;                         // Code
    MsChapChangePw1[7] = bId;                       // Identifier

    CopyMemory( MsChapChangePw1+8, 
                pEncryptedLmOwfOldPassword,
                16 );

    CopyMemory( MsChapChangePw1+8+16, 
                pEncryptedLmOwfNewPassword,
                16 );

    CopyMemory( MsChapChangePw1+8+16+16, 
                pEncryptedNtOwfOldPassword,
                16 );

    CopyMemory( MsChapChangePw1+8+16+16+16, 
                pEncryptedNtOwfNewPassword,
                16 );

    HostToWireFormat16( LenPassword, MsChapChangePw1+8+16+16+16+16 );

    HostToWireFormat16( wFlags, MsChapChangePw1+8+16+16+16+16+2 );

    //
    // Build vendor specific attribute for MS-CHAP change password 1
    //

    dwRetCode = RasAuthAttributeInsert( 2,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        72+4,
                                        MsChapChangePw1);

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    return( dwRetCode );
}

//**
//
// Call:        MakeChangePasswordV2RequestAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
MakeChangePasswordV2RequestAttributes( 
    IN  CHAPWB*                         pwb,
    IN  BYTE                            bId,
    IN  CHAR*                           pchIdentity,
    IN  SAMPR_ENCRYPTED_USER_PASSWORD*  pNewEncryptedWithOldNtOwf,
    IN  ENCRYPTED_NT_OWF_PASSWORD*      pOldNtOwfEncryptedWithNewNtOwf,
    IN  SAMPR_ENCRYPTED_USER_PASSWORD*  pNewEncryptedWithOldLmOwf,
    IN  ENCRYPTED_NT_OWF_PASSWORD*      pOldLmOwfEncryptedWithNewNtOwf,
    IN  DWORD                           cbChallenge, 
    IN  BYTE *                          pbChallenge, 
    IN  BYTE *                          pbResponse,
    IN  WORD                            wFlags
)
{
    DWORD                   dwRetCode;
    BYTE                    MsChapChallenge[MAXCHALLENGELEN+6];
    BYTE                    MsChapChangePw2[86+4];
    BYTE                    NtPassword1[250+4];
    BYTE                    NtPassword2[250+4];
    BYTE                    NtPassword3[34+4];
    BYTE                    LmPassword1[250+4];
    BYTE                    LmPassword2[250+4];
    BYTE                    LmPassword3[34+4];

    if ( pwb->pUserAttributes != NULL )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;
    }

    //
    // Allocate the appropriate amount
    //

    pwb->pUserAttributes = RasAuthAttributeCreate( 9 );

    if ( pwb->pUserAttributes == NULL )
    {
        return( GetLastError() );
    }

    dwRetCode = RasAuthAttributeInsert( 0,
                                        pwb->pUserAttributes,
                                        raatUserName,
                                        FALSE,
                                        strlen( pchIdentity ),
                                        pchIdentity );

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    //
    // Build vendor specific attribute for MS-CHAP challenge
    //

    HostToWireFormat32( 311, MsChapChallenge );     // Vendor Id
    MsChapChallenge[4] = 11;                        // Vendor Type
    MsChapChallenge[5] = 2+(BYTE)cbChallenge;       // Vendor Length

    CopyMemory( MsChapChallenge+6, pbChallenge, cbChallenge );

    dwRetCode = RasAuthAttributeInsert( 1,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        cbChallenge+6,
                                        MsChapChallenge);

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    //
    // Insert change password attribute
    //

    HostToWireFormat32( 311, MsChapChangePw2 );     // Vendor Id
    MsChapChangePw2[4] = 4;                         // Vendor Type
    MsChapChangePw2[5] = 86;                        // Vendor Length
    MsChapChangePw2[6] = 6;                         // Code
    MsChapChangePw2[7] = bId;                       // Identifier

    CopyMemory( MsChapChangePw2+8,
                pOldNtOwfEncryptedWithNewNtOwf,
                16 );

    CopyMemory( MsChapChangePw2+8+16,
                pOldLmOwfEncryptedWithNewNtOwf,
                16 );

    CopyMemory( MsChapChangePw2+8+16+16, pbResponse, 24+24 );

    HostToWireFormat16( (WORD)wFlags, MsChapChangePw2+8+16+16+24+24 );

    //
    // Build vendor specific attribute for MS-CHAP change password 2
    //

    dwRetCode = RasAuthAttributeInsert( 2,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        86+4,
                                        MsChapChangePw2);

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    //
    // Insert the new password attributes
    //

    HostToWireFormat32( 311, NtPassword1 );         // Vendor Id
    NtPassword1[4] = 6;                             // Vendor Type
    NtPassword1[5] = 249;                           // Vendor Length
    NtPassword1[6] = 6;                             // Code
    NtPassword1[7] = bId;                           // Identifier
    HostToWireFormat16( (WORD)1, NtPassword1+8 );   // Sequence number

    CopyMemory( NtPassword1+10, (PBYTE)pNewEncryptedWithOldNtOwf, 243 );

    dwRetCode = RasAuthAttributeInsert( 3,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        249+4,
                                        NtPassword1);

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    HostToWireFormat32( 311, NtPassword2 );         // Vendor Id
    NtPassword2[4] = 6;                             // Vendor Type
    NtPassword2[5] = 249;                           // Vendor Length
    NtPassword2[6] = 6;                             // Code
    NtPassword2[7] = bId;                           // Identifier
    HostToWireFormat16( (WORD)2, NtPassword2+8 );   // Sequence number

    CopyMemory( NtPassword2+10, 
                ((PBYTE)pNewEncryptedWithOldNtOwf)+243,  
                243 );

    dwRetCode = RasAuthAttributeInsert( 4,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        249+4,
                                        NtPassword2 );

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    HostToWireFormat32( 311, NtPassword3 );         // Vendor Id
    NtPassword3[4] = 6;                             // Vendor Type
    NtPassword3[5] = 36;                            // Vendor Length
    NtPassword3[6] = 6;                             // Code
    NtPassword3[7] = bId;                           // Identifier
    HostToWireFormat16( (WORD)3, NtPassword3+8 );   // Sequence number

    CopyMemory( NtPassword3+10,
                ((PBYTE)pNewEncryptedWithOldNtOwf)+486,
                30 );

    dwRetCode = RasAuthAttributeInsert( 5,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        36+4,
                                        NtPassword3 );


    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    HostToWireFormat32( 311, LmPassword1 );         // Vendor Id
    LmPassword1[4] = 5;                             // Vendor Type
    LmPassword1[5] = 249;                           // Vendor Length
    LmPassword1[6] = 6;                             // Code
    LmPassword1[7] = bId;                           // Identifier
    HostToWireFormat16( (WORD)1, LmPassword1+8 );   // Sequence number

    CopyMemory( LmPassword1+10, pNewEncryptedWithOldLmOwf, 243 );

    dwRetCode = RasAuthAttributeInsert( 6,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        249+4,
                                        LmPassword1);

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    HostToWireFormat32( 311, LmPassword2 );         // Vendor Id
    LmPassword2[4] = 5;                             // Vendor Type
    LmPassword2[5] = 249;                           // Vendor Length
    LmPassword2[6] = 6;                             // Code
    LmPassword2[7] = bId;                           // Identifier
    HostToWireFormat16( (WORD)2, LmPassword2+8 );   // Sequence number

    CopyMemory( LmPassword2+10, 
                ((PBYTE)pNewEncryptedWithOldLmOwf)+243, 
                243 );

    dwRetCode = RasAuthAttributeInsert( 7,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        249+4,
                                        LmPassword2 );

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    HostToWireFormat32( 311, LmPassword3 );         // Vendor Id
    LmPassword3[4] = 5;                             // Vendor Type
    LmPassword3[5] = 36;                            // Vendor Length
    LmPassword3[6] = 6;                             // Code
    LmPassword3[7] = bId;                           // Identifier
    HostToWireFormat16( (WORD)3, LmPassword3+8 );   // Sequence number

    CopyMemory( LmPassword3+10,
                ((PBYTE)pNewEncryptedWithOldLmOwf)+486,
                30 );

    dwRetCode = RasAuthAttributeInsert( 8,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        36+4,
                                        LmPassword3 );

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    return( dwRetCode );
}

//**
//
// Call:        MakeChangePasswordV3RequestAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
MakeChangePasswordV3RequestAttributes( 
    IN  CHAPWB*                         pwb,
    IN  BYTE                            bId,
    IN  CHAR*                           pchIdentity,
    IN  CHANGEPW3*                      pchangepw3,
    IN  DWORD                           cbChallenge, 
    IN  BYTE *                          pbChallenge
)
{
    DWORD                   dwRetCode;
    BYTE                    MsChapChallenge[MAXCHALLENGELEN+6];
    BYTE                    MsChapChangePw3[70+4];
    BYTE                    NtPassword1[250+4];
    BYTE                    NtPassword2[250+4];
    BYTE                    NtPassword3[34+4];

    if ( pwb->pUserAttributes != NULL )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;
    }

    //
    // Allocate the appropriate amount
    //

    pwb->pUserAttributes = RasAuthAttributeCreate( 6 );

    if ( pwb->pUserAttributes == NULL )
    {
        return( GetLastError() );
    }

    dwRetCode = RasAuthAttributeInsert( 0,
                                        pwb->pUserAttributes,
                                        raatUserName,
                                        FALSE,
                                        strlen( pchIdentity ),
                                        pchIdentity );

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    //
    // Build vendor specific attribute for MS-CHAP challenge
    //

    HostToWireFormat32( 311, MsChapChallenge );     // Vendor Id
    MsChapChallenge[4] = 11;                        // Vendor Type
    MsChapChallenge[5] = 2+(BYTE)cbChallenge;       // Vendor Length

    CopyMemory( MsChapChallenge+6, pbChallenge, cbChallenge );

    dwRetCode = RasAuthAttributeInsert( 1,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        cbChallenge+6,
                                        MsChapChallenge);

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    //
    // Insert change password attribute
    //

    HostToWireFormat32( 311, MsChapChangePw3 );     // Vendor Id
    MsChapChangePw3[4] = 27;                        // Vendor Type
    MsChapChangePw3[5] = 70;                        // Vendor Length
    MsChapChangePw3[6] = 7;                         // Code
    MsChapChangePw3[7] = bId;                       // Identifier

    CopyMemory( MsChapChangePw3+8, pchangepw3->abEncryptedHash, 16 );
    CopyMemory( MsChapChangePw3+8+16, pchangepw3->abPeerChallenge, 24 );
    CopyMemory( MsChapChangePw3+8+16+24, pchangepw3->abNTResponse, 24 );

    HostToWireFormat16( (WORD)0, MsChapChangePw3+8+16+24+24 );

    //
    // Build vendor specific attribute for MS-CHAP2-PW
    //

    dwRetCode = RasAuthAttributeInsert( 2,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        70+4,
                                        MsChapChangePw3);

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    //
    // Insert the new password attributes
    //

    HostToWireFormat32( 311, NtPassword1 );         // Vendor Id
    NtPassword1[4] = 6;                             // Vendor Type
    NtPassword1[5] = 249;                           // Vendor Length
    NtPassword1[6] = 6;                             // Code
    NtPassword1[7] = bId;                           // Identifier
    HostToWireFormat16( (WORD)1, NtPassword1+8 );   // Sequence number

    CopyMemory( NtPassword1+10, pchangepw3->abEncryptedPassword, 243 );

    dwRetCode = RasAuthAttributeInsert( 3,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        249+4,
                                        NtPassword1);

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    HostToWireFormat32( 311, NtPassword2 );         // Vendor Id
    NtPassword2[4] = 6;                             // Vendor Type
    NtPassword2[5] = 249;                           // Vendor Length
    NtPassword2[6] = 6;                             // Code
    NtPassword2[7] = bId;                           // Identifier
    HostToWireFormat16( (WORD)2, NtPassword2+8 );   // Sequence number

    CopyMemory( NtPassword2+10, 
                pchangepw3->abEncryptedPassword+243,  
                243 );

    dwRetCode = RasAuthAttributeInsert( 4,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        249+4,
                                        NtPassword2 );

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    HostToWireFormat32( 311, NtPassword3 );         // Vendor Id
    NtPassword3[4] = 6;                             // Vendor Type
    NtPassword3[5] = 36;                            // Vendor Length
    NtPassword3[6] = 6;                             // Code
    NtPassword3[7] = bId;                           // Identifier
    HostToWireFormat16( (WORD)3, NtPassword3+8 );   // Sequence number

    CopyMemory( NtPassword3+10,
                pchangepw3->abEncryptedPassword+486,
                30 );

    dwRetCode = RasAuthAttributeInsert( 5,
                                        pwb->pUserAttributes,
                                        raatVendorSpecific,
                                        FALSE,
                                        36+4,
                                        NtPassword3 );


    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    return( dwRetCode );
}

//**
//
// Call:        MakeAuthenticationRequestAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD 
MakeAuthenticationRequestAttributes( 
    IN CHAPWB *             pwb,
    IN BOOL                 fMSChap,
    IN BYTE                 bAlgorithm,
    IN CHAR*                szUserName, 
    IN BYTE*                pbChallenge, 
    IN DWORD                cbChallenge, 
    IN BYTE*                pbResponse,
    IN DWORD                cbResponse,
    IN BYTE                 bId
)
{
    DWORD                dwRetCode;
    BYTE                 abResponse[MD5RESPONSELEN+1];

    if ( pwb->pUserAttributes != NULL )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;
    }

    //
    // Allocate the appropriate amount
    //

    if ( ( pwb->pUserAttributes = RasAuthAttributeCreate( 3 ) ) == NULL )
    {
        return( GetLastError() );
    }

    dwRetCode = RasAuthAttributeInsert( 0,
                                        pwb->pUserAttributes,
                                        raatUserName,
                                        FALSE,
                                        strlen( szUserName ),
                                        szUserName  );

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    if ( fMSChap )
    {
        BYTE MsChapChallenge[MAXCHALLENGELEN+6];

        HostToWireFormat32( 311, MsChapChallenge );     // Vendor Id
        MsChapChallenge[4] = 11;                        // Vendor Type
        MsChapChallenge[5] = 2+(BYTE)cbChallenge;       // Vendor Length

        CopyMemory( MsChapChallenge+6, pbChallenge, cbChallenge );

        //
        // Build vendor specific attribute for MS-CHAP challenge
        //

        dwRetCode = RasAuthAttributeInsert( 1,
                                            pwb->pUserAttributes,
                                            raatVendorSpecific,
                                            FALSE,
                                            cbChallenge+6,
                                            MsChapChallenge );
    }
    else
    {
        dwRetCode = RasAuthAttributeInsert( 1,
                                            pwb->pUserAttributes,
                                            raatMD5CHAPChallenge,
                                            FALSE,
                                            cbChallenge,
                                            pbChallenge );
    }

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    if ( fMSChap && ( bAlgorithm == PPP_CHAP_DIGEST_MSEXT ) )
    {
        BYTE MsChapResponse[56];

        HostToWireFormat32( 311, MsChapResponse );      // Vendor Id
        MsChapResponse[4] = 1;                          // Vendor Type
        MsChapResponse[5] = (BYTE)52;                   // Vendor Length
        MsChapResponse[6] = bId;                        // Ident
        MsChapResponse[7] = pbResponse[cbResponse-1];   // Flags

        CopyMemory( MsChapResponse+8, pbResponse, cbResponse-1 );

        dwRetCode = RasAuthAttributeInsert( 2,
                                            pwb->pUserAttributes,
                                            raatVendorSpecific,
                                            FALSE,
                                            56,
                                            MsChapResponse);
    }
    else if ( fMSChap && ( bAlgorithm == PPP_CHAP_DIGEST_MSEXT_NEW ) )
    {
        BYTE MsChap2Response[56];

        HostToWireFormat32( 311, MsChap2Response );     // Vendor Id
        MsChap2Response[4] = 25;                        // Vendor Type
        MsChap2Response[5] = (BYTE)52;                  // Vendor Length
        MsChap2Response[6] = bId;                       // Ident
        MsChap2Response[7] = 0;                         // Flags

        CopyMemory( MsChap2Response+8, pbResponse, cbResponse-1 );

        dwRetCode = RasAuthAttributeInsert( 2,
                                            pwb->pUserAttributes,
                                            raatVendorSpecific,
                                            FALSE,
                                            56,
                                            MsChap2Response);
    }
    else
    {
        abResponse[0] = bId;

        CopyMemory( abResponse+1, pbResponse, cbResponse );

        dwRetCode = RasAuthAttributeInsert( 2,
                                            pwb->pUserAttributes,
                                            raatMD5CHAPPassword,
                                            FALSE,
                                            cbResponse+1,  
                                            abResponse );
    }

    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pwb->pUserAttributes );

        pwb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    return( dwRetCode );
}

//**
//
// Call:        GetErrorCodeFromAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will extract the error code returned from the authentication
//              provider and insert it into the reponse sent to the client
//
DWORD
GetErrorCodeFromAttributes(
    IN  CHAPWB* pwb
)
{
    RAS_AUTH_ATTRIBUTE * pAttribute;
    RAS_AUTH_ATTRIBUTE * pAttributes = pwb->pAttributesFromAuthenticator;
    DWORD                dwRetCode = NO_ERROR;

    //
    // Search for MS-CHAP Error attributes
    //

    pAttribute = RasAuthAttributeGetVendorSpecific( 311, 2, pAttributes );

    if ( pAttribute != NULL )
    {
        CHAR    chErrorBuffer[150];
        CHAR*   pszValue;
        DWORD   cbError = (DWORD)*(((PBYTE)(pAttribute->Value))+5);
                
        //
        // Leave one byte for NULL terminator
        //

        if ( cbError > sizeof( chErrorBuffer ) - 1 )
        {
            cbError = sizeof( chErrorBuffer ) - 1;
        }

        ZeroMemory( chErrorBuffer, sizeof( chErrorBuffer ) );

        CopyMemory( chErrorBuffer, 
                    (CHAR *)((PBYTE)(pAttribute->Value) + 7),
                    cbError );

        pszValue = strstr( chErrorBuffer, "E=" );

        if ( pszValue )
        {
            pwb->result.dwError = (DWORD )atol( pszValue + 2 );
        }

        pszValue = strstr( chErrorBuffer, "R=1" );

        if ( pszValue )
        {
            pwb->dwTriesLeft = 1;
        }
    }
    else
    {
        //
        // If we did not get an error code attribute back then assume an
        // access denied
        //

        TRACE("No error code attribute returned, assuming access denied");

        pwb->result.dwError = ERROR_AUTHENTICATION_FAILURE;
    }

    return( dwRetCode );
}

//**
//
// Call:        GetEncryptedPasswordsForChangePassword2
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
GetEncryptedPasswordsForChangePassword2(
    IN  CHAR*                          pszOldPassword,
    IN  CHAR*                          pszNewPassword,
    OUT SAMPR_ENCRYPTED_USER_PASSWORD* pNewEncryptedWithOldNtOwf,
    OUT ENCRYPTED_NT_OWF_PASSWORD*     pOldNtOwfEncryptedWithNewNtOwf,
    OUT SAMPR_ENCRYPTED_USER_PASSWORD* pNewEncryptedWithOldLmOwf,
    OUT ENCRYPTED_NT_OWF_PASSWORD*     pOldLmOwfEncryptedWithNewNtOwf,
    OUT BOOLEAN*                       pfLmPresent )
{
    DWORD          dwErr;
    BOOL           fLmPresent;
    UNICODE_STRING uniOldPassword;
    UNICODE_STRING uniNewPassword;

    TRACE("GetEncryptedPasswordsForChangePassword2...");

    uniOldPassword.Buffer = NULL;
    uniNewPassword.Buffer = NULL;

    if (!RtlCreateUnicodeStringFromAsciiz(
            &uniOldPassword, pszOldPassword )
        || !RtlCreateUnicodeStringFromAsciiz(
               &uniNewPassword, pszNewPassword ))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        dwErr =
            SamiEncryptPasswords(
                &uniOldPassword,
                &uniNewPassword,
                pNewEncryptedWithOldNtOwf,
                pOldNtOwfEncryptedWithNewNtOwf,
                pfLmPresent,
                pNewEncryptedWithOldLmOwf,
                pOldLmOwfEncryptedWithNewNtOwf );
    }

    /* Erase password buffers.
    */
    if (uniOldPassword.Buffer)
    {
        ZeroMemory( uniOldPassword.Buffer,
                    lstrlenW( uniOldPassword.Buffer ) * sizeof( WCHAR ) );
    }

    if (uniNewPassword.Buffer)
    {
        ZeroMemory( uniNewPassword.Buffer,
                    lstrlenW( uniNewPassword.Buffer ) * sizeof( WCHAR ) );
    }

    RtlFreeUnicodeString( &uniOldPassword );
    RtlFreeUnicodeString( &uniNewPassword );

    TRACE1("GetEncryptedPasswordsForChangePassword2 done(%d)",dwErr);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by raschap.rc
//

// Next default values for new objects
// 
#include "xpsp1res.h"
#define         IDR_EAPCFG              1900
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS



#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\raschap.h ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** raschap.h
** Remote Access PPP Challenge Handshake Authentication Protocol
**
** 11/05/93 Steve Cobb
*/

#ifndef _RASCHAP_H_
#define _RASCHAP_H_


#include "md5.h"
#include <ntsamp.h>

#define TRACE_RASCHAP        (0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC|TRACE_USE_DATE)

#define TRACE(a)        TracePrintfExA(g_dwTraceIdChap,TRACE_RASCHAP,a )
#define TRACE1(a,b)     TracePrintfExA(g_dwTraceIdChap,TRACE_RASCHAP,a,b )
#define TRACE2(a,b,c)   TracePrintfExA(g_dwTraceIdChap,TRACE_RASCHAP,a,b,c )
#define TRACE3(a,b,c,d) TracePrintfExA(g_dwTraceIdChap,TRACE_RASCHAP,a,b,c,d )

#define DUMPW(X,Y)      TraceDumpExA(g_dwTraceIdChap,1,(LPBYTE)X,Y,4,1,NULL)
#define DUMPB(X,Y)      TraceDumpExA(g_dwTraceIdChap,1,(LPBYTE)X,Y,1,1,NULL)

//General macros
#define GEN_RAND_ENCODE_SEED            ((CHAR) ( 1 + rand() % 250 ))

/* CHAP packet codes from CHAP spec except ChangePw.
*/
#define CHAPCODE_Challenge 1
#define CHAPCODE_Response  2
#define CHAPCODE_Success   3
#define CHAPCODE_Failure   4
#define CHAPCODE_ChangePw1 5
#define CHAPCODE_ChangePw2 6
#define CHAPCODE_ChangePw3 7

#define MAXCHAPCODE 7


/* Returned by receive buffer parsing routines that discover the packet is
** corrupt, usually because the length fields don't make sense.
*/
#define ERRORBADPACKET (DWORD )-1

/* Maximum challenge and response lengths.
*/
#define MAXCHALLENGELEN 255
#define MSRESPONSELEN   (LM_RESPONSE_LENGTH + NT_RESPONSE_LENGTH + 1)
#define MD5RESPONSELEN  MD5_LEN
#define MAXRESPONSELEN  max( MSRESPONSELEN, MD5RESPONSELEN )

#define MAXINFOLEN 1500

/* Defines states within the CHAP protocol.
*/
#define CHAPSTATE enum tagCHAPSTATE
CHAPSTATE
{
    CS_Initial,
    CS_WaitForChallenge,
    CS_ChallengeSent,
    CS_ResponseSent,
    CS_Retry,
    CS_ChangePw,
    CS_ChangePw1,
    CS_ChangePw2,
    CS_ChangePw1Sent,
    CS_ChangePw2Sent,
    CS_WaitForAuthenticationToComplete1,
    CS_WaitForAuthenticationToComplete2,
    CS_Done
};


/* Defines the change password version 1 (NT 3.5) response data buffer.
*/
#define CHANGEPW1 struct tagCHANGEPW1
CHANGEPW1
{
    BYTE abEncryptedLmOwfOldPw[ ENCRYPTED_LM_OWF_PASSWORD_LENGTH ];
    BYTE abEncryptedLmOwfNewPw[ ENCRYPTED_LM_OWF_PASSWORD_LENGTH ];
    BYTE abEncryptedNtOwfOldPw[ ENCRYPTED_NT_OWF_PASSWORD_LENGTH ];
    BYTE abEncryptedNtOwfNewPw[ ENCRYPTED_NT_OWF_PASSWORD_LENGTH ];
    BYTE abPasswordLength[ 2 ];
    BYTE abFlags[ 2 ];
};


/* CHANGEPW1.abFlags bit definitions.
*/
#define CPW1F_UseNtResponse 0x00000001


/* Define the change password version 2 (NT 3.51) response data buffer.
*/
#define CHANGEPW2 struct tagCHANGEPW2
CHANGEPW2
{
    BYTE abNewEncryptedWithOldNtOwf[ sizeof(SAMPR_ENCRYPTED_USER_PASSWORD) ];
    BYTE abOldNtOwfEncryptedWithNewNtOwf[ ENCRYPTED_NT_OWF_PASSWORD_LENGTH ];
    BYTE abNewEncryptedWithOldLmOwf[ sizeof(SAMPR_ENCRYPTED_USER_PASSWORD) ];
    BYTE abOldLmOwfEncryptedWithNewNtOwf[ ENCRYPTED_NT_OWF_PASSWORD_LENGTH ];
    BYTE abLmResponse[ LM_RESPONSE_LENGTH ];
    BYTE abNtResponse[ NT_RESPONSE_LENGTH ];
    BYTE abFlags[ 2 ];
};


/* CHANGEPW2.abFlags bit definitions.
*/
#define CPW2F_UseNtResponse     0x00000001
#define CPW2F_LmPasswordPresent 0x00000002

/* Define the change password for new MS-CHAP
*/
#define CHANGEPW3 struct tagCHANGEPW3
CHANGEPW3
{
    BYTE abEncryptedPassword[ 516 ];
    BYTE abEncryptedHash[ 16 ];
    BYTE abPeerChallenge[ 24 ];
    BYTE abNTResponse[ 24 ];
    BYTE abFlags[ 2 ];
};

/* Union for storage effieciency (never need both formats at same time).
*/
#define CHANGEPW union tagCHANGEPW
CHANGEPW
{
    /* This dummy field is included so the MIPS compiler will align the
    ** structure on a DWORD boundary.  Normally, MIPS does not force alignment
    ** if the structure contains only BYTEs or BYTE arrays.  This protects us
    ** from alignment faults should SAM or LSA interpret the byte arrays as
    ** containing some necessarily aligned type, though currently they do not.
    */
    DWORD dwAlign;

    CHANGEPW1 v1;
    CHANGEPW2 v2;
    CHANGEPW3 v3;
};


/* Defines the WorkBuf stored for us by the PPP engine.
*/
#define CHAPWB struct tagCHAPWB
CHAPWB
{
    /* CHAP encryption method negotiated (MD5 or Microsoft extended).  Note
    ** that server does not support MD5.
    */
    BYTE bAlgorithm;

    /* True if role is server, false if client.
    */
    BOOL fServer;

    /* The port handle on which the protocol is active.
    */
    HPORT hport;

    /* Number of authentication attempts left before we shut down.  (Microsoft
    ** extended CHAP only)
    */
    DWORD dwTriesLeft;

    /* Client's credentials.
    */
    CHAR szUserName[ UNLEN + DNLEN + 2 ];
    CHAR szOldPassword[ PWLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];

    /* The LUID is a logon ID required by LSA to determine the response.  It
    ** must be determined in calling app's context and is therefore passed
    ** down. (client only)
    */
    LUID Luid;

    /* The challenge sent or received in the Challenge Packet and the length
    ** in bytes of same.  Note that LUID above keeps this DWORD aligned.
    */
    BYTE abChallenge[ MAXCHALLENGELEN ];
    BYTE cbChallenge;

    BYTE abComputedChallenge[ MAXCHALLENGELEN ];

    /* Indicates whether a new challenge was provided in the last Failure
    ** packet.  (client only)
    */
    BOOL fNewChallengeProvided;

    /* The response sent or received in the Response packet and the length in
    ** bytes of same.  Note the BOOL above keeps this DWORD aligned.
    */
    BYTE abResponse[ MAXRESPONSELEN ];
    BYTE cbResponse;

    /* The change password response sent or received in the ChangePw or
    ** ChangePw2 packets.
    */
    CHANGEPW changepw;

    /* The LM and user session keys retrieved when credentials are successfully
    ** authenticated.
    */
    LM_SESSION_KEY keyLm;
    USER_SESSION_KEY keyUser;

    /* This flag indicates that the session key has been calculated
    ** from the password or retrieved from LSA.  
    */
    BOOL fSessionKeysObtained;

    /* On the client, this contains the pointer to the MPPE keys. On the server
    ** this field is not used.
    */

    RAS_AUTH_ATTRIBUTE * pMPPEKeys;

    /* The current state in the CHAP protocol.
    */
    CHAPSTATE state;

    /* Sequencing ID expected on next packet received on this port and the
    ** value to send on the next outgoing packet.
    */
    BYTE bIdExpected;
    BYTE bIdToSend;

    /* The final result, used to duplicate the original response in subsequent
    ** response packets.  This is per CHAP spec to cover lost Success/Failure
    ** case without allowing malicious client to discover alternative
    ** identities under the covers during a connection.  (applies to server
    ** only)
    */
    PPPAP_RESULT result;

    HPORT hPort;

    DWORD dwInitialPacketId;

    DWORD fConfigInfo;
    
    RAS_AUTH_ATTRIBUTE * pAttributesFromAuthenticator;

    //
    // Used to send authentication request to backend server
    // 

    RAS_AUTH_ATTRIBUTE * pUserAttributes;
	CHAR		chSeed;			//Seed for encoding password.
};


/* Prototypes.
*/

DWORD
ChapInit(
    IN  BOOL        fInitialize 
);

DWORD ChapSMakeMessage( CHAPWB*, PPP_CONFIG*, PPP_CONFIG*, DWORD, PPPAP_RESULT*, 
        PPPAP_INPUT* );
DWORD
MakeAuthenticationRequestAttributes(
    IN CHAPWB*              pwb,
    IN BOOL                 fMSChap,
    IN BYTE                 bAlgorithm,
    IN CHAR*                szUserName,
    IN BYTE*                pbChallenge,
    IN DWORD                cbChallenge,
    IN BYTE*                pbResponse,
    IN DWORD                cbResponse,
    IN BYTE                 bId
);

DWORD
GetErrorCodeFromAttributes(
    IN  CHAPWB* pwb
);

DWORD
LoadChapHelperFunctions(
    VOID
);

DWORD ChapCMakeMessage( CHAPWB*, PPP_CONFIG*, PPP_CONFIG*, DWORD, PPPAP_RESULT*,
          PPPAP_INPUT* );
DWORD ChapBegin( VOID**, VOID* );
DWORD ChapEnd( VOID* );
DWORD ChapMakeMessage( VOID*, PPP_CONFIG*, PPP_CONFIG*, DWORD, PPPAP_RESULT*,
          PPPAP_INPUT* );
DWORD GetChallengeFromChallenge( CHAPWB*, PPP_CONFIG* );
DWORD MakeChangePw1Message( CHAPWB*, PPP_CONFIG*, DWORD );
DWORD MakeChangePw2Message( CHAPWB*, PPP_CONFIG*, DWORD );
DWORD MakeChangePw3Message( CHAPWB*, PPP_CONFIG*, DWORD, BOOL );
DWORD GetCredentialsFromResponse( PPP_CONFIG*, BYTE, CHAR*, BYTE* );
DWORD GetInfoFromChangePw1( PPP_CONFIG*, CHANGEPW1* );
DWORD GetInfoFromChangePw2( PPP_CONFIG*, CHANGEPW2*, BYTE* );
DWORD GetInfoFromChangePw3( PPP_CONFIG*, CHANGEPW3*, BYTE* );
VOID  GetInfoFromFailure( CHAPWB*, PPP_CONFIG*, DWORD*, BOOL*, DWORD* );
BYTE  HexCharValue( CHAR );
DWORD MakeChallengeMessage( CHAPWB*, PPP_CONFIG*, DWORD );
DWORD MakeResponseMessage( CHAPWB*, PPP_CONFIG*, DWORD, BOOL );
VOID  ChapMakeResultMessage( CHAPWB*, DWORD, BOOL, PPP_CONFIG*, DWORD );
DWORD StoreCredentials( CHAPWB*, PPPAP_INPUT* );

DWORD
ChapChangeNotification(
    VOID
);

DWORD 
GetChallenge( 
    OUT PBYTE pChallenge 
);

VOID
EndLSA(
    VOID
);

DWORD
InitLSA(
    VOID
);

DWORD
MakeChangePasswordV1RequestAttributes(
    IN  CHAPWB*                     pwb,
    IN  BYTE                        bId,
    IN  PCHAR                       pchIdentity,
    IN  PBYTE                       Challenge,
    IN  PENCRYPTED_LM_OWF_PASSWORD  pEncryptedLmOwfOldPassword,
    IN  PENCRYPTED_LM_OWF_PASSWORD  pEncryptedLmOwfNewPassword,
    IN  PENCRYPTED_NT_OWF_PASSWORD  pEncryptedNtOwfOldPassword,
    IN  PENCRYPTED_NT_OWF_PASSWORD  pEncryptedNtOwfNewPassword,
    IN  WORD                        LenPassword,
    IN  WORD                        wFlags,
    IN  DWORD                       cbChallenge, 
    IN  BYTE *                      pbChallenge
);

DWORD
MakeChangePasswordV2RequestAttributes(
    IN  CHAPWB*                        pwb,
    IN  BYTE                           bId,
    IN  CHAR*                          pchIdentity,
    IN  SAMPR_ENCRYPTED_USER_PASSWORD* pNewEncryptedWithOldNtOwf,
    IN  ENCRYPTED_NT_OWF_PASSWORD*     pOldNtOwfEncryptedWithNewNtOwf,
    IN  SAMPR_ENCRYPTED_USER_PASSWORD* pNewEncryptedWithOldLmOwf,
    IN  ENCRYPTED_NT_OWF_PASSWORD*     pOldLmOwfEncryptedWithNewNtOwf,
    IN  DWORD                          cbChallenge, 
    IN  BYTE *                         pbChallenge, 
    IN  BYTE *                         pbResponse,
    IN  WORD                           wFlags
);

DWORD
MakeChangePasswordV3RequestAttributes( 
    IN  CHAPWB*                         pwb,
    IN  BYTE                            bId,
    IN  CHAR*                           pchIdentity,
    IN  CHANGEPW3*                      pchangepw3,
    IN  DWORD                           cbChallenge, 
    IN  BYTE *                          pbChallenge
);

DWORD
GetEncryptedPasswordsForChangePassword2(
    IN  CHAR*                          pszOldPassword,
    IN  CHAR*                          pszNewPassword,
    OUT SAMPR_ENCRYPTED_USER_PASSWORD* pNewEncryptedWithOldNtOwf,
    OUT ENCRYPTED_NT_OWF_PASSWORD*     pOldNtOwfEncryptedWithNewNtOwf,
    OUT SAMPR_ENCRYPTED_USER_PASSWORD* pNewEncryptedWithOldLmOwf,
    OUT ENCRYPTED_NT_OWF_PASSWORD*     pOldLmOwfEncryptedWithNewNtOwf,
    OUT BOOLEAN*                       pfLmPresent 
);

/* Globals.
*/
#ifdef RASCHAPGLOBALS
#define GLOBALS
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN DWORD g_dwTraceIdChap 
#ifdef GLOBALS
    = INVALID_TRACEID;
#endif
;

EXTERN DWORD g_dwRefCount
#ifdef GLOBALS
    = 0;
#endif
;

EXTERN HANDLE g_hLsa
#ifdef GLOBALS
    = INVALID_HANDLE_VALUE;
#endif
;

EXTERN 
CHAR
szComputerName[CNLEN+1];

#undef EXTERN
#undef GLOBALS


#endif // _RASCHAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raseap\raseap.c ===
/********************************************************************/
/**          Copyright(c) 1985-1997 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    raseap.c
//
// Description: Main module that will do interfacing between the PPP engine
//              and the various EAP modules.
//
// History:     May 11,1997	    NarenG		Created original version.
//
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <ntsamp.h>
#include <crypt.h>
#include <windows.h>
#include <lmcons.h>
#include <string.h>
#include <stdlib.h>
#include <rasman.h>
#include <pppcp.h>
#include <mprlog.h>
#include <mprerror.h>
#include <raserror.h>
#include <rtutils.h>
#include <rasauth.h>
#include <raseapif.h>
#define INCL_PWUTIL
#define INCL_HOSTWIRE
#define INCL_RASAUTHATTRIBUTES
#include <ppputil.h>
#include <raseapif.h>
#define RASEAPGLOBALS
#include "raseap.h"
#include "bltincps.h"

//**
//
// Call:        LoadEapDlls
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will load all the EAP dlls installed.
//
DWORD
LoadEapDlls(
    VOID 
)
{
    HKEY        hKeyEap             = (HKEY)NULL;
    LPWSTR      pEapDllPath         = (LPWSTR)NULL;
    LPWSTR      pEapDllExpandedPath = (LPWSTR)NULL;
    HKEY        hKeyEapDll          = (HKEY)NULL;
    DWORD       dwRetCode;
    DWORD       dwNumSubKeys;
    DWORD       dwMaxSubKeySize;
    DWORD       dwNumValues;
    DWORD       cbMaxValNameLen;
    DWORD       cbMaxValueDataSize;
    DWORD       dwKeyIndex;
    WCHAR       wchSubKeyName[200];
    HINSTANCE   hInstance;
    FARPROC     pRasEapGetInfo;
    DWORD       cbSubKeyName;
    DWORD       dwSecDescLen;
    DWORD       cbSize;
    DWORD       dwType;
    DWORD       dwEapTypeId;

    //
    // Open the EAP key
    //

    dwRetCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              RAS_EAP_REGISTRY_LOCATION,
                              0,
                              KEY_READ,
                              &hKeyEap );

    if ( dwRetCode != NO_ERROR )
    {
        EapLogErrorString( ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL, dwRetCode,0);

        return( dwRetCode );
    }

    //
    // Find out how many EAP DLLs there are
    //

    dwRetCode = RegQueryInfoKey(
                                hKeyEap,
                                NULL,
                                NULL,
                                NULL,
                                &dwNumSubKeys,
                                &dwMaxSubKeySize,
                                NULL,
                                &dwNumValues,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL );

    if ( dwRetCode != NO_ERROR )
    {
        EapLogErrorString(ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL, dwRetCode,0);

        RegCloseKey( hKeyEap );

        return( dwRetCode );
    }

    //
    // Allocate space in the table to hold information for each one 
    //

    gblpEapTable=(EAP_INFO*)LocalAlloc(LPTR,sizeof(EAP_INFO)*dwNumSubKeys);

    if ( gblpEapTable == NULL )
    {
        RegCloseKey( hKeyEap );

        return( GetLastError() );
    }

    //
    // Read the registry to find out the various EAPs to load.
    //

    for ( dwKeyIndex = 0; dwKeyIndex < dwNumSubKeys; dwKeyIndex++ )
    {
        cbSubKeyName = sizeof( wchSubKeyName ) / sizeof(TCHAR);

        dwRetCode = RegEnumKeyEx(   
                                hKeyEap,
                                dwKeyIndex,
                                wchSubKeyName,
                                &cbSubKeyName,
                                NULL,
                                NULL,
                                NULL,
                                NULL );

        if ( ( dwRetCode != NO_ERROR )      &&
             ( dwRetCode != ERROR_MORE_DATA )   &&
             ( dwRetCode != ERROR_NO_MORE_ITEMS ) )
        {
            EapLogErrorString(ROUTERLOG_CANT_ENUM_REGKEYVALUES,0,
                              NULL,dwRetCode,0);
            break;
        }
        else
        {
            if ( dwRetCode == ERROR_NO_MORE_ITEMS )
            {
                dwRetCode = NO_ERROR;

                break;
            }
        }

        dwRetCode = RegOpenKeyEx(
                                hKeyEap,
                                wchSubKeyName,
                                0,
                                KEY_QUERY_VALUE,
                                &hKeyEapDll );


        if ( dwRetCode != NO_ERROR )
        {
            EapLogErrorString( ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL,
                               dwRetCode,0);
            break;
        }

        dwEapTypeId = _wtol( wchSubKeyName );

        //
        // Find out the size of the path value.
        //

        dwRetCode = RegQueryInfoKey(
                                hKeyEapDll,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL
                                );

        if ( dwRetCode != NO_ERROR )
        {
            EapLogErrorString(ROUTERLOG_CANT_OPEN_PPP_REGKEY,0,NULL,
                              dwRetCode,0);
            break;
        }

        //
        // Allocate space for path and add one for NULL terminator
        //

        cbMaxValueDataSize += sizeof( WCHAR );

        pEapDllPath = (LPWSTR)LocalAlloc( LPTR, cbMaxValueDataSize );

        if ( pEapDllPath == (LPWSTR)NULL )
        {
            dwRetCode = GetLastError();
            EapLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);
            break;
        }

        //
        // Read in the path
        //

        dwRetCode = RegQueryValueEx(
                                hKeyEapDll,
                                RAS_EAP_VALUENAME_PATH,
                                NULL,
                                &dwType,
                                (LPBYTE)pEapDllPath,
                                &cbMaxValueDataSize );

        if ( dwRetCode != NO_ERROR )
        {
            EapLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        if ( ( dwType != REG_EXPAND_SZ ) && ( dwType != REG_SZ ) )
        {
            dwRetCode = ERROR_REGISTRY_CORRUPT;
            EapLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        //
        // Replace the %SystemRoot% with the actual path.
        //

        cbSize = ExpandEnvironmentStrings( pEapDllPath, NULL, 0 );

        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            EapLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        pEapDllExpandedPath = (LPWSTR)LocalAlloc( LPTR, cbSize*sizeof(WCHAR) );

        if ( pEapDllExpandedPath == (LPWSTR)NULL )
        {
            dwRetCode = GetLastError();
            EapLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);
            break;
        }

        cbSize = ExpandEnvironmentStrings( pEapDllPath,
                                           pEapDllExpandedPath,
                                           cbSize*sizeof(WCHAR) );
        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            EapLogError(ROUTERLOG_CANT_GET_REGKEYVALUES,0,NULL,dwRetCode);
            break;
        }

        hInstance = LoadLibrary( pEapDllExpandedPath );

        if ( hInstance == (HINSTANCE)NULL )
        {
            dwRetCode = GetLastError();
            EapLogErrorString( ROUTERLOG_PPP_CANT_LOAD_DLL,1,
                               &pEapDllExpandedPath,dwRetCode, 1);
            break;
        }

        gblpEapTable[dwKeyIndex].hInstance = hInstance;

        gbldwNumEapProtocols++;

        pRasEapGetInfo = GetProcAddress( hInstance, "RasEapGetInfo" );

        if ( pRasEapGetInfo == (FARPROC)NULL )
        {
            dwRetCode = GetLastError();

            EapLogErrorString( ROUTERLOG_PPPCP_DLL_ERROR, 1,
                               &pEapDllExpandedPath, dwRetCode, 1);
            break;
        }

        gblpEapTable[dwKeyIndex].RasEapInfo.dwSizeInBytes = 
                                                    sizeof( PPP_EAP_INFO );

        dwRetCode = (DWORD) (*pRasEapGetInfo)( dwEapTypeId,
                                                &(gblpEapTable[dwKeyIndex].RasEapInfo));

        if ( dwRetCode != NO_ERROR )
        {
            EapLogErrorString(ROUTERLOG_PPPCP_DLL_ERROR, 1,
                              &pEapDllExpandedPath, dwRetCode, 1);
            break;

        }

        //
        // Also initialize the GetCredentials entrypoint if available.
        //
        gblpEapTable[dwKeyIndex].RasEapGetCredentials = (DWORD (*) (
                                    DWORD,VOID *, VOID **)) GetProcAddress(
                                                hInstance,
                                                "RasEapGetCredentials");
#if DBG
        if(NULL != gblpEapTable[dwKeyIndex].RasEapGetCredentials)
        {
            EAP_TRACE1("GetCredentials entry point found for typeid %d",
                        dwEapTypeId);
        }
#endif

        if ( gblpEapTable[dwKeyIndex].RasEapInfo.RasEapInitialize != NULL )
        {
            dwRetCode = gblpEapTable[dwKeyIndex].RasEapInfo.RasEapInitialize(
                            TRUE );

            if ( dwRetCode != NO_ERROR )
            {
                EapLogErrorString(ROUTERLOG_PPPCP_DLL_ERROR, 1,
                                  &pEapDllExpandedPath, dwRetCode, 1);
                break;
            }
        }

        EAP_TRACE1("Successfully loaded EAP DLL type id = %d", dwEapTypeId );

        RegCloseKey( hKeyEapDll );

        hKeyEapDll = (HKEY)NULL;

        LocalFree( pEapDllExpandedPath );

        pEapDllExpandedPath = NULL;

        LocalFree( pEapDllPath );

        pEapDllPath = (LPWSTR)NULL;
    }

    if ( hKeyEap != (HKEY)NULL )
    {
        RegCloseKey( hKeyEap );
    }

    if ( hKeyEapDll == (HKEY)NULL )
    {
        RegCloseKey( hKeyEapDll );
    }

    if ( pEapDllPath != (LPWSTR)NULL )
    {
        LocalFree( pEapDllPath );
    }

    if ( pEapDllExpandedPath != NULL )
    {
        LocalFree( pEapDllExpandedPath );
    }

    return( dwRetCode );
}

//**
//
// Call:        EapInit
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to initialize/uninitialize this CP. In the former case,
//              fInitialize will be TRUE; in the latter case, it will be FALSE.
//
DWORD
EapInit(
    IN  BOOL        fInitialize
)
{
    DWORD   dwError;

    if ( fInitialize )
    {
        g_dwTraceIdEap = TraceRegister( TEXT("RASEAP") );

        g_hLogEvents = RouterLogRegister( TEXT("RemoteAccess") );

        if ( ( dwError = LoadEapDlls() ) != NO_ERROR )
        {
            if ( g_dwTraceIdEap != INVALID_TRACEID )
            {
                TraceDeregister( g_dwTraceIdEap );

                g_dwTraceIdEap = INVALID_TRACEID;
            }

            if ( g_hLogEvents != NULL )
            {
                RouterLogDeregister( g_hLogEvents );

                g_hLogEvents = NULL;
            }

            if ( gblpEapTable != NULL )
            {
                LocalFree( gblpEapTable );

                gblpEapTable = NULL;
            }

            gbldwNumEapProtocols = 0;

            return( dwError );
        }
    }
    else
    {
        if ( g_dwTraceIdEap != INVALID_TRACEID )
        {
            TraceDeregister( g_dwTraceIdEap );

            g_dwTraceIdEap = INVALID_TRACEID;
        }

        if ( g_hLogEvents != NULL )
        {
            RouterLogDeregister( g_hLogEvents );

            g_hLogEvents = NULL;
        }

        if ( gblpEapTable != NULL )
        {
            DWORD dwIndex;

            //
            // Unload loaded DLLs
            //

            for ( dwIndex = 0; dwIndex < gbldwNumEapProtocols; dwIndex++ )
            {
                if ( gblpEapTable[dwIndex].hInstance != NULL )
                {
                    if ( gblpEapTable[dwIndex].RasEapInfo.RasEapInitialize !=
                         NULL )
                    {
                        dwError = gblpEapTable[dwIndex].RasEapInfo.
                                        RasEapInitialize(
                                            FALSE );

                        if ( dwError != NO_ERROR )
                        {
                            EAP_TRACE2(
                                "RasEapInitialize(%d) failed and returned %d",
                                gblpEapTable[dwIndex].RasEapInfo.dwEapTypeId,
                                dwError );
                        }
                    }

                    FreeLibrary( gblpEapTable[dwIndex].hInstance );
                    gblpEapTable[dwIndex].hInstance = NULL;
                }
            }

            LocalFree( gblpEapTable );

            gblpEapTable = NULL;
        }

        gbldwNumEapProtocols    = 0;
    }

    return(NO_ERROR);
}

//**
//
// Call:        EapGetInfo
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to get information for all protocols supported in this
//              module
//
LONG_PTR
EapGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pInfo 
)
{
    ZeroMemory( pInfo, sizeof( PPPCP_INFO ) );

    pInfo->Protocol         = (DWORD )PPP_EAP_PROTOCOL;
    lstrcpyA(pInfo->SzProtocolName, "EAP");
    pInfo->Recognize        = MAXEAPCODE + 1;
    pInfo->RasCpInit        = EapInit;
    pInfo->RasCpBegin       = EapBegin;
    pInfo->RasCpEnd         = EapEnd;
    pInfo->RasApMakeMessage = EapMakeMessage;

    return( 0 );
}

//**
//
// Call:        EapBegin
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called by the engine to begin a EAP PPP session.
//
DWORD
EapBegin(
    OUT VOID** ppWorkBuf,
    IN  VOID*  pInfo 
)
{
    DWORD        dwRetCode;
    PPPAP_INPUT* pInput = (PPPAP_INPUT* )pInfo;
    EAPCB*       pEapCb;

    EAP_TRACE1("EapBegin(fServer=%d)",pInput->fServer );


    if ( pInput->dwEapTypeToBeUsed != -1 )
    {
        //
        // First check if we support this EAP type
        //

        if ( GetEapTypeIndex( (BYTE)(pInput->dwEapTypeToBeUsed) ) == -1 )
        {
            return( ERROR_NOT_SUPPORTED );
        }
    }

    //
    // Allocate work buffer.
    //

    if ( ( pEapCb = (EAPCB* )LocalAlloc( LPTR, sizeof( EAPCB ) ) ) == NULL )
    {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    pEapCb->hPort                        = pInput->hPort;
    pEapCb->fAuthenticator               = pInput->fServer;
    pEapCb->fRouter                      = pInput->fRouter;
    pEapCb->fLogon                       = pInput->fLogon;
    pEapCb->fNonInteractive              = pInput->fNonInteractive;
    pEapCb->fPortWillBeBundled           = pInput->fPortWillBeBundled;
    pEapCb->fThisIsACallback             = pInput->fThisIsACallback;
    pEapCb->hTokenImpersonateUser        = pInput->hTokenImpersonateUser;
    pEapCb->pCustomAuthConnData          = pInput->pCustomAuthConnData;
    pEapCb->pCustomAuthUserData          = pInput->pCustomAuthUserData;
    pEapCb->EapState                     = EAPSTATE_Initial;
    pEapCb->dwEapIndex                   = (DWORD)-1;
    pEapCb->dwEapTypeToBeUsed            = pInput->dwEapTypeToBeUsed;
	pEapCb->chSeed = GEN_RAND_ENCODE_SEED;

    if ( !pEapCb->fAuthenticator )
    {
        if ( ( pInput->pszDomain != NULL ) && 
             ( pInput->pszDomain[0] != (CHAR)NULL ) )
        {
            strcpy( pEapCb->szIdentity, pInput->pszDomain );
            strcat( pEapCb->szIdentity, "\\" );
            strcat( pEapCb->szIdentity, pInput->pszUserName );
        }
        else
        {
            strcpy( pEapCb->szIdentity, pInput->pszUserName );
        }

        strcpy( pEapCb->szPassword, pInput->pszPassword );
        EncodePw( pEapCb->chSeed, pEapCb->szPassword );

        if ( pInput->EapUIData.pEapUIData != NULL )
        {
            PPP_EAP_UI_DATA     EapUIData;

            EapUIData.dwSizeOfEapUIData = pInput->EapUIData.dwSizeOfEapUIData;
            EapUIData.dwContextId = pInput->EapUIData.dwContextId;

            EapUIData.pEapUIData = LocalAlloc( LPTR,
                                               EapUIData.dwSizeOfEapUIData );

            if ( NULL == EapUIData.pEapUIData )
            {
                LocalFree( pEapCb );

                return( ERROR_NOT_ENOUGH_MEMORY );
            }

            CopyMemory( EapUIData.pEapUIData, pInput->EapUIData.pEapUIData,
                        EapUIData.dwSizeOfEapUIData );

            pEapCb->EapUIData = EapUIData;
        }
    }

    //
    // Register work buffer with engine.
    //

    *ppWorkBuf = pEapCb;

    EAP_TRACE("EapBegin done");

    return( NO_ERROR );
}

//**
//
// Call:        EapEnd
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to end the Eap session initiated by an EapBegin
//
DWORD
EapEnd(
    IN VOID* pWorkBuf 
)
{
    EAPCB* pEapCb = (EAPCB* )pWorkBuf;

    EAP_TRACE("EapEnd");

    if ( pEapCb == NULL )
    {
        return( NO_ERROR );
    }

    EapDllEnd( pEapCb );

    if ( pEapCb->pUserAttributes != NULL )
    {
        RasAuthAttributeDestroy( pEapCb->pUserAttributes );
    }

    LocalFree( pEapCb->EapUIData.pEapUIData );

    //
    // Nuke any credentials in memory.
    //

    ZeroMemory( pEapCb, sizeof(EAPCB) );

    LocalFree( pEapCb );

    return( NO_ERROR );
}

//**
//
// Call:        EapExtractMessage
//
// Returns:     VOID
//
// Description: If there is any message in the Request/Notification packet, then
//              save the string in pResult->szReplyMessage
//
VOID
EapExtractMessage(
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPPAP_RESULT* pResult )
{
    DWORD   dwNumBytes;
    CHAR*   szReplyMessage  = NULL;
    WORD    cbPacket;

    cbPacket = WireToHostFormat16( pReceiveBuf->Length );

    if ( PPP_CONFIG_HDR_LEN + 1 >= cbPacket )
    {
        goto LDone;
    }

    dwNumBytes = cbPacket - PPP_CONFIG_HDR_LEN - 1;

    //
    // One more for the terminating NULL.
    //

    szReplyMessage = LocalAlloc( LPTR, dwNumBytes + 1 );

    if ( NULL == szReplyMessage )
    {
        EAP_TRACE( "LocalAlloc failed. Cannot extract server's message." );
        goto LDone;
    }

    CopyMemory( szReplyMessage, pReceiveBuf->Data + 1, dwNumBytes );

    LocalFree( pResult->szReplyMessage );

    pResult->szReplyMessage = szReplyMessage;

    szReplyMessage = NULL;

LDone:

    LocalFree( szReplyMessage );

    return;
}

//**
//
// Call:        EapMakeMessage
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to process and/or to send an EAP packet.
//
DWORD
EapMakeMessage(
    IN  VOID*         pWorkBuf,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput 
)
{
    EAPCB* pEapCb = (EAPCB* )pWorkBuf;

    EAP_TRACE1("EapMakeMessage,RBuf=%x",pReceiveBuf);

    if ( ( pReceiveBuf != NULL ) && ( pReceiveBuf->Code == EAPCODE_Request ) )
    {
        //
        // Always respond to notitication request, with a notification response
        //

        if ( pReceiveBuf->Data[0] == EAPTYPE_Notification ) 
        {
            pSendBuf->Code  = EAPCODE_Response;
            pSendBuf->Id    = pReceiveBuf->Id;

            HostToWireFormat16( PPP_CONFIG_HDR_LEN + 1, pSendBuf->Length );

            pSendBuf->Data[0] = EAPTYPE_Notification;   

            pResult->Action = APA_Send;

            EapExtractMessage( pReceiveBuf, pResult );

            return( NO_ERROR );
        }

        //
        // Always respond to Identity request, with an Identity response
        //

        if ( pReceiveBuf->Data[0] == EAPTYPE_Identity )
        {
            pSendBuf->Code  = EAPCODE_Response;
            pSendBuf->Id    = pReceiveBuf->Id;

            if ( !pEapCb->fAuthenticator )
            {
                HostToWireFormat16(
                    (WORD)(PPP_CONFIG_HDR_LEN+1+strlen(pEapCb->szIdentity)),
                    pSendBuf->Length );

                strcpy( pSendBuf->Data+1, pEapCb->szIdentity );
            }
            else
            {
                HostToWireFormat16( (WORD)(PPP_CONFIG_HDR_LEN+1), 
                                    pSendBuf->Length );
            }

            pSendBuf->Data[0] = EAPTYPE_Identity;

            pResult->Action = APA_Send;

            return( NO_ERROR );
        }
    }

    return
        (pEapCb->fAuthenticator)
            ? MakeAuthenticatorMessage(
                  pEapCb, pReceiveBuf, pSendBuf, cbSendBuf, pResult, pInput )
            : MakeAuthenticateeMessage(
                  pEapCb, pReceiveBuf, pSendBuf, cbSendBuf, pResult, pInput );
}

//**
//
// Call:        MakeAuthenticateeMessage
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: EAP Authenticatee engine
//
DWORD
MakeAuthenticateeMessage(
    IN  EAPCB*        pEapCb,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput
)
{
    DWORD   dwEapIndex;
    DWORD   dwRetCode = NO_ERROR;

    EAP_TRACE("MakeAuthenticateeMessage...");

    switch( pEapCb->EapState )
    {
    case EAPSTATE_Initial:

        EAP_TRACE("EAPSTATE_Initial");

        if ( pReceiveBuf == NULL )
        {
            //
            // Do nothing. Wait for request from authenticator
            //

            pResult->Action = APA_NoAction;

            break;
        }
        else
        {
            if ( pReceiveBuf->Code != EAPCODE_Request )
            {
                //
                // We are authenticatee side so drop everything other than
                // requests, since we do not send requests
                //

                pResult->Action = APA_NoAction;

                break;
            }

            //
            // We got a packet, see if we support this EAP type, also that  
            // we are authorized to use it
            //

            dwEapIndex = GetEapTypeIndex( pReceiveBuf->Data[0] );

            if (( dwEapIndex == -1 ) ||
                ( ( pEapCb->dwEapTypeToBeUsed != -1 ) &&
                  ( dwEapIndex != GetEapTypeIndex( pEapCb->dwEapTypeToBeUsed))))
            {
                //
                // We do not support this type or we are not authorized to use
                // it so we NAK with a type we support
                //

                pSendBuf->Code  = EAPCODE_Response;
                pSendBuf->Id    = pReceiveBuf->Id;

                HostToWireFormat16( PPP_CONFIG_HDR_LEN + 2, pSendBuf->Length );

                pSendBuf->Data[0] = EAPTYPE_Nak;

                if ( pEapCb->dwEapTypeToBeUsed != -1 )
                {
                    pSendBuf->Data[1] = (BYTE)pEapCb->dwEapTypeToBeUsed;
                }
                else
                {
                    pSendBuf->Data[1] = 
                                (BYTE)gblpEapTable[0].RasEapInfo.dwEapTypeId;
                }

                pResult->Action = APA_Send;

                break;
            }
            else
            {
                //
                // The EAP type is acceptable to us so we begin authentication
                //

                if ( (dwRetCode = EapDllBegin(pEapCb, dwEapIndex)) != NO_ERROR )
                {
                    break;
                }

                pEapCb->EapState = EAPSTATE_Working;

                //
                // Fall thru
                //
            }
        }

    case EAPSTATE_Working:

        EAP_TRACE("EAPSTATE_Working");

        if ( pReceiveBuf != NULL )
        {
            if ( ( pReceiveBuf->Code != EAPCODE_Request ) &&
                 ( pReceiveBuf->Code != EAPCODE_Success ) &&
                 ( pReceiveBuf->Code != EAPCODE_Failure ) )
            {
                //
                // We are authenticatee side so drop everything other than
                // request/success/failure 
                //

                EAP_TRACE("Dropping invlid packet not request/success/failure");

                pResult->Action = APA_NoAction;

                break;
            }

            if ( ( pReceiveBuf->Code == EAPCODE_Request ) &&
                 ( pReceiveBuf->Data[0] != 
                     gblpEapTable[pEapCb->dwEapIndex].RasEapInfo.dwEapTypeId ) )
            {
                EAP_TRACE("Dropping invalid request packet with unknown Id");

                pResult->Action = APA_NoAction;

                break;
            }
        }

        dwRetCode = EapDllWork( pEapCb, 
                                pReceiveBuf, 
                                pSendBuf, 
                                cbSendBuf, 
                                pResult,
                                pInput );

        break;

    default:
    
        RTASSERT( FALSE );

        break;
    }

    return( dwRetCode );
}

//**
//
// Call:        MakeAuthenticatorMessage
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: EAP Authenticator engine
//
DWORD
MakeAuthenticatorMessage(
    IN  EAPCB*        pEapCb,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput 
)
{
    DWORD                dwRetCode = NO_ERROR;
    DWORD                dwEapTypeIndex;
    CHAR *               pszReplyMessage;
    DWORD                dwNumBytes;
    WORD                 wLength;
    BYTE                 bCode;
    RAS_AUTH_ATTRIBUTE * pAttribute;

    EAP_TRACE("MakeAuthenticatorMessage...");

    pResult->dwEapTypeId = pEapCb->dwEapTypeToBeUsed;

    switch( pEapCb->EapState )
    {
    case EAPSTATE_IdentityRequestSent:

        EAP_TRACE("EAPSTATE_IdentityRequestSent");

        if ( pReceiveBuf != NULL )
        {
            //
            // If we received a response to our identity request, then process
            // it. 
            //

            if ( ( pReceiveBuf->Code    == EAPCODE_Response ) &&
                 ( pReceiveBuf->Data[0] == EAPTYPE_Identity ) ) 
            {
                DWORD dwIdentityLength=WireToHostFormat16(pReceiveBuf->Length);

                dwIdentityLength -= ( PPP_CONFIG_HDR_LEN + 1 );

                //
                // Truncate the identity length if it is greater than UNLEN
                //

                if ( dwIdentityLength > UNLEN+DNLEN+1 )
                {
                    dwIdentityLength = UNLEN+DNLEN+1;
                }

                CopyMemory( pEapCb->szIdentity, 
                            pReceiveBuf->Data+1, 
                            dwIdentityLength );

                pEapCb->szIdentity[dwIdentityLength] = (CHAR)NULL;

                dwRetCode = MakeRequestAttributes( pEapCb,  pReceiveBuf );

                if ( dwRetCode == NO_ERROR )    
                {
                    pResult->pUserAttributes = pEapCb->pUserAttributes;

                    pEapCb->EapState = EAPSTATE_EapPacketSentToAuthServer;

                    pResult->Action  = APA_Authenticate;
                }
            }
            else
            {
                //
                // Otherwise drop the packet
                //

                EAP_TRACE("Dropping invalid packet");

                pResult->Action = APA_NoAction;
            }

            break;
        }

        //
        // Else if If timed out, fallthru and resend
        //

    case EAPSTATE_Initial:

        EAP_TRACE("EAPSTATE_Initial");

        pEapCb->dwIdExpected = bNextId++;

        //
        // Create Identity request packet
        //

        pSendBuf->Code          = EAPCODE_Request;
        pSendBuf->Id            = (BYTE)pEapCb->dwIdExpected;

        HostToWireFormat16( PPP_CONFIG_HDR_LEN + 1, pSendBuf->Length );

        pSendBuf->Data[0]       = EAPTYPE_Identity;   
        pResult->Action         = APA_SendWithTimeout;
        pResult->bIdExpected    = (BYTE)pEapCb->dwIdExpected;
        pEapCb->EapState        = EAPSTATE_IdentityRequestSent;

        break;

    case EAPSTATE_EapPacketSentToAuthServer:

        //
        // Wait for response from RADIUS authentication provider
        // drop all other packets received in the mean time.
        //

        if ( pInput == NULL )
        {
            pResult->Action = APA_NoAction;

            break;
        }

        if ( !pInput->fAuthenticationComplete )
        {
            //
            // If authentication was not complete then we do nothing
            //

            pResult->Action = APA_NoAction;

            break;
        }

        strcpy( pResult->szUserName, pEapCb->szIdentity );

        //
        // If authentication completed with an error, then we error out
        // now, otherwise we process the authentication completion
        // event below
        //

        if ( pInput->dwAuthError != NO_ERROR )
        {
            EAP_TRACE1("Error %d while processing Access-Request",
                        pInput->dwAuthError );

            return( pInput->dwAuthError );
        }

        //
        // If we got here then the authentication completed successfully,
        // ie the RADIUS server returned attributes. First save the state
        // attribute from the access challenge if there was one.
        //

        if ( pEapCb->pStateAttribute != NULL )
        {
            LocalFree( pEapCb->pStateAttribute );

            pEapCb->pStateAttribute = NULL;
        }

        pAttribute = RasAuthAttributeGet(
                                    raatState,
                                    pInput->pAttributesFromAuthenticator );

        if ( pAttribute != NULL )
        {
            pEapCb->pStateAttribute =
                                (PBYTE)LocalAlloc(LPTR, pAttribute->dwLength);

            if ( pEapCb->pStateAttribute == NULL )
            {
                return( GetLastError() );
            }

            CopyMemory( pEapCb->pStateAttribute,
                        (PBYTE)(pAttribute->Value),
                        pAttribute->dwLength );

            pEapCb->cbStateAttribute = pAttribute->dwLength;
        }

        //
        // Try to get the EAP Message if there is one
        //

        pAttribute = RasAuthAttributeGet(
                                    raatEAPMessage,
                                    pInput->pAttributesFromAuthenticator );

        if ( pAttribute != NULL )
        {
            //
            // Save the send buffer in case we have to resend
            //

            if ( pEapCb->pEAPSendBuf != NULL )
            {
                LocalFree( pEapCb->pEAPSendBuf );
                pEapCb->cbEAPSendBuf = 0;
            }

            pszReplyMessage = RasAuthAttributeGetConcatString(
                                raatReplyMessage,
                                pInput->pAttributesFromAuthenticator,
                                &dwNumBytes );

            wLength = (USHORT) (PPP_CONFIG_HDR_LEN + 1 + dwNumBytes);
            bCode = ((PPP_CONFIG*)(pAttribute->Value))->Code;

            if ( ( NULL != pszReplyMessage ) &&
                 ( wLength <= cbSendBuf ) &&
                 ( ( bCode == EAPCODE_Success ) ||
                   ( bCode == EAPCODE_Failure ) ) )
            {
                pEapCb->pEAPSendBuf = (PBYTE)LocalAlloc( LPTR, wLength );

                if ( pEapCb->pEAPSendBuf == NULL )
                {
                    LocalFree( pszReplyMessage );

                    return( GetLastError() );
                }

                pEapCb->cbEAPSendBuf = wLength;

                pSendBuf->Code = EAPCODE_Request;
                pSendBuf->Id = ++((PPP_CONFIG*)(pAttribute->Value))->Id;
                HostToWireFormat16( wLength, pSendBuf->Length );

                pSendBuf->Data[0] = EAPTYPE_Notification;

                CopyMemory( pSendBuf->Data + 1, pszReplyMessage, dwNumBytes );

                LocalFree( pszReplyMessage );

                CopyMemory( pEapCb->pEAPSendBuf, pSendBuf, wLength );

                pResult->Action = APA_SendWithTimeout;
                pResult->bIdExpected = pSendBuf->Id;

                pEapCb->fSendWithTimeoutInteractive = FALSE;
                pEapCb->dwIdExpected = pSendBuf->Id;
                pEapCb->EapState = EAPSTATE_NotificationSentToClient;

                pEapCb->pSavedAttributesFromAuthenticator =
                            pInput->pAttributesFromAuthenticator;
                pEapCb->dwSavedAuthResultCode = pInput->dwAuthResultCode;

                EAP_TRACE("Sending notification to client");

                break;
            }

            LocalFree( pszReplyMessage );

            if ( pAttribute->dwLength > cbSendBuf )
            {
                EAP_TRACE( "Need a larger buffer to construct reply" );
                // return( ERROR_BUFFER_TOO_SMALL );
            }

            pEapCb->pEAPSendBuf = (PBYTE)LocalAlloc(LPTR, pAttribute->dwLength);

            if ( pEapCb->pEAPSendBuf == NULL )
            {
                return( GetLastError() );
            }

            EAP_TRACE("Sending packet to client");

            pEapCb->cbEAPSendBuf = pAttribute->dwLength;

            CopyMemory( pEapCb->pEAPSendBuf, 
                        pAttribute->Value,
                        pAttribute->dwLength );

            CopyMemory( pSendBuf, pAttribute->Value, pAttribute->dwLength );
        }
        else
        {
            //
            // No EAP Message attribute returned so fail the authentication
            //

            EAP_TRACE("No EAP Message attribute received, failing auth");

            if ( pInput->dwAuthResultCode == NO_ERROR )
            {
                pInput->dwAuthResultCode = ERROR_AUTHENTICATION_FAILURE;
            }
        }

        if ( pInput->dwAuthResultCode != NO_ERROR )
        {
            //
            // If we failed authentication
            //

            pResult->dwError = pInput->dwAuthResultCode;

            if ( pAttribute == NULL )
            {
                //
                // If there was no EAP packet then we are done
                //

                pResult->Action = APA_Done;
            }
            else
            {
                //
                // If there was an EAP packet returned then simply send it
                //

                pResult->Action = APA_SendAndDone;
            }
        }
        else
        {
            //
            // Otherwise either we succeeded or for some reason, we don't have 
            // a success or failure packet.
            //

            if ( pAttribute == NULL )
            {
                //
                // We succeeded but there was no packet to send, so we are
                // done
                //

                pResult->Action = APA_Done;
            }
            else
            {
                //
                // If we succeeded and there is a packet to send and that
                // packet is a success packet, then send it and we are done
                //

                if ( pSendBuf->Code == EAPCODE_Success )
                {
                    pResult->Action = APA_SendAndDone;
                }
                else
                {
                    pResult->Action = APA_SendWithTimeout;

                    pEapCb->fSendWithTimeoutInteractive = FALSE;

                    pAttribute = RasAuthAttributeGet(
                                        raatSessionTimeout,
                                        pInput->pAttributesFromAuthenticator );

                    if ( pAttribute != NULL )
                    {
                        //
                        // If session timeout in Access-Challenge is
                        // greater then 10 then send with interactive
                        // timeout.
                        //

                        if ( PtrToUlong(pAttribute->Value) > 10 )
                        {
                            pResult->Action = APA_SendWithTimeout2;

                            pEapCb->fSendWithTimeoutInteractive = TRUE;
                        }
                    }

                    pEapCb->dwIdExpected = pSendBuf->Id;
                    pResult->bIdExpected = (BYTE)pEapCb->dwIdExpected;
                    pEapCb->EapState     = EAPSTATE_EapPacketSentToClient;
                }
            }

            pResult->dwError = NO_ERROR;
        }

        break;

    case EAPSTATE_NotificationSentToClient:

        if ( pReceiveBuf != NULL )
        {
            //
            // Make sure the packet IDs match
            //

            if ( pReceiveBuf->Id != ((PPP_CONFIG*)(pEapCb->pEAPSendBuf))->Id )
            {
                EAP_TRACE("Id of packet recvd doesn't match one sent");

                pResult->Action = APA_NoAction;

                break;
            }

            strcpy( pResult->szUserName, pEapCb->szIdentity );

            pAttribute = RasAuthAttributeGet(
                                    raatEAPMessage,
                                    pEapCb->pSavedAttributesFromAuthenticator );

            if ( pAttribute != NULL )
            {
                //
                // Save the send buffer in case we have to resend
                //

                if ( pEapCb->pEAPSendBuf != NULL )
                {
                  LocalFree( pEapCb->pEAPSendBuf );
                  pEapCb->cbEAPSendBuf = 0;
                }

                if ( pAttribute->dwLength > cbSendBuf )
                {
                    EAP_TRACE( "Need a larger buffer to construct reply" );
                    // return( ERROR_BUFFER_TOO_SMALL );
                }

                pEapCb->pEAPSendBuf = (PBYTE)LocalAlloc(LPTR, pAttribute->dwLength);

                if ( pEapCb->pEAPSendBuf == NULL )
                {
                  return( GetLastError() );
                }

                EAP_TRACE("Sending packet to client");

                pEapCb->cbEAPSendBuf = pAttribute->dwLength;

                CopyMemory( pEapCb->pEAPSendBuf,
                            pAttribute->Value,
                            pAttribute->dwLength );

                CopyMemory( pSendBuf, pAttribute->Value, pAttribute->dwLength );

                if ( pEapCb->dwSavedAuthResultCode != NO_ERROR )
                {
                    //
                    // If we failed authentication
                    //

                    pResult->dwError = pEapCb->dwSavedAuthResultCode;
                    pResult->Action = APA_SendAndDone;
                    break;
                }
                else if ( EAPCODE_Success == pSendBuf->Code )
                {
                    pResult->dwError = NO_ERROR;
                    pResult->Action = APA_SendAndDone;
                    break;
                }
            }

            pResult->dwError = ERROR_AUTHENTICATION_FAILURE;
            pResult->Action = APA_Done;
            break;
        }

        //
        // Fall thru
        //

    case EAPSTATE_EapPacketSentToClient:

        //
        // If we did not get any input structure, then we either received
        // a packet or we timed out.
        //

        if ( pReceiveBuf != NULL )
        {
            //
            // Make sure the packet IDs match
            //

            if ( pReceiveBuf->Id != ((PPP_CONFIG*)(pEapCb->pEAPSendBuf))->Id )
            {
                EAP_TRACE("Id of packet recvd doesn't match one sent");

                pResult->Action = APA_NoAction;

                break;
            }

            //
            // Save the Eap Type. Make sure that the response from the client 
            // contains an authentication Type code, and not something like
            // a Nak.
            //

            if ( ( pReceiveBuf->Code    == EAPCODE_Response ) &&
                 ( pReceiveBuf->Data[0] >  EAPTYPE_Nak ) )
            {
                pEapCb->dwEapTypeToBeUsed = pReceiveBuf->Data[0];
            }

            //
            // We received a packet so simply send it to the RADIUS server
            //

            dwRetCode = MakeRequestAttributes( pEapCb, pReceiveBuf );

            if ( dwRetCode == NO_ERROR )
            {
                pResult->pUserAttributes = pEapCb->pUserAttributes;
                pResult->Action          = APA_Authenticate;
                pEapCb->EapState         = EAPSTATE_EapPacketSentToAuthServer;
            }
        }
        else
        {
            //
            // We timed out and have to resend
            //

            EAP_TRACE("Timed out, resending packet to client");

            CopyMemory(pSendBuf, pEapCb->pEAPSendBuf, pEapCb->cbEAPSendBuf);

            if ( pEapCb->fSendWithTimeoutInteractive )
            {
                pResult->Action = APA_SendWithTimeout2;
            }
            else
            {
                pResult->Action = APA_SendWithTimeout;
            }

            pResult->bIdExpected = (BYTE)pEapCb->dwIdExpected;
        }

        break;

    default:

        RTASSERT( FALSE );
        break;
    }

    return( dwRetCode );
}

//**
//
// Call:        EapDllBegin
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to initiate an EAP session for a certain type
//
//
DWORD
EapDllBegin(
    IN EAPCB * pEapCb,
    IN DWORD   dwEapIndex
)
{
    PPP_EAP_INPUT   PppEapInput;
    WCHAR           awszIdentity[DNLEN+UNLEN+2];
    WCHAR           awszPassword[PWLEN+1];
    DWORD           dwRetCode;

    EAP_TRACE1("EapDllBegin called for EAP Type %d",  
            gblpEapTable[dwEapIndex].RasEapInfo.dwEapTypeId);

    if (0 == MultiByteToWideChar(
                CP_ACP,
                0,
                pEapCb->szIdentity,
                -1,
                awszIdentity, 
                DNLEN+UNLEN+2 ) )
    {
        dwRetCode = GetLastError();

        EAP_TRACE2("MultiByteToWideChar(%s) failed: %d",
            pEapCb->szIdentity,
            dwRetCode);

        return( dwRetCode );
    }

    ZeroMemory( &PppEapInput, sizeof( PppEapInput ) );

    PppEapInput.dwSizeInBytes           = sizeof( PPP_EAP_INPUT );
    PppEapInput.fFlags                  = ( pEapCb->fRouter ? 
                                            RAS_EAP_FLAG_ROUTER : 0 );
    PppEapInput.fFlags                 |= ( pEapCb->fLogon ? 
                                            RAS_EAP_FLAG_LOGON : 0 );
    PppEapInput.fFlags                 |= ( pEapCb->fNonInteractive ? 
                                            RAS_EAP_FLAG_NON_INTERACTIVE : 0 );

    if ( !pEapCb->fThisIsACallback && !pEapCb->fPortWillBeBundled )
    {
        PppEapInput.fFlags             |= RAS_EAP_FLAG_FIRST_LINK;
    }

    PppEapInput.fAuthenticator          = pEapCb->fAuthenticator;
    PppEapInput.pwszIdentity            = awszIdentity;
    PppEapInput.pwszPassword            = awszPassword;
    PppEapInput.hTokenImpersonateUser   = pEapCb->hTokenImpersonateUser;
    PppEapInput.fAuthenticationComplete = FALSE;
    PppEapInput.dwAuthResultCode        = NO_ERROR;

    if ( NULL != pEapCb->pCustomAuthConnData )
    {
        PppEapInput.pConnectionData =
            pEapCb->pCustomAuthConnData->abCustomAuthData;
        PppEapInput.dwSizeOfConnectionData =
            pEapCb->pCustomAuthConnData->cbCustomAuthData;
    }

    if ( NULL != pEapCb->pCustomAuthUserData )
    {
        PppEapInput.pUserData =
            pEapCb->pCustomAuthUserData->abCustomAuthData;
        PppEapInput.dwSizeOfUserData =
            pEapCb->pCustomAuthUserData->cbCustomAuthData;
    }

    if ( NULL != pEapCb->EapUIData.pEapUIData )
    {
        PppEapInput.pDataFromInteractiveUI   = 
                                    pEapCb->EapUIData.pEapUIData;
        PppEapInput.dwSizeOfDataFromInteractiveUI =
                                    pEapCb->EapUIData.dwSizeOfEapUIData;
    }

    DecodePw( pEapCb->chSeed, pEapCb->szPassword );

    MultiByteToWideChar(
        CP_ACP,
        0,
        pEapCb->szPassword,
        -1,
        awszPassword,
        PWLEN+1 );

    awszPassword[PWLEN] = 0;

    dwRetCode = gblpEapTable[dwEapIndex].RasEapInfo.RasEapBegin( 
                                                &pEapCb->pWorkBuffer,   
                                                &PppEapInput );
    EncodePw( pEapCb->chSeed, pEapCb->szPassword );
    ZeroMemory( awszPassword, sizeof(awszPassword) );

    if ( dwRetCode == NO_ERROR )
    {
        pEapCb->dwEapIndex = dwEapIndex;
    }
    else
    {
        pEapCb->dwEapIndex = (DWORD)-1;
    }

    return( dwRetCode );
}

//**
//
// Call:        EapDllEnd
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to end an EAP session for a certain type
//
//
DWORD
EapDllEnd(
    EAPCB * pEapCb
)
{
    DWORD dwRetCode = NO_ERROR;

    EAP_TRACE1("EapDllEnd called for EAP Index %d", pEapCb->dwEapIndex );

    if ( pEapCb->pWorkBuffer != NULL )
    {
        //
        // On the server, pWorkBuffer must be NULL. IAS must call RasEapEnd.
        //

        if ( pEapCb->dwEapIndex != (DWORD)-1 )
        {
            dwRetCode = gblpEapTable[pEapCb->dwEapIndex].RasEapInfo.RasEapEnd(
                                                        pEapCb->pWorkBuffer );
        }

        pEapCb->pWorkBuffer = NULL;
    }

    if ( pEapCb->pEAPSendBuf != NULL )
    {
        LocalFree( pEapCb->pEAPSendBuf );

        pEapCb->pEAPSendBuf = NULL;
        pEapCb->cbEAPSendBuf = 0;
    }

    if ( pEapCb->pStateAttribute != NULL )
    {
        LocalFree( pEapCb->pStateAttribute );

        pEapCb->pStateAttribute = NULL;
    }

    pEapCb->dwEapIndex = (DWORD)-1;

    return( dwRetCode );
}

//**
//
// Call:        EapDllWork
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to process an incomming packet or timeout etc
//
DWORD
EapDllWork( 
    IN  EAPCB *       pEapCb,    
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput 
)
{
    PPP_EAP_OUTPUT  PppEapOutput;
    PPP_EAP_INPUT   PppEapInput;
    DWORD           dwRetCode;
    CHAR *          pChar = NULL;

    EAP_TRACE1("EapDllWork called for EAP Type %d", 
            gblpEapTable[pEapCb->dwEapIndex].RasEapInfo.dwEapTypeId);

    ZeroMemory( &PppEapOutput, sizeof( PppEapOutput ) );
    PppEapOutput.dwSizeInBytes = sizeof( PppEapOutput );

    ZeroMemory( &PppEapInput, sizeof( PppEapInput ) );
    PppEapInput.dwSizeInBytes           = sizeof( PPP_EAP_INPUT );
    PppEapInput.fAuthenticator          = pEapCb->fAuthenticator;
    PppEapInput.hTokenImpersonateUser   = pEapCb->hTokenImpersonateUser;

    if ( pInput != NULL )
    {
        PppEapInput.fAuthenticationComplete = pInput->fAuthenticationComplete;
        PppEapInput.dwAuthResultCode        = pInput->dwAuthResultCode;
        PppEapInput.fSuccessPacketReceived  = pInput->fSuccessPacketReceived;

        if ( pInput->fEapUIDataReceived )
        {
            //
            // EapUIData.pEapUIData is allocated by rasman and freed by engine.
            // raseap.c must not free it.
            //

            if ( pInput->EapUIData.dwContextId != pEapCb->dwUIInvocationId )
            {
                //
                // Ignore this data received
                //

                EAP_TRACE("Out of date data received from UI" );

                return( NO_ERROR );
            }

            PppEapInput.fDataReceivedFromInteractiveUI = TRUE;

            PppEapInput.pDataFromInteractiveUI   = 
                                        pInput->EapUIData.pEapUIData;
            PppEapInput.dwSizeOfDataFromInteractiveUI =
                                        pInput->EapUIData.dwSizeOfEapUIData;

        }
    }

    dwRetCode = gblpEapTable[pEapCb->dwEapIndex].RasEapInfo.RasEapMakeMessage( 
                                                pEapCb->pWorkBuffer,   
                                                (PPP_EAP_PACKET *)pReceiveBuf,
                                                (PPP_EAP_PACKET *)pSendBuf,
                                                cbSendBuf,
                                                &PppEapOutput,
                                                &PppEapInput );
    
    if ( dwRetCode != NO_ERROR )
    {
        switch( dwRetCode )
        {
        case ERROR_PPP_INVALID_PACKET:

            EAP_TRACE("Silently discarding invalid EAP packet");

            pResult->Action = APA_NoAction;

            return( NO_ERROR );
        
        default:

            EAP_TRACE2("EapDLLMakeMessage for type %d returned %d",
                    gblpEapTable[pEapCb->dwEapIndex].RasEapInfo.dwEapTypeId,
                    dwRetCode );
            break;
        }

        return( dwRetCode );
    }

    switch( PppEapOutput.Action )
    {
    case EAPACTION_NoAction:

        pResult->Action = APA_NoAction;
        EAP_TRACE( "EAP Dll returned Action=EAPACTION_NoAction" );
        break;

    case EAPACTION_Send:

        pResult->Action = APA_Send;
        EAP_TRACE( "EAP Dll returned Action=EAPACTION_Send" );
        break;

    case EAPACTION_Done:
    case EAPACTION_SendAndDone:

        if ( PppEapOutput.Action == EAPACTION_SendAndDone )
        {
            pResult->Action = APA_SendAndDone;
            EAP_TRACE( "EAP Dll returned Action=EAPACTION_SendAndDone" );
        }
        else
        {
            pResult->Action = APA_Done;
            EAP_TRACE( "EAP Dll returned Action=EAPACTION_Done" );
        }

        pResult->dwError         = PppEapOutput.dwAuthResultCode; 
        pResult->pUserAttributes = PppEapOutput.pUserAttributes;

        strcpy( pResult->szUserName, pEapCb->szIdentity );

        break;

    case EAPACTION_SendWithTimeout:
    case EAPACTION_SendWithTimeoutInteractive:
    case EAPACTION_Authenticate:

        EAP_TRACE1( "EAP Dll returned disallowed Action=%d",    
                                                    PppEapOutput.Action );
        break;

    default:

        RTASSERT( FALSE );
        EAP_TRACE1( "EAP Dll returned unknown Action=%d", PppEapOutput.Action );
        break;
    }
    
    //
    // Check to see if EAP dll wants to bring up UI
    //

    if ( PppEapOutput.fInvokeInteractiveUI )
    {
        if ( pEapCb->fAuthenticator )
        {
            EAP_TRACE( "EAP Dll wants to bring up UI on the server side" );

            return( ERROR_INTERACTIVE_MODE );
        }

        if ( PppEapOutput.pUIContextData != NULL )
        {
            pResult->InvokeEapUIData.dwSizeOfUIContextData =
                                            PppEapOutput.dwSizeOfUIContextData;

            pResult->InvokeEapUIData.pUIContextData 
                      = LocalAlloc(LPTR, PppEapOutput.dwSizeOfUIContextData);

            if ( pResult->InvokeEapUIData.pUIContextData == NULL )
            {
                return( ERROR_NOT_ENOUGH_MEMORY );
            }
        
            CopyMemory( pResult->InvokeEapUIData.pUIContextData,
                        PppEapOutput.pUIContextData, 
                        pResult->InvokeEapUIData.dwSizeOfUIContextData );
        }
        else
        {
            pResult->InvokeEapUIData.pUIContextData        = NULL;
            pResult->InvokeEapUIData.dwSizeOfUIContextData = 0;
        }

        pResult->fInvokeEapUI                = TRUE;
        pEapCb->dwUIInvocationId             = gbldwGuid++;
        pResult->InvokeEapUIData.dwContextId = pEapCb->dwUIInvocationId;
        pResult->InvokeEapUIData.dwEapTypeId = 
                    gblpEapTable[pEapCb->dwEapIndex].RasEapInfo.dwEapTypeId;

        EAP_TRACE( "EAP Dll wants to invoke interactive UI" );
    }

    pResult->dwEapTypeId      = pEapCb->dwEapTypeToBeUsed;
    pResult->fSaveUserData    = PppEapOutput.fSaveUserData;
    pResult->pUserData        = PppEapOutput.pUserData;
    pResult->dwSizeOfUserData = PppEapOutput.dwSizeOfUserData;

    pResult->fSaveConnectionData    = PppEapOutput.fSaveConnectionData;
    pResult->SetCustomAuthData.pConnectionData =
                                    PppEapOutput.pConnectionData;
    pResult->SetCustomAuthData.dwSizeOfConnectionData =
                                    PppEapOutput.dwSizeOfConnectionData;

    return( dwRetCode );
}

//**
//
// Call:        GetEapIndex
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will return the index into gblpEapTable of the specified 
//              EAP type
//
DWORD
GetEapTypeIndex( 
    IN DWORD dwEapTypeId
)
{
    DWORD dwIndex;

    for ( dwIndex = 0; dwIndex < gbldwNumEapProtocols; dwIndex++ )
    {
        if ( gblpEapTable[dwIndex].RasEapInfo.dwEapTypeId == dwEapTypeId )
        {
            return( dwIndex );
        }
    }

    return( (DWORD)-1 );
}

//**
//
// Call:        MakeRequestAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will begin the RADIUS/EAP dialog by sending the caller's
//              identity to the RADIUS server.
//
DWORD
MakeRequestAttributes( 
    IN  EAPCB *         pEapCb,
    IN  PPP_CONFIG *    pReceiveBuf
)
{
    DWORD                dwIndex = 0;
    DWORD                dwRetCode;

    EAP_TRACE("Sending EAP packet to RADIUS/IAS");

    if ( pEapCb->pUserAttributes != NULL )
    {
        RasAuthAttributeDestroy( pEapCb->pUserAttributes );

        pEapCb->pUserAttributes = NULL;
    }

    //
    // Allocate the appropriate amount + 1 for Identity + 1 more for EAP packet
    // +1 for State attribute (if any).
    //
    
    if ( ( pEapCb->pUserAttributes = RasAuthAttributeCreate( 
                                    ( pEapCb->pStateAttribute != NULL ) 
                                        ? 3
                                        : 2 ) ) == NULL )
    {
        return( GetLastError() );
    }

    //
    // Insert EAP Message
    //

    dwRetCode = RasAuthAttributeInsert( dwIndex++,
                                        pEapCb->pUserAttributes,
                                        raatEAPMessage,
                                        FALSE,
                                        WireToHostFormat16(pReceiveBuf->Length),
                                        pReceiveBuf );
    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pEapCb->pUserAttributes );

        pEapCb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    //
    // Insert username
    //

    dwRetCode = RasAuthAttributeInsert( dwIndex++,
                                        pEapCb->pUserAttributes,
                                        raatUserName,
                                        FALSE,
                                        strlen( pEapCb->szIdentity ),
                                        pEapCb->szIdentity );
    if ( dwRetCode != NO_ERROR )
    {
        RasAuthAttributeDestroy( pEapCb->pUserAttributes );

        pEapCb->pUserAttributes = NULL;

        return( dwRetCode );
    }

    //
    // Insert State attribute if we have one
    //

    if ( pEapCb->pStateAttribute != NULL )
    {
       dwRetCode = RasAuthAttributeInsert( 
                                        dwIndex++,
                                        pEapCb->pUserAttributes,
                                        raatState,
                                        FALSE,
                                        pEapCb->cbStateAttribute,
                                        pEapCb->pStateAttribute );
        if ( dwRetCode != NO_ERROR )
        {
            RasAuthAttributeDestroy( pEapCb->pUserAttributes );

            pEapCb->pUserAttributes = NULL;

            return( dwRetCode );
        }
    }

    return( NO_ERROR );
}    

DWORD
EapGetCredentials(
    VOID *  pWorkBuf,
    VOID ** ppCredentials)
{
    EAPCB *pEapCb = (EAPCB *) pWorkBuf;
    DWORD dwRetCode = ERROR_SUCCESS;

    if(     (NULL == pEapCb)
        ||  (NULL == ppCredentials))
    {
        return E_INVALIDARG;
    }

    if(NULL != gblpEapTable[pEapCb->dwEapIndex].RasEapGetCredentials)
    {
        //
        // Invoke appropriate eap dll for credentials
        //
        dwRetCode =
            gblpEapTable[pEapCb->dwEapIndex].RasEapGetCredentials(
                                            pEapCb->dwEapTypeToBeUsed,
                                            pEapCb->pWorkBuffer,
                                            ppCredentials);
    }

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raseap\test\ceapcfg.cpp ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:

History:

*/

#include "ceapcfg.h"

extern "C"
DWORD APIENTRY
RasEapInvokeConfigUI(
    IN  DWORD       dwEapTypeId,
    IN  HWND        hwndParent,
    IN  DWORD       dwFlags,
    IN  BYTE*       pConnectionDataIn,
    IN  DWORD       dwSizeOfConnectionDataIn,
    OUT BYTE**      ppConnectionDataOut,
    OUT DWORD*      pdwSizeOfConnectionDataOut
);

extern "C"
DWORD
GetIdentity(
    IN  HWND    hwndParent,
    IN  BYTE*   pUserDataIn,
    IN  DWORD   dwSizeOfUserDataIn,
    OUT BYTE**  ppUserDataOut,
    OUT DWORD*  pdwSizeOfUserDataOut,
    OUT WCHAR** ppwszIdentityOut
);

extern "C"
DWORD APIENTRY
RasEapFreeMemory(
    IN  BYTE*   pMemory
);

/*

Notes:
    Implementation of IEAPProviderConfig::Initialize
    
*/

STDMETHODIMP
CEapCfg::Initialize(
    LPCOLESTR   pwszMachineName,
    DWORD       dwEapTypeId,
    ULONG_PTR*  puConnectionParam
)
{
    DWORD       cch;
    WCHAR*      pwsz    = NULL;
    DWORD       dwErr   = NO_ERROR;

    *puConnectionParam = NULL;

    //
    // Save machine name as connection param.
    //

    //
    // How many chars are there in the name?
    //

    cch = wcslen(pwszMachineName);

    pwsz = (WCHAR*) LocalAlloc(LPTR, (cch + 1) * sizeof(WCHAR));

    if (NULL == pwsz)
    {
        dwErr = GetLastError();
        goto LDone;
    }

    //
    // Copy machine name
    //

    wcscpy(pwsz, pwszMachineName);
    *puConnectionParam = (ULONG_PTR)pwsz;
    pwsz = NULL;

LDone:

    LocalFree(pwsz);

    return(HRESULT_FROM_WIN32(dwErr));
}

/*

Notes:
    Implementation of IEAPProviderConfig::Uninitialize

*/

STDMETHODIMP
CEapCfg::Uninitialize(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam
)
{
    LocalFree((VOID*)uConnectionParam);
    return(HRESULT_FROM_WIN32(NO_ERROR));
}

/*

Notes:
    Implementation of IEAPProviderConfig::ServerInvokeConfigUI
        hWnd - handle to the parent window
        dwRes1 - reserved parameter (ignore)
        dwRes2 - reserved parameter (ignore)

*/

STDMETHODIMP
CEapCfg::ServerInvokeConfigUI(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam,
    HWND        hWnd,
    DWORD_PTR   dwRes1,
    DWORD_PTR   dwRes2
)
{
    WCHAR*      pwszMachineName;
    HRESULT     hr;
    DWORD       dwErr;

    pwszMachineName = (WCHAR*)uConnectionParam;

    if (NULL == pwszMachineName)
    {
        dwErr = E_FAIL;
    }
    else
    {
        MessageBox(hWnd, pwszMachineName, L"You are configuring the EAP on...",
            MB_OK | MB_ICONINFORMATION);
    }

    hr = HRESULT_FROM_WIN32(dwErr);

    return(hr);
}

/*

Notes:
    Implementation of IEAPProviderConfig::RouterInvokeConfigUI

*/

STDMETHODIMP
CEapCfg::RouterInvokeConfigUI(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam,
    HWND        hwndParent,
    DWORD       dwFlags,
    BYTE*       pConnectionDataIn,
    DWORD       dwSizeOfConnectionDataIn,
    BYTE**      ppConnectionDataOut,
    DWORD*      pdwSizeOfConnectionDataOut
)
{
    DWORD       dwErr                       = NO_ERROR;
    BYTE*       pConnectionDataOut          = NULL;
    DWORD       dwSizeOfConnectionDataOut   = 0;

    *ppConnectionDataOut = NULL;
    *pdwSizeOfConnectionDataOut = 0;

    dwErr = RasEapInvokeConfigUI(
                dwEapTypeId,
                hwndParent,
                dwFlags,
                pConnectionDataIn,
                dwSizeOfConnectionDataIn,
                &pConnectionDataOut,
                &dwSizeOfConnectionDataOut);

    if (   (NO_ERROR == dwErr)
        && (0 != dwSizeOfConnectionDataOut))
    {
        //
        // If we got valid ConnectionDataOut, allocate memory for it...
        //

        *ppConnectionDataOut = (BYTE*)CoTaskMemAlloc(dwSizeOfConnectionDataOut);

        if (NULL == *ppConnectionDataOut)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto LDone;
        }

        //
        // ... and return it in the OUT parameter
        //

        CopyMemory(*ppConnectionDataOut, pConnectionDataOut,
            dwSizeOfConnectionDataOut);
        *pdwSizeOfConnectionDataOut = dwSizeOfConnectionDataOut;
    }

LDone:

    RasEapFreeMemory(pConnectionDataOut);

    return(HRESULT_FROM_WIN32(dwErr));
}

/*

Notes:
    Implementation of IEAPProviderConfig::RouterInvokeCredentialsUI

*/

STDMETHODIMP
CEapCfg::RouterInvokeCredentialsUI(
    DWORD       dwEapTypeId,
    ULONG_PTR   uConnectionParam,
    HWND        hwndParent,
    DWORD       dwFlags,
    BYTE*       pConnectionDataIn,
    DWORD       dwSizeOfConnectionDataIn,
    BYTE*       pUserDataIn,
    DWORD       dwSizeOfUserDataIn,
    BYTE**      ppUserDataOut,
    DWORD*      pdwSizeOfUserDataOut
)
{
    BYTE*       pUserDataOut            = NULL;
    DWORD       dwSizeOfUserDataOut;
    WCHAR*      pwszIdentityOut         = NULL;
    DWORD       dwErr                   = NO_ERROR;

    *ppUserDataOut = NULL;
    *pdwSizeOfUserDataOut = 0;

    dwErr = GetIdentity(
                    hwndParent,
                    NULL /* pUserDataIn */,
                    0 /* dwSizeOfUserDataIn */,
                    &pUserDataOut,
                    &dwSizeOfUserDataOut,
                    &pwszIdentityOut);

    if (   (NO_ERROR == dwErr)
        && (0 != dwSizeOfUserDataOut))
    {
        //
        // If we got valid UserDataOut, allocate memory for it...
        //

        *ppUserDataOut = (BYTE*)CoTaskMemAlloc(dwSizeOfUserDataOut);

        if (NULL == *ppUserDataOut)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto LDone;
        }

        //
        // ... and return it in the OUT parameter
        //

        CopyMemory(*ppUserDataOut, pUserDataOut, dwSizeOfUserDataOut);
        *pdwSizeOfUserDataOut = dwSizeOfUserDataOut;
    }

LDone:

    LocalFree(pUserDataOut);
    LocalFree((BYTE*)pwszIdentityOut);

    return(HRESULT_FROM_WIN32(dwErr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\slsa.c ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** slsa.c
** Server-side LSA Authentication Utilities
**
** 11/10/93 MikeSa  Pulled from NT 3.1 RAS authentication.
** 11/12/93 SteveC  Do clear-text authentication when Challenge is NULL
*/


#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <ntsamp.h>
#include <crypt.h>

#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>

#include <rasfmsub.h>
#include <stdlib.h>
#include <rtutils.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <mprapi.h>
#include <rasman.h>
#include <rasauth.h>
#include <pppcp.h>
#include <raserror.h>
#include <stdio.h>
#include <md5.h>
#define INCL_MISC
#include <ppputil.h>
#include "raschap.h"


static DWORD g_dwAuthPkgId;


//**
//
// Call:
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
InitLSA(
    VOID
)
{
    NTSTATUS ntstatus;
    STRING   PackageName;

    //
    // To be able to call into NTLM, we need a handle to the LSA.
    //

    ntstatus = LsaConnectUntrusted(&g_hLsa);

    if ( ntstatus != STATUS_SUCCESS )
    {
        return( RtlNtStatusToDosError( ntstatus ) );
    }

    //
    // We use the MSV1_0 authentication package for LM2.x logons.  We get
    // to MSV1_0 via the Lsa.  So we call Lsa to get MSV1_0's package id,
    // which we'll use in later calls to Lsa.
    //

    RtlInitString(&PackageName, MSV1_0_PACKAGE_NAME);

    ntstatus = LsaLookupAuthenticationPackage(g_hLsa, &PackageName, &g_dwAuthPkgId);

    return( RtlNtStatusToDosError( ntstatus ) );
}

//**
//
// Call:
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
EndLSA(
    VOID
)
{
    LsaDeregisterLogonProcess( g_hLsa );
}

//** -GetChallenge
//
//    Function:
//        Calls Lsa to get LM 2.0 challenge to send client during
//        authentication
//
//    Returns:
//        0 - success
//        1 - Lsa error
//
//    History:
//        05/18/92 - Michael Salamone (MikeSa) - Original Version 1.0
//**

DWORD GetChallenge(
    OUT PBYTE pChallenge
    )
{
    MSV1_0_LM20_CHALLENGE_REQUEST ChallengeRequest;
    PMSV1_0_LM20_CHALLENGE_RESPONSE pChallengeResponse;
    DWORD dwChallengeResponseLength;
    NTSTATUS Status;
    NTSTATUS PStatus;

    ChallengeRequest.MessageType = MsV1_0Lm20ChallengeRequest;

    Status = LsaCallAuthenticationPackage(
            g_hLsa,
            g_dwAuthPkgId,
            &ChallengeRequest,
            sizeof(MSV1_0_LM20_CHALLENGE_REQUEST),
            (PVOID) &pChallengeResponse,
            &dwChallengeResponseLength,
            &PStatus
            );

    if ( Status != STATUS_SUCCESS )
    {
        return( RtlNtStatusToDosError( Status ) );
    }
    else if ( PStatus != STATUS_SUCCESS )
    {
        return( RtlNtStatusToDosError( PStatus ) );
    }
    else
    {
        RtlMoveMemory(pChallenge, pChallengeResponse->ChallengeToClient,
                MSV1_0_CHALLENGE_LENGTH);

        LsaFreeReturnBuffer(pChallengeResponse);

        return (0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raseap\test\ceapcfg.h ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _CEAPCFG_H_
#define _CEAPCFG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <rrascfg.h>    // IEAPProviderConfig declarations

#include "resource.h"

// Define this here so that our macros will expand correctly
#define IMPL

// External references
extern const CLSID  CLSID_EapCfg;

class ATL_NO_VTABLE CEapCfg : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CEapCfg, &CLSID_EapCfg>,
    public IEAPProviderConfig
{
public:
    CEapCfg()  {}

DECLARE_REGISTRY_RESOURCEID(IDR_EAPCFG)
DECLARE_NOT_AGGREGATABLE(CEapCfg)

BEGIN_COM_MAP(CEapCfg)
    COM_INTERFACE_ENTRY(IEAPProviderConfig)
END_COM_MAP()

public:
    // This is the declaration of the UI interface members.
    // See rrascfg.idl for the prototypes
    DeclareIEAPProviderConfigMembers(IMPL);
};

#endif // _CEAPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raseap\raseap.h ===
/********************************************************************/
/**          Copyright(c) 1985-1997 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    raseap.h
//
// Description: Header for EAP module
//
// History:     May 11,1997	    NarenG		Created original version.
//

#ifndef _RASEAP_H_
#define _RASEAP_H_



//General macros
#define GEN_RAND_ENCODE_SEED            ((CHAR) ( 1 + rand() % 250 ))

//
// Tracing and event logging for EAP
//

#define EapLogError( LogId, NumStrings, lpwsSubStringArray, dwRetCode )     \
    RouterLogError( g_hLogEvents, LogId, NumStrings, lpwsSubStringArray,    \
                    dwRetCode )

#define EapLogWarning( LogId, NumStrings, lpwsSubStringArray )              \
    RouterLogWarning( g_hLogEvents, LogId, NumStrings, lpwsSubStringArray, 0 )

#define EapLogInformation( LogId, NumStrings, lpwsSubStringArray )          \
    RouterLogInformation(g_hLogEvents,LogId, NumStrings, lpwsSubStringArray,0)

#define EapLogErrorString(LogId,NumStrings,lpwsSubStringArray,dwRetCode,    \
                          dwPos )                                           \
    RouterLogErrorString( g_hLogEvents, LogId, NumStrings,                  \
                          lpwsSubStringArray, dwRetCode, dwPos )

#define EapLogWarningString( LogId,NumStrings,lpwsSubStringArray,dwRetCode, \
                            dwPos )                                         \
    RouterLogWarningString( g_hLogEvents, LogId, NumStrings,                \
                           lpwsSubStringArray, dwRetCode, dwPos )

#define EapLogInformationString( LogId, NumStrings, lpwsSubStringArray,     \
                                 dwRetCode, dwPos )                         \
    RouterLogInformationString( g_hLogEvents, LogId,                        \
                                NumStrings, lpwsSubStringArray, dwRetCode,dwPos)


#define TRACE_RASEAP        (0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC)

#define EAP_TRACE(a)        TracePrintfExA(g_dwTraceIdEap,TRACE_RASEAP,a )
#define EAP_TRACE1(a,b)     TracePrintfExA(g_dwTraceIdEap,TRACE_RASEAP,a,b )
#define EAP_TRACE2(a,b,c)   TracePrintfExA(g_dwTraceIdEap,TRACE_RASEAP,a,b,c )
#define EAP_TRACE3(a,b,c,d) TracePrintfExA(g_dwTraceIdEap,TRACE_RASEAP,a,b,c,d )

#define EAP_DUMPW(X,Y)      TraceDumpEx(g_dwTraceIdEap,1,(LPBYTE)X,Y,4,1,NULL)
#define EAP_DUMPB(X,Y)      TraceDumpEx(g_dwTraceIdEap,1,(LPBYTE)X,Y,1,1,NULL)

//
// Defines states within the EAP protocol.
//

typedef enum _EAPSTATE 
{
    EAPSTATE_Initial,
    EAPSTATE_IdentityRequestSent,
    EAPSTATE_Working,
    EAPSTATE_EapPacketSentToAuthServer,
    EAPSTATE_EapPacketSentToClient,
    EAPSTATE_NotificationSentToClient

}EAPSTATE;

typedef enum _EAPTYPE 
{
    EAPTYPE_Identity    = 1,
    EAPTYPE_Notification,
    EAPTYPE_Nak,
    EAPTYPE_MD5Challenge,
    EAPTYPE_SKey,
    EAPTYPE_GenericTokenCard

}EAPTYPE;

typedef struct _EAPCB 
{
    EAPSTATE                EapState;

    HPORT                   hPort;

    BOOL                    fAuthenticator;

    BOOL                    fRouter;

    LPVOID                  pWorkBuffer;

    DWORD                   dwEapIndex;

    DWORD                   dwEapTypeToBeUsed;

    CHAR                    szIdentity[DNLEN+UNLEN+2];

    DWORD                   dwIdExpected;

    HANDLE                  hTokenImpersonateUser;

    PRAS_CUSTOM_AUTH_DATA   pCustomAuthConnData;

    PRAS_CUSTOM_AUTH_DATA   pCustomAuthUserData;

    PPP_EAP_UI_DATA         EapUIData;

    BOOL                    fLogon;

    BOOL                    fNonInteractive;

    BOOL                    fPortWillBeBundled;

    BOOL                    fThisIsACallback;

    CHAR                    szPassword[ PWLEN + 1 ];

    DWORD                   dwUIInvocationId;

    RAS_AUTH_ATTRIBUTE *    pUserAttributes;

    RAS_AUTH_ATTRIBUTE *    pSavedAttributesFromAuthenticator;

    DWORD                   dwSavedAuthResultCode;
    
    PBYTE                   pEAPSendBuf;

    DWORD                   cbEAPSendBuf;

    BOOL                    fSentPacketToRadiusServer;

    BOOL                    fSendWithTimeoutInteractive;

    BYTE *                  pStateAttribute;

    DWORD                   cbStateAttribute;

	CHAR					chSeed;			//Random seed used for encoding password

} EAPCB, *PEAPCB;

typedef struct _EAP_INFO 
{
    HINSTANCE       hInstance;

    DWORD   (APIENTRY *RasEapGetCredentials)(
                            IN  DWORD   dwTypeId,
                            IN  VOID *  pWorkBuf,
                            OUT VOID ** pInfo);

    PPP_EAP_INFO    RasEapInfo;

} EAP_INFO, *PEAP_INFO;

//
// Prototypes
//

DWORD
EapBegin(
    OUT VOID** ppWorkBuf,
    IN  VOID*  pInfo 
);

DWORD
EapEnd(
    IN VOID* pWorkBuf 
);

DWORD
EapMakeMessage(
    IN  VOID*         pWorkBuf,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput 
);

DWORD
MakeRequestAttributes( 
    IN  EAPCB *         pEapCb,
    IN  PPP_CONFIG*     pReceiveBuf
);

DWORD
MakeAuthenticateeMessage(
    IN  EAPCB*        pEapCb,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput
);

DWORD
MakeAuthenticatorMessage(
    IN  EAPCB*        pEapCb,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput 
);

DWORD
EapDllBegin(
    IN EAPCB * pEapCb,
    IN DWORD   dwEapIndex
);

BOOL
InRadiusMode(
    VOID
);

DWORD
EapDllWork( 
    IN  EAPCB *       pEapCb,    
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput 
);

DWORD
EapDllEnd(
    EAPCB * pEapCb
);

DWORD
GetEapTypeIndex( 
    IN DWORD dwEapType
);

DWORD
ChapWrapperBegin(
    OUT VOID **             ppWorkBuffer,
    IN  PPP_EAP_INPUT *     pPppEapInput
);

DWORD
ChapWrapperEnd(
    IN VOID* pWorkBuf 
);

DWORD
ChapWrapperMakeMessage(
    IN  VOID*               pWorkBuf,
    IN  PPP_EAP_PACKET*     pReceivePacket,
    OUT PPP_EAP_PACKET*     pSendPacket,
    IN  DWORD               cbSendPacket,
    OUT PPP_EAP_OUTPUT*     pEapOutput,
    IN  PPP_EAP_INPUT*      pEapInput 
);

VOID
MapEapInputToApInput( 
    IN  PPP_EAP_INPUT*      pPppEapInput,
    OUT PPPAP_INPUT *       pInput
);

//
// Globals.
//

#ifdef RASEAPGLOBALS
#define GLOBALS
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN EAP_INFO * gblpEapTable 
#ifdef GLOBALS
    = NULL;
#endif
;

EXTERN DWORD gbldwNumEapProtocols
#ifdef GLOBALS
    = 0;
#endif
;

EXTERN DWORD gbldwGuid
#ifdef GLOBALS
    = 1;
#endif
;


/* Next packet identifier to assign.  Unlike CPs, APs must handle updating
** this sequence number themselves because the engine can't make as many
** assumptions about the protocol.  It is stored global to all ports and
** authentication sessions to make it less likely that an ID will be used in
** sequential authentication sessions.  Not to be confused with the 'bIdSent'
** updated on a per-port basis and used for matching.
*/
EXTERN BYTE bNextId
#ifdef GLOBALS
    = 0
#endif
;

EXTERN DWORD g_dwTraceIdEap 
#ifdef GLOBALS
    = INVALID_TRACEID;
#endif
;

EXTERN HANDLE g_hLogEvents 
#ifdef GLOBALS
    = NULL;
#endif
;

#undef EXTERN
#undef GLOBALS


#endif // _RASEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raseap\test\eap.h ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:
    Sample Extensible Authentication Protocol header file.

History:

*/

#ifndef _EAP_H_
#define _EAP_H_

#define PPP_EAP_PROTOCOL_ID 20  // This protocols Type Id

// Defines states within the this EAP protocol.

typedef enum _MYSTATE 
{
    MYSTATE_Initial,
    MYSTATE_WaitForUserOK,
    MYSTATE_WaitForRequest,
    MYSTATE_ReqSent,
    MYSTATE_WaitForAuthenticationToComplete,
    MYSTATE_Done

} MYSTATE;

typedef struct _EAPCB 
{
    MYSTATE             EapState;
    DWORD               fFlags;
    BOOL                fAuthenticator;
    LPVOID              pWorkBuffer;
    CHAR                aszIdentity[ UNLEN + 1 ];
    DWORD               dwIdExpected;
    CHAR                aszPassword[ PWLEN + 1 ];
    DWORD               dwResult;
    DWORD               dwInitialPacketId;
    BYTE*               pDataFromInteractiveUI;
    BYTE                bRecvPacketId;          //Special Id for Wireless case 
                                                //because it does not retransmit packets
    DWORD               dwSizeOfDataFromInteractiveUI;
    PBYTE               pUIContext;
    RAS_AUTH_ATTRIBUTE* pUserAttributes;
    RAS_AUTH_ATTRIBUTE* pMPPEKeyAttributes;    // MPPE key

} EAPCB;

typedef struct _EAP_NAME_DIALOG
{
    WCHAR               awszIdentity[ UNLEN + 1 ];
    WCHAR               awszPassword[ PWLEN + 1 ];

} EAP_NAME_DIALOG;

// Globals

#ifdef RASEAPGLOBALS

DWORD        g_dwEapTraceId  = INVALID_TRACEID;
HINSTANCE    g_hInstance     = NULL;

#else

extern DWORD        g_dwEapTraceId;
extern HINSTANCE    g_hInstance;

#endif // RASEAPGLOBALS

// Function Prototypes

VOID   
EapTrace(
    IN  CHAR*   Format, 
    ... 
);

DWORD APIENTRY
EapBegin(
    OUT VOID** ppWorkBuf,
    IN  VOID*  pInfo 
);

DWORD APIENTRY
EapEnd(
    IN VOID* pWorkBuf 
);

DWORD APIENTRY
EapMakeMessage(
    IN  VOID*               pWorkBuf,
    IN  PPP_EAP_PACKET*     pReceiveBuf,
    OUT PPP_EAP_PACKET*     pSendBuf,
    IN  DWORD               cbSendBuf,
    OUT PPP_EAP_OUTPUT*     pResult,
    IN  PPP_EAP_INPUT*      pInput 
);

DWORD
AuthenticateeMakeMessage(
    IN  EAPCB*              pwb,
    IN  PPP_EAP_PACKET*     pReceiveBuf,
    OUT PPP_EAP_PACKET*     pSendBuf,
    IN  DWORD               cbSendBuf,
    IN PPP_EAP_INPUT*       pInput,
    OUT  PPP_EAP_OUTPUT*    pResult
);

DWORD
AuthenticatorMakeMessage(
    IN  EAPCB*              pwb,
    IN  PPP_EAP_PACKET*     pReceiveBuf,
    OUT PPP_EAP_PACKET*     pSendBuf,
    IN  DWORD               cbSendBuf,
    IN PPP_EAP_INPUT*       pInput,
    OUT  PPP_EAP_OUTPUT*    pResult
);

VOID
MakeResponseMessage(
    IN  EAPCB*              pwb,
    IN  PPP_EAP_PACKET*     pReceiveBuf,
    OUT PPP_EAP_PACKET *    pSendBuf,
    IN DWORD                cbSendBuf
);

VOID
MakeResponseMessage1(
    IN  EAPCB*              pwb,
    OUT PPP_EAP_PACKET *    pSendBuf,
    IN DWORD                cbSendBuf
);

VOID
MakeResultMessage(
    IN  EAPCB *             pwb,
    IN  DWORD               dwError,
    OUT PPP_EAP_PACKET*     pSendBuf,
    IN  DWORD               cbSendBuf
);

DWORD
GetPasswordFromResponse(
    IN  PPP_EAP_PACKET*     pReceiveBuf,
    OUT CHAR*               pszUserName
);

DWORD
MakeAuthenticationAttributes(
    IN CHAR *   szUserName,
    IN CHAR *   szPassword,
    IN EAPCB *  pwb
);

DWORD
MakeMPPEKeyAttributes(
    IN EAPCB *  pwb
);

DWORD
GetIdentity(
    IN  HWND    hwndParent,
    IN  BYTE*   pUserDataIn,
    IN  DWORD   dwSizeOfUserDataIn,
    OUT BYTE**  ppUserDataOut,
    OUT DWORD*  pdwSizeOfUserDataOut,
    OUT WCHAR** ppwszIdentityOut
);

VOID
GetUsernameAndPassword(
    IN  HWND                hwndParent,
    IN  EAP_NAME_DIALOG*    pEapNameDialog
);

INT_PTR CALLBACK
UsernameDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

BOOL
InitUsernameDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
);

BOOL
UsernameCommand(
    IN  EAP_NAME_DIALOG*    pEapNameDialog,
    IN  WORD                wId,
    IN  HWND                hWndDlg
);

#endif // _EAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raseap\test\exports.cpp ===
/*

Copyright (c) 1999, Microsoft Corporation, all rights reserved

Description:
    Implementation of DLL Exports.

*/

#include <windows.h>
#include <lmcons.h>
#include <raseapif.h>
#include <rtutils.h>
#include "ceapcfg.h"
#include <initguid.h>
#include <atlimpl.cpp>

extern "C"
{
    extern  DWORD        g_dwEapTraceId;
    extern  HINSTANCE    g_hInstance;
}

CComModule  _Module;

const IID IID_IEAPProviderConfig = {
    0x66A2DB19,
    0xD706,
    0x11D0,
    {0xA3, 0x7B, 0x00, 0xC0, 0x4F, 0xC9, 0xDA, 0x04}
};

// Define the EAP UI GUIDs here
const CLSID CLSID_EapCfg = { /* 3b9aae60-a032-11d2-95f6-00104b98f3f5 */
    0x3b9aae60,
    0xa032,
    0x11d2,
    {0x95, 0xf6, 0x00, 0x10, 0x4b, 0x98, 0xf3, 0xf5}
};

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_EapCfg, CEapCfg)
END_OBJECT_MAP()

/*

Notes:
    DLL Entry Point

*/

extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      /*lpReserved*/
)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
        g_dwEapTraceId = TraceRegister(L"SampleEAP");
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TraceDeregister(g_dwEapTraceId);
        g_dwEapTraceId = INVALID_TRACEID;
        _Module.Term();
    }

    return(TRUE);
}

/*

Notes:
    Used to determine whether the DLL can be unloaded by OLE
    
*/

STDAPI
DllCanUnloadNow(
    VOID
)
{
    if (0 == _Module.GetLockCount())
    {
        return(S_OK);
    }
    else
    {
        return(S_FALSE);
    }
}

/*

Notes:
    Returns a class factory to create an object of the requested type
    
*/

STDAPI
DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv
)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}

/*

Notes:
    Adds entries to the system registry. Registers object, typelib and all
    interfaces in typelib
    
*/

STDAPI
DllRegisterServer(
    VOID
)
{
    return(_Module.RegisterServer(FALSE /* bRegTypeLib */));
}

/*

Notes:
    Removes entries from the system registry
    
*/

STDAPI
DllUnregisterServer(
    VOID
)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raseap\test\resource.h ===
#define IDC_STATIC                          (-1)
#define IDR_EAPCFG                          1001
#define IDD_DIALOG                          1002
#define IDC_EDIT_NAME                       1003
#define IDC_EDIT_PASSWD                     1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raseap\test\eap.c ===
/*

Copyright (c) 1997, Microsoft Corporation, all rights reserved

Description:
    Sample Extensible Authentication Protocol. Here is a graphic of the EAP
    sample protocol:

                Authenticator                       Authenticatee
                -------------                       -------------

                                "Send Password"
                            ---------------------->
                                  EAP Request

                                  <password>
                            <----------------------
                                  EAP Response

                            ----------------------->
                                 Success/Failure

History:

*/

#include <windows.h>
#include <winuser.h>
#include <lmcons.h>
#include <string.h>
#include <stdlib.h>
#include <raseapif.h>
#include <raserror.h>
#include <rtutils.h>
#include <stdio.h>
#define SDEBUGGLOBALS
#define RASEAPGLOBALS
#include "eap.h"
#include "resource.h"

/*---------------------------------------------------------------------------
    External entry points
---------------------------------------------------------------------------*/
/*

Notes:
    RasEapGetInfo entry point called by the EAP-PPP engine by name.
    
*/

DWORD APIENTRY
RasEapGetInfo(
    IN  DWORD         dwEapTypeId,
    OUT PPP_EAP_INFO* pInfo 
)
{
    EapTrace("RasEapGetInfo");

    if (dwEapTypeId != PPP_EAP_PROTOCOL_ID)
    {
        //
        // We only support PPP_EAP_PROTOCOL_ID eap type
        //

        EapTrace("Type ID %d is not supported", dwEapTypeId);

        return(ERROR_NOT_SUPPORTED);
    }

    ZeroMemory(pInfo, sizeof(PPP_EAP_INFO));

    //
    // Fill in the required information
    //

    pInfo->dwEapTypeId       = PPP_EAP_PROTOCOL_ID;
    pInfo->RasEapBegin       = EapBegin;
    pInfo->RasEapEnd         = EapEnd;
    pInfo->RasEapMakeMessage = EapMakeMessage;

    return(NO_ERROR);
}

/*

Notes:
    EapBegin entry point called by the EAP PPP engine thru the passed address.
    
*/

DWORD APIENTRY
EapBegin(
    OUT VOID** ppWorkBuf,
    IN  VOID*  pInfo 
)
{
    PPP_EAP_INPUT* pInput = (PPP_EAP_INPUT*)pInfo;
    EAPCB*         pwb;

    EapTrace("EapBegin(%ws)", pInput->pwszIdentity);

    //
    // Allocate work buffer.
    //

    if ((pwb = (EAPCB*)LocalAlloc(LPTR, sizeof(EAPCB))) == NULL)
    {
        EapTrace("Not enough memory");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Save information passed in, will be used later
    //

    pwb->fFlags             = pInput->fFlags;
    pwb->fAuthenticator     = pInput->fAuthenticator;
    pwb->EapState           = MYSTATE_Initial;
    pwb->dwInitialPacketId  = pInput->bInitialId;

    if (pInput->pDataFromInteractiveUI != NULL)
    {
        pwb->dwSizeOfDataFromInteractiveUI = 
            pInput->dwSizeOfDataFromInteractiveUI;
        pwb->pDataFromInteractiveUI =
            LocalAlloc(LPTR, pwb->dwSizeOfDataFromInteractiveUI);

        if (NULL != pwb->pDataFromInteractiveUI)
        {
            CopyMemory(pwb->pDataFromInteractiveUI, 
                pInput->pDataFromInteractiveUI,
                pwb->dwSizeOfDataFromInteractiveUI);
        }
    }

    //
    // Save the identity. On the authenticatee side, this is obtained by user
    // input; on the authenticator side this was obtained by the Identity
    // request message.
    //

    WideCharToMultiByte(
        CP_ACP,
        0,
        pInput->pwszIdentity,
        -1,
        pwb->aszIdentity,
        UNLEN + 1,
        NULL,
        NULL );

    //
    // If we are an authenticatee, then use the password passed in
    //

    if (!pwb->fAuthenticator)
    {
        if (   (NULL != pInput->pUserData)
            && (sizeof(EAP_NAME_DIALOG) == pInput->dwSizeOfUserData))
        {
            WideCharToMultiByte(
                CP_ACP,
                0,
                ((EAP_NAME_DIALOG*)(pInput->pUserData))->awszPassword,
                -1,
                pwb->aszPassword,
                PWLEN + 1,
                NULL,
                NULL );
        }
    }

    //
    // Register work buffer with engine.
    //

    *ppWorkBuf = pwb;

    return(NO_ERROR);
}

/*

Notes:
    EapEnd entry point called by the PPP engine thru the passed address.
    See EAP interface documentation.
    
*/

DWORD APIENTRY
EapEnd(
    IN VOID* pWorkBuf 
)
{
    EAPCB* pwb = (EAPCB *)pWorkBuf;

    if (pwb == NULL)
    {
        return(NO_ERROR);
    }

    //
    // Release all resources used by this authentication session.
    //

    EapTrace("EapEnd(%s)", pwb->aszIdentity);

    LocalFree(pwb->pUIContext);
    LocalFree(pwb->pDataFromInteractiveUI);

    if (pwb->pUserAttributes != NULL)
    {
        //
        // Free up Attributes
        //

        LocalFree(pwb->pUserAttributes[0].Value);
        LocalFree(pwb->pUserAttributes[1].Value);
        LocalFree(pwb->pUserAttributes);
    }

    if (pwb->pMPPEKeyAttributes != NULL)
    {
        //
        // Free up the MPPE Key Attributes
        //

        LocalFree(pwb->pMPPEKeyAttributes[0].Value);
        LocalFree(pwb->pMPPEKeyAttributes);
    }

    ZeroMemory(pwb, sizeof(EAPCB));

    LocalFree(pwb);

    return(NO_ERROR);
}

/*

Notes:
    RasEapMakeMessage entry point called by the PPP engine thru the passed
    address.
    
*/

DWORD APIENTRY
EapMakeMessage(
    IN  VOID*               pWorkBuf,
    IN  PPP_EAP_PACKET*     pReceiveBuf,
    OUT PPP_EAP_PACKET*     pSendBuf,
    IN  DWORD               cbSendBuf,
    OUT PPP_EAP_OUTPUT*     pResult,
    IN  PPP_EAP_INPUT*      pInput 
)
{
    EAPCB*  pwb = (EAPCB*)pWorkBuf;

    EapTrace("EapMakeMessage(%s)", pwb->aszIdentity);

    //
    // Call the appropriate routine to process the event.
    //

    if (pwb->fAuthenticator)
    {
        return(AuthenticatorMakeMessage(pwb, 
                                        pReceiveBuf,
                                        pSendBuf, 
                                        cbSendBuf, 
                                        pInput, 
                                        pResult));
    }
    else
    {
        return(AuthenticateeMakeMessage(pwb, 
                                        pReceiveBuf, 
                                        pSendBuf, 
                                        cbSendBuf, 
                                        pInput, 
                                        pResult));
    }
}

/*

Notes:
    RasEapGetIdentity entry point called by the EAP-PPP engine by name.

*/

DWORD APIENTRY
RasEapGetIdentity(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT WCHAR**         ppwszIdentity
)
{
    DWORD               dwErr           = NO_ERROR;

    if ( dwFlags & RAS_EAP_FLAG_NON_INTERACTIVE )
    {
        dwErr = ERROR_INTERACTIVE_MODE;
        goto LDone;
    }

    if ( dwFlags & RAS_EAP_FLAG_MACHINE_AUTH )
    {
        dwErr = ERROR_NOT_SUPPORTED;
        goto LDone;
    }

    if (dwFlags & RAS_EAP_FLAG_ROUTER)
    {
        //
        // A routing interface must have its credentials set beforehand
        //

        if (   (NULL == pUserDataIn)
            || (sizeof(EAP_NAME_DIALOG) != dwSizeOfUserDataIn))
        {
            //
            // Bad saved credentials
            //

            EapTrace("Credentials for this interface have not been set");
            dwErr = E_FAIL;
            goto LDone;
        }
    }
    else
    {
        //
        // Ignore old values. Prompt for username and password.
        //

        pUserDataIn = NULL;
    }

    dwErr = GetIdentity(
                    hwndParent,
                    pUserDataIn,
                    dwSizeOfUserDataIn,
                    ppUserDataOut,
                    pdwSizeOfUserDataOut,
                    ppwszIdentity);

LDone:

    return(dwErr);
}

/*

Notes:
    RasEapInvokeConfigUI entry point called by the EAP-PPP engine by name.

*/

DWORD APIENTRY
RasEapInvokeConfigUI(
    IN  DWORD       dwEapTypeId,
    IN  HWND        hwndParent,
    IN  DWORD       dwFlags,
    IN  BYTE*       pConnectionDataIn,
    IN  DWORD       dwSizeOfConnectionDataIn,
    OUT BYTE**      ppConnectionDataOut,
    OUT DWORD*      pdwSizeOfConnectionDataOut
)
{
    DWORD       dwDisplayedNumber;
    WCHAR       awszMessage[100];
    DWORD       dwErr               = NO_ERROR;

    *ppConnectionDataOut = NULL;
    *pdwSizeOfConnectionDataOut = 0;

    if (   (NULL == pConnectionDataIn)
        || (0 == dwSizeOfConnectionDataIn))
    {
        //
        // We are configuring for the first time
        //

        dwDisplayedNumber = 1;
    }
    else
    {
        //
        // How many times has this been configured?
        //

        dwDisplayedNumber = *(DWORD*)pConnectionDataIn;
    }

    swprintf(awszMessage, L"%d times", dwDisplayedNumber);

    MessageBox(hwndParent, awszMessage,
        L"You have configured this interface...", MB_OK | MB_ICONINFORMATION);

    //
    // Allocate memory for the OUT parameter
    //

    *ppConnectionDataOut = (BYTE*)LocalAlloc(LPTR, sizeof(DWORD));

    if (NULL == *ppConnectionDataOut)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto LDone;
    }

    //
    // This has been configured one more time
    //

    dwDisplayedNumber += 1;

    //
    // Set the OUT parameters
    //

    CopyMemory(*ppConnectionDataOut, (BYTE*)&dwDisplayedNumber,
        sizeof(DWORD));
    *pdwSizeOfConnectionDataOut = sizeof(DWORD);

LDone:

    return(dwErr);
}

/*

Notes:
    RasEapInvokeInteractiveUI entry point called by the EAP-PPP engine by name.

*/

DWORD APIENTRY
RasEapInvokeInteractiveUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hWndParent,
    IN  PBYTE           pUIContextData,
    IN  DWORD           dwSizeofUIContextData,
    OUT PBYTE *         ppDataFromInteractiveUI,
    OUT DWORD *         lpdwSizeOfDataFromInteractiveUI
)
{
    EapTrace("RasEapInvokeInteractiveUI");

    if (MessageBox(hWndParent, 
                      (WCHAR*)pUIContextData, 
                      L"EAP sample", 
                      MB_OKCANCEL) == IDOK)
    {
        *lpdwSizeOfDataFromInteractiveUI = (wcslen(L"OK") + 1) * sizeof(WCHAR);

        if ((*ppDataFromInteractiveUI = 
                    LocalAlloc(LPTR, *lpdwSizeOfDataFromInteractiveUI)) == NULL)
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        wcscpy((WCHAR*)*ppDataFromInteractiveUI, L"OK");
    }
    else
    {
        *ppDataFromInteractiveUI         = NULL;
        *lpdwSizeOfDataFromInteractiveUI = 0;
    }
    
    return(NO_ERROR);
}

/*

Notes:
    RasEapFreeMemory entry point called by the EAP-PPP engine by name.

*/

DWORD APIENTRY
RasEapFreeMemory(
    IN  BYTE*   pMemory
)
{
    EapTrace("RasEapFreeMemory");
    LocalFree(pMemory);
    return(NO_ERROR);
}

/*---------------------------------------------------------------------------
    Internal routines 
---------------------------------------------------------------------------*/

/*

Notes:
    Print debug information.
    
*/

VOID   
EapTrace(
    IN  CHAR*   Format, 
    ... 
) 
{
    va_list arglist;

    va_start(arglist, Format);

    TraceVprintfExA(g_dwEapTraceId, 
        0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC,
        Format,
        arglist);

    va_end(arglist);
}

/*

Notes:
    Will convert a 32 bit integer from host format to wire format.
    
*/

VOID
HostToWireFormat32(
    IN     DWORD dwHostFormat,
    IN OUT PBYTE pWireFormat
)
{
    *((PBYTE)(pWireFormat)+0) = (BYTE) ((DWORD)(dwHostFormat) >> 24);
    *((PBYTE)(pWireFormat)+1) = (BYTE) ((DWORD)(dwHostFormat) >> 16);
    *((PBYTE)(pWireFormat)+2) = (BYTE) ((DWORD)(dwHostFormat) >>  8);
    *((PBYTE)(pWireFormat)+3) = (BYTE) (dwHostFormat);
}

/*

Notes:
    Will convert a 16 bit integer from host format to wire format.
    
*/

VOID
HostToWireFormat16(
    IN     WORD  wHostFormat,
    IN OUT PBYTE pWireFormat
)
{
    *((PBYTE)(pWireFormat)+0) = (BYTE) ((DWORD)(wHostFormat) >>  8);
    *((PBYTE)(pWireFormat)+1) = (BYTE) (wHostFormat);
}

/*

Notes:
    Will convert a 16 bit integer from wire format to host format.
    
*/

WORD
WireToHostFormat16(
    IN PBYTE pWireFormat
)
{
    WORD wHostFormat = ((*((PBYTE)(pWireFormat)+0) << 8) +
                        (*((PBYTE)(pWireFormat)+1)));

    return(wHostFormat);
}

/*

Notes:
    Authenticatee side event handler.
    
*/

DWORD
AuthenticateeMakeMessage(
    IN  EAPCB*            pwb,
    IN  PPP_EAP_PACKET*   pReceiveBuf,
    OUT PPP_EAP_PACKET*   pSendBuf,
    IN  DWORD             cbSendBuf,
    IN  PPP_EAP_INPUT*    pInput,
    OUT PPP_EAP_OUTPUT*   pResult
)
{
    DWORD dwRetCode = NO_ERROR;
    BYTE* pDataFromInteractiveUI;
    DWORD dwSizeOfDataFromInteractiveUI;

    EapTrace("AuthenticateeMakeMessage");

    switch(pwb->EapState)
    {
        case MYSTATE_Initial:

            if (pwb->fFlags & RAS_EAP_FLAG_ROUTER)
            {
                pwb->EapState = MYSTATE_WaitForRequest;

                break;
            }
            pwb->bRecvPacketId = pReceiveBuf->Id;
            if (NULL == pwb->pDataFromInteractiveUI)
            {
                //
                // Bring up interactive UI to notify user that he/she is being
                // authenticated via the sample EAP
                //

                pResult->fInvokeInteractiveUI = TRUE;

                pResult->dwSizeOfUIContextData =
                   (wcslen(L"You are being authenticated by a Sample EAP")+1) *
                       sizeof(WCHAR);

                pResult->pUIContextData = LocalAlloc(
                                              LPTR,
                                              pResult->dwSizeOfUIContextData);

                if (pResult->pUIContextData == NULL)
                {
                    EapTrace("OUt of memory");
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }

                wcscpy((WCHAR*)pResult->pUIContextData,
                       L"You are being authenticated by a Sample EAP");

                pwb->pUIContext = pResult->pUIContextData;

                pwb->EapState = MYSTATE_WaitForUserOK;

                break;
            }

            //
            // Else, fall through
            //

        case MYSTATE_WaitForUserOK:

            //
            // Wait for response from user
            //

            if (   pInput->fDataReceivedFromInteractiveUI
                || (NULL != pwb->pDataFromInteractiveUI))
            {
                if (pInput->fDataReceivedFromInteractiveUI)
                {
                    pDataFromInteractiveUI =
                            pInput->pDataFromInteractiveUI;
                    dwSizeOfDataFromInteractiveUI =
                            pInput->dwSizeOfDataFromInteractiveUI;
                }
                else
                {
                    pDataFromInteractiveUI =
                            pwb->pDataFromInteractiveUI;
                    dwSizeOfDataFromInteractiveUI =
                            pwb->dwSizeOfDataFromInteractiveUI;
                }

                LocalFree(pwb->pUIContext);
                pwb->pUIContext = NULL;

                //
                // If user doesn't like this, then we hangup the line
                //

                if (dwSizeOfDataFromInteractiveUI !=
                            (wcslen(L"OK")+1) * sizeof(WCHAR))
                {
                    EapTrace("User chose to cancel");
                    dwRetCode = ERROR_ACCESS_DENIED;
                    break;
                }

                if (wcscmp((WCHAR*)pDataFromInteractiveUI, L"OK") != 0)
                {
                    EapTrace("User chose to cancel");
                    dwRetCode = ERROR_ACCESS_DENIED;
                    break;
                }

                
                pwb->EapState = MYSTATE_WaitForRequest;
            }
            else
            {
                //
                // Ignore all other events.
                //

                pResult->Action = EAPACTION_NoAction;
            }

            if ( !(pwb->fFlags & RAS_EAP_FLAG_8021X_AUTH ) )
            {
                //
                // if this is a VPN client, we can rely on 
                // retransmission.  But with wireless client
                // we cannot do that.
                //
                break;
            }
            //fall thru

        case MYSTATE_WaitForRequest:

            if ( (pwb->fFlags & RAS_EAP_FLAG_8021X_AUTH ) )
            {
                //
                // Build the response packet
                //
                MakeResponseMessage1(pwb, pSendBuf, cbSendBuf);

                //
                // Response packets should not be sent with any timeout
                //

                pResult->Action = EAPACTION_Send;

                //
                // We are done so we change to MYSTATE_Done
                //

                pwb->EapState = MYSTATE_Done;

                break;

            }
            else if (pReceiveBuf != NULL )
            {
                //
                // If we received a request packet from the server then we
                // process it.
                //

                if (pReceiveBuf->Code == EAPCODE_Request)
                {
                    //
                    // Build the response packet
                    //

                    MakeResponseMessage(pwb, pReceiveBuf, pSendBuf, cbSendBuf);

                    //
                    // Response packets should not be sent with any timeout
                    //

                    pResult->Action = EAPACTION_Send;

                    //
                    // We are done so we change to MYSTATE_Done
                    //

                    pwb->EapState = MYSTATE_Done;

                    break;
                }
                else
                {
                    //
                    // We shouldn't get any other packet in this state so
                    // we simply drop this invalid packet
                    //

                    pResult->Action = EAPACTION_NoAction;
                    dwRetCode = ERROR_PPP_INVALID_PACKET;
                    break;
                }
            }

            break;

        case MYSTATE_Done:
        {
            if (pReceiveBuf == NULL)
            {
                //
                // If we did not receive a packet then we check to see if
                // the fSuccessPacketReceived flag is set
                //

                if ((pInput != NULL) && (pInput->fSuccessPacketReceived))
                {
                    //
                    // We are done
                    //

                    //
                    // Create the MPPE Key Attribute and give it to the EAP-PPP 
                    // engine.
                    //

                    dwRetCode = MakeMPPEKeyAttributes(pwb);

                    if (NO_ERROR == dwRetCode)
                    {
                        pResult->pUserAttributes = pwb->pMPPEKeyAttributes;
                    }
                    
                    pResult->Action = EAPACTION_Done;
                    pwb->EapState   = MYSTATE_Done;
                }
                else
                {
                    //
                    // Otherwise we ignore this event
                    //

                    pResult->Action = EAPACTION_NoAction;
                }

                break;
            }

            if ((pReceiveBuf->Code == EAPCODE_Success) ||
                (pReceiveBuf->Code == EAPCODE_Failure))
            {
                if (pReceiveBuf->Code == EAPCODE_Success)
                {
                    //
                    // If we received success or failure, we are done, but first
                    // make sure the ID's match
                    //

                    //
                    // Create the MPPE Key Attribute and give it to the EAP-PPP 
                    // engine.
                    //

                    dwRetCode = MakeMPPEKeyAttributes(pwb);

                    if (NO_ERROR == dwRetCode)
                    {
                        pResult->pUserAttributes = pwb->pMPPEKeyAttributes;
                    }

                    pResult->Action = EAPACTION_Done;
                    pwb->EapState   = MYSTATE_Done;
                }
                else
                {
                    //
                    // Otherwise drop the packet
                    //

                    pResult->Action = EAPACTION_NoAction;
                    dwRetCode       = ERROR_PPP_INVALID_PACKET;
                }

                break;
            }
            else if (pReceiveBuf->Code == EAPCODE_Request)  
            {
                //
                // We must always respond to requests
                //

                MakeResponseMessage(pwb, pReceiveBuf, pSendBuf, cbSendBuf);

                //
                // Response packets should not be sent with any timeout
                //

                pResult->Action = EAPACTION_Send;
            }
            else
            {
                //
                // Otherwise we received an illegal packet, wrong code set
                // So simply drop the packet.
                //

                pResult->Action = EAPACTION_NoAction;
                dwRetCode       = ERROR_PPP_INVALID_PACKET;
            }
        }
    }

    return(dwRetCode);
}


VOID
MakeResponseMessage1(
    IN  EAPCB*           pwb,    
    OUT PPP_EAP_PACKET * pSendBuf,
    IN  DWORD            cbSendBuf
)
{
    BYTE* pcbPassword;
    CHAR* pchPassword;

    EapTrace("MakeResponseMessage1");

    (void)cbSendBuf;

    //
    // Fill in the password.
    //

    pcbPassword = pSendBuf->Data + 1; 

    *pcbPassword = (BYTE)strlen(pwb->aszPassword);

    pchPassword = pcbPassword + 1;

    strcpy(pchPassword, pwb->aszPassword);

    //
    // Set the response code
    //

    pSendBuf->Code = (BYTE)EAPCODE_Response;

    //
    // The Reponse packet Id MUST match the Request packet Id.
    //

    pSendBuf->Id = pwb->bRecvPacketId;

    //
    // The Success/Failure packet that we get must match the ID of the last 
    // response sent
    //

    pwb->dwIdExpected = pSendBuf->Id;

    //
    // Set the EAP type ID
    //

    pSendBuf->Data[0] = (BYTE)PPP_EAP_PROTOCOL_ID;

    //
    // Set the length of the packet
    //

    HostToWireFormat16((WORD)(PPP_EAP_PACKET_HDR_LEN+1+*pcbPassword+1),
                       pSendBuf->Length);
}
/*

Notes:
    Builds a response packet. 'pwb' is the address of the work
    buffer associated with the port.
    
*/

VOID
MakeResponseMessage(
    IN  EAPCB*           pwb,
    IN  PPP_EAP_PACKET * pReceiveBuf,
    OUT PPP_EAP_PACKET * pSendBuf,
    IN  DWORD            cbSendBuf
)
{
    BYTE* pcbPassword;
    CHAR* pchPassword;

    EapTrace("MakeResponseMessage");

    (void)cbSendBuf;

    //
    // Fill in the password.
    //

    pcbPassword = pSendBuf->Data + 1; 

    *pcbPassword = (BYTE)strlen(pwb->aszPassword);

    pchPassword = pcbPassword + 1;

    strcpy(pchPassword, pwb->aszPassword);

    //
    // Set the response code
    //

    pSendBuf->Code = (BYTE)EAPCODE_Response;

    //
    // The Reponse packet Id MUST match the Request packet Id.
    //

    pSendBuf->Id = pReceiveBuf->Id;

    //
    // The Success/Failure packet that we get must match the ID of the last 
    // response sent
    //

    pwb->dwIdExpected = pSendBuf->Id;

    //
    // Set the EAP type ID
    //

    pSendBuf->Data[0] = (BYTE)PPP_EAP_PROTOCOL_ID;

    //
    // Set the length of the packet
    //

    HostToWireFormat16((WORD)(PPP_EAP_PACKET_HDR_LEN+1+*pcbPassword+1),
                       pSendBuf->Length);
}

/*

Notes:
    Builds a result packet (Success or Failure) in caller's 'pSendBuf' 
    buffer. 'cbSendBuf' is the length of caller's buffer.  
    'dwError' indicates whether an Success or Failure should be generated, 
    'bId' is the Id of the Success of Failure packet.
    
*/

VOID
MakeResultMessage(
    IN  EAPCB *         pwb,
    IN  DWORD           dwError,
    OUT PPP_EAP_PACKET* pSendBuf,
    IN  DWORD           cbSendBuf 
)
{
    EapTrace("MakeResultMessage");

    (void)cbSendBuf;

    //
    // If there was no error then we send a Success packet, otherwise we send
    // a failure message
    //

    if (dwError == NO_ERROR)
    {
        pSendBuf->Code = EAPCODE_Success;
    }
    else
    {
        pSendBuf->Code = EAPCODE_Failure;
    }

    //
    // The Id of a success or failure message MUST match the Id of the last
    // response received from the client according to the EAP spec.
    //

    pSendBuf->Id = (BYTE)pwb->dwInitialPacketId;

    //
    // Set the length
    //

    HostToWireFormat16((WORD)PPP_EAP_PACKET_HDR_LEN, (PBYTE)pSendBuf->Length);
}

/*

Notes:
    Will build a request packet.
    
*/

VOID
MakeRequestMessage(
    IN  EAPCB*           pwb,
    OUT PPP_EAP_PACKET * pSendBuf,
    IN DWORD             cbSendBuf
)
{
    BYTE *pcbPeerMessage;
    CHAR *pchPeerMessage;

    EapTrace("MakeRequestMessage");

    pcbPeerMessage  = pSendBuf->Data + 1;

    *pcbPeerMessage = (BYTE)strlen("send password");

    pchPeerMessage  = pcbPeerMessage + 1;

    strcpy(pchPeerMessage, "send password");

    //
    // Set the Request Code
    // 

    pSendBuf->Code = EAPCODE_Request;

    //
    // Set the request packet identifier. Start with the Id that was give to us
    //

    pSendBuf->Id = (BYTE)pwb->dwInitialPacketId;

    //
    // Set the length
    //

    HostToWireFormat16((WORD)(PPP_EAP_PACKET_HDR_LEN+1+*pcbPeerMessage+1),  
                              pSendBuf->Length);

    //
    // Set the EAP Type Id
    //

    pSendBuf->Data[0] = PPP_EAP_PROTOCOL_ID;

}

/*

Notes:
    Authenticator side event handler.
    
*/

DWORD
AuthenticatorMakeMessage(
    IN  EAPCB*              pwb,
    IN  PPP_EAP_PACKET*     pReceiveBuf,
    OUT PPP_EAP_PACKET*     pSendBuf,
    IN  DWORD               cbSendBuf,
    IN  PPP_EAP_INPUT*      pInput,
    OUT PPP_EAP_OUTPUT*     pResult 
)
{
    DWORD dwRetCode = NO_ERROR;

    EapTrace("AuthenticatorMakeMessage");

    switch(pwb->EapState)
    {
        case MYSTATE_ReqSent:

            if (pReceiveBuf != NULL)
            {
                //
                // If we received a packet
                //

                if (pReceiveBuf->Code == EAPCODE_Response)
                {
                    //
                    // If we received a response to our identity request, 
                    // then process it. There is no need to check the Id    
                    // here since the PPP engine will only pass on packets
                    // whose Id matches those set with the 
                    // EAPACTION_SendWithTimeout action.
                    //

                    dwRetCode = GetPasswordFromResponse(pReceiveBuf, 
                                                         pwb->aszPassword);

                    if (dwRetCode != NO_ERROR)
                    {    
                        if (dwRetCode != ERROR_PPP_INVALID_PACKET)
                        {
                            //
                            // Fatal error, we fail the connection. 
                            //

                            return(dwRetCode);
                        }
                    }
                    else
                    {
                        //
                        // Request authentication provider to authenticate 
                        // this user.
                        //
            
                        dwRetCode = MakeAuthenticationAttributes(
                                                            pwb->aszIdentity, 
                                                            pwb->aszPassword,   
                                                            pwb);

                        if (dwRetCode != NO_ERROR)
                        {
                            return(dwRetCode);
                        }
                        else
                        {
                            //
                            // Authentication request completed successfully.
                            // This is an asynchronous call so we change state
                            // and wait for the provider to complete the 
                            // authentication.  
                            //

                            pResult->pUserAttributes = pwb->pUserAttributes;

                            pResult->Action = EAPACTION_Authenticate;

                            // 
                            // Save Id so that we can send the correct one
                            // in the success/failure packet
                            //

                            pwb->dwIdExpected = pReceiveBuf->Id; 

                            pwb->EapState = 
                                    MYSTATE_WaitForAuthenticationToComplete;
                        }        
                    }

                    break;
                }
                else
                {
                    //
                    // Otherwise silently drop the packet. 
                    // We should only get requests
                    //

                    pResult->Action = EAPACTION_NoAction;

                    break;
                }
            }

            break;

        case MYSTATE_Initial:

            //
            // Create Request packet
            //

            MakeRequestMessage(pwb, pSendBuf, cbSendBuf);

            //
            // Request messages must be sent with a timeout
            //

            pResult->Action = EAPACTION_SendWithTimeoutInteractive;

            //
            // Since we have sent a request we change to the ReqSent state
            // where we will wait for a response.
            //

            pwb->EapState = MYSTATE_ReqSent;

            break;

        case MYSTATE_WaitForAuthenticationToComplete:
        {
            if (pInput != NULL)
            {
                //
                // Did the authentication provider complete the authentication?
                //

                if (pInput->fAuthenticationComplete)
                {
                    //
                    // If the user failed to authenticate, save the failure 
                    // code.
                    //

                    if (pInput->dwAuthResultCode != NO_ERROR)
                    {
                        pwb->dwResult = pInput->dwAuthResultCode;
                    }

                    pResult->Action = EAPACTION_SendAndDone;
                    pwb->EapState   = MYSTATE_Done;

                    //
                    // fall thru to the MYSTATE_Done state where we will
                    // send a Success or Failure packet
                    //
                }
            }

            if ((pInput == NULL) || (!pInput->fAuthenticationComplete))
            {
                //
                // Ignore everything if authentication is not complete
                //

                pResult->Action = EAPACTION_NoAction;

                break;
            }

            //
            // ...fall thru to the MYSTATE_Done state where we will
            // send a Success or Failure packet
            //
        }

        case MYSTATE_Done:
        {
            //
            // Make Success or Failure packet.  
            //

            MakeResultMessage(pwb, pwb->dwResult, pSendBuf, cbSendBuf);

            if (NO_ERROR == pwb->dwResult)
            {
                //
                // If we made a Success packet, create the MPPE Key Attribute
                // and give it to the EAP-PPP engine.
                //

                dwRetCode = MakeMPPEKeyAttributes(pwb);

                if (NO_ERROR == dwRetCode)
                {
                    pResult->pUserAttributes = pwb->pMPPEKeyAttributes;
                }
            }

            pResult->Action = EAPACTION_SendAndDone;

            pResult->dwAuthResultCode = pwb->dwResult;

            break;
        }

        default:

            break;
    }

    return(dwRetCode);

}

/*

Notes:
    Fill caller's pszPassword' buffer with the password, in the request 
    packet.

    Returns NO_ERROR if successful., or ERROR_PPP_INVALID_PACKET if the 
    packet is misformatted in any way.

*/

DWORD
GetPasswordFromResponse(
    IN  PPP_EAP_PACKET* pReceiveBuf,
    OUT CHAR*           pszPassword
)
{
    BYTE* pcbPassword;
    CHAR* pchPassword;
    WORD  cbPacket;

    EapTrace("GetPasswordFromResponse");

    cbPacket = WireToHostFormat16(pReceiveBuf->Length);

    //
    // Extract the password
    //

    if (cbPacket < (PPP_EAP_PACKET_HDR_LEN + 1 + 1))
    {
        EapTrace("Number of bytes in the EAP packet is only %d", cbPacket);

        return(ERROR_PPP_INVALID_PACKET);
    }

    pcbPassword = pReceiveBuf->Data + 1;
    pchPassword = pcbPassword + 1;

    if (cbPacket < PPP_EAP_PACKET_HDR_LEN + 1 + 1 + *pcbPassword)
    {
        EapTrace("Number of characters in password is %d", *pcbPassword);
        EapTrace("Number of bytes in the EAP packet is only %d", cbPacket);

        return ERROR_PPP_INVALID_PACKET;
    }

    CopyMemory(pszPassword, pchPassword, *pcbPassword);

    //
    // NULL terminate the password
    //

    pszPassword[ *pcbPassword ] = '\0';

    return(NO_ERROR);
}

/*

Notes:
    Will build user attributes and send them to the authentication provider
    for authentication.

*/

DWORD 
MakeAuthenticationAttributes(
    IN CHAR *   szUserName,    
    IN CHAR *   szPassword,    
    IN EAPCB *  pwb
)
{
    EapTrace("MakeAuthenticationAttributes");

    if (pwb->pUserAttributes != NULL)
    {
        LocalFree(pwb->pUserAttributes[0].Value);
        LocalFree(pwb->pUserAttributes[1].Value);
        LocalFree(pwb->pUserAttributes);

        pwb->pUserAttributes = NULL;
    }

    pwb->pUserAttributes = (RAS_AUTH_ATTRIBUTE *)
                           LocalAlloc(LPTR, sizeof (RAS_AUTH_ATTRIBUTE) * 3);

    if (pwb->pUserAttributes == NULL) 
    {
        return(GetLastError());
    }

    //
    // for user name
    //

    pwb->pUserAttributes[0].raaType  = raatUserName;
    pwb->pUserAttributes[0].dwLength = strlen(szUserName);
    pwb->pUserAttributes[0].Value    = LocalAlloc(LPTR, (strlen(szUserName)+1));

    if (pwb->pUserAttributes[0].Value == NULL)
    { 
        LocalFree(pwb->pUserAttributes); 

        pwb->pUserAttributes = NULL;

        return(GetLastError());
    }

    CopyMemory(pwb->pUserAttributes[0].Value,szUserName, strlen(szUserName));

    //
    // for password
    //

    pwb->pUserAttributes[1].raaType  = raatUserPassword;
    pwb->pUserAttributes[1].dwLength = strlen(szPassword);
    pwb->pUserAttributes[1].Value    = LocalAlloc(LPTR, (strlen(szPassword)+1));

    if (pwb->pUserAttributes[1].Value == NULL) 
    {
        LocalFree(pwb->pUserAttributes[0].Value);

        LocalFree(pwb->pUserAttributes); 

        pwb->pUserAttributes = NULL;

        return(GetLastError());
    }

    CopyMemory(pwb->pUserAttributes[1].Value,szPassword, strlen(szPassword));
  
    //
    // For Termination
    //

    pwb->pUserAttributes[2].raaType  = raatMinimum;
    pwb->pUserAttributes[2].dwLength = 0;
    pwb->pUserAttributes[2].Value    = NULL;

    return(NO_ERROR);
}

/*

Notes:

*/

DWORD
MakeMPPEKeyAttributes(
    IN EAPCB *  pwb
)
{
    DWORD   dwErr           = NO_ERROR;
    DWORD   dwIndex;
    DWORD   dwSendPattern;
    DWORD   dwRecvPattern;
    BYTE*   pByte;

    EapTrace("MakeMPPEKeyAttributes");

    if (NULL != pwb->pMPPEKeyAttributes)
    {
        //
        // Free up the MPPE Key Attributes if they exist
        //

        LocalFree(pwb->pMPPEKeyAttributes[0].Value);
        LocalFree(pwb->pMPPEKeyAttributes[1].Value);
        LocalFree(pwb->pMPPEKeyAttributes);
        pwb->pMPPEKeyAttributes = NULL;
    }

    //
    // We need 3 RAS_AUTH_ATTRIBUTE structs: for MS-MPPE-Send-Key, 
    // MS-MPPE-Recv-Key, and termination
    //

    pwb->pMPPEKeyAttributes = (RAS_AUTH_ATTRIBUTE *) LocalAlloc(
                LPTR, sizeof(RAS_AUTH_ATTRIBUTE) * 3);

    if (NULL == pwb->pMPPEKeyAttributes)
    {
        dwErr = GetLastError();
        goto LDone;
    }

    if (pwb->fAuthenticator)
    {
        dwSendPattern = 0xAB;
        dwRecvPattern = 0xCD;
    }
    else
    {
        dwSendPattern = 0xCD;
        dwRecvPattern = 0xAB;
    }

    //
    // Bytes needed:
    //      4: Vendor-Id
    //      1: Vendor-Type
    //      1: Vendor-Length
    //      2: Salt
    //      1: Key-Length
    //     32: Key
    //     15: Padding
    //     -----------------
    //     56: Total
    //

    //
    // Copy MS-MPPE-Send-Key
    //

    pwb->pMPPEKeyAttributes[0].Value = LocalAlloc(LPTR, 56);

    if (pwb->pMPPEKeyAttributes[0].Value == NULL)
    {
        dwErr = GetLastError();
        goto LDone;
    }

    pByte = pwb->pMPPEKeyAttributes[0].Value;

    HostToWireFormat32(311, pByte); // Vendor-Id
    pByte[4] = 16;                  // Vendor-Type (MS-MPPE-Send-Key)
    pByte[5] = 56 - 4;              // Vendor-Length (all except Vendor-Id)
    // pByte[6-7] is the zero-filled salt field
    pByte[8] = 32;                  // Key-Length

    {
        //
        // This is just an example. Copy a real key here.
        //

        CopyMemory(pByte + 9, pwb->aszPassword, 32);

        for (dwIndex = 0; dwIndex < 32; dwIndex++)
        {
            pByte[9 + dwIndex] ^= dwSendPattern;
        }
    }

    // pByte[41-55] is the Padding (zero octets)

    pwb->pMPPEKeyAttributes[0].dwLength = 56;
    pwb->pMPPEKeyAttributes[0].raaType  = raatVendorSpecific;

    //
    // Copy MS-MPPE-Recv-Key
    //

    pwb->pMPPEKeyAttributes[1].Value = LocalAlloc(LPTR, 56);

    if (pwb->pMPPEKeyAttributes[1].Value == NULL)
    {
        dwErr = GetLastError();
        goto LDone;
    }

    pByte = pwb->pMPPEKeyAttributes[1].Value;

    HostToWireFormat32(311, pByte); // Vendor-Id
    pByte[4] = 17;                  // Vendor-Type (MS-MPPE-Recv-Key)
    pByte[5] = 56 - 4;              // Vendor-Length (all except Vendor-Id)
    // pByte[6-7] is the zero-filled salt field
    pByte[8] = 32;                  // Key-Length

    {
        //
        // This is just an example. Copy a real key here.
        //

        CopyMemory(pByte + 9, pwb->aszPassword, 32);

        for (dwIndex = 0; dwIndex < 32; dwIndex++)
        {
            pByte[9 + dwIndex] ^= dwRecvPattern;
        }
    }

    // pByte[41-55] is the Padding (zero octets)

    pwb->pMPPEKeyAttributes[1].dwLength = 56;
    pwb->pMPPEKeyAttributes[1].raaType  = raatVendorSpecific;

    //
    // For Termination
    //

    pwb->pMPPEKeyAttributes[2].raaType  = raatMinimum;
    pwb->pMPPEKeyAttributes[2].dwLength = 0;
    pwb->pMPPEKeyAttributes[2].Value    = NULL;

LDone:

    if (NO_ERROR != dwErr)
    {
        //
        // If something failed, free the allocated memory
        //

        if (pwb->pMPPEKeyAttributes != NULL)
        {
            LocalFree(pwb->pMPPEKeyAttributes[0].Value);
            LocalFree(pwb->pMPPEKeyAttributes[1].Value);
            LocalFree(pwb->pMPPEKeyAttributes);
            pwb->pMPPEKeyAttributes = NULL;
        }
    }

    return(dwErr);
}

/*

Notes:

*/

DWORD
GetIdentity(
    IN  HWND    hwndParent,
    IN  BYTE*   pUserDataIn,
    IN  DWORD   dwSizeOfUserDataIn,
    OUT BYTE**  ppUserDataOut,
    OUT DWORD*  pdwSizeOfUserDataOut,
    OUT WCHAR** ppwszIdentity
)
{
    EAP_NAME_DIALOG*    pEapNameDialog  = NULL;
    WCHAR*              pwszIdentity     = NULL;
    DWORD               dwErr           = NO_ERROR;


    //
    // Allocate memory for OUT parameters
    //

    pEapNameDialog = LocalAlloc(LPTR, sizeof(EAP_NAME_DIALOG));

    if (NULL == pEapNameDialog)
    {
        EapTrace("Out of memory");
        dwErr = GetLastError();
        goto LDone;
    }

    pwszIdentity = LocalAlloc(LPTR, (UNLEN + 1) * sizeof(WCHAR));

    if (NULL == pwszIdentity)
    {
        EapTrace("Out of memory");
        dwErr = GetLastError();
        goto LDone;
    }

    if (NULL != pUserDataIn)
    {
        //
        // Use the saved credentials if they exist
        //

        CopyMemory(pEapNameDialog, pUserDataIn, sizeof(EAP_NAME_DIALOG));
    }
    else
    {
        //
        // Else prompt for username and password
        //

        GetUsernameAndPassword(hwndParent, pEapNameDialog);
    }

    wcscpy(pwszIdentity, pEapNameDialog->awszIdentity);

    //
    // Set the OUT paramters
    //

    *ppUserDataOut = (BYTE*)pEapNameDialog;
    *pdwSizeOfUserDataOut = sizeof(EAP_NAME_DIALOG);
    *ppwszIdentity = pwszIdentity;

    //
    // We mustn't LocalFree OUT parameters
    //

    pEapNameDialog = NULL;
    pwszIdentity = NULL;

LDone:

    LocalFree(pEapNameDialog);
    LocalFree(pwszIdentity);

    return(dwErr);
}

/*---------------------------------------------------------------------------
    Dialog routines 
---------------------------------------------------------------------------*/

/*

Notes:
    Displays the IDD_DIALOG dialog, and fills up pEapNameDialog with the 
    username and password.

*/

VOID
GetUsernameAndPassword(
    IN  HWND                hwndParent,
    IN  EAP_NAME_DIALOG*    pEapNameDialog
)
{
    DialogBoxParam(
        g_hInstance,
        MAKEINTRESOURCE(IDD_DIALOG),
        hwndParent,
        UsernameDialogProc,
        (LPARAM)pEapNameDialog);
}

/*

Notes:
    Callback function used with the DialogBoxParam function. It processes 
    messages sent to the dialog box. See the DialogProc documentation in MSDN.

*/

INT_PTR CALLBACK
UsernameDialogProc(
    IN  HWND    hWnd,
    IN  UINT    unMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    EAP_NAME_DIALOG*    pEapNameDialog;

    switch (unMsg)
    {
    case WM_INITDIALOG:
        
        return(InitUsernameDialog(hWnd, lParam));

    case WM_COMMAND:

        pEapNameDialog = (EAP_NAME_DIALOG*)GetWindowLongPtr(hWnd, DWLP_USER);

        return(UsernameCommand(pEapNameDialog, LOWORD(wParam), hWnd));
    }

    return(FALSE);
}

/*

Returns:
    FALSE (prevent Windows from setting the default keyboard focus).

Notes:
    Response to the WM_INITDIALOG message.

*/

BOOL
InitUsernameDialog(
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
{
    HWND    hWndEdit;

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);

    return(FALSE);
}

/*

Returns:
    TRUE: We prrocessed this message.
    FALSE: We did not prrocess this message.

Notes:
    Response to the WM_COMMAND message.

*/

BOOL
UsernameCommand(
    IN  EAP_NAME_DIALOG*    pEapNameDialog,
    IN  WORD                wId,
    IN  HWND                hWndDlg
)
{
    HWND    hWnd;

    switch(wId)
    {
    case IDOK:

        //
        // Save whatever the user typed in as the user name
        //

        hWnd = GetDlgItem(hWndDlg, IDC_EDIT_NAME);
        GetWindowText(hWnd, pEapNameDialog->awszIdentity, UNLEN + 1);

        //
        // Save whatever the user typed in as the password
        //

        hWnd = GetDlgItem(hWndDlg, IDC_EDIT_PASSWD);
        GetWindowText(hWnd, pEapNameDialog->awszPassword, PWLEN + 1);

        // Fall through

    case IDCANCEL:

        EndDialog(hWndDlg, wId);
        return(TRUE);

    default:

        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipcp\rasipcp.c ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** rasipcp.c
** Remote Access PPP Internet Protocol Control Protocol
** Core routines
**
** 11/05/93 Steve Cobb
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


#include <lmcons.h>
#include <string.h>
#include <stdlib.h>
#include <llinfo.h>
#include <rasman.h>
#include <ddwanarp.h>
#include <rtutils.h>
#include <dhcpcapi.h>
#include <devioctl.h>
#include <rasppp.h>
#include <uiip.h>
#include <pppcp.h>
#define INCL_HOSTWIRE
#define INCL_PARAMBUF
#define INCL_RASAUTHATTRIBUTES
#include <ppputil.h>
#include <raserror.h>
#include <mprlog.h>
#include <dnsapi.h>
#include "rassrvr.h"
#include "tcpreg.h"
#include "helper.h"
#include "rastcp.h"
#define RASIPCPGLOBALS
#include "rasipcp.h"

#define REGKEY_Ipcp     \
            "SYSTEM\\CurrentControlSet\\Services\\RasMan\\PPP\\ControlProtocols\\BuiltIn"
#define REGKEY_Params   "SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\IP"
#define REGKEY_Linkage  "SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Linkage"
#define REGKEY_Disabled "SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Linkage\\Disabled"
#define REGVAL_NsAddrs  "RequestNameServerAddresses"
#define REGVAL_Unnumbered   "Unnumbered"
#define REGVAL_VjComp   "RequestVJCompression"
#define REGVAL_VjComp2  "AcceptVJCompression"
#define REGVAL_AllowVJOverVPN   "AllowVJOverVPN"
#define REGVAL_HardIp   "AllowClientIPAddresses"
#define REGVAL_RegisterRoutersWithWINS "RegisterRoutersWithWINSServers"
#define REGVAL_Bind     "Bind"
#define ID_NetBTNdisWan "NetBT_NdisWan"

// DHCP Options.  (from dhcp.h)
// dhcp.h lives in the sockets project.  These are standard and
// cannot change, so its safe to put them here.

#define OPTION_SUBNET_MASK              1
#define OPTION_DNS_NAME_SERVERS         6
#define OPTION_NETBIOS_NAME_SERVERS     44
#define OPTION_DNS_DOMAIN_NAME          15
#define OPTION_VENDOR_SPEC_INFO         43
//Route Plumbing option
#define OPTION_VENDOR_ROUTE_PLUMB	   249 


#define CLASSA_ADDR(a)  (( (*((unsigned char *)&(a))) & 0x80) == 0)
#define CLASSB_ADDR(a)  (( (*((unsigned char *)&(a))) & 0xc0) == 0x80)
#define CLASSC_ADDR(a)  (( (*((unsigned char *)&(a))) & 0xe0) == 0xc0)
#define CLASSE_ADDR(a)  ((( (*((uchar *)&(a))) & 0xf0) == 0xf0) && \
                        ((a) != 0xffffffff))

/* Gurdeepian dword byte-swapping macro.
**
** Note that in this module all IP addresses are stored in on the net form
** which is the opposite of Intel format.
*/
#define net_long(x) (((((unsigned long)(x))&0xffL)<<24) | \
                     ((((unsigned long)(x))&0xff00L)<<8) | \
                     ((((unsigned long)(x))&0xff0000L)>>8) | \
                     ((((unsigned long)(x))&0xff000000L)>>24))

typedef struct _IPCP_DHCP_INFORM
{
    WCHAR*  wszDevice;
    HCONN   hConnection;
    BOOL    fUseDhcpInformDomainName;

} IPCP_DHCP_INFORM;

/*---------------------------------------------------------------------------
** External entry points
**---------------------------------------------------------------------------
*/

DWORD
IpcpInit(
    IN  BOOL        fInitialize)

    /* Called to initialize/uninitialize this CP. In the former case,
    ** fInitialize will be TRUE; in the latter case, it will be FALSE.
    */
{
    static  DWORD   dwRefCount  = 0;
    DWORD   dwErr;

    if (fInitialize)
    {
        if (0 == dwRefCount)
        {
            if ((dwErr = HelperInitialize(&HDhcpDll)) != NO_ERROR)
            {
                return(dwErr);
            }

            PDhcpRequestOptions = (DHCPREQUESTOPTIONS)
                GetProcAddress(HDhcpDll, "DhcpRequestOptions");

            if (NULL == PDhcpRequestOptions)
            {
                return(GetLastError());
            }

            PDhcpNotifyConfigChange2 = (DHCPNOTIFYCONFIGCHANGEEX)
                GetProcAddress(HDhcpDll, "DhcpNotifyConfigChangeEx");

            if (NULL == PDhcpNotifyConfigChange2)
            {
                return(GetLastError());
            }

            ClearTcpipInfo();

            DwIpcpTraceId = TraceRegister("RASIPCP");
        }

        dwRefCount++;
    }
    else
    {
        dwRefCount--;

        if (0 == dwRefCount)
        {
            HelperUninitialize();
            // Ignore errors

            HDhcpDll                    = NULL;
            PDhcpRequestOptions         = NULL;
            PDhcpNotifyConfigChange2    = NULL;

            if (HRasArp != INVALID_HANDLE_VALUE)
                CloseHandle( HRasArp );

            HRasArp = INVALID_HANDLE_VALUE;

            TraceDeregister(DwIpcpTraceId);
            DwIpcpTraceId = INVALID_TRACEID;
        }
    }

    return(NO_ERROR);
}


DWORD
IpcpGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pInfo )

    /* IpcpGetInfo entry point called by the PPP engine by name.  See RasCp
    ** interface documentation.
    */
{
    ZeroMemory( pInfo, sizeof(*pInfo) );

    pInfo->Protocol = (DWORD )PPP_IPCP_PROTOCOL;
    lstrcpy(pInfo->SzProtocolName, "IPCP");
    pInfo->Recognize = 7;
    pInfo->RasCpInit = IpcpInit;
    pInfo->RasCpBegin = IpcpBegin;
    pInfo->RasCpReset = IpcpReset;
    pInfo->RasCpEnd = IpcpEnd;
    pInfo->RasCpThisLayerFinished = IpcpThisLayerFinished;
    pInfo->RasCpThisLayerUp = IpcpThisLayerUp;
    pInfo->RasCpPreDisconnectCleanup = IpcpPreDisconnectCleanup;
    pInfo->RasCpMakeConfigRequest = IpcpMakeConfigRequest;
    pInfo->RasCpMakeConfigResult = IpcpMakeConfigResult;
    pInfo->RasCpConfigAckReceived = IpcpConfigAckReceived;
    pInfo->RasCpConfigNakReceived = IpcpConfigNakReceived;
    pInfo->RasCpConfigRejReceived = IpcpConfigRejReceived;
    pInfo->RasCpGetNegotiatedInfo = IpcpGetNegotiatedInfo;
    pInfo->RasCpProjectionNotification = IpcpProjectionNotification;
    pInfo->RasCpChangeNotification = IpcpChangeNotification;

    return 0;
}


DWORD
IpcpChangeNotification(
    VOID )
{
    HelperChangeNotification();

    return(NO_ERROR);
}


DWORD
IpcpBegin(
    OUT VOID** ppWorkBuf,
    IN  VOID*  pInfo )

    /* RasCpBegin entry point called by the PPP engine thru the passed
    ** address.  See RasCp interface documentation.
    */
{
    DWORD                   dwErr;
    PPPCP_INIT*             pInit = (PPPCP_INIT* )pInfo;
    IPCPWB*                 pwb;
    RAS_AUTH_ATTRIBUTE *    pAttribute;
    BOOL                    fVPN = FALSE;
    BOOL                    fVJAttributePresent = FALSE;

    TraceIp("IPCP: IpcpBegin");

    /* Allocate work buffer.
    */
    if (!(pwb = (IPCPWB* )LocalAlloc( LPTR, sizeof(IPCPWB) )))
    {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    pwb->fServer            = pInit->fServer;
    pwb->hport              = pInit->hPort;
    pwb->hConnection        = pInit->hConnection;
    pwb->hIPInterface       = pInit->hInterface;
    pwb->IfType             = pInit->IfType;
    pwb->fDisableNetbt      = pInit->fDisableNetbt;
	
    if (0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pInit->pszUserName,
                    -1,
                    pwb->wszUserName,
                    UNLEN+1 ) )
    {
        dwErr = GetLastError();
        TraceIp("MultiByteToWideChar(%s) failed: %d", 
            pInit->pszUserName, dwErr);
        LocalFree( pwb );
        return( dwErr );
    }

    if (0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pInit->pszPortName,
                    -1,
                    pwb->wszPortName,
                    MAX_PORT_NAME+1 ) )
    {
        dwErr = GetLastError();
        TraceIp("MultiByteToWideChar(%s) failed: %d", 
            pInit->pszPortName, dwErr);
        LocalFree( pwb );
        return( dwErr );
    }
                                
    if ( pwb->fServer )
    {
        HKEY  hkey;
        DWORD dwType;
        DWORD dwValue;
        DWORD cb = sizeof(DWORD);

        if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Params, &hkey ) == 0)
        {
            if (RegQueryValueEx(
                   hkey, REGVAL_HardIp, NULL, &dwType,
                   (LPBYTE )&dwValue, &cb ) == 0
                && dwType == REG_DWORD
                && cb == sizeof(DWORD)
                && dwValue)
            {
                FClientMaySelectAddress = TRUE;
            }

            RegCloseKey( hkey );
        }

        TraceIp("IPCP: Hard IP=%d",FClientMaySelectAddress);

        pwb->IpAddressToHandout = ( FClientMaySelectAddress ) 
                                        ? net_long( 0xFFFFFFFF )
                                        : net_long( 0xFFFFFFFE );
        //
        // Is there an IP address parameter ?
        //

        pAttribute = RasAuthAttributeGet( raatFramedIPAddress,  
                                          pInit->pAttributes );

        if ( pAttribute != NULL )
        {
            pwb->IpAddressToHandout = net_long( PtrToUlong(pAttribute->Value) ); 

            TraceIp("IPCP: Using IP address attribute 0x%x", 
                    pwb->IpAddressToHandout );
        }
    }
    else
    {
        //
        // We are a router or client dialing out, let other side always choose
        // their address
        //

        pwb->IpAddressToHandout = net_long( 0xFFFFFFFF );
    }

    pwb->fRegisterWithWINS = 1;

    if ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER )
    {
        HKEY  hkey;
        DWORD dwType;
        DWORD dwValue;
        DWORD cb = sizeof(DWORD);

        pwb->fRegisterWithWINS = 0;

        if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Ipcp, &hkey ) == 0)
        {
            if (RegQueryValueEx(
                   hkey, REGVAL_RegisterRoutersWithWINS, NULL,
                   &dwType, (LPBYTE )&dwValue, &cb ) == 0
                && dwType == REG_DWORD
                && cb == sizeof(DWORD)
                && dwValue != 0)
            {
                TraceIp("IPCP: Will register routers with WINS");
                pwb->fRegisterWithWINS = 1;
            }

            RegCloseKey( hkey );
        }
    }

    /* Allocate a route between the MAC and the TCP/IP stack.
    */
    if ((dwErr = RasAllocateRoute(
            pwb->hport, IP, !pwb->fServer, &pwb->routeinfo )) != 0)
    {
        TraceIp("IPCP: RasAllocateRoute=%d",dwErr);
        LocalFree( (HLOCAL )pwb );
        return dwErr;
    }

    /* Lookup the compression capabilities.
    */
    if ((dwErr = RasPortGetProtocolCompression(
             pwb->hport, IP, &pwb->rpcSend, &pwb->rpcReceive )) != 0)
    {
        TraceIp("IPCP: RasPortGetProtocolCompression=%d",dwErr);
        pwb->dwErrInBegin = dwErr;
        *ppWorkBuf = pwb;
        return 0;
    }

    if (0 == pwb->rpcSend.RP_ProtocolType.RP_IP.RP_IPCompressionProtocol)
    {
        HKEY  hkey;
        DWORD dwType;
        DWORD dwValue;
        DWORD cb = sizeof(DWORD);

        fVPN = TRUE;

        if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Ipcp, &hkey ) == 0)
        {
            /* VJ header compression is a history based scheme and since
               we can't reliably detect lost frames over vpn's we have
               dropped support for vj over vpn's.
            */

            if (RegQueryValueEx(
                   hkey, REGVAL_AllowVJOverVPN, NULL,
                   &dwType, (LPBYTE )&dwValue, &cb ) == 0
                && dwType == REG_DWORD
                && cb == sizeof(DWORD)
                && dwValue == 1)
            {
                TraceIp("IPCP: AllowVJOverVPN is TRUE");
                pwb->rpcSend.RP_ProtocolType.RP_IP.RP_IPCompressionProtocol = 0x2D;
                pwb->rpcReceive.RP_ProtocolType.RP_IP.RP_IPCompressionProtocol = 0x2D;
                fVPN = FALSE;
            }

            RegCloseKey( hkey );
        }
    }

    if ( pwb->fServer )
    {
        HANDLE  hAttribute;

        pAttribute = RasAuthAttributeGetFirst(raatFramedCompression,
                        pInit->pAttributes, &hAttribute );

        while (NULL != pAttribute)
        {
            switch (PtrToUlong(pAttribute->Value))
            {
            case 0:

                /* Don't request or accept VJ compression.
                */
                TraceIp("IPCP: VJ disabled by RADIUS");
                pwb->fIpCompressionRejected = TRUE;
                memset( &pwb->rpcSend, '\0', sizeof(pwb->rpcSend) );

                fVJAttributePresent = TRUE;
                break;

            case 1:

                TraceIp("IPCP: VJ required by RADIUS");
                fVJAttributePresent = TRUE;
                break;

            default:

                break;
            }

            if (fVJAttributePresent)
            {
                break;
            }

            pAttribute = RasAuthAttributeGetNext(&hAttribute,
                            raatFramedCompression);
        }
    }

    if (fVJAttributePresent)
    {
        // Nothing
    }
    else if (fVPN)
    {
        TraceIp("IPCP: VJ disabled for VPN");
        pwb->fIpCompressionRejected = TRUE;
        memset( &pwb->rpcSend, '\0', sizeof(pwb->rpcSend) );
    }
    else
    {
        /* Look up "request VJ compresion" flag in registry.
        */
        {
            HKEY  hkey;
            DWORD dwType;
            DWORD dwValue;
            DWORD cb = sizeof(DWORD);

            if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Ipcp, &hkey ) == 0)
            {
                if (RegQueryValueEx(
                       hkey, REGVAL_VjComp, NULL,
                       &dwType, (LPBYTE )&dwValue, &cb ) == 0
                    && dwType == REG_DWORD
                    && cb == sizeof(DWORD)
                    && dwValue == 0)
                {
                    TraceIp("IPCP: VJ requests disabled");
                    pwb->fIpCompressionRejected = TRUE;
                }

                RegCloseKey( hkey );
            }
        }

        /* Look up "accept VJ compresion" flag in registry.
        */
        {
            HKEY  hkey;
            DWORD dwType;
            DWORD dwValue;
            DWORD cb = sizeof(DWORD);

            if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Ipcp, &hkey ) == 0)
            {
                if (RegQueryValueEx(
                       hkey, REGVAL_VjComp2, NULL,
                       &dwType, (LPBYTE )&dwValue, &cb ) == 0
                    && dwType == REG_DWORD
                    && cb == sizeof(DWORD)
                    && dwValue == 0)
                {
                    TraceIp("IPCP: VJ will not be accepted");
                    memset( &pwb->rpcSend, '\0', sizeof(pwb->rpcSend) );
                }

                RegCloseKey( hkey );
            }
        }
    }

    TraceIp("IPCP: Compress capabilities: s=$%x,%d,%d r=$%x,%d,%d",
            (int)Protocol(pwb->rpcSend),(int)MaxSlotId(pwb->rpcSend),
            (int)CompSlotId(pwb->rpcSend),(int)Protocol(pwb->rpcReceive),
            (int)MaxSlotId(pwb->rpcReceive),CompSlotId(pwb->rpcReceive));

    //
    // If we are receiving a call from a client or another router, or we
    // are a router dialing out.
    //

    if ( ( pwb->fServer ) ||
         ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER ) )
    {
        /* Look up the DNS server, WINS server, and "this server" addresses.
        ** This is done once at the beginning since these addresses are the
        ** same for a given route regardless of the IP addresses. 
        */

        TraceIp("IPCP: Server address lookup...");
        TraceIp("IPCP: RasSrvrQueryServerAddresses...");

        dwErr = RasSrvrQueryServerAddresses( &(pwb->IpInfoRemote) );

        TraceIp("IPCP: RasSrvrQueryServerAddresses done(%d)",dwErr);

        if (dwErr != 0)
        {
            pwb->dwErrInBegin = dwErr;
            *ppWorkBuf = pwb;
            return 0;
        }
        else
        {
            TraceIp("IPCP:Dns=%08x,Wins=%08x,DnsB=%08x,WinsB=%08x,"
                    "Server=%08x,Mask=%08x",
                    pwb->IpInfoRemote.nboDNSAddress,
                    pwb->IpInfoRemote.nboWINSAddress,
                    pwb->IpInfoRemote.nboDNSAddressBackup,
                    pwb->IpInfoRemote.nboWINSAddressBackup,
                    pwb->IpInfoRemote.nboServerIpAddress,
                    pwb->IpInfoRemote.nboServerSubnetMask);
        }

        //
        // If this is not a router interface, then we use the server address
        // as a local address
        //

        if ( ( pwb->fServer ) && ( pwb->IfType != ROUTER_IF_TYPE_FULL_ROUTER ) )
        {
            /* Request server's own IP address.  (RAS client's don't care what
            ** the server's address is, but some other vendors like
            ** MorningStar won't connect unless you tell them)
            */

            pwb->IpAddressLocal = pwb->IpInfoRemote.nboServerIpAddress;
        }
    }

    //
    // We are a client\router dialing out or a router dialing in, 
    //

    if ( ( !pwb->fServer ) || ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER ) )
    {
        //
        // See if registry indicates "no WINS/DNS requests" mode for clients
        // dialing out.
        //

        HKEY  hkey;
        DWORD dwType;
        DWORD dwValue;
        DWORD cb = sizeof(DWORD);

        if ( RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Ipcp, &hkey ) == 0)
        {
            if ( RegQueryValueEx(
                   hkey, REGVAL_NsAddrs, NULL,
                   &dwType, (LPBYTE )&dwValue, &cb ) == 0
                && dwType == REG_DWORD
                && cb == sizeof(DWORD)
                && dwValue == 0)
            {
                TraceIp("IPCP: WINS/DNS requests disabled");
                pwb->fIpaddrDnsRejected         = TRUE;
                pwb->fIpaddrWinsRejected        = TRUE;
                pwb->fIpaddrDnsBackupRejected   = TRUE;
                pwb->fIpaddrWinsBackupRejected  = TRUE;
            }

            RegCloseKey( hkey );
        }

        /* Read the parameters sent from the UI in the parameters buffer.
        */
        pwb->fPrioritizeRemote = TRUE;

        if (pInit->pszzParameters)
        {
            DWORD dwIpSource;
            CHAR  szIpAddress[ 16 ];
            WCHAR wszIpAddress[ 16 ];
            BOOL  fVjCompression;
            DWORD dwDnsFlags;
            CHAR  szDnsSuffix[DNS_SUFFIX_SIZE + 1];

            TraceIp("IPCP: UI parameters...");
            DUMPB(pInit->pszzParameters,PARAMETERBUFLEN);

            FindFlagInParamBuf(
                pInit->pszzParameters, PBUFKEY_IpPrioritizeRemote,
                &pwb->fPrioritizeRemote );

            pwb->fUnnumbered = FALSE;

            if ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER )
            {
                if ( RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Ipcp, &hkey ) == 0)
                {
                    if ( RegQueryValueEx(
                           hkey, REGVAL_Unnumbered, NULL,
                           &dwType, (LPBYTE )&dwValue, &cb ) == 0
                        && dwType == REG_DWORD
                        && cb == sizeof(DWORD)
                        && dwValue != 0)
                    {
                        TraceIp("Unnumbered");
                        pwb->fUnnumbered = TRUE;
                    }

                    RegCloseKey( hkey );
                }
            }

            {
                if (FindLongInParamBuf(
                        pInit->pszzParameters, PBUFKEY_IpDnsFlags,
                        &dwDnsFlags ))
                {
                    if (dwDnsFlags & 0x1)
                    {
                        pwb->fRegisterWithDNS = 1;
                    }

                    if (   (dwDnsFlags & 0x2)
                        || (dwDnsFlags & 0x4) )
                    {
                        pwb->fRegisterAdapterDomainName = 1;
                    }
                }
            }

            {
                if (FindStringInParamBuf(
                        pInit->pszzParameters, PBUFKEY_IpDnsSuffix,
                        szDnsSuffix, DNS_SUFFIX_SIZE + 1 ))
                {
                    strncpy(pwb->szDnsSuffix, szDnsSuffix, DNS_SUFFIX_SIZE);
                }
            }

            {
                fVjCompression = TRUE;
                FindFlagInParamBuf(
                    pInit->pszzParameters, PBUFKEY_IpVjCompression,
                    &fVjCompression );

                if (!fVjCompression)
                {
                    /* Don't request or accept VJ compression.
                    */
                    TraceIp("IPCP: VJ disabled");
                    pwb->fIpCompressionRejected = TRUE;
                    memset( &pwb->rpcSend, '\0', sizeof(pwb->rpcSend) );
                }
            }

            if(     !pwb->fIpCompressionRejected
                &&  !Protocol(pwb->rpcReceive))
            {
                pwb->fIpCompressionRejected = TRUE;
            }
            

            dwIpSource = PBUFVAL_ServerAssigned;
            FindLongInParamBuf(
                pInit->pszzParameters, PBUFKEY_IpAddressSource,
                &dwIpSource );

            if (dwIpSource == PBUFVAL_RequireSpecific)
            {
                if (FindStringInParamBuf(
                        pInit->pszzParameters, PBUFKEY_IpAddress,
                        szIpAddress, 16 ))
                {
                    mbstowcs( wszIpAddress, szIpAddress, 16 );
                    pwb->IpAddressLocal
                        = IpAddressFromAbcdWsz( wszIpAddress );
                }
            }

            dwIpSource = PBUFVAL_ServerAssigned;
            FindLongInParamBuf(
                    pInit->pszzParameters, PBUFKEY_IpNameAddressSource,
                    &dwIpSource );

            if (dwIpSource == PBUFVAL_RequireSpecific)
            {
				//
				//check to see if DNS or WINS or both have been 
				//requested specific and set the flags accordingly
				//so that we only request proper addresses
				//from the server
				//

                if (FindStringInParamBuf(
                            pInit->pszzParameters, PBUFKEY_IpDnsAddress,
                            szIpAddress, 16 ))
                {
                    mbstowcs( wszIpAddress, szIpAddress, 16 );
                    pwb->IpInfoLocal.nboDNSAddress
                            = IpAddressFromAbcdWsz( wszIpAddress );
                }

                if (FindStringInParamBuf(
                            pInit->pszzParameters, PBUFKEY_IpDns2Address,
                            szIpAddress, 16 ))
                {
                    mbstowcs( wszIpAddress, szIpAddress, 16 );
                    pwb->IpInfoLocal.nboDNSAddressBackup
                            = IpAddressFromAbcdWsz( wszIpAddress );
                }

                if (FindStringInParamBuf(
                            pInit->pszzParameters, PBUFKEY_IpWinsAddress,
                            szIpAddress, 16 ))
                {
                    mbstowcs( wszIpAddress, szIpAddress, 16 );
                    pwb->IpInfoLocal.nboWINSAddress
                            = IpAddressFromAbcdWsz( wszIpAddress );
                }

                if (FindStringInParamBuf(
                            pInit->pszzParameters, PBUFKEY_IpWins2Address,
                            szIpAddress, 16 ))
                {
                    mbstowcs( wszIpAddress, szIpAddress, 16 );
                    pwb->IpInfoLocal.nboWINSAddressBackup
                            = IpAddressFromAbcdWsz( wszIpAddress );
                }
				if ( pwb->IpInfoLocal.nboDNSAddress ||
					 pwb->IpInfoLocal.nboDNSAddressBackup
				   )
				{
					//Specific DNS address has been passed in
					pwb->fIpaddrDnsRejected = TRUE;
					pwb->fIpaddrDnsBackupRejected = TRUE;

				}
				if ( pwb->IpInfoLocal.nboWINSAddress ||
					 pwb->IpInfoLocal.nboWINSAddressBackup
				   )
				{
					//Specific WINS address has been requested
					pwb->fIpaddrWinsRejected = TRUE;
					pwb->fIpaddrWinsBackupRejected = TRUE;
				}

            }
        }

        TraceIp( "IPCP:a=%08x,f=%d",
                 pwb->IpAddressLocal,pwb->fPrioritizeRemote);
    }


    /* Register work buffer with engine.
    */
    *ppWorkBuf = pwb;
    return 0;
}


DWORD
IpcpThisLayerFinished(
    IN VOID* pWorkBuf )

    /* RasCpThisLayerFinished entry point called by the PPP engine thru the
    ** passed address. See RasCp interface documentation.
    */
{
    DWORD   dwErr = 0;
    IPCPWB* pwb = (IPCPWB* )pWorkBuf;

    TraceIp("IPCP: IpcpThisLayerFinished...");

    //
    // If this is a server or a router dialing in or out then we release this
    // address
    //

    if ( ( pwb->fServer ) ||
         ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER ))
    {
        if (pwb->IpAddressRemote != 0)
        {
            TraceIp("IPCP: RasSrvrReleaseAddress...");
            RasSrvrReleaseAddress(pwb->IpAddressRemote,
                                        pwb->wszUserName,
                                        pwb->wszPortName,
                                        ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER ) ?
                                        FALSE : TRUE);
            TraceIp("IPCP: RasSrvrReleaseAddress done");
            pwb->IpAddressRemote = 0;
        }

        //
        // Set ConfigActive to false only for server
        //

        if ( ( pwb->fServer ) && 
             ( pwb->IfType != ROUTER_IF_TYPE_FULL_ROUTER ))
        {
            pwb->fRasConfigActive = FALSE;
        }
    }

    //
    // If we are a client dialing out or a router dialing in or out then we
    // notify DHCP of releasing this address.
    //

    if ( ( !pwb->fServer ) ||
         ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER ))
    {
        dwErr = DeActivateRasConfig( pwb );

        if (dwErr == 0)
        {
            pwb->fRasConfigActive = FALSE;
        }
    }

    if (pwb->fRouteActivated)
    {
        TraceIp("IPCP: RasDeAllocateRoute...");
        RasDeAllocateRoute( pwb->hConnection, IP );
        pwb->fRouteActivated = FALSE;
    }

	if ( pwb->pbDhcpRoutes )
	{
		//Parse the dhcp routes and remove the routes from stack
		TraceIp("IPCP: RasDeAllocateDhcpRoute...");
		RasTcpSetDhcpRoutes ( pwb->pbDhcpRoutes , pwb->IpAddressLocal, FALSE );
		LocalFree (pwb->pbDhcpRoutes );
        pwb->pbDhcpRoutes = NULL;
	}

    TraceIp("IPCP: IpcpThisLayerFinished done(%d)",dwErr);
    return dwErr;
}

DWORD
IpcpEnd(
    IN VOID* pWorkBuf )

    /* RasCpEnd entry point called by the PPP engine thru the passed address.
    ** See RasCp interface documentation.
    */
{
    DWORD   dwErr = 0;
    IPCPWB* pwb = (IPCPWB* )pWorkBuf;

    TraceIp("IPCP: IpcpEnd...");

    dwErr = IpcpThisLayerFinished( pWorkBuf );

    LocalFree( (HLOCAL )pWorkBuf );
    TraceIp("IPCP: IpcpEnd done(%d)",dwErr);
    return dwErr;
}


DWORD
IpcpReset(
    IN VOID* pWorkBuf )

    /* Called to reset negotiations.  See RasCp interface documentation.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    /* RasPpp.dll requires this to exist even though it does nothing
    ** (complaints to Gibbs).
    */
    return 0;
}


DWORD
IpcpThisLayerUp(
    IN VOID* pWorkBuf )

    /* Called when the CP is entering Open state.  See RasCp interface
    ** documentation.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    IPCPWB* pwb = (IPCPWB* )pWorkBuf;

    TraceIp("IPCP: IpcpThisLayerUp");

    if (pwb->fRasConfigActive || pwb->fExpectingProjection)
    {
        TraceIp("IPCP: Link already up...ignored.");
        return 0;
    }

    /* Can't route until we know the result of the projection.  Shouldn't
    ** activate until just before we route or WANARP reports errors.  See
    ** IpcpProjectionResult.
    */
    pwb->fExpectingProjection = TRUE;

    TraceIp("IPCP: IpcpThisLayerUp done");
    return 0;
}

DWORD
IpcpPreDisconnectCleanup(
    IN  VOID*       pWorkBuf )
{
    IPCPWB* pwb     = (IPCPWB* )pWorkBuf;
    DWORD   dwErr   = NO_ERROR;

    TraceIp("IPCP: IpcpPreDisconnectCleanup");

    if (   ( pwb->fServer )
        || ( pwb->pwszDevice == NULL )
        || ( !pwb->fRegisterWithDNS ))
    {
        return( NO_ERROR );
    }

    if ( ( dwErr = ResetNetBTConfigInfo( pwb ) ) != NO_ERROR )
    {
        TraceIp("IPCP: ResetNetBTConfigInfo=%d",dwErr);
    }
    else
    {
        if ((dwErr = ReconfigureTcpip( pwb->pwszDevice, FALSE, 0, 0)) != 0)
        {
            TraceIp("IPCP: ReconfigureTcpip=%d", dwErr);
        }
    }

    return(dwErr);
}

DWORD
IpcpMakeConfigRequest(
    IN  VOID*       pWorkBuf,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf )

    /* Makes a configure-request packet in 'pSendBuf'.  See RasCp interface
    ** documentation.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    IPCPWB* pwb = (IPCPWB* )pWorkBuf;
    WORD    cbPacket = PPP_CONFIG_HDR_LEN;
    BYTE*   pbThis = pSendBuf->Data;

    TraceIp("IPCP: IpcpMakeConfigRequest");
    RTASSERT(cbSendBuf>PPP_CONFIG_HDR_LEN+(IPADDRESSOPTIONLEN*3));

    if (pwb->dwErrInBegin != 0)
    {
        TraceIp("IPCP: Deferred IpcpBegin error=%d",pwb->dwErrInBegin);
        return pwb->dwErrInBegin;
    }

    if (++pwb->cRequestsWithoutResponse >= 5)
    {
        TraceIp("IPCP: Tossing MS options (request timeouts)");
        pwb->fTryWithoutExtensions = TRUE;
        pwb->fIpaddrDnsRejected = TRUE;
        pwb->fIpaddrWinsRejected = TRUE;
        pwb->fIpaddrDnsBackupRejected = TRUE;
        pwb->fIpaddrWinsBackupRejected = TRUE;
    }

    if (!pwb->fIpCompressionRejected )
    {
        /* Request IP compression for both client and server.
        */
        AddIpCompressionOption( pbThis, &pwb->rpcReceive );
        cbPacket += IPCOMPRESSIONOPTIONLEN;
        pbThis += IPCOMPRESSIONOPTIONLEN;
    }

    //
    // We always negotiate this option, it will be 0 for clients and routers
    // dialing out and routers dialing in, it will be the server's address 
    // for clients dialing in. We don't negotiate this option if we want
    // unnumbered IPCP.
    //

    if (!pwb->fIpaddrRejected && !pwb->fUnnumbered)
    {
        AddIpAddressOption(
                pbThis, OPTION_IpAddress, pwb->IpAddressLocal );
        cbPacket += IPADDRESSOPTIONLEN;
        pbThis += IPADDRESSOPTIONLEN;
    }

    //
    // If we are client dialing out we need WINS and DNS addresses
    //

    if ( !pwb->fServer )
    {
        /* The client asks the server to provide a DNS address and WINS
        ** address (and depending on user's UI selections, an IP address) by
        ** sending 0's for these options.
        */

        if (!pwb->fIpaddrDnsRejected)
        {
            AddIpAddressOption(
                pbThis, OPTION_DnsIpAddress, 
                pwb->IpInfoLocal.nboDNSAddress );
            cbPacket += IPADDRESSOPTIONLEN;
            pbThis += IPADDRESSOPTIONLEN;
        }

        if (!pwb->fIpaddrWinsRejected)
        {
            AddIpAddressOption(
                pbThis, OPTION_WinsIpAddress,
                pwb->IpInfoLocal.nboWINSAddress );
            cbPacket += IPADDRESSOPTIONLEN;
            pbThis += IPADDRESSOPTIONLEN;
        }

        if (!pwb->fIpaddrDnsBackupRejected)
        {
            AddIpAddressOption(
                pbThis, OPTION_DnsBackupIpAddress,
                pwb->IpInfoLocal.nboDNSAddressBackup );
            cbPacket += IPADDRESSOPTIONLEN;
            pbThis += IPADDRESSOPTIONLEN;
        }

        if (!pwb->fIpaddrWinsBackupRejected)
        {
            AddIpAddressOption(
                pbThis, OPTION_WinsBackupIpAddress,
                pwb->IpInfoLocal.nboWINSAddressBackup );
            cbPacket += IPADDRESSOPTIONLEN;
        }
    }

    pSendBuf->Code = CONFIG_REQ;
    HostToWireFormat16( cbPacket, pSendBuf->Length );
    TraceIp("IPCP: ConfigRequest...");
    DUMPB(pSendBuf,cbPacket);
    return 0;
}


DWORD
IpcpMakeConfigResult(
    IN  VOID*       pWorkBuf,
    IN  PPP_CONFIG* pReceiveBuf,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf,
    IN  BOOL        fRejectNaks )

    /* Makes a configure-ack, -nak, or -reject packet in 'pSendBuf'.  See
    ** RasCp interface documentation.
    **
    ** Implements the Stefanian rule, i.e. accept only configure requests that
    ** exactly match the previously acknowledged request after this layer up
    ** has been called.  This is necessary because the RAS route cannot be
    ** deallocated when the port is open (NDISWAN driver limitation), so
    ** renegotiation with different parameters is not possible once the route
    ** has been activated.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    DWORD   dwErr;
    BOOL    f;
    IPCPWB* pwb = (IPCPWB* )pWorkBuf;

    TraceIp("IPCP: IpcpMakeConfigResult for...");
    DUMPB(pReceiveBuf,(pReceiveBuf)?WireToHostFormat16(pReceiveBuf->Length):0);

    pwb->cRequestsWithoutResponse = 0;

    /* Check if there's reason to reject the request and if so, do it.
    */
    if ((dwErr = RejectCheck(
            pwb, pReceiveBuf, pSendBuf, cbSendBuf, &f )) != 0)
    {
        TraceIp("IPCP: ConfigResult...");
        DUMPB(pSendBuf,WireToHostFormat16(pSendBuf->Length));
        return dwErr;
    }

    if (f)
        return (pwb->fRasConfigActive) ? ERROR_PPP_NOT_CONVERGING : 0;

    /* Check if there's reason to nak the request and if so, do it (or
    ** reject instead of nak if indicated by engine).
    */
    if ((dwErr = NakCheck(
            pwb, pReceiveBuf, pSendBuf, cbSendBuf, &f, fRejectNaks )) != 0)
    {
        TraceIp("IPCP: ConfigResult...");
        DUMPB(pSendBuf,WireToHostFormat16(pSendBuf->Length));
        return dwErr;
    }

    if (f)
        return (pwb->fRasConfigActive) ? ERROR_PPP_NOT_CONVERGING : 0;

    /* Acknowledge the request.
    */
    {
        WORD cbPacket = WireToHostFormat16( pReceiveBuf->Length );
        CopyMemory( pSendBuf, pReceiveBuf, cbPacket );
        pSendBuf->Code = CONFIG_ACK;
    }

    TraceIp("IPCP: ConfigResult...");
    DUMPB(pSendBuf,WireToHostFormat16(pSendBuf->Length));
    return 0;
}


DWORD
IpcpConfigAckReceived(
    IN VOID*       pWorkBuf,
    IN PPP_CONFIG* pReceiveBuf )

    /* Examines received configure-ack in 'pReceiveBuf'.  See RasCp interface
    ** documentation.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    DWORD   dwErr = 0;
    IPCPWB* pwb = (IPCPWB* )pWorkBuf;

    WORD cbPacket = WireToHostFormat16( pReceiveBuf->Length );
    WORD cbLeft = cbPacket - PPP_CONFIG_HDR_LEN;

    PPP_OPTION UNALIGNED* pROption = (PPP_OPTION UNALIGNED* )pReceiveBuf->Data;

    BOOL fIpCompressionOk = pwb->fIpCompressionRejected;
    BOOL fIpaddrOk = pwb->fIpaddrRejected || pwb->fUnnumbered;
    BOOL fIpaddrDnsOk = pwb->fIpaddrDnsRejected;
    BOOL fIpaddrWinsOk = pwb->fIpaddrWinsRejected;
    BOOL fIpaddrDnsBackupOk = pwb->fIpaddrDnsBackupRejected;
    BOOL fIpaddrWinsBackupOk = pwb->fIpaddrWinsBackupRejected;

    TraceIp("IPCP: IpcpConfigAckReceived...");
    DUMPB(pReceiveBuf,cbPacket);

    pwb->cRequestsWithoutResponse = 0;

    while (cbLeft > 0)
    {
        if (cbLeft < pROption->Length)
            return ERROR_PPP_INVALID_PACKET;

        if (pROption->Type == OPTION_IpCompression)
        {
            WORD wProtocol;

            if (pROption->Length != IPCOMPRESSIONOPTIONLEN)
                return ERROR_PPP_INVALID_PACKET;

            wProtocol = WireToHostFormat16U(pROption->Data );
            if (wProtocol != Protocol(pwb->rpcReceive)
                || pROption->Data[ 2 ] != MaxSlotId(pwb->rpcReceive)
                || pROption->Data[ 3 ] != CompSlotId(pwb->rpcReceive))
            {
                return ERROR_PPP_INVALID_PACKET;
            }

            fIpCompressionOk = TRUE;
        }
        else if (pROption->Type == OPTION_IpAddress)
        {
            IPADDR ipaddr;

            if (pROption->Length != IPADDRESSOPTIONLEN)
                return ERROR_PPP_INVALID_PACKET;

            CopyMemory( &ipaddr, pROption->Data, sizeof(IPADDR) );

            if (ipaddr != 0 && ipaddr == pwb->IpAddressLocal )
                fIpaddrOk = TRUE;
        }
        else if (!pwb->fServer)
        {
            // 
            // We are a client dialing out 
            //

            switch (pROption->Type)
            {
                case OPTION_DnsIpAddress:
                {
                    IPADDR ipaddr;

                    if (pROption->Length != IPADDRESSOPTIONLEN)
                        return ERROR_PPP_INVALID_PACKET;

                    CopyMemory( &ipaddr, pROption->Data, sizeof(IPADDR) );

                    if (ipaddr == pwb->IpInfoLocal.nboDNSAddress)
                        fIpaddrDnsOk = TRUE;
                    break;
                }

                case OPTION_WinsIpAddress:
                {
                    IPADDR ipaddr;

                    if (pROption->Length != IPADDRESSOPTIONLEN)
                        return ERROR_PPP_INVALID_PACKET;

                    CopyMemory( &ipaddr, pROption->Data, sizeof(IPADDR) );

                    if (ipaddr == pwb->IpInfoLocal.nboWINSAddress)
                        fIpaddrWinsOk = TRUE;
                    break;
                }

                case OPTION_DnsBackupIpAddress:
                {
                    IPADDR ipaddr;

                    if (pROption->Length != IPADDRESSOPTIONLEN)
                        return ERROR_PPP_INVALID_PACKET;

                    CopyMemory( &ipaddr, pROption->Data, sizeof(IPADDR) );

                    if (ipaddr == pwb->IpInfoLocal.nboDNSAddressBackup)
                    {
                        fIpaddrDnsBackupOk = TRUE;
                    }
                    break;
                }

                case OPTION_WinsBackupIpAddress:
                {
                    IPADDR ipaddr;

                    if (pROption->Length != IPADDRESSOPTIONLEN)
                        return ERROR_PPP_INVALID_PACKET;

                    CopyMemory( &ipaddr, pROption->Data, sizeof(IPADDR) );

                    if (ipaddr == pwb->IpInfoLocal.nboWINSAddressBackup)
                    {
                        fIpaddrWinsBackupOk = TRUE;
                    }
                    break;
                }

                default:
                {
                    TraceIp("IPCP: Unrecognized option ACKed?");
                    return ERROR_PPP_INVALID_PACKET;
                }
            }
        }
        else
        {
            TraceIp("IPCP: Unrecognized option ACKed?");
            return ERROR_PPP_INVALID_PACKET;
        }

        if (pROption->Length && pROption->Length < cbLeft)
            cbLeft -= pROption->Length;
        else
            cbLeft = 0;

        pROption = (PPP_OPTION* )((BYTE* )pROption + pROption->Length);
    }

    if (   !fIpCompressionOk
        || !fIpaddrOk
        || (   !pwb->fServer
            && (   !fIpaddrDnsOk
                || !fIpaddrWinsOk
                || !fIpaddrDnsBackupOk
                || !fIpaddrWinsBackupOk)))
    {
        dwErr = ERROR_PPP_INVALID_PACKET;
    }

    TraceIp("IPCP: IpcpConfigAckReceived done(%d)",dwErr);
    return dwErr;
}


DWORD
IpcpConfigNakReceived(
    IN VOID*       pWorkBuf,
    IN PPP_CONFIG* pReceiveBuf )

    /* Examines received configure-nak in 'pReceiveBuf'.  See RasCp interface
    ** documentation.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    IPCPWB*     pwb = (IPCPWB* )pWorkBuf;
    PPP_OPTION* pROption = (PPP_OPTION* )pReceiveBuf->Data;
    WORD        cbPacket = WireToHostFormat16( pReceiveBuf->Length );
    WORD        cbLeft = cbPacket - PPP_CONFIG_HDR_LEN;

    TraceIp("IPCP: IpcpConfigNakReceived");
    TraceIp("IPCP: Nak received...");
    DUMPB(pReceiveBuf,(pReceiveBuf)?WireToHostFormat16(pReceiveBuf->Length):0);

    pwb->cRequestsWithoutResponse = 0;

    while (cbLeft > 0)
    {
        if (cbLeft < pROption->Length)
            return ERROR_PPP_INVALID_PACKET;

        if (pROption->Type == OPTION_IpCompression)
        {
            WORD wProtocol = WireToHostFormat16( pROption->Data );

            if (wProtocol == COMPRESSION_VanJacobson)
            {
                /* He can send Van Jacobson but not with the slot parameters
                ** we suggested.
                */
                if (pROption->Length != IPCOMPRESSIONOPTIONLEN)
                    return ERROR_PPP_INVALID_PACKET;

                if (pROption->Data[ 2 ] <= MaxSlotId(pwb->rpcReceive))
                {
                    /* We can accept his suggested MaxSlotID when it is less
                    ** than or the same as what we can do.
                    */
                    MaxSlotId(pwb->rpcReceive) = pROption->Data[ 2 ];
                }

                if (CompSlotId(pwb->rpcReceive))
                {
                    /* We can compress the slot-ID or not, so just accept
                    ** whatever he wants to do.
                    */
                    CompSlotId(pwb->rpcReceive) = pROption->Data[ 3 ];
                }
            }
        }
        else if ( ( !pwb->fServer ) ||
                  ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER ) )
        {
            switch (pROption->Type)
            {
                case OPTION_IpAddress:
                {
                    IPADDR ipaddr;

                    if (pROption->Length != IPADDRESSOPTIONLEN)
                        return ERROR_PPP_INVALID_PACKET;

                    CopyMemory( &ipaddr, pROption->Data, sizeof(IPADDR) );

                    if (ipaddr == 0)
                    {
                        if (pwb->IpAddressLocal == 0)
                        {
                            /* Server naked us with zero when we asked it to
                            ** assign us an address, meaning he doesn't know
                            ** how to assign us an address but we can provide
                            ** an alternate address if we want.  Currently we
                            ** don't support a backup address here.
                            */
                            return ERROR_PPP_NO_ADDRESS_ASSIGNED;
                        }
                        else
                        {
                            /* Server naked us with zero when we asked for a
                            ** specific address, meaning he doesn't know how
                            ** to assign us an address but we can provide an
                            ** alternate address if we want.  Currently we
                            ** don't support a backup address here.
                            */
                            return ERROR_PPP_REQUIRED_ADDRESS_REJECTED;
                        }
                    }

                    if (pwb->IpAddressLocal != 0)
                    {
                        /* We asked for a specific address (per user's
                        ** instructions) but server says we can't have it and
                        ** is trying to give us another.  No good, tell user
                        ** we can't get the address he requires.
                        */
                        return ERROR_PPP_REQUIRED_ADDRESS_REJECTED;
                    }

                    /* Accept the address suggested by server.
                    */
                    pwb->IpAddressLocal = ipaddr;
                    break;
                }

                case OPTION_DnsIpAddress:
                {
                    if (pROption->Length != IPADDRESSOPTIONLEN)
                        return ERROR_PPP_INVALID_PACKET;

                    //
                    // Use this only if we asked for it
                    //

                    if ( !pwb->fIpaddrDnsRejected )
                    {
                        /* Accept the DNS address suggested by server.
                        */
                        CopyMemory( &pwb->IpInfoLocal.nboDNSAddress,
                            pROption->Data, sizeof(IPADDR) );
                    }

                    break;
                }

                case OPTION_WinsIpAddress:
                {
                    if (pROption->Length != IPADDRESSOPTIONLEN)
                        return ERROR_PPP_INVALID_PACKET;

                    //
                    // Use this only if we asked for it
                    //

                    if ( !pwb->fIpaddrWinsRejected )
                    {
                        /* Accept the WINS address suggested by server.
                        */
                        CopyMemory( &pwb->IpInfoLocal.nboWINSAddress,
                            pROption->Data, sizeof(IPADDR) );
                    }

                    break;
                }

                case OPTION_DnsBackupIpAddress:
                {
                    if (pROption->Length != IPADDRESSOPTIONLEN)
                        return ERROR_PPP_INVALID_PACKET;

                    //
                    // Use this only if we asked for it
                    //

                    if ( !pwb->fIpaddrDnsBackupRejected )
                    {
                        /* Accept the DNS backup address suggested by server.
                        */
                        CopyMemory( &pwb->IpInfoLocal.nboDNSAddressBackup,
                            pROption->Data, sizeof(IPADDR) );
                    }

                    break;
                }

                case OPTION_WinsBackupIpAddress:
                {
                    if (pROption->Length != IPADDRESSOPTIONLEN)
                        return ERROR_PPP_INVALID_PACKET;

                    //
                    // Use this only if we asked for it
                    //

                    if ( !pwb->fIpaddrWinsBackupRejected )
                    {
                        /* Accept the WINS backup address suggested by server.
                        */
                        CopyMemory( &pwb->IpInfoLocal.nboWINSAddressBackup,
                            pROption->Data, sizeof(IPADDR) );
                    }

                    break;
                }

                default:
                    TraceIp("IPCP: Unrequested option NAKed?");
                    break;
            }
        }

        if (pROption->Length && pROption->Length < cbLeft)
            cbLeft -= pROption->Length;
        else
            cbLeft = 0;

        pROption = (PPP_OPTION* )((BYTE* )pROption + pROption->Length);
    }

    return 0;
}


DWORD
IpcpConfigRejReceived(
    IN VOID*       pWorkBuf,
    IN PPP_CONFIG* pReceiveBuf )

    /* Examines received configure-reject in 'pReceiveBuf'.  See RasCp
    ** interface documentation.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    IPCPWB*     pwb = (IPCPWB* )pWorkBuf;
    PPP_OPTION* pROption = (PPP_OPTION* )pReceiveBuf->Data;
    WORD        cbPacket = WireToHostFormat16( pReceiveBuf->Length );
    WORD        cbLeft = cbPacket - PPP_CONFIG_HDR_LEN;

    TraceIp("IPCP: IpcpConfigRejReceived");
    TraceIp("IPCP: Rej received...");
    DUMPB(pReceiveBuf,(pReceiveBuf)?WireToHostFormat16(pReceiveBuf->Length):0);

    pwb->cRequestsWithoutResponse = 0;

    while (cbLeft > 0)
    {
        if (pROption->Type == OPTION_IpCompression)
        {
            TraceIp("IPCP: IP compression was rejected");
            pwb->fIpCompressionRejected = TRUE;
            Protocol(pwb->rpcReceive) = 0;
            MaxSlotId(pwb->rpcReceive) = 0;
            CompSlotId(pwb->rpcReceive) = 0;
        }
        else if ( ( pwb->fServer ) && 
                  ( pwb->IfType != ROUTER_IF_TYPE_FULL_ROUTER ) )
        {
            switch (pROption->Type)
            {
                case OPTION_IpAddress:
                {
                    /* He can't handle a server address option.  No problem,
                    ** it's informational only.
                    */
                    TraceIp("IPCP: Server IP address was rejected");
                    pwb->fIpaddrRejected = TRUE;
                    break;
                }

                default:
                    TraceIp("IPCP: Unrequested option rejected?");
                    break;
            }
        }
        else
        {
            switch (pROption->Type)
            {
                case OPTION_IpAddress:
                {
                    TraceIp("IPCP: IP was rejected");

                    if (pwb->IpAddressLocal != 0)
                    {
                        /* We accept rejection of the IP address if we know
                        ** what address we want to use and use it anyway.
                        ** Some router implementations require a
                        ** certain IP address but can't handle this option to
                        ** confirm that.
                        */
                        pwb->fIpaddrRejected = TRUE;
                        break;
                    }

                    if ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER )
                    {
                        pwb->fUnnumbered = TRUE;
                        break;
                    }
                    else if (pwb->fTryWithoutExtensions)
                    {
                        /* He doesn't know how to give us an IP address, but
                        ** we can't accept no for an answer.  Have to bail.
                        */
                        return ERROR_PPP_NO_ADDRESS_ASSIGNED;
                    }
                    else
                    {
                        /* When we request that server assign us an address,
                        ** this is a required option.  If it's rejected assume
                        ** all the Microsoft extension options were rejected
                        ** and try again.  Other vendors will not test this
                        ** case explicitly and may have bugs in their reject
                        ** code.
                        */
                        TraceIp("IPCP: Tossing MS options (no address)");
                        pwb->fTryWithoutExtensions = TRUE;
                        pwb->fIpaddrDnsRejected = TRUE;
                        pwb->fIpaddrWinsRejected = TRUE;
                        pwb->fIpaddrDnsBackupRejected = TRUE;
                        pwb->fIpaddrWinsBackupRejected = TRUE;
                        return 0;
                    }
                }

                case OPTION_DnsIpAddress:
                {
                    /* He doesn't know how to give us a DNS address, but we
                    ** can live with that.
                    */
                    TraceIp("IPCP: DNS was rejected");
                    pwb->fIpaddrDnsRejected = TRUE;
                    break;
                }

                case OPTION_WinsIpAddress:
                {
                    /* He doesn't know how to give us a WINS address, but we
                    ** can live with that.
                    */
                    TraceIp("IPCP: WINS was rejected");
                    pwb->fIpaddrWinsRejected = TRUE;
                    break;
                }

                case OPTION_DnsBackupIpAddress:
                {
                    /* He doesn't know how to give us a backup DNS address,
                    ** but we can live with that.
                    */
                    TraceIp("IPCP: DNS backup was rejected");
                    pwb->fIpaddrDnsBackupRejected = TRUE;
                    break;
                }

                case OPTION_WinsBackupIpAddress:
                {
                    /* He doesn't know how to give us a backup WINS address,
                    ** but we can live with that.
                    */
                    TraceIp("IPCP: WINS backup was rejected");
                    pwb->fIpaddrWinsBackupRejected = TRUE;
                    break;
                }

                default:
                    TraceIp("IPCP: Unrequested option rejected?");
                    break;
            }
        }

        if (pROption->Length && pROption->Length <= cbLeft)
            cbLeft -= pROption->Length;
        else
        {
            if (pwb->fTryWithoutExtensions)
                cbLeft = 0;
            else
            {
                /* If an invalid packet is detected, assume all the Microsoft
                ** extension options were rejected and try again.  Other
                ** vendors will not test this case explicitly and may have
                ** bugs in their reject code.
                */
                TraceIp("IPCP: Tossing MS options (length)");
                pwb->fTryWithoutExtensions = TRUE;
                pwb->fIpaddrDnsRejected = TRUE;
                pwb->fIpaddrWinsRejected = TRUE;
                pwb->fIpaddrDnsBackupRejected = TRUE;
                pwb->fIpaddrWinsBackupRejected = TRUE;
                return 0;
            }
        }

        pROption = (PPP_OPTION* )((BYTE* )pROption + pROption->Length);
    }

    return 0;
}


DWORD
IpcpGetNegotiatedInfo(
    IN  VOID*               pWorkBuf,
    OUT PPP_IPCP_RESULT *   pIpCpResult 
)
    /* Returns the negotiated IP address in string form followed by the
    ** server's IP address, if known.  The two addresses are null-terminated
    ** strings in back to back 15 + 1 character arrays.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.  "No address
    ** active" is considered successful, and an empty address string is
    ** returned.
    */
{
    IPCPWB* pwb = (IPCPWB* )pWorkBuf;

    TraceIp("IPCP: IpcpGetNetworkAddress...");

    if (pwb->fRasConfigActive || pwb->fExpectingProjection)
    {
        pIpCpResult->fSendVJHCompression    = Protocol(pwb->rpcSend);
        pIpCpResult->fReceiveVJHCompression = Protocol(pwb->rpcReceive);

        pIpCpResult->dwLocalAddress         = pwb->IpAddressLocal;
        pIpCpResult->dwLocalWINSAddress     = pwb->IpInfoLocal.nboWINSAddress;
        pIpCpResult->dwLocalWINSBackupAddress  
                                = pwb->IpInfoLocal.nboWINSAddressBackup;
        pIpCpResult->dwLocalDNSAddress     = pwb->IpInfoLocal.nboDNSAddress;
        pIpCpResult->dwLocalDNSBackupAddress   
                                = pwb->IpInfoLocal.nboDNSAddressBackup;

        pIpCpResult->dwRemoteAddress       = pwb->IpAddressRemote;
        pIpCpResult->dwRemoteWINSAddress   = pwb->IpInfoRemote.nboWINSAddress;
        pIpCpResult->dwRemoteWINSBackupAddress 
                                = pwb->IpInfoRemote.nboWINSAddressBackup;
        pIpCpResult->dwRemoteDNSAddress    = pwb->IpInfoRemote.nboDNSAddress;
        pIpCpResult->dwRemoteDNSBackupAddress   
                                = pwb->IpInfoRemote.nboDNSAddressBackup;
    }

    TraceIp("IPCP: IpcpGetNetworkAddress done");
    return 0;
}

DWORD
IpcpDhcpInform(
    IN IPCPWB*          pwb,
    IN PPP_DHCP_INFORM* pDhcpInform)
{
    TCPIP_INFO*         ptcpip  = NULL;
    IPADDR              nboMask;
    IPADDR              nboIpAddr;

    DWORD               dwErr;
    DWORD               dwDomainNameSize;
    size_t              size;
    DWORD               dwIndex;

    // Get current TCPIP setup info from registry.

    TraceIp("IpcpDhcpInform:LoadTcpipInfo(Device=%ws)",pDhcpInform->wszDevice);
    dwErr = LoadTcpipInfo( &ptcpip, pDhcpInform->wszDevice,
                FALSE /* fAdapterOnly */ );
    TraceIp("IpcpDhcpInform:LoadTcpipInfo done(%d)",dwErr);

    if (dwErr != 0)
    {
        goto LDone;
    }

    TraceIp("IpcpDhcpInform: Old Dns=%ws",
        ptcpip->wszDNSNameServers ? ptcpip->wszDNSNameServers : L"");

    for (dwIndex = 0; dwIndex < pDhcpInform->dwNumDNSAddresses; dwIndex++)
    {
        dwErr = PrependDwIpAddress(
            &ptcpip->wszDNSNameServers, 
            pDhcpInform->pdwDNSAddresses[dwIndex]);

        if (dwErr)
        {
            TraceIp("IpcpDhcpInform: PrependDwIpAddress done(%d)",dwErr);
            goto LDone;
        }
    }

    TraceIp("IpcpDhcpInform: New Dns=%ws",
        ptcpip->wszDNSNameServers ? ptcpip->wszDNSNameServers : L"");

    if (pDhcpInform->dwWINSAddress1)
    {
        PrintMwsz("IpcpDhcpInform: Old Wins=", ptcpip->mwszNetBIOSNameServers);

        if (pDhcpInform->dwWINSAddress2)
        {
            dwErr = PrependDwIpAddressToMwsz(
                &ptcpip->mwszNetBIOSNameServers,
                pDhcpInform->dwWINSAddress2);

            if (dwErr)
            {
                TraceIp("IpcpDhcpInform: PrependDwIpAddress done(%d)",dwErr);
                goto LDone;
            }
        }

        dwErr = PrependDwIpAddressToMwsz(
            &ptcpip->mwszNetBIOSNameServers,
            pDhcpInform->dwWINSAddress1);

        if (dwErr)
        {
            TraceIp("IpcpDhcpInform: PrependDwIpAddress done(%d)",dwErr);
            goto LDone;
        }

        PrintMwsz("IpcpDhcpInform: New Wins=", ptcpip->mwszNetBIOSNameServers);
    }

    if (pDhcpInform->szDomainName)
    {
        dwDomainNameSize = strlen(pDhcpInform->szDomainName) + 1;

        LocalFree(ptcpip->wszDNSDomainName);

        ptcpip->wszDNSDomainName = LocalAlloc(LPTR, sizeof(WCHAR) * dwDomainNameSize);

        if (NULL == ptcpip->wszDNSDomainName)
        {
            dwErr = GetLastError();
            TraceIp("IpcpDhcpInform: LocalAlloc done(%d)", dwErr);
            goto LDone;
        }

        if (0 == MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pDhcpInform->szDomainName,
                    -1,
                    ptcpip->wszDNSDomainName,
                    dwDomainNameSize ) )
        {
            dwErr = GetLastError();
            TraceIp("IpcpDhcpInform: Error %d converting domain name %s",
                dwErr,
                pDhcpInform->szDomainName);
            goto LDone;
        }
    }

    ptcpip->fDisableNetBIOSoverTcpip = pwb->fDisableNetbt;

    // Set TCPIP setup info in registry and release the buffer.
    
    TraceIp("IpcpDhcpInform: SaveTcpipInfo...");
    dwErr = SaveTcpipInfo( ptcpip );
    TraceIp("IpcpDhcpInform: SaveTcpipInfo done(%d)",dwErr);

    if (dwErr != 0)
    {
        goto LDone;
    }

    dwErr = ReconfigureTcpip(pDhcpInform->wszDevice, FALSE, 0, 0);
    if (NO_ERROR != dwErr)
    {
        TraceIp("IpcpDhcpInform: ReconfigureTcpip=%d",dwErr);
        goto LDone;
    }


	nboIpAddr = pwb->IpAddressLocal;

    if ( !pwb->fPrioritizeRemote )
    {
        // We have added this route only if there is 
        // no default route and so remove it if 
        // there is no default route
        // Remove the old route with the guessed mask

        
        nboMask = RasTcpDeriveMask(nboIpAddr);

        if (nboMask != 0)
        {
            RasTcpSetRoute(
                nboIpAddr & nboMask, 
                nboIpAddr, 
                nboMask,
                nboIpAddr,
                FALSE, 
                1,
                TRUE);
        }
    }

    // Add the new route with the precise mask

    nboMask = pDhcpInform->dwSubnetMask;

    if (nboMask != 0)
    {
        RasTcpSetRoute(
            nboIpAddr & nboMask, 
            nboIpAddr, 
            nboMask,
            nboIpAddr,
            TRUE, 
            1,
            TRUE);
    }

    pwb->dwNumDNSAddresses = pDhcpInform->dwNumDNSAddresses;
    pwb->pdwDNSAddresses = pDhcpInform->pdwDNSAddresses;

	if ( pDhcpInform->pbDhcpRoutes )
	{
		//Parse the dhcp routes and plumb ths stack
		RasTcpSetDhcpRoutes ( pDhcpInform->pbDhcpRoutes, pwb->IpAddressLocal, TRUE );
		pwb->pbDhcpRoutes = pDhcpInform->pbDhcpRoutes;
	}
	
LDone:

    FreeTcpipInfo(&ptcpip);

    return(dwErr);
}

DWORD
ResetNetBTConfigInfo(
    IN IPCPWB* pwb )

    /*
    ** Will reset all the NetBT information in the registry to 0
    */
{
    TCPIP_INFO* ptcpip  = NULL;
    DWORD       dwErr;

    /* Get current TCPIP setup info from registry.
    */
    TraceIp("IPCP: LoadTcpipInfo...");
    dwErr = LoadTcpipInfo( &ptcpip, pwb->pwszDevice, TRUE /* fAdapterOnly */ );
    TraceIp("IPCP: LoadTcpipInfo done(%d)",dwErr);

    if (dwErr)
    {
        goto LDone;
    }

    ptcpip->fChanged    = TRUE ;

    /* Set TCPIP setup info in registry and release the buffer.
    */
    TraceIp("IPCP: SaveTcpipInfo...");
    dwErr = SaveTcpipInfo( ptcpip );
    TraceIp("IPCP: SaveTcpipInfo done(%d)",dwErr);

LDone:

    FreeTcpipInfo( &ptcpip );

    pwb->dwNumDNSAddresses = 0;
    LocalFree(pwb->pdwDNSAddresses);
    pwb->pdwDNSAddresses = NULL;

    return( dwErr );
}

VOID
DhcpInform(
    PVOID   pContext
)
{
    IPCP_DHCP_INFORM*   pIpcpDhcpInform = (IPCP_DHCP_INFORM*)pContext;
    PPPE_MESSAGE        PppMessage;
//Changed vivekk
    BYTE    pbRequestedOptions[6];
    BYTE*   pbOptionList                = NULL;
    DWORD   dwOptionListSize;
    BYTE*   pbReturnedOptions           = NULL;
    DWORD   dwNumberOfAvailableOptions;
    DWORD   dwNumOptions;

    DWORD   dwIndex;
    DWORD   dwOffset;
    DWORD   dwNextOffset;
    DWORD   dwCurOffset;
    DWORD   dwDomainNameSize;

    DWORD   dwNumDNSAddresses           = 0;
    IPADDR* pnboDNSAddresses            = NULL;
    IPADDR  nboWINSAddress1             = 0;
    IPADDR  nboWINSAddress2             = 0;
    IPADDR  nboSubnetMask               = 0;
    CHAR*   szDomainName                = NULL;

	PBYTE	pbRouteInfo					= NULL;			//Route information got from DHCP option 133

    DWORD   dwErr;
    BOOL    fFree                       = TRUE;
    BOOL    fSendMessage                = FALSE;
    int     i;

    pbRequestedOptions[0] = OPTION_DNS_NAME_SERVERS;
    pbRequestedOptions[1] = OPTION_NETBIOS_NAME_SERVERS;
    pbRequestedOptions[2] = OPTION_VENDOR_SPEC_INFO;
    pbRequestedOptions[3] = OPTION_SUBNET_MASK;
    pbRequestedOptions[4] = OPTION_VENDOR_ROUTE_PLUMB;
	pbRequestedOptions[5] = OPTION_DNS_DOMAIN_NAME;
    // There is a bug in DhcpRequestOptions, due to which, if we request 
    // OPTION_DNS_DOMAIN_NAME, it automatically gets written to the registry
    
    if (pIpcpDhcpInform->fUseDhcpInformDomainName)
    {
        dwNumOptions = 6;
    }
    else
    {
        dwNumOptions = 5;
    }

    TraceIp("DhcpRequestOptions(%ws)...", pIpcpDhcpInform->wszDevice); 

    dwErr = PDhcpRequestOptions(
                                pIpcpDhcpInform->wszDevice,
                                pbRequestedOptions,
                                dwNumOptions,
                                &pbOptionList,
                                &dwOptionListSize,
                                &pbReturnedOptions,
                                &dwNumberOfAvailableOptions);

    TraceIp("DhcpRequestOptions done(%d)", dwErr);

    if (dwErr != ERROR_SUCCESS)
    {
        goto LDhcpInformEnd;
    }

    TraceIpDump(pbOptionList, dwOptionListSize);

    for (dwIndex = 0, dwOffset = 0;
         dwIndex < dwNumberOfAvailableOptions;
         dwIndex++)
    {
        RTASSERT(dwOffset + 1 <= dwOptionListSize);

        switch (pbReturnedOptions[dwIndex])
        {
        case OPTION_DNS_DOMAIN_NAME:

            dwDomainNameSize = pbOptionList[dwOffset]; 

            if (0 == dwDomainNameSize)
            {
                TraceIp("Invalid DOMAIN_NAME size %d", dwDomainNameSize);
                goto LDhcpInformEnd;
            }

            if (NULL != szDomainName)
            {
                LocalFree(szDomainName);
            }

            szDomainName = LocalAlloc(LPTR, dwDomainNameSize + 1);

            if (NULL == szDomainName)
            {
                TraceIp("DhcpInform: LocalAlloc=%d", GetLastError());
                goto LDhcpInformEnd;
            }

            dwNextOffset = dwOffset + dwDomainNameSize + 1;

            CopyMemory(szDomainName, pbOptionList + dwOffset + 1,
                dwDomainNameSize);

            fSendMessage = TRUE;

            TraceIp("DhcpInform: DOMAIN_NAME %s", szDomainName);

            dwOffset = dwNextOffset;

            break;

        case OPTION_DNS_NAME_SERVERS:

            if (0 != (pbOptionList[dwOffset] % 4))
            {
                TraceIp("Invalid DOMAIN_NAME_SERVERS size %d",
                       pbOptionList[dwOffset]);
                goto LDhcpInformEnd;
            }

            if (NULL != pnboDNSAddresses)
            {
                LocalFree(pnboDNSAddresses);
                dwNumDNSAddresses = 0;
            }

            pnboDNSAddresses = LocalAlloc(LPTR,
                    sizeof(IPADDR) * pbOptionList[dwOffset] / 4);

            if (NULL == pnboDNSAddresses)
            {
                TraceIp("DhcpInform: LocalAlloc=%d",GetLastError());
                goto LDhcpInformEnd;
            }

            dwNextOffset = dwOffset + pbOptionList[dwOffset] + 1;

            for (dwCurOffset = dwOffset + 1;
                 dwCurOffset < dwNextOffset;
                 dwCurOffset += 4, dwNumDNSAddresses++)
            {
                pnboDNSAddresses[dwNumDNSAddresses] =
                            (pbOptionList[dwCurOffset]) +
                            (pbOptionList[dwCurOffset + 1] << 8) +
                            (pbOptionList[dwCurOffset + 2] << 16) +
                            (pbOptionList[dwCurOffset + 3] << 24);

                TraceIp("DhcpInform: DOMAIN_NAME_SERVER 0x%x",
                       pnboDNSAddresses[dwNumDNSAddresses]);
                fSendMessage = TRUE;
            }

            RTASSERT((DWORD)(pbOptionList[dwOffset] / 4) == dwNumDNSAddresses);

            dwOffset = dwNextOffset;

            break;

        case OPTION_NETBIOS_NAME_SERVERS:

            if (0 != (pbOptionList[dwOffset] % 4))
            {
                TraceIp("Invalid NETBIOS_NAME_SERVER size %d",
                    pbOptionList[dwOffset]);
                goto LDhcpInformEnd;
            }

            dwNextOffset = dwOffset + pbOptionList[dwOffset] + 1;
            dwCurOffset = dwOffset + 1;

            for (i = 0; i < 2; i++)
            {
                IPADDR* paddr;

                if (0 == i)
                {
                    paddr = &nboWINSAddress1;
                }
                else
                {
                    paddr = &nboWINSAddress2;
                }

                *paddr =
                    (pbOptionList[dwCurOffset]) +
                    (pbOptionList[dwCurOffset + 1] << 8) +
                    (pbOptionList[dwCurOffset + 2] << 16) +
                    (pbOptionList[dwCurOffset + 3] << 24);

                TraceIp("DhcpInform: NETBIOS_NAME_SERVER 0x%x",
                    *paddr);

                fSendMessage = TRUE;

                dwCurOffset += 4;
                if (dwCurOffset == dwNextOffset)
                {
                    break;
                }
            }

            dwOffset = dwNextOffset;

            break;

        case OPTION_SUBNET_MASK:

            if (0 != (pbOptionList[dwOffset] % 4))
            {
                TraceIp("Invalid OPTION_SUBNET_MASK size %d",
                       pbOptionList[dwOffset]);
                goto LDhcpInformEnd;
            }

            dwNextOffset = dwOffset + pbOptionList[dwOffset] + 1;

            nboSubnetMask = (pbOptionList[dwOffset + 1]) +
                            (pbOptionList[dwOffset + 2] << 8) +
                            (pbOptionList[dwOffset + 3] << 16) +
                            (pbOptionList[dwOffset + 4] << 24);

            TraceIp("DhcpInform: OPTION_SUBNET_MASK 0x%x", nboSubnetMask);

            fSendMessage = TRUE;

            dwOffset = dwNextOffset;

            break;
		case OPTION_VENDOR_ROUTE_PLUMB:
			TraceIp("DhcpInform: OPTION_VENDOR_ROUTE_PLUMB Code %x Len %x", pbOptionList[dwOffset], pbOptionList[dwOffset+1]);
			//this should be a minimum of 5 bytes
			dwNextOffset = dwOffset + pbOptionList[dwOffset] + 1;
			if ( pbOptionList[dwOffset+1]  < 5 )
			{
				TraceIp("Invalid OPTION_VENDOR_ROUTE_PLUMB size %d", pbOptionList[dwOffset+1]);
				goto LDhcpInformEnd;
			}
			//now decode the 
			fSendMessage = TRUE;
			pbRouteInfo = (PBYTE)LocalAlloc(LPTR, pbOptionList[dwOffset] + 1 );
            if (NULL == pbRouteInfo)
            {
                TraceIp("DhcpInform: LocalAlloc=%d",GetLastError());
                goto LDhcpInformEnd;
            }
            CopyMemory(pbRouteInfo, pbOptionList + dwOffset,
							pbOptionList[dwOffset]+1);
			fSendMessage= TRUE;
            dwOffset = dwNextOffset;
			break;
        default:

            dwOffset += pbOptionList[dwOffset] + 1;
            break;
        }
    }

    if (fSendMessage)
    {
        PppMessage.dwMsgId = PPPEMSG_DhcpInform;
        PppMessage.hConnection = pIpcpDhcpInform->hConnection;
        PppMessage.ExtraInfo.DhcpInform.wszDevice = pIpcpDhcpInform->wszDevice;
        PppMessage.ExtraInfo.DhcpInform.dwNumDNSAddresses = dwNumDNSAddresses;
        PppMessage.ExtraInfo.DhcpInform.pdwDNSAddresses = pnboDNSAddresses;
        PppMessage.ExtraInfo.DhcpInform.dwWINSAddress1 = nboWINSAddress1;
        PppMessage.ExtraInfo.DhcpInform.dwWINSAddress2 = nboWINSAddress2;
        PppMessage.ExtraInfo.DhcpInform.dwSubnetMask = nboSubnetMask;
        PppMessage.ExtraInfo.DhcpInform.szDomainName = szDomainName;
		PppMessage.ExtraInfo.DhcpInform.pbDhcpRoutes = pbRouteInfo;
        dwErr = SendPPPMessageToEngine(&PppMessage);

        if (dwErr != NO_ERROR)
        {
            TraceIp("DhcpInform: SendPPPMessageToEngine=%d",dwErr);
            goto LDhcpInformEnd;
        }

        fFree = FALSE;
    }

LDhcpInformEnd:

    if (fFree)
    {
        LocalFree(pIpcpDhcpInform->wszDevice);
        LocalFree(pnboDNSAddresses);
        LocalFree(szDomainName);
		LocalFree(pbRouteInfo);
    }

    LocalFree(pIpcpDhcpInform);
    LocalFree(pbOptionList);
    LocalFree(pbReturnedOptions);
}

DWORD
IpcpProjectionNotification(
    IN VOID* pWorkBuf,
    IN VOID* pProjectionResult )

    /* Called when projection result of all CPs is known.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    DWORD   dwErr = 0;
    IPCPWB* pwb = (IPCPWB* )pWorkBuf;
    BOOL fSetDefaultRoute = FALSE;

    TraceIp("IPCP: IpcpProjectionNotification");

    if (pwb->fExpectingProjection)
    {
        CHAR szBuf[sizeof(PROTOCOL_CONFIG_INFO) + sizeof(IP_WAN_LINKUP_INFO)];

        IPCPWB*                pwb = (IPCPWB* )pWorkBuf;
        PROTOCOL_CONFIG_INFO*  pProtocol = (PROTOCOL_CONFIG_INFO* )szBuf;
        IP_WAN_LINKUP_INFO UNALIGNED *pLinkUp = (PIP_WAN_LINKUP_INFO)pProtocol->P_Info;
        PPP_PROJECTION_RESULT* p = (PPP_PROJECTION_RESULT* )pProjectionResult;

        /* Activate the route between the TCP/IP stack and the RAS MAC.
        */
        pProtocol->P_Length = sizeof(IP_WAN_LINKUP_INFO);

        pLinkUp->duUsage = ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER ) 
                             ? DU_ROUTER
                             : (pwb->fServer) ? DU_CALLIN : DU_CALLOUT;

        pLinkUp->dwUserIfIndex = HandleToULong(pwb->hIPInterface);
        pLinkUp->dwLocalMask  = 0xFFFFFFFF;
        pLinkUp->dwLocalAddr    = pwb->IpAddressLocal;
        pLinkUp->dwRemoteAddr   = pwb->IpAddressRemote;

        pLinkUp->fFilterNetBios =
             (pwb->fServer && p->nbf.dwError == 0);

        pLinkUp->fDefaultRoute = pwb->fPrioritizeRemote;

        TraceIp("IPCP: RasActivateRoute(u=%x,a=%x,nf=%d)...",
                    pLinkUp->duUsage,pLinkUp->dwLocalAddr,
                    pLinkUp->fFilterNetBios);

        TraceIp("IPCP: RasActivateRoute ICB# == %d",
                pLinkUp->dwUserIfIndex);

        dwErr = RasActivateRoute(pwb->hport,IP,&pwb->routeinfo,pProtocol);

        TraceIp("IPCP: RasActivateRoute done(%d)",dwErr);

        if ( dwErr == 0 )
        {
            pwb->fRouteActivated = TRUE;

            /* Find the device name within the adapter name, e.g. ndiswan00.  
            ** This is used to identify adapters in the TcpipInfo calls later.
            */
            pwb->pwszDevice = wcschr(&pwb->routeinfo.RI_AdapterName[1], L'\\');

            if ( !pwb->pwszDevice ) 
            {
                TraceIp("IPCP: No device?");
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else
            {
                ++pwb->pwszDevice;
            }
        }

        //
        // If we are a client or a router dialing in or out we need to plumb
        // the registry.
        //

        if ( ( dwErr == 0 ) && 
             ((!pwb->fServer) || (pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER)))
        {
            do
            {
            
                TCPIP_INFO* ptcpip;

                /* Get current TCPIP setup info from registry.
                */
                TraceIp("IPCP:LoadTcpipInfo(Device=%ws)",pwb->pwszDevice);
                dwErr = LoadTcpipInfo( &ptcpip, pwb->pwszDevice,
                            TRUE /* fAdapterOnly */ );
                TraceIp("IPCP: LoadTcpipInfo done(%d)",dwErr);

                if (dwErr != 0)
                    break;

                //
                // We first save the IP address and call 
                // DhcpNotifyConfigChange, then set WINS/DNS and call
                // DhcpNotifyConfigChange to work around Windows 2000 bug 
                // 381884.
                //

                AbcdWszFromIpAddress(pwb->IpAddressLocal, ptcpip->wszIPAddress);
                AbcdWszFromIpAddress(pLinkUp->dwLocalMask, ptcpip->wszSubnetMask);

                ptcpip->fDisableNetBIOSoverTcpip = pwb->fDisableNetbt;

                ptcpip->fChanged    = TRUE ;
                
                TraceIp("IPCP: SaveTcpipInfo...");

                dwErr = SaveTcpipInfo( ptcpip );

                TraceIp("IPCP: SaveTcpipInfo done(%d)",dwErr);

                if (dwErr)
                {
                    ResetNetBTConfigInfo( pwb );
                    FreeTcpipInfo( &ptcpip );
                    break;
                }

#if 0
                if (!pwb->fUnnumbered)
                {
                    /* Tell TCPIP components to reconfigure themselves.
                    */
                    if ((dwErr = ReconfigureTcpip(pwb->pwszDevice,
                                                  TRUE,
                                                  pwb->IpAddressLocal,
                                                  pLinkUp->dwLocalMask)) != NO_ERROR)
                    {
                        TraceIp("IPCP: ReconfigureTcpip=%d",dwErr);
                        ResetNetBTConfigInfo( pwb );
                        FreeTcpipInfo( &ptcpip );
                        break;
                    }
                }

#endif                

                /* Make the LAN the default interface in multi-homed case.
                */
                if(pLinkUp->duUsage != DU_ROUTER)
                {

                    BOOL fAddRoute = TRUE;
                    RASMAN_INFO *pInfo = LocalAlloc(LPTR, sizeof(RASMAN_INFO));

                    if(NULL != pInfo)
                    {
                        dwErr = RasGetInfo(NULL, pwb->hport, pInfo);
                        if(ERROR_SUCCESS != dwErr)
                        {
                            TraceIp("IPCP: HelperSetDefaultInterfaceNet, RasGetInfo "
                                    "failed 0x%x", dwErr);
                        }

                        if(RAS_DEVICE_CLASS(pInfo->RI_rdtDeviceType) 
                                == RDT_Tunnel)
                        {
                            fAddRoute = FALSE;
                        }

                        LocalFree(pInfo);
                    }
                    
                    //
                    // Do the change metric and add subnet route stuff
                    // for non router cases only
                    //

                    TraceIp("IPCP: HelperSetDefaultInterfaceNet(a=%08x,f=%d)",
                           pwb->IpAddressLocal,pwb->fPrioritizeRemote);

                    dwErr = HelperSetDefaultInterfaceNet(
                                                    pwb->IpAddressLocal, 
                                                    (fAddRoute) ?
                                                    pwb->IpAddressRemote : 
                                                    0,
                                                    pwb->fPrioritizeRemote,
                                                    pwb->pwszDevice);

                    TraceIp("IPCP: HelperSetDefaultInterfaceNet done(%d)",
                            dwErr);

                    if ( dwErr != NO_ERROR )
                    {
                        // ResetNetBTConfigInfo( pwb );
                        // FreeTcpipInfo( &ptcpip );
                        break;
                    }

                    fSetDefaultRoute = TRUE;
                }


#if 0

                /* Get current TCPIP setup info from registry.
                */
                TraceIp("IPCP:LoadTcpipInfo(Device=%ws)",pwb->pwszDevice);
                dwErr = LoadTcpipInfo( &ptcpip, pwb->pwszDevice,
                            TRUE /* fAdapterOnly */ );
                TraceIp("IPCP: LoadTcpipInfo done(%d)",dwErr);

                if (dwErr != 0)
                    break;
                    
                AbcdWszFromIpAddress(pwb->IpAddressLocal, ptcpip->wszIPAddress);
                AbcdWszFromIpAddress(pLinkUp->dwLocalMask, ptcpip->wszSubnetMask);

#endif
                
                ptcpip->fChanged    = FALSE ;

                /* Add the negotiated DNS and backup DNS server (if any)
                ** at the head of the list of DNS servers.  (Backup is
                ** done first so the the non-backup will wind up first)
                */
                if (pwb->IpInfoLocal.nboDNSAddressBackup)
                {
                    dwErr = PrependDwIpAddress(
                        &ptcpip->wszDNSNameServers,
                        pwb->IpInfoLocal.nboDNSAddressBackup );

                    if (dwErr)
                    {
                        FreeTcpipInfo( &ptcpip );
                        break;
                    }
                }

                if (pwb->IpInfoLocal.nboDNSAddress)
                {
                    dwErr = PrependDwIpAddress(
                        &ptcpip->wszDNSNameServers, 
                        pwb->IpInfoLocal.nboDNSAddress );

                    if (dwErr)
                    {
                        FreeTcpipInfo( &ptcpip );
                        break;
                    }
                }

                TraceIp("IPCP: New Dns=%ws",
                    ptcpip->wszDNSNameServers ? ptcpip->wszDNSNameServers : L"");

                if (!pwb->fRegisterWithWINS)
                {
                    // Ignore the WINS server addresses. If we save them, then 
                    // registration will happen automatically.
                }
                else
                {
                    /* Set the WINS and backup WINS server addresses to
                    ** the negotiated addresses (if any).
                    */

                    if (pwb->IpInfoLocal.nboWINSAddressBackup)
                    {
                        dwErr = PrependDwIpAddressToMwsz(
                            &ptcpip->mwszNetBIOSNameServers,
                            pwb->IpInfoLocal.nboWINSAddressBackup );

                        if (dwErr)
                        {
                            FreeTcpipInfo( &ptcpip );
                            break;
                        }
                    }

                    if (pwb->IpInfoLocal.nboWINSAddress)
                    {
                        dwErr = PrependDwIpAddressToMwsz(
                            &ptcpip->mwszNetBIOSNameServers,
                            pwb->IpInfoLocal.nboWINSAddress );

                        if (dwErr)
                        {
                            FreeTcpipInfo( &ptcpip );
                            break;
                        }
                    }

                    PrintMwsz("IPCP: New Wins=",
                                        ptcpip->mwszNetBIOSNameServers);
                }

                // The DNS API's are called in rasSrvrInitAdapterName also.

                if (pwb->fRegisterWithDNS)
                {
                    DnsEnableDynamicRegistration(pwb->pwszDevice);
                    TraceIp("DnsEnableDynamicRegistration");
                }
                else
                {
                    DnsDisableDynamicRegistration(pwb->pwszDevice);
                    TraceIp("DnsDisableDynamicRegistration");
                }

                if (pwb->fRegisterAdapterDomainName)
                {
                    DnsEnableAdapterDomainNameRegistration(pwb->pwszDevice);
                    TraceIp("DnsEnableAdapterDomainNameRegistration");
                }
                else
                {
                    DnsDisableAdapterDomainNameRegistration(pwb->pwszDevice);
                    TraceIp("DnsDisableAdapterDomainNameRegistration");
                }

                if (pwb->szDnsSuffix[0] != 0)
                {
                    DWORD dwDomainNameSize;

                    dwDomainNameSize = strlen(pwb->szDnsSuffix) + 1;

                    ptcpip->wszDNSDomainName = LocalAlloc(LPTR, sizeof(WCHAR) * dwDomainNameSize);

                    if (NULL != ptcpip->wszDNSDomainName)
                    {
                        MultiByteToWideChar(
                                CP_ACP,
                                0,
                                pwb->szDnsSuffix,
                                -1,
                                ptcpip->wszDNSDomainName,
                                dwDomainNameSize );
                    }
                }

                TraceIp("IPCP: SaveTcpipInfo...");

                dwErr = SaveTcpipInfo( ptcpip );

                TraceIp("IPCP: SaveTcpipInfo done(%d)",dwErr);
                
                FreeTcpipInfo( &ptcpip );

                if (dwErr != 0)
                {
                    break;
                }

                if (!pwb->fUnnumbered)
                {
                    /* Tell TCPIP components to reconfigure themselves.
                    */
                    if ((dwErr = ReconfigureTcpip(pwb->pwszDevice,
                                                  TRUE,
                                                  pwb->IpAddressLocal,
                                                  pLinkUp->dwLocalMask)) != NO_ERROR)
                    {
                        TraceIp("IPCP: ReconfigureTcpip=%d",dwErr);
                        // This will fail if the dhcp client is not running.
                        // dwErr = NO_ERROR;
                        ResetNetBTConfigInfo( pwb );
                        break;
                    }
                }
				/* Adjust the metric for Multicast class D Addresses */
				if ( (!pwb->fServer) 
                    )
				{
					dwErr = RasTcpAdjustMulticastRouteMetric ( pwb->IpAddressLocal, TRUE );
					if ( NO_ERROR != dwErr )
					{
						TraceIp("IPCP: =RasTcpAdjustMulticastRouteMetric%d",dwErr);
						dwErr = NO_ERROR;
					}


				}
                /* Do DHCPINFORM only for clients */

                while ((!pwb->fServer) &&
                    (pwb->IfType != ROUTER_IF_TYPE_FULL_ROUTER))
                {
                    IPCP_DHCP_INFORM*   pIpcpDhcpInform     = NULL;
                    BOOL                fErr                = TRUE;

                    pIpcpDhcpInform = LocalAlloc(LPTR, sizeof(IPCP_DHCP_INFORM));

                    if (NULL == pIpcpDhcpInform)
                    {
                        TraceIp("IPCP: LocalAlloc 1 =%d",GetLastError());
                        goto LWhileEnd;
                    }

                    pIpcpDhcpInform->fUseDhcpInformDomainName = 
                                    (pwb->szDnsSuffix[0] == 0);

                    pIpcpDhcpInform->wszDevice = LocalAlloc(LPTR,
                            sizeof(WCHAR) * (wcslen(pwb->pwszDevice) + 1));

                    if (NULL == pIpcpDhcpInform->wszDevice)
                    {
                        TraceIp("IPCP: LocalAlloc 2 =%d",GetLastError());
                        goto LWhileEnd;
                    }

                    wcscpy(pIpcpDhcpInform->wszDevice, pwb->pwszDevice);
                    pIpcpDhcpInform->hConnection = pwb->hConnection;

                    dwErr = RtlQueueWorkItem(DhcpInform, pIpcpDhcpInform,
                                WT_EXECUTELONGFUNCTION);

                    if (dwErr != STATUS_SUCCESS)
                    {
                        TraceIp("IPCP: RtlQueueWorkItem=%d",dwErr);
                        goto LWhileEnd;
                    }

                    fErr = FALSE;

LWhileEnd:
                    if (fErr)
                    {
                        if (pIpcpDhcpInform)
                        {
                            LocalFree(pIpcpDhcpInform->wszDevice);
                        }

                        LocalFree(pIpcpDhcpInform);
                    }

                    break;
                }
            }
            while (FALSE);
        }

        if (dwErr == 0)
        {
            pwb->fRasConfigActive = TRUE;

            /* Tell MAC about any negotiated compression parameters.
            */
            if (pwb->fIpCompressionRejected)
            {
                Protocol(pwb->rpcReceive) = NO_PROTOCOL_COMPRESSION;
                MaxSlotId(pwb->rpcReceive) = 0;
                CompSlotId(pwb->rpcReceive) = 0;
            }

            if (!pwb->fSendCompression)
            {
                Protocol(pwb->rpcSend) = NO_PROTOCOL_COMPRESSION;
                MaxSlotId(pwb->rpcSend) = 0;
                CompSlotId(pwb->rpcSend) = 0;
            }

            //if (Protocol(pwb->rpcSend) != 0 || Protocol(pwb->rpcReceive) != 0)
            {
                TraceIp("IPCP:RasPortSetProtocolCompression(s=%d,%d r=%d,%d)",
                    (int)MaxSlotId(pwb->rpcSend),(int)CompSlotId(pwb->rpcSend),
                    (int)MaxSlotId(pwb->rpcReceive),
                    (int)CompSlotId(pwb->rpcReceive));
                dwErr = RasPortSetProtocolCompression(
                            pwb->hport, IP, &pwb->rpcSend, &pwb->rpcReceive );
                TraceIp("IPCP: RasPortSetProtocolCompression done(%d)",dwErr);
            }

            if (   ( ( pwb->fServer ) || 
                     ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER ) )
                && ( pwb->IpAddressRemote != 0 ))
            {
                WCHAR*  pwsz[5];
                WCHAR   wszIPAddress[MAXIPSTRLEN + 1];
                WCHAR   wszSubnet[MAXIPSTRLEN + 1];
                WCHAR   wszMask[MAXIPSTRLEN + 1];

                /* Register addresses in server's routing tables.
                */

                TraceIp("IPCP: RasSrvrActivateIp...");
                dwErr = RasSrvrActivateIp( pwb->IpAddressRemote,
                                            pLinkUp->duUsage );
                TraceIp("IPCP: RasSrvrActivateIp done(%d)",dwErr);
            }

            if ( pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER )
            {
                WCHAR*  pwsz[2];

                if ( pwb->IpAddressRemote == 0 )
                {
                    pwsz[0] = pwb->wszPortName;
                    pwsz[1] = pwb->wszUserName;

                    LogEventW(EVENTLOG_WARNING_TYPE,
                        ROUTERLOG_REMOTE_UNNUMBERED_IPCP, 2,
                        pwsz);
                }

                if ( pwb->IpAddressLocal == 0 )
                {
                    pwsz[0] = pwb->wszPortName;
                    pwsz[1] = pwb->wszUserName;

                    LogEventW(EVENTLOG_WARNING_TYPE,
                        ROUTERLOG_LOCAL_UNNUMBERED_IPCP, 2,
                        pwsz);
                }
            }
        }

        pwb->fExpectingProjection = FALSE;

        if (dwErr != NO_ERROR)
        {
            if(pwb->fRouteActivated)
            {
                TraceIp("IPCP: RasDeAllocateRoute...");
                RasDeAllocateRoute( pwb->hConnection, IP );
                pwb->fRouteActivated = FALSE;
            }

            if(fSetDefaultRoute)
            {
                HelperResetDefaultInterfaceNet(
                                    pwb->IpAddressLocal, 
                                    pwb->fPrioritizeRemote);
            }
        }
    }

    return dwErr;
}

/*---------------------------------------------------------------------------
** Internal routines (alphabetically)
**---------------------------------------------------------------------------
*/


VOID
AddIpAddressOption(
    OUT BYTE UNALIGNED*  pbBuf,
    IN  BYTE             bOption,
    IN  IPADDR           ipaddr )

    /* Write an IP address 'ipaddr' configuration option of type 'bOption' at
    ** location 'pbBuf'.
    */
{
    *pbBuf++ = bOption;
    *pbBuf++ = IPADDRESSOPTIONLEN;
    *((IPADDR UNALIGNED* )pbBuf) = ipaddr;
}


VOID
AddIpCompressionOption(
    OUT BYTE UNALIGNED*          pbBuf,
    IN  RAS_PROTOCOLCOMPRESSION* prpc )

    /* Write an IP compression protocol configuration as described in '*prpc'
    ** at location 'pbBuf'.
    */
{
    *pbBuf++ = OPTION_IpCompression;
    *pbBuf++ = IPCOMPRESSIONOPTIONLEN;
    HostToWireFormat16U( Protocol(*prpc), pbBuf );
    pbBuf += 2;
    *pbBuf++ = MaxSlotId(*prpc);
    *pbBuf = CompSlotId(*prpc);
}

/*

Notes:
    DeActivates the active RAS configuration, if any.

*/

DWORD
DeActivateRasConfig(
    IN  IPCPWB* pwb
)
{
    DWORD   dwErr   = NO_ERROR;

    if (!pwb->fRasConfigActive)
    {
        goto LDone;
    }

    TraceIp("DeActivateRasConfig");

    dwErr = ResetNetBTConfigInfo(pwb);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }
	/* Adjust the metric for Multicast class D Addresses */
	if ( (!pwb->fServer) 
        )
	{
		RasTcpAdjustMulticastRouteMetric ( pwb->IpAddressLocal, FALSE );
		//The route will be automatically removed when the interface disapperars
	}

    dwErr = ReconfigureTcpip(pwb->pwszDevice, TRUE, 0, 0);

    if (NO_ERROR != dwErr)
    {
        // Ignore errors. You may get a 15 here.
        dwErr = NO_ERROR;
    }

    if (pwb->IfType != ROUTER_IF_TYPE_FULL_ROUTER)
    {
        TraceIp("HelperResetDefaultInterfaceNet(0x%x, %sPrioritizeRemote)",
            pwb->IpAddressLocal,
            pwb->fPrioritizeRemote ? "" : "!");

        dwErr = HelperResetDefaultInterfaceNet(
                    pwb->IpAddressLocal, pwb->fPrioritizeRemote);

        if (NO_ERROR != dwErr)
        {
            TraceIp("HelperResetDefaultInterfaceNet failed and returned %d",
                dwErr);
        }
    }

LDone:

    return(dwErr);
}

DWORD
NakCheck(
    IN  IPCPWB*     pwb,
    IN  PPP_CONFIG* pReceiveBuf,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf,
    OUT BOOL*       pfNak,
    IN  BOOL        fRejectNaks )

    /* Check to see if received packet 'pReceiveBuf' should be Naked and if
    ** so, build a Nak packet with suggested values in 'pSendBuf'.  If
    ** 'fRejectNaks' is set the original options are placed in a Reject packet
    ** instead.  '*pfNak' is set true if either a Nak or Rej packet was
    ** created.
    **
    ** Note: This routine assumes that corrupt packets have already been
    **       weeded out.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    PPP_OPTION UNALIGNED* pROption = (PPP_OPTION UNALIGNED* )pReceiveBuf->Data;
    PPP_OPTION UNALIGNED* pSOption = (PPP_OPTION UNALIGNED* )pSendBuf->Data;

    /* (server only) The address the client requests, then if NAKed, the non-0
    ** address we NAK with.  If this is 0 after the packet has been processed,
    ** the IP-Address option was not negotiated.
    */
    IPADDR ipaddrClient = 0;

    DWORD dwErr = 0;
    WORD  cbPacket = WireToHostFormat16( pReceiveBuf->Length );
    WORD  cbLeft = cbPacket - PPP_CONFIG_HDR_LEN;

    TraceIp("IPCP: NakCheck");

    *pfNak = FALSE;

    while (cbLeft > 0)
    {
        RTASSERT(cbLeft>=pROption->Length);

        if (pROption->Type == OPTION_IpCompression)
        {
            BOOL fNakCompression = FALSE;

            if (WireToHostFormat16U(pROption->Data )
                    == COMPRESSION_VanJacobson)
            {
                RTASSERT((pROption->Length==IPCOMPRESSIONOPTIONLEN));

                /* He wants to receive Van Jacobson.  We know we can do it or
                ** it would have already been rejected, but make sure we can
                ** handle his slot parameters.
                */
                if (pROption->Data[ 2 ] <= MaxSlotId(pwb->rpcSend))
                {
                    /* We can accept his suggested MaxSlotID when it is less
                    ** than or the same as what we can send.
                    */
                    MaxSlotId(pwb->rpcSend) = pROption->Data[ 2 ];
                }
                else
                    fNakCompression = TRUE;

                if (CompSlotId(pwb->rpcSend))
                {
                    /* We can compress the slot-ID or not, so just accept
                    ** whatever he wants us to send.
                    */
                    CompSlotId(pwb->rpcSend) = pROption->Data[ 3 ];
                }
                else if (pROption->Data[ 3 ])
                    fNakCompression = TRUE;
            }
            else
                fNakCompression = TRUE;

            if (fNakCompression)
            {
                TraceIp("IPCP: Naking IP compression");
                *pfNak = TRUE;

                if (fRejectNaks)
                {
                    CopyMemory(
                        (VOID* )pSOption, (VOID* )pROption, pROption->Length );
                }
                else
                {
                    pSOption->Type = OPTION_IpCompression;
                    pSOption->Length = IPCOMPRESSIONOPTIONLEN;
                    HostToWireFormat16U(
                        (WORD )COMPRESSION_VanJacobson,
                        pSOption->Data );

                    pSOption->Data[ 2 ] = MaxSlotId(pwb->rpcSend);
                    pSOption->Data[ 3 ] = CompSlotId(pwb->rpcSend);

                    pSOption =
                        (PPP_OPTION UNALIGNED* )((BYTE* )pSOption +
                        pSOption->Length);
                }

                pwb->fSendCompression = FALSE;
            }
            else
            {
                pwb->fSendCompression = TRUE;
            }
        }
        else if ((pwb->fServer) || (pwb->IfType == ROUTER_IF_TYPE_FULL_ROUTER))
        {
            switch (pROption->Type)
            {
                case OPTION_IpAddress:
                {
                    RTASSERT(pROption->Length==IPADDRESSOPTIONLEN);
                    CopyMemory( &ipaddrClient, pROption->Data, sizeof(IPADDR) );

                    if (pwb->IpAddressRemote != 0)
                    {
                        if ( ipaddrClient == pwb->IpAddressRemote )
                        {
                            //
                            // If we have already allocated what the user
                            // wants, we are done with this option.
                            //

                            break;
                        }
                        else if ( ipaddrClient == 0 )
                        {
                            ipaddrClient = pwb->IpAddressRemote;

                            *pfNak = TRUE;
                            CopyMemory(
                                (VOID* )pSOption, (VOID* )pROption,
                                pROption->Length );

                            if (!fRejectNaks)
                            {
                                TraceIp("IPCP: Naking IP");

                                CopyMemory( pSOption->Data,
                                    &pwb->IpAddressRemote,
                                    sizeof(IPADDR) );
                            }

                            pSOption =
                                (PPP_OPTION UNALIGNED* )((BYTE* )pSOption +
                                pROption->Length);

                            break;
                        }
                        else
                        {
                            TraceIp("IPCP: RasSrvrReleaseAddress...");
                            RasSrvrReleaseAddress( 
                                pwb->IpAddressRemote,
                                pwb->wszUserName,
                                pwb->wszPortName,
                                FALSE );
                            TraceIp("IPCP: RasSrvrReleaseAddress done");

                            pwb->IpAddressRemote = 0;
                        }
                    }

                    //
                    // If client is requesting an IP address, check to see
                    // if we are allowed to give it to him.
                    //

                    if ( ( ipaddrClient != 0 )                          &&
                         ( pwb->IfType != ROUTER_IF_TYPE_FULL_ROUTER )  &&
                         ( pwb->IpAddressToHandout == net_long( 0xFFFFFFFE ) ) )
                    {
                        TraceIp("IPCP: Clients not allowed to request IPaddr");

                        ipaddrClient = 0;
                    }

                    TraceIp("IPCP: RasSrvrAcquireAddress(%08x)...",
                            ipaddrClient);
                    dwErr = RasSrvrAcquireAddress(
                            pwb->hport, 
                            ((pwb->IpAddressToHandout != net_long(0xFFFFFFFF))&&
                             (pwb->IpAddressToHandout != net_long(0xFFFFFFFE)))
                                ? pwb->IpAddressToHandout
                                : ipaddrClient,
                            &(pwb->IpAddressRemote),
                            pwb->wszUserName,
                            pwb->wszPortName );
                    TraceIp("IPCP: RasSrvrAcquireAddress done(%d)",
                            dwErr);

                    if (dwErr != 0)
                    {
                        return dwErr;
                    }

                    if (ipaddrClient != 0)
                    {
                        TraceIp("IPCP: Hard IP requested");

                        if ( ipaddrClient == pwb->IpAddressRemote )
                        {
                            /* Good. Client's asking for the address we 
                            ** want to give him.
                            */
                            TraceIp("IPCP: Accepting IP");
                            break;
                        }
                        else
                        {
                            // 
                            // Otherwise we could not give the user the
                            // address he/she requested. Nak with this address.
                            //

                            TraceIp("IPCP: 3rd party DLL changed IP");
                        }
                    }
                    else
                    {
                        TraceIp("IPCP: Server IP requested");
                    }

                    ipaddrClient = pwb->IpAddressRemote;

                    *pfNak = TRUE;
                    CopyMemory(
                        (VOID* )pSOption, (VOID* )pROption,
                        pROption->Length );

                    if (!fRejectNaks)
                    {
                        TraceIp("IPCP: Naking IP");

                        CopyMemory( pSOption->Data,
                            &pwb->IpAddressRemote,
                            sizeof(IPADDR) );
                    }

                    pSOption =
                        (PPP_OPTION UNALIGNED* )((BYTE* )pSOption +
                        pROption->Length);

                    break;
                }

                case OPTION_DnsIpAddress:
                case OPTION_WinsIpAddress:
                case OPTION_DnsBackupIpAddress:
                case OPTION_WinsBackupIpAddress:
                {
                    if (NakCheckNameServerOption(
                            pwb, fRejectNaks, pROption, &pSOption ))
                    {
                        *pfNak = TRUE;
                    }

                    break;
                }

                default:
                    TraceIp("IPCP: Unknown option?");
                    break;
            }
        }

        if (pROption->Length && pROption->Length < cbLeft)
            cbLeft -= pROption->Length;
        else
            cbLeft = 0;

        pROption =
            (PPP_OPTION UNALIGNED* )((BYTE* )pROption + pROption->Length);
    }

    if (   pwb->fServer
        && ( pwb->IfType != ROUTER_IF_TYPE_FULL_ROUTER )
        && ipaddrClient == 0 )
    {
        /* ipaddrClient is 0 iff there is no OPTION_IpAddress */
        TraceIp("IPCP: No IP option");

        /* If client doesn't provide or asked to be assigned an IP address,
        ** suggest one so he'll tell us what he wants.
        */
        if ( pwb->IpAddressRemote == 0 )
        {
            TraceIp("IPCP: RasSrvrAcquireAddress(0)...");
            dwErr = RasSrvrAcquireAddress( 
                                        pwb->hport, 
                                        0, 
                                        &(pwb->IpAddressRemote),
                                        pwb->wszUserName,
                                        pwb->wszPortName );
            TraceIp("IPCP: RasSrvrAcquireAddress done(%d)",dwErr);

            if (dwErr != 0)
                return dwErr;
        }

        /* Time to reject instead of nak and client is still not requesting an
        ** IP address.  We simply allocate an IP address and ACK this request
        */
        if ( !fRejectNaks )
        {
            AddIpAddressOption(
                (BYTE UNALIGNED* )pSOption, OPTION_IpAddress,
                pwb->IpAddressRemote );

            pSOption =
                (PPP_OPTION UNALIGNED* )((BYTE* )pSOption + IPADDRESSOPTIONLEN);

            *pfNak = TRUE;
        }
    }

    if (*pfNak)
    {
        pSendBuf->Code = (fRejectNaks) ? CONFIG_REJ : CONFIG_NAK;

        HostToWireFormat16(
            (WORD )((BYTE* )pSOption - (BYTE* )pSendBuf), pSendBuf->Length );
    }

    return 0;
}


BOOL
NakCheckNameServerOption(
    IN  IPCPWB*                pwb,
    IN  BOOL                   fRejectNaks,
    IN  PPP_OPTION UNALIGNED*  pROption,
    OUT PPP_OPTION UNALIGNED** ppSOption )

    /* Check a name server option for possible naking.  'pwb' the work buffer
    ** stored for us by the engine.  'fRejectNaks' is set the original options
    ** are placed in a Reject packet instead.  'pROption' is the address of
    ** the received option.  '*ppSOption' is the address of the option to be
    ** sent, if there's a problem.
    **
    ** Returns true if the name server address option should be naked or
    ** rejected, false if it's OK.
    */
{
    IPADDR  ipaddr;
    IPADDR* pipaddrWant;

    switch (pROption->Type)
    {
        case OPTION_DnsIpAddress:
            pipaddrWant = &pwb->IpInfoRemote.nboDNSAddress;
            break;

        case OPTION_WinsIpAddress:
            pipaddrWant = &pwb->IpInfoRemote.nboWINSAddress;
            break;

        case OPTION_DnsBackupIpAddress:
            pipaddrWant = &pwb->IpInfoRemote.nboDNSAddressBackup;
            break;

        case OPTION_WinsBackupIpAddress:
            pipaddrWant = &pwb->IpInfoRemote.nboWINSAddressBackup;
            break;

        default:
            RTASSERT((!"Bogus option"));
            return FALSE;
    }

    RTASSERT(pROption->Length==IPADDRESSOPTIONLEN);
    CopyMemory( &ipaddr, pROption->Data, sizeof(IPADDR) );

    if (ipaddr == *pipaddrWant)
    {
        /* Good. Client's asking for the address we want to give him.
        */
        return FALSE;
    }

    /* Not our expected address value, so Nak it.
    */
    TraceIp("IPCP: Naking $%x",(int)pROption->Type);

    CopyMemory( (VOID* )*ppSOption, (VOID* )pROption, pROption->Length );

    if (!fRejectNaks)
        CopyMemory( (*ppSOption)->Data, pipaddrWant, sizeof(IPADDR) );

    *ppSOption =
        (PPP_OPTION UNALIGNED* )((BYTE* )*ppSOption + pROption->Length);

    return TRUE;
}


DWORD
RejectCheck(
    IN  IPCPWB*     pwb,
    IN  PPP_CONFIG* pReceiveBuf,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf,
    OUT BOOL*       pfReject )

    /* Check received packet 'pReceiveBuf' options to see if any should be
    ** rejected and if so, build a Rej packet in 'pSendBuf'.  '*pfReject' is
    ** set true if a Rej packet was created.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    PPP_OPTION UNALIGNED* pROption = (PPP_OPTION UNALIGNED* )pReceiveBuf->Data;
    PPP_OPTION UNALIGNED* pSOption = (PPP_OPTION UNALIGNED* )pSendBuf->Data;

    WORD cbPacket = WireToHostFormat16( pReceiveBuf->Length );
    WORD cbLeft = cbPacket - PPP_CONFIG_HDR_LEN;

    TraceIp("IPCP: RejectCheck");

    *pfReject = FALSE;

    while (cbLeft > 0)
    {
        if (cbLeft < pROption->Length)
            return ERROR_PPP_INVALID_PACKET;

        if (pROption->Type == OPTION_IpCompression)
        {
            WORD wProtocol =
                WireToHostFormat16U(pROption->Data );

            if (wProtocol != COMPRESSION_VanJacobson
                || pROption->Length != IPCOMPRESSIONOPTIONLEN
                || Protocol(pwb->rpcSend) == 0)
            {
                TraceIp("IPCP: Rejecting IP compression");

                *pfReject = TRUE;
                CopyMemory(
                    (VOID* )pSOption, (VOID* )pROption, pROption->Length );

                pSOption = (PPP_OPTION UNALIGNED* )((BYTE* )pSOption +
                    pROption->Length);
            }
        }
        else if (pwb->fServer)
        {
            //
            // This is a client/router dialing in
            //

            switch (pROption->Type)
            {
                case OPTION_IpAddress:
                case OPTION_DnsIpAddress:
                case OPTION_WinsIpAddress:
                case OPTION_DnsBackupIpAddress:
                case OPTION_WinsBackupIpAddress:
                {
                    IPADDR ipaddr;
                    BOOL fBadLength = (pROption->Length != IPADDRESSOPTIONLEN);

                    if (!fBadLength)
                        CopyMemory( &ipaddr, pROption->Data, sizeof(IPADDR) );

                    if (fBadLength
                        || (!ipaddr
                            && ((pROption->Type == OPTION_DnsIpAddress
                                   && !pwb->IpInfoRemote.nboDNSAddress)
                                || (pROption->Type == OPTION_WinsIpAddress
                                   && !pwb->IpInfoRemote.nboWINSAddress)
                                || (pROption->Type == OPTION_DnsBackupIpAddress
                                   && !pwb->IpInfoRemote.nboDNSAddressBackup)
                                || (pROption->Type == OPTION_WinsBackupIpAddress
                                   && !pwb->IpInfoRemote.nboWINSAddressBackup))))
                    {
                        /* messed up IP address option, reject it.
                        */
                        TraceIp("IPCP: Rejecting $%x",(int )pROption->Type);

                        *pfReject = TRUE;
                        CopyMemory(
                            (VOID* )pSOption, (VOID* )pROption,
                            pROption->Length );

                        pSOption = (PPP_OPTION UNALIGNED* )((BYTE* )pSOption +
                            pROption->Length);
                    }
                    break;
                }

                default:
                {
                    /* Unknown option, reject it.
                    */
                    TraceIp("IPCP: Rejecting $%x",(int )pROption->Type);

                    *pfReject = TRUE;
                    CopyMemory(
                        (VOID* )pSOption, (VOID* )pROption, pROption->Length );
                    pSOption =
                        (PPP_OPTION UNALIGNED* )((BYTE* )pSOption +
                        pROption->Length);
                    break;
                }
            }
        }
        else
        {
            //
            // This is a client/router dialing out
            //

            IPADDR ipaddr;
            BOOL fBad = (pROption->Type != OPTION_IpAddress
                         || pROption->Length != IPADDRESSOPTIONLEN);

            if (!fBad)
                CopyMemory( &ipaddr, pROption->Data, sizeof(IPADDR) );

            if (   fBad
                || (   !ipaddr
                    && (pwb->IfType != ROUTER_IF_TYPE_FULL_ROUTER)))
            {
                /* Client rejects everything except a non-zero IP address
                ** which is accepted because some peers (such as Shiva) can't
                ** handle rejection of this option.
                */
                TraceIp("IPCP: Rejecting %d",(int )pROption->Type);

                *pfReject = TRUE;
                CopyMemory(
                    (VOID* )pSOption, (VOID* )pROption, pROption->Length );
                pSOption = (PPP_OPTION UNALIGNED* )((BYTE* )pSOption +
                    pROption->Length);
            }
            else
            {
                /* Store the server's IP address as some applications may be
                ** able to make use of it (e.g. Compaq does), though they are
                ** not guaranteed to receive it from all IPCP implementations.
                */
                if (pwb->IfType != ROUTER_IF_TYPE_FULL_ROUTER)
                {
                    pwb->IpAddressRemote = ipaddr;
                }
            }
        }

        if (pROption->Length && pROption->Length < cbLeft)
            cbLeft -= pROption->Length;
        else
            cbLeft = 0;

        pROption =
            (PPP_OPTION UNALIGNED* )((BYTE* )pROption +
            pROption->Length);
    }

    if (*pfReject)
    {
        pSendBuf->Code = CONFIG_REJ;

        HostToWireFormat16(
            (WORD )((BYTE* )pSOption - (BYTE* )pSendBuf), pSendBuf->Length );
    }

    return 0;
}


DWORD
ReconfigureTcpip(
                 IN WCHAR* pwszDevice,
                 IN BOOL   fNewIpAddress,
                 IN IPADDR ipaddr,
                 IN IPADDR ipMask
                 )

    /* Reconfigure running TCP/IP components.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    */
{
    DWORD dwErr;

    TraceIp("IPCP: ReconfigureTcpip(%08x, %08x)",
        ipaddr, ipMask);

    dwErr = PDhcpNotifyConfigChange2(NULL, pwszDevice, fNewIpAddress, 0, 
                                   ipaddr, ipMask, IgnoreFlag,
                                   NOTIFY_FLG_DO_DNS);

    TraceIp("IPCP: ReconfigureTcpip done(%d)",dwErr);

    return dwErr;
}

VOID   
TraceIp(
    CHAR * Format, 
    ... 
) 
{
    va_list arglist;

    va_start(arglist, Format);

    TraceVprintfEx( DwIpcpTraceId, 
                    PPPIPCP_TRACE | TRACE_USE_MASK | TRACE_USE_MSEC,
                    Format,
                    arglist);

    va_end(arglist);
}

VOID   
TraceIpDump( 
    LPVOID lpData, 
    DWORD dwByteCount 
)
{
    TraceDumpEx( DwIpcpTraceId,
                 PPPIPCP_TRACE | TRACE_USE_MASK | TRACE_USE_MSEC,
                 lpData, dwByteCount, 1, FALSE, NULL );
}

VOID
PrintMwsz(
    CHAR*   sz,
    WCHAR*  mwsz
)
{
    WCHAR*  wsz;
    DWORD   dwLength;

    if (NULL == mwsz)
    {
        TraceIp("%s", sz);
        return;
    }

    dwLength = MwszLength(mwsz);

    wsz = LocalAlloc(LPTR, dwLength * sizeof(WCHAR));

    if (NULL == wsz)
    {
        TraceIp("LocalAlloc failed and returned %d", GetLastError());
        return;
    }

    CopyMemory(wsz, mwsz, dwLength * sizeof(WCHAR));

    dwLength -= 2;

    while (dwLength != 0)
    {
        dwLength--;

        if (0 == wsz[dwLength])
        {
            wsz[dwLength] = L' ';
        }
    }

    TraceIp("%s %ws", sz, wsz);

    LocalFree(wsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipcp\rasipcp.h ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** rasipcp.h
** Remote Access PPP Internet Protocol Control Protocol
**
** 11/05/93 Steve Cobb
*/

#ifndef _RASIPCP_H_
#define _RASIPCP_H_


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* Highest PPP packet code used by IPCP.
*/
#define MAXIPCPCODE 7

/* IPCP configuration option codes.
*/
#define OPTION_IpCompression       2    // Official PPP code
#define OPTION_IpAddress           3    // Official PPP code
#define OPTION_DnsIpAddress        129  // Private RAS code
#define OPTION_WinsIpAddress       130  // Private RAS code
#define OPTION_DnsBackupIpAddress  131  // Private RAS code
#define OPTION_WinsBackupIpAddress 132  // Private RAS code

/* Length of an IP address option, i.e. IpAddress, DnsIpAddress, and
** WinsIpAddress.  Length of IP compression option, always Van Jacobson.
*/
#define IPADDRESSOPTIONLEN     6
#define IPCOMPRESSIONOPTIONLEN 6

/* Compression protocol codes, per PPP spec.
*/
#define COMPRESSION_VanJacobson 0x002D

/* Macros for shortening cumbersome RAS_PROTOCOLCOMPRESSION expressions.
*/
#define Protocol(r)   (r).RP_ProtocolType.RP_IP.RP_IPCompressionProtocol
#define MaxSlotId(r)  (r).RP_ProtocolType.RP_IP.RP_MaxSlotID
#define CompSlotId(r) (r).RP_ProtocolType.RP_IP.RP_CompSlotID

/* Used to trace IPCP 
*/
#define PPPIPCP_TRACE         0x00010000

#define DNS_SUFFIX_SIZE       255

/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Defines the WorkBuf stored for us by the PPP engine.
*/
typedef struct tagIPCPWB
{
    BOOL  fServer;
    HPORT hport;

    /* Indicates the remote network should be given priority on address
    ** conflicts and that the default gateway on the remote network should be
    ** used rather than the one on the local network.  This is sent down from
    ** the UI.  (client only)
    */
    BOOL fPrioritizeRemote;

    /* Indicates the link has been reconfigured with PPP IP settings.  When
    ** set renegotiation is not allowed without dropping the link, due to
    ** RasActivateRoute/RasDeAllocateRoute restrictions.
    */
    BOOL fRasConfigActive;

    /* Indicates a ThisLayerUp has been successfully processed and we are
    ** waiting for the NBFCP projection result before activating the route.
    ** Reset once the route is activated.
    */
    BOOL fExpectingProjection;

    /* Indicates the given option should not be requested in future Config-Req
    ** packets.  This typically means the option has been rejected by the
    ** peer, but may also indicate that a registry parameter has
    ** "pre-rejected" the option.
    */
    BOOL fIpCompressionRejected;
    BOOL fIpaddrRejected;
    BOOL fIpaddrDnsRejected;
    BOOL fIpaddrWinsRejected;
    BOOL fIpaddrDnsBackupRejected;
    BOOL fIpaddrWinsBackupRejected;

    /* Indicates some protocol aberration has occurred and we are trying a
    ** configuration without MS extensions in a last ditch attempt to
    ** negotiate something satisfactory.
    */
    BOOL fTryWithoutExtensions;

    /* Unnumbered IPCP
    */
    BOOL fUnnumbered;

    BOOL fRegisterWithWINS;

    BOOL fRegisterWithDNS;

    BOOL fRegisterAdapterDomainName;

    BOOL fRouteActivated;

    BOOL fDisableNetbt;

    /* The number of Config-Reqs sent without receiving a response.  After 3
    ** consecutive attempts an attempt without MS extensions is attempted.
    */
    DWORD cRequestsWithoutResponse;

    /* Current value of negotiated IP address parameters.
    */
    IPINFO  IpInfoLocal;

    IPINFO  IpInfoRemote;

    IPADDR  IpAddressLocal;

    IPADDR  IpAddressRemote;

    IPADDR  IpAddressToHandout;

    DWORD   dwNumDNSAddresses;

    DWORD*  pdwDNSAddresses;

    /* Current value of "send" and "receive" compression parameters.  The
    ** "send compression" flag is set when a compression option from the
    ** remote peer is acknowledged and indicates whether the "send"
    ** capabilities stored in 'rpcSend' should be activated.
    ** 'fIpCompressionRejected' provides this same information (though
    ** inverted) for the 'rpcReceive' capabilities.
    */
    RAS_PROTOCOLCOMPRESSION rpcSend;
    RAS_PROTOCOLCOMPRESSION rpcReceive;
    BOOL                    fSendCompression;

    /* RAS Manager interface buffers.
    */
    RASMAN_ROUTEINFO routeinfo;
    WCHAR*           pwszDevice;

    /* This flag is set in IpcpBegin when an error occurs after
    ** RasAllocateRoute has succeeded.  IpcpMakeConfigReq (always called) will
    ** notice and return the error.  This results in IpcpEnd being called when
    ** it is safe to call RasDeAllocateRoute, which would not occur if the
    ** error were returned from IpcpBegin directly.  RasDeAllocateRoute cannot
    ** be called in IpcpBegin because the port is open, which is a limitation
    ** in NDISWAN.
    */
    DWORD dwErrInBegin;

    WCHAR wszUserName[UNLEN+1];

    WCHAR wszPortName[MAX_PORT_NAME+1];

    CHAR szDnsSuffix[DNS_SUFFIX_SIZE + 1];

    HBUNDLE hConnection;

    HANDLE hIPInterface;

    ROUTER_INTERFACE_TYPE IfType;
	/*
	** The following field is used to store the DHCP route that 
	** is send by option 133 from DHCP server. 
	*/
	
	PBYTE			pbDhcpRoutes;
} IPCPWB;


/*----------------------------------------------------------------------------
** Globals
**----------------------------------------------------------------------------
*/

#ifdef RASIPCPGLOBALS
#define GLOBALS
#define EXTERN
#else
#define EXTERN extern
#endif

/* Handle to RAS ARP.
*/
EXTERN HANDLE HRasArp
#ifdef GLOBALS
    = INVALID_HANDLE_VALUE
#endif
;

/* DHCP.DLL handle and entry points.  The handle is NULL if the DLL is not
** loaded.
*/
EXTERN HINSTANCE HDhcpDll
#ifdef GLOBALS
    = NULL
#endif
;

typedef
DWORD
(APIENTRY *DHCPNOTIFYCONFIGCHANGEEX)(
    LPWSTR ServerName,
    LPWSTR AdapterName,
    BOOL IsNewIpAddress,
    DWORD IpIndex,
    DWORD IpAddress,
    DWORD SubnetMask,
    SERVICE_ENABLE DhcpServiceEnabled,
    ULONG ulFlags
);

EXTERN
DHCPNOTIFYCONFIGCHANGEEX  PDhcpNotifyConfigChange2
#ifdef GLOBALS
    = NULL
#endif
;

typedef
DWORD // Request client for options.. and get the options.
(APIENTRY *DHCPREQUESTOPTIONS)(
    LPWSTR             AdapterName,
    BYTE              *pbRequestedOptions,
    DWORD              dwNumberOfOptions,
    BYTE             **ppOptionList,        // out param
    DWORD             *pdwOptionListSize,   // out param
    BYTE             **ppbReturnedOptions,  // out param
    DWORD             *pdwNumberOfAvailableOptions // out param
);

EXTERN
DHCPREQUESTOPTIONS  PDhcpRequestOptions
#ifdef GLOBALS
    = NULL
#endif
;

/* TRACE ID
*/
EXTERN DWORD DwIpcpTraceId
#ifdef GLOBALS
    = INVALID_TRACEID
#endif
;

EXTERN BOOL FClientMaySelectAddress
#ifdef GLOBALS
    = FALSE
#endif
;

#undef EXTERN
#undef GLOBALS


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/


DWORD IpcpChangeNotification( VOID );
DWORD IpcpBegin( VOID**, VOID* );
DWORD IpcpThisLayerFinished( VOID* );
DWORD IpcpEnd( VOID* );
DWORD IpcpReset( VOID* );
DWORD IpcpThisLayerUp( VOID* );
DWORD IpcpPreDisconnectCleanup( VOID* );
DWORD IpcpMakeConfigRequest( VOID*, PPP_CONFIG*, DWORD );
DWORD IpcpMakeConfigResult( VOID*, PPP_CONFIG*, PPP_CONFIG*, DWORD, BOOL );
DWORD IpcpConfigAckReceived( VOID*, PPP_CONFIG* );
DWORD IpcpConfigNakReceived( VOID*, PPP_CONFIG* );
DWORD IpcpConfigRejReceived( VOID*, PPP_CONFIG* );
DWORD IpcpGetNegotiatedInfo( VOID*, VOID* );
DWORD IpcpProjectionNotification( VOID*, VOID* );
DWORD IpcpTimeSinceLastActivity( VOID*, DWORD* );

DWORD
ResetNetBTConfigInfo(
    IN IPCPWB* pwb );

VOID   AbcdFromIpaddr( IPADDR, WCHAR* );
VOID   AddIpAddressOption( BYTE UNALIGNED*, BYTE, IPADDR );
VOID   AddIpCompressionOption( BYTE UNALIGNED* pbBuf,
           RAS_PROTOCOLCOMPRESSION* prpc );
DWORD  DeActivateRasConfig( IPCPWB* );
// DWORD  LoadDhcpDll();
DWORD  NakCheck( IPCPWB*, PPP_CONFIG*, PPP_CONFIG*, DWORD, BOOL*, BOOL );
BOOL   NakCheckNameServerOption( IPCPWB*, BOOL, PPP_OPTION UNALIGNED*,
           PPP_OPTION UNALIGNED** );
DWORD  RejectCheck( IPCPWB*, PPP_CONFIG*, PPP_CONFIG*, DWORD, BOOL* );
DWORD  ReconfigureTcpip( WCHAR*, BOOL, IPADDR, IPADDR);
// VOID   UnloadDhcpDll();
VOID   TraceIp(CHAR * Format, ... ); 
VOID   TraceIpDump( LPVOID lpData, DWORD dwByteCount );

VOID
PrintMwsz(
    CHAR*   sz,
    WCHAR*  mwsz
);

#define DUMPB TraceIpDump  

#endif // _RASIPCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\helper.c ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:
    HBO: host byte order. Used by DNS, DHCP (except in DhcpNotifyConfigChange).
    NBO: network byte order. Used by IPCP, inet_ntoa, inet_addr, the stack 
    (SetProxyArpEntryToStack, IPRouteEntry, etc).

*/

#include "helper_.h"
#include "reghelp.h" // for RegHelpGuidFromString

/*

Returns:
    VOID

Description:

*/

VOID   
TraceHlp(
    IN  CHAR*   Format, 
    ... 
)
{
    va_list arglist;

    RTASSERT(NULL != Format);

    va_start(arglist, Format);

    TraceVprintfEx(HelperTraceId, 
                   0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC,
                   Format,
                   arglist);

    va_end(arglist);
}

/*

Returns:

Notes:

*/

DWORD
HelperInitialize(
    OUT HINSTANCE*  phInstanceDhcpDll
)
{
    DWORD   dwErr           = NO_ERROR;

    while (InterlockedIncrement(&HelperLock) > 1)
    {
        InterlockedDecrement(&HelperLock);

        if (!HelperInitialized)
        {
            Sleep(1000);
        }
        else
        {
            *phInstanceDhcpDll = HelperDhcpDll;
            goto LDone;
        }
    }

    ZeroMemory(&HelperRegVal, sizeof(HelperRegVal));

    HelperTraceId = TraceRegister("RASIPHLP");

    TraceHlp("HelperInitialize");

    HelperDhcpDll = LoadLibrary("dhcpcsvc.dll");

    if (NULL == HelperDhcpDll)
    {
        dwErr = GetLastError();

        TraceHlp("LoadLibrary(dhcpcsvc.dll) failed and returned %d",
            dwErr);

        goto LDone;
    }

    HelperIpHlpDll = LoadLibrary("iphlpapi.dll");

    if (NULL == HelperIpHlpDll)
    {
        dwErr = GetLastError();

        TraceHlp("LoadLibrary(iphlpapi.dll) failed and returned %d",
            dwErr);

        goto LDone;
    }

    HelperIpBootpDll = LoadLibrary("ipbootp.dll");

    if (NULL == HelperIpBootpDll)
    {
        TraceHlp("LoadLibrary(ipbootp.dll) failed and returned %d",
            GetLastError());
    }

    dwErr = helperGetAddressOfProcs();

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    /*
    This is done to send an IRP_MJ_CREATE to the driver. WanArp starts 
    "working" (initializes itself etc) only when a component opens it. When the 
    router is running, this is done by the router manager, but in the ras 
    client case we need to force WanArp to start.
    */

    HelperWanArpHandle = CreateFile(
                            WANARP_DOS_NAME_T,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE, 
                            NULL, 
                            OPEN_EXISTING, 
                            FILE_FLAG_OVERLAPPED, 
                            NULL);

    if (INVALID_HANDLE_VALUE == HelperWanArpHandle)
    {
        dwErr = GetLastError();

        TraceHlp("CreateFile(%s) failed and returned %d",
            WANARP_DOS_NAME_A, dwErr);

        goto LDone;
    }

    // This is done last. If something fails above, we don't have to
    // DeleteCriticalSection.

    InitializeCriticalSection(&RasDhcpCriticalSection);
    InitializeCriticalSection(&RasStatCriticalSection);
    InitializeCriticalSection(&RasSrvrCriticalSection);
    InitializeCriticalSection(&RasTimrCriticalSection);

    HelperChangeNotification();

    *phInstanceDhcpDll = HelperDhcpDll;

    HelperInitialized = TRUE;

LDone:

    if (NO_ERROR != dwErr)
    {
        if ((DWORD)-1 != HelperTraceId)
        {
            TraceDeregister(HelperTraceId);
            HelperTraceId = (DWORD)-1;
        }

        if (INVALID_HANDLE_VALUE != HelperWanArpHandle)
        {
            CloseHandle(HelperWanArpHandle);
            HelperWanArpHandle = INVALID_HANDLE_VALUE;
        }

        if (NULL != HelperDhcpDll)
        {
            FreeLibrary(HelperDhcpDll);
            HelperDhcpDll = NULL;
        }

        if (NULL != HelperIpHlpDll)
        {
            FreeLibrary(HelperIpHlpDll);
            HelperIpHlpDll = NULL;
        }

        if (NULL != HelperIpBootpDll)
        {
            FreeLibrary(HelperIpBootpDll);
            HelperIpBootpDll = NULL;
        }

        PDhcpNotifyConfigChange                     = NULL;
        PDhcpLeaseIpAddress                         = NULL;
        PDhcpRenewIpAddressLease                    = NULL;
        PDhcpReleaseIpAddressLease                  = NULL;
        PAllocateAndGetIpAddrTableFromStack         = NULL;
        PSetProxyArpEntryToStack                    = NULL;
        PSetIpForwardEntryToStack                   = NULL;
        PSetIpForwardEntry                          = NULL;
        PDeleteIpForwardEntry                       = NULL;
        PNhpAllocateAndGetInterfaceInfoFromStack    = NULL;
        PAllocateAndGetIpForwardTableFromStack      = NULL;
        PGetAdaptersInfo                            = NULL;
        PGetPerAdapterInfo                          = NULL;
        PEnableDhcpInformServer                     = NULL;
        PDisableDhcpInformServer                    = NULL;

        ZeroMemory(&HelperRegVal, sizeof(HelperRegVal));

        InterlockedDecrement(&HelperLock);
    }

    return(dwErr);
}

/*

Returns:
    VOID

Notes:

*/

VOID
HelperUninitialize(
    VOID
)
{
    TraceHlp("HelperUninitialize");

    if ((DWORD)-1 != HelperTraceId)
    {
        TraceDeregister(HelperTraceId);
        HelperTraceId = (DWORD)-1;
    }

    if (INVALID_HANDLE_VALUE != HelperWanArpHandle)
    {
        CloseHandle(HelperWanArpHandle);
        HelperWanArpHandle = INVALID_HANDLE_VALUE;
    }

    if (NULL != HelperDhcpDll)
    {
        FreeLibrary(HelperDhcpDll);
        HelperDhcpDll = NULL;
    }

    if (NULL != HelperIpHlpDll)
    {
        FreeLibrary(HelperIpHlpDll);
        HelperIpHlpDll = NULL;
    }

    if (NULL != HelperIpBootpDll)
    {
        FreeLibrary(HelperIpBootpDll);
        HelperIpBootpDll = NULL;
    }

    RasStatFreeAddrPool(HelperRegVal.pAddrPool);
    HelperRegVal.pAddrPool = NULL;

    PDhcpNotifyConfigChange                     = NULL;
    PDhcpLeaseIpAddress                         = NULL;
    PDhcpRenewIpAddressLease                    = NULL;
    PDhcpReleaseIpAddressLease                  = NULL;
    PAllocateAndGetIpAddrTableFromStack         = NULL;
    PSetProxyArpEntryToStack                    = NULL;
    PSetIpForwardEntryToStack                   = NULL;
    PSetIpForwardEntry                          = NULL;
    PDeleteIpForwardEntry                       = NULL;
    PNhpAllocateAndGetInterfaceInfoFromStack    = NULL;
    PAllocateAndGetIpForwardTableFromStack      = NULL;
    PGetAdaptersInfo                            = NULL;
    PGetPerAdapterInfo                          = NULL;
    PEnableDhcpInformServer                     = NULL;
    PDisableDhcpInformServer                    = NULL;

    ZeroMemory(&HelperRegVal, sizeof(HelperRegVal));

    if (HelperInitialized)
    {
        DeleteCriticalSection(&RasDhcpCriticalSection);
        DeleteCriticalSection(&RasStatCriticalSection);
        DeleteCriticalSection(&RasSrvrCriticalSection);
        DeleteCriticalSection(&RasTimrCriticalSection);
        HelperInitialized = FALSE;
        InterlockedDecrement(&HelperLock);
    }
}

/*

Returns:
    VOID

Description:

*/

VOID
HelperChangeNotification(
    VOID
)
{
    BOOL        fUseDhcpAddressingOld;
    BOOL        fUseDhcpAddressing          = TRUE;
    ADDR_POOL*  pAddrPool                   = NULL;
    BOOL        fNICChosen;
    GUID        guidChosenNIC;
    HANDLE      h;

    DWORD       dwNumBytes;
    HKEY        hKey                        = NULL;
    LONG        lErr;
    DWORD       dwErr;

    TraceHlp("HelperChangeNotification");

    fUseDhcpAddressingOld   = HelperRegVal.fUseDhcpAddressing;
    fNICChosen              = HelperRegVal.fNICChosen;
    CopyMemory(&guidChosenNIC, &(HelperRegVal.guidChosenNIC), sizeof(GUID));

    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_RAS_IP_PARAM_A, 0, KEY_READ,
                &hKey);

    if (ERROR_SUCCESS == lErr)
    {
        dwNumBytes = sizeof(fUseDhcpAddressing);

        lErr = RegQueryValueEx(hKey, REGVAL_USEDHCPADDRESSING_A, NULL, NULL,
                    (BYTE*)&fUseDhcpAddressing, &dwNumBytes);

        if (ERROR_SUCCESS != lErr)
        {
            fUseDhcpAddressing = TRUE;
        }
    }

    helperReadRegistry();

    if (!fUseDhcpAddressing)
    {
        RasStatCreatePoolList(&pAddrPool);
    }

    EnterCriticalSection(&RasSrvrCriticalSection);

    if (RasSrvrRunning)
    {
        RasSrvrEnableRouter(HelperRegVal.fEnableRoute);

        if (   (fUseDhcpAddressingOld != fUseDhcpAddressing)
            || (   !fUseDhcpAddressing
                && RasStatAddrPoolsDiffer(HelperRegVal.pAddrPool, pAddrPool))
            || (   fUseDhcpAddressing
                && (   (fNICChosen != HelperRegVal.fNICChosen)
                    || (   fNICChosen
                        && (!IsEqualGUID(&guidChosenNIC,
                                         &(HelperRegVal.guidChosenNIC)))))))
        {
            RasSrvrStop(TRUE /* fParametersChanged */);
            HelperRegVal.fUseDhcpAddressing = fUseDhcpAddressing;
            RasStatFreeAddrPool(HelperRegVal.pAddrPool);
            HelperRegVal.pAddrPool = pAddrPool;
            dwErr = RasSrvrStart();

            if (NO_ERROR != dwErr)
            {
                TraceHlp("RasSrvrStart failed and returned %d");
            }
        }
    }
    else
    {
        HelperRegVal.fUseDhcpAddressing = fUseDhcpAddressing;
        RasStatFreeAddrPool(HelperRegVal.pAddrPool);
        HelperRegVal.pAddrPool = pAddrPool;
    }

    LeaveCriticalSection(&RasSrvrCriticalSection);

    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
}

/*

Returns:

Description:

*/

DWORD
HelperSetDefaultInterfaceNet(
    IN  IPADDR  nboIpAddrLocal,
    IN  IPADDR  nboIpAddrRemote,
    IN  BOOL    fPrioritize,
    IN  WCHAR   *pszDevice
)
{
    DWORD   dwErr                   = NO_ERROR;
    GUID    DeviceGuid;

    TraceHlp("HelperSetDefaultInterfaceNet(IP addr: 0x%x, fPrioritize: %d)",
        nboIpAddrLocal, fPrioritize);

    if(NULL == pszDevice)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto LDone;
    }

    RegHelpGuidFromString(pszDevice, &DeviceGuid);

    // If fPrioritize flag is set, "fix" the metrics so that the packets go on
    // the RAS links

    if (fPrioritize)
    {
        dwErr = RasTcpAdjustRouteMetrics(nboIpAddrLocal, TRUE);

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }
    }

    // Add code to check for the remote network - same as the one of the local
    // networks - if so, set the subnet route to be over the RAS adapter -
    // making the ras link as the primary adapter

    // We add a Default route to make RAS adapter as the default net if
    // fPrioritize flag is set.

    if (fPrioritize)
    {
        // RasTcpSetRoutesForNameServers(TRUE);

        RasTcpSetRouteEx(
            ALL_NETWORKS_ROUTE, 
            nboIpAddrLocal, 
            0,
            nboIpAddrLocal,
            TRUE, 
            1,
            TRUE,
            &DeviceGuid);
    }
    else
    {
        IPADDR nboMask;

        nboMask = RasTcpDeriveMask(nboIpAddrLocal);

        if (nboMask != 0)
        {
            RasTcpSetRouteEx(
                nboIpAddrLocal & nboMask, 
                nboIpAddrLocal, 
                nboMask,
                nboIpAddrLocal,
                TRUE, 
                1,
                TRUE,
                &DeviceGuid);
        }
    }

    if (0 != nboIpAddrRemote)
    {
        RasTcpSetRouteEx(
            nboIpAddrRemote, 
            nboIpAddrLocal, 
            HOST_MASK,
            nboIpAddrLocal,
            TRUE, 
            1,
            TRUE,
            &DeviceGuid);
    }

LDone:

    return(dwErr);
}

/*

Returns:

Description:

*/

DWORD
HelperResetDefaultInterfaceNet(
    IN  IPADDR  nboIpAddr,
    IN  BOOL    fPrioritize
)
{
    DWORD   dwErr = NO_ERROR;;

    if (fPrioritize)
    {
        // RasTcpSetRoutesForNameServers(FALSE);
        dwErr = RasTcpAdjustRouteMetrics(nboIpAddr, FALSE);
    }

    return(dwErr);
}

/*

Returns:

Notes:

*/

DWORD
HelperSetDefaultInterfaceNetEx(
    IPADDR  nboIpAddr,
    WCHAR*  wszDevice,
    BOOL    fPrioritize,
    WCHAR*  wszDnsAddress,
    WCHAR*  wszDns2Address,
    WCHAR*  wszWinsAddress,
    WCHAR*  wszWins2Address
)
{
    DWORD           dwErr       = NO_ERROR;
    IPADDR          nboIpMask   = HOST_MASK;
    TCPIP_INFO*     pTcpipInfo  = NULL;

    TraceHlp("HelperSetDefaultInterfaceNetEx(IP addr: 0x%x, Device: %ws, "
        "fPrioritize: %d, DNS1: %ws, DNS2: %ws, WINS1: %ws, WINS2: %ws",
        nboIpAddr, wszDevice, fPrioritize, wszDnsAddress, wszDns2Address,
        wszWinsAddress, wszWins2Address);

    dwErr = LoadTcpipInfo(&pTcpipInfo, wszDevice, FALSE /* fAdapterOnly */);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    AbcdWszFromIpAddress(nboIpAddr, pTcpipInfo->wszIPAddress);
    AbcdWszFromIpAddress(nboIpMask, pTcpipInfo->wszSubnetMask);

    // Since we are adding the addresses to the head of the list, we need to add 
    // the backup DNS and WINS addresses before the primary addresses, so the 
    // primary ones will be at the head of the list when we're done.

    if (wszDns2Address != NULL)
    {
        dwErr = PrependWszIpAddress(&pTcpipInfo->wszDNSNameServers,
                    wszDns2Address);

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }
    }

    if (wszDnsAddress != NULL)
    {
        dwErr = PrependWszIpAddress(&pTcpipInfo->wszDNSNameServers,
                    wszDnsAddress);

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }
    }

    if (wszWins2Address != NULL)
    {
        dwErr = PrependWszIpAddressToMwsz(&pTcpipInfo->mwszNetBIOSNameServers,
                    wszWins2Address);

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }
    }

    if (wszWinsAddress != NULL)
    {
        dwErr = PrependWszIpAddressToMwsz(&pTcpipInfo->mwszNetBIOSNameServers,
                    wszWinsAddress);

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }
    }

    pTcpipInfo->fChanged = TRUE;

    dwErr = SaveTcpipInfo(pTcpipInfo);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    dwErr = PDhcpNotifyConfigChange(NULL, wszDevice, TRUE, 0, nboIpAddr,
                nboIpMask, IgnoreFlag);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("DhcpNotifyConfigChange failed and returned %d", dwErr);
        goto LDone;
    }

    // If fPrioritize flag is set "Fix" the metrics so that the packets go on
    // the RAS links

    if (fPrioritize)
    {
        dwErr = RasTcpAdjustRouteMetrics(nboIpAddr, TRUE);

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }
    }

    // Add code to check for the remote network - same as the one of the local
    // networks - if so, set the subnet route to be over the RAS adapter -
    // making the RAS link as the primary adapter

    // We add a Default route to make RAS adapter as the default net if
    // fPrioritize flag is set.

    if (fPrioritize)
    {
        // RasTcpSetRoutesForNameServers(TRUE);

        RasTcpSetRoute(ALL_NETWORKS_ROUTE,
                       nboIpAddr,
                       0,
                       nboIpAddr,
                       TRUE,
                       1,
                       TRUE);
    }
    else
    {
        IPADDR nboMask;

        nboMask = RasTcpDeriveMask(nboIpAddr);

        if (nboMask != 0)
        {
            RasTcpSetRoute(
                nboIpAddr & nboMask, 
                nboIpAddr, 
                nboMask,
                nboIpAddr,
                TRUE, 
                1,
                TRUE);
        }
    }

LDone:

    if (pTcpipInfo != NULL)
    {
        FreeTcpipInfo(&pTcpipInfo);
    }

    return(dwErr);
}

/*

Returns:

Notes:

*/

DWORD
HelperResetDefaultInterfaceNetEx(
    IPADDR  nboIpAddr,
    WCHAR*  wszDevice,
    BOOL    fPrioritize,
    WCHAR*  wszDnsAddress,
    WCHAR*  wszDns2Address,
    WCHAR*  wszWinsAddress,
    WCHAR*  wszWins2Address
)
{
    DWORD           dwErr       = NO_ERROR;
    TCPIP_INFO*     pTcpipInfo  = NULL;

    TraceHlp("HelperResetDefaultInterfaceNetEx(0x%x)", nboIpAddr);

    if (fPrioritize)
    {

        // RasTcpSetRoutesForNameServers(FALSE);
        RasTcpAdjustRouteMetrics(nboIpAddr, FALSE);
    }

    dwErr = LoadTcpipInfo(&pTcpipInfo, wszDevice, TRUE /* fAdapterOnly */);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    pTcpipInfo->fChanged = TRUE;

    dwErr = SaveTcpipInfo(pTcpipInfo);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    dwErr = PDhcpNotifyConfigChange(NULL, wszDevice, TRUE, 0, 0, 0, IgnoreFlag);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("DhcpNotifyConfigChange failed and returned %d", dwErr);
        dwErr = NO_ERROR;
    }

LDone:

    if (pTcpipInfo != NULL)
    {
        FreeTcpipInfo(&pTcpipInfo);
    }

    return(dwErr);
}

/*

Returns:

Description:

*/

DWORD
helperGetAddressOfProcs(
    VOID
)
{
    DWORD   dwErr   = NO_ERROR;

    PDhcpNotifyConfigChange = (DHCPNOTIFYCONFIGCHANGE)
        GetProcAddress(HelperDhcpDll, "DhcpNotifyConfigChange");

    if (NULL == PDhcpNotifyConfigChange)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(DhcpNotifyConfigChange) failed and returned "
            "%d", dwErr);

        goto LDone;
    }

    PDhcpLeaseIpAddress = (DHCPLEASEIPADDRESS)
        GetProcAddress(HelperDhcpDll, "DhcpLeaseIpAddress");

    if (NULL == PDhcpLeaseIpAddress)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(DhcpLeaseIpAddress) failed and returned "
            "%d", dwErr);

        goto LDone;
    }

    PDhcpRenewIpAddressLease = (DHCPRENEWIPADDRESSLEASE)
        GetProcAddress(HelperDhcpDll, "DhcpRenewIpAddressLease");

    if (NULL == PDhcpRenewIpAddressLease)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(DhcpRenewIpAddressLease) failed and returned "
            "%d", dwErr);

        goto LDone;
    }

    PDhcpReleaseIpAddressLease = (DHCPRELEASEIPADDRESSLEASE)
        GetProcAddress(HelperDhcpDll, "DhcpReleaseIpAddressLease");

    if (NULL == PDhcpReleaseIpAddressLease)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(DhcpReleaseIpAddressLease) failed and "
            "returned %d", dwErr);

        goto LDone;
    }

    PAllocateAndGetIpAddrTableFromStack = (ALLOCATEANDGETIPADDRTABLEFROMSTACK)
        GetProcAddress(HelperIpHlpDll, "AllocateAndGetIpAddrTableFromStack");

    if (NULL == PAllocateAndGetIpAddrTableFromStack)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(AllocateAndGetIpAddrTableFromStack) failed "
            "and returned %d", dwErr);

        goto LDone;
    }

    PSetProxyArpEntryToStack = (SETPROXYARPENTRYTOSTACK)
        GetProcAddress(HelperIpHlpDll, "SetProxyArpEntryToStack");

    if (NULL == PSetProxyArpEntryToStack)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(SetProxyArpEntryToStack) failed and "
            "returned %d", dwErr);

        goto LDone;
    }

    PSetIpForwardEntryToStack = (SETIPFORWARDENTRYTOSTACK)
        GetProcAddress(HelperIpHlpDll, "SetIpForwardEntryToStack");

    if (NULL == PSetIpForwardEntryToStack)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(SetIpForwardEntryToStack) failed and "
            "returned %d", dwErr);

        goto LDone;
    }

    PSetIpForwardEntry = (SETIPFORWARDENTRY)
        GetProcAddress(HelperIpHlpDll, "SetIpForwardEntry");

    if (NULL == PSetIpForwardEntry)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(SetIpForwardEntry) failed and "
            "returned %d", dwErr);

        goto LDone;
    }

    PDeleteIpForwardEntry = (DELETEIPFORWARDENTRY)
        GetProcAddress(HelperIpHlpDll, "DeleteIpForwardEntry");

    if (NULL == PDeleteIpForwardEntry)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(DeleteIpForwardEntry) failed and "
            "returned %d", dwErr);

        goto LDone;
    }

    PNhpAllocateAndGetInterfaceInfoFromStack =
        (NHPALLOCATEANDGETINTERFACEINFOFROMSTACK)
        GetProcAddress(HelperIpHlpDll,
            "NhpAllocateAndGetInterfaceInfoFromStack");

    if (NULL == PNhpAllocateAndGetInterfaceInfoFromStack)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(NhpAllocateAndGetInterfaceInfoFromStack) "
            "failed and returned %d", dwErr);

        goto LDone;
    }

    PAllocateAndGetIpForwardTableFromStack =
        (ALLOCATEANDGETIPFORWARDTABLEFROMSTACK)
        GetProcAddress(HelperIpHlpDll,
            "AllocateAndGetIpForwardTableFromStack");

    if (NULL == PAllocateAndGetIpForwardTableFromStack)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(AllocateAndGetIpForwardTableFromStack) "
            "failed and returned %d", dwErr);

        goto LDone;
    }

    PGetAdaptersInfo = (GETADAPTERSINFO)
        GetProcAddress(HelperIpHlpDll, "GetAdaptersInfo");

    if (NULL == PGetAdaptersInfo)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(GetAdaptersInfo) failed and "
            "returned %d", dwErr);

        goto LDone;
    }

    PGetPerAdapterInfo = (GETPERADAPTERINFO)
        GetProcAddress(HelperIpHlpDll, "GetPerAdapterInfo");

    if (NULL == PGetPerAdapterInfo)
    {
        dwErr = GetLastError();

        TraceHlp("GetProcAddress(GetPerAdapterInfo) failed and "
            "returned %d", dwErr);

        goto LDone;
    }

    if (NULL != HelperIpBootpDll)
    {
        PEnableDhcpInformServer = (ENABLEDHCPINFORMSERVER)
            GetProcAddress(HelperIpBootpDll, "EnableDhcpInformServer");

        if (NULL == PEnableDhcpInformServer)
        {
            dwErr = GetLastError();

            TraceHlp("GetProcAddress(EnableDhcpInformServer) failed and "
                "returned %d", dwErr);

            goto LDone;
        }

        PDisableDhcpInformServer = (DISABLEDHCPINFORMSERVER)
            GetProcAddress(HelperIpBootpDll, "DisableDhcpInformServer");

        if (NULL == PDisableDhcpInformServer)
        {
            dwErr = GetLastError();

            TraceHlp("GetProcAddress(DisableDhcpInformServer) failed and "
                "returned %d", dwErr);

            goto LDone;
        }
    }

LDone:

    return(dwErr);
}

/*

Returns:
    VOID

Description:

*/

VOID
helperReadRegistry(
    VOID
)
{
    LONG    lErr;
    DWORD   dwErr;
    DWORD   dw;
    DWORD   dwNumBytes;
    CHAR*   szIpAddr            = NULL;
    CHAR*   szAlloced           = NULL;
    IPADDR  nboIpAddr1;
    IPADDR  nboIpAddr2;
    HKEY    hKeyIpParam         = NULL;
    WCHAR*  wszAdapterGuid      = NULL;
    HRESULT hr;

    HelperRegVal.fSuppressWINSNameServers   = FALSE;
    HelperRegVal.fSuppressDNSNameServers    = FALSE;
    HelperRegVal.dwChunkSize                = 10;
    HelperRegVal.nboWINSNameServer1         = 0;
    HelperRegVal.nboWINSNameServer2         = 0;
    HelperRegVal.nboDNSNameServer1          = 0;
    HelperRegVal.nboDNSNameServer2          = 0;
    HelperRegVal.fNICChosen                 = FALSE;
    HelperRegVal.fEnableRoute               = FALSE;

    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_RAS_IP_PARAM_A, 0,
                KEY_READ, &hKeyIpParam); 

    if (ERROR_SUCCESS == lErr)
    {
        dwErr = RegQueryValueWithAllocW(hKeyIpParam, REGVAL_ADAPTERGUID_W,
                    REG_SZ, (BYTE**)&wszAdapterGuid);

        if (   (NO_ERROR == dwErr)
            && (wszAdapterGuid[0]))
        {
            hr = CLSIDFromString(wszAdapterGuid, &(HelperRegVal.guidChosenNIC));

            if (!FAILED(hr))
            {
                HelperRegVal.fNICChosen = TRUE;
            }
        }

        dwNumBytes = sizeof(dw);

        lErr = RegQueryValueEx(hKeyIpParam, REGVAL_SUPPRESSWINS_A, NULL, NULL,
                    (BYTE*)&dw, &dwNumBytes);

        if (   (ERROR_SUCCESS == lErr)
            && (0 != dw))
        {
            HelperRegVal.fSuppressWINSNameServers = TRUE;
        }

        dwNumBytes = sizeof(dw);

        lErr = RegQueryValueEx(hKeyIpParam, REGVAL_SUPPRESSDNS_A, NULL, NULL,
                   (BYTE*)&dw, &dwNumBytes);

        if (   (ERROR_SUCCESS == lErr)
            && (0 != dw))
        {
            HelperRegVal.fSuppressDNSNameServers = TRUE;
        }

        dwNumBytes = sizeof(dw);

        lErr = RegQueryValueEx(hKeyIpParam, REGVAL_CHUNK_SIZE_A, NULL, NULL,
                    (BYTE*)&dw, &dwNumBytes);

        if (ERROR_SUCCESS == lErr)
        {
            HelperRegVal.dwChunkSize = dw;
        }

        dwNumBytes = sizeof(dw);

        lErr = RegQueryValueEx(hKeyIpParam, REGVAL_ALLOW_NETWORK_ACCESS_A, NULL,
                    NULL, (BYTE*)&dw, &dwNumBytes);

        if (ERROR_SUCCESS == lErr)
        {
            HelperRegVal.fEnableRoute = dw;
        }

        dwErr = RegQueryValueWithAllocA(hKeyIpParam, REGVAL_WINSSERVER_A, 
                    REG_SZ, &szIpAddr);

        if (NO_ERROR == dwErr)
        {
            nboIpAddr1 = inet_addr(szIpAddr);

            if (INADDR_NONE != nboIpAddr1)
            {
                HelperRegVal.nboWINSNameServer1 = nboIpAddr1;
            }

            LocalFree(szIpAddr);
            szIpAddr = NULL;
        }

        dwErr = RegQueryValueWithAllocA(hKeyIpParam, REGVAL_WINSSERVERBACKUP_A,
                    REG_SZ, &szIpAddr);

        if (NO_ERROR == dwErr)
        {
            nboIpAddr2 = inet_addr(szIpAddr);

            if (   (INADDR_NONE != nboIpAddr2)
                && (0 != HelperRegVal.nboWINSNameServer1))
            {
                HelperRegVal.nboWINSNameServer2 = nboIpAddr2;
            }

            LocalFree(szIpAddr);
            szIpAddr = NULL;
        }

        dwErr = RegQueryValueWithAllocA(hKeyIpParam, REGVAL_DNSSERVERS_A, 
                    REG_MULTI_SZ, &szAlloced);

        if (NO_ERROR == dwErr)
        {
            szIpAddr = szAlloced;
            nboIpAddr1 = inet_addr(szIpAddr);
            // We are sure that the buffer szIpAddr has 2 zeros at the end
            szIpAddr += strlen(szIpAddr) + 1;
            nboIpAddr2 = inet_addr(szIpAddr);

            if (   (INADDR_NONE != nboIpAddr1)
                && (0 != nboIpAddr1))
            {
                HelperRegVal.nboDNSNameServer1 = nboIpAddr1;

                if (INADDR_NONE != nboIpAddr2)
                {
                    HelperRegVal.nboDNSNameServer2 = nboIpAddr2;
                }
            }

            LocalFree(szAlloced);
            szAlloced = NULL;
        }
    }

    TraceHlp("%s: %d, %s: %d, %s: %d",
        REGVAL_SUPPRESSWINS_A, HelperRegVal.fSuppressWINSNameServers,
        REGVAL_SUPPRESSDNS_A,  HelperRegVal.fSuppressDNSNameServers,
        REGVAL_CHUNK_SIZE_A,   HelperRegVal.dwChunkSize);

    TraceHlp("%s: 0x%x, %s: 0x%x, %s: 0x%x, 0x%x",
        REGVAL_WINSSERVER_A,        HelperRegVal.nboWINSNameServer1,
        REGVAL_WINSSERVERBACKUP_A,  HelperRegVal.nboWINSNameServer2,
        REGVAL_DNSSERVERS_A,        HelperRegVal.nboDNSNameServer1,
                                    HelperRegVal.nboDNSNameServer2);

    if (NULL != hKeyIpParam)
    {
        RegCloseKey(hKeyIpParam);
    }

    LocalFree(wszAdapterGuid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\helper.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _HELPER_H_
#define _HELPER_H_

#include "rasiphlp.h"

VOID   
TraceHlp(
    IN  CHAR*   Format, 
    ... 
);

DWORD
HelperInitialize(
    OUT HINSTANCE*  phInstanceDhcpDll
);

VOID
HelperUninitialize(
    VOID
);

VOID
HelperChangeNotification(
    VOID
);

DWORD
HelperSetDefaultInterfaceNet(
    IN  IPADDR  nboIpAddrLocal,
    IN  IPADDR  nboIpAddrRemote,
    IN  BOOL    fPrioritize,
    IN  WCHAR   *pszDevice
);

DWORD
HelperResetDefaultInterfaceNet(
    IN  IPADDR  nboIpAddr,
    IN  BOOL    fPrioritize
);

DWORD
HelperSetDefaultInterfaceNetEx(
    IPADDR  nboIpAddr,
    WCHAR*  wszDevice,
    BOOL    fPrioritize,
    WCHAR*  wszDnsAddress,
    WCHAR*  wszDns2Address,
    WCHAR*  wszWinsAddress,
    WCHAR*  wszWins2Address
);

DWORD
HelperResetDefaultInterfaceNetEx(
    IPADDR  nboIpAddr,
    WCHAR*  wszDevice,
    BOOL    fPrioritize,
    WCHAR*  wszDnsAddress,
    WCHAR*  wszDns2Address,
    WCHAR*  wszWinsAddress,
    WCHAR*  wszWins2Address
);

#endif // #ifndef _HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rasdhcp.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _RASDHCP_H_
#define _RASDHCP_H_

#include "rasiphlp.h"

DWORD
RasDhcpInitialize(
    VOID
);

VOID
RasDhcpUninitialize(
    VOID
);

DWORD
RasDhcpAcquireAddress(
    IN  HPORT   hPort,
    OUT IPADDR* pnboIpAddr,
    OUT IPADDR* pnboIpMask,
    OUT BOOL*   pfEasyNet
);

VOID
RasDhcpReleaseAddress(
    IN  IPADDR  nboIpAddr
);

#endif // #ifndef _RASDHCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rasiphlp.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _RASIPHLP_H_
#define _RASIPHLP_H_

typedef ULONG IPADDR;

#endif // #ifndef _RASIPHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\helper_.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _HELPER__H_
#define _HELPER__H_

#include "rasiphlp_.h"
#include <dhcpcapi.h>
#include <rasman.h>
#include <llinfo.h>
#include <ddwanarp.h>
#include <winsock2.h>
#include <objbase.h>
#include "rastcp.h"
#include "tcpreg.h"
#include "rassrvr.h"
#include "rasstat.h"
#include "helper.h"

LONG                        HelperLock                  = 0;
BOOL                        HelperInitialized           = FALSE;
HANDLE                      HelperWanArpHandle          = INVALID_HANDLE_VALUE;
HINSTANCE                   HelperDhcpDll               = NULL;
HINSTANCE                   HelperIpHlpDll              = NULL;
HINSTANCE                   HelperIpBootpDll            = NULL;
DWORD                       HelperTraceId               = (DWORD)-1;
REGVAL                      HelperRegVal;

DHCPNOTIFYCONFIGCHANGE              PDhcpNotifyConfigChange             = NULL;
DHCPLEASEIPADDRESS                  PDhcpLeaseIpAddress                 = NULL;
DHCPRENEWIPADDRESSLEASE             PDhcpRenewIpAddressLease            = NULL;
DHCPRELEASEIPADDRESSLEASE           PDhcpReleaseIpAddressLease          = NULL;
SETPROXYARPENTRYTOSTACK             PSetProxyArpEntryToStack            = NULL;
SETIPFORWARDENTRYTOSTACK            PSetIpForwardEntryToStack           = NULL;
SETIPFORWARDENTRY                   PSetIpForwardEntry                  = NULL;
DELETEIPFORWARDENTRY                PDeleteIpForwardEntry               = NULL;
ALLOCATEANDGETIPADDRTABLEFROMSTACK  PAllocateAndGetIpAddrTableFromStack = NULL;
NHPALLOCATEANDGETINTERFACEINFOFROMSTACK PNhpAllocateAndGetInterfaceInfoFromStack = NULL;
ALLOCATEANDGETIPFORWARDTABLEFROMSTACK   PAllocateAndGetIpForwardTableFromStack   = NULL;
GETADAPTERSINFO                     PGetAdaptersInfo                    = NULL;
GETPERADAPTERINFO                   PGetPerAdapterInfo                  = NULL;
ENABLEDHCPINFORMSERVER              PEnableDhcpInformServer             = NULL;
DISABLEDHCPINFORMSERVER             PDisableDhcpInformServer            = NULL;

CRITICAL_SECTION            RasDhcpCriticalSection;
CRITICAL_SECTION            RasStatCriticalSection;
CRITICAL_SECTION            RasSrvrCriticalSection;
CRITICAL_SECTION            RasTimrCriticalSection;

DWORD
helperGetAddressOfProcs(
    VOID
);

VOID
helperReadRegistry(
    VOID
);

#endif // #ifndef _HELPER__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rasdhcp_.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _RASDHCP__H_
#define _RASDHCP__H_

#include "rasiphlp_.h"
#include <time.h>
#include <dhcpcapi.h>
#include <winsock2.h>
#include <mprlog.h>
#include <rasman.h>
#include <rasppp.h>
#include <raserror.h>
#include "helper.h"
#include "tcpreg.h"
#include "timer.h"
#include "rastcp.h"
#include "rassrvr.h"
#include "rasdhcp.h"

// This is used in combination with MAC address and Index to generate a
// unique clientUID.

#define RAS_PREPEND                 "RAS "

// The following should be a multiple of TIMER_PERIOD/1000

#define RETRY_TIME                  120     // Every 120 seconds

// Values of the ADDR_INFO->ai_Flags field

// Set after lease expires and after registry is read. Unset after a
// successful renew.

#define AI_FLAG_RENEW               0x00000001

// Set if in use

#define AI_FLAG_IN_USE              0x00000002

typedef struct _Addr_Info
{
    struct _Addr_Info*              ai_Next;
    TIMERLIST                       ai_Timer;
    DHCP_LEASE_INFO                 ai_LeaseInfo;

    // AI_FLAG_*
    DWORD                           ai_Flags;

    // Valid only for allocated addresses. For diagnositc purposes.
    HPORT                           ai_hPort;

    // Client UID is a combo of RAS_PREPEND,
    // 8 byte base and a 4 byte index.
    union
    {
        BYTE                        ai_ClientUIDBuf[16];
        DWORD                       ai_ClientUIDWords[4];
    };

} ADDR_INFO;

typedef struct _Available_Index
{
    struct _Available_Index*        pNext;

    // This index is < RasDhcpNextIndex, but is available
    // because we couldn't renew its lease.
    DWORD                           dwIndex;

} AVAIL_INDEX;

NT_PRODUCT_TYPE                     RasDhcpNtProductType    = NtProductWinNt;

ADDR_INFO*                          RasDhcpFreePool         = NULL;
ADDR_INFO*                          RasDhcpAllocPool        = NULL;
AVAIL_INDEX*                        RasDhcpAvailIndexes     = NULL;
BOOL                                RasDhcpUsingEasyNet     = TRUE;

DWORD                               RasDhcpNumAddrsAlloced  = 0;
DWORD                               RasDhcpNumReqAddrs      = 0;
DWORD                               RasDhcpNextIndex        = 0;

TIMERLIST                           RasDhcpMonitorTimer     = { 0 };

// This critical section controls access to the above global variables
extern          CRITICAL_SECTION    RasDhcpCriticalSection;

DWORD
rasDhcpAllocateAddress(
    VOID
);

VOID
rasDhcpRenewLease(
    IN  HANDLE      rasDhcpTimerShutdown,
    IN  TIMERLIST*  pTimer
);

VOID
rasDhcpFreeAddress(
    IN  ADDR_INFO*  pAddrInfo
);

VOID
rasDhcpMonitorAddresses(
    IN  HANDLE      rasDhcpTimerShutdown,
    IN  TIMERLIST*  pTimer
);

VOID
rasDhcpInitializeAddrInfo(
    IN OUT  ADDR_INFO*  pNewAddrInfo,
    IN      BYTE*       pbAddress,
    OUT     BOOL*       pfPutInAvailList
);

VOID
rasDhcpDeleteLists(
    VOID
);

BOOL
rasDhcpNeedToRenewLease(
    IN  ADDR_INFO*  pAddrInfo
);

DWORD
rasDhcpMaxAddrsToAllocate(
    VOID
);

#endif // #ifndef _RASDHCP__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rasdhcp.c ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:
    Only the timer thread can call the following functions: 
    rasDhcpAllocateAddress, rasDhcpMonitorAddresses, rasDhcpRenewLease. This is 
    required to avoid race conditions in the timer queue (because these 
    functions call RasDhcpTimerSchedule). The only exception is that 
    RasDhcpInitialize can call RasDhcpTimerSchedule, but before the timer thread
    is started. rasDhcpRenewLease leaves and enters the critical section in the
    middle of the function. If pAddrInfo is freed in the meantime, there will be
    an AV. However, only rasDhcpDeleteLists frees pAddrInfo's from the list. 
    Fortunately, only RasDhcpUninitialize (after stopping the timer thread) and 
    rasDhcpAllocateAddress (which belongs to the timer thread) call 
    rasDhcpDeleteLists.

    If we get an EasyNet address, DHCP has already made sure that it is not 
    conflicting with anyone. We call SetProxyArp, so that no one else in the 
    future will take it (if they are well behaved).

*/

#include "rasdhcp_.h"

/*

Returns:

Notes:
    There is no synchronization here, can be added easily but the assumption 
    here is that the initialization is a synchronous operation and till it 
    completes, no other code in this sub-system will be called.

*/

DWORD
RasDhcpInitialize(
    VOID
)
{
    DWORD   dwErr   = NO_ERROR;

    TraceHlp("RasDhcpInitialize");

    EnterCriticalSection(&RasDhcpCriticalSection);

    RtlGetNtProductType(&RasDhcpNtProductType);

    if (NtProductWinNt == RasDhcpNtProductType)
    {
        RasDhcpNumReqAddrs = 2;
    }
    else
    {
        RasDhcpNumReqAddrs = HelperRegVal.dwChunkSize;
    }

    // This should be done before we start the timer thread. Once the timer
    // thread starts, only it can call RasDhcpTimerSchedule (to avoid race
    // conditions). 

    RasDhcpTimerSchedule(
        &RasDhcpMonitorTimer,
        0,
        rasDhcpMonitorAddresses);

    dwErr = RasDhcpTimerInitialize();

    if (NO_ERROR != dwErr)
    {
        TraceHlp("RasDhcpInitTimer failed and returned %d", dwErr);
        goto LDone;
    }

LDone:

    if (NO_ERROR != dwErr)
    {
        RasDhcpTimerUninitialize();
    }

    LeaveCriticalSection(&RasDhcpCriticalSection);

    return(dwErr);
}

/*

Returns:
    VOID

Notes:

*/

VOID
RasDhcpUninitialize(
    VOID
)
{
    TraceHlp("RasDhcpUninitialize");

    /*
    Do not hold RasDhcpCriticalSection while calling this function. Otherwise, 
    the following deadlock can occur: The timer thread is blocked in 
    rasDhcpAllocateAddress, waiting for RasDhcpCriticalSection, and this thread 
    is blocked in RasDhcpTimerUninitialize, waiting for the timer thread to 
    stop.
    */
    RasDhcpTimerUninitialize();

    EnterCriticalSection(&RasDhcpCriticalSection);

    /*
    To avoid a possible race condition in rasDhcpRenewLease (see the comments
    in that function), it is important to call RasDhcpTimerUninitialize and
    kill the timer thread before calling rasDhcpDeleteLists.
    */
    rasDhcpDeleteLists();

    RasDhcpUsingEasyNet = TRUE;

    LeaveCriticalSection(&RasDhcpCriticalSection);
}

/*

Returns:

Notes:

*/

DWORD
RasDhcpAcquireAddress(
    IN  HPORT   hPort,
    OUT IPADDR* pnboIpAddr,
    OUT IPADDR* pnboIpMask,
    OUT BOOL*   pfEasyNet
)
{
    ADDR_INFO*  pAddrInfo;
    DWORD       dwErr       = ERROR_NOT_FOUND;

    TraceHlp("RasDhcpAcquireAddress");

    EnterCriticalSection(&RasDhcpCriticalSection);

    if (NULL == RasDhcpFreePool)
    {
        TraceHlp("Out of addresses");
        goto LDone;
    }

    // Move from Free pool to Alloc pool
    pAddrInfo = RasDhcpFreePool;
    RasDhcpFreePool = RasDhcpFreePool->ai_Next;
    pAddrInfo->ai_Next = RasDhcpAllocPool;
    RasDhcpAllocPool = pAddrInfo;

    TraceHlp("Acquired 0x%x", pAddrInfo->ai_LeaseInfo.IpAddress);
    *pnboIpAddr = htonl(pAddrInfo->ai_LeaseInfo.IpAddress);
    *pnboIpMask = htonl(pAddrInfo->ai_LeaseInfo.SubnetMask);
    pAddrInfo->ai_hPort = hPort;
    pAddrInfo->ai_Flags |= AI_FLAG_IN_USE;

    if (NULL != pfEasyNet)
    {
        *pfEasyNet = RasDhcpUsingEasyNet;
    }

    if (   (NULL == RasDhcpFreePool)
        && (0 == RasDhcpNumReqAddrs))
    {
        // We don't have any more addresses to give out. Let us
        // acquire another chunk of them.

        if (NtProductWinNt == RasDhcpNtProductType)
        {
            RasDhcpNumReqAddrs += 1;
        }
        else
        {
            RasDhcpNumReqAddrs += HelperRegVal.dwChunkSize;
        }

        RasDhcpTimerRunNow();
    }

    dwErr = NO_ERROR;

LDone:

    LeaveCriticalSection(&RasDhcpCriticalSection);

    return(dwErr);
}

/*

Returns:
    VOID

Notes:

*/

VOID
RasDhcpReleaseAddress(
    IN  IPADDR  nboIpAddr
)
{
    ADDR_INFO*  pAddrInfo;
    ADDR_INFO** ppAddrInfo;
    IPADDR      hboIpAddr;

    TraceHlp("RasDhcpReleaseAddress");

    EnterCriticalSection(&RasDhcpCriticalSection);

    hboIpAddr = ntohl(nboIpAddr);

    for (ppAddrInfo = &RasDhcpAllocPool;
         (pAddrInfo = *ppAddrInfo) != NULL;
         ppAddrInfo = &pAddrInfo->ai_Next)
    {
        if (pAddrInfo->ai_LeaseInfo.IpAddress == hboIpAddr)
        {
            TraceHlp("Released 0x%x", nboIpAddr);

            // Unlink from alloc pool
            *ppAddrInfo = pAddrInfo->ai_Next;

            // Put at the end of the free pool, because we want to round-robin
            // the addresses.
            pAddrInfo->ai_Next = NULL;

            ppAddrInfo = &RasDhcpFreePool;
            while (NULL != *ppAddrInfo)
            {
                ppAddrInfo = &((*ppAddrInfo)->ai_Next);
            }
            *ppAddrInfo = pAddrInfo;

            pAddrInfo->ai_Flags &= ~AI_FLAG_IN_USE;
            goto LDone;
        }
    }

    TraceHlp("IpAddress 0x%x not present in alloc pool", nboIpAddr);

LDone:

    LeaveCriticalSection(&RasDhcpCriticalSection);
}

/*

Returns:

Notes:
    Allocate an address from the DHCP server.

*/

DWORD
rasDhcpAllocateAddress(
    VOID
)
{
    IPADDR              nboIpAddress;
    ADDR_INFO*          pAddrInfo                               = NULL;
    DHCP_OPTION_INFO*   pOptionInfo                             = NULL;
    DHCP_LEASE_INFO*    pLeaseInfo                              = NULL;
    AVAIL_INDEX*        pAvailIndex;
    time_t              now                                     = time(NULL);
    BOOL                fEasyNet                                = FALSE;
    BOOL                fPutInAvailList                         = FALSE;
    BOOL                fCSEntered                              = FALSE;
    BYTE                bAddress[MAX_ADAPTER_ADDRESS_LENGTH];
    CHAR                szIpAddress[MAXIPSTRLEN + 1];
    CHAR*               sz;
    PPPE_MESSAGE        PppMessage;
    DWORD               dwErr                                   = NO_ERROR;

    TraceHlp("rasDhcpAllocateAddress");

    dwErr = GetPreferredAdapterInfo(&nboIpAddress, NULL, NULL, NULL, NULL,
                bAddress);

    if (NO_ERROR != dwErr)
    {
        // There is probably no NIC on the machine
        nboIpAddress = htonl(INADDR_LOOPBACK);
    }

    pAddrInfo = LocalAlloc(LPTR, sizeof(ADDR_INFO));

    if (pAddrInfo == NULL)
    {
        dwErr = GetLastError();
        TraceHlp("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    // Initialize the structure.

    rasDhcpInitializeAddrInfo(pAddrInfo, bAddress, &fPutInAvailList);

    // Call DHCP to allocate an IP address.

    dwErr = PDhcpLeaseIpAddress(
                ntohl(nboIpAddress),
                &pAddrInfo->ai_LeaseInfo.ClientUID,
                0,
                NULL,
                &pLeaseInfo,
                &pOptionInfo);

    if (ERROR_SUCCESS != dwErr)
    {
        pLeaseInfo = NULL;
        pOptionInfo = NULL;
        TraceHlp("DhcpLeaseIpAddress failed and returned %d", dwErr);
        goto LDone;
    }

    // Copy stuff into the pAddrInfo structure

    pAddrInfo->ai_LeaseInfo.IpAddress         = pLeaseInfo->IpAddress;
    pAddrInfo->ai_LeaseInfo.SubnetMask        = pLeaseInfo->SubnetMask;
    pAddrInfo->ai_LeaseInfo.DhcpServerAddress = pLeaseInfo->DhcpServerAddress;
    pAddrInfo->ai_LeaseInfo.Lease             = pLeaseInfo->Lease;
    pAddrInfo->ai_LeaseInfo.LeaseObtained     = pLeaseInfo->LeaseObtained;
    pAddrInfo->ai_LeaseInfo.T1Time            = pLeaseInfo->T1Time;
    pAddrInfo->ai_LeaseInfo.T2Time            = pLeaseInfo->T2Time;
    pAddrInfo->ai_LeaseInfo.LeaseExpires      = pLeaseInfo->LeaseExpires;

    EnterCriticalSection(&RasDhcpCriticalSection);
    fCSEntered = TRUE;

    if (-1 == (DWORD)(pLeaseInfo->DhcpServerAddress))
    {
        fEasyNet = TRUE;

        if (!RasDhcpUsingEasyNet)
        {
            dwErr = E_FAIL;
            TraceHlp("Not accepting any more EasyNet addresses");
            goto LDone;
        }

        AbcdSzFromIpAddress(htonl(pLeaseInfo->IpAddress), szIpAddress);
        sz = szIpAddress;

        LogEvent(EVENTLOG_WARNING_TYPE, ROUTERLOG_AUTONET_ADDRESS, 1,
            (CHAR**)&sz);

        // We undo this call to RasTcpSetProxyArp in rasDhcpDeleteLists. 

        RasTcpSetProxyArp(htonl(pLeaseInfo->IpAddress), TRUE);
    }
    else
    {
        if (RasDhcpUsingEasyNet)
        {
            rasDhcpDeleteLists();
            // We have already used up index 0 to get this address
            RasDhcpNextIndex = 1;
            RasDhcpUsingEasyNet = FALSE;

            PppMessage.dwMsgId = PPPEMSG_IpAddressLeaseExpired;
            PppMessage.ExtraInfo.IpAddressLeaseExpired.nboIpAddr = 0;
            SendPPPMessageToEngine(&PppMessage);
        }

        if (NULL != PEnableDhcpInformServer)
        {
            // Redirect DHCP inform packets to this server.
            PEnableDhcpInformServer(htonl(pLeaseInfo->DhcpServerAddress));
        }
    }

    pAddrInfo->ai_Next = RasDhcpFreePool;
    RasDhcpFreePool = pAddrInfo;
    if (0 < RasDhcpNumReqAddrs)
    {
        // We need one less address now.
        RasDhcpNumReqAddrs--;
    }

    RasDhcpNumAddrsAlloced++;

    TraceHlp("Allocated address 0x%x using 0x%x, timer %ld%s",
        pAddrInfo->ai_LeaseInfo.IpAddress,
        nboIpAddress,
        pAddrInfo->ai_LeaseInfo.T1Time - now,
        fEasyNet ? ", EasyNet" : "");

    if (!fEasyNet)
    {
        // Start timer for lease renewal
        RasDhcpTimerSchedule(
            &pAddrInfo->ai_Timer,
            (LONG)(pAddrInfo->ai_LeaseInfo.T1Time - now),
            rasDhcpRenewLease);
    }

LDone:

    if (fCSEntered)
    {
        LeaveCriticalSection(&RasDhcpCriticalSection);
    }

    if (NO_ERROR != dwErr)
    {
        if (fPutInAvailList)
        {
            pAvailIndex = LocalAlloc(LPTR, sizeof(AVAIL_INDEX));

            if (NULL == pAvailIndex)
            {
                TraceHlp("Couldn't put index %d in the avail list. "
                    "Out of memory", pAddrInfo->ai_ClientUIDWords[3]);
            }
            else
            {
                EnterCriticalSection(&RasDhcpCriticalSection);

                pAvailIndex->dwIndex = pAddrInfo->ai_ClientUIDWords[3];
                pAvailIndex->pNext = RasDhcpAvailIndexes;
                RasDhcpAvailIndexes = pAvailIndex;

                LeaveCriticalSection(&RasDhcpCriticalSection);
            }
        }

        LocalFree(pAddrInfo);
    }

    LocalFree(pLeaseInfo);
    LocalFree(pOptionInfo);

    return(dwErr);
}

/*

Returns:
    VOID

Notes:
    Renew the lease on an address with the DHCP server. This is also called by 
    the timer thread when the its time to renew the lease.

*/

VOID
rasDhcpRenewLease(
    IN  HANDLE      rasDhcpTimerShutdown,
    IN  TIMERLIST*  pTimer
)
{
    IPADDR              nboIpAddress;
    ADDR_INFO*          pAddrInfo;
    ADDR_INFO**         ppAddrInfo;
    DHCP_OPTION_INFO*   pOptionInfo     = NULL;
    AVAIL_INDEX*        pAvailIndex;
    time_t              now             = time(NULL);
    IPADDR              nboIpAddrTemp   = 0;
    PPPE_MESSAGE        PppMessage;
    BOOL                fNeedToRenew;
    DWORD               dwErr;

    TraceHlp("rasDhcpRenewLease");

    dwErr = GetPreferredAdapterInfo(&nboIpAddress, NULL, NULL, NULL, NULL,
                NULL);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("Couldn't get a NIC IP Address. Unable to renew lease");
        goto LDone;
    }

    EnterCriticalSection(&RasDhcpCriticalSection);

    pAddrInfo = CONTAINING_RECORD(pTimer, ADDR_INFO, ai_Timer);

    TraceHlp("address 0x%x", pAddrInfo->ai_LeaseInfo.IpAddress);

    pAddrInfo->ai_Flags |= AI_FLAG_RENEW;

    fNeedToRenew = rasDhcpNeedToRenewLease(pAddrInfo);

    LeaveCriticalSection(&RasDhcpCriticalSection);

    /*
    A race condition can occur if a thread other than this thread (the timer 
    thread) calls rasDhcpDeleteLists when we are here. rasDhcpAllocateAddress 
    calls rasDhcpDeleteLists, but only the timer thread calls 
    rasDhcpAllocateAddress. RasDhcpUninitialize also calls rasDhcpDeleteLists, 
    but it calls RasDhcpTimerUninitialize first. Before RasDhcpTimerUninitialize
    returns, the timer thread exits, so it is impossible for us to be here.

    In the worst case, DhcpRenewIpAddressLease might take up to 60 sec. In the
    average case, it is 2-10 sec.
    */

    if (fNeedToRenew)
    {
        dwErr = PDhcpRenewIpAddressLease(
                    ntohl(nboIpAddress),
                    &pAddrInfo->ai_LeaseInfo,
                    NULL,
                    &pOptionInfo);
    }
    else
    {
        // Simulate not being able to renew
        dwErr = ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection(&RasDhcpCriticalSection);

    if (dwErr == ERROR_SUCCESS)
    {
        pAddrInfo->ai_Flags &= ~AI_FLAG_RENEW;
    
        TraceHlp("success for address 0x%x, resched timer %ld",
            pAddrInfo->ai_LeaseInfo.IpAddress,
            pAddrInfo->ai_LeaseInfo.T1Time - now);

        // Start timer to renew

        RasDhcpTimerSchedule(
            pTimer,
            (LONG)(pAddrInfo->ai_LeaseInfo.T1Time - now),
            rasDhcpRenewLease);
    }
    else if (   (ERROR_ACCESS_DENIED == dwErr)
             || (now > pAddrInfo->ai_LeaseInfo.T2Time))
    {
        TraceHlp("failed for address 0x%x", pAddrInfo->ai_LeaseInfo.IpAddress);

        if (fNeedToRenew)
        {
            RasDhcpNumReqAddrs++;
        }

        if (RasDhcpNumAddrsAlloced > 0)
        {
            RasDhcpNumAddrsAlloced--;
        }

        // Cannot renew lease. Blow this away.

        nboIpAddrTemp = htonl(pAddrInfo->ai_LeaseInfo.IpAddress);

        // Unlink this structure from the list and cleanup

        ppAddrInfo = (pAddrInfo->ai_Flags & AI_FLAG_IN_USE) ?
                        &RasDhcpAllocPool : &RasDhcpFreePool;

        for (; *ppAddrInfo != NULL; ppAddrInfo = &(*ppAddrInfo)->ai_Next)
        {
            if (pAddrInfo == *ppAddrInfo)
            {
                pAvailIndex = LocalAlloc(LPTR, sizeof(AVAIL_INDEX));

                if (NULL == pAvailIndex)
                {
                    TraceHlp("Couldn't put index %d in the avail list. "
                        "Out of memory", pAddrInfo->ai_ClientUIDWords[3]);
                }
                else
                {
                    pAvailIndex->dwIndex = pAddrInfo->ai_ClientUIDWords[3];
                    pAvailIndex->pNext = RasDhcpAvailIndexes;
                    RasDhcpAvailIndexes = pAvailIndex;
                }

                *ppAddrInfo = pAddrInfo->ai_Next;
                break;
            }
        }

        rasDhcpFreeAddress(pAddrInfo);
        LocalFree(pAddrInfo);

        PppMessage.dwMsgId = PPPEMSG_IpAddressLeaseExpired;
        PppMessage.ExtraInfo.IpAddressLeaseExpired.nboIpAddr = nboIpAddrTemp;
        SendPPPMessageToEngine(&PppMessage);
    }
    else
    {
        TraceHlp("Error %d. Will try again later.", dwErr);
        TraceHlp("Seconds left before expiry: %d",
            pAddrInfo->ai_LeaseInfo.T2Time - now);

        // Could not contact the Dhcp Server, retry in a little bit
        RasDhcpTimerSchedule(pTimer, RETRY_TIME, rasDhcpRenewLease);
    }

    LeaveCriticalSection(&RasDhcpCriticalSection);

LDone:

    LocalFree(pOptionInfo);
}

/*

Notes:
    We call DHCP to release the address.

*/

VOID
rasDhcpFreeAddress(
    IN  ADDR_INFO*  pAddrInfo
)
{
    IPADDR  nboIpAddress;
    DWORD   dwErr;

    RTASSERT(NULL != pAddrInfo);

    TraceHlp("rasDhcpFreeAddress 0x%x", pAddrInfo->ai_LeaseInfo.IpAddress);

    dwErr = GetPreferredAdapterInfo(&nboIpAddress, NULL, NULL, NULL, NULL,
                NULL);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("Couldn't get a NIC IP Address. Unable to release address");
        goto LDone;
    }

    // Call DHCP to release the address.

    dwErr = PDhcpReleaseIpAddressLease(ntohl(nboIpAddress),
                &pAddrInfo->ai_LeaseInfo);

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("DhcpReleaseIpAddressLease failed and returned %d", dwErr);
    }

    if (RasDhcpNumAddrsAlloced > 0)
    {
        RasDhcpNumAddrsAlloced--;
    }

LDone:

    return;
}

/*

Returns:
    VOID

Notes:
    If we don't have enough addresses (because lease renewal failed or we were 
    unable to allocate), try to acquire some. The argument pTimer is not used.

*/

VOID
rasDhcpMonitorAddresses(
    IN  HANDLE      rasDhcpTimerShutdown,
    IN  TIMERLIST*  pTimer
)
{
    DWORD   dwErr;

    while (TRUE)
    {
        EnterCriticalSection(&RasDhcpCriticalSection);

        if (0 == RasDhcpNumReqAddrs)
        {
            LeaveCriticalSection(&RasDhcpCriticalSection);
            break;
        }

        if (RasDhcpNumAddrsAlloced >= rasDhcpMaxAddrsToAllocate())
        {
            RasDhcpNumReqAddrs = 0;
            LeaveCriticalSection(&RasDhcpCriticalSection);
            break;
        }

        LeaveCriticalSection(&RasDhcpCriticalSection);

        dwErr = rasDhcpAllocateAddress();

        if (NO_ERROR != dwErr)
        {
            break;
        }

        if (WaitForSingleObject(rasDhcpTimerShutdown, 10) != WAIT_TIMEOUT)
        {
            break;
        }
    }

    // Start timer to monitor if we are running short on addresses etc.

    RasDhcpTimerSchedule(
        &RasDhcpMonitorTimer,
        0,
        rasDhcpMonitorAddresses);
}

/*

Returns:
    VOID

Notes:

*/

VOID
rasDhcpInitializeAddrInfo(
    IN OUT  ADDR_INFO*  pNewAddrInfo,
    IN      BYTE*       pbAddress,
    OUT     BOOL*       pfPutInAvailList
)
{
    DWORD           dwIndex;
    AVAIL_INDEX*    pAvailIndex;

    RTASSERT(NULL != pNewAddrInfo);

    TraceHlp("rasDhcpInitializeAddrInfo");

    EnterCriticalSection(&RasDhcpCriticalSection);

    // ClientUIDBase is a combination of RAS_PREPEND (4 chars),
    // MAC address (8 chars), Index (4 chars)

    if (RasDhcpUsingEasyNet)
    {
        dwIndex = 0;
    }
    else
    {
        *pfPutInAvailList = TRUE;

        if (NULL != RasDhcpAvailIndexes)
        {
            pAvailIndex = RasDhcpAvailIndexes;
            dwIndex = pAvailIndex->dwIndex;
            RasDhcpAvailIndexes = RasDhcpAvailIndexes->pNext;
            LocalFree(pAvailIndex);
        }
        else
        {
            dwIndex = RasDhcpNextIndex++;
        }
    }

    TraceHlp("dwIndex = %d", dwIndex);

    strcpy(pNewAddrInfo->ai_ClientUIDBuf, RAS_PREPEND);
    memcpy(pNewAddrInfo->ai_ClientUIDBuf + strlen(RAS_PREPEND),
           pbAddress, MAX_ADAPTER_ADDRESS_LENGTH);
    pNewAddrInfo->ai_ClientUIDWords[3] = dwIndex;

    pNewAddrInfo->ai_LeaseInfo.ClientUID.ClientUID =
        pNewAddrInfo->ai_ClientUIDBuf;
    pNewAddrInfo->ai_LeaseInfo.ClientUID.ClientUIDLength =
        sizeof(pNewAddrInfo->ai_ClientUIDBuf);

    LeaveCriticalSection(&RasDhcpCriticalSection);
}

/*

Returns:
    VOID

Notes:
    Delete proxy arp entries for easy net addresses.

*/

VOID
rasDhcpDeleteLists(
    VOID
)
{
    ADDR_INFO*      pAddrInfo;
    ADDR_INFO*      pTempAddrInfo;
    ADDR_INFO*      pList[2]            = {RasDhcpAllocPool, RasDhcpFreePool};
    AVAIL_INDEX*    pAvailIndex;
    AVAIL_INDEX*    pTempAvailIndex;
    DWORD           dwIndex;

    TraceHlp("rasDhcpDeleteLists");

    EnterCriticalSection(&RasDhcpCriticalSection);

    for (dwIndex = 0; dwIndex < 2; dwIndex++)
    {
        pAddrInfo = pList[dwIndex];
        while (pAddrInfo != NULL)
        {
            if (RasDhcpUsingEasyNet)
            {
                RasTcpSetProxyArp(htonl(pAddrInfo->ai_LeaseInfo.IpAddress),
                    FALSE);
            }
            else
            {
                rasDhcpFreeAddress(pAddrInfo);
            }
            pTempAddrInfo = pAddrInfo;
            pAddrInfo = pAddrInfo->ai_Next;
            LocalFree(pTempAddrInfo);
        }
    }

    for (pAvailIndex = RasDhcpAvailIndexes; NULL != pAvailIndex;)
    {
        pTempAvailIndex = pAvailIndex;
        pAvailIndex = pAvailIndex->pNext;
        LocalFree(pTempAvailIndex);
    }

    RasDhcpAllocPool    = NULL;
    RasDhcpFreePool     = NULL;
    RasDhcpAvailIndexes = NULL;
    if (NtProductWinNt == RasDhcpNtProductType)
    {
        RasDhcpNumReqAddrs = 2;
    }
    else
    {
        RasDhcpNumReqAddrs = HelperRegVal.dwChunkSize;
    }
    RasDhcpNextIndex        = 0;
    RasDhcpNumAddrsAlloced  = 0;

    LeaveCriticalSection(&RasDhcpCriticalSection);
}

/*

Returns:
    VOID

Notes:
    Should we bother to renew the lease?

*/

BOOL
rasDhcpNeedToRenewLease(
    IN  ADDR_INFO*  pAddrInfo
)
{
    BOOL        fRet    = TRUE;
    DWORD       dwCount = 0;
    ADDR_INFO*  pTemp;

    TraceHlp("rasDhcpNeedToRenewLease");

    EnterCriticalSection(&RasDhcpCriticalSection);

    if (pAddrInfo->ai_Flags & AI_FLAG_IN_USE)
    {
        goto LDone;
    }

    // How many free addresses do we have?

    for (pTemp = RasDhcpFreePool; pTemp != NULL; pTemp = pTemp->ai_Next)
    {
        dwCount++;
    }

    if (dwCount > HelperRegVal.dwChunkSize)
    {
        fRet = FALSE;
    }

LDone:

    TraceHlp("Need to renew: %s", fRet ? "TRUE" : "FALSE");

    LeaveCriticalSection(&RasDhcpCriticalSection);

    return(fRet);
}

/*

Returns:
    The maximum number of addresses that we can get from the DHCP server.

Notes:

*/

DWORD
rasDhcpMaxAddrsToAllocate(
    VOID
)
{
    DWORD           dwErr           = NO_ERROR;
    DWORD           dwSize          = 0;
    DWORD           dwNumEntries    = 0;
    DWORD           dwRet           = 0;
    DWORD           dw;
    RASMAN_PORT*    pRasmanPort     = NULL;

    dwErr = RasPortEnum(NULL, NULL, &dwSize, &dwNumEntries);
    RTASSERT(ERROR_BUFFER_TOO_SMALL == dwErr);

    pRasmanPort = (RASMAN_PORT*) LocalAlloc(LPTR, dwSize);
    if (NULL == pRasmanPort)
    {
        // The server adapter also needs an address.
        dwRet = dwNumEntries + 1;
        goto LDone;
    }

    dwErr = RasPortEnum(NULL, (BYTE*)pRasmanPort, &dwSize, &dwNumEntries);
    if (NO_ERROR != dwErr)
    {
        // The server adapter also needs an address.
        dwRet = dwNumEntries + 1;
        goto LDone;
    }

    for (dw = 0, dwRet = 0; dw < dwNumEntries; dw++)
    {
        if (   (pRasmanPort[dw].P_ConfiguredUsage & CALL_IN)
            || (pRasmanPort[dw].P_ConfiguredUsage & CALL_ROUTER))
        {
            dwRet++;
        }
    }

    // The server adapter also needs an address.
    dwRet++;

LDone:

    LocalFree(pRasmanPort);
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rassrvr.c ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#include "rassrvr_.h"

//    This flag indicates if netbios options are to be preserved for
//    the ras server adapter or not.
BOOL g_fDisableNetbiosOverTcpip = FALSE;

extern BOOL HelperInitialized;

BOOL WINAPI ShutdownHandlerRoutine ( DWORD dwCtrlType )
{
	if ( CTRL_SHUTDOWN_EVENT == dwCtrlType )
	{
		TraceHlp("ShutdownHandlerRoutine.  Got Shutdown Event.  Releasing DhcpAddresses");
		//uninitialize Dhcp addresses here.
		RasDhcpUninitialize();
		return TRUE;
	}
	return FALSE;
}


/*

Returns:

Notes:

*/

DWORD
RasSrvrInitialize(
    IN  MPRADMINGETIPADDRESSFORUSER*    pfnMprGetAddress,
    IN  MPRADMINRELEASEIPADDRESS*       pfnMprReleaseAddress
)
{
    DNS_STATUS  DnsStatus;
    HINSTANCE   hInstance;
    DWORD       dwErr                   = NO_ERROR;

    TraceHlp("RasSrvrInitialize");

    g_fDisableNetbiosOverTcpip = FALSE;

    //
    // Read the key that tells whether to disable netbios over ip
    //
    {
        HKEY hkeyRASIp;


        dwErr = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,  REGKEY_RAS_IP_PARAM_A, 0,
                KEY_READ, &hkeyRASIp);

        if(NO_ERROR == dwErr)
        {
            DWORD dwSize = sizeof(DWORD) , dwData = 0, dwType;

            dwErr = RegQueryValueExA(
                        hkeyRASIp,
                        "DisableNetbiosOverTcpip",
                        NULL, &dwType, (BYTE *) &dwData,
                        &dwSize);

            if(     (NO_ERROR == dwErr)
                &&  (dwType == REG_DWORD))
            {
                g_fDisableNetbiosOverTcpip = !!(dwData);
            }

            RegCloseKey(hkeyRASIp);
            dwErr = NO_ERROR;
        }
    }

    TraceHlp("DisableNetbt = %d", g_fDisableNetbiosOverTcpip);    
	
    // Keep a ref count in HelperUninitialize, and call HelperUninitialize
    // once for each time you call HelperInitialize.

    dwErr = HelperInitialize(&hInstance);

    if (NO_ERROR != dwErr)
    {
        // goto LDone; Don't do this. The CriticalSections are not available.
        return(dwErr);
    }

    EnterCriticalSection(&RasSrvrCriticalSection);

    if (RasSrvrRunning)
    {
        goto LDone;
    }

	//Set the control handler for the process here
	if ( !SetProcessShutdownParameters( 510 , SHUTDOWN_NORETRY ) )
	{
		TraceHlp("SetProcessShutdownParameters failed and returned 0x%x.  This is not a fatal error so continuing on with server start", GetLastError());
	}
	else
	{
		if ( !SetConsoleCtrlHandler( ShutdownHandlerRoutine, TRUE ) )
		{
			TraceHlp("SetConsoleCtrlHandler failed and returned 0x%x.  This is not a fatal error so continuing on with server start", GetLastError());
		}
	}
	
    dwErr = rasSrvrInitAdapterName();

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    dwErr = MprAdminMIBServerConnect(NULL, &RasSrvrHMIBServer);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("MprAdminMIBServerConnect failed and returned 0x%x", dwErr);
        goto LDone;
    }

    pfnMprAdminGetIpAddressForUser = pfnMprGetAddress;
    pfnMprAdminReleaseIpAddress = pfnMprReleaseAddress;

    DnsStatus = DnsDhcpSrvRegisterInit();

    if (DNSDHCP_SUCCESS != DnsStatus)
    {
        dwErr = DnsStatus;
        TraceHlp("DnsDhcpSrvRegisterInit failed and returned 0x%x", dwErr);
        goto LDone;
    }

    // HelperChangeNotification();

    dwErr = RasSrvrStart();

    if (NO_ERROR != dwErr)
    {
        TraceHlp("RasSrvrStart failed and returned 0x%x", dwErr);
        goto LDone;
    }

    RasSrvrRunning = TRUE;

LDone:

    if (NO_ERROR != dwErr)
    {
        RasSrvrUninitialize();
    }

    LeaveCriticalSection(&RasSrvrCriticalSection);

    return(dwErr);
}

/*

Returns:
    VOID

Notes:

*/

VOID
RasSrvrUninitialize(
    VOID
)
{
    AINODE*     pAiNode;
    DNS_STATUS  DnsStatus;
    DWORD       dwErr;

    TraceHlp("RasSrvrUninitialize");

    RasSrvrRunning = FALSE;

    /*

    Don't call RasSrvrStop when you have RasSrvrCriticalSection. It will call 
    RasDhcpUninitialize, which will call RasDhcpTimerUninitialize, which will 
    wait till all the timer work itemss are done. The timer work item could be 
    rasDhcpAllocateAddress or rasDhcpRenewLease, both of which can call 
    RasSrvrDhcpCallback, which tries to acquire RasSrvrCriticalSection.

    */
	SetConsoleCtrlHandler(ShutdownHandlerRoutine, FALSE);
    RasSrvrStop(FALSE /* fParametersChanged */);

    EnterCriticalSection(&RasSrvrCriticalSection);

    if (NULL != RasSrvrHMIBServer)
    {
        MprAdminMIBServerDisconnect(RasSrvrHMIBServer);
        RasSrvrHMIBServer = NULL;
    }

    pfnMprAdminGetIpAddressForUser = NULL;
    pfnMprAdminReleaseIpAddress = NULL;

    DnsStatus = DnsDhcpSrvRegisterTerm();

    if (DNSDHCP_SUCCESS != DnsStatus)
    {
        TraceHlp("DnsDhcpSrvRegisterTerm failed and returned 0x%x",
            DnsStatus);
    }

    if (NULL != PDisableDhcpInformServer)
    {
        PDisableDhcpInformServer();
    }

    g_fDisableNetbiosOverTcpip = FALSE;    

    LeaveCriticalSection(&RasSrvrCriticalSection);
}

/*

Returns:

Notes:

*/

DWORD
RasSrvrStart(
    VOID
)
{
    DWORD   dwErr;

    TraceHlp("RasSrvrStart");

    EnterCriticalSection(&RasSrvrCriticalSection);

    if (HelperRegVal.fUseDhcpAddressing)
    {
        dwErr = RasDhcpInitialize();
    }
    else
    {
        dwErr = RasStatInitialize();
    }

    LeaveCriticalSection(&RasSrvrCriticalSection);

    return(dwErr);
}

/*

Returns:
    VOID

Notes:

*/

VOID
RasSrvrStop(
    IN  BOOL    fParametersChanged
)
{
    AINODE*     pAiNode;
    CHAR        szIpAddress[MAXIPSTRLEN + 1];
    CHAR*       sz;
    DWORD       dwNumBytes;
    DWORD       dwErr;

    WANARP_MAP_SERVER_ADAPTER_INFO info;

    TraceHlp("RasSrvrStop");
    
    RasDhcpUninitialize();
    EnterCriticalSection(&RasSrvrCriticalSection);

    if (   fParametersChanged
        && (0 != RasSrvrNboServerIpAddress))
    {
        AbcdSzFromIpAddress(RasSrvrNboServerIpAddress, szIpAddress);
        sz = szIpAddress;

        LogEvent(EVENTLOG_WARNING_TYPE, ROUTERLOG_SRV_ADDR_CHANGED, 1,
            (CHAR**)&sz);
    }

    if (!fParametersChanged)
    {
        while (NULL != RasSrvrAcquiredIpAddresses)
        {
            RasSrvrReleaseAddress(
                RasSrvrAcquiredIpAddresses->nboIpAddr,
                RasSrvrAcquiredIpAddresses->wszUserName,
                RasSrvrAcquiredIpAddresses->wszPortName,
                TRUE);

            // Assert: the list decreases by one node in each iteration.
        }
    }

    RasStatUninitialize();
    RasStatSetRoutes(RasSrvrNboServerIpAddress, FALSE);

    RasTcpSetProxyArp(RasSrvrNboServerIpAddress, FALSE);

    rasSrvrSetIpAddressInRegistry(0, 0);

    dwErr = PDhcpNotifyConfigChange(NULL, g_rgwcAdapterName, TRUE,
                    0, 0, 0, IgnoreFlag);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("DhcpNotifyConfigChange failed and returned %d", dwErr);
    }

    if (RasSrvrAdapterMapped)
    {
        // Ask wanarp to unmap the adapter

        info.fMap = 0;

        if(!DeviceIoControl(HelperWanArpHandle,
                            IOCTL_WANARP_MAP_SERVER_ADAPTER,
                            &info,
                            sizeof(WANARP_MAP_SERVER_ADAPTER_INFO),
                            &info,
                            sizeof(WANARP_MAP_SERVER_ADAPTER_INFO),
                            &dwNumBytes,
                            NULL))
        {
            dwErr = GetLastError();
            TraceHlp("Error %d unmapping server adapter", dwErr);
        }

        TraceHlp("RasSrvrAdapterUnMapped");
        RasSrvrAdapterMapped = FALSE;
    }

    RasSrvrNboServerIpAddress = 0;
    RasSrvrNboServerSubnetMask = 0;

    LeaveCriticalSection(&RasSrvrCriticalSection);

    /*

    Don't call RasDhcpUninitialize when you have RasSrvrCriticalSection. It 
    will call RasDhcpTimerUninitialize, which will wait till all the timer work 
    itemss are done. The timer work item could be rasDhcpAllocateAddress or
    rasDhcpRenewLease, both of which can call RasSrvrDhcpCallback, which tries 
    to acquire RasSrvrCriticalSection.

    */

    //RasDhcpUninitialize();
}

/*

Returns:

Description:

*/

DWORD
RasSrvrAcquireAddress(
    IN  HPORT       hPort, 
    IN  IPADDR      nboIpAddressRequested, 
    OUT IPADDR*     pnboIpAddressAllocated, 
    IN  WCHAR*      wszUserName,
    IN  WCHAR*      wszPortName
)
{
    IPADDR      nboIpAddr;
    IPADDR      nboIpMask;
    IPADDR      nboIpAddrObtained   = 0;
    IPADDR      nboIpAddrFromDll    = 0;
    BOOL        fNotifyDll          = FALSE;
    BOOL        fEasyNet            = FALSE;
    WCHAR*      wszUserNameTemp     = NULL;
    WCHAR*      wszPortNameTemp     = NULL;
    AINODE*     pAiNode             = NULL;
    DWORD       dwErr               = NO_ERROR;

    TraceHlp("RasSrvrAcquireAddress(hPort: 0x%x, IP address: 0x%x, "
        "UserName: %ws, PortName: %ws)",
        hPort, nboIpAddressRequested, wszUserName, wszPortName);

    EnterCriticalSection(&RasSrvrCriticalSection);

    dwErr = rasSrvrGetAddressForServerAdapter();

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    if (nboIpAddressRequested == RasSrvrNboServerIpAddress)
    {
        // The server's address is being requested. Forget the request.
        nboIpAddressRequested = 0;
    }

    nboIpAddr = nboIpAddressRequested;

    dwErr = rasSrvrAcquireAddressEx(hPort, &nboIpAddr, &nboIpMask, &fEasyNet);

    if (   (NO_ERROR != dwErr)
        && (0 != nboIpAddr))
    {
        // We couldn't get the address we wanted. Let us get any other
        // address.
        nboIpAddr = 0;
        dwErr = rasSrvrAcquireAddressEx(hPort, &nboIpAddr, &nboIpMask,
                    &fEasyNet);
    }

    if (NO_ERROR == dwErr)
    {
        RTASSERT(0 != nboIpAddr);
        nboIpAddrObtained = nboIpAddr;
    }
    else
    {
        RTASSERT(0 == nboIpAddr);
        goto LDone;
    }

    if (NULL != pfnMprAdminGetIpAddressForUser)
    {
        nboIpAddrFromDll = nboIpAddrObtained;

        dwErr = pfnMprAdminGetIpAddressForUser(wszUserName, wszPortName,
                    &nboIpAddrFromDll, &fNotifyDll);

        if (NO_ERROR != dwErr)
        {
            TraceHlp("MprAdminGetIpAddressForUser(%ws, %ws, 0x%x) failed "
                "and returned %d",
                wszUserName, wszPortName, nboIpAddrFromDll, dwErr);
            goto LDone;
        }

        if (   (0 == nboIpAddrFromDll)
            || (RasSrvrNboServerIpAddress == nboIpAddrFromDll))
        {
            // We can't give the server's address.
            TraceHlp("3rd party DLL wants to hand out bad address 0x%x",
                nboIpAddrFromDll);
            dwErr = ERROR_NOT_FOUND;
            goto LDone;
        }

        if (nboIpAddrObtained != nboIpAddrFromDll)
        {
            TraceHlp("3rd party DLL wants to hand out address 0x%x",
                nboIpAddrFromDll);

            // We have to make sure that nboIpAddrFromDll is available.

            // The DLL changed what we had got from Dhcp or Static. Release the
            // old address.

            if (HelperRegVal.fUseDhcpAddressing)
            {
                RasDhcpReleaseAddress(nboIpAddrObtained);
            }
            else
            {
                RasStatReleaseAddress(nboIpAddrObtained);
            }

            nboIpAddrObtained = 0;
            fEasyNet = FALSE;

            nboIpAddr = nboIpAddrFromDll;

            dwErr = rasSrvrAcquireAddressEx(hPort, &nboIpAddr, &nboIpMask,
                        &fEasyNet);

            if (NO_ERROR != dwErr)
            {
                goto LDone;
            }

            nboIpAddrObtained = nboIpAddr;
        }
    }

    wszUserNameTemp = _wcsdup(wszUserName);

    if (NULL == wszUserNameTemp)
    {
        dwErr = ERROR_OUTOFMEMORY;
        TraceHlp("_strdup failed and returned %d", dwErr);
        goto LDone;
    }

    wszPortNameTemp = _wcsdup(wszPortName);

    if (NULL == wszPortNameTemp)
    {
        dwErr = ERROR_OUTOFMEMORY;
        TraceHlp("_strdup failed and returned %d", dwErr);
        goto LDone;
    }

    pAiNode = LocalAlloc(LPTR, sizeof(AINODE));

    if (NULL == pAiNode)
    {
        dwErr = GetLastError();
        TraceHlp("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    pAiNode->hPort = hPort;
    pAiNode->fFlags = fNotifyDll ? AINODE_FLAG_NOTIFY_DLL : 0;
    pAiNode->fFlags |= fEasyNet ? AINODE_FLAG_EASYNET : 0;
    pAiNode->wszUserName = wszUserNameTemp;
    pAiNode->wszPortName = wszPortNameTemp;
    pAiNode->pNext = RasSrvrAcquiredIpAddresses;
    RasSrvrAcquiredIpAddresses = pAiNode;

    pAiNode->nboIpAddr = *pnboIpAddressAllocated = nboIpAddrObtained;

LDone:

    if (NO_ERROR != dwErr)
    {
        if (fNotifyDll)
        {
            pfnMprAdminReleaseIpAddress(wszUserName, wszPortName,
                &nboIpAddrFromDll);
        }

        if (0 != nboIpAddrObtained)
        {
            if (HelperRegVal.fUseDhcpAddressing)
            {
                RasDhcpReleaseAddress(nboIpAddrObtained);
            }
            else
            {
                RasStatReleaseAddress(nboIpAddrObtained);
            }
        }

        free(wszUserNameTemp);
        free(wszPortNameTemp);
    }

    LeaveCriticalSection(&RasSrvrCriticalSection);

    return(dwErr);
}

/*

Returns:

Description:

*/

VOID
RasSrvrReleaseAddress(
    IN  IPADDR      nboIpAddress, 
    IN  WCHAR*      wszUserName,
    IN  WCHAR*      wszPortName,
    IN  BOOL        fDeregister
)
{
    DNS_STATUS              DnsStatus;
    REGISTER_HOST_ENTRY     HostAddr;
    AINODE*                 pAiNode     = NULL;
    DWORD                   dwErr;

    TraceHlp("RasSrvrReleaseAddress(IP address: 0x%x, "
        "UserName: %ws, PortName: %ws)",
        nboIpAddress, wszUserName, wszPortName);

    EnterCriticalSection(&RasSrvrCriticalSection);

    if (fDeregister)
    {
        HostAddr.dwOptions = REGISTER_HOST_PTR;
        HostAddr.Addr.ipAddr = nboIpAddress;

        DnsStatus = DnsDhcpSrvRegisterHostName_W(
                        HostAddr, NULL, 600,
                        DYNDNS_DELETE_ENTRY | DYNDNS_REG_FORWARD,
                        NULL, NULL, NULL, 0);

        if (DNSDHCP_SUCCESS != DnsStatus)
        {
            TraceHlp("DnsDhcpSrvRegisterHostName_A(0x%x) failed: 0x%x",
                nboIpAddress, DnsStatus);
        }
    }

    pAiNode = rasSrvrFindAiNode(nboIpAddress, TRUE /* fRemoveFromList */);

    if (NULL == pAiNode)
    {
        TraceHlp("Couldn't find address 0x%x in Acquired Ip Addresses list",
            nboIpAddress);
        goto LDone;
    }

    if (HelperRegVal.fUseDhcpAddressing)
    {
        RasDhcpReleaseAddress(nboIpAddress);
    }
    else
    {
        RasStatReleaseAddress(nboIpAddress);
    }

    if (pAiNode->fFlags & AINODE_FLAG_NOTIFY_DLL)
    {
        pfnMprAdminReleaseIpAddress(wszUserName, wszPortName, &nboIpAddress);
    }

    if (pAiNode->fFlags & AINODE_FLAG_ACTIVATED)
    {
        if (!(pAiNode->fFlags & AINODE_FLAG_EASYNET))
        {
            RasTcpSetProxyArp(nboIpAddress, FALSE);
        }

        dwErr = rasSrvrGetAddressForServerAdapter();

        if (NO_ERROR != dwErr)
        {
            TraceHlp("Couldn't get address for server adapter");
            goto LDone;
        }

        RasTcpSetRoute(nboIpAddress,
                       nboIpAddress,
                       HOST_MASK,
                       RasSrvrNboServerIpAddress,
                       FALSE,
                       1,
                       TRUE);
    }

LDone:

    LeaveCriticalSection(&RasSrvrCriticalSection);
    rasSrvrFreeAiNode(pAiNode);
}

/*

Returns:

Description:
    Look up the DNS server, WINS server, and "this server" addresses.

*/

DWORD
RasSrvrQueryServerAddresses(
    IN OUT  IPINFO* pIpInfo
)
{
    DWORD   dwNumBytes;
    IPADDR  nboWins1        = 0;
    IPADDR  nboWins2        = 0;
    IPADDR  nboDns1         = 0;
    IPADDR  nboDns2         = 0;
    DWORD   dwErr           = NO_ERROR;

    TraceHlp("RasSrvrQueryServerAddresses");

    EnterCriticalSection(&RasSrvrCriticalSection);

    dwErr = rasSrvrGetAddressForServerAdapter();

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    // Ignore errors; its OK not to be able to give DNS or WINS server
    // addresses

    GetPreferredAdapterInfo(NULL, &nboDns1, &nboDns2, &nboWins1, 
                &nboWins2, NULL);

    if (TRUE == HelperRegVal.fSuppressWINSNameServers)
    {
        nboWins1 = 0;
        nboWins2 = 0;
    }
    else if (0 != HelperRegVal.nboWINSNameServer1)
    {
        nboWins1 = HelperRegVal.nboWINSNameServer1;
        nboWins2 = HelperRegVal.nboWINSNameServer2;
    }

    if (TRUE == HelperRegVal.fSuppressDNSNameServers)
    {
        nboDns1 = 0;
        nboDns2 = 0;
    }
    else if (0 != HelperRegVal.nboDNSNameServer1)
    {
        nboDns1 = HelperRegVal.nboDNSNameServer1;
        nboDns2 = HelperRegVal.nboDNSNameServer2;
    }

    pIpInfo->nboDNSAddress        = nboDns1;
    pIpInfo->nboDNSAddressBackup  = nboDns2;
    pIpInfo->nboWINSAddress       = nboWins1;
    pIpInfo->nboWINSAddressBackup = nboWins2;
    pIpInfo->nboServerIpAddress   = RasSrvrNboServerIpAddress;
    pIpInfo->nboServerSubnetMask  = RasSrvrNboServerSubnetMask;

LDone:

    LeaveCriticalSection(&RasSrvrCriticalSection);

    return(dwErr);
}

/*

Returns:

Description:
    Does two things - RasTcpSetRoute and RasTcpSetProxyArp.

*/

DWORD
RasSrvrActivateIp(
    IN  IPADDR  nboIpAddress,
    IN  DWORD   dwUsage
)
{
    AINODE*     pAiNode;
    DWORD       dwErr       = NO_ERROR;

    TraceHlp("RasSrvrActivateIp(IpAddr = 0x%x, dwUsage = %d)",
        nboIpAddress, dwUsage);

    EnterCriticalSection(&RasSrvrCriticalSection);

    pAiNode = rasSrvrFindAiNode(nboIpAddress, FALSE /* fRemoveFromList */);

    if (NULL == pAiNode)
    {
        TraceHlp("Couldn't find address 0x%x in Acquired Ip Addresses list",
            nboIpAddress);
        dwErr = ERROR_IP_CONFIGURATION;
        goto LDone;
    }

    pAiNode->fFlags |= AINODE_FLAG_ACTIVATED;

    RasTcpSetProxyArp(nboIpAddress, TRUE);

    if (dwUsage != DU_ROUTER)
    {
        // Add a route to the route table. Router connections get 
        // added by router manager

        dwErr = rasSrvrGetAddressForServerAdapter();

        if (NO_ERROR != dwErr)
        {
            // Don't return an error, because we have done RasTcpSetProxyArp.
            dwErr = NO_ERROR;
            TraceHlp("Couldn't get address for server adapter");
            goto LDone;
        }

        RasTcpSetRoute(nboIpAddress,
                       nboIpAddress,
                       HOST_MASK,
                       RasSrvrNboServerIpAddress,
                       TRUE,
                       1,
                       TRUE);
    }

LDone:

    LeaveCriticalSection(&RasSrvrCriticalSection);

    return(dwErr);
}

/*

Returns:
    VOID

Description:
    Called by dhcp address code when the lease for a given address expires.
    nboIpAddr = 0 indicates the server's IP address.

*/

VOID
RasSrvrDhcpCallback(
    IN  IPADDR  nboIpAddr
)
{
    AINODE*     pAiNode                         = NULL;
    CHAR        szIpAddress[MAXIPSTRLEN + 1];
    CHAR*       sz;
    DWORD       dwErr                           = NO_ERROR;

    TraceHlp("RasSrvrDhcpCallback(0x%x)", nboIpAddr);

    EnterCriticalSection(&RasSrvrCriticalSection);

    if (   (0 == nboIpAddr)
        && (0 == RasSrvrNboServerIpAddress))
    {
        // The server hasn't got an IP address yet. Its lease hasn't really
        // expired. We are just simulating it.
        goto LDone;
    }

    if (   (0 == nboIpAddr)
        || (nboIpAddr == RasSrvrNboServerIpAddress))
    {
        TraceHlp("******** SERVER ADDRESS (0x%x) LEASE EXPIRED ********",
              RasSrvrNboServerIpAddress);

        AbcdSzFromIpAddress(RasSrvrNboServerIpAddress, szIpAddress);
        sz = szIpAddress;

        // Log that the server adapter address lease was lost

        LogEvent(EVENTLOG_WARNING_TYPE, ROUTERLOG_SRV_ADDR_CHANGED, 1,
            (CHAR**)&sz);

        // Unroute all the connected clients

        while (NULL != RasSrvrAcquiredIpAddresses)
        {
            RasSrvrReleaseAddress(
                RasSrvrAcquiredIpAddresses->nboIpAddr,
                RasSrvrAcquiredIpAddresses->wszUserName,
                RasSrvrAcquiredIpAddresses->wszPortName,
                TRUE);

            // Assert: the list decreases by one node in each iteration.
        }

        RasTcpSetProxyArp(RasSrvrNboServerIpAddress, FALSE);

        rasSrvrSetIpAddressInRegistry(0, 0);

        dwErr = PDhcpNotifyConfigChange(NULL, g_rgwcAdapterName, TRUE,
                        0, 0, 0, IgnoreFlag);

        if (NO_ERROR != dwErr)
        {
            TraceHlp("DhcpNotifyConfigChange failed and returned %d", dwErr);
        }

        RasSrvrNboServerIpAddress = 0;
        RasSrvrNboServerSubnetMask = 0;
    }
    else
    {
        pAiNode = rasSrvrFindAiNode(nboIpAddr, TRUE /* fRemoveFromList */);

        if (NULL != pAiNode)
        {
            TraceHlp("******** CLIENT ADDRESS (0x%x) LEASE EXPIRED ********",
                  nboIpAddr);

            AbcdSzFromIpAddress(nboIpAddr, szIpAddress);
            sz = szIpAddress;

            // Log that the client's address lease could not be renewed

            LogEvent(EVENTLOG_WARNING_TYPE, ROUTERLOG_CLIENT_ADDR_LEASE_LOST, 1,
                (CHAR**)&sz);

            RasSrvrReleaseAddress(nboIpAddr, pAiNode->wszUserName, 
                pAiNode->wszPortName, TRUE);
        }
    }

LDone:

    LeaveCriticalSection(&RasSrvrCriticalSection);
    rasSrvrFreeAiNode(pAiNode);
}

/*

Returns:
    VOID

Description:

*/

VOID
RasSrvrEnableRouter(
    BOOL    fEnable
)
{
    DWORD   dwErr;

    DEFINE_MIB_BUFFER(pSetInfo, MIB_IPSTATS, pSetStats);

    TraceHlp("RasSrvrEnableRouter(%d)", fEnable);

    EnterCriticalSection(&RasSrvrCriticalSection);

    pSetInfo->dwId          = IP_STATS;
    pSetStats->dwForwarding = fEnable? MIB_IP_FORWARDING: MIB_IP_NOT_FORWARDING;
    pSetStats->dwDefaultTTL = MIB_USE_CURRENT_TTL;

    dwErr = MprAdminMIBEntrySet(
        RasSrvrHMIBServer,
        PID_IP,
        IPRTRMGR_PID,
        (VOID*)pSetInfo,
        MIB_INFO_SIZE(MIB_IPSTATS));

    if (NO_ERROR != dwErr)
    {
        TraceHlp("MprAdminMIBEntrySet failed with error %x", dwErr);
    }

    LeaveCriticalSection(&RasSrvrCriticalSection);
}

/*

Returns:
    VOID

Description:

*/

VOID
RasSrvrAdapterUnmapped(
    VOID
)
{
    if (HelperInitialized)
    {
        EnterCriticalSection(&RasSrvrCriticalSection);

        RasSrvrAdapterMapped = FALSE;
        TraceHlp("RasSrvrAdapterUnMapped");

        LeaveCriticalSection(&RasSrvrCriticalSection);
    }
}

/*

Returns:
    VOID

Description:

*/

DWORD
rasSrvrInitAdapterName(
    VOID
)
{
    DWORD                       dwNumBytes;
    WANARP_ADD_INTERFACE_INFO   info;
    DWORD                       dwErr       = NO_ERROR;

    info.dwUserIfIndex    = WANARP_INVALID_IFINDEX;
    info.bCallinInterface = TRUE;

    if (!DeviceIoControl(HelperWanArpHandle,
                            IOCTL_WANARP_ADD_INTERFACE,
                            &info,
                            sizeof(WANARP_ADD_INTERFACE_INFO),
                            &info,
                            sizeof(WANARP_ADD_INTERFACE_INFO),
                            &dwNumBytes,
                            NULL))
    {
        dwErr = GetLastError();
        TraceHlp("rasSrvrInitAdapterName: Error %d getting server name",
                 dwErr);
        goto LDone;
    }

    wcsncpy(g_rgwcAdapterName, info.rgwcDeviceName, WANARP_MAX_DEVICE_NAME_LEN);

    // The RAS server adapter must not be registered with DNS. (These API's are 
    // called in IpcpProjectionNotification also.)

    DnsDisableAdapterDomainNameRegistration(g_rgwcAdapterName);
    DnsDisableDynamicRegistration(g_rgwcAdapterName);

LDone:

    return(dwErr);
}

/*

Returns:

Description:

*/

AINODE*
rasSrvrFindAiNode(
    IN  IPADDR  nboIpAddr,
    IN  BOOL    fRemoveFromList
)
{
    AINODE*     pNode;
    AINODE*     pNodePrev;

    EnterCriticalSection(&RasSrvrCriticalSection);

    for (pNode = RasSrvrAcquiredIpAddresses, pNodePrev = pNode;
         NULL != pNode;
         pNodePrev = pNode, pNode = pNode->pNext)
    {
        if (pNode->nboIpAddr == nboIpAddr)
        {
            break;
        }
    }

    if (!fRemoveFromList)
    {
        goto LDone;
    }

    if (NULL == pNode)
    {
        goto LDone;
    }

    if (pNode == pNodePrev)
    {
        RTASSERT(pNode == RasSrvrAcquiredIpAddresses);
        RasSrvrAcquiredIpAddresses = pNode->pNext;
        goto LDone;
    }

    pNodePrev->pNext = pNode->pNext;

LDone:

    LeaveCriticalSection(&RasSrvrCriticalSection);

    return(pNode);
}

/*

Returns:

Description:

*/

VOID
rasSrvrFreeAiNode(
    IN  AINODE* pNode
)
{
    if (NULL != pNode)
    {
        free(pNode->wszUserName);
        free(pNode->wszPortName);
        LocalFree(pNode);
    }
}

/*

Returns:

Description:

*/

DWORD
rasSrvrSetIpAddressInRegistry(
    IN  IPADDR  nboIpAddr,
    IN  IPADDR  nboIpMask
)
{
    TCPIP_INFO*     pTcpipInfo  = NULL;
    DWORD           dwErr       = NO_ERROR;

    dwErr = LoadTcpipInfo(&pTcpipInfo, g_rgwcAdapterName,
                TRUE /* fAdapterOnly */);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("LoadTcpipInfo(%ws) failed and returned %d",
              g_rgwcAdapterName, dwErr);

        goto LDone;
    }

    AbcdWszFromIpAddress(nboIpAddr, pTcpipInfo->wszIPAddress);
    AbcdWszFromIpAddress(nboIpMask, pTcpipInfo->wszSubnetMask);

    if(g_fDisableNetbiosOverTcpip)
    {
        TraceHlp("rasSrvrSetIpAddressInRegistry: Netbios disabled");
        pTcpipInfo->fDisableNetBIOSoverTcpip = TRUE;
    }

    pTcpipInfo->fChanged = TRUE;

    dwErr = SaveTcpipInfo(pTcpipInfo);

    if (dwErr != NO_ERROR)
    {
        TraceHlp("SaveTcpipInfo(%ws) failed and returned %d",
              g_rgwcAdapterName, dwErr);

        goto LDone;
    }

LDone:

    FreeTcpipInfo(&pTcpipInfo);
    return(dwErr);
}

/*

Returns:

Notes:

*/

DWORD
rasSrvrAcquireAddressEx(
    IN      HPORT   hPort,
    IN OUT  IPADDR* pnboIpAddr,
    IN OUT  IPADDR* pnboIpMask,
    OUT     BOOL*   pfEasyNet
)
{
    BOOL    fExitWhile;
    BOOL    fAnyAddress;
    AINODE* pAiNode;
    DWORD   dwErr       = NO_ERROR;

    EnterCriticalSection(&RasSrvrCriticalSection);

    if (NULL != pfEasyNet)
    {
        *pfEasyNet = FALSE;
    }

    fAnyAddress = (0 == *pnboIpAddr);
    fExitWhile = FALSE;

    while (!fExitWhile)
    {
        dwErr = NO_ERROR;

        if (fAnyAddress)
        {
            if (HelperRegVal.fUseDhcpAddressing)
            {
                dwErr = RasDhcpAcquireAddress(hPort, pnboIpAddr, pnboIpMask,
                            pfEasyNet);
            }
            else
            {
                dwErr = RasStatAcquireAddress(hPort, pnboIpAddr, pnboIpMask);
            }
        }

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }

        for (pAiNode = RasSrvrAcquiredIpAddresses; NULL != pAiNode;
             pAiNode = pAiNode->pNext)
        {
            if (pAiNode->nboIpAddr == *pnboIpAddr)
            {
                // This address is in use

                if (fAnyAddress)
                {
                    // Ask for another address
                    goto LWhileEnd;
                }
                else
                {
                    TraceHlp("Address 0x%x is already in use", *pnboIpAddr);
                    dwErr = ERROR_PPP_REQUIRED_ADDRESS_REJECTED;
                    goto LDone;
                }
            }
        }

        dwErr = NO_ERROR;
        fExitWhile = TRUE;

LWhileEnd:
        ;
    }

LDone:

    LeaveCriticalSection(&RasSrvrCriticalSection);

    if (   fAnyAddress
        && (NO_ERROR != dwErr))
    {
        LogEvent(EVENTLOG_WARNING_TYPE, ROUTERLOG_NO_IP_ADDRESS, 0, NULL);
    }

    return(dwErr);
}

/*

Returns:

Description:

*/

DWORD
rasSrvrGetAddressForServerAdapter(
    VOID
)
{
    IPADDR      nboIpAddr                       = 0;
    IPADDR      nboIpMask;
    CHAR        szIpAddress[MAXIPSTRLEN + 1];
    CHAR*       sz;
    BOOL        fAddrAcquired                   = FALSE;
    BOOL        fAdapterMapped                  = FALSE;
    DWORD       dwNumBytes;
    DWORD       dwErrTemp;
    DWORD       dwErr                           = NO_ERROR;

    WANARP_MAP_SERVER_ADAPTER_INFO info;

    TraceHlp("rasSrvrGetAddressForServerAdapter");

    EnterCriticalSection(&RasSrvrCriticalSection);

    if (!RasSrvrAdapterMapped)
    {
        // First time - ask wanarp to map the adapter

        info.fMap           = 1;
        info.dwAdapterIndex = (DWORD)-1;

        if(!DeviceIoControl(HelperWanArpHandle,
                            IOCTL_WANARP_MAP_SERVER_ADAPTER,
                            &info,
                            sizeof(WANARP_MAP_SERVER_ADAPTER_INFO),
                            &info,
                            sizeof(WANARP_MAP_SERVER_ADAPTER_INFO),
                            &dwNumBytes,
                            NULL))
        {
            dwErr = GetLastError();
            TraceHlp("Error %d mapping server adapter", dwErr);
            goto LDone;
        }

        TraceHlp("RasSrvrAdapterMapped");
        RasSrvrAdapterMapped = TRUE;
        fAdapterMapped = TRUE;
    }

    if (0 != RasSrvrNboServerIpAddress)
    {
        if (!fAdapterMapped)
        {
            goto LDone;
        }
    }
    else
    {
        dwErr = rasSrvrAcquireAddressEx((HPORT) ULongToPtr(((ULONG) SERVER_HPORT)), 
                                        &nboIpAddr, &nboIpMask, NULL);

        if (NO_ERROR != dwErr)
        {
            goto LDone;
        }

        fAddrAcquired = TRUE;

        RasSrvrNboServerIpAddress = nboIpAddr;
        RasSrvrNboServerSubnetMask = HOST_MASK;
    }

    dwErr = rasSrvrSetIpAddressInRegistry(
                RasSrvrNboServerIpAddress, RasSrvrNboServerSubnetMask);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    dwErr = PDhcpNotifyConfigChange(NULL, g_rgwcAdapterName, TRUE, 0, 
                RasSrvrNboServerIpAddress,
                RasSrvrNboServerSubnetMask,
                IgnoreFlag);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("DhcpNotifyConfigChange(%ws) failed and returned %d",
            g_rgwcAdapterName, dwErr);
        goto LDone;
    }

    /*

    It looks like the default subnet route no longer gets added.

    // Now delete the default subnet route added as a result of setting the
    // adapter's IP address and subnet mask

    RasTcpSetRoute(RasSrvrNboServerIpAddress & RasSrvrNboServerSubnetMask,
                   RasSrvrNboServerIpAddress,
                   RasSrvrNboServerSubnetMask, 
                   RasSrvrNboServerIpAddress,
                   FALSE, 
                   1,
                   TRUE);
    */

    RasTcpSetProxyArp(RasSrvrNboServerIpAddress, TRUE);

    if (!HelperRegVal.fUseDhcpAddressing)
    {
        RasStatSetRoutes(RasSrvrNboServerIpAddress, TRUE);
    }

    AbcdSzFromIpAddress(RasSrvrNboServerIpAddress, szIpAddress);

    sz = szIpAddress;

    LogEvent(EVENTLOG_INFORMATION_TYPE, ROUTERLOG_SRV_ADDR_ACQUIRED, 1,
        (CHAR**)&sz);

    TraceHlp("Acquired IP address 0x%x(%s) and subnet mask 0x%x for the server",
        RasSrvrNboServerIpAddress, szIpAddress, RasSrvrNboServerSubnetMask);

LDone:

    if (NO_ERROR != dwErr)
    {
        // Some cleanup is required here. We must release the 
        // address if RasSrvrNboServerIpAddress != 0 and get rid of the 
        // variable fAddrAcquired. 

        if (fAddrAcquired)
        {
            if (HelperRegVal.fUseDhcpAddressing)
            {
                RasDhcpReleaseAddress(nboIpAddr);
            }
            else
            {
                RasStatReleaseAddress(nboIpAddr);
            }

            RasTcpSetProxyArp(RasSrvrNboServerIpAddress, FALSE);
        }

        RasSrvrNboServerIpAddress = RasSrvrNboServerSubnetMask = 0;

        rasSrvrSetIpAddressInRegistry(0, 0);

        dwErrTemp = PDhcpNotifyConfigChange(NULL, g_rgwcAdapterName, TRUE,
                        0, 0, 0, IgnoreFlag);

        if (NO_ERROR != dwErrTemp)
        {
            TraceHlp("DhcpNotifyConfigChange failed and returned %d", 
                dwErrTemp);
        }
    }

    LeaveCriticalSection(&RasSrvrCriticalSection);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rasiphlp_.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _RASIPHLP__H_
#define _RASIPHLP__H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rtutils.h>
#include <dhcpcapi.h>
#include <iprtrmib.h>
#include <ntddip.h>
#include <iptypes.h>
#include "rasiphlp.h"

#define REGKEY_TCPIP_NDISWANIP_W    L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters\\NdisWanIp"
#define REGKEY_TCPIP_PARAM_W        L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
#define REGKEY_NETBT_PARAM_W        L"System\\CurrentControlSet\\Services\\NetBT\\Parameters"
#define REGKEY_INTERFACES_W         L"Interfaces"
#define REGVAL_ADAPTERGUID_W        L"NetworkAdapterGUID"
#define REGVAL_NAMESERVERLIST_W     L"NameServerList"
#define REGVAL_NETBIOSOPTIONS_W     L"NetbiosOptions"
#define REGVAL_DHCPIPADDRESS_W      L"DhcpIPAddress"
#define REGVAL_DHCPSUBNETMASK_W     L"DhcpSubnetMask"
#define REGVAL_DOMAIN_W             L"Domain"
#define REGVAL_NAMESERVER_W         L"NameServer"
#define REGVAL_IPCONFIG_W           L"IpConfig"
#define WCH_TCPIP_                  L"Tcpip_"
#define WCH_TCPIP_PARAM_INT_W       L"Tcpip\\Parameters\\Interfaces\\"

#define REGKEY_RAS_IP_PARAM_A       "System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Ip"
#define REGKEY_ADDR_POOL_A          "System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Ip\\StaticAddressPool"
#define REGKEY_BUILTIN_PARAM_A      "System\\CurrentControlSet\\Services\\Rasman\\PPP\\ControlProtocols\\BuiltIn"
#define REGVAL_FROM_A               "From"
#define REGVAL_TO_A                 "To"
#define REGVAL_IPADDRESS_A          "IpAddress"
#define REGVAL_IPMASK_A             "IpMask"
#define REGVAL_USEDHCPADDRESSING_A  "UseDhcpAddressing"
#define REGVAL_SUPPRESSWINS_A       "SuppressWINSNameServers"
#define REGVAL_SUPPRESSDNS_A        "SuppressDNSNameServers"
#define REGVAL_WINSSERVER_A         "WINSNameServer"
#define REGVAL_WINSSERVERBACKUP_A   "WINSNameServerBackup"
#define REGVAL_DNSSERVERS_A         "DNSNameServers"
#define REGVAL_CHUNK_SIZE_A         "InitialAddressPoolSize"
#define REGVAL_ALLOW_NETWORK_ACCESS_A   "AllowNetworkAccess"

#define REGVAL_DISABLE_NETBT        2

#define HOST_MASK                   0xffffffff
#define ALL_NETWORKS_ROUTE          0x00000000
#define INVALID_INDEX               0xffffffff

#define CLASSA_HBO_ADDR(a)          (((a) & 0x80000000) == 0)
#define CLASSB_HBO_ADDR(a)          (((a) & 0xc0000000) == 0x80000000)
#define CLASSC_HBO_ADDR(a)          (((a) & 0xe0000000) == 0xc0000000)
#define LOOPBACK_HBO_ADDR(a)        (((a) & 0xFF000000) == 0x7F000000)
#define INVALID_HBO_CLASS(x)        (x >= 0xE0000000)

#define CLASSA_HBO_ADDR_MASK        0xff000000
#define CLASSB_HBO_ADDR_MASK        0xffff0000
#define CLASSC_HBO_ADDR_MASK        0xffffff00

#define CLASSA_NBO_ADDR(a)          (((*((uchar *)&(a))) & 0x80) == 0)
#define CLASSB_NBO_ADDR(a)          (((*((uchar *)&(a))) & 0xc0) == 0x80)
#define CLASSC_NBO_ADDR(a)          (((*((uchar *)&(a))) & 0xe0) == 0xc0)

typedef struct _ADDR_POOL
{
    struct _ADDR_POOL*  pNext;          // Next pool

    IPADDR              hboFirstIpAddr; // First address in the pool
    IPADDR              hboLastIpAddr;  // Last address in the pool
    IPADDR              hboMask;

    IPADDR              hboNextIpAddr;  // Next address to use from the pool

} ADDR_POOL;

typedef struct _REGISTRY_VALUES
{
    BOOL        fSuppressWINSNameServers;
    BOOL        fSuppressDNSNameServers;
    DWORD       dwChunkSize;
    BOOL        fUseDhcpAddressing;
    IPADDR      nboWINSNameServer1;
    IPADDR      nboWINSNameServer2;
    IPADDR      nboDNSNameServer1;
    IPADDR      nboDNSNameServer2;
    BOOL        fEnableRoute;
    BOOL        fNICChosen;
    ADDR_POOL*  pAddrPool;
    GUID        guidChosenNIC;

} REGVAL;

extern  REGVAL  HelperRegVal;

typedef
DWORD
(APIENTRY *DHCPNOTIFYCONFIGCHANGE)(
    LPWSTR ServerName,
    LPWSTR AdapterName,
    BOOL IsNewIpAddress,
    DWORD IpIndex,
    DWORD IpAddress,
    DWORD SubnetMask,
    SERVICE_ENABLE DhcpServiceEnabled
);

extern  DHCPNOTIFYCONFIGCHANGE  PDhcpNotifyConfigChange;

typedef
DWORD
(*DHCPLEASEIPADDRESS)(
    DWORD AdapterIpAddress,
    LPDHCP_CLIENT_UID ClientUID,
    DWORD DesiredIpAddress,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_LEASE_INFO *LeaseInfo,
    LPDHCP_OPTION_INFO *OptionInfo
);

extern  DHCPLEASEIPADDRESS  PDhcpLeaseIpAddress;

typedef
DWORD
(*DHCPRENEWIPADDRESSLEASE)(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo,
    LPDHCP_OPTION_LIST OptionList,
    LPDHCP_OPTION_INFO *OptionInfo
);

extern  DHCPRENEWIPADDRESSLEASE PDhcpRenewIpAddressLease;

typedef
DWORD
(*DHCPRELEASEIPADDRESSLEASE)(
    DWORD AdapterIpAddress,
    LPDHCP_LEASE_INFO ClientLeaseInfo
);

extern  DHCPRELEASEIPADDRESSLEASE   PDhcpReleaseIpAddressLease;

typedef
DWORD
(*ALLOCATEANDGETIPADDRTABLEFROMSTACK)(
    OUT MIB_IPADDRTABLE   **ppIpAddrTable,
    IN  BOOL              bOrder,
    IN  HANDLE            hHeap,
    IN  DWORD             dwFlags
);

extern  ALLOCATEANDGETIPADDRTABLEFROMSTACK  PAllocateAndGetIpAddrTableFromStack;

typedef
DWORD
(*SETPROXYARPENTRYTOSTACK)(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwAdapterIndex,
    IN  BOOL    bAddEntry,
    IN  BOOL    bForceUpdate
);

extern  SETPROXYARPENTRYTOSTACK     PSetProxyArpEntryToStack;

typedef
DWORD
(*SETIPFORWARDENTRYTOSTACK)(
    IN PMIB_IPFORWARDROW pForwardRow
);

extern  SETIPFORWARDENTRYTOSTACK    PSetIpForwardEntryToStack;

typedef
DWORD
(*SETIPFORWARDENTRY)(
    IN PMIB_IPFORWARDROW pForwardRow
);

extern  SETIPFORWARDENTRY   PSetIpForwardEntry;

typedef
DWORD
(*DELETEIPFORWARDENTRY)(
    IN PMIB_IPFORWARDROW pForwardRow
);

extern  DELETEIPFORWARDENTRY    PDeleteIpForwardEntry;

typedef
DWORD
(*NHPALLOCATEANDGETINTERFACEINFOFROMSTACK)(
    OUT IP_INTERFACE_NAME_INFO  **ppTable,
    OUT PDWORD                  pdwCount,
    IN  BOOL                    bOrder,
    IN  HANDLE                  hHeap,
    IN  DWORD                   dwFlags
);

extern  NHPALLOCATEANDGETINTERFACEINFOFROMSTACK PNhpAllocateAndGetInterfaceInfoFromStack;

typedef
DWORD
(*ALLOCATEANDGETIPFORWARDTABLEFROMSTACK)(
    OUT MIB_IPFORWARDTABLE  **ppForwardTable,
    IN  BOOL                bOrder,
    IN  HANDLE              hHeap,
    IN  DWORD               dwFlags
);

extern  ALLOCATEANDGETIPFORWARDTABLEFROMSTACK   PAllocateAndGetIpForwardTableFromStack;

typedef
DWORD
(*GETADAPTERSINFO)(
    PIP_ADAPTER_INFO    pAdapterInfo,
    PULONG              pOutBufLen
);

extern  GETADAPTERSINFO     PGetAdaptersInfo;

typedef
DWORD
(*GETPERADAPTERINFO)(
    ULONG                   IfIndex,
    PIP_PER_ADAPTER_INFO    pPerAdapterInfo,
    PULONG                  pOutBufLen
);

extern  GETPERADAPTERINFO   PGetPerAdapterInfo;

typedef
VOID
(APIENTRY *ENABLEDHCPINFORMSERVER)(
    IN  DWORD   DhcpInformServer
);

extern  ENABLEDHCPINFORMSERVER      PEnableDhcpInformServer;

typedef
VOID
(APIENTRY *DISABLEDHCPINFORMSERVER)(
    VOID
);

extern  DISABLEDHCPINFORMSERVER      PDisableDhcpInformServer;

#endif // #ifndef _RASIPHLP__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rasstat.c ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

*/

#include "rasstat_.h"

/*

Returns:

Notes:

*/

DWORD
RasStatInitialize(
    VOID
)
{
    TraceHlp("RasStatInitialize");

    EnterCriticalSection(&RasStatCriticalSection);

    RasStatAllocPool    = NULL;
    RasStatFreePool     = NULL;
    RasStatCurrentPool  = HelperRegVal.pAddrPool;

    LeaveCriticalSection(&RasStatCriticalSection);

    return(NO_ERROR);
}

/*

Returns:
    VOID

Notes:

*/

VOID
RasStatUninitialize(
    VOID
)
{
    ADDR_POOL*  pAddrPool;

    TraceHlp("RasStatUninitialize");

    EnterCriticalSection(&RasStatCriticalSection);

    rasStatDeleteLists();
    RasStatCurrentPool = HelperRegVal.pAddrPool;

    pAddrPool = HelperRegVal.pAddrPool;
    while (pAddrPool != NULL)
    {
        pAddrPool->hboNextIpAddr = pAddrPool->hboFirstIpAddr;
        pAddrPool = pAddrPool->pNext;
    }

    LeaveCriticalSection(&RasStatCriticalSection);
}

/*

Returns:
    VOID

Notes:

*/

VOID
RasStatSetRoutes(
    IN  IPADDR  nboServerIpAddress,
    IN  BOOL    fSet
)
{
    ADDR_POOL*  pAddrPool;
    IPADDR      nboAddress;
    IPADDR      nboMask;

    TraceHlp("RasStatSetRoutes");
    
    pAddrPool = HelperRegVal.pAddrPool;
    while (pAddrPool != NULL)
    {
        nboAddress = htonl(pAddrPool->hboFirstIpAddr & pAddrPool->hboMask);
        nboMask = htonl(pAddrPool->hboMask);

        RasTcpSetRoute(
            nboAddress,
            nboServerIpAddress,
            nboMask,
            nboServerIpAddress,
            fSet,
            1,
            FALSE);

        pAddrPool = pAddrPool->pNext;
    }
}

/*

Returns:

Notes:

*/

VOID
RasStatCreatePoolList(
    IN OUT  ADDR_POOL**     ppAddrPoolOut
)
{
    HKEY        hKeyAddrPool            = NULL;
    HKEY        hKey;
    LONG        lErr;
    CHAR        aszSubKey[10];
    DWORD       dwIndex;
    BOOL        fExitWhile;
    DWORD       dwType;
    DWORD       dwValue;
    DWORD       dwSize;
    IPADDR      hboFirstIpAddr;
    IPADDR      hboLastIpAddr;
    IPADDR      hboMask;
    ADDR_POOL*  pAddrPool               = NULL;
    ADDR_POOL** ppAddrPool              = NULL;
    ADDR_POOL*  pAddrPoolTemp;

    TraceHlp("RasStatCreatePoolList");

    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_ADDR_POOL_A, 0,
                KEY_READ, &hKeyAddrPool); 

    if (ERROR_SUCCESS != lErr)
    {
        rasStatCreatePoolListFromOldValues(ppAddrPoolOut);
        goto LDone;
    }

    ppAddrPool = &pAddrPool;

    dwIndex = 0;
    fExitWhile = FALSE;

    while (!fExitWhile)
    {
        hKey = NULL;

        sprintf(aszSubKey, "%d", dwIndex);

        lErr = RegOpenKeyEx(hKeyAddrPool, aszSubKey, 0, KEY_READ,
                    &hKey); 

        if (ERROR_SUCCESS != lErr)
        {
            TraceHlp("Couldn't open key %s in key :%ld",  aszSubKey, lErr );
            fExitWhile = TRUE;
            goto LWhileEnd;
        }

        dwSize = sizeof(dwValue);

        lErr = RegQueryValueEx(hKey, REGVAL_FROM_A, NULL, &dwType,
                (BYTE*)&dwValue, &dwSize);

        if (   (ERROR_SUCCESS != lErr)
            || (REG_DWORD != dwType))
        {
            TraceHlp("Couldn't read value %s in key %s: %d",
                REGVAL_FROM_A, aszSubKey, lErr);
            goto LWhileEnd;
        }

        hboFirstIpAddr = dwValue;

        dwSize = sizeof(dwValue);

        lErr = RegQueryValueEx(hKey, REGVAL_TO_A, NULL, &dwType,
                (BYTE*)&dwValue, &dwSize);

        if (   (ERROR_SUCCESS != lErr)
            || (REG_DWORD != dwType))
        {
            TraceHlp("Couldn't read value %s in key %s: %d",
                REGVAL_TO_A, aszSubKey, lErr);
            goto LWhileEnd;
        }

        hboLastIpAddr = dwValue;

        hboMask = rasStatMaskFromAddrPair(hboFirstIpAddr, hboLastIpAddr);

        pAddrPoolTemp = LocalAlloc(LPTR, sizeof(ADDR_POOL));

        if (NULL == pAddrPoolTemp)
        {
            TraceHlp("Out of memory");
            fExitWhile = TRUE;
            goto LWhileEnd;
        }

        pAddrPoolTemp->hboFirstIpAddr = hboFirstIpAddr;
        pAddrPoolTemp->hboLastIpAddr = hboLastIpAddr;
        pAddrPoolTemp->hboNextIpAddr = hboFirstIpAddr;
        pAddrPoolTemp->hboMask = hboMask;
        TraceHlp("0x%x...0x%x/0x%x", hboFirstIpAddr, hboLastIpAddr, hboMask);

        *ppAddrPool = pAddrPoolTemp;
        ppAddrPool = &(pAddrPoolTemp->pNext);

    LWhileEnd:

        if (NULL != hKey)
        {
            RegCloseKey(hKey);
        }

        dwIndex++;
    }

    *ppAddrPoolOut = pAddrPool;
    pAddrPool = NULL;

LDone:

    if (NULL != hKeyAddrPool)
    {
        RegCloseKey(hKeyAddrPool);
    }

    RasStatFreeAddrPool(pAddrPool);
}

/*

Returns:
    VOID

Description:

*/

VOID
RasStatFreeAddrPool(
    IN  ADDR_POOL*  pAddrPool
)
{
    ADDR_POOL*  pAddrPoolTemp;

    while (pAddrPool != NULL)
    {
        pAddrPoolTemp = pAddrPool;
        pAddrPool = pAddrPool->pNext;
        LocalFree(pAddrPoolTemp);
    }
}

/*

Returns:
    TRUE: The 2 static address pools are different
    FALSE: The 2 static address pools are identical

Description:

*/

BOOL
RasStatAddrPoolsDiffer
(
    IN  ADDR_POOL*  pAddrPool1,
    IN  ADDR_POOL*  pAddrPool2
)
{
    while (TRUE)
    {
        if (   (NULL == pAddrPool1)
            && (NULL == pAddrPool2))
        {
            return(FALSE);
        }

        if (   (NULL == pAddrPool1)
            || (NULL == pAddrPool2))
        {
            return(TRUE);
        }

        if (   (pAddrPool1->hboFirstIpAddr != pAddrPool2->hboFirstIpAddr)
            || (pAddrPool1->hboLastIpAddr != pAddrPool2->hboLastIpAddr))
        {
            return(TRUE);
        }

        pAddrPool1 = pAddrPool1->pNext;
        pAddrPool2 = pAddrPool2->pNext;
    }
}

/*

Returns:

Notes:

*/

DWORD
RasStatAcquireAddress(
    IN  HPORT   hPort,
    OUT IPADDR* pnboIpAddr,
    OUT IPADDR* pnboIpMask
)
{
    IPADDR_NODE*    pNode;
    DWORD           dwErr   = ERROR_NO_IP_ADDRESSES;

    TraceHlp("RasStatAcquireAddress");

    EnterCriticalSection(&RasStatCriticalSection);

    if (NULL == RasStatFreePool)
    {
        rasStatAllocateAddresses();

        if (NULL == RasStatFreePool)
        {
            TraceHlp("Out of addresses");
            goto LDone;
        }
    }

    // Move from Free pool to Alloc pool
    pNode = RasStatFreePool;
    RasStatFreePool = RasStatFreePool->pNext;
    pNode->pNext = RasStatAllocPool;
    RasStatAllocPool = pNode;

    TraceHlp("Acquired 0x%x", pNode->hboIpAddr);
    *pnboIpAddr = htonl(pNode->hboIpAddr);
    *pnboIpMask = htonl(HOST_MASK);
    pNode->hPort = hPort;

    dwErr = NO_ERROR;

LDone:

    LeaveCriticalSection(&RasStatCriticalSection);

    return(dwErr);
}

/*

Returns:
    VOID

Notes:

*/

VOID
RasStatReleaseAddress(
    IN  IPADDR  nboIpAddr
)
{
    IPADDR_NODE*    pNode;
    IPADDR_NODE**   ppNode;
    IPADDR          hboIpAddr;

    TraceHlp("RasStatReleaseAddress");

    EnterCriticalSection(&RasStatCriticalSection);

    hboIpAddr = ntohl(nboIpAddr);

    for (ppNode = &RasStatAllocPool;
         (pNode = *ppNode) != NULL;
         ppNode = &pNode->pNext)
    {
        if (pNode->hboIpAddr == hboIpAddr)
        {
            TraceHlp("Released 0x%x", nboIpAddr);

            // Unlink from alloc pool
            *ppNode = pNode->pNext;

            // Put at the end of the free pool, because we want to round-robin
            // the addresses.
            pNode->pNext = NULL;

            ppNode = &RasStatFreePool;
            while (NULL != *ppNode)
            {
                ppNode = &((*ppNode)->pNext);
            }
            *ppNode = pNode;

            goto LDone;
        }
    }

    TraceHlp("IpAddress 0x%x not present in alloc pool", nboIpAddr);

LDone:

    LeaveCriticalSection(&RasStatCriticalSection);
}

/*

Returns:
    VOID

Notes:

*/

VOID
rasStatDeleteLists(
    VOID
)
{
    IPADDR_NODE*    pNode;
    IPADDR_NODE*    pNodeTemp;
    DWORD           dwIndex;

    TraceHlp("rasStatDeleteLists");

    EnterCriticalSection(&RasStatCriticalSection);

    pNode = RasStatAllocPool;
    while (pNode != NULL)
    {
        pNodeTemp = pNode;
        pNode = pNode->pNext;
        LocalFree(pNodeTemp);
    }

    pNode = RasStatFreePool;
    while (pNode != NULL)
    {
        pNodeTemp = pNode;
        pNode = pNode->pNext;
        LocalFree(pNodeTemp);
    }

    RasStatAllocPool = NULL;
    RasStatFreePool  = NULL;

    LeaveCriticalSection(&RasStatCriticalSection);
}

/*

Returns:
    VOID

Notes:

*/

VOID
rasStatAllocateAddresses(
    VOID
)
{
    DWORD           dwNumAddressesToGet;
    IPADDR_NODE*    pNode;
    IPADDR_NODE**   ppNode;
    IPADDR          hboIpAddr;

    TraceHlp("rasStatAllocateAddresses");

    EnterCriticalSection(&RasStatCriticalSection);

    ppNode = &RasStatFreePool;
    dwNumAddressesToGet = HelperRegVal.dwChunkSize;

    while (dwNumAddressesToGet > 0)
    {
        if (RasStatCurrentPool == NULL)
        {
            goto LDone;
        }

        hboIpAddr = RasStatCurrentPool->hboNextIpAddr;

        if (rasStatBadAddress(hboIpAddr))
        {
            TraceHlp("Discarding address 0x%x", hboIpAddr);
            goto LWhileEnd;
        }

        pNode = LocalAlloc(LPTR, sizeof(IPADDR_NODE));

        if (NULL == pNode)
        {
            TraceHlp("LocalAlloc failed and returned %d", GetLastError());
            goto LDone;
        }

        pNode->hboIpAddr = hboIpAddr;
        TraceHlp("Allocated address 0x%x", hboIpAddr);

        *ppNode = pNode;
        ppNode = &((*ppNode)->pNext);

        dwNumAddressesToGet--;

LWhileEnd:

        if (RasStatCurrentPool->hboNextIpAddr ==
            RasStatCurrentPool->hboLastIpAddr)
        {
            RasStatCurrentPool = RasStatCurrentPool->pNext;
        }
        else
        {
            RasStatCurrentPool->hboNextIpAddr++;
        }
    }

LDone:

    LeaveCriticalSection(&RasStatCriticalSection);
}

/*

Returns:
    VOID

Notes:

*/

BOOL
rasStatBadAddress(
    IPADDR  hboIpAddr
)
{
    IPADDR  hboSubnetMask;

    if (   INVALID_HBO_CLASS(hboIpAddr)
        || LOOPBACK_HBO_ADDR(hboIpAddr))
    {
        // Addresses >= 224.0.0.0 (0xE0000000) are invalid unicast addresses.
        // They are meant only for multicast use.

        return(TRUE);
    }

    // Reject 0.*.*.* also

    if ((hboIpAddr & 0xFF000000) == 0)
    {
        return(TRUE);
    }

    if (CLASSA_HBO_ADDR(hboIpAddr))
    {
        hboSubnetMask = CLASSA_HBO_ADDR_MASK;
    }
    else if (CLASSB_HBO_ADDR(hboIpAddr))
    {
        hboSubnetMask = CLASSB_HBO_ADDR_MASK;
    }
    else if (CLASSC_HBO_ADDR(hboIpAddr))
    {
        hboSubnetMask = CLASSC_HBO_ADDR_MASK;
    }
    else
    {
        return(TRUE);
    }

    // Reject subnet address

    if ((hboIpAddr & hboSubnetMask) == hboIpAddr)
    {
        return(TRUE);
    }

    // Reject broadcast address

    if ((hboIpAddr | ~hboSubnetMask) == hboIpAddr)
    {
        return(TRUE);
    }

    return(FALSE);
}

/*

Returns:

Notes:

*/

VOID
rasStatCreatePoolListFromOldValues(
    IN OUT  ADDR_POOL**     ppAddrPoolOut
)
{
    HKEY        hKeyIpParam         = NULL;
    CHAR*       szIpAddress         = NULL;
    CHAR*       szIpMask            = NULL;
    ADDR_POOL*  pAddrPool           = NULL;

    IPADDR      hboFirstIpAddr;
    IPADDR      hboLastIpAddr;
    IPADDR      hboMask;

    LONG        lErr;
    DWORD       dwErr;

    TraceHlp("rasStatCreatePoolListFromOldValues");

    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_RAS_IP_PARAM_A, 0,
                KEY_READ, &hKeyIpParam); 

    if (ERROR_SUCCESS != lErr)
    {
        TraceHlp("Couldn't open key %s: %d", REGKEY_RAS_IP_PARAM_A, lErr);
        goto LDone;
    }

    pAddrPool = LocalAlloc(LPTR, sizeof(ADDR_POOL));

    if (NULL == pAddrPool)
    {
        TraceHlp("Out of memory");
        goto LDone;
    }

    dwErr = RegQueryValueWithAllocA(hKeyIpParam, REGVAL_IPADDRESS_A, 
                REG_SZ, &szIpAddress);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("RegQueryValueWithAllocA(%s) failed: %d",
            REGVAL_IPADDRESS_A, dwErr);
        goto LDone;
    }

    hboFirstIpAddr = ntohl(inet_addr(szIpAddress));

    if (INADDR_NONE == hboFirstIpAddr)
    {
        TraceHlp("Bad value in %s", REGVAL_IPADDRESS_A);
        goto LDone;
    }

    dwErr = RegQueryValueWithAllocA(hKeyIpParam, REGVAL_IPMASK_A, 
                REG_SZ, &szIpMask);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("RegQueryValueWithAllocA(%s) failed: %d",
            REGVAL_IPMASK_A, dwErr);
        goto LDone;
    }

    hboMask = ntohl(inet_addr(szIpMask));

    if (INADDR_NONE == hboMask)
    {
        TraceHlp("Bad value in %s", REGVAL_IPMASK_A);
        goto LDone;
    }

    hboLastIpAddr = hboFirstIpAddr | (~hboMask);

    pAddrPool->hboFirstIpAddr = hboFirstIpAddr;
    pAddrPool->hboLastIpAddr = hboLastIpAddr;
    pAddrPool->hboNextIpAddr = hboFirstIpAddr;
    pAddrPool->hboMask = hboMask;
    TraceHlp("0x%x...0x%x/0x%x", hboFirstIpAddr, hboLastIpAddr, hboMask);

    *ppAddrPoolOut = pAddrPool;
    pAddrPool = NULL;

LDone:

    if (NULL != hKeyIpParam)
    {
        RegCloseKey(hKeyIpParam);
    }

    LocalFree(szIpAddress);
    LocalFree(szIpMask);

    RasStatFreeAddrPool(pAddrPool);
}

/*

Returns:

Notes:

*/

IPADDR
rasStatMaskFromAddrPair(
    IN  IPADDR  hboFirstIpAddr,
    IN  IPADDR  hboLastIpAddr
)
{
    IPADDR  hboTemp;
    IPADDR  hboMask;
    IPADDR  hboMaskTemp;
    DWORD   dw;

    // This will put 1's where the bits have the same value

    hboTemp = ~(hboFirstIpAddr ^ hboLastIpAddr);

    // Now we look for the first 0 bit (looking from high bit to low bit)
    // This will give us our mask

    hboMask = 0;
    hboMaskTemp = 0;

    for (dw = 0; dw < sizeof(IPADDR) * 8; dw++)
    {
        hboMaskTemp >>= 1;
        hboMaskTemp |= 0x80000000;

        // Is there a zero bit?

        if ((hboMaskTemp & hboTemp) != hboMaskTemp)
        {
            // There is a zero, so we break out.

            break;
        }

        // If not, continue

        hboMask = hboMaskTemp;
    }

    return(hboMask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rassrvr_.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _RASSRVR__H_
#define _RASSRVR__H_

#include "rasiphlp_.h"
#include <mprlog.h>
#include <dns.h>
#include <dnsapi.h>
#include <dhcpcapi.h>
#include <raserror.h>
#include <malloc.h>
#include <rasman.h>
#include <llinfo.h>
#include <ddwanarp.h>
#include "helper.h"
#include "tcpreg.h"
#include "rasdhcp.h"
#include "rasstat.h"
#include "rastcp.h"
#include "rassrvr.h"

#define SERVER_HPORT                0xee170466

#define AINODE_FLAG_NOTIFY_DLL      0x00000001
#define AINODE_FLAG_ACTIVATED       0x00000002
#define AINODE_FLAG_EASYNET         0x00000004

typedef struct _ACQUIRED_IPADDR
{
    struct _ACQUIRED_IPADDR*    pNext;
    HPORT                       hPort;      // For diagnostic purposes
    IPADDR                      nboIpAddr;
    WCHAR*                      wszUserName;
    WCHAR*                      wszPortName;
    DWORD                       fFlags;     // See AINODE_FLAG_*

} AINODE;

MPRADMINGETIPADDRESSFORUSER*        pfnMprAdminGetIpAddressForUser      = NULL;
MPRADMINRELEASEIPADDRESS*           pfnMprAdminReleaseIpAddress         = NULL;
IPADDR                              RasSrvrNboServerIpAddress           = 0;
IPADDR                              RasSrvrNboServerSubnetMask          = 0;
AINODE*                             RasSrvrAcquiredIpAddresses          = NULL;
BOOL                                RasSrvrRunning                      = FALSE;
BOOL                                RasSrvrAdapterMapped                = FALSE;
MIB_SERVER_HANDLE                   RasSrvrHMIBServer                   = NULL;

WCHAR g_rgwcAdapterName[WANARP_MAX_DEVICE_NAME_LEN + 2];

extern HANDLE HelperWanArpHandle;

// This critical section controls access to the above global variables
extern          CRITICAL_SECTION    RasSrvrCriticalSection;

DWORD
rasSrvrInitAdapterName(
    VOID
);

AINODE*
rasSrvrFindAiNode(
    IN  IPADDR  nboIpAddr,
    IN  BOOL    fRemoveFromList
);

VOID
rasSrvrFreeAiNode(
    IN  AINODE* pNode
);

DWORD
rasSrvrSetIpAddressInRegistry(
    IN  IPADDR  nboIpAddr,
    IN  IPADDR  nboIpMask
);

DWORD
rasSrvrAcquireAddressEx(
    IN      HPORT   hPort,
    IN OUT  IPADDR* pnboIpAddr,
    IN OUT  IPADDR* pnboIpMask,
    OUT     BOOL*   pfEasyNet
);

DWORD
rasSrvrGetAddressForServerAdapter(
    VOID
);

#endif // #ifndef _RASSRVR__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rasstat.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _RASSTAT_H_
#define _RASSTAT_H_

#include "rasiphlp.h"

DWORD
RasStatInitialize(
    VOID
);

VOID
RasStatUninitialize(
    VOID
);

VOID
RasStatSetRoutes(
    IN  IPADDR  nboServerIpAddress,
    IN  BOOL    fSet
);

VOID
RasStatCreatePoolList(
    IN OUT  ADDR_POOL**     ppAddrPoolOut
);

VOID
RasStatFreeAddrPool(
    IN  ADDR_POOL*  pAddrPool
);

BOOL
RasStatAddrPoolsDiffer
(
    IN  ADDR_POOL*  pAddrPool1,
    IN  ADDR_POOL*  pAddrPool2
);

DWORD
RasStatAcquireAddress(
    IN      HPORT   hPort,
    IN OUT  IPADDR* pnboIpAddr,
    IN OUT  IPADDR* pnboIpMask
);

VOID
RasStatReleaseAddress(
    IN  IPADDR  nboIpAddr
);

#endif // #ifndef _RASSTAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rassrvr.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _RASSRVR_H_
#define _RASSRVR_H_

#include "rasiphlp.h"

typedef DWORD (MPRADMINGETIPADDRESSFORUSER)(
    IN      WCHAR*      wszUserName,
    IN      WCHAR*      wszPortName,
    IN OUT  IPADDR*     pnboIpAddress,
    OUT     BOOL*       fNotifyDll
);

typedef VOID (MPRADMINRELEASEIPADDRESS)(  
    IN      WCHAR*      wszUserName,
    IN      WCHAR*      wszPortName,
    IN OUT  IPADDR*     pnboIpAddress
);

typedef struct IPINFO
{
    IPADDR  nboWINSAddress;
    IPADDR  nboWINSAddressBackup;
    IPADDR  nboDNSAddress;
    IPADDR  nboDNSAddressBackup;
    IPADDR  nboServerIpAddress;
    IPADDR  nboServerSubnetMask;

} IPINFO;

extern  BOOL    RasSrvrRunning;

DWORD
RasSrvrInitialize(
    IN  MPRADMINGETIPADDRESSFORUSER*    pfnMprGetAddress,
    IN  MPRADMINRELEASEIPADDRESS*       pfnMprReleaseAddress
);

VOID
RasSrvrUninitialize(
    VOID
);

DWORD
RasSrvrStart(
    VOID
);

VOID
RasSrvrStop(
    IN  BOOL    fParametersChanged
);

DWORD
RasSrvrAcquireAddress(
    IN  HPORT       hPort, 
    IN  IPADDR      nboIpAddress, 
    OUT IPADDR*     pnboIpAddressAllocated, 
    IN  WCHAR*      wszUserName,
    IN  WCHAR*      wszPortName
);

VOID
RasSrvrReleaseAddress(
    IN  IPADDR      nboIpAddress, 
    IN  WCHAR*      wszUserName,
    IN  WCHAR*      wszPortName,
    IN  BOOL        fDeregister
);

DWORD
RasSrvrActivateIp(
    IN  IPADDR  nboIpAddress,
    IN  DWORD   dwUsage
);

DWORD
RasSrvrQueryServerAddresses(
    IN OUT  IPINFO* pIpInfo
);

VOID
RasSrvrDhcpCallback(
    IN  IPADDR  nboIpAddr
);

VOID
RasSrvrEnableRouter(
    BOOL    fEnable
);

VOID
RasSrvrAdapterUnmapped(
    VOID
);

#endif // #ifndef _RASSRVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rasstat_.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _RASSTAT__H_
#define _RASSTAT__H_

#include "rasiphlp_.h"
#include <raserror.h>
#include <winsock2.h>
#include <stdio.h>
#include <rasman.h>
#include "helper.h"
#include "tcpreg.h"
#include "rastcp.h"
#include "rasstat.h"

typedef struct _IPADDR_NODE
{
    struct _IPADDR_NODE*    pNext;
    HPORT                   hPort;      // For diagnostic purposes
    IPADDR                  hboIpAddr;

} IPADDR_NODE;

IPADDR_NODE*                        RasStatAllocPool            = NULL;
IPADDR_NODE*                        RasStatFreePool             = NULL;
ADDR_POOL*                          RasStatCurrentPool          = NULL;

// This critical section controls access to the above global variables
extern          CRITICAL_SECTION    RasStatCriticalSection;

VOID
rasStatDeleteLists(
    VOID
);

VOID
rasStatAllocateAddresses(
    VOID
);

BOOL
rasStatBadAddress(
    IPADDR  hboIpAddr
);

VOID
rasStatCreatePoolListFromOldValues(
    IN OUT  ADDR_POOL**     ppAddrPoolOut
);

IPADDR
rasStatMaskFromAddrPair(
    IN  IPADDR  hboFirstIpAddr,
    IN  IPADDR  hboLastIpAddr
);

#endif // #ifndef _RASSTAT__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rastcp.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _RASTCP_H_
#define _RASTCP_H_

#include "rasiphlp.h"

IPADDR
RasTcpDeriveMask(
    IN  IPADDR  nboIpAddr
);

VOID
RasTcpSetProxyArp(
    IN  IPADDR  nboIpAddr,
    IN  BOOL    fAddAddress
);

VOID
RasTcpSetRoute(
    IN  IPADDR  nboDestAddr,
    IN  IPADDR  nboNextHopAddr,
    IN  IPADDR  nboIpMask,
    IN  IPADDR  nboLocalAddr,
    IN  BOOL    fAddAddress,
    IN  DWORD   dwMetric,
    IN  BOOL    fSetToStack
);

VOID
RasTcpSetRouteEx(
    IN  IPADDR  nboDestAddr,
    IN  IPADDR  nboNextHopAddr,
    IN  IPADDR  nboIpMask,
    IN  IPADDR  nboLocalAddr,
    IN  BOOL    fAddAddress,
    IN  DWORD   dwMetric,
    IN  BOOL    fSetToStack,
    IN  GUID   *pDeviceGuid
);


#if 0
VOID
RasTcpSetRoutesForNameServers(
    BOOL
);

#endif


DWORD
RasTcpAdjustMulticastRouteMetric (
    IN IPADDR   nboIpAddr,
    IN BOOL     fSet
);
DWORD
RasTcpAdjustRouteMetrics(
    IN  IPADDR  nboIpAddr,
    IN  BOOL    fSet
);

VOID 
RasTcpSetDhcpRoutes ( 
 IN PBYTE pbRouteInfo, 
 IN IPADDR ipAddrLocal, 
 IN BOOL fSet );
#endif // #ifndef _RASTCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rastcp.c ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#include "rastcp_.h"

/*

Returns:

Description:

*/

IPADDR
RasTcpDeriveMask(
    IN  IPADDR  nboIpAddr
)
{
    IPADDR nboMask = 0;
    IPADDR hboMask = 0;

    if (CLASSA_NBO_ADDR(nboIpAddr))
    {
        hboMask = CLASSA_HBO_ADDR_MASK;
    }
    else if (CLASSB_NBO_ADDR(nboIpAddr))
    {
        hboMask = CLASSB_HBO_ADDR_MASK;
    }
    else if (CLASSC_NBO_ADDR(nboIpAddr))
    {
        hboMask = CLASSC_HBO_ADDR_MASK;
    }

    nboMask = htonl(hboMask);

    return(nboMask);
}

/*

Returns:
    VOID

Description:
    Sets the ip address for proxy arp"ing" on all lan interfaces.

*/

VOID
RasTcpSetProxyArp(
    IN  IPADDR  nboIpAddr,
    IN  BOOL    fAddAddress
)
{
    MIB_IPADDRTABLE*    pIpAddrTable    = NULL;
    HANDLE              hHeap           = NULL;
    DWORD               dwNboIpAddr;
    DWORD               dwNboMask;
    DWORD               dw;
    DWORD               dwErr           = NO_ERROR;

    extern  IPADDR      RasSrvrNboServerIpAddress;

    TraceHlp("RasTcpSetProxyArp(IP Addr: 0x%x, fAddAddress: %s)",
        nboIpAddr, fAddAddress ? "TRUE" : "FALSE");

    hHeap = GetProcessHeap();

    if (NULL == hHeap)
    {
        dwErr = GetLastError();
        TraceHlp("GetProcessHeap failed and returned %d", dwErr);
        goto LDone;
    }

    dwErr = PAllocateAndGetIpAddrTableFromStack(&pIpAddrTable,
                FALSE /* bOrder */, hHeap, LPTR);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("AllocateAndGetIpAddrTableFromStack failed and returned %d",
            dwErr);
        goto LDone;
    }

    for (dw = 0; dw < pIpAddrTable->dwNumEntries; dw++)
    {
        dwNboIpAddr = pIpAddrTable->table[dw].dwAddr;
        dwNboMask = pIpAddrTable->table[dw].dwMask;

        if (   (ALL_NETWORKS_ROUTE == dwNboIpAddr)
            || (HOST_MASK == dwNboIpAddr)
            || (RasSrvrNboServerIpAddress == dwNboIpAddr))
        {
            continue;
        }

        if ((nboIpAddr & dwNboMask) != (dwNboIpAddr & dwNboMask))
        {
            continue;
        }

        dwErr = PSetProxyArpEntryToStack(nboIpAddr, HOST_MASK,
                    pIpAddrTable->table[dw].dwIndex, 
                    fAddAddress, FALSE);

        if (NO_ERROR != dwErr)
        {
            TraceHlp("SetProxyArpEntryToStack on NIC with address 0x%x failed "
                "and returned 0x%x", dwNboIpAddr, dwErr);

            dwErr = PSetProxyArpEntryToStack(nboIpAddr, HOST_MASK,
                        pIpAddrTable->table[dw].dwIndex, 
                        fAddAddress, TRUE);

            TraceHlp("SetProxyArpEntryToStack: 0x%x", dwErr);
        }
    }

LDone:

    if (   (NULL != hHeap)
        && (NULL != pIpAddrTable))
    {
        HeapFree(hHeap, 0, pIpAddrTable);
    }

    return;
}

/*

Returns:
    VOID

Description:

*/

VOID
RasTcpSetRoute(
    IN  IPADDR  nboDestAddr,
    IN  IPADDR  nboNextHopAddr,
    IN  IPADDR  nboIpMask,
    IN  IPADDR  nboLocalAddr,
    IN  BOOL    fAddAddress,
    IN  DWORD   dwMetric,
    IN  BOOL    fSetToStack
)
{
    MIB_IPADDRTABLE*    pIpAddrTable    = NULL;
    MIB_IPFORWARDROW    IpForwardRow;
    HANDLE              hHeap           = NULL;
    DWORD               dw;
    DWORD               dwErr           = NO_ERROR;

    TraceHlp("RasTcpSetRoute(Dest: 0x%x, Mask: 0x%x, NextHop: 0x%x, "
        "Intf: 0x%x, %d, %s, %s)",
        nboDestAddr, nboIpMask, nboNextHopAddr, nboLocalAddr, dwMetric,
        fAddAddress ? "Add" : "Del",
        fSetToStack ? "Stack" : "Rtr");

    ZeroMemory(&IpForwardRow, sizeof(IpForwardRow));

    hHeap = GetProcessHeap();

    if (NULL == hHeap)
    {
        dwErr = GetLastError();
        TraceHlp("GetProcessHeap failed and returned %d", dwErr);
        goto LDone;
    }

    dwErr = PAllocateAndGetIpAddrTableFromStack(&pIpAddrTable,
                FALSE /* bOrder */, hHeap, LPTR);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("AllocateAndGetIpAddrTableFromStack failed and returned %d",
            dwErr);
        goto LDone;
    }

    for (dw = 0; dw < pIpAddrTable->dwNumEntries; dw++)
    {
        if (nboLocalAddr == pIpAddrTable->table[dw].dwAddr)
        {
            IpForwardRow.dwForwardDest      = nboDestAddr;
            IpForwardRow.dwForwardMask      = nboIpMask;
            IpForwardRow.dwForwardPolicy    = 0;
            IpForwardRow.dwForwardNextHop   = nboNextHopAddr;
            IpForwardRow.dwForwardIfIndex   = pIpAddrTable->table[dw].dwIndex;
            IpForwardRow.dwForwardProto     = IRE_PROTO_NETMGMT;
            IpForwardRow.dwForwardAge       = (DWORD)-1;
            IpForwardRow.dwForwardNextHopAS = 0;
            IpForwardRow.dwForwardMetric1   = dwMetric;
            IpForwardRow.dwForwardMetric2   = (DWORD)-1;
            IpForwardRow.dwForwardMetric3   = (DWORD)-1;
            IpForwardRow.dwForwardMetric4   = (DWORD)-1;
            IpForwardRow.dwForwardMetric5   = (DWORD)-1;
            IpForwardRow.dwForwardType      = (fAddAddress ?
                                          IRE_TYPE_DIRECT : IRE_TYPE_INVALID);

            if (fSetToStack)
            {
                dwErr = PSetIpForwardEntryToStack(&IpForwardRow);
            }
            else
            {
                if (fAddAddress)
                {
                    dwErr = PSetIpForwardEntry(&IpForwardRow);
                }
                else
                {
                    dwErr = PDeleteIpForwardEntry(&IpForwardRow);
                }
            }

            if (NO_ERROR != dwErr)
            {
                TraceHlp("SetIpForwardEntry%s failed and returned 0x%x",
                    fSetToStack ? "ToStack" : "", dwErr);
            }

            break;
        }
    }

LDone:

    if (   (NULL != hHeap)
        && (NULL != pIpAddrTable))
    {
        HeapFree(hHeap, 0, pIpAddrTable);
    }

    return;
}

VOID
RasTcpSetRouteEx(
    IN  IPADDR  nboDestAddr,
    IN  IPADDR  nboNextHopAddr,
    IN  IPADDR  nboIpMask,
    IN  IPADDR  nboLocalAddr,
    IN  BOOL    fAddAddress,
    IN  DWORD   dwMetric,
    IN  BOOL    fSetToStack,
    IN  GUID   *pIfGuid
)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hHeap = NULL;
    IP_INTERFACE_NAME_INFO *pTable = NULL;
    DWORD dw;
    DWORD dwCount;
    MIB_IPFORWARDROW    IpForwardRow;
    
    TraceHlp("RasTcpSetRouteEx(Dest: 0x%x, Mask: 0x%x, NextHop: 0x%x, "
        "Intf: 0x%x, %d, %s, %s)",
        nboDestAddr, nboIpMask, nboNextHopAddr, nboLocalAddr, dwMetric,
        fAddAddress ? "Add" : "Del",
        fSetToStack ? "Stack" : "Rtr");

    hHeap = GetProcessHeap();

    if(NULL == hHeap)
    {
        dwErr = GetLastError();
        TraceHlp("GetPRocessHeap failed and returned %d", dwErr);
        goto LDone;
    }

    ZeroMemory(&IpForwardRow, sizeof(MIB_IPFORWARDROW));

    dwErr = PNhpAllocateAndGetInterfaceInfoFromStack(&pTable, &dwCount,
                FALSE /* bOrder */, hHeap, LPTR);
    
    for(dw = 0; dw < dwCount; dw++)
    {
        if(0 == memcmp(&pTable[dw].DeviceGuid,
                       pIfGuid,
                       sizeof(GUID)))
        {
            break;
        }
    }

    if(dw == dwCount)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto LDone;
    }

    IpForwardRow.dwForwardDest      = nboDestAddr;
    IpForwardRow.dwForwardMask      = nboIpMask;
    IpForwardRow.dwForwardPolicy    = 0;

    if(nboDestAddr != ALL_NETWORKS_ROUTE)
    {   
        IpForwardRow.dwForwardNextHop   = nboNextHopAddr;
    }
    else
    {
        IpForwardRow.dwForwardNextHop   = 0;
    }
    
    IpForwardRow.dwForwardIfIndex   = pTable[dw].Index;
    IpForwardRow.dwForwardProto     = IRE_PROTO_NETMGMT;
    IpForwardRow.dwForwardAge       = (DWORD)-1;
    IpForwardRow.dwForwardNextHopAS = 0;
    IpForwardRow.dwForwardMetric1   = dwMetric;
    IpForwardRow.dwForwardMetric2   = (DWORD)-1;
    IpForwardRow.dwForwardMetric3   = (DWORD)-1;
    IpForwardRow.dwForwardMetric4   = (DWORD)-1;
    IpForwardRow.dwForwardMetric5   = (DWORD)-1;
    IpForwardRow.dwForwardType      = (fAddAddress ?
                                  IRE_TYPE_DIRECT : IRE_TYPE_INVALID);

    if (fSetToStack)
    {
        dwErr = PSetIpForwardEntryToStack(&IpForwardRow);
    }
    else
    {
        if (fAddAddress)
        {
            dwErr = PSetIpForwardEntry(&IpForwardRow);
        }
        else
        {
            dwErr = PDeleteIpForwardEntry(&IpForwardRow);
        }
    }

    if (NO_ERROR != dwErr)
    {
        TraceHlp("SetIpForwardEntry%s failed and returned 0x%x",
            fSetToStack ? "ToStack" : "", dwErr);
    }

LDone:

    if(NULL != pTable)
    {
        HeapFree(hHeap, 0, pTable);
    }
}


/*

Returns:
    VOID

Description:

*/
#if 0

VOID
RasTcpSetRoutesForNameServers(
    BOOL fSet
)
{
    HANDLE                  hHeap           = NULL;
    IP_INTERFACE_NAME_INFO* pTable          = NULL;
    DWORD                   dw;
    DWORD                   dwCount;
    IPADDR                  nboIpAddress;
    IPADDR                  nboDNS1;
    IPADDR                  nboDNS2;
    IPADDR                  nboWINS1;
    IPADDR                  nboWINS2;
    IPADDR                  nboGateway;
    DWORD                   dwErr           = NO_ERROR;

    TraceHlp("RasTcpSetRoutesForNameServers. fSet=%d", fSet);

    hHeap = GetProcessHeap();

    if (NULL == hHeap)
    {
        dwErr = GetLastError();
        TraceHlp("GetProcessHeap failed and returned %d", dwErr);
        goto LDone;
    }

    dwErr = PNhpAllocateAndGetInterfaceInfoFromStack(&pTable, &dwCount,
                FALSE /* bOrder */, hHeap, LPTR);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("NhpAllocateAndGetInterfaceInfoFromStack failed and "
            "returned %d", dwErr);
        goto LDone;
    }


    for (dw = 0; dw < dwCount; dw++)
    {
        
        dwErr = GetAdapterInfo(
                    pTable[dw].Index,
                    &nboIpAddress,
                    &nboDNS1, &nboDNS2,
                    &nboWINS1, &nboWINS2,
                    &nboGateway,
                    NULL);

        if (NO_ERROR != dwErr)
        {
            dwErr = NO_ERROR;
            continue;
        }

        if (0 != nboDNS1)
        {
            RasTcpSetRoute(nboDNS1, nboGateway, HOST_MASK, nboIpAddress,
                fSet, 1, TRUE);
        }

        if (0 != nboDNS2)
        {
            RasTcpSetRoute(nboDNS2, nboGateway, HOST_MASK, nboIpAddress,
                fSet, 1, TRUE);
        }

        if (0 != nboWINS1)
        {
            RasTcpSetRoute(nboWINS1, nboGateway, HOST_MASK, nboIpAddress,
                fSet, 1, TRUE);
        }

        if (0 != nboWINS2)
        {
            RasTcpSetRoute(nboWINS2, nboGateway, HOST_MASK, nboIpAddress,
                fSet, 1, TRUE);
        }
    }

LDone:

    if (NULL != pTable)
    {
        HeapFree(hHeap, 0, pTable);
    }
}

#endif

//
//Bump up the metric of all the routes or reduce the metric
//of all multicase routes by 1
//
DWORD 
RasTcpAdjustMulticastRouteMetric ( 
	IN IPADDR	nboIpAddr,
	IN BOOL		fSet
)
{
    MIB_IPFORWARDTABLE* pIpForwardTable = NULL;
    MIB_IPFORWARDROW*   pIpForwardRow;
    HANDLE              hHeap           = NULL;
    DWORD               dw;
    DWORD               dwErr           = NO_ERROR;

    TraceHlp("RasTcpAdjustMulticastRouteMetric(IP Addr: 0x%x, Set: %s)", nboIpAddr, 
        fSet ? "TRUE" : "FALSE");

    hHeap = GetProcessHeap();

    if (NULL == hHeap)
    {
        dwErr = GetLastError();
        TraceHlp("GetProcessHeap failed and returned %d", dwErr);
        goto LDone;
    }

    dwErr = PAllocateAndGetIpForwardTableFromStack(&pIpForwardTable,
                FALSE /* bOrder */, hHeap, LPTR);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("AllocateAndGetIpAddrTableFromStack failed and returned %d",
            dwErr);
        goto LDone;
    }
	//
	//Steps to follow:
	// 1.	Check to see if we have a default route for the interface with
	//		the ip address passed in.
	// 2.   If we do then bump up the metric for all interfaces with 0xE0
	//			as the forward dest.
	//		Else
	//			we have nothing to do.
	// 3.	Add an E0 route with a metric of 1. 
    for (dw = 0; dw < pIpForwardTable->dwNumEntries; dw++)
    {
        pIpForwardRow = pIpForwardTable->table + dw;
		if ( 0 == pIpForwardRow->dwForwardDest  ) //default route
		{
			IPADDR		nboIpIfIpAddr;
			//
			//get the adapter information 
			//to see if the ip address matches
			//
			dwErr = GetAdapterInfo ( pIpForwardRow->dwForwardIfIndex,
									 &nboIpIfIpAddr, 
									 NULL,
									 NULL,
									 NULL,
									 NULL,
									 NULL,
									 NULL
								   );
			if ( NO_ERROR != dwErr )
			{
				TraceHlp("GetAdapterInfo failed and returned %d",
					dwErr);
				goto LDone;				
			}
			if ( nboIpAddr == nboIpIfIpAddr )
			{
				DWORD dw1 = 0;
				MIB_IPFORWARDROW * pIpForwardRow1 = NULL;
				//
				//This means that we have a default route.  So we need to bump up the metric of 
				//all the E0 by 1
				for ( dw1 = 0; dw1 < pIpForwardTable->dwNumEntries; dw1 ++ )
				{
					pIpForwardRow1  = pIpForwardTable->table + dw1;
					if (0xE0 == pIpForwardRow1->dwForwardDest /* multicast route */)
					{
						if (fSet)
						{
							// Bump up metric (hop count)

							pIpForwardRow1->dwForwardMetric1++;
						}
						else if (pIpForwardRow1->dwForwardMetric1 > 1) // Never make it 0!
						{
							// Bump down metric
                
							pIpForwardRow1->dwForwardMetric1--;
						}

						dwErr = PSetIpForwardEntryToStack(pIpForwardRow1);

						if (NO_ERROR != dwErr)
						{
							TraceHlp("SetIpForwardEntryToStack failed and returned 0x%x"
								"dest=0x%x, nexthop=0x%x, mask=0x%x",
								dwErr,
								pIpForwardRow->dwForwardDest,
								pIpForwardRow->dwForwardNextHop,
								pIpForwardRow->dwForwardMask);

							dwErr = NO_ERROR;
						}
					}
				}
				if ( fSet )
				{
					//
					//Set the multicast route metric on this interface
					//to 1
					RasTcpSetRoute( 0xE0,
									nboIpAddr,
									0xF0,
									nboIpAddr,
									TRUE,
									1,
									TRUE
					);

				}
				break;
			}

		}

    }

LDone:

    if (   (NULL != hHeap)
        && (NULL != pIpForwardTable))
    {
        HeapFree(hHeap, 0, pIpForwardTable);
    }

    return(dwErr);

}
/*

Returns:
    Error codes from TCPConfig (your basic nt codes)

Description:
    fSet: If TRUE means set existing routes to higher metrics and add OVERRIDE
            routes.
         If FALSE means mark existing routes to lower metrics.
*/

DWORD
RasTcpAdjustRouteMetrics(
    IN  IPADDR  nboIpAddr,
    IN  BOOL    fSet
)
{
    MIB_IPFORWARDTABLE* pIpForwardTable = NULL;
    MIB_IPFORWARDROW*   pIpForwardRow;
    HANDLE              hHeap           = NULL;
    DWORD               dw;
    DWORD               dwErr           = NO_ERROR;

    TraceHlp("RasTcpAdjustRouteMetrics(IP Addr: 0x%x, Set: %s)", nboIpAddr, 
        fSet ? "TRUE" : "FALSE");

    hHeap = GetProcessHeap();

    if (NULL == hHeap)
    {
        dwErr = GetLastError();
        TraceHlp("GetProcessHeap failed and returned %d", dwErr);
        goto LDone;
    }

    dwErr = PAllocateAndGetIpForwardTableFromStack(&pIpForwardTable,
                FALSE /* bOrder */, hHeap, LPTR);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("AllocateAndGetIpAddrTableFromStack failed and returned %d",
            dwErr);
        goto LDone;
    }

    for (dw = 0; dw < pIpForwardTable->dwNumEntries; dw++)
    {
        pIpForwardRow = pIpForwardTable->table + dw;

        if (0 == pIpForwardRow->dwForwardDest /* default route */)
        {
            if (fSet)
            {
                // Bump up metric (hop count)

                pIpForwardRow->dwForwardMetric1++;
            }
            else if (pIpForwardRow->dwForwardMetric1 > 1) // Never make it 0!
            {
                // Bump down metric
                
                pIpForwardRow->dwForwardMetric1--;
            }

            dwErr = PSetIpForwardEntryToStack(pIpForwardRow);

            if (NO_ERROR != dwErr)
            {
                TraceHlp("SetIpForwardEntryToStack failed and returned 0x%x"
                    "dest=0x%x, nexthop=0x%x, mask=0x%x",
                    dwErr,
                    pIpForwardRow->dwForwardDest,
                    pIpForwardRow->dwForwardNextHop,
                    pIpForwardRow->dwForwardMask);

                dwErr = NO_ERROR;
            }
        }
    }

LDone:

    if (   (NULL != hHeap)
        && (NULL != pIpForwardTable))
    {
        HeapFree(hHeap, 0, pIpForwardTable);
    }

    return(dwErr);
}

VOID 
RasTcpSetDhcpRoutes ( PBYTE pbRouteInfo, IPADDR ipAddrLocal, BOOL fSet )
{
	//parse the byte stream and decode destination descriptors to get the subnet number and subnet mask.
	//The format of the stream is as follows
	//+------------------------------------------------------------------------------------
	//+Code | Len | d1 | ... | dn | r1 | r2 | r3 | r4 | d1 | ... | dn | r1 | r2 | r3 | r4 | 
	//+------------------------------------------------------------------------------------
	//length of code = 1 octet
	//length of Len = 1 octet
	//Length of each d1 ... dn - 1 octet
	//Length of each r1 - r4 = 1 octet.
	
	BYTE dwAddrMaskLookup [] = {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF };

	PBYTE pbRover = pbRouteInfo + 1;
	BYTE  bLen = pbRouteInfo[0];
	TraceHlp ( "RasTcpSetDhcpRoutes Begin");
	while ( pbRover < pbRouteInfo + 1 + bLen )
	{
		unsigned char ipszdest[5] = {0};
		unsigned char ipszsnetmask[5] = {0};
		unsigned char ipsznexthop[5] = {0};
		IPADDR ipdest = 0;
		IPADDR ipmask = 0;
		IPADDR ipnexthop = 0;
		
		
		if ( *pbRover > 32 )
		{
			//Error.  We cannot have more than 32 1's in the mask
            TraceHlp("RasTcpSetDhcpRoutes: invalid destination descriptor first byte %d",
                    *pbRover);

			goto done;
		}
		else
		{	//set the subnet mask first
			int n1 = (int)((*pbRover) / 8);
			int n2 = (int)((*pbRover) % 8 );
			int i;
			for ( i = 0; i < n1; i++)
			{
				ipszsnetmask[i] = (BYTE)0xFF;
			}
			//set the final byte
			if ( n2 ) ipszsnetmask[3] = dwAddrMaskLookup[n2];
			pbRover ++;
			//now for the ip address
			if ( n2 ) n1 ++;
			
			for ( i = 0; i < n1; i ++ )
			{
				ipszdest[i] = *pbRover;
				pbRover++;
			}
			
			TraceHlp ( "RasTcpSetDhcpRoutes: Got route dest addr = %d.%d.%d.%d   subnet mask = %d.%d.%d.%d    route = %d.%d.%d.%d\n",
					 ipszdest[0],ipszdest[1],ipszdest[2],ipszdest[3],
					 ipszsnetmask[0],ipszsnetmask[1],ipszsnetmask[2],ipszsnetmask[3],
					 *pbRover, *(pbRover+1),*(pbRover+2),*(pbRover+3)
					);
			
			CopyMemory ( ipsznexthop, pbRover, 4 );
		/*	
			//now set the route
			ipdest = inet_addr ((const char FAR *)ipszdest);
			ipmask = inet_addr ((const char FAR *)ipszsnetmask);
			ipnexthop = inet_addr ((const char FAR *)ipsznexthop);
        */
            ipdest = *((ULONG *)ipszdest);
            ipmask = *((ULONG *)ipszsnetmask);
            ipnexthop = *((ULONG *)ipsznexthop);
			RasTcpSetRoute(	ipdest,
							ipAddrLocal,
							ipmask,
							ipAddrLocal,
							fSet,
							1,
							TRUE
						  );
            pbRover +=4;

		}
	}
done:
	TraceHlp ( "RasTcpSetDhcpRoutes End");
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\rastcp_.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _RASTCP__H_
#define _RASTCP__H_

#include "rasiphlp_.h"
#include <tdistat.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include <ntddip.h>
#include <ipinfo.h>
#include <iprtrmib.h>
#include <iphlpstk.h>
#include <winsock2.h>
#include "tcpreg.h"
#include "helper.h"
#include "rastcp.h"

#endif // #ifndef _RASTCP__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\tcpreg_.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:
    Dec 1997: Vijay Baliga created original version.

*/

#ifndef _TCPREG__H_
#define _TCPREG__H_

#include "rasiphlp_.h"
#include <dhcpcapi.h>
#include <winsock2.h>
#include <objbase.h>
#include <llinfo.h>
#include <ddwanarp.h>
#include "helper.h"
#include "tcpreg.h"

#define WCH_SPACE                   L' '
#define WCH_ZEROADDRESS             L"0.0.0.0"

#endif // #ifndef _TCPREG__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\tcpreg.c ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:
    The old code is in SaveRegistry and LoadRegistry functions in
    ncpa1.1\tcpip\tcpipcpl.cxx

History:
    Dec 1997: Vijay Baliga created original version.

*/

#include "tcpreg_.h"

/*

Returns:
    Number of bytes in the mwsz including the two terminating NULLs.

Notes:
    
*/

DWORD
MwszLength(
    IN  WCHAR*  mwsz
)
{
    DWORD   dwLength = 2;

    RTASSERT(NULL != mwsz);

    while (mwsz[0] != 0 || mwsz[1] != 0)
    {
        dwLength++;
        mwsz++;
    }

    return(dwLength);
}

/*

Returns:
    VOID

Notes:
    There should be atleast two zeros at the end
    
*/

VOID
ConvertSzToMultiSz(
    IN  CHAR*   sz
)
{
    while (TRUE)
    {
        if (   (0 == sz[0])
            && (0 == sz[1]))
        {
            break;
        }

        if (   (' ' == sz[0])
            || (',' == sz[0]))
        {
            sz[0] = 0;
        }

        sz++;
    }
}

/*

Returns:
    Win32 error code

Notes:
    
*/

DWORD
RegQueryValueWithAllocA(
    IN  HKEY    hKey,
    IN  CHAR*   szValueName,
    IN  DWORD   dwTypeRequired,
    IN  BYTE**  ppbData
)
{
    DWORD   dwType = 0;
    DWORD   dwSize = 0;

    DWORD   dwErr   = ERROR_SUCCESS;

    RTASSERT(NULL != szValueName);
    RTASSERT(NULL != ppbData);

    *ppbData = NULL;

    dwErr = RegQueryValueExA(hKey,
                             szValueName,
                             NULL,
                             &dwType,
                             NULL,
                             &dwSize);

    if (ERROR_SUCCESS != dwErr)
    {
        // TraceHlp("RegQueryValueEx(%s) failed and returned %d.",
        //      szValueName, dwErr);

        goto LDone;
    }

    if (dwTypeRequired != dwType)
    {
        dwErr = E_FAIL;
        TraceHlp("The type of the value %s should be %d, not %d",
              szValueName, dwTypeRequired, dwType);

        goto LDone;
    }

    // For an empty MULTI-SZ, dwSize will be sizeof(CHAR) instead of
    // 2 * sizeof(CHAR). We also want to make sure that no matter what
    // the type, there will be 2 zeros at the end.
    dwSize += 2 * sizeof(CHAR);

    *ppbData = LocalAlloc(LPTR, dwSize);

    if (NULL == *ppbData)
    {
        dwErr = GetLastError();
        TraceHlp("LocalAlloc failed and returned %d", dwErr);

        goto LDone;
    }

    dwErr = RegQueryValueExA(hKey,
                             szValueName,
                             NULL,
                             &dwType,
                             *ppbData,
                             &dwSize);

    if (ERROR_SUCCESS != dwErr)
    {
        // TraceHlp("RegQueryValueEx(%s) failed and returned %d.",
        //      szValueName, dwErr);

        goto LDone;
    }

LDone:

    if (NO_ERROR != dwErr)
    {
        LocalFree(*ppbData);
        *ppbData = NULL;
    }

    return(dwErr);
}

/*

Returns:
    Win32 error code

Notes:
    
*/

DWORD
RegQueryValueWithAllocW(
    IN  HKEY    hKey,
    IN  WCHAR*  wszValueName,
    IN  DWORD   dwTypeRequired,
    IN  BYTE**  ppbData
)
{
    DWORD   dwType;
    DWORD   dwSize;

    DWORD   dwErr   = ERROR_SUCCESS;

    RTASSERT(NULL != wszValueName);
    RTASSERT(NULL != ppbData);

    *ppbData = NULL;

    dwErr = RegQueryValueExW(hKey,
                             wszValueName,
                             NULL,
                             &dwType,
                             NULL,
                             &dwSize);

    if (ERROR_SUCCESS != dwErr)
    {
        // TraceHlp("RegQueryValueEx(%ws) failed and returned %d.",
        //      wszValueName, dwErr);

        goto LDone;
    }

    if (dwTypeRequired != dwType)
    {
        dwErr = E_FAIL;
        TraceHlp("The type of the value %ws should be %d, not %d",
              wszValueName, dwTypeRequired, dwType);

        goto LDone;
    }

    // For an empty MULTI-SZ, dwSize will be sizeof(WCHAR) instead of
    // 2 * sizeof(WCHAR). We also want to make sure that no matter what
    // the type, there will be 2 zeros at the end.
    dwSize += sizeof(WCHAR);

    *ppbData = LocalAlloc(LPTR, dwSize);

    if (NULL == *ppbData)
    {
        dwErr = GetLastError();
        TraceHlp("LocalAlloc failed and returned %d", dwErr);

        goto LDone;
    }

    dwErr = RegQueryValueExW(hKey,
                             wszValueName,
                             NULL,
                             &dwType,
                             *ppbData,
                             &dwSize);

    if (ERROR_SUCCESS != dwErr)
    {
        // TraceHlp("RegQueryValueEx(%ws) failed and returned %d.",
        //      wszValueName, dwErr);

        goto LDone;
    }

LDone:

    if (NO_ERROR != dwErr)
    {
        LocalFree(*ppbData);
        *ppbData = NULL;
    }

    return(dwErr);
}

/*

Returns:
    IP address

Notes:
    Converts caller's a.b.c.d IP address string to a network byte order IP 
    address. 0 if formatted incorrectly.
    
*/

IPADDR
IpAddressFromAbcdWsz(
    IN  WCHAR*  wszIpAddress
)
{
    CHAR    szIpAddress[MAXIPSTRLEN + 1];
    IPADDR  nboIpAddr;

    if (0 == WideCharToMultiByte(
                CP_UTF8,
                0,
                wszIpAddress,
                -1,
                szIpAddress,
                MAXIPSTRLEN + 1,
                NULL,
                NULL))
    {
        return(0);
    }

    nboIpAddr = inet_addr(szIpAddress);

    if (INADDR_NONE == nboIpAddr)
    {
        nboIpAddr = 0;
    }

    return(nboIpAddr);
}

/*

Returns:
    VOID

Description:
    Converts nboIpAddr to a string in the a.b.c.d form and returns same in 
    caller's szIpAddress buffer. The buffer should be at least 
    MAXIPSTRLEN + 1 characters long.

*/

VOID
AbcdSzFromIpAddress(
    IN  IPADDR  nboIpAddr,
    OUT CHAR*   szIpAddress
)
{
    struct in_addr  in_addr;
    CHAR*           sz;

    in_addr.s_addr = nboIpAddr;
    sz = inet_ntoa(in_addr);

    strcpy(szIpAddress, sz ? sz : "");
}

/*

Returns:
    VOID

Description:
    Converts nboIpAddr to a string in the a.b.c.d form and returns same in 
    caller's wszIpAddress buffer. The buffer should be at least 
    MAXIPSTRLEN + 1 characters long.

*/

VOID
AbcdWszFromIpAddress(
    IN  IPADDR  nboIpAddr,
    OUT WCHAR*  wszIpAddress
)
{
    CHAR    szIpAddress[MAXIPSTRLEN + 1];

    AbcdSzFromIpAddress(nboIpAddr, szIpAddress);

    if (0 == MultiByteToWideChar(
                CP_UTF8,
                0,
                szIpAddress,
                -1,
                wszIpAddress,
                MAXIPSTRLEN + 1))
    {
        wszIpAddress[0] = 0;
    }
}

/*

Returns:
    ERROR_SUCCESS: Success (including not finding a.b.c.d)
    ERROR_NOT_ENOUGH_MEMORY: Failure

Notes:
    Remove the a.b.c.d string wszIpAddress from the space-separated 
    LocalAlloc'ed list *pwsz. *pwsz is LocalFree'ed and a new string 
    LocalAlloc'ed and stored in *pwsz.

*/

DWORD
RemoveWszIpAddress(
    IN  WCHAR** pwsz,
    IN  WCHAR*  wszIpAddress
)
{
    DWORD   cwchIpAddress;
    DWORD   cwchNew;
    WCHAR*  wszFound;
    WCHAR*  wszNew;
    DWORD   nFoundOffset;

    if (NULL == *pwsz)
    {
        return(ERROR_SUCCESS);
    }

    cwchIpAddress = wcslen(wszIpAddress);

    wszFound = wcsstr(*pwsz, wszIpAddress);
    if (!wszFound)
    {
        return(ERROR_SUCCESS);
    }

    if (wszFound[cwchIpAddress] == L' ')
    {
        ++cwchIpAddress;
    }

    cwchNew = wcslen(*pwsz) - cwchIpAddress + 1;
    wszNew = LocalAlloc(LPTR, cwchNew * sizeof(WCHAR));

    if (!wszNew)
    {
        TraceHlp("RemoveWszIpAddress: LocalAlloc returned NULL");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    nFoundOffset = (ULONG) (wszFound - *pwsz);
    wcsncpy(wszNew, *pwsz, nFoundOffset);
    wcscpy(wszNew + nFoundOffset, *pwsz + nFoundOffset + cwchIpAddress);

    LocalFree(*pwsz);
    *pwsz = wszNew;

    return(ERROR_SUCCESS);
}

/*

Returns:
    Win32 error code

Notes:
    Add the a.b.c.d string wszIpAddress to the front of the space-separated 
    LocalAlloc'ed list *pwsz. *pwsz is LocalFree'ed and a new string 
    LocalAlloc'ed and stored in *pwsz.

*/

DWORD
PrependWszIpAddress(
    IN  WCHAR** pwsz,
    IN  WCHAR*  wszIpAddress
)
{
    DWORD   cwchOld;
    DWORD   cwchNew;
    WCHAR*  wszNew;

    if (0 == IpAddressFromAbcdWsz(wszIpAddress))
    {
        TraceHlp("PrependWszIpAddress: Not prepending %ws", wszIpAddress);
        return(ERROR_SUCCESS);
    }

    cwchOld = *pwsz ? wcslen(*pwsz) : 0;
    cwchNew = cwchOld + wcslen(wszIpAddress) + 6;
    wszNew = LocalAlloc(LPTR, cwchNew * sizeof(WCHAR));

    if (!wszNew)
    {
        TraceHlp("PrependWszIpAddress: LocalAlloc returned NULL");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wcscpy(wszNew, wszIpAddress);

    if (cwchOld)
    {
        wcscat(wszNew, L" ");
        wcscat(wszNew, *pwsz);
        LocalFree(*pwsz);
    }

    wcscat(wszNew, L"\0");


    *pwsz = wszNew;
    return(ERROR_SUCCESS);
}

/*

Returns:
    ERROR_SUCCESS: Success (including not finding a.b.c.d)
    ERROR_NOT_ENOUGH_MEMORY: Failure

Notes:
    Remove the a.b.c.d string wszIpAddress from the LocalAlloc'ed MULTI_SZ 
    *pmwsz. *pmwsz is LocalFree'ed and a new string LocalAlloc'ed and stored in 
    *pmwsz.

*/

DWORD
RemoveWszIpAddressFromMwsz(
    IN  WCHAR** pmwsz,
    IN  WCHAR*  wszIpAddress
)
{
    DWORD   cwchIpAddress;
    DWORD   cwchNew;
    WCHAR*  wszFound;
    WCHAR*  mwszNew;
    DWORD   nFoundOffset;

    if (NULL == *pmwsz)
    {
        return(ERROR_SUCCESS);
    }

    cwchIpAddress = wcslen(wszIpAddress);

    for (wszFound = *pmwsz;
         wszFound[0] != 0;
         wszFound += wcslen(wszFound) + 1)
    {
        if (!wcscmp(wszFound, wszIpAddress))
        {
            break;
        }
    }

    if (!wszFound[0])
    {
        return(ERROR_SUCCESS);
    }

    if (wszFound[cwchIpAddress + 1] != 0)
    {
        ++cwchIpAddress;
    }

    cwchNew = MwszLength(*pmwsz) - cwchIpAddress;
    mwszNew = LocalAlloc(LPTR, cwchNew * sizeof(WCHAR));

    if (!mwszNew)
    {
        TraceHlp("RemoveWszIpAddress: LocalAlloc returned NULL");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    nFoundOffset = (ULONG) (wszFound - *pmwsz);
    CopyMemory(mwszNew, *pmwsz, nFoundOffset * sizeof(WCHAR));
    CopyMemory(mwszNew + nFoundOffset,
               *pmwsz + nFoundOffset + cwchIpAddress,
               (cwchNew - nFoundOffset) * sizeof(WCHAR));

    LocalFree(*pmwsz);
    *pmwsz = mwszNew;

    return(ERROR_SUCCESS);
}

/*

Returns:
    Win32 error code

Notes:
    Add the a.b.c.d string wszIpAddress to the front of the LocalAlloc'ed 
    MULTI_SZ *pmwsz. *pmwsz is LocalFree'ed and a new string LocalAlloc'ed and 
    stored in *pmwsz.

*/

DWORD
PrependWszIpAddressToMwsz(
    IN  WCHAR** pmwsz,
    IN  WCHAR*  wszIpAddress
)
{
    DWORD   cwchIpAddress;
    DWORD   cwchOld;
    DWORD   cwchNew;
    WCHAR*  mwszNew;

    cwchIpAddress = wcslen(wszIpAddress);

    cwchOld = *pmwsz ? MwszLength(*pmwsz) : 0;
    cwchNew = cwchOld + cwchIpAddress + 6;
    mwszNew = LocalAlloc(LPTR, cwchNew * sizeof(WCHAR));

    if (!mwszNew)
    {
        TraceHlp("PrependWszIpAddress: LocalAlloc returned NULL");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wcscpy(mwszNew, wszIpAddress);

    if (cwchOld)
    {
        CopyMemory(mwszNew + cwchIpAddress + 1, *pmwsz, cwchOld *sizeof(WCHAR));
        LocalFree(*pmwsz);
    }
    *pmwsz = mwszNew;
    return(ERROR_SUCCESS);
}

/*

Returns:
    Win32 error code

Notes:
    Add the address nboIpAddr to the front of the space-separated 
    LocalAlloc'ed list *pwsz. *pwsz is LocalFree'ed and a new string 
    LocalAlloc'ed and stored in *pwsz.

*/

DWORD
PrependDwIpAddress(
    IN  WCHAR** pwsz,
    IN  IPADDR  nboIpAddr
)
{
    WCHAR  wszIpAddress[MAXIPSTRLEN + 1];
    AbcdWszFromIpAddress(nboIpAddr, wszIpAddress);
    return(PrependWszIpAddress(pwsz, wszIpAddress));
}

/*

Returns:
    Win32 error code

Notes:
    Add the address nboIpAddr to the front of the LocalAlloc'ed MULTI_SZ 
    *pmwsz. *pmwsz is LocalFree'ed and a new string LocalAlloc'ed and stored in 
    *pmwsz.

*/

DWORD
PrependDwIpAddressToMwsz(
    IN  WCHAR** pmwsz,
    IN  IPADDR  nboIpAddr
)
{
    WCHAR  wszIpAddress[MAXIPSTRLEN + 1];
    AbcdWszFromIpAddress(nboIpAddr, wszIpAddress);
    return(PrependWszIpAddressToMwsz(pmwsz, wszIpAddress));
}

/*

Returns:
    BOOL

Description:
    Returns TRUE if there is any non zero value in pTcpipInfo. It also zeroes
    the value.

*/

BOOL
FJunkExists(
    TCPIP_INFO* pTcpipInfo
)
{
    BOOL    fRet    = FALSE;

    if (   0 != pTcpipInfo->wszIPAddress[0]
        && wcscmp(pTcpipInfo->wszIPAddress, WCH_ZEROADDRESS))
    {
        fRet = TRUE;
        pTcpipInfo->fChanged = TRUE;
        pTcpipInfo->wszIPAddress[0] = 0;
    }

    if (   0 != pTcpipInfo->wszSubnetMask[0]
        && wcscmp(pTcpipInfo->wszSubnetMask, WCH_ZEROADDRESS))
    {
        fRet = TRUE;
        pTcpipInfo->fChanged = TRUE;
        pTcpipInfo->wszSubnetMask[0] = 0;
    }

    if (   NULL != pTcpipInfo->wszDNSNameServers
        && 0 != pTcpipInfo->wszDNSNameServers[0])
    {
        fRet = TRUE;
        LocalFree(pTcpipInfo->wszDNSNameServers);
        pTcpipInfo->wszDNSNameServers = NULL;
    }

    if (   NULL != pTcpipInfo->mwszNetBIOSNameServers
        && 0 != pTcpipInfo->mwszNetBIOSNameServers[0]
        && 0 != pTcpipInfo->mwszNetBIOSNameServers[1])
    {
        fRet = TRUE;
        LocalFree(pTcpipInfo->mwszNetBIOSNameServers);
        pTcpipInfo->mwszNetBIOSNameServers = NULL;
    }

    if (   NULL != pTcpipInfo->wszDNSDomainName
        && 0 != pTcpipInfo->wszDNSDomainName[0])
    {
        fRet = TRUE;
        LocalFree(pTcpipInfo->wszDNSDomainName);
        pTcpipInfo->wszDNSDomainName = NULL;
    }

    return(fRet);
}

/*

Returns:
    VOID

Description:
    Clears up the stale information left in the regsitry when we AV or the
    machine BS's.
*/

VOID
ClearTcpipInfo(
    VOID
)
{
    LONG        lRet;
    DWORD       dwErr;
    HKEY        hKeyNdisWanIp   = NULL;
    WCHAR*      mwszAdapters    = NULL;
    WCHAR*      mwszTemp;
    WCHAR*      wszAdapterName;
    TCPIP_INFO* pTcpipInfo      = NULL;
    DWORD       dwPrefixLen     = wcslen(WCH_TCPIP_PARAM_INT_W);
    DWORD       dwStrLen;

    lRet = RegOpenKeyExW(HKEY_LOCAL_MACHINE, REGKEY_TCPIP_NDISWANIP_W, 0, 
                KEY_READ, &hKeyNdisWanIp);

    if (ERROR_SUCCESS != lRet)
    {
        goto LDone;
    }

    dwErr = RegQueryValueWithAllocW(hKeyNdisWanIp, REGVAL_IPCONFIG_W, 
                REG_MULTI_SZ, (BYTE**)&mwszAdapters);

    if (NO_ERROR != dwErr)
    {
        goto LDone;
    }

    mwszTemp = mwszAdapters;

    while (mwszTemp[0] != 0)
    {
        pTcpipInfo = NULL;

        dwStrLen = wcslen(mwszTemp);

        if (dwPrefixLen >= dwStrLen)
        {
            goto LWhileEnd;
        }

        wszAdapterName = mwszTemp + dwPrefixLen;

        RTASSERT('{' == wszAdapterName[0]);

        dwErr = LoadTcpipInfo(&pTcpipInfo, wszAdapterName, FALSE);

        if (NO_ERROR != dwErr)
        {
            goto LWhileEnd;
        }

        if (!FJunkExists(pTcpipInfo))
        {
            goto LWhileEnd;
        }

        dwErr = SaveTcpipInfo(pTcpipInfo);

        if (NO_ERROR != dwErr)
        {
            goto LWhileEnd;
        }

        TraceHlp("Clearing Tcpip info for adapter %ws", wszAdapterName);

        dwErr = PDhcpNotifyConfigChange(NULL, wszAdapterName, TRUE, 0, 
                    0, 0, IgnoreFlag);

LWhileEnd:

        if (NULL != pTcpipInfo)
        {
            FreeTcpipInfo(&pTcpipInfo);
        }

        mwszTemp = mwszTemp + dwStrLen + 1;
    }

LDone:

    if (NULL != hKeyNdisWanIp)
    {
        RegCloseKey(hKeyNdisWanIp);
    }

    LocalFree(mwszAdapters);
}

/*

Returns:
    Win32 error code

Description:
    Frees the TCPIP_INFO buffer.

*/

DWORD
FreeTcpipInfo(
    IN  TCPIP_INFO**    ppTcpipInfo
)
{
    if (NULL == *ppTcpipInfo)
    {
        return(NO_ERROR);
    }
    TraceHlp("Freeing Tcpip info for adapter %ws", (*ppTcpipInfo)->wszAdapterName);
    LocalFree((*ppTcpipInfo)->wszAdapterName);
    LocalFree((*ppTcpipInfo)->mwszNetBIOSNameServers);
    LocalFree((*ppTcpipInfo)->wszDNSDomainName);
    LocalFree((*ppTcpipInfo)->wszDNSNameServers);
    LocalFree(*ppTcpipInfo);

    *ppTcpipInfo = NULL;

    return(NO_ERROR);
}

/*

Returns:
    Win32 error code

Description:
    Reads NETBT information for the adapter pTcpipInfo->wszAdapterName from
    the registry.

*/

DWORD
LoadWinsParam(
    IN  HKEY        hKeyWinsParam,
    IN  TCPIP_INFO* pTcpipInfo
)
{
    HKEY    hKeyInterfaces      = NULL;
    HKEY    hKeyInterfaceParam  = NULL;
    WCHAR*  wszNetBtBindPath    = NULL;

    DWORD   dwStrLenTcpip_;
    DWORD   dwStrLenTcpipBindPath;

    DWORD   dwErr               = ERROR_SUCCESS;

    RTASSERT(NULL != pTcpipInfo);
    RTASSERT(NULL != pTcpipInfo->wszAdapterName);
    RTASSERT(NULL == pTcpipInfo->mwszNetBIOSNameServers);

    dwErr = RegOpenKeyExW(hKeyWinsParam,
                          REGKEY_INTERFACES_W,
                          0,
                          KEY_READ,
                          &hKeyInterfaces);

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
              REGKEY_INTERFACES_W, dwErr);

        goto LDone;
    }

    dwStrLenTcpip_ = wcslen(WCH_TCPIP_);
    dwStrLenTcpipBindPath = wcslen(pTcpipInfo->wszAdapterName);

    wszNetBtBindPath = LocalAlloc(
            LPTR, (dwStrLenTcpip_ + dwStrLenTcpipBindPath + 1) * sizeof(WCHAR));

    if (NULL == wszNetBtBindPath)
    {
        dwErr = GetLastError();
        TraceHlp("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    wcscpy(wszNetBtBindPath, WCH_TCPIP_);
    wcscat(wszNetBtBindPath, pTcpipInfo->wszAdapterName);

    dwErr = RegOpenKeyExW(hKeyInterfaces,
                          wszNetBtBindPath,
                          0,
                          KEY_READ,
                          &hKeyInterfaceParam);

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
              wszNetBtBindPath, dwErr);

        goto LDone;
    }

    // Its OK if we cannot find the value. Ignore the error.
    RegQueryValueWithAllocW(hKeyInterfaceParam,
        REGVAL_NAMESERVERLIST_W,
        REG_MULTI_SZ,
        (BYTE**)&(pTcpipInfo->mwszNetBIOSNameServers));

LDone:

    LocalFree(wszNetBtBindPath);

    if (NULL != hKeyInterfaces)
    {
        RegCloseKey(hKeyInterfaces);
    }

    if (NULL != hKeyInterfaceParam)
    {
        RegCloseKey(hKeyInterfaceParam);
    }

    if (NO_ERROR != dwErr)
    {
        LocalFree(pTcpipInfo->mwszNetBIOSNameServers);
        pTcpipInfo->mwszNetBIOSNameServers = NULL;
    }

    return(dwErr);
}

/*

Returns:
    Win32 error code

Description:
    Reads TCPIP information for the adapter pTcpipInfo->wszAdapterName from
    the registry.

*/

DWORD
LoadTcpipParam(
    IN  HKEY        hKeyTcpipParam,
    IN  TCPIP_INFO* pTcpipInfo
)
{
    HKEY            hKeyInterfaces      = NULL;
    HKEY            hKeyInterfaceParam  = NULL;

    DWORD           dwType;
    DWORD           dwSize;

    DWORD           dwErr               = ERROR_SUCCESS;

    RTASSERT(NULL != pTcpipInfo);
    RTASSERT(NULL != pTcpipInfo->wszAdapterName);
    _wcslwr(pTcpipInfo->wszAdapterName);

    RTASSERT(0 == pTcpipInfo->wszIPAddress[0]);
    RTASSERT(0 == pTcpipInfo->wszSubnetMask[0]);
    RTASSERT(NULL == pTcpipInfo->wszDNSDomainName);
    RTASSERT(NULL == pTcpipInfo->wszDNSNameServers);

    dwErr = RegOpenKeyExW(hKeyTcpipParam,
                          REGKEY_INTERFACES_W,
                          0,
                          KEY_READ,
                          &hKeyInterfaces);

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
              REGKEY_INTERFACES_W, dwErr);
        goto LDone;
    }

    // Open subkey for this adapter under "Interfaces"
    dwErr = RegOpenKeyExW(hKeyInterfaces,
                          pTcpipInfo->wszAdapterName,
                          0,
                          KEY_READ,
                          &hKeyInterfaceParam);

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
              pTcpipInfo->wszAdapterName, dwErr);
        goto LDone;
    }

    dwSize = sizeof(pTcpipInfo->wszIPAddress);

    // Its OK if we cannot find the value. Ignore the error.
    dwErr = RegQueryValueExW(hKeyInterfaceParam,
                                REGVAL_DHCPIPADDRESS_W,
                                NULL,
                                &dwType,
                                (BYTE*)pTcpipInfo->wszIPAddress,
                                &dwSize);

    if (ERROR_SUCCESS != dwErr || REG_SZ != dwType)
    {
        dwErr = ERROR_SUCCESS;
        RTASSERT(0 == pTcpipInfo->wszIPAddress[0]);
        pTcpipInfo->wszIPAddress[0] = 0;
    }

    dwSize = sizeof(pTcpipInfo->wszSubnetMask);

    // Its OK if we cannot find the value. Ignore the error.
    dwErr = RegQueryValueExW(hKeyInterfaceParam,
                                REGVAL_DHCPSUBNETMASK_W,
                                NULL,
                                &dwType,
                                (BYTE*)pTcpipInfo->wszSubnetMask,
                                &dwSize);

    if (ERROR_SUCCESS != dwErr || REG_SZ != dwType)
    {
        dwErr = ERROR_SUCCESS;
        RTASSERT(0 == pTcpipInfo->wszSubnetMask[0]);
        pTcpipInfo->wszSubnetMask[0] = 0;

        // No point in having a valid IP address with an invalid mask.
        pTcpipInfo->wszIPAddress[0] = 0;
    }

    // Its OK if we cannot find the value. Ignore the error.
    RegQueryValueWithAllocW(hKeyInterfaceParam,
        REGVAL_DOMAIN_W,
        REG_SZ,
        (BYTE**)&(pTcpipInfo->wszDNSDomainName));

    // Its OK if we cannot find the value. Ignore the error.
    RegQueryValueWithAllocW(hKeyInterfaceParam,
        REGVAL_NAMESERVER_W,
        REG_SZ,
        (BYTE**)&(pTcpipInfo->wszDNSNameServers));

LDone:

    if (NULL != hKeyInterfaces)
    {
        RegCloseKey(hKeyInterfaces);
    }

    if (NULL != hKeyInterfaceParam)
    {
        RegCloseKey(hKeyInterfaceParam);
    }

    if (ERROR_SUCCESS != dwErr)
    {
        LocalFree(pTcpipInfo->wszDNSDomainName);
        pTcpipInfo->wszDNSDomainName = NULL;

        LocalFree(pTcpipInfo->wszDNSNameServers);
        pTcpipInfo->wszDNSNameServers = NULL;
    }

    return(dwErr);
}

/*

Returns:
    Win32 error code

Description:
    If fAdapterOnly is FALSE, reads NETBT and TCPIP information for the adapter
    wszAdapterName from the registry. *ppTcpipInfo must ultimately be freed by 
    calling FreeTcpipInfo(). 

*/

DWORD
LoadTcpipInfo(
    IN  TCPIP_INFO**    ppTcpipInfo,
    IN  WCHAR*          wszAdapterName,
    IN  BOOL            fAdapterOnly
)
{
    HKEY                hKeyTcpipParam  = NULL;
    HKEY                hKeyWinsParam   = NULL;

    DWORD               dwErr           = ERROR_SUCCESS;

    RTASSERT(NULL != wszAdapterName);

    if (NULL == wszAdapterName)
    {
        dwErr = E_FAIL;
        TraceHlp("wszAdapterName is NULL");
        goto LDone;
    }

    *ppTcpipInfo = NULL;

    *ppTcpipInfo = LocalAlloc(LPTR, sizeof(TCPIP_INFO));

    if (NULL == *ppTcpipInfo)
    {
        dwErr = GetLastError();
        TraceHlp("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    (*ppTcpipInfo)->wszAdapterName = LocalAlloc(
                LPTR, (wcslen(wszAdapterName) + 1) * sizeof(WCHAR));

    if (NULL == (*ppTcpipInfo)->wszAdapterName)
    {
        dwErr = GetLastError();
        TraceHlp("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    wcscpy((*ppTcpipInfo)->wszAdapterName, wszAdapterName);

    if (fAdapterOnly)
    {
        goto LDone;
    }

    dwErr = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                          REGKEY_TCPIP_PARAM_W,
                          0,
                          KEY_READ,
                          &hKeyTcpipParam);

    if (ERROR_SUCCESS != dwErr)
    {
        if (ERROR_FILE_NOT_FOUND == dwErr)
        {
            // Mask the error
            dwErr = ERROR_SUCCESS;
        }
        else
        {
            TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
                  REGKEY_TCPIP_PARAM_W, dwErr);
            goto LDone;
        }
    }
    else
    {
        dwErr = LoadTcpipParam(hKeyTcpipParam, *ppTcpipInfo);

        if (ERROR_SUCCESS != dwErr)
        {
            goto LDone;
        }
    }

    // Open NETBT's parameters key

    dwErr = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                          REGKEY_NETBT_PARAM_W,
                          0,
                          KEY_READ,
                          &hKeyWinsParam);

    if (ERROR_SUCCESS != dwErr)
    {
        if (ERROR_FILE_NOT_FOUND == dwErr)
        {
            // Mask the error
            dwErr = ERROR_SUCCESS;
        }
        else
        {
            TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
                  REGKEY_NETBT_PARAM_W, dwErr);
            goto LDone;
        }
    }
    else
    {
        dwErr = LoadWinsParam(hKeyWinsParam, *ppTcpipInfo);

        if (ERROR_SUCCESS != dwErr)
        {
            goto LDone;
        }
    }

LDone:

    if (NULL != hKeyTcpipParam)
    {
        RegCloseKey(hKeyTcpipParam);
    }

    if (NULL != hKeyWinsParam)
    {
        RegCloseKey(hKeyWinsParam);
    }

    if (ERROR_SUCCESS != dwErr)
    {
        FreeTcpipInfo(ppTcpipInfo);
    }

    return(dwErr);
}

/*

Returns:
    Win32 error code

Description:
    Saves NETBT information for the adapter pTcpipInfo->wszAdapterName to
    the registry.

*/

DWORD
SaveWinsParam(
    IN  HKEY        hKeyWinsParam,
    IN  TCPIP_INFO* pTcpipInfo
)
{
    HKEY    hKeyInterfaces          = NULL;
    HKEY    hKeyInterfaceParam      = NULL;
    WCHAR*  wszNetBtBindPath        = NULL;

    DWORD   dwStrLenTcpip_;
    DWORD   dwStrLenAdapterName;

    WCHAR*  mwszData                = NULL;
    WCHAR   mwszBlank[2];

    DWORD   dw;
    DWORD   dwErr                   = ERROR_SUCCESS;

    RTASSERT(NULL != pTcpipInfo);
    RTASSERT(NULL != pTcpipInfo->wszAdapterName);

    dwErr = RegOpenKeyExW(hKeyWinsParam,
                          REGKEY_INTERFACES_W,
                          0,
                          KEY_WRITE,
                          &hKeyInterfaces);

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
              REGKEY_INTERFACES_W, dwErr);

        goto LDone;
    }

    dwStrLenTcpip_ = wcslen(WCH_TCPIP_);
    dwStrLenAdapterName = wcslen(pTcpipInfo->wszAdapterName);

    wszNetBtBindPath = LocalAlloc(
            LPTR, (dwStrLenTcpip_ + dwStrLenAdapterName + 1) * sizeof(WCHAR));

    if (NULL == wszNetBtBindPath)
    {
        dwErr = GetLastError();
        TraceHlp("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    wcscpy(wszNetBtBindPath, WCH_TCPIP_);
    wcscat(wszNetBtBindPath, pTcpipInfo->wszAdapterName);

    dwErr = RegOpenKeyExW(hKeyInterfaces,
                          wszNetBtBindPath,
                          0,
                          KEY_WRITE,
                          &hKeyInterfaceParam);

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
              wszNetBtBindPath, dwErr);

        goto LDone;
    }

    if (pTcpipInfo->fDisableNetBIOSoverTcpip)
    {
        dw = REGVAL_DISABLE_NETBT;

        dwErr = RegSetValueExW(hKeyInterfaceParam,
                               REGVAL_NETBIOSOPTIONS_W,
                               0,
                               REG_DWORD,
                               (BYTE*)&dw,
                               sizeof(DWORD));

        if (ERROR_SUCCESS != dwErr)
        {
            TraceHlp("RegSetValueEx(%ws) failed: %d",
                  REGVAL_NETBIOSOPTIONS_W, dwErr);

            dwErr = NO_ERROR;   // Ignore this error
        }
    }
    else
    {
        dwErr = RegDeleteValueW(hKeyInterfaceParam, REGVAL_NETBIOSOPTIONS_W);

        if (ERROR_SUCCESS != dwErr)
        {
            TraceHlp("RegDeleteValue(%ws) failed: %d",
                  REGVAL_NETBIOSOPTIONS_W, dwErr);

            dwErr = NO_ERROR;   // Ignore this error
        }
    }

    if (NULL == pTcpipInfo->mwszNetBIOSNameServers)
    {
        ZeroMemory(mwszBlank, sizeof(mwszBlank));
        mwszData = mwszBlank;
    }
    else
    {
        mwszData = pTcpipInfo->mwszNetBIOSNameServers;
    }

    dwErr = RegSetValueExW(hKeyInterfaceParam,
                           REGVAL_NAMESERVERLIST_W,
                           0,
                           REG_MULTI_SZ,
                           (BYTE*)mwszData,
                           sizeof(WCHAR) * MwszLength(mwszData));

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("RegSetValueEx(%ws) failed and returned %d",
              REGVAL_NAMESERVERLIST_W, dwErr);

        goto LDone;
    }

LDone:

    LocalFree(wszNetBtBindPath);

    if (NULL != hKeyInterfaceParam)
    {
        RegCloseKey(hKeyInterfaceParam);
    }

    if (NULL != hKeyInterfaces)
    {
        RegCloseKey(hKeyInterfaces);
    }

    return(dwErr);
}

/*

Returns:
    Win32 error code

Description:
    Saves TCPIP information for the adapter pTcpipInfo->wszAdapterName to
    the registry.

*/

DWORD
SaveTcpipParam(
    IN  HKEY        hKeyTcpipParam,
    IN  TCPIP_INFO* pTcpipInfo
)
{
    HKEY            hKeyInterfaces                      = NULL;
    HKEY            hKeyInterfaceParam                  = NULL;
    DWORD           dwLength;
    WCHAR           mwszZeroAddress[MAXIPSTRLEN + 1];

    WCHAR*          wszData                             = NULL;
    WCHAR           wszBlank[2];

    DWORD           dwErr                               = ERROR_SUCCESS;

    RTASSERT(NULL != pTcpipInfo);
    RTASSERT(NULL != pTcpipInfo->wszAdapterName);
    _wcslwr(pTcpipInfo->wszAdapterName);

    dwErr = RegOpenKeyExW(hKeyTcpipParam,
                          REGKEY_INTERFACES_W,
                          0,
                          KEY_WRITE,
                          &hKeyInterfaces);

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
              REGKEY_INTERFACES_W, dwErr);
        goto LDone;
    }

    // Open subkey for this adapter under "Interfaces"
    dwErr = RegOpenKeyExW(hKeyInterfaces,
                          pTcpipInfo->wszAdapterName,
                          0,
                          KEY_WRITE,
                          &hKeyInterfaceParam);

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
              pTcpipInfo->wszAdapterName, dwErr);
        goto LDone;
    }

    // If fChanged is set
    if (pTcpipInfo->fChanged == TRUE)
    {
        if (   0 == pTcpipInfo->wszIPAddress[0]
            || 0 == pTcpipInfo->wszSubnetMask[0])
        {
            RTASSERT(wcslen(WCH_ZEROADDRESS) <= MAXIPSTRLEN);
            wcscpy(pTcpipInfo->wszIPAddress, WCH_ZEROADDRESS);
            wcscpy(pTcpipInfo->wszSubnetMask, WCH_ZEROADDRESS);
        }

        dwErr = RegSetValueExW(hKeyInterfaceParam,
                    REGVAL_DHCPIPADDRESS_W,
                    0,
                    REG_SZ,
                    (BYTE*)pTcpipInfo->wszIPAddress,
                    sizeof(WCHAR) * wcslen(pTcpipInfo->wszIPAddress));

        if (ERROR_SUCCESS != dwErr)
        {
            TraceHlp("RegSetValueEx(%ws) failed and returned %d",
                  REGVAL_DHCPIPADDRESS_W, dwErr);

            goto LDone;
        }

        dwErr = RegSetValueExW(hKeyInterfaceParam,
                    REGVAL_DHCPSUBNETMASK_W,
                    0,
                    REG_SZ,
                    (BYTE*)pTcpipInfo->wszSubnetMask,
                    sizeof(WCHAR) *
                        wcslen(pTcpipInfo->wszSubnetMask));

        if (ERROR_SUCCESS != dwErr)
        {
            TraceHlp("RegSetValueEx(%ws) failed and returned %d",
                  REGVAL_DHCPSUBNETMASK_W, dwErr);

            goto LDone;
        }
    } // if fChanged = TRUE

    ZeroMemory(wszBlank, sizeof(wszBlank));

    if (NULL == pTcpipInfo->wszDNSDomainName)
    {
        wszData = wszBlank;
    }
    else
    {
        wszData = pTcpipInfo->wszDNSDomainName;
    }

    dwErr = RegSetValueExW(hKeyInterfaceParam, 
                           REGVAL_DOMAIN_W,
                           0,
                           REG_SZ,
                           (BYTE*)wszData,
                           sizeof(WCHAR) * (wcslen(wszData) + 1));

    if (ERROR_SUCCESS != dwErr)
    {
        TraceHlp("RegSetValueEx(%ws) failed and returned %d",
              REGVAL_DOMAIN_W, dwErr);

        goto LDone;
    }

    if (NULL == pTcpipInfo->wszDNSNameServers)
    {
        wszData = wszBlank;
    }
    else
    {
        wszData = pTcpipInfo->wszDNSNameServers;
    }

    // Check whether the value starts with a space.
    // If so, delete the key. Otherwise save the value.
    if (WCH_SPACE != wszData[0])
    {
        dwErr = RegSetValueExW(hKeyInterfaceParam, 
                               REGVAL_NAMESERVER_W,
                               0,
                               REG_SZ,
                               (BYTE*)wszData,
                               sizeof(WCHAR) * (wcslen(wszData) + 1));

        if (ERROR_SUCCESS != dwErr)
        {
            TraceHlp("RegSetValueEx(%ws) failed and returned %d",
                  REGVAL_NAMESERVER_W, dwErr);

            goto LDone;
        }
    }
    else
    {
        dwErr = RegDeleteValueW(hKeyInterfaceParam, REGVAL_NAMESERVER_W);

        if (ERROR_SUCCESS != dwErr)
        {
            TraceHlp("RegDeleteValue(%ws) failed and returned %d",
                  REGVAL_NAMESERVER_W, dwErr);

            goto LDone;
        }
    }

LDone:

    if (NULL != hKeyInterfaceParam)
    {
        RegCloseKey(hKeyInterfaceParam);
    }

    if (NULL != hKeyInterfaces)
    {
        RegCloseKey(hKeyInterfaces);
    }

    return(dwErr);
}

/*

Returns:
    Win32 error code

Description:
    Saves NETBT and TCPIP information for the adapter
    pTcpipInfo->wszAdapterName to the registry.

*/

DWORD
SaveTcpipInfo(
    IN  TCPIP_INFO* pTcpipInfo
)
{
    HKEY            hKeyTcpipParam  = NULL;
    HKEY            hKeyWinsParam   = NULL;

    DWORD           dwErr           = ERROR_SUCCESS;

    RTASSERT(NULL != pTcpipInfo);

    if (   (NULL == pTcpipInfo)
        || (NULL == pTcpipInfo->wszAdapterName))
    {
        dwErr = E_FAIL;
        TraceHlp("pTcpipInfo or wszAdapterName is NULL");
        goto LDone;
    }

    dwErr = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                          REGKEY_TCPIP_PARAM_W,
                          0,
                          KEY_WRITE,
                          &hKeyTcpipParam);

    if (ERROR_SUCCESS != dwErr)
    {
        if (ERROR_FILE_NOT_FOUND == dwErr)
        {
            // Mask the error
            dwErr = ERROR_SUCCESS;
        }
        else
        {
            TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
                  REGKEY_TCPIP_PARAM_W, dwErr);
            goto LDone;
        }
    }
    else
    {
        dwErr = SaveTcpipParam(hKeyTcpipParam, pTcpipInfo);

        if (ERROR_SUCCESS != dwErr)
        {
            goto LDone;
        }
    }

    // Open NETBT's parameters key

    dwErr = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                          REGKEY_NETBT_PARAM_W,
                          0,
                          KEY_WRITE,
                          &hKeyWinsParam);

    if (ERROR_SUCCESS != dwErr)
    {
        if (ERROR_FILE_NOT_FOUND == dwErr)
        {
            // Mask the error
            dwErr = ERROR_SUCCESS;
        }
        else
        {
            TraceHlp("RegOpenKeyEx(%ws) failed and returned %d",
                  REGKEY_NETBT_PARAM_W, dwErr);
            goto LDone;
        }
    }
    else
    {
        dwErr = SaveWinsParam(hKeyWinsParam, pTcpipInfo);

        if (ERROR_SUCCESS != dwErr)
        {
            goto LDone;
        }
    }

LDone:

    if (NULL != hKeyTcpipParam)
    {
        RegCloseKey(hKeyTcpipParam);
    }

    if (NULL != hKeyWinsParam)
    {
        RegCloseKey(hKeyWinsParam);
    }

    return(dwErr);
}

/*

Returns:
    Win32 error code

Notes:

*/

DWORD
GetAdapterInfo(
    IN  DWORD       dwIndex,
    OUT IPADDR*     pnboIpAddress,
    OUT IPADDR*     pnboDNS1,
    OUT IPADDR*     pnboDNS2,
    OUT IPADDR*     pnboWINS1,
    OUT IPADDR*     pnboWINS2,
    OUT IPADDR*     pnboGateway,
    OUT BYTE*       pbAddress
)
{
    IP_ADAPTER_INFO*        pAdapterInfo    = NULL;
    IP_ADAPTER_INFO*        pAdapter;
    IP_PER_ADAPTER_INFO*    pPerAdapterInfo = NULL;
    DWORD                   dwSize;
    DWORD                   dw;
    IPADDR                  nboIpAddress    = 0;
    IPADDR                  nboDNS1         = 0;
    IPADDR                  nboDNS2         = 0;
    IPADDR                  nboWINS1        = 0;
    IPADDR                  nboWINS2        = 0;
    IPADDR                  nboGateway      = 0;
    BYTE                    bAddress[MAX_ADAPTER_ADDRESS_LENGTH];
    DWORD                   dwErr           = NO_ERROR;

    TraceHlp("GetAdapterInfo");

    dwSize = 0;

    dwErr = PGetAdaptersInfo(NULL, &dwSize);

    if (ERROR_BUFFER_OVERFLOW != dwErr && NO_ERROR != dwErr )
    {
        TraceHlp("GetAdaptersInfo failed and returned %d", dwErr);
        goto LDone;
    }

    pAdapterInfo = LocalAlloc(LPTR, dwSize);

    if (NULL == pAdapterInfo)
    {
        dwErr = GetLastError();
        TraceHlp("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    dwErr = PGetAdaptersInfo(pAdapterInfo, &dwSize);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("GetAdaptersInfo failed and returned %d", dwErr);
        goto LDone;
    }

    pAdapter = pAdapterInfo;

    while (pAdapter)
    {
        if (pAdapter->Index != dwIndex)
        {
            pAdapter = pAdapter->Next;
            continue;
        }

        break;
    }

    if (NULL == pAdapter)
    {
        TraceHlp("Couldn't get info for the adapter");
        dwErr = ERROR_NOT_FOUND;
        goto LDone;
    }

    nboIpAddress = inet_addr(pAdapter->IpAddressList.IpAddress.String);

    nboGateway = inet_addr(pAdapter->GatewayList.IpAddress.String);

    if (pAdapter->HaveWins)
    {
        nboWINS1 = inet_addr(pAdapter->PrimaryWinsServer.IpAddress.String);
        nboWINS2 = inet_addr(pAdapter->SecondaryWinsServer.IpAddress.String);
    }

    for (dw = 0;
         dw < pAdapter->AddressLength, dw < MAX_ADAPTER_ADDRESS_LENGTH;
         dw++)
    {
        bAddress[dw] = pAdapter->Address[dw];
    }

    dwSize = 0;

    dwErr = PGetPerAdapterInfo(dwIndex, NULL, &dwSize);

    if (ERROR_BUFFER_OVERFLOW != dwErr)
    {
        TraceHlp("GetPerAdapterInfo failed and returned %d", dwErr);
        goto LDone;
    }

    pPerAdapterInfo = LocalAlloc(LPTR, dwSize);

    if (NULL == pPerAdapterInfo)
    {
        dwErr = GetLastError();
        TraceHlp("LocalAlloc failed and returned %d", dwErr);
        goto LDone;
    }

    dwErr = PGetPerAdapterInfo(dwIndex, pPerAdapterInfo, &dwSize);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("GetPerAdapterInfo failed and returned %d", dwErr);
        goto LDone;
    }

    if (NULL == pPerAdapterInfo)
    {
        TraceHlp("Couldn't get per adapter info for the adapter");
        dwErr = ERROR_NOT_FOUND;
        goto LDone;
    }

    nboDNS1 = inet_addr(pPerAdapterInfo->DnsServerList.IpAddress.String);

    if (NULL != pPerAdapterInfo->DnsServerList.Next)
    {
        nboDNS2 =
            inet_addr(pPerAdapterInfo->DnsServerList.Next->IpAddress.String);
    }

    if (   (0 == nboIpAddress)
        || (INADDR_NONE == nboIpAddress))
    {
        TraceHlp("Couldn't get IpAddress for the adapter");
        dwErr = ERROR_NOT_FOUND;
        goto LDone;
    }

    if(INADDR_NONE == nboGateway)
    {
        nboGateway = 0;
    }

    if (INADDR_NONE == nboDNS1)
    {
        nboDNS1 = 0;
    }

    if (INADDR_NONE == nboDNS2)
    {
        nboDNS2 = 0;
    }

    if (INADDR_NONE == nboWINS1)
    {
        nboWINS1 = 0;
    }

    if (INADDR_NONE == nboWINS2)
    {
        nboWINS2 = 0;
    }

LDone:

    if (NO_ERROR != dwErr)
    {
        nboIpAddress = nboGateway = nboDNS1 = nboDNS2 
                    = nboWINS1 = nboWINS2 = 0;
        ZeroMemory(bAddress, MAX_ADAPTER_ADDRESS_LENGTH);
    }

    if (pnboIpAddress)
    {
        *pnboIpAddress = nboIpAddress;
    }

    if (pnboDNS1)
    {
        *pnboDNS1 = nboDNS1;
    }

    if (pnboDNS2)
    {
        *pnboDNS2 = nboDNS2;
    }

    if (pnboWINS1)
    {
        *pnboWINS1 = nboWINS1;
    }

    if (pnboWINS2)
    {
        *pnboWINS2 = nboWINS2;
    }

    if (pbAddress)
    {
        CopyMemory(pbAddress, bAddress, MAX_ADAPTER_ADDRESS_LENGTH);
    }

    if(pnboGateway)
    {
        *pnboGateway = nboGateway;
    }

    LocalFree(pAdapterInfo);
    LocalFree(pPerAdapterInfo);

    return(dwErr);
}

/*

Returns:
    Win32 error code

Description:
    Don't cache these values because DHCP leases may have expired, etc

*/

DWORD
GetPreferredAdapterInfo(
    OUT IPADDR*     pnboIpAddress,
    OUT IPADDR*     pnboDNS1,
    OUT IPADDR*     pnboDNS2,
    OUT IPADDR*     pnboWINS1,
    OUT IPADDR*     pnboWINS2,
    OUT BYTE*       pbAddress
)
{
    HANDLE                  hHeap           = NULL;
    IP_INTERFACE_NAME_INFO* pTable          = NULL;
    DWORD                   dw;
    DWORD                   dwCount;
    DWORD                   dwIndex         = (DWORD)-1;
    DWORD                   dwErr           = NO_ERROR;

    TraceHlp("GetPreferredAdapterInfo");

    hHeap = GetProcessHeap();

    if (NULL == hHeap)
    {
        dwErr = GetLastError();
        TraceHlp("GetProcessHeap failed and returned %d", dwErr);
        goto LDone;
    }

    dwErr = PNhpAllocateAndGetInterfaceInfoFromStack(&pTable, &dwCount,
                FALSE /* bOrder */, hHeap, LPTR);

    if (NO_ERROR != dwErr)
    {
        TraceHlp("NhpAllocateAndGetInterfaceInfoFromStack failed and "
            "returned %d", dwErr);
        goto LDone;
    }

    for (dw = 0; dw < dwCount; dw++)
    {
        // Only interested in NICs

        if (IF_CONNECTION_DEDICATED != pTable[dw].ConnectionType)
        {
            continue;
        }

        // If the admin wants to use a particular NIC

        if (   HelperRegVal.fNICChosen
            && (!IsEqualGUID(&(HelperRegVal.guidChosenNIC),
                             &(pTable[dw].DeviceGuid))))
        {
            continue;
        }

        dwIndex = pTable[dw].Index;
        break;
    }

    if ((DWORD)-1 == dwIndex)
    {
        if (HelperRegVal.fNICChosen)
        {
            // The chosen NIC is not available. Let us choose another one.

            for (dw = 0; dw < dwCount; dw++)
            {
                // Only interested in NICs

                if (IF_CONNECTION_DEDICATED != pTable[dw].ConnectionType)
                {
                    continue;
                }

                dwIndex = pTable[dw].Index;
                break;
            }
        }

        if ((DWORD)-1 == dwIndex)
        {
            TraceHlp("Couldn't find an appropriate NIC");
            dwErr = ERROR_NOT_FOUND;
            goto LDone;
        }

        HelperRegVal.fNICChosen = FALSE;

        TraceHlp("The network adapter chosen by the administrator is not "
            "available. Some other adapter will be used.");
    }

    dwErr = GetAdapterInfo(
                dwIndex,
                pnboIpAddress,
                pnboDNS1, pnboDNS2,
                pnboWINS1, pnboWINS2,
                NULL,
                pbAddress);

LDone:

    if (NULL != pTable)
    {
        HeapFree(hHeap, 0, pTable);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\timer.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _TIMER_H_
#define _TIMER_H_

typedef VOID (*TIMERFUNCTION) (IN HANDLE, IN struct _TimerList* pTimer);

typedef struct _TimerList
{
   struct _TimerList*   tmr_Next;
   LONG                 tmr_Delta;
   TIMERFUNCTION        tmr_TimerFunc;

} TIMERLIST;

DWORD
RasDhcpTimerInitialize(
    VOID
);

VOID
RasDhcpTimerUninitialize(
    VOID
);

VOID
RasDhcpTimerFunc(
    IN  VOID*   pArg1,
    IN  BOOLEAN fArg2
);

VOID
RasDhcpTimerSchedule(
    IN  TIMERLIST*      pNewTimer,
    IN  LONG            DeltaTime,
    IN  TIMERFUNCTION   TimerFunc
);

VOID
RasDhcpTimerRunNow(
    VOID
);

#endif // #ifndef _TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\timer.c ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#include "timer_.h"

LONG			g_TimerLockUninit = 0;
/*

Returns:
    Win 32 error

Notes:
    Its a good idea to always call RasDhcpTimerUninitialize after calling 
    RasDhcpTimerInitialize, even if RasDhcpTimerInitialize failed.

*/

DWORD
RasDhcpTimerInitialize(
    VOID
)
{
    NTSTATUS    Status;
    DWORD       dwErr           = NO_ERROR;

	g_TimerLockUninit = 0;
    RasDhcpTimerShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (NULL == RasDhcpTimerShutdown)
    {
        dwErr = GetLastError();
        goto LEnd;
    }

    Status = RtlCreateTimerQueue(&RasDhcpTimerQueueHandle);

    if (STATUS_SUCCESS != Status)
    {
        RasDhcpTimerQueueHandle = NULL;
        dwErr = Status;
        TraceHlp("RtlCreateTimerQueue failed and returned %d", dwErr);
        goto LEnd;
    }

    RasDhcpTimerPrevTime = time(NULL);
    Status = RtlCreateTimer(RasDhcpTimerQueueHandle, &RasDhcpTimerHandle, 
                RasDhcpTimerFunc, NULL, 0, TIMER_PERIOD,
                WT_EXECUTELONGFUNCTION);

    if (STATUS_SUCCESS != Status)
    {
        dwErr = Status;
        TraceHlp("RtlCreateTimer failed and returned %d", dwErr);
        goto LEnd;
    }

LEnd:

    if (NO_ERROR != dwErr)
    {
        if (NULL != RasDhcpTimerQueueHandle)
        {
            Status = RtlDeleteTimerQueueEx(RasDhcpTimerQueueHandle, (HANDLE)-1);
            RTASSERT(STATUS_SUCCESS == Status);
            RasDhcpTimerQueueHandle = NULL;
        }

        if (NULL != RasDhcpTimerShutdown)
        {
            CloseHandle(RasDhcpTimerShutdown);
            RasDhcpTimerShutdown = NULL;
        }
    }

    return(dwErr);
}

/*

Returns:
    VOID

Notes:
    RasDhcpTimerUninitialize can be called even if  RasDhcpTimerInitialize
    failed.

*/

VOID
RasDhcpTimerUninitialize(
    VOID
)
{
    NTSTATUS    Status;
    DWORD       dwRet;
	LONG		lPrev = 1;


    // Signal the timer thread to shutdown.
	lPrev = InterlockedExchangeAdd(&g_TimerLockUninit, 1);
	if ( lPrev > 1 )
		return;

    if (NULL != RasDhcpTimerQueueHandle)
    {
        RTASSERT(NULL != RasDhcpTimerShutdown);
        SetEvent(RasDhcpTimerShutdown);

        Status = RtlDeleteTimerQueueEx(RasDhcpTimerQueueHandle, (HANDLE)-1);
        RTASSERT(STATUS_SUCCESS == Status);
        RasDhcpTimerQueueHandle = NULL;
    }

    if (NULL != RasDhcpTimerShutdown)
    {
        CloseHandle(RasDhcpTimerShutdown);
        RasDhcpTimerShutdown = NULL;
    }

    // timer.c didn't alloc the nodes in the linked list.
    // So we don't free them here.
    RasDhcpTimerListHead = NULL;
}

/*

Returns:

Notes:

*/

VOID
RasDhcpTimerFunc(
    IN  VOID*   pArg1,
    IN  BOOLEAN fArg2
)
{
    TIMERLIST*      pTimer;
    TIMERLIST*      pTmp;
    TIMERFUNCTION   TimerFunc;
    time_t          now             = time(NULL);
    LONG            lElapsedTime;
    LONG            lTime;

    if (0 == TryEnterCriticalSection(&RasTimrCriticalSection))
    {
        // Another thread already owns the critical section
        return;
    }

    lElapsedTime = (LONG)(now - RasDhcpTimerPrevTime);
    RasDhcpTimerPrevTime = now;

    pTimer = NULL;

    while (RasDhcpTimerListHead != NULL)
    {
        lTime = RasDhcpTimerListHead->tmr_Delta;

        if ( lTime > 0)
        {
            RasDhcpTimerListHead->tmr_Delta -= lElapsedTime;
            lElapsedTime -= lTime;
        }

        if (RasDhcpTimerListHead->tmr_Delta <= 0)
        {
            pTmp = pTimer;
            pTimer = RasDhcpTimerListHead;
            RasDhcpTimerListHead = pTimer->tmr_Next;
            pTimer->tmr_Next = pTmp;
        }
        else
        {
            break;
        }
    }

    while (pTimer != NULL)
    {
        pTmp = pTimer->tmr_Next;
        TimerFunc = pTimer->tmr_TimerFunc;
        pTimer->tmr_TimerFunc = NULL;
        (*TimerFunc)(RasDhcpTimerShutdown, pTimer);
        pTimer = pTmp;
    }

    LeaveCriticalSection(&RasTimrCriticalSection);
}

/*

Returns:
    VOID

Notes:
    Once the timer thread starts, only it can call RasDhcpTimerSchedule (to 
    avoid race conditions). The timer thread will call rasDhcpMonitorAddresses 
    (and hence rasDhcpAllocateAddress), and rasDhcpRenewLease. These functions 
    will call RasDhcpTimerSchedule. No one else should call these functions or 
    RasDhcpTimerSchedule. The only exception is RasDhcpInitialize, which can 
    call RasDhcpTimerSchedule before it creates the timer thread.

*/

VOID
RasDhcpTimerSchedule(
    IN  TIMERLIST*      pNewTimer,
    IN  LONG            DeltaTime,
    IN  TIMERFUNCTION   TimerFunc
)
{
    TIMERLIST** ppTimer;
    TIMERLIST*  pTimer;

    pNewTimer->tmr_TimerFunc = TimerFunc;

    for (ppTimer = &RasDhcpTimerListHead;
         (pTimer = *ppTimer) != NULL;
         ppTimer = &pTimer->tmr_Next)
    {
        if (DeltaTime <= pTimer->tmr_Delta)
        {
            pTimer->tmr_Delta -= DeltaTime;
            break;
        }
        DeltaTime -= pTimer->tmr_Delta;
    }

    pNewTimer->tmr_Delta = DeltaTime;
    pNewTimer->tmr_Next = *ppTimer;
    *ppTimer = pNewTimer;
}

/*

Returns:

Notes:

*/

VOID
RasDhcpTimerRunNow(
    VOID
)
{
    RtlUpdateTimer(RasDhcpTimerQueueHandle, RasDhcpTimerHandle, 0, 
        TIMER_PERIOD);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\tcpreg.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _TCPREG_H_
#define _TCPREG_H_

#include "rasiphlp.h"

// Maximum characters in an IP address string of the form a.b.c.d
#define MAXIPSTRLEN                 20

typedef struct _TCPIP_INFO
{
    BOOL    fChanged;
    BOOL    fDisableNetBIOSoverTcpip;

    WCHAR*  wszAdapterName;

    WCHAR   wszIPAddress[MAXIPSTRLEN + 1];
    WCHAR   wszSubnetMask[MAXIPSTRLEN + 1];

    WCHAR*  wszDNSNameServers;                  // space separated SZ
    WCHAR*  mwszNetBIOSNameServers;             // MULTI_SZ
    WCHAR*  wszDNSDomainName;

} TCPIP_INFO;

// *ppTcpipInfo must ultimately be freed by calling FreeTcpipInfo()

DWORD
LoadTcpipInfo(
    IN  TCPIP_INFO**    ppTcpipInfo,
    IN  WCHAR*          wszAdapterName,
    IN  BOOL            fAdapterOnly
);

DWORD
SaveTcpipInfo(
    IN  TCPIP_INFO*     pTcpipInfo
);

DWORD
FreeTcpipInfo(
    IN  TCPIP_INFO**    ppTcpipInfo
);

VOID
ClearTcpipInfo(
    VOID
);

DWORD
GetAdapterInfo(
    IN  DWORD       dwIndex,
    OUT IPADDR*     pnboIpAddress,
    OUT IPADDR*     pnboDNS1,
    OUT IPADDR*     pnboDNS2,
    OUT IPADDR*     pnboWINS1,
    OUT IPADDR*     pnboWINS2,
    OUT IPADDR*     pnboGateway,
    OUT BYTE*       pbAddress
);

DWORD
GetPreferredAdapterInfo(
    OUT IPADDR*     pnboIpAddress,
    OUT IPADDR*     pnboDNS1,
    OUT IPADDR*     pnboDNS2,
    OUT IPADDR*     pnboWINS1,
    OUT IPADDR*     pnboWINS2,
    OUT BYTE*       pbAddress
);

DWORD
MwszLength(
    IN  WCHAR*  mwsz
);

DWORD
RegQueryValueWithAllocA(
    IN  HKEY            hKey,
    IN  CHAR*           szValueName,
    IN  DWORD           dwTypeRequired,
    IN  BYTE**          ppbData
);

DWORD
RegQueryValueWithAllocW(
    IN  HKEY    hKey,
    IN  WCHAR*  wszValueName,
    IN  DWORD   dwTypeRequired,
    IN  BYTE**  ppbData
);

IPADDR
IpAddressFromAbcdWsz(
    IN  WCHAR*  wszIpAddress
);

VOID
AbcdSzFromIpAddress(
    IN  IPADDR  nboIpAddr,
    OUT CHAR*   szIpAddress
);

VOID
AbcdWszFromIpAddress(
    IN  IPADDR  nboIpAddr,
    OUT WCHAR*  wszIpAddress
);

DWORD
PrependWszIpAddress(
    IN  WCHAR** pwsz,
    IN  WCHAR*  wszIpAddress
);

DWORD
PrependWszIpAddressToMwsz(
    IN  WCHAR** pmwsz,
    IN  WCHAR*  wszIpAddress
);

DWORD
PrependDwIpAddress(
    IN  WCHAR** pwsz,
    IN  IPADDR  nboIpAddr
);

DWORD
PrependDwIpAddressToMwsz(
    IN  WCHAR** pmwsz,
    IN  IPADDR  nboIpAddr
);

#endif // #ifndef _TCPREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\browser.c ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	    browser.c
//
// Description:     implements the functions to enable/restore browser
//		    on IPX ras lines
//
// Author:	    Stefan Solomon (stefans)	September 1, 1994.
//
// Revision History:
//
//***

#include "precomp.h"
#pragma  hdrstop

#include <ntddbrow.h>

NTSTATUS
OpenBrowser(
     OUT PHANDLE BrowserHandle
    );

NTSTATUS
BrDgReceiverIoControl(
	   IN  HANDLE FileHandle,
	   IN  ULONG DgReceiverControlCode,
	   IN  PLMDR_REQUEST_PACKET Drp,
	   IN  ULONG DrpSize,
	   IN  PVOID SecondBuffer OPTIONAL,
	   IN  ULONG SecondBufferLength,
	   OUT PULONG Information OPTIONAL
	   );

VOID
EnableDisableTransport(
    IN PCHAR		Transport,
    BOOL		Disable,
    BOOL		*Previous

    );

//***
//
// Function: DisableRestoreBrowserOverIpx
//
// Arguments:
//	contextp - context pointer
//	Disable  - TRUE - disable, FALSE - restore previous state
//
//***

VOID
DisableRestoreBrowserOverIpx(PIPXCP_CONTEXT	contextp,
			     BOOL		Disable)
{
    PCHAR Transport = "\\Device\\NwLnkIpx";

    EnableDisableTransport(Transport,
			   Disable,
			   &contextp->NwLnkIpxPreviouslyEnabled);
}

//***
//
// Function: DisableRestoreBrowserOverNetbiosIpx
//
// Arguments:
//	contextp - context pointer
//	Disable  - TRUE - disable, FALSE - restore previous state
//
//***

VOID
DisableRestoreBrowserOverNetbiosIpx(PIPXCP_CONTEXT    contextp,
				    BOOL	      Disable)
{
    PCHAR Transport = "\\Device\\NwLnkNb";

    EnableDisableTransport(Transport,
			   Disable,
			   &contextp->NwLnkNbPreviouslyEnabled);
}

VOID
EnableDisableTransport(
    IN PCHAR		Transport,
    BOOL		Disable,
    BOOL		*Previous

    )
{
    NTSTATUS Status;
    UNICODE_STRING TransportName;
    ANSI_STRING ATransportName;
    HANDLE BrowserHandle;
    PLMDR_REQUEST_PACKET RequestPacket = NULL;

    RtlInitString(&ATransportName, Transport);

    if ( RtlAnsiStringToUnicodeString(&TransportName, &ATransportName, TRUE) 
                                                                    != STATUS_SUCCESS )
    {
        return;
    }

    RequestPacket = (PLMDR_REQUEST_PACKET)LocalAlloc(0, sizeof(LMDR_REQUEST_PACKET) + TransportName.MaximumLength);

    if (RequestPacket == NULL) 
    {
        RtlFreeUnicodeString(&TransportName);
    	return;
    }

    RequestPacket->TransportName.Buffer = (PWSTR)((PCHAR)RequestPacket + sizeof(LMDR_REQUEST_PACKET) );

    RequestPacket->TransportName.MaximumLength = TransportName.MaximumLength;

    RtlCopyUnicodeString(&RequestPacket->TransportName, &TransportName);

    Status = OpenBrowser(&BrowserHandle);

    if (!NT_SUCCESS(Status)) 
    {
    	SS_PRINT(("EnableDisableTransport: Failed to open browser, status %x\n",
	    	  Status));
    	LocalFree(RequestPacket);
        RtlFreeUnicodeString(&TransportName);
    	return;
    }

    SS_PRINT(("EnableDisableTransport: Browser opened succesfully!\n"));
    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION;

    if(Disable) 
    {
    	// request to disable
    	RequestPacket->Parameters.EnableDisableTransport.EnableTransport = FALSE;
    }
    else
    {
    	// request to restore
    	RequestPacket->Parameters.EnableDisableTransport.EnableTransport =  *Previous;
    }

    // IOCTl the Browser
    Status = BrDgReceiverIoControl(BrowserHandle,
		      IOCTL_LMDR_ENABLE_DISABLE_TRANSPORT,
		      RequestPacket,
		      sizeof(LMDR_REQUEST_PACKET)+TransportName.MaximumLength,
		      RequestPacket,
		      sizeof(LMDR_REQUEST_PACKET)+TransportName.MaximumLength,
		      NULL);

    if (!NT_SUCCESS(Status)) 
    {
    	SS_PRINT(("EnableDisableTransport: Failed to IOCtl browser, status %x\n",
    		  Status));

        RtlFreeUnicodeString(&TransportName);
    	CloseHandle(BrowserHandle);
    	LocalFree(RequestPacket);
    	return;
    }

    SS_PRINT(("Browser IOCTled Ok, EnableTransport %x PreviouslyEnabled %x\n",
    RequestPacket->Parameters.EnableDisableTransport.EnableTransport,
    RequestPacket->Parameters.EnableDisableTransport.PreviouslyEnabled));

    // save the previous if disable requested
    if(Disable) 
    {
	    *Previous = RequestPacket->Parameters.EnableDisableTransport.PreviouslyEnabled;
    }

    RtlFreeUnicodeString(&TransportName);
    CloseHandle(BrowserHandle);
    LocalFree(RequestPacket);
}

NTSTATUS
OpenBrowser(
     OUT PHANDLE BrowserHandle
    )
/*++

 Routine Description:

     This function opens a handle to the bowser device driver.

 Arguments:

     OUT PHANDLE BrowserHandle - Returns the handle to the browser.

 Return Value:

     Succes or reason for failure.

 --*/
{
    NTSTATUS ntstatus;

    UNICODE_STRING DeviceName;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;

    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&DeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
	      &ObjectAttributes,
	      &DeviceName,
	      OBJ_CASE_INSENSITIVE,
	      NULL,
	      NULL
	      );

    ntstatus = NtOpenFile(
	      BrowserHandle,
	      SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
	      &ObjectAttributes,
	      &IoStatusBlock,
	      FILE_SHARE_READ | FILE_SHARE_WRITE,
	      FILE_SYNCHRONOUS_IO_NONALERT
	      );

    if (NT_SUCCESS(ntstatus)) {
	  ntstatus = IoStatusBlock.Status;
    }

    return ntstatus;

}


NTSTATUS
BrDgReceiverIoControl(
	   IN  HANDLE FileHandle,
	   IN  ULONG DgReceiverControlCode,
	   IN  PLMDR_REQUEST_PACKET Drp,
	   IN  ULONG DrpSize,
	   IN  PVOID SecondBuffer OPTIONAL,
	   IN  ULONG SecondBufferLength,
	   OUT PULONG Information OPTIONAL
	   )
/*++

 Routine Description:

 Arguments:

	   FileHandle - Supplies a handle to the file or device on which the service
	  is being performed.

	   DgReceiverControlCode - Supplies the NtDeviceIoControlFile function code
	  given to the datagram receiver.

	   Drp - Supplies the datagram receiver request packet.

	   DrpSize - Supplies the length of the datagram receiver request packet.

	   SecondBuffer - Supplies the second buffer in call to NtDeviceIoControlFile.

	   SecondBufferLength - Supplies the length of the second buffer.

	   Information - Returns the information field of the I/O status block.

 Return Value:

	   Success or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE CompletionEvent;

    SS_PRINT(("TransportName.MaximumLength %d\n", Drp->TransportName.MaximumLength));

    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == NULL) {

	return(GetLastError());
    }
    //
    // Send the request to the Datagram Receiver DD.
    //

    ntstatus = NtDeviceIoControlFile(
		 FileHandle,
		 CompletionEvent,
		 NULL,
		 NULL,
		 &IoStatusBlock,
		 DgReceiverControlCode,
		 Drp,
		 DrpSize,
		 Drp,
		 DrpSize
		 );

    if (NT_SUCCESS(ntstatus)) {

	//
	//  If pending was returned, then wait until the request completes.
	//

	if (ntstatus == STATUS_PENDING) {

	    do {
		  ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
	    } while ( ntstatus == WAIT_IO_COMPLETION );
	 }


	 if (NT_SUCCESS(ntstatus)) {
	     ntstatus = IoStatusBlock.Status;
	 }
    }

    CloseHandle(CompletionEvent);

    return (ntstatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasiphlp\timer_.h ===
/*

Copyright (c) 1998, Microsoft Corporation, all rights reserved

Description:

History:

*/

#ifndef _TIMER__H_
#define _TIMER__H_

#include "rasiphlp_.h"
#include <nturtl.h>
#include "helper.h"
#include "timer.h"

extern      CRITICAL_SECTION            RasTimrCriticalSection;

#define     TIMER_PERIOD                30*1000     // 30 sec (in milliseconds)

HANDLE      RasDhcpTimerQueueHandle     = NULL;
HANDLE      RasDhcpTimerHandle          = NULL;
TIMERLIST*  RasDhcpTimerListHead        = NULL;
HANDLE      RasDhcpTimerShutdown        = NULL;
time_t      RasDhcpTimerPrevTime        = 0;

#endif // #ifndef _TIMER__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\configq.c ===
/*
    File    ConfigQ.c

    Defines a mechanism for queueing configuration changes.  This is
    needed because some ipxcp pnp re-config has to be delayed until
    there are zero connected clients.
*/

#include "precomp.h"
#pragma hdrstop

typedef struct _ConfigQNode {
    DWORD dwCode;
    DWORD dwDataSize;
    LPVOID pvData;
    struct _ConfigQNode * pNext;
} ConfigQNode;

typedef struct _ConfigQueue {
    ConfigQNode * pHead;
} ConfigQueue;    

//
// Create a new configuration queue
//
DWORD CQCreate (HANDLE * phQueue) {
    ConfigQueue * pQueue = GlobalAlloc(GPTR, sizeof(ConfigQueue));
    if (pQueue == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    *phQueue = (HANDLE)pQueue;
    
    return NO_ERROR;
}

//
// Cleanup a queue
//
DWORD CQCleanup (HANDLE hQueue) {
    ConfigQueue * pQueue = (ConfigQueue *)hQueue;
    DWORD dwErr;

    if ((dwErr = CQRemoveAll (hQueue)) != NO_ERROR)
        return dwErr;
        
    GlobalFree (pQueue);

    return NO_ERROR;
}    

//
// Remove all elements from a queue
//
DWORD CQRemoveAll (HANDLE hQueue) {
    ConfigQueue * pQueue = (ConfigQueue *)hQueue;
    ConfigQNode * pNode = pQueue->pHead, * pTemp;

    while (pNode) {
        pTemp = pNode;
        pNode = pNode->pNext;
        if (pTemp->pvData)
            GlobalFree (pTemp->pvData);
        GlobalFree (pTemp);
    }

    pQueue->pHead = NULL;
    
    return NO_ERROR;
}

//
// Add an element to a queue -- overwriting it if
// it already exists.
//
DWORD CQAdd (HANDLE hQueue, DWORD dwCode, LPVOID pvData, DWORD dwDataSize) {
    ConfigQueue * pQueue = (ConfigQueue *)hQueue;
    ConfigQNode * pNode = pQueue->pHead;
    
    // Find the node in the queue
    while (pNode) {
        if (pNode->dwCode == dwCode)
            break;
        pNode = pNode->pNext;
    }

    // Allocate a new node if it wasn't found
    // in the list.
    if (pNode == NULL) {
        pNode = GlobalAlloc (GPTR, sizeof (ConfigQNode));
        if (pNode == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        pNode->pNext = pQueue->pHead;
        pQueue->pHead = pNode;
    }

    // Free any old memory
    if (pNode->pvData)
        GlobalFree (pNode->pvData);

    // Assign the values
    pNode->pvData = GlobalAlloc(GPTR, dwDataSize);
    if (! pNode->pvData)
        return ERROR_NOT_ENOUGH_MEMORY;
    CopyMemory (pNode->pvData, pvData, dwDataSize);
    pNode->dwCode = dwCode;
    pNode->dwDataSize = dwDataSize;

    return NO_ERROR;
}

//
// Enumerate queue values.  Enumeration continues until the
// given enumeration function returns TRUE or until there are
// no more elements in the queue.
//
DWORD CQEnum (HANDLE hQueue, CQENUMFUNCPTR pFunc, ULONG_PTR ulpUser) {

    ConfigQueue * pQueue = (ConfigQueue *)hQueue;
    ConfigQNode * pNode = pQueue->pHead;
    
    // Find the node in the queue
    while (pNode) {
        if ((*pFunc)(pNode->dwCode, pNode->pvData, pNode->dwDataSize, ulpUser))
            break;
        pNode = pNode->pNext;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\ipxcpcom.h ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	    ipxcpcom.h
//
// Description:     ipxcp/ipxwan common stuff
//
//
// Author:	    Stefan Solomon (stefans)	November 2, 1995.
//
// Revision History:
//
//***

#ifndef _IPXCPCOM_
#define _IPXCPCOM_

#define INVALID_NETWORK_INDEX	    0xFFFFFFFF


typedef struct _IPXWAN_INTERFACE {

    // IPXCP configuration parameters needed by IPXWAN

    ULONG     EnableUnnumberedWanLinks;

    // IPXCP Entry Points

    DWORD (WINAPI *IpxcpGetWanNetNumber)(IN OUT PUCHAR		Network,
					 IN OUT PULONG		AllocatedNetworkIndexp,
					 IN	ULONG		InterfaceType);

    VOID  (WINAPI *IpxcpReleaseWanNetNumber)(ULONG	    AllocatedNetworkIndex);

    DWORD (WINAPI *IpxcpConfigDone)(ULONG		ConnectionId,
				    PUCHAR		Network,
				    PUCHAR		LocalNode,
				    PUCHAR		RemoteNode,
				    BOOL		Success);

    VOID (WINAPI *IpxcpGetInternalNetNumber)(PUCHAR	Network);

    ULONG (WINAPI *IpxcpGetInterfaceType)(ULONG	    ConnectionId);

    DWORD (WINAPI *IpxcpGetRemoteNode)(ULONG	    ConnectionId,
				       PUCHAR	    RemoteNode);

    BOOL  (WINAPI *IpxcpIsRoute)(PUCHAR	  Network);

    } IPXWAN_INTERFACE, *PIPXWAN_INTERFACE;

// IPXWAN Entry Point

#define IPXWAN_BIND_ENTRY_POINT 	        IpxwanBind
#define IPXWAN_UNBIND_ENTRY_POINT 	        IpxwanUnbind
#define IPXWAN_BIND_ENTRY_POINT_STRING	    "IpxwanBind"
#define IPXWAN_UNBIND_ENTRY_POINT_STRING	"IpxwanUnbind"

typedef DWORD   (*PIPXWAN_BIND)(PIPXWAN_INTERFACE IpxWanIfp);
typedef VOID    (*PIPXWAN_UNBIND)(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\ipxcp.h ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	    ipxcp.h
//
// Description:     IPX network layer configuration definitions
//
//
// Author:	    Stefan Solomon (stefans)	November 24, 1993.
//
// Revision History:
//
//***


#ifndef _IPXCP_
#define _IPXCP_


//*** IPXCP Option Offsets ***

#define OPTIONH_TYPE			0
#define OPTIONH_LENGTH			1
#define OPTIONH_DATA			2

//*** IPXCP Configuration Option Types ***

#define IPX_NETWORK_NUMBER		(UCHAR)1
#define IPX_NODE_NUMBER 		(UCHAR)2
#define IPX_COMPRESSION_PROTOCOL	(UCHAR)3
#define IPX_ROUTING_PROTOCOL		(UCHAR)4
#define IPX_ROUTER_NAME 		(UCHAR)5
#define IPX_CONFIGURATION_COMPLETE	(UCHAR)6

//*** IPXCP Configuration Option Values ***

#define RIP_SAP_ROUTING 		2
#define TELEBIT_COMPRESSED_IPX		0x0002

// nr of parameters we will try to negotiate
#define MAX_DESIRED_PARAMETERS		3

//*** IPXCP Work Buffer ***

typedef enum _ROUTE_STATE {

    NO_ROUTE,
    ROUTE_ALLOCATED,
    ROUTE_ACTIVATED
    } ROUTE_STATE;

typedef enum _IPXWAN_STATE {

    IPXWAN_NOT_STARTED,
    IPXWAN_ACTIVE,
    IPXWAN_DONE

    } IPXWAN_STATE;

typedef struct _IPXCP_CONTEXT {

    ULONG			InterfaceType;
    ROUTE_STATE 		RouteState;
    IPXWAN_STATE		IpxwanState;
    ULONG			IpxwanConfigResult;
    IPXCP_CONFIGURATION 	Config;
    ULONG			IpxConnectionHandle; // used in IpxGetWanInactivityCounter
    ULONG			AllocatedNetworkIndex;	// net number index from the wannet pool
    USHORT			CompressionProtocol;
    BOOL			SetReceiveCompressionProtocol;
    BOOL			SetSendCompressionProtocol;
    BOOL			ErrorLogged;
    USHORT			NetNumberNakSentCount; // nr of Naks we issued by the CLIENT
    USHORT			NetNumberNakReceivedCount; // nr of Naks recv by the SERVER

    // This array is used to turn off negotiation for certain options.
    // An option negotiation is turned off if it gets rejected by the other end
    // or if (in the compression case) is not supported by the other end.

    BOOL			DesiredParameterNegotiable[MAX_DESIRED_PARAMETERS];

    // hash tables linkages
    LIST_ENTRY			ConnHtLinkage;	// linkage in connection id hash table
    LIST_ENTRY			NodeHtLinkage;	// linkage in node hash table

    // these two variables used to store the previous browser enabling state
    // for nwlnkipx and nwlnknb

    BOOL			NwLnkIpxPreviouslyEnabled;
    BOOL			NwLnkNbPreviouslyEnabled;

    // !!! This should go away !!!

    ULONG			hPort;
    HBUNDLE         hConnection;

    } IPXCP_CONTEXT, *PIPXCP_CONTEXT;

//*** max nr of Naks we can send or receive for the Net Number
// if you modify these values set max naks sent < max naks received to give
// the client a chance to terminate and inform the user before the server terminates

// max nr of naks the client can send before giving up and terminating the connection
#define MAX_NET_NUMBER_NAKS_SENT	5

// max nr of naks the server can receive before giving up
#define MAX_NET_NUMBER_NAKS_RECEIVED	5

//*** The following define the index for each option as they appear in the
//    DesiredParameter array. CHANGE THESE DEFS IF YOU CHANGE DESIREDPARAMETER!

#define IPX_NETWORK_NUMBER_INDEX	0
#define IPX_NODE_NUMBER_INDEX		1
#define IPX_COMPRESSION_PROTOCOL_INDEX	2

//*** Option Handler Actions ***

typedef enum _OPT_ACTION {

    SNDREQ_OPTION,  // Copy the option value from the local context struct
		    // to the REQ option frame to be sent

    RCVNAK_OPTION,  // Check the option value from the received NAK frame.
		    // Copy it to our local context struct if it is acceptable
		    // for us.

    RCVACK_OPTION,  // Compare option values from the received ACK frame and
		    // the local context struct.

    RCVREQ_OPTION,  // Check if the option value in the received REQ frame is
		    // acceptable. If not, write the acceptable value in the
		    // response NAK frame.

    SNDNAK_OPTION   // Make an acceptable option in the response NAK frame.
		    // This happens when a desired option is missing from the
		    // received REQ frame.
    } OPT_ACTION;



extern	CRITICAL_SECTION	  DbaseCritSec;

#define ACQUIRE_DATABASE_LOCK	EnterCriticalSection(&DbaseCritSec)
#define RELEASE_DATABASE_LOCK	LeaveCriticalSection(&DbaseCritSec)

extern BOOL  RouterStarted;
extern DWORD SingleClientDialinIfNoRouter;
extern UCHAR nullnet[4];
extern UCHAR nullnode[6];
extern DWORD WorkstationDialoutActive;
    
typedef struct _IPXCP_GLOBAL_CONFIG_PARAMS {
    IPXCP_ROUTER_CONFIG_PARAMS RParams;
    DWORD			  SingleClientDialout;
    DWORD			  FirstWanNet;
    DWORD			  WanNetPoolSize;
    UNICODE_STRING    WanNetPoolStr;
    DWORD			  EnableUnnumberedWanLinks;
    DWORD			  EnableAutoWanNetAllocation;
    DWORD			  EnableCompressionProtocol;
    DWORD			  EnableIpxwanForWorkstationDialout;
    DWORD             AcceptRemoteNodeNumber;
    DWORD			  DebugLog;
    UCHAR             puSpecificNode[6];
} IPXCP_GLOBAL_CONFIG_PARAMS, *PIPXCP_GLOBAL_CONFIG_PARAMS;

extern IPXCP_GLOBAL_CONFIG_PARAMS GlobalConfig;

extern	VOID	(*PPPCompletionRoutine)(HCONN		  hPortOrBundle,
				DWORD		  Protocol,
				PPP_CONFIG *	  pSendConfig,
				DWORD		  dwError);

extern HANDLE	PPPThreadHandle;

extern HINSTANCE IpxWanDllHandle;

// ipxwan dll name
#define 	IPXWANDLLNAME		    "ipxwan.dll"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\ipxcpdbg.c ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	ipxcpdbg.c
//
// Description: Debug Stuff
//
// Author:	Stefan Solomon (stefans)    October 27, 1995.
//
// Revision History:
//
//***

#include "precomp.h"
#pragma  hdrstop

//*** TRACE ID FOR RIP ***

DWORD	    IpxCpTraceID;



DWORD	DbgLevel = DEFAULT_DEBUG;
HANDLE	DbgLogFileHandle = INVALID_HANDLE_VALUE;

//
//  Debug switch which directs debug output to console or file
//
//  values:
//	     1 - Console Debug
//	     > 1 - log file: ipxcpdbg.log in the root directory
//	     2 - resets the log file for each new connection

DWORD	DebugLog;

#if DBG

VOID
SsDbgInitialize(VOID)
{
    if (DebugLog == 1) {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        COORD coord;
        (VOID)AllocConsole( );
        (VOID)GetConsoleScreenBufferInfo(
                GetStdHandle(STD_OUTPUT_HANDLE),
                &csbi
                );
        coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
        coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
        (VOID)SetConsoleScreenBufferSize(
                GetStdHandle(STD_OUTPUT_HANDLE),
                coord
                );
    }

    if(DebugLog > 1) {

	DbgLogFileHandle = CreateFile("\\ipxcpdbg.log",
					 GENERIC_READ | GENERIC_WRITE,
					 FILE_SHARE_READ,
					 NULL,
					 CREATE_ALWAYS,
					 0,
					 NULL);
    }
}

#endif

#if DBG

VOID
SsResetDbgLogFile(VOID)
{
    if(DebugLog == 2) {

	// reset the debug log file at the beginning for each new connection
	if(DbgLogFileHandle != INVALID_HANDLE_VALUE) {

	    SetFilePointer(DbgLogFileHandle, 0, NULL, FILE_BEGIN);
	}
    }
}

#endif

#if DBG

VOID
SsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    )
{
    SS_PRINT(("\nAssertion failed: %s\n  at line %ld of %s\n",
		FailedAssertion, LineNumber, FileName));

    DbgUserBreakPoint( );

} // SsAssert

#endif

#if DBG

VOID
SsPrintf (
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;

    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    length = strlen( OutputBuffer );

    WriteFile( GetStdHandle(STD_OUTPUT_HANDLE), (LPVOID )OutputBuffer, length, &length, NULL );

    if(DbgLogFileHandle != INVALID_HANDLE_VALUE) {

	WriteFile(DbgLogFileHandle, (LPVOID )OutputBuffer, length, &length, NULL );
    }

} // SsPrintf




#endif

VOID
StartTracing(VOID)
{
    IpxCpTraceID = TraceRegister("IPXCP");
}

VOID
TraceIpx(ULONG	ComponentID,
      char	*Format,
      ...)
{
    va_list	arglist;

    va_start(arglist, Format);

    TraceVprintfEx(IpxCpTraceID,
		   ComponentID | TRACE_USE_MASK,
		   Format,
		   arglist);

    va_end(arglist);
}

VOID
StopTracing(VOID)
{
    TraceDeregister(IpxCpTraceID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\configq.h ===
/*
    File    ConfigQ.h

    Defines a mechanism for queueing configuration changes.  This is
    needed because some ipxcp pnp re-config has to be delayed until
    there are zero connected clients.
*/


#ifndef __rasipxcp_configq_h
#define __rasipxcp_configq_h

// Definitions of the config queue codes
//
#define CQC_THIS_MACHINE_ONLY               0x1
#define CQC_ENABLE_GLOBAL_WAN_NET           0x2
#define CQC_GLOBAL_WAN_NET                  0x3
#define CQC_SINGLE_CLIENT_DIALOUT           0x4
#define CQC_FIRST_WAN_NET                   0x5
#define CQC_WAN_NET_POOL_SIZE               0x6
#define CQC_WAN_NET_POOL_STR                0x7
#define CQC_ENABLE_UNNUMBERED_WAN_LINKS     0x8
#define CQC_ENABLE_AUTO_WAN_NET_ALLOCATION  0x9
#define CQC_ENABLE_COMPRESSION_PROTOCOL     0xA
#define CQC_ENABLE_IPXWAN_FOR_WORKST_OUT    0xB
#define CQC_ACCEPT_REMOTE_NODE_NUMBER       0xC
#define CQC_FIRST_WAN_NODE                  0xD
#define CQC_DEBUG_LOG                       0xE

// Callback function used when enumerating config values
//
typedef BOOL (* CQENUMFUNCPTR)(DWORD dwCode, LPVOID pvData, DWORD dwSize, ULONG_PTR ulpUser);

// Creation/cleanup, etc.
//
DWORD CQCreate (HANDLE * phQueue);
DWORD CQCleanup (HANDLE hQueue);
DWORD CQRemoveAll (HANDLE hQueue);
DWORD CQAdd (HANDLE hQueue, DWORD dwCode, LPVOID pvData, DWORD dwSize);
DWORD CQEnum (HANDLE hQueue, CQENUMFUNCPTR pFunc, ULONG_PTR ulpUser);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\ipxcp.c ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	    ipxcp.c
//
// Description:     implements the IPX network layer configuration
//
//
// Author:	    Stefan Solomon (stefans)	November 24, 1993.
//
// Revision History:
//
//***

#include "precomp.h"
#pragma hdrstop

// keep track is we already have an active dialout port as a client
DWORD	    WorkstationDialoutActive = 0;

// Keep track of the number of clients currently connected
DWORD dwClientCount = 0;

// Used to assign remote wan workstations node numbers
extern DWORD LastNodeAssigned;
extern BOOL bAssignSpecificNode;

VOID	(*PPPCompletionRoutine)(HCONN		  hPortOrBundle,
				DWORD		  Protocol,
				PPP_CONFIG *	  pSendConfig,
				DWORD		  dwError);

HANDLE	PPPThreadHandle = INVALID_HANDLE_VALUE;

// Handle to queue that holds configuration changes that need to 
// be made when the client count goes to zero next.
HANDLE hConfigQueue = NULL;

// Function obtained from the router manager to update global 
// config
extern DWORD (WINAPI *RmUpdateIpxcpConfig)(PIPXCP_ROUTER_CONFIG_PARAMS pParams);

HANDLE g_hRouterLog = NULL;

DWORD
WanNetReconfigure();

DWORD
IpxCpBegin(OUT VOID  **ppWorkBuf,
	   IN  VOID  *pInfo);

DWORD
IpxCpEnd(IN VOID	*pWorkBuffer);

DWORD
IpxCpReset(IN VOID *pWorkBuffer);

DWORD
IpxCpThisLayerUp(IN VOID *pWorkBuffer);

DWORD
IpxCpThisLayerDown(IN VOID *pWorkBuffer);

DWORD
IpxCpMakeConfigRequest(IN  VOID 	*pWorkBuffer,
		       OUT PPP_CONFIG	*pRequestBufffer,
		       IN  DWORD	cbRequestBuffer);

DWORD
IpxCpMakeConfigResult(IN  VOID		*pWorkBuffer,
		      IN  PPP_CONFIG	*pReceiveBuffer,
		      OUT PPP_CONFIG	*pResultBuffer,
		      IN  DWORD		cbResultBuffer,
		      IN  BOOL		fRejectNaks);

DWORD
IpxCpConfigNakReceived(IN VOID		*pWorkBuffer,
		       IN PPP_CONFIG	*pReceiveBuffer);

DWORD
IpxCpConfigAckReceived(IN VOID		*pWorkBuffer,
		       IN PPP_CONFIG	*pReceiveBuffer);

DWORD
IpxCpConfigRejReceived(IN VOID		*pWorkBuffer,
		       IN PPP_CONFIG	*pReceiveBuffer);

DWORD
IpxCpGetNegotiatedInfo(IN VOID		 *pWorkBuffer,
                       OUT VOID *    pIpxCpResult );

DWORD
IpxCpProjectionNotification(IN VOID *pWorkBuf,
			    IN VOID *pProjectionResult);

#define     ERROR_INVALID_OPTION	    1
#define     ERROR_INVALID_OPTLEN	    2

DWORD
ValidOption(UCHAR	option,
	    UCHAR	optlen);

BOOL
DesiredOption(UCHAR	option, USHORT	*indexp);

USHORT
DesiredConfigReqLength();

DWORD
IpxCpUpdateGlobalConfig( VOID );

DWORD
IpxcpUpdateQueuedGlobalConfig();

// Update Flags
#define FLAG_UPDATE_WANNET  0x1
#define FLAG_UPDATE_ROUTER  0x2 

typedef BOOL	(*OPTION_HANDLER)(PUCHAR	     optptr,
				  PIPXCP_CONTEXT     contextp,
				  PUCHAR	     resptr,
				  OPT_ACTION	     Action);


static OPTION_HANDLER	 OptionHandler[] =
{
    NULL,
    NetworkNumberHandler,
    NodeNumberHandler,
    CompressionProtocolHandler,
    RoutingProtocolHandler,
    NULL,			// RouterName - not a DESIRED parammeter
    ConfigurationCompleteHandler
    };

UCHAR	nullnet[] = { 0x00, 0x00, 0x00, 0x00 };
UCHAR	nullnode[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

USHORT	MaxDesiredParameters = MAX_DESIRED_PARAMETERS;

CRITICAL_SECTION	DbaseCritSec;

//*** Declarations and defs for the options to be negotiated with this
//	version of IPXCP

UCHAR	DesiredParameter[MAX_DESIRED_PARAMETERS] = {

    IPX_NETWORK_NUMBER,
    IPX_NODE_NUMBER,
    IPX_COMPRESSION_PROTOCOL
    };

USHORT	DesiredParameterLength[MAX_DESIRED_PARAMETERS] = {

    6,	// IPX_NETWORK_NUMBER,
    8,	// IPX_NODE_NUMBER,
    4	// IPX_COMPRESSION_PROTOCOL
    };

DWORD
IpxCpInit(BOOL fInitialize)
{
    static  DWORD   dwRefCount  = 0;

    if (fInitialize)
    {
        if (0 == dwRefCount)
        {
            //
            // Read the registry parameters and set IpxCp configuration
            //

            InitializeCriticalSection(&DbaseCritSec);

            g_hRouterLog = RouterLogRegisterW(L"IPXCP");
            
            StartTracing();

            GetIpxCpParameters(&GlobalConfig);

            SS_DBGINITIALIZE;

            InitializeRouterManagerIf();

            InitializeNodeHT();

            InitializeConnHT();

            LoadIpxWan();

            CQCreate (&hConfigQueue);
        }

        dwRefCount++;
    }
    else
    {
        dwRefCount--;

        if (0 == dwRefCount)
        {
            //
            // Release the global list of routes
            //
            
            CQCleanup (hConfigQueue);
            UnloadIpxWan ();
            StopTracing();
            g_hRouterLog = NULL;
            
            DeleteCriticalSection(&DbaseCritSec);
        }
    }

    return(NO_ERROR);
}

DWORD
IpxCpGetInfo(
    IN  DWORD 	    dwProtocolId,
    OUT PPPCP_INFO  *pCpInfo)
{
    if (dwProtocolId != PPP_IPXCP_PROTOCOL)
        return(ERROR_INVALID_PARAMETER);

    ZeroMemory(pCpInfo, sizeof(PPPCP_INFO));

    pCpInfo->Protocol                    = PPP_IPXCP_PROTOCOL;
    lstrcpy(pCpInfo->SzProtocolName, "IPXCP");
    pCpInfo->Recognize                   = CODE_REJ + 1;
    pCpInfo->RasCpInit                   = IpxCpInit;
    pCpInfo->RasCpBegin                  = IpxCpBegin;
    pCpInfo->RasCpEnd                    = IpxCpEnd;
    pCpInfo->RasCpReset                  = IpxCpReset;
    pCpInfo->RasCpThisLayerUp            = IpxCpThisLayerUp;
    pCpInfo->RasCpThisLayerDown          = IpxCpThisLayerDown;
    pCpInfo->RasCpMakeConfigRequest      = IpxCpMakeConfigRequest;
    pCpInfo->RasCpMakeConfigResult       = IpxCpMakeConfigResult;
    pCpInfo->RasCpConfigAckReceived      = IpxCpConfigAckReceived;
    pCpInfo->RasCpConfigNakReceived      = IpxCpConfigNakReceived;
    pCpInfo->RasCpConfigRejReceived      = IpxCpConfigRejReceived;
    pCpInfo->RasCpGetNegotiatedInfo         = IpxCpGetNegotiatedInfo;
    pCpInfo->RasCpProjectionNotification = IpxCpProjectionNotification;
    pCpInfo->RasCpChangeNotification     = IpxCpUpdateGlobalConfig;

    return(NO_ERROR);
}

//***
//
// Function:	IpxCpBegin
//
// Descr:	Called when a line is connected.
//
//***

DWORD
IpxCpBegin(OUT VOID  **ppWorkBuf,
	   IN  VOID  *pInfo)
{
    PIPXCP_CONTEXT	contextp;
    PPPPCP_INIT		initp;
    DWORD		err;
    DWORD		tickcount;
    int 		i;
    ULONG		InterfaceType;
    ULONG		ConnectionId;

    initp = (PPPPCP_INIT)pInfo;

    TraceIpx(PPPIF_TRACE, "IpxCpBegin: Entered for if # %d\n", initp->hInterface);

    // Get the completion routine and the thread handle
    if(PPPThreadHandle == INVALID_HANDLE_VALUE) {

	// not initialized
	if (!DuplicateHandle(
                            GetCurrentProcess(),
                            GetCurrentThread(),
                            GetCurrentProcess(),
			    &PPPThreadHandle,
                            0,
                            FALSE,
			    DUPLICATE_SAME_ACCESS )) {

	    return GetLastError();
        }

	PPPCompletionRoutine = initp->CompletionRoutine;
    }

    //
    // Get the Connection Id (Bundle id)
    //

    ConnectionId = HandleToUlong(initp->hConnection);

    //
    // Determine the connection type
    //

    if((InterfaceType = GetInterfaceType(initp)) == IF_TYPE_OTHER) {

	return ERROR_CAN_NOT_COMPLETE;
    }

    if((InterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT) ||
       (InterfaceType == IF_TYPE_STANDALONE_WORKSTATION_DIALOUT)) {

	// If we are configured to allow only one dialout net and if we are
	// already dialed out once, we disable further dialouts.
	if(GlobalConfig.SingleClientDialout && IsWorkstationDialoutActive()) {

	    return ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE;
	}
    }

    if(initp->fServer &&
       (!IsRouterStarted())) {

	// we cannot accept dialin on machines without the router started
	return ERROR_CAN_NOT_COMPLETE;
    }

    // allocate a context structure to be used as work buffer for this connection
    if((contextp = (PIPXCP_CONTEXT)GlobalAlloc(GPTR, sizeof(IPXCP_CONTEXT))) == NULL) {

	*ppWorkBuf = NULL;
	return (ERROR_NOT_ENOUGH_MEMORY);
    }

    *ppWorkBuf = (VOID *)contextp;

    // allocate a route for this connection to the IPX stack
    if(err = RmAllocateRoute(HandleToUlong(initp->hPort))) {

	// cannot allocate route
	*ppWorkBuf = NULL;
        GlobalFree(contextp);
	return err;
    }

    //
    // Set up common context part
    //
    
    // hInterface is always an index

    contextp->Config.InterfaceIndex = HandleToUlong(initp->hInterface);

    if(InterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT) {

	if(AddLocalWkstaDialoutInterface(&contextp->Config.InterfaceIndex) != NO_ERROR) {

	    TraceIpx(PPPIF_TRACE, "IpxCpBegin: AddLocalWkstaDialoutInterface failed !\n");
	    RmDeallocateRoute(HandleToUlong(initp->hConnection));
	    GlobalFree(contextp);

	    return ERROR_CAN_NOT_COMPLETE;
	}
    }

    contextp->hPort = HandleToUlong(initp->hPort);
    contextp->hConnection = initp->hConnection;

    contextp->InterfaceType = InterfaceType;

    contextp->RouteState = ROUTE_ALLOCATED;
    contextp->IpxwanState = IPXWAN_NOT_STARTED;
    contextp->ErrorLogged = FALSE;
    contextp->NetNumberNakSentCount = 0;
    contextp->NetNumberNakReceivedCount = 0;

    contextp->CompressionProtocol = TELEBIT_COMPRESSED_IPX;
    contextp->SetReceiveCompressionProtocol = FALSE; // no compression initially
    contextp->SetSendCompressionProtocol = FALSE;

    // mark all our desired parameters as negotiable
    for(i=0; i<MAX_DESIRED_PARAMETERS; i++) {

	contextp->DesiredParameterNegotiable[i] = TRUE;
    }

    if(!GlobalConfig.EnableCompressionProtocol) {

	contextp->DesiredParameterNegotiable[IPX_COMPRESSION_PROTOCOL_INDEX] = FALSE;
    }

    contextp->NodeHtLinkage.Flink = NULL;
    contextp->NodeHtLinkage.Blink = NULL;

    contextp->Config.ConnectionId = ConnectionId;

    contextp->AllocatedNetworkIndex = INVALID_NETWORK_INDEX;

    // check if this is an IPXWAN connection
    contextp->Config.IpxwanConfigRequired = 0;

    if((InterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT) ||
       (InterfaceType == IF_TYPE_STANDALONE_WORKSTATION_DIALOUT)) {

	if(GlobalConfig.EnableIpxwanForWorkstationDialout) {

	    contextp->Config.IpxwanConfigRequired = 1;
	}
    }
    else
    {
	if(GetIpxwanInterfaceConfig(contextp->Config.InterfaceIndex,
				    &contextp->Config.IpxwanConfigRequired) != NO_ERROR) {

	    RmDeallocateRoute(HandleToUlong(initp->hConnection));
	    GlobalFree(contextp);
	    return ERROR_CAN_NOT_COMPLETE;
	}
    }

    if(contextp->Config.IpxwanConfigRequired &&
       !IpxWanDllHandle) {

	TraceIpx(PPPIF_TRACE, "IpxCpBegin: IPXWAN Config Required but IPXWAN.DLL not loaded");

	RmDeallocateRoute(HandleToUlong(initp->hConnection));
	GlobalFree(contextp);
	return ERROR_CAN_NOT_COMPLETE;
    }

    contextp->IpxConnectionHandle = 0xFFFFFFFF;

    //
    // Set up the remaining context according to Dialin/Dialout role
    //
    if(initp->fServer) {

	//*** DIALIN ***

	if(!contextp->Config.IpxwanConfigRequired) {

	    // allocate/generate the connection's WAN net number according to the router configuration
	    if(GetWanNetNumber(contextp->Config.Network,
			       &contextp->AllocatedNetworkIndex,
			       contextp->InterfaceType) != NO_ERROR) {

		if(contextp->InterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT) {

		     DeleteLocalWkstaDialoutInterface(contextp->Config.InterfaceIndex);
		}

		RmDeallocateRoute(HandleToUlong(initp->hConnection));
		GlobalFree(contextp);

		return ERROR_CAN_NOT_COMPLETE;
	    }

	    // set up the local server node value
	    contextp->Config.LocalNode[5] = 1;

	    // set up the remote client node value
	    ACQUIRE_DATABASE_LOCK;

        // if we have been given a specific node to handout 
        // to clients, assign it here
        if (bAssignSpecificNode) {
            memcpy (contextp->Config.RemoteNode, GlobalConfig.puSpecificNode, 6);
        }

        // Otherwise, assign a random node number
        else {
    	    LastNodeAssigned++;

    	    PUTULONG2LONG(&contextp->Config.RemoteNode[2], LastNodeAssigned);
    	    contextp->Config.RemoteNode[0] = 0x02;
    	    contextp->Config.RemoteNode[1] = 0xEE;
	    }

	    // if global wan net -> insert this context buffer in the node hash table.
	    if((contextp->InterfaceType == IF_TYPE_WAN_WORKSTATION) &&
		    GlobalConfig.RParams.EnableGlobalWanNet) 
		{
    		// Try until we get a unique node number
    		while(!NodeIsUnique(contextp->Config.RemoteNode)) {
    		    LastNodeAssigned++;
    		    PUTULONG2LONG(&contextp->Config.RemoteNode[2], LastNodeAssigned);
    		}
    		AddToNodeHT(contextp);
        }
        
	    RELEASE_DATABASE_LOCK;
	}
	else
	{
	    // we'll have IPXWAN config on this line
	    // set up the remote client node value if the remote is a wksta

	    if(contextp->InterfaceType == IF_TYPE_WAN_WORKSTATION) {

		ACQUIRE_DATABASE_LOCK;

		LastNodeAssigned++;

		PUTULONG2LONG(&contextp->Config.RemoteNode[2], LastNodeAssigned);
		contextp->Config.RemoteNode[0] = 0x02;
		contextp->Config.RemoteNode[1] = 0xEE;

		if(GlobalConfig.RParams.EnableGlobalWanNet) {

		    // Try until we get a unique node number
		    while(!NodeIsUnique(contextp->Config.RemoteNode)) {

			LastNodeAssigned++;
			PUTULONG2LONG(&contextp->Config.RemoteNode[2], LastNodeAssigned);
		    }

		    AddToNodeHT(contextp);
		}

		RELEASE_DATABASE_LOCK;
	    }
	}

	contextp->Config.ConnectionClient = 0;
    }
    else
    {
	//*** DIALOUT ***

	if(!contextp->Config.IpxwanConfigRequired) {

	    // set up the context for the client
	    // no network allocated
	    contextp->AllocatedNetworkIndex = INVALID_NETWORK_INDEX;

	    // default network is null for all cases except cisco router client
	    memcpy(contextp->Config.Network, nullnet, 4);

	    contextp->Config.RemoteNode[5] = 1; // server node value

	    // set up the value to be requested as the client node
	    tickcount = GetTickCount();

	    PUTULONG2LONG(&contextp->Config.LocalNode[2], tickcount);
	    contextp->Config.LocalNode[0] = 0x02;
	    contextp->Config.LocalNode[1] = 0xEE;
	}

	contextp->Config.ConnectionClient = 1;

	if((contextp->InterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT) ||
	   (contextp->InterfaceType == IF_TYPE_STANDALONE_WORKSTATION_DIALOUT)) {

	    ACQUIRE_DATABASE_LOCK;

	    WorkstationDialoutActive++;

	    RELEASE_DATABASE_LOCK;
	}

	// disable the browser on ipx and netbios
	DisableRestoreBrowserOverIpx(contextp, TRUE);
	DisableRestoreBrowserOverNetbiosIpx(contextp, TRUE);
    }

    ACQUIRE_DATABASE_LOCK;

    if(contextp->Config.IpxwanConfigRequired) {

	AddToConnHT(contextp);
    }

    RELEASE_DATABASE_LOCK;

    return (NO_ERROR);
}

//***
//
// Function:	    IpxCpEnd
//
// Descr:	    Called when the line gets disconnected
//
//***

DWORD
IpxCpEnd(IN VOID	*pWorkBuffer)
{
    PIPXCP_CONTEXT	contextp;
    DWORD		err;

    contextp = (PIPXCP_CONTEXT)pWorkBuffer;

    TraceIpx(PPPIF_TRACE, "IpxCpEnd: Entered for if # %d\n", contextp->Config.InterfaceIndex);

    if(!contextp->Config.ConnectionClient) {

	//*** DIALIN Clean-Up ***

	if(!contextp->Config.IpxwanConfigRequired) {

	    // if wan net allocated, release the wan net
	    if(contextp->AllocatedNetworkIndex != INVALID_NETWORK_INDEX) {

		ReleaseWanNetNumber(contextp->AllocatedNetworkIndex);
	    }
	}

	ACQUIRE_DATABASE_LOCK;

	if((contextp->InterfaceType == IF_TYPE_WAN_WORKSTATION) &&
	    GlobalConfig.RParams.EnableGlobalWanNet) {

	    RemoveFromNodeHT(contextp);
	}

	RELEASE_DATABASE_LOCK;
    }
    else
    {
	//*** DIALOUT Clean-Up ***

	if((contextp->InterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT) ||
	   (contextp->InterfaceType == IF_TYPE_STANDALONE_WORKSTATION_DIALOUT)) {

	    ACQUIRE_DATABASE_LOCK;

	    WorkstationDialoutActive--;

	    RELEASE_DATABASE_LOCK;
	}

	// restore the browser on ipx and netbios
	DisableRestoreBrowserOverIpx(contextp, FALSE);
	DisableRestoreBrowserOverNetbiosIpx(contextp, FALSE);
    }

    // we count on the route being de-allocated when the line gets disconnected
    err = RmDeallocateRoute(HandleToUlong(contextp->hConnection));

    if(contextp->InterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT) {

	DeleteLocalWkstaDialoutInterface(contextp->Config.InterfaceIndex);
    }

    ACQUIRE_DATABASE_LOCK;

    if(contextp->Config.IpxwanConfigRequired) {

	RemoveFromConnHT(contextp);
    }

    // free the work buffer
    if(GlobalFree(contextp)) {

	SS_ASSERT(FALSE);
    }

    RELEASE_DATABASE_LOCK;

    return (NO_ERROR);
}

DWORD
IpxCpReset(IN VOID *pWorkBuffer)
{
    return(NO_ERROR);
}

DWORD
IpxCpProjectionNotification(IN VOID *pWorkBuffer,
			    IN VOID *pProjectionResult)
{
    PIPXCP_CONTEXT	contextp;

    return NO_ERROR;
}


//***
//
// Function:	    IpxThisLayerUp
//
// Descr:	    Called when the IPXCP negotiation has been SUCCESSFULY
//		    completed
//
//***


DWORD
IpxCpThisLayerUp(IN VOID *pWorkBuffer)
{
    PIPXCP_CONTEXT	contextp;
    DWORD		err;

    contextp = (PIPXCP_CONTEXT)pWorkBuffer;

    dwClientCount++;
    TraceIpx(PPPIF_TRACE, "IpxCpThisLayerUp: Entered for if # %d (%d total)\n", 
                            contextp->Config.InterfaceIndex, dwClientCount);

    if(contextp->Config.IpxwanConfigRequired) {
    	//
    	//*** Configuration done with IPXWAN ***
    	//

    	ACQUIRE_DATABASE_LOCK;

    	switch(contextp->IpxwanState) {

    	    case IPXWAN_NOT_STARTED:
                TraceIpx(
                    PPPIF_TRACE, 
                    "IpxCpThisLayerUp: Do LINEUP on if #%d.  IPXWAN completes config.\n",
                    contextp->Config.InterfaceIndex);
        		if((err = RmActivateRoute(contextp->hPort, &contextp->Config)) == NO_ERROR) {

        		    contextp->RouteState = ROUTE_ACTIVATED;
        		    contextp->IpxwanState = IPXWAN_ACTIVE;

        		    err = PENDING;
        		}

        		break;

    	    case IPXWAN_ACTIVE:
        		err = PENDING;
        		break;

    	    case IPXWAN_DONE:
       	    default:
        		err = contextp->IpxwanConfigResult;
        		break;
    	}

    	RELEASE_DATABASE_LOCK;

    	return err;
    }

    //
    //*** Configuration done with IPXCP  ***
    //

    if(contextp->RouteState != ROUTE_ALLOCATED) {
	    return NO_ERROR;
    }

    // call LineUp indication into the IPX stack with the negociated config
    // values.
    TraceIpx(
        PPPIF_TRACE, 
        "IpxCpThisLayerUp: Config complete, Do LINEUP on if #%d.\n",
        contextp->Config.InterfaceIndex);
    if(err = RmActivateRoute(contextp->hPort, &contextp->Config)) {
    	return err;
    }

    TraceIpx(PPPIF_TRACE,"\n*** IPXCP final configuration ***\n");
    TraceIpx(PPPIF_TRACE,"    Network:     %.2x%.2x%.2x%.2x\n",
		   contextp->Config.Network[0],
		   contextp->Config.Network[1],
		   contextp->Config.Network[2],
		   contextp->Config.Network[3]);

    TraceIpx(PPPIF_TRACE,"    LocalNode:   %.2x%.2x%.2x%.2x%.2x%.2x\n",
		   contextp->Config.LocalNode[0],
		   contextp->Config.LocalNode[1],
		   contextp->Config.LocalNode[2],
		   contextp->Config.LocalNode[3],
		   contextp->Config.LocalNode[4],
		   contextp->Config.LocalNode[5]);

    TraceIpx(PPPIF_TRACE,"    RemoteNode:  %.2x%.2x%.2x%.2x%.2x%.2x\n",
		   contextp->Config.RemoteNode[0],
		   contextp->Config.RemoteNode[1],
		   contextp->Config.RemoteNode[2],
		   contextp->Config.RemoteNode[3],
		   contextp->Config.RemoteNode[4],
		   contextp->Config.RemoteNode[5]);

    TraceIpx(PPPIF_TRACE,"    ReceiveCompression = %d SendCompression = %d\n",
		   contextp->SetReceiveCompressionProtocol,
		   contextp->SetSendCompressionProtocol);

    contextp->RouteState = ROUTE_ACTIVATED;

    return NO_ERROR;
}

//***
//
// Function:	    IpxMakeConfigRequest
//
// Descr:	    Builds the config request packet from the desired parameters
//
//***

DWORD
IpxCpMakeConfigRequest(IN  VOID 	*pWorkBuffer,
		       OUT PPP_CONFIG	*pRequestBuffer,
		       IN  DWORD	cbRequestBuffer)
{
    USHORT		cnfglen;
    PUCHAR		cnfgptr;
    USHORT		optlen;
    PIPXCP_CONTEXT	contextp;
    int 		i;

    contextp = (PIPXCP_CONTEXT)pWorkBuffer;

    TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigRequest: Entered for if # %d\n",
	  contextp->Config.InterfaceIndex);

    if(contextp->RouteState == NO_ROUTE) {

	TraceIpx(PPPIF_TRACE, "IpxcpMakeConfigRequest: No route allocated!\n");
	return(ERROR_NO_NETWORK);
    }

    // check that the request buffer is big enough to get the desired
    // parameters
    if((USHORT)cbRequestBuffer < DesiredConfigReqLength()) {

	return(ERROR_INSUFFICIENT_BUFFER);
    }

    pRequestBuffer->Code = CONFIG_REQ;

    cnfglen = 4;
    cnfgptr = (PUCHAR)pRequestBuffer;

    if(contextp->Config.IpxwanConfigRequired) {

	// Do not request any option
	PUTUSHORT2SHORT(pRequestBuffer->Length, cnfglen);
	return NO_ERROR;
    }

    // set the desired options
    for(i = 0; i < MaxDesiredParameters; i++) {

	if(!contextp->DesiredParameterNegotiable[i]) {

	    // do not request this config option
	    continue;
	}

	OptionHandler[DesiredParameter[i]](cnfgptr + cnfglen,
					   contextp,
					   NULL,
					   SNDREQ_OPTION);

	optlen = *(cnfgptr + cnfglen + OPTIONH_LENGTH);
	cnfglen += optlen;
    }

    // set the length of the configuration request frame
    PUTUSHORT2SHORT(pRequestBuffer->Length, cnfglen);
    return NO_ERROR;
}

//***
//
// Function:	    IpxMakeConfigResult
//
// Descr:	    Starts by building the ack packet as the result
//		    If an option gets NAKed (!), it resets the result packet
//		    and starts building the NAK packet instead.
//		    If an option gets rejected, only the reject packet will
//		    be built.
//		    If one of the desired parameters is missing from this
//		    configuration request, we reset the result packet and start
//		    building a NAK packet with the missing desired parameters.
//
//***

#define MAX_OPTION_LENGTH		512

DWORD
IpxCpMakeConfigResult(IN  VOID		*pWorkBuffer,
		      IN  PPP_CONFIG	*pReceiveBuffer,
		      OUT PPP_CONFIG	*pResultBuffer,
		      IN  DWORD		cbResultBuffer,
		      IN  BOOL		fRejectNaks)
{
    USHORT		cnfglen; // config request packet len
    USHORT		rcvlen;	// used to scan the received options packet
    USHORT		reslen;  // result length
    PUCHAR		rcvptr;
    PUCHAR		resptr;  // result ptr
    PIPXCP_CONTEXT	contextp;
    UCHAR		option;  // value of this option
    UCHAR		optlen;  // length of this option
    BOOL		DesiredParameterRequested[MAX_DESIRED_PARAMETERS];
    USHORT		i;
    BOOL		AllDesiredParamsRequested;
    UCHAR		nakedoption[MAX_OPTION_LENGTH];
    DWORD		rc;

    contextp = (PIPXCP_CONTEXT)pWorkBuffer;

    TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: Entered for if # %d\n",
	  contextp->Config.InterfaceIndex);

    if(contextp->RouteState == NO_ROUTE) {

	return(ERROR_NO_NETWORK);
    }

    // start by marking all negotiable parameters as not requested yet
    for(i=0; i<MaxDesiredParameters; i++) {

	DesiredParameterRequested[i] = !contextp->DesiredParameterNegotiable[i];
    }
    contextp = (PIPXCP_CONTEXT)pWorkBuffer;

    // get the total cnfg request packet length
    GETSHORT2USHORT(&cnfglen, pReceiveBuffer->Length);

    // check that the result buffer is at least as big as the receive buffer
    if((USHORT)cbResultBuffer < cnfglen) {

	return(ERROR_PPP_INVALID_PACKET);
    }

    // set the ptrs and length to the start of the options in the packet
    pResultBuffer->Code = CONFIG_ACK;
    rcvptr = (PUCHAR)pReceiveBuffer;
    resptr = (PUCHAR)pResultBuffer;

    if(contextp->Config.IpxwanConfigRequired) {

	if(cnfglen > 4) {

	    pResultBuffer->Code = CONFIG_REJ;

	    for(rcvlen = reslen = 4;
		rcvlen < cnfglen;
		rcvlen += optlen) {

		// get the current option type and length
		option = *(rcvptr + rcvlen + OPTIONH_TYPE);
		optlen = *(rcvptr + rcvlen + OPTIONH_LENGTH);

		CopyOption(resptr + reslen, rcvptr + rcvlen);
		reslen += optlen;
	    }

	    // set the final result length
	    PUTUSHORT2SHORT(pResultBuffer->Length, reslen);

	    TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: reject all options because IPXWAN required\n");
	}
	else
	{
	    PUTUSHORT2SHORT(pResultBuffer->Length, 4);

	    TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: ack null options packet because IPXWAN required\n");
	}

	return (NO_ERROR);
    }

    for(rcvlen = reslen = 4;
	rcvlen < cnfglen;
	rcvlen += optlen) {

	// get the current option type and length
	option = *(rcvptr +  rcvlen + OPTIONH_TYPE);
	optlen = *(rcvptr + rcvlen + OPTIONH_LENGTH);

	switch(pResultBuffer->Code) {

	    case CONFIG_ACK:

		// Check if this is a valid option
		if((rc = ValidOption(option, optlen)) != NO_ERROR) {

		    if(rc == ERROR_INVALID_OPTLEN) {

			TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: option %d has invalid length %d\n",
			      option, optlen);

			return ERROR_PPP_NOT_CONVERGING;
		    }

		    // reject this option
		    pResultBuffer->Code = CONFIG_REJ;

		    // restart the result packet with this rejected option
		    reslen = 4;
		    CopyOption(resptr + reslen, rcvptr + rcvlen);
		    reslen += optlen;

		    TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: REJECT option %\n",
				   option);

		    break;
		}

		// Option is valid.
		// Check if it is desired and acceptable
		if(DesiredOption(option, &i)) {

		    DesiredParameterRequested[i] = TRUE;

		    if(!OptionHandler[option](rcvptr + rcvlen,
					      contextp,
					      nakedoption,
					      RCVREQ_OPTION)) {


			// if this is a renegociation, we are not converging!
			if(contextp->RouteState == ROUTE_ACTIVATED) {

			    TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: Not Converging\n");

			    return ERROR_PPP_NOT_CONVERGING;
			}

			if((option == IPX_NETWORK_NUMBER) &&
			   (contextp->NetNumberNakSentCount >= MAX_NET_NUMBER_NAKS_SENT)) {

			    TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: Not converging because TOO MANY NAKs SENT!!\n");

			    return ERROR_PPP_NOT_CONVERGING;
			}

			//
			//*** NAK this option ***
			//

			// check if we should send a reject instead
			if(fRejectNaks) {

			    // make up a reject packet
			    pResultBuffer->Code = CONFIG_REJ;

			    // restart the result packet with this rejected option
			    reslen = 4;
			    CopyOption(resptr + reslen, rcvptr + rcvlen);
			    reslen += optlen;

			    break;
			}

			pResultBuffer->Code = CONFIG_NAK;

			// restart the result packet with the NAK-ed option
			reslen = 4;
			CopyOption(resptr + reslen, nakedoption);

			reslen += optlen;

			TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: NAK option %d\n", option);

			break;
		    }

		}

		// Option is valid and either desired AND accepted or
		// not desired and we will accept it without any testing
		// Ack it and increment the result length.
		CopyOption(resptr + reslen, rcvptr + rcvlen);
		reslen += optlen;

		break;

	    case CONFIG_NAK:

		// Check if this is a valid option
		if((rc = ValidOption(*(rcvptr + rcvlen + OPTIONH_TYPE),
				     *(rcvptr + rcvlen + OPTIONH_LENGTH))) != NO_ERROR) {

		    if(rc == ERROR_INVALID_OPTLEN) {

			TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: option %d has invalid length %d\n",
			      *(rcvptr + rcvlen + OPTIONH_TYPE),
			      *(rcvptr + rcvlen + OPTIONH_LENGTH));

			return ERROR_PPP_NOT_CONVERGING;
		    }

		    // reject this option
		    pResultBuffer->Code = CONFIG_REJ;

		    // restart the result packet with this rejected option
		    reslen = 4;
		    CopyOption(resptr + reslen, rcvptr + rcvlen);
		    reslen += optlen;

		    break;
		}

		// We are looking only for options to NAK and skip all others
		if(DesiredOption(option, &i)) {

		    DesiredParameterRequested[i] = TRUE;

		    if(!OptionHandler[option](rcvptr + rcvlen,
					     contextp,
					     resptr + reslen,
					     RCVREQ_OPTION)) {
			reslen += optlen;

			TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: NAK option %d\n", option);

			if((option == IPX_NETWORK_NUMBER) &&
			   (contextp->NetNumberNakSentCount >= MAX_NET_NUMBER_NAKS_SENT)) {

			    TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: TOO MANY NAKs SENT!!\n");

			    return ERROR_PPP_NOT_CONVERGING;
			}
		    }
		}

		break;

	    case CONFIG_REJ:

		// We are looking only for options to reject and skip all others
		if((rc = ValidOption(*(rcvptr + rcvlen + OPTIONH_TYPE),
				     *(rcvptr + rcvlen + OPTIONH_LENGTH))) != NO_ERROR) {

		   if(rc == ERROR_INVALID_OPTLEN) {

			TraceIpx(PPPIF_TRACE, "IpxCpMakeConfigResult: option %d has invalid length %d\n",
			      *(rcvptr + rcvlen + OPTIONH_TYPE),
			      *(rcvptr + rcvlen + OPTIONH_LENGTH));

			return ERROR_PPP_NOT_CONVERGING;
		    }

		    CopyOption(resptr + reslen, rcvptr + rcvlen);
		    reslen += optlen;
		}

		if(DesiredOption(option, &i)) {

		    DesiredParameterRequested[i] = TRUE;
		}

		break;

	    default:

		SS_ASSERT(FALSE);
		break;
	}
    }

    // check if all our desired parameters have been requested
    AllDesiredParamsRequested = TRUE;

    for(i=0; i<MaxDesiredParameters; i++) {

	if(!DesiredParameterRequested[i]) {

	    AllDesiredParamsRequested = FALSE;
	}
    }

    if(AllDesiredParamsRequested) {

	//
	//*** ALL DESIRED PARAMETERS HAVE BEEN REQUESTED ***
	//

	// set the final result length
	PUTUSHORT2SHORT(pResultBuffer->Length, reslen);

	return (NO_ERROR);
    }

    //
    //***  SOME DESIRED PARAMETERS ARE MISSING ***
    //

    // check that we have enough result buffer to transmit all our non received
    // desired params
    if((USHORT)cbResultBuffer < DesiredConfigReqLength()) {

	return(ERROR_INSUFFICIENT_BUFFER);
    }

    switch(pResultBuffer->Code) {

	case CONFIG_ACK:

	    // the only case where we request a NAK when a requested parameter
	    // is missing is when this parameter is the node number
	    if(DesiredParameterRequested[IPX_NODE_NUMBER_INDEX]) {

		break;
	    }
	    else
	    {
		// reset the ACK packet and make it NAK packet
		pResultBuffer->Code = CONFIG_NAK;
		reslen = 4;

		// FALL THROUGH
	    }

	case CONFIG_NAK:

	    // Append the missing options in the NAK packet
	    for(i=0; i<MaxDesiredParameters; i++) {

		if(DesiredParameterRequested[i]) {

		    // skip it!
		    continue;
		}

		option = DesiredParameter[i];

		if((option == IPX_NETWORK_NUMBER) ||
		   (option == IPX_COMPRESSION_PROTOCOL)) {

		    // These two desired options are not forced in a nak if
		    // the other end didn't provide them.

		    // skip it!
		    continue;
		}

		OptionHandler[option](NULL,
				      contextp,
				      resptr + reslen,
				      SNDNAK_OPTION);

		optlen = *(resptr + reslen + OPTIONH_LENGTH);
		reslen += optlen;
	    }

	    break;

	default:

	    break;
    }

    // set the final result length
    PUTUSHORT2SHORT(pResultBuffer->Length, reslen);

    return (NO_ERROR);
}

DWORD
IpxCpConfigNakReceived(IN VOID		*pWorkBuffer,
		       IN PPP_CONFIG	*pReceiveBuffer)
{
    PIPXCP_CONTEXT		contextp;
    PUCHAR			rcvptr;
    USHORT			rcvlen;
    USHORT			naklen;
    UCHAR			option;
    UCHAR			optlen;
    DWORD			rc;

    contextp = (PIPXCP_CONTEXT)pWorkBuffer;

    TraceIpx(PPPIF_TRACE, "IpxCpConfigNakReceived: Entered for if # %d\n",
	  contextp->Config.InterfaceIndex);


    if(contextp->Config.IpxwanConfigRequired) {

	return NO_ERROR;
    }

    rcvptr = (PUCHAR)pReceiveBuffer;
    GETSHORT2USHORT(&naklen, pReceiveBuffer->Length);

    for(rcvlen = 4; rcvlen < naklen; rcvlen += optlen) {

	// get the current option type and length
	option = *(rcvptr +  rcvlen + OPTIONH_TYPE);
	optlen = *(rcvptr + rcvlen + OPTIONH_LENGTH);

	if((rc = ValidOption(option, optlen)) != NO_ERROR) {

	    if(rc == ERROR_INVALID_OPTLEN) {

		TraceIpx(PPPIF_TRACE, "IpxCpConfigNakReceived: option %d has invalid length %d\n",
		      option, optlen);

		return ERROR_PPP_NOT_CONVERGING;
	    }

	    TraceIpx(PPPIF_TRACE, "IpxCpConfigNakReceived: option %d not valid\n", option);

	    // ignore this option
	    continue;
	}
	else
	{
	    // valid option
	    OptionHandler[option](rcvptr + rcvlen,
				  contextp,
				  NULL,
				  RCVNAK_OPTION);

	    if((option == IPX_NETWORK_NUMBER) &&
	       (contextp->NetNumberNakReceivedCount >= MAX_NET_NUMBER_NAKS_RECEIVED)) {

		TraceIpx(PPPIF_TRACE, "IpxCpConfigNakReceived: TOO MANY NAKs RECEIVED !! terminate IPXCP negotiation\n");

		return ERROR_PPP_NOT_CONVERGING;
	    }
	}
    }

    return NO_ERROR;
}

DWORD
IpxCpConfigAckReceived(IN VOID		*pWorkBuffer,
		       IN PPP_CONFIG	*pReceiveBuffer)
{
    PIPXCP_CONTEXT		contextp;
    PUCHAR			rcvptr;
    USHORT			rcvlen;
    USHORT			acklen;
    UCHAR			option;
    USHORT			optlen;


    contextp = (PIPXCP_CONTEXT)pWorkBuffer;

    TraceIpx(PPPIF_TRACE, "IpxCpConfigAckReceived: Entered for if # %d\n",
	 contextp->Config.InterfaceIndex);

    // check that this is what we have requested
    rcvptr = (PUCHAR)pReceiveBuffer;
    GETSHORT2USHORT(&acklen, pReceiveBuffer->Length);

    if(contextp->Config.IpxwanConfigRequired) {

	if(acklen != 4) {

	    return ERROR_PPP_NOT_CONVERGING;
	}
	else
	{
	    return NO_ERROR;
	}
    }

    for(rcvlen = 4; rcvlen < acklen; rcvlen += optlen) {

	// get the current option type and length
	option = *(rcvptr +  rcvlen + OPTIONH_TYPE);
	optlen = *(rcvptr + rcvlen + OPTIONH_LENGTH);

	if(!DesiredOption(option, NULL)) {

	    // this is not our option!

	    TraceIpx(PPPIF_TRACE, "IpxCpConfigAckReceived: Option %d not desired\n", option);

	    return ERROR_PPP_NOT_CONVERGING;
	}

	if(!OptionHandler[option](rcvptr + rcvlen,
				  contextp,
				  NULL,
				  RCVACK_OPTION)) {

	    // this option doesn't have our configured request value

	    TraceIpx(PPPIF_TRACE, "IpxCpConfigAckReceived: Option %d not our value\n", option);

	    return ERROR_PPP_NOT_CONVERGING;
	}
    }

    TraceIpx(PPPIF_TRACE, "IpxCpConfigAckReceived: All options validated\n");

    return NO_ERROR;
}

DWORD
IpxCpConfigRejReceived(IN VOID		*pWorkBuffer,
		       IN PPP_CONFIG	*pReceiveBuffer)
{
    PIPXCP_CONTEXT		contextp;
    PUCHAR			rcvptr;
    USHORT			rcvlen;
    USHORT			rejlen;
    UCHAR			option;
    USHORT			optlen;
    int 			i;

    // if we are a server node or a client on a server machine, we don't accept
    // any rejection
    if(IsRouterStarted()) {

	TraceIpx(PPPIF_TRACE, "IpxCpConfigRejReceived: Cannot handle rejects on a router, aborting\n");
	return ERROR_PPP_NOT_CONVERGING;
    }

    // This node doesn't have a router. We continue the negotiation with the
    // remaining options.
    // If the network number negotiation has been rejected, we will tell the
    // ipx stack that we have net number 0 and let it deal with it.

    contextp = (PIPXCP_CONTEXT)pWorkBuffer;

    TraceIpx(PPPIF_TRACE, "IpxCpConfigRejReceived: Entered for if # %d\n",
	  contextp->Config.InterfaceIndex);

    if(contextp->Config.IpxwanConfigRequired) {

	return ERROR_PPP_NOT_CONVERGING;
    }

    // check that this is what we have requested
    rcvptr = (PUCHAR)pReceiveBuffer;
    GETSHORT2USHORT(&rejlen, pReceiveBuffer->Length);

    for(rcvlen = 4; rcvlen < rejlen; rcvlen += optlen) {

	// get the current option type and length
	option = *(rcvptr +  rcvlen + OPTIONH_TYPE);
	optlen = *(rcvptr + rcvlen + OPTIONH_LENGTH);

	if(optlen == 0) {

	    TraceIpx(PPPIF_TRACE, "IpxCpConfigRejReceived: received null option length, aborting\n");

	    return ERROR_PPP_NOT_CONVERGING;
	}

	for(i=0; i<MAX_DESIRED_PARAMETERS; i++) {

	    if(option == DesiredParameter[i]) {

		switch(i) {

		    case 0:

			TraceIpx(PPPIF_TRACE, "IpxCpConfigRejReceived: Turn off Network Number negotiation\n");

			break;

		    case 1:

			TraceIpx(PPPIF_TRACE, "IpxCpConfigRejReceived: Turn off Node Number negotiation\n");

			break;

		    default:

			break;
		}

		contextp->DesiredParameterNegotiable[i] = FALSE;

		// if this is the node configuration rejected, set the remote
		// node to 0 to indicate it's unknown.
		if(option == IPX_NODE_NUMBER) {

		    memcpy(contextp->Config.RemoteNode, nullnode, 6);
		}
	    }
	}
    }

    return NO_ERROR;
}


DWORD
IpxCpThisLayerDown(IN VOID *pWorkBuffer)
{
    dwClientCount--;
    TraceIpx(PPPIF_TRACE, "IpxCpThisLayerDown: Entered (%d total)\n", dwClientCount);

    // If the last client hung up, go ahead and update all of the global
    // config
    if (dwClientCount == 0)
        IpxcpUpdateQueuedGlobalConfig();

    return 0L;
}

char * YesNo (DWORD dwVal) {
    return (dwVal) ? "YES" : "NO";
}    

//
// Gets called when a registry value related to ppp changes.  This
// function must read in the new registry config and plumb any 
// changes it finds.
//
// The following values will be supported for on the fly update
// since they are exposed through connections ui:
//      CQC_THIS_MACHINE_ONLY
//      CQC_ENABLE_GLOBAL_WAN_NET
//      CQC_FIRST_WAN_NET
//      CQC_ENABLE_AUTO_WAN_NET_ALLOCATION
//      CQC_ACCEPT_REMOTE_NODE_NUMBER
//
// In addition the following will be supported
//      CQC_FIRST_WAN_NODE
//
DWORD
IpxCpUpdateGlobalConfig() 
{
    IPXCP_GLOBAL_CONFIG_PARAMS Params;
    DWORD dwErr;
    INT iCmp;
    
    TraceIpx(PPPIF_TRACE, "IpxCpUpdateGlobalConfig: Entered");
    
    // Re-read the configuration from the registry
    CopyMemory (&Params, &GlobalConfig, sizeof (Params));
    GetIpxCpParameters(&Params);

    // First, go through and update any parameters that can immediately be 
    // applied.  Included in these are: CQC_THIS_MACHINE_ONLY
    //
    if (!!(Params.RParams.ThisMachineOnly) != !!(GlobalConfig.RParams.ThisMachineOnly)) {
        GlobalConfig.RParams.ThisMachineOnly = !!(Params.RParams.ThisMachineOnly);
        // Tell the router manager that some configuration has updated
        if (RmUpdateIpxcpConfig) {
            if ((dwErr = RmUpdateIpxcpConfig (&(GlobalConfig.RParams))) != NO_ERROR)
                return dwErr;
        }            
    }

    // Now, go through and queue any settings that will take
    // delayed effect.
    //
    // Queue any changes to the global wan net enabling
    if (!!(Params.RParams.EnableGlobalWanNet) != !!(GlobalConfig.RParams.EnableGlobalWanNet))
        CQAdd ( hConfigQueue, 
                CQC_ENABLE_GLOBAL_WAN_NET, 
                &(Params.RParams.EnableGlobalWanNet), 
                sizeof (Params.RParams.EnableGlobalWanNet));

    // Queue any changes to the globalwan/firstwan setting
    if (Params.FirstWanNet != GlobalConfig.FirstWanNet)
        CQAdd (hConfigQueue, CQC_FIRST_WAN_NET, &(Params.FirstWanNet), sizeof(Params.FirstWanNet));

    // Queue any changes to the auto net assignment enabling                           
    if (!!(Params.EnableAutoWanNetAllocation) != !!(GlobalConfig.EnableAutoWanNetAllocation))
        CQAdd ( hConfigQueue, 
                CQC_ENABLE_AUTO_WAN_NET_ALLOCATION, 
                &(Params.EnableAutoWanNetAllocation), 
                sizeof (Params.EnableAutoWanNetAllocation));

    // Queue any changes to the accept remote node enabling
    if (!!(Params.AcceptRemoteNodeNumber) != !!(GlobalConfig.AcceptRemoteNodeNumber))
        CQAdd ( hConfigQueue, 
                CQC_ACCEPT_REMOTE_NODE_NUMBER, 
                &(Params.AcceptRemoteNodeNumber), 
                sizeof (Params.AcceptRemoteNodeNumber));

    // Queue any changes to the first remote node setting
    if (memcmp (Params.puSpecificNode, GlobalConfig.puSpecificNode, 6) != 0)
        CQAdd (hConfigQueue, CQC_FIRST_WAN_NODE, Params.puSpecificNode, 6);

    // If there are no clients, go ahead and update the queued config
    //
    if (dwClientCount == 0) {
        if ((dwErr = IpxcpUpdateQueuedGlobalConfig()) != NO_ERROR)
            return dwErr;
    }

    TraceIpx(PPPIF_TRACE, "IpxCpUpdateGlobalConfig: exiting...\n");
    
    return NO_ERROR;
}

//
// Callback function used to update each piece of queued configuration
// data one at a time.  The client count is assumed to be zero when this
// function is called.
//
BOOL  
IpxcpUpdateConfigItem (DWORD dwCode, LPVOID pvData, DWORD dwSize, ULONG_PTR ulpUser) {
    DWORD dwErr, dwData = *(DWORD*)pvData;
    PUCHAR puData = (PUCHAR)pvData;
    DWORD* pdwFlags = (DWORD*)ulpUser;

    TraceIpx(PPPIF_TRACE, "IpxcpUpdateConfigItem: Entered for item code %x", dwCode);
    
    switch (dwCode) {
        case CQC_ENABLE_GLOBAL_WAN_NET:
            TraceIpx(PPPIF_TRACE, "IpxcpUpdateConfigItem: EnableGlobalWanNet %s", YesNo(dwData));
            GlobalConfig.RParams.EnableGlobalWanNet = !!dwData;
            *pdwFlags |= FLAG_UPDATE_ROUTER | FLAG_UPDATE_WANNET;
            break;
            
        case CQC_FIRST_WAN_NET:
            TraceIpx(PPPIF_TRACE, "IpxcpUpdateConfigItem: FirstWanNet %x", dwData);
            GlobalConfig.FirstWanNet = dwData;
            *pdwFlags |= FLAG_UPDATE_WANNET;
            break;
            
        case CQC_ENABLE_AUTO_WAN_NET_ALLOCATION:
            TraceIpx(PPPIF_TRACE, "IpxcpUpdateConfigItem: EnableAutoAssign %s", YesNo(dwData));
            GlobalConfig.EnableAutoWanNetAllocation = !!dwData;
            *pdwFlags |= FLAG_UPDATE_WANNET;
            break;
            
        case CQC_ACCEPT_REMOTE_NODE_NUMBER:
            TraceIpx(PPPIF_TRACE, "IpxcpUpdateConfigItem: AcceptRemoteNodeNumber %s", YesNo(dwData));
            GlobalConfig.AcceptRemoteNodeNumber = !!dwData;
            break;
            
        case CQC_FIRST_WAN_NODE:
            TraceIpx(PPPIF_TRACE, "IpxcpUpdateConfigItem: FirstWanNode %x%x%x%x%x%x", puData[0], puData[1], puData[2], puData[3], puData[4], puData[5]);
            memcpy (GlobalConfig.puSpecificNode, pvData, 6);
            GETLONG2ULONG(&LastNodeAssigned,&(GlobalConfig.puSpecificNode[2]));
            break;
    }
    
    return NO_ERROR;
}

//
// Called only when client count is zero to update any settings that have
// been queued to take place.
//
DWORD
IpxcpUpdateQueuedGlobalConfig() {
    DWORD dwErr, dwFlags = 0;

    TraceIpx(PPPIF_TRACE, "IpxcpUpdateQueuedGlobalConfig: entered");

    // Enumerate all of the queued config information updating 
    // global config as we go.
    //
    if ((dwErr = CQEnum (hConfigQueue, IpxcpUpdateConfigItem, (ULONG_PTR)&dwFlags)) != NO_ERROR)
        return dwErr;

    // If we need to update the wan net, do so
    //
    if (dwFlags & FLAG_UPDATE_WANNET) {
        TraceIpx(PPPIF_TRACE, "IpxcpUpdateQueuedGlobalConfig: Updating WanNet Information.");
        WanNetReconfigure();
    }

    // If we need to update the router, do so
    //
    if (dwFlags & FLAG_UPDATE_ROUTER) {
        TraceIpx(PPPIF_TRACE, "IpxcpUpdateQueuedGlobalConfig: Updating Router.");
        if (RmUpdateIpxcpConfig) {
            if ((dwErr = RmUpdateIpxcpConfig (&(GlobalConfig.RParams))) != NO_ERROR)
                return dwErr;
        }            
    }

    // Clear the queued config data as it has been completely processed
    // at this point.
    //
    CQRemoveAll (hConfigQueue);
    
    return NO_ERROR;
}


DWORD
ValidOption(UCHAR	option,
	    UCHAR	optlen)
{
    //
    // NarenG: Put in fix for Bug # 74555. Otherwise PPP was blocked in
    // NakReceived which was in a forever loop.
    //

    if ( optlen == 0 )
    {
        return( ERROR_INVALID_OPTLEN );
    }

    switch(option) 
    {
    	case IPX_NETWORK_NUMBER:
    	    if(optlen != 6) 
    	    {
        		return ERROR_INVALID_OPTLEN;
    	    }
    	    return NO_ERROR;
            break;

    	case IPX_NODE_NUMBER:
            if(optlen != 8) 
            {
                return ERROR_INVALID_OPTLEN;
            }
            return NO_ERROR;
            break;

    	case IPX_ROUTING_PROTOCOL:
    	    if(optlen < 4) 
    	    {
        		return ERROR_INVALID_OPTLEN;
    	    }
    	    return NO_ERROR;
            break;

    	case IPX_ROUTER_NAME:
    	    if(optlen < 3) 
    	    {
        		return ERROR_INVALID_OPTLEN;
    	    }
            else
            {
                TraceIpx(
                    PPPIF_TRACE, 
                    "ValidOption: Accept Router Name w/ valid len.");
                    
        	    return NO_ERROR;
            }
            break;

    	case IPX_CONFIGURATION_COMPLETE:
    	    if(optlen != 2) 
    	    {
        		return ERROR_INVALID_OPTLEN;
    	    }
       	    return NO_ERROR;
            break;

    	case IPX_COMPRESSION_PROTOCOL:
    	    if(GlobalConfig.EnableCompressionProtocol) 
    	    {
        		if(optlen < 4) 
        		{
        		    return ERROR_INVALID_OPTLEN;
        		}
    	    }
    	    else
    	    {
    	    	return ERROR_INVALID_OPTION;
    	    }
            break;

    	default:
    	    return ERROR_INVALID_OPTION;
    }

    return ERROR_INVALID_OPTION;
}


BOOL
DesiredOption(UCHAR	option, USHORT	*indexp)
{
    USHORT	    i;

    for(i=0; i<MaxDesiredParameters; i++) {

	if(option == DesiredParameter[i]) {

	    if(indexp) {

		*indexp = i;
	    }

	    return TRUE;
	}
    }

    return FALSE;
}

USHORT
DesiredConfigReqLength(VOID)
{
    USHORT	i, len;

    for(i=0, len=0; i<MaxDesiredParameters; i++) {

	len += DesiredParameterLength[i];
    }

    return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\ipxstub.c ===
// misc temporary stubs

#include "precomp.h"
#pragma hdrstop


// This function return the counter in minutes since last activity
// occured on this connection.
//
//  Parameters:
//			ConnectionId - identifies the connection passed in LineUp
//				       to the IPX stack
//			IpxConnectionHandle - initially -1 and filled by the
//					      IPX stack on return to the value
//					      corresponding to the connection Id
//					      In subsequent calls this is used.
//			WanInnnactivityCounter -
//
//

DWORD
IpxGetWanInactivityCounter(
		    IN ULONG	    ConnectionId,
		    IN PULONG	    IpxConnectionHandle,
		    IN PULONG	    WanInactivityCounter)
{
    *WanInactivityCounter = 0;

    return NO_ERROR;
}


//  This function checks if the specified network exists on the net
//  If there is no router installed, it does a re-rip to find out
//
//  Return:	    TRUE    - The net number is in use

// BOOL
// IpxIsRoute(PUCHAR	Network);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\ipxcpdbg.h ===
/*******************************************************************/
/*	      Copyright(c)  1994 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	ipxcpdbg.h
//
// Description: This module debug definitions for
//		the debug utilities
//
// Author:	Stefan Solomon (stefans)    Jan 10, 1994
//
// Revision History:
//
//***



#ifndef _IPXCPDBG_
#define _IPXCPDBG_


#define PPPIF_TRACE			0x00010000
#define OPTIONS_TRACE			0x00020000
#define WANNET_TRACE			0x00040000
#define RMIF_TRACE			0x00080000
#define RASMANIF_TRACE			0x00100000
#define IPXWANIF_TRACE			0x00200000

#if DBG

extern DWORD	DbgLevel;

#define DEBUG if ( TRUE )
#define IF_DEBUG(flag) if (DbgLevel & (DEBUG_ ## flag))

VOID
SsDbgInitialize(VOID);

VOID
SsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    );

VOID
SsPrintf (
    char *Format,
    ...
    );

VOID
SsResetDbgLogFile(VOID);

#define SS_PRINT(args) SsPrintf args

#define SS_ASSERT(exp) if (!(exp)) SsAssert( #exp, __FILE__, __LINE__ )

#define SS_DBGINITIALIZE  SsDbgInitialize()

#define SS_RESETDBGLOGFILE  SsResetDbgLogFile()

#else

#define DEBUG if ( FALSE )
#define IF_DEBUG(flag) if (FALSE)

#define SS_PRINT(args)

#define SS_ASSERT(exp)

#define SS_DBGINITIALIZE

#define SS_RESETDBGLOGFILE()

#endif // DBG

//*** Definitions to enable debug printing

#define DEFAULT_DEBUG		    0x0FFFF

#endif // ndef _IPXCPDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\ipxwanif.c ===
/*******************************************************************/
/*	      Copyright(c)  1996 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	ipxwanif.c
//
// Description: routines for interfacing with ipxwan
//
// Author:	Stefan Solomon (stefans)    March 12, 1996
//
// Revision History:
//
//***

#include "precomp.h"
#pragma  hdrstop

HINSTANCE	IpxWanDllHandle;

PIPXWAN_BIND	IpxwanBind;
PIPXWAN_UNBIND	IpxwanUnbind;

VOID
IpxcpConfigDoneCompletion(ULONG_PTR	    ConnectionId);

DWORD
IpxcpConfigDone(ULONG		ConnectionId,
		PUCHAR		Network,
		PUCHAR		LocalNode,
		PUCHAR		RemoteNode,
		BOOL		Success);

ULONG
IpxcpGetInterfaceType(ULONG	    ConnectionId);

DWORD
IpxcpGetRemoteNode(ULONG	      ConnectionId,
		   PUCHAR	      RemoteNode);


/*++

Function:	LoadIpxWan

Descr:		Load the ipxwan.dll and bind to it if present

--*/

VOID
LoadIpxWan(VOID)
{
    IPXWAN_INTERFACE	    IpxwanIf;

    if((IpxWanDllHandle = LoadLibrary(IPXWANDLLNAME)) == NULL) {

	TraceIpx(IPXWANIF_TRACE, "LoadIpxWan: IPXWAN DLL not present\n");
	return;
    }

    if( ((IpxwanBind = (PIPXWAN_BIND)GetProcAddress(IpxWanDllHandle,
						   IPXWAN_BIND_ENTRY_POINT_STRING)) == NULL)
        || ((IpxwanUnbind = (PIPXWAN_UNBIND)GetProcAddress(IpxWanDllHandle,
						   IPXWAN_UNBIND_ENTRY_POINT_STRING)) == NULL)){

	TraceIpx(IPXWANIF_TRACE, "LoadIpxWan: Failed to get IPXWAN Entry point!\n");
    FreeLibrary (IpxWanDllHandle);
    IpxWanDllHandle = NULL;
	return;
    }

    IpxwanIf.EnableUnnumberedWanLinks = GlobalConfig.EnableUnnumberedWanLinks;
    IpxwanIf.IpxcpGetWanNetNumber = GetWanNetNumber;
    IpxwanIf.IpxcpReleaseWanNetNumber = ReleaseWanNetNumber;
    IpxwanIf.IpxcpConfigDone = IpxcpConfigDone;
    IpxwanIf.IpxcpGetInternalNetNumber = GetInternalNetNumber;
    IpxwanIf.IpxcpGetInterfaceType = IpxcpGetInterfaceType;
    IpxwanIf.IpxcpGetRemoteNode = IpxcpGetRemoteNode;
    IpxwanIf.IpxcpIsRoute = IsRoute;

    if(IpxwanBind(&IpxwanIf) == NO_ERROR) {

	TraceIpx(IPXWANIF_TRACE, "LoadIpxWan: IPXWAN DLL loaded OK");
    }
    else
    {
	TraceIpx(IPXWANIF_TRACE, "LoadIpxWan: IpxwanBind failed!");
    FreeLibrary (IpxWanDllHandle);
    IpxWanDllHandle = NULL;
    }
}

VOID
UnloadIpxWan(VOID)
{
    if (IpxWanDllHandle!=NULL) {
        IpxwanUnbind ();
        FreeLibrary (IpxWanDllHandle);
    }
}


/*++

Function:	IpxcpConfigDone

Descr:		Tells IPXCP that the link has been configured OR that it
		should be terminated.
		If configured, the config parameters will be copied into the
		work buffer so that they are available for reporting to PPP
		(IpxCpGetNetworkAddress)
--*/

DWORD
IpxcpConfigDone(ULONG		ConnectionId,
		PUCHAR		Network,
		PUCHAR		LocalNode,
		PUCHAR		RemoteNode,
		BOOL		Success)
{
    PIPXCP_CONTEXT	contextp;

    TraceIpx(IPXWANIF_TRACE, "IpxcpConfigDone: Entered for ConectionId %d\n", ConnectionId);

    ACQUIRE_DATABASE_LOCK;

    if((contextp = GetContextBuffer(ConnectionId)) == NULL) {

	TraceIpx(IPXWANIF_TRACE, "IpxcpConfigDone: ConectionId %d not present\n", ConnectionId);

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    contextp->IpxwanState = IPXWAN_DONE;

    if(!Success) {

	contextp->IpxwanConfigResult = ERROR_CAN_NOT_COMPLETE;
    }
    else
    {
	contextp->IpxwanConfigResult = NO_ERROR;
	memcpy(contextp->Config.Network, Network, 4);
	memcpy(contextp->Config.LocalNode, LocalNode, 6);
	memcpy(contextp->Config.RemoteNode, RemoteNode, 6);
    }

    RELEASE_DATABASE_LOCK;

    if(!QueueUserAPC(IpxcpConfigDoneCompletion,
		      PPPThreadHandle,
		      ConnectionId)) {

	TraceIpx(IPXWANIF_TRACE, "IpxcpConfigDone: Error queueing the APC to PPP\n");

	return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
}


/*++

Function:	IpxcpGetInterfaceType

Descr:

--*/

ULONG
IpxcpGetInterfaceType(ULONG	    ConnectionId)
{
    ULONG		InterfaceType;
    PIPXCP_CONTEXT	contextp;

    ACQUIRE_DATABASE_LOCK;

    if((contextp = GetContextBuffer(ConnectionId)) == NULL) {

	TraceIpx(IPXWANIF_TRACE, "IpxcpGetInterfaceType: ConectionId %d not present\n", ConnectionId);

	RELEASE_DATABASE_LOCK;
	return IF_TYPE_OTHER;
    }

    InterfaceType = contextp->InterfaceType;

    RELEASE_DATABASE_LOCK;

    return InterfaceType;
}

/*++

Function:	IpxcpGetRemoteNode

Descr:		Called when the remote peer is a workstation.
		Returns the node number assigned to it by the local router.

--*/

DWORD
IpxcpGetRemoteNode(ULONG	      ConnectionId,
		   PUCHAR	      RemoteNode)
{
    ULONG		InterfaceType;
    PIPXCP_CONTEXT	contextp;

    ACQUIRE_DATABASE_LOCK;

    if((contextp = GetContextBuffer(ConnectionId)) == NULL) {

	TraceIpx(IPXWANIF_TRACE, "IpxcpGetRemoteNode: ConectionId %d not present\n", ConnectionId);

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    memcpy(RemoteNode, contextp->Config.RemoteNode, 6);

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

VOID
IpxcpConfigDoneCompletion(ULONG_PTR	    ConnectionId)
{
    PIPXCP_CONTEXT	contextp;
    DWORD		Error;
    DWORD		rc;

    ACQUIRE_DATABASE_LOCK;

    if((contextp = GetContextBuffer(ConnectionId)) == NULL) {

	RELEASE_DATABASE_LOCK;
	return;
    }

    Error = contextp->IpxwanConfigResult;

    RELEASE_DATABASE_LOCK;

    TraceIpx(IPXWANIF_TRACE, "IpxcpConfigDoneCompletion: Calling PPPCompletionRoutine with ConnId=%d, Error=%d\n",
	  ConnectionId,
	  Error);

    (*PPPCompletionRoutine)((HCONN)ConnectionId,
			    PPP_IPXCP_PROTOCOL,
			    NULL,
			    Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\options.c ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	    options.c
//
// Description:     routines for options handling
//
// Author:	    Stefan Solomon (stefans)	November 24, 1993.
//
// Revision History:
//
//***

#include "precomp.h"
#pragma hdrstop

extern HANDLE g_hRouterLog;


VOID
SetNetworkNak(PUCHAR		resptr,
	      PIPXCP_CONTEXT	contextp);

VOID
SetNodeNak(PUCHAR		resptr,
	   PIPXCP_CONTEXT	contextp);

VOID
SetOptionTypeAndLength(PUCHAR		dstptr,
		       UCHAR		opttype,
		       UCHAR		optlen);



#if DBG

#define GET_LOCAL_NET  GETLONG2ULONG(&dbglocnet, contextp->Config.Network)

#else

#define GET_LOCAL_NET

#endif



//***
//
// Global description of option handlers
//
// Input:   optptr     - pointer to the respective option in the frame
//	    contextp   - pointer to the associated context (work buffer)
//	    resptr     - pointer to the response frame to be generated
//	    Action     - one of:
//			    SNDREQ_OPTION - optptr is the frame to be sent as
//					    a config request;
//			    RCVNAK_OPTION - optptr is the frame received as NAK
//			    RCVREQ_OPTION - optptr is the received request.
//					    resptr is the frame to generate back
//					    a response. If the response is not
//					    an ACK, the return code is FALSE.
//					    In this case if resptr is not NULL it
//					    gets the NAK frame.
//
//***


BOOL
NetworkNumberHandler(PUCHAR	       optptr,
		     PIPXCP_CONTEXT    contextp,
		     PUCHAR	       resptr,
		     OPT_ACTION	       Action)
{
    ULONG	recvdnet;
    ULONG	localnet;
    BOOL	rc = TRUE;
    UCHAR	newnet[4];

    UCHAR		asc[9];
    PUCHAR		ascp;

    // prepare to log if error
    asc[8] = 0;
    ascp = asc;

    switch(Action) {

	case SNDREQ_OPTION:

	    SetOptionTypeAndLength(optptr, IPX_NETWORK_NUMBER, 6);
	    memcpy(optptr + OPTIONH_DATA, contextp->Config.Network, 4);

	    GETLONG2ULONG(&localnet, contextp->Config.Network);
	    TraceIpx(OPTIONS_TRACE, "NetworkNumberHandler: SND REQ with net 0x%x\n", localnet);

	    break;

	case RCVNAK_OPTION:

	    contextp->NetNumberNakReceivedCount++;

	    GETLONG2ULONG(&recvdnet, optptr + OPTIONH_DATA);
	    GETLONG2ULONG(&localnet, contextp->Config.Network);

	    TraceIpx(OPTIONS_TRACE, "NetworkNumberHandler: RCV NAK with net 0x%x\n", recvdnet);

	    if(recvdnet > localnet) {


		if(IsRoute(optptr + OPTIONH_DATA)) {

		    if(GetUniqueHigherNetNumber(newnet,
						optptr + OPTIONH_DATA,
						contextp) == NO_ERROR) {

			// store a new net proposal for the next net send config request
			memcpy(contextp->Config.Network, newnet, 4);
		    }
		    else
		    {
			// cannot get a net number unique and higher
			break;
		    }
		}
		else
		{
		    if((contextp->InterfaceType == IF_TYPE_WAN_WORKSTATION) &&
		       GlobalConfig.RParams.EnableGlobalWanNet) {

			break;
		    }
		    else
		    {
			memcpy(contextp->Config.Network, optptr + OPTIONH_DATA, 4);
		    }
		}
	    }

	    break;

       case RCVACK_OPTION:

	    if(memcmp(contextp->Config.Network, optptr + OPTIONH_DATA, 4)) {

		rc = FALSE;
	    }

	    break;

	case RCVREQ_OPTION:

	    // if we have already negotiated and this is a renegociation, stick by
	    // what we have already told the stack in line-up
	    if(contextp->RouteState == ROUTE_ACTIVATED) {

		TraceIpx(OPTIONS_TRACE, "NetworkNumberHandler: rcv req in re-negociation\n");

		if(memcmp(contextp->Config.Network, optptr + OPTIONH_DATA, 4)) {

		    SetNetworkNak(resptr, contextp);
		    rc = FALSE;
		}

		break;
	    }

	    GETLONG2ULONG(&recvdnet, optptr + OPTIONH_DATA);
	    GETLONG2ULONG(&localnet, contextp->Config.Network);

	    // check if a network number has been requested
	    if((recvdnet == 0) &&
	       ((contextp->InterfaceType == IF_TYPE_STANDALONE_WORKSTATION_DIALOUT) ||
		(contextp->InterfaceType == IF_TYPE_ROUTER_WORKSTATION_DIALOUT))) {

		// this is a workstation and needs a network number
		if(GetUniqueHigherNetNumber(newnet,
					    nullnet,
					    contextp) == NO_ERROR) {

		    memcpy(contextp->Config.Network, newnet, 4);
		}

		SetNetworkNak(resptr, contextp);
		rc = FALSE;
	    }
	    else
	    {
		if(recvdnet > localnet) {

		    // check if we don't have a net number conflict
		    if(IsRoute(optptr + OPTIONH_DATA)) {

			NetToAscii(ascp, optptr + OPTIONH_DATA);
			RouterLogErrorW(
			    g_hRouterLog,
			    ROUTERLOG_IPXCP_NETWORK_NUMBER_CONFLICT,
			    1,
			    (PWCHAR*)&ascp,
			    NO_ERROR);

			if(GetUniqueHigherNetNumber(newnet,
						    optptr + OPTIONH_DATA,
						    contextp) == NO_ERROR) {

			    // new net is different, NAK with this new value
			    memcpy(contextp->Config.Network, newnet, 4);
			}

			SetNetworkNak(resptr, contextp);
			rc = FALSE;
		    }
		    else
		    {
			// the received net number is unique but is different
			// of the locally configured net number.

			if((contextp->InterfaceType == IF_TYPE_WAN_WORKSTATION) &&
			   GlobalConfig.RParams.EnableGlobalWanNet) {

			    NetToAscii(ascp, optptr + OPTIONH_DATA);
                RouterLogErrorW(
                    g_hRouterLog,
                    ROUTERLOG_IPXCP_CANNOT_CHANGE_WAN_NETWORK_NUMBER,
				     1,
				     (PWCHAR*)&ascp,
				     NO_ERROR);

			    SetNetworkNak(resptr, contextp);
			    rc = FALSE;
			}
			else
			{
			    // router is not installed or net number is unique
			    memcpy(contextp->Config.Network, optptr + OPTIONH_DATA, 4);
			}
		    }
		}
		else
		{
		    // recvdnet is smaller or equal with the local net
		    if(recvdnet < localnet) {

			// as per RFC - return the highest network number
			SetNetworkNak(resptr, contextp);
			rc = FALSE;
		    }
		}
	    }

	    break;

	case SNDNAK_OPTION:

	    // this option has not been requested by the remote end.
	    // Force it to request in a NAK
	    SetNetworkNak(resptr, contextp);

	    GETLONG2ULONG(&localnet, contextp->Config.Network);
	    TraceIpx(OPTIONS_TRACE, "NetworkNumberHandler: SND NAK to force request for net 0x%x\n", localnet);

	    rc = FALSE;

	    break;

	default:

	    SS_ASSERT(FALSE);
	    break;

    }

    return rc;
}

BOOL
NodeNumberHandler(PUCHAR	       optptr,
		  PIPXCP_CONTEXT       contextp,
		  PUCHAR	       resptr,
		  OPT_ACTION	       Action)
{
    BOOL	rc = TRUE;

    switch(Action) {

	case SNDREQ_OPTION:

	    SetOptionTypeAndLength(optptr, IPX_NODE_NUMBER, 8);
	    memcpy(optptr + OPTIONH_DATA, contextp->Config.LocalNode, 6);

	    TraceIpx(OPTIONS_TRACE, "NodeNumberHandler: SND REQ with local node %.2x%.2x%.2x%.2x%.2x%.2x\n",
			   contextp->Config.LocalNode[0],
			   contextp->Config.LocalNode[1],
			   contextp->Config.LocalNode[2],
			   contextp->Config.LocalNode[3],
			   contextp->Config.LocalNode[4],
			   contextp->Config.LocalNode[5]);

	    break;

	case RCVNAK_OPTION:

	    // If this is server config, then the client has rejected
	    // our local node number.  Ignore the suggestion
	    // to use a new one.  We will not negociate
        if(!contextp->Config.ConnectionClient)
	            break;

        // If we are the client, then we'll be happy to accept 
        // whatever the server assigns us.
	    memcpy(contextp->Config.LocalNode, optptr + OPTIONH_DATA, 6);
	    TraceIpx(OPTIONS_TRACE, "NodeNumberHandler: RCV NAK accepted. New local node %.2x%.2x%.2x%.2x%.2x%.2x\n",
			   contextp->Config.LocalNode[0],
			   contextp->Config.LocalNode[1],
			   contextp->Config.LocalNode[2],
			   contextp->Config.LocalNode[3],
			   contextp->Config.LocalNode[4],
			   contextp->Config.LocalNode[5]);
	    break;

	case RCVACK_OPTION:

	    if(memcmp(optptr + OPTIONH_DATA, contextp->Config.LocalNode, 6)) {

		rc = FALSE;
	    }

	    break;

	case RCVREQ_OPTION:
        // Is it legal to consider node options at this time?
	    if(contextp->RouteState == ROUTE_ACTIVATED) {
    		TraceIpx(OPTIONS_TRACE, "NodeNumberHandler: rcv req in re-negociation\n");
    		if(memcmp(contextp->Config.RemoteNode, optptr + OPTIONH_DATA, 6)) {
    		    SetNodeNak(resptr, contextp);
    		    rc = FALSE;
    		}
    		break;
	    }

	    // Check if the remote machine has specified any node number
	    if(!memcmp(optptr + OPTIONH_DATA, nullnode, 6)) {
    		// the remote node wants us to specify its node number.
    		SetNodeNak(resptr, contextp);
    		TraceIpx(OPTIONS_TRACE, "NodeNumberHandler: RCV REQ with remote node 0x0, snd NAK with remote node %.2x%.2x%.2x%.2x%.2x%.2x\n",
    			   contextp->Config.RemoteNode[0],
    			   contextp->Config.RemoteNode[1],
    			   contextp->Config.RemoteNode[2],
    			   contextp->Config.RemoteNode[3],
    			   contextp->Config.RemoteNode[4],
    			   contextp->Config.RemoteNode[5]);

    		rc = FALSE;
	    }
	    // Otherwise go through the process of determining whether we
	    // are able/willing to accept the remote node number suggested.
	    else {
            // If we have been set up as the ras server to reject the request for
            // a specific node number, do so here.
            if ( (GlobalConfig.AcceptRemoteNodeNumber == 0)                         &&
                 (contextp->InterfaceType == IF_TYPE_WAN_WORKSTATION)               &&
                 (memcmp(contextp->Config.RemoteNode, optptr + OPTIONH_DATA, 6)) )
            {
                SetNodeNak(resptr, contextp);
    			TraceIpx(OPTIONS_TRACE, "NodeNumberHandler: RCV REQ with remote client node but we force a specific node, snd NAK with remote node %.2x%.2x%.2x%.2x%.2x%.2x\n",
    				   contextp->Config.RemoteNode[0],
    				   contextp->Config.RemoteNode[1],
    				   contextp->Config.RemoteNode[2],
    				   contextp->Config.RemoteNode[3],
    				   contextp->Config.RemoteNode[4],
    				   contextp->Config.RemoteNode[5]);

    			rc = FALSE;
            }    			   
    	    
    		// else, if we are a ras server set up with a global network and the client
    		// requests a specific node number (different from our suggestion), then accept
    		// or reject the node based on whether that node is unique in the global network.
    		else if ( (!contextp->Config.ConnectionClient)                            &&
            		  (contextp->InterfaceType == IF_TYPE_WAN_WORKSTATION)            &&
    		          (memcmp(contextp->Config.RemoteNode, optptr + OPTIONH_DATA, 6)) &&
    		          (GlobalConfig.RParams.EnableGlobalWanNet) ) 
    		{
    		    ACQUIRE_DATABASE_LOCK;

    		    // remove the present node from the node HT
    		    RemoveFromNodeHT(contextp);

    		    // check the remote node is unique
    		    if(NodeIsUnique(optptr + OPTIONH_DATA)) {
        		    // copy this value in the context buffer
        		    memcpy(contextp->Config.RemoteNode, optptr + OPTIONH_DATA, 6);

        		    TraceIpx(OPTIONS_TRACE, "NodeNumberHandler: RCV REQ with remote client node different, ACCEPT it\n");
    		    }
    		    else {
        			// proposed node not unique -> NAK it
        			SetNodeNak(resptr, contextp);

        			TraceIpx(OPTIONS_TRACE, "NodeNumberHandler: RCV REQ with non unique remote client node, snd NAK with remote node %.2x%.2x%.2x%.2x%.2x%.2x\n",
        				   contextp->Config.RemoteNode[0],
        				   contextp->Config.RemoteNode[1],
        				   contextp->Config.RemoteNode[2],
        				   contextp->Config.RemoteNode[3],
        				   contextp->Config.RemoteNode[4],
        				   contextp->Config.RemoteNode[5]);

        			rc = FALSE;
    		    }

    		    // add node to HT
    		    AddToNodeHT(contextp);

    		    RELEASE_DATABASE_LOCK;
    		}

    		// Otherwise, it's ok to accept the node number that the other side 
    		// requests.  This is true for ras clients, ras servers that don't enforce
    		// specific node numbers, and ras server that don't assign the same
    		// network number to every dialed in client.
    		else
    		{
    		    memcpy(contextp->Config.RemoteNode, optptr + OPTIONH_DATA, 6);

    		    TraceIpx(OPTIONS_TRACE, "NodeNumberHandler: RCV REQ with remote node %.2x%.2x%.2x%.2x%.2x%.2x, accepted\n",
    			   contextp->Config.RemoteNode[0],
    			   contextp->Config.RemoteNode[1],
    			   contextp->Config.RemoteNode[2],
    			   contextp->Config.RemoteNode[3],
    			   contextp->Config.RemoteNode[4],
    			   contextp->Config.RemoteNode[5]);
    		}
    	}
	    break;

	case SNDNAK_OPTION:

	    // the remote node didn't specify this parameter as a desired
	    // parameter. We suggest it what to specify in a further REQ
	    SetNodeNak(resptr, contextp);

	    TraceIpx(OPTIONS_TRACE, "NodeNumberHandler: SND NAK to force the remote to request node %.2x%.2x%.2x%.2x%.2x%.2x\n",
			   contextp->Config.RemoteNode[0],
			   contextp->Config.RemoteNode[1],
			   contextp->Config.RemoteNode[2],
			   contextp->Config.RemoteNode[3],
			   contextp->Config.RemoteNode[4],
			   contextp->Config.RemoteNode[5]);

	    rc = FALSE;

	    break;

	default:

	    SS_ASSERT(FALSE);
	    break;
    }

    return rc;
}

BOOL
RoutingProtocolHandler(PUCHAR		optptr,
		       PIPXCP_CONTEXT	contextp,
		       PUCHAR		resptr,
		       OPT_ACTION	Action)
{
    USHORT	    RoutingProtocol;
    BOOL	    rc = TRUE;

    switch(Action) {

	case SNDREQ_OPTION:

	    SetOptionTypeAndLength(optptr, IPX_ROUTING_PROTOCOL, 4);
	    PUTUSHORT2SHORT(optptr + OPTIONH_DATA, (USHORT)RIP_SAP_ROUTING);

	    break;

	case RCVNAK_OPTION:

	    // if this option get NAK-ed, we ignore any other suggestions
	    // for it
	    break;

	case RCVACK_OPTION:

	    GETSHORT2USHORT(&RoutingProtocol, optptr + OPTIONH_DATA);
	    if(RoutingProtocol != RIP_SAP_ROUTING) {

		rc = FALSE;
	    }

	    break;

	case RCVREQ_OPTION:

	    GETSHORT2USHORT(&RoutingProtocol, optptr + OPTIONH_DATA);
	    if(RoutingProtocol != RIP_SAP_ROUTING) {

		SetOptionTypeAndLength(resptr, IPX_ROUTING_PROTOCOL, 4);
		PUTUSHORT2SHORT(resptr + OPTIONH_DATA, (USHORT)RIP_SAP_ROUTING);

		rc = FALSE;
	    }

	    break;

	case SNDNAK_OPTION:

	    SetOptionTypeAndLength(resptr, IPX_ROUTING_PROTOCOL, 4);
	    PUTUSHORT2SHORT(resptr + OPTIONH_DATA, (USHORT)RIP_SAP_ROUTING);

	    rc = FALSE;

	    break;

	 default:

	    SS_ASSERT(FALSE);
	    break;
    }

    return rc;
}

BOOL
CompressionProtocolHandler(PUCHAR		optptr,
			   PIPXCP_CONTEXT	contextp,
			   PUCHAR		resptr,
			   OPT_ACTION		Action)
{
    USHORT	    CompressionProtocol;
    BOOL	    rc = TRUE;

    switch(Action) {

	case SNDREQ_OPTION:

	    SetOptionTypeAndLength(optptr, IPX_COMPRESSION_PROTOCOL, 4);
	    PUTUSHORT2SHORT(optptr + OPTIONH_DATA, (USHORT)TELEBIT_COMPRESSED_IPX);

	    break;

	case RCVNAK_OPTION:

	    // if this option gets NAK-ed it means that the remote node doesn't
	    // support Telebit compression but supports another type of compression
	    // that we don't support. In this case we turn off compression negotiation.

	    break;

	case RCVACK_OPTION:

	    GETSHORT2USHORT(&CompressionProtocol, optptr + OPTIONH_DATA);
	    if(CompressionProtocol != TELEBIT_COMPRESSED_IPX) {

		rc = FALSE;
	    }
	    else
	    {
		// Our compression option got ACK-ed by the other end. This means that
		// we can receive compressed packets and have to set the receive
		// compression on our end.
		contextp->SetReceiveCompressionProtocol = TRUE;
	    }

	    break;

	case RCVREQ_OPTION:

	    // if we have already negotiated and this is a renegociation, stick by
	    // what we have already told the stack in line-up
	    if(contextp->RouteState == ROUTE_ACTIVATED) {

	    TraceIpx(OPTIONS_TRACE, "CompressionProtocolHandler: rcv req in re-negociation\n");
	    }

	    GETSHORT2USHORT(&CompressionProtocol, optptr + OPTIONH_DATA);
	    if(CompressionProtocol != TELEBIT_COMPRESSED_IPX) {

		if(resptr) {

		    SetOptionTypeAndLength(resptr, IPX_COMPRESSION_PROTOCOL, 4);
		    PUTUSHORT2SHORT(resptr + OPTIONH_DATA, (USHORT)TELEBIT_COMPRESSED_IPX);
		}

		rc = FALSE;
	    }
	    else
	    {
		// The remote requests the supported compression option and we ACK it.
		// This means it can receive compressed packets and we have to
		// set the send compression on our end.
		contextp->SetSendCompressionProtocol = TRUE;
	    }

	    break;

	 default:

	    SS_ASSERT(FALSE);
	    break;
    }

    return rc;
}


BOOL
ConfigurationCompleteHandler(PUCHAR		optptr,
			     PIPXCP_CONTEXT	contextp,
			     PUCHAR		resptr,
			     OPT_ACTION		Action)
{
    BOOL	    rc = TRUE;

    switch(Action) {

	case SNDREQ_OPTION:

	    SetOptionTypeAndLength(optptr, IPX_CONFIGURATION_COMPLETE, 2);

	    break;

	case RCVNAK_OPTION:

	    // if this option gets NAK-ed we ignore any other suggestions

	case RCVREQ_OPTION:
	case RCVACK_OPTION:

	    break;

	case SNDNAK_OPTION:

	    SetOptionTypeAndLength(resptr, IPX_CONFIGURATION_COMPLETE, 2);

	    rc = FALSE;

	    break;

	default:

	    SS_ASSERT(FALSE);
	    break;
    }

    return rc;
}

VOID
CopyOption(PUCHAR	dstptr,
	   PUCHAR	srcptr)
{
    USHORT	optlen;

    optlen = *(srcptr + OPTIONH_LENGTH);
    memcpy(dstptr, srcptr, optlen);
}

VOID
SetOptionTypeAndLength(PUCHAR		dstptr,
		       UCHAR		opttype,
		       UCHAR		optlen)
{
    *(dstptr + OPTIONH_TYPE) = opttype;
    *(dstptr + OPTIONH_LENGTH) = optlen;
}

VOID
SetNetworkNak(PUCHAR		resptr,
	      PIPXCP_CONTEXT	contextp)
{
    SetOptionTypeAndLength(resptr, IPX_NETWORK_NUMBER, 6);
    memcpy(resptr + OPTIONH_DATA, contextp->Config.Network, 4);

    contextp->NetNumberNakSentCount++;
}

VOID
SetNodeNak(PUCHAR		resptr,
	   PIPXCP_CONTEXT	contextp)
{
    SetOptionTypeAndLength(resptr, IPX_NODE_NUMBER, 8);
    memcpy(resptr + OPTIONH_DATA, contextp->Config.RemoteNode, 6);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\prot.h ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	    prot.h
//
// Description:     Prototypes
//
//
// Author:	    Stefan Solomon (stefans)	November 2, 1995.
//
// Revision History:
//
//***

#ifndef _IPXCP_PROT_
#define _IPXCP_PROT_

BOOL
NetworkNumberHandler(PUCHAR	       optptr,
		     PIPXCP_CONTEXT    contextp,
		     PUCHAR	       resptr,
		     OPT_ACTION	       Action);

BOOL
NodeNumberHandler(PUCHAR	       optptr,
		  PIPXCP_CONTEXT       contextp,
		  PUCHAR	       resptr,
		  OPT_ACTION	       Action);

BOOL
RoutingProtocolHandler(PUCHAR		optptr,
		       PIPXCP_CONTEXT	contextp,
		       PUCHAR		resptr,
		       OPT_ACTION	Action);

BOOL
ConfigurationCompleteHandler(PUCHAR		optptr,
			     PIPXCP_CONTEXT	contextp,
			     PUCHAR		resptr,
			     OPT_ACTION		Action);

VOID
CopyOption(PUCHAR	dstptr,
	   PUCHAR	srcptr);

DWORD
RmAllocateRoute(ULONG	    ConnectionId);

DWORD
RmDeallocateRoute(ULONG     ConnectionId);

DWORD
RmActivateRoute(ULONG			ConnectionId,
		PIPXCP_CONFIGURATION	configp);

VOID
GetIpxCpParameters(PIPXCP_GLOBAL_CONFIG_PARAMS pConfig);

VOID
NetToAscii(PUCHAR	  ascp,
	   PUCHAR	  net);

BOOL
CompressionProtocolHandler(PUCHAR		optptr,
			   PIPXCP_CONTEXT	contextp,
			   PUCHAR		resptr,
			   OPT_ACTION		 Action);

VOID
InitializeNodeHT(VOID);

VOID
DestroyNodeHT(VOID);

BOOL
NodeisUnique(PUCHAR	   nodep);

VOID
AddToNodeHT(PIPXCP_CONTEXT	    contextp);

VOID
RemoveFromNodeHT(PIPXCP_CONTEXT      contextp);

VOID
DisableRestoreBrowserOverIpx(PIPXCP_CONTEXT	contextp,
			     BOOL		Disable);

VOID
DisableRestoreBrowserOverNetbiosIpx(PIPXCP_CONTEXT    contextp,
				    BOOL	      Disable);
BOOL
IsWorkstationDialoutActive(VOID);

BOOL
IsDialinActive(VOID);

BOOL
IsRouterStarted(VOID);

DWORD
GetIpxwanInterfaceConfig(ULONG	    InterfaceIndex,
			 PULONG	    IpxwanConfigRequiredp);

BOOL
IsRoute(PUCHAR	    Network);

VOID
InitializeRouterManagerIf(VOID);

DWORD
AddLocalWkstaDialoutInterface(PULONG	    InterfaceIndexp);

DWORD
DeleteLocalWkstaDialoutInterface(ULONG	    InterfaceIndex);

ULONG
GetInterfaceType(PPPPCP_INIT	initp);

BOOL
NodeIsUnique(PUCHAR	   nodep);

DWORD
GetUniqueHigherNetNumber(PUCHAR 	newnet,
			 PUCHAR 	oldnet,
			 PIPXCP_CONTEXT contextp);

VOID
StartTracing(VOID);

VOID
TraceIpx(ULONG	ComponentID,
      char	*Format,
      ...);

VOID
StopTracing(VOID);

VOID
InitializeConnHT(VOID);

VOID
AddToConnHT(PIPXCP_CONTEXT	    contextp);

VOID
RemoveFromConnHT(PIPXCP_CONTEXT	    contextp);

PIPXCP_CONTEXT
GetContextBuffer(ULONG_PTR	ConnectionId);

VOID
LoadIpxWan(VOID);
VOID
UnloadIpxWan(VOID);

DWORD
GetWanNetNumber(IN OUT PUCHAR		Network,
		IN OUT PULONG		AllocatedNetworkIndexp,
		IN     ULONG		InterfaceType);

VOID
ReleaseWanNetNumber(ULONG	    AllocatedNetworkIndex);

VOID
GetInternalNetNumber(PUCHAR	Network);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <lmcons.h>
#include <rasman.h>
#include <raserror.h>
#include <rasppp.h>
#include <pppcp.h>
#include <mprlog.h>
#include <mprerror.h>
#include <ipxcpif.h>
#include "ipxcpdbg.h"
#include <utils.h>
#include <rtinfo.h>
#include <ipxrtdef.h>
#include <ipxrip.h>
#include <ipxsap.h>
#include <ipxif.h>
#include <ipxconst.h>
#include <routprot.h>
#include <rtutils.h>

#include <ntddndis.h>
#include <tdi.h>
#include <isnkrnl.h>

#include "configq.h"
#include "ipxcp.h"

#include "prot.h"

#include  "ipxcpcom.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\misc.c ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	    misc.c
//
// Description:     misc & aux routines
//
//
// Author:	    Stefan Solomon (stefans)	October 27, 1995
//
// Revision History:
//
//***

#include "precomp.h"
#pragma hdrstop



// Hash Table for the case where we have to accept the remote client node number and
// we have a global wan net. The table is used to detect if the same node number
// is not allocated twice

#define NODE_HASH_TABLE_SIZE		31

LIST_ENTRY				NodeHT[NODE_HASH_TABLE_SIZE];

// Coonection Id Hash Table

#define CONN_HASH_TABLE_SIZE		31

LIST_ENTRY				ConnHT[CONN_HASH_TABLE_SIZE];

#define  connhash(ConnectionId) 	(ConnectionId) % CONN_HASH_TABLE_SIZE;

//***
//
// Function:	IpxCpGetNegotiatedInfo
//
// Descr:	returns the client IPX address
//
//***

DWORD
IpxCpGetNegotiatedInfo(IN  VOID		        *pWorkBuffer,
                       OUT VOID *           pIpxCpResultBuf
)
{
    PIPXCP_CONTEXT contextp = (PIPXCP_CONTEXT)pWorkBuffer;
    PPP_IPXCP_RESULT * pIpxCpResult = (PPP_IPXCP_RESULT *)pIpxCpResultBuf;

    memcpy( pIpxCpResult->bLocalAddress, contextp->Config.Network, 4 );
    memcpy( pIpxCpResult->bLocalAddress+4, contextp->Config.LocalNode, 6 );

    memcpy( pIpxCpResult->bRemoteAddress, contextp->Config.Network, 4 );
    memcpy( pIpxCpResult->bRemoteAddress+4, contextp->Config.RemoteNode, 6 );

    return NO_ERROR;
}

/*++

Function:	GetInterfaceType

Dscr:

--*/

ULONG
GetInterfaceType(PPPPCP_INIT	initp)
{
    ULONG	 InterfaceType;

    InterfaceType = IF_TYPE_OTHER;

    if(initp->hInterface == INVALID_HANDLE_VALUE) {

	// The handle has invalid value. This happens in 2 cases:
	// 1. Dialed out as a standalone workstation
	// 2. Dialed out from a router but using the client UI. This will
	//    result later in an interface added to the router.

	if(!initp->fServer) {

	    // Workstation dialing out

	    if(IsRouterStarted()) {

		InterfaceType = IF_TYPE_ROUTER_WORKSTATION_DIALOUT;
	    }
	    else
	    {
		InterfaceType = IF_TYPE_STANDALONE_WORKSTATION_DIALOUT;
	    }
	}
	else
	{
	    // Somebody dialed in but it doesn't have an interface handle !!!
	    SS_ASSERT(FALSE);
	}
    }
    else
    {
	// The handle has a valid value

	if(!initp->fServer) {

	    // Dialout - this can be only a WAN router interface

	    if(IsRouterStarted()) {

		// double check with the PPP router type
		switch(initp->IfType) {

		    case ROUTER_IF_TYPE_FULL_ROUTER:

			InterfaceType = IF_TYPE_WAN_ROUTER;
			break;

		    case ROUTER_IF_TYPE_HOME_ROUTER:

			InterfaceType = IF_TYPE_PERSONAL_WAN_ROUTER;
			break;

		    default:

			// Doesn't match the PPP Interface Type
			SS_ASSERT(FALSE);
			break;
		}
	    }
	    else
	    {
		// Router not started but we got a valid handle !!!
		SS_ASSERT(FALSE);
	    }
	}
	else
	{
	    // Dialin - this can be:
	    // 1. Remote router dialing in
	    // 2. Remote client dialing in

	    if(IsRouterStarted()) {

		switch(initp->IfType) {

		    case ROUTER_IF_TYPE_FULL_ROUTER:

			InterfaceType = IF_TYPE_WAN_ROUTER;
			break;

		    case ROUTER_IF_TYPE_HOME_ROUTER:

			InterfaceType = IF_TYPE_PERSONAL_WAN_ROUTER;
			break;

		    case ROUTER_IF_TYPE_CLIENT:

			InterfaceType = IF_TYPE_WAN_WORKSTATION;
			break;

		    default:

			// Doesn't match the PPP Interface Type
			SS_ASSERT(FALSE);
			break;
		}
	    }
	    else
	    {
		// Router not started but we got a valid handle !!!
		SS_ASSERT(FALSE);
	    }
	}
    }

    return InterfaceType;
}

VOID
NetToAscii(PUCHAR	  ascp,
	   PUCHAR	  net)
{
    PUCHAR	hexdigit = "0123456789ABCDEF";
    int 	i;

    for(i=0; i<4; i++) {

	*ascp++ = hexdigit[net[i] / 16];
	*ascp++ = hexdigit[net[i] % 16];
    }
}


//*** Routines for handling the hash table of node numbers ***

//***
//
// Function:	InitializeNodeHT
//
// Descr:
//
//***

VOID
InitializeNodeHT(VOID)
{
    int 	    i;
    PLIST_ENTRY     NodeHTBucketp;

    NodeHTBucketp = NodeHT;

    for(i=0; i<NODE_HASH_TABLE_SIZE; i++, NodeHTBucketp++) {

	InitializeListHead(NodeHTBucketp);
    }
}


//***
//
// Function:	ndhash
//
// Descr:	compute the hash index for this node
//
//***

int
ndhash(PUCHAR	    nodep)
{
    USHORT	ndindex = 6;
    int 	hv = 0;	// hash value

    while(ndindex--) {

	hv +=  nodep[ndindex] & 0xff;
    }

    return hv % NODE_HASH_TABLE_SIZE;
}

//***
//
// Function:	NodeIsUnique
//
// Descr:	returns TRUE if the node is not in the Node Table
//
//***

BOOL
NodeIsUnique(PUCHAR	   nodep)
{
    int 	    hv;
    PLIST_ENTRY     nextp;
    PIPXCP_CONTEXT  contextp;

    hv = ndhash(nodep);

    // walk the niccbs list until we get to the node
    nextp = NodeHT[hv].Flink;

    while(nextp != &NodeHT[hv]) {

	contextp = CONTAINING_RECORD(nextp, IPXCP_CONTEXT, NodeHtLinkage);

	if(!memcmp(contextp->Config.RemoteNode, nodep, 6)) {

	    return FALSE;
	}

	nextp = contextp->NodeHtLinkage.Flink;
    }

    return TRUE;
}


//***
//
// Function:	AddToNodeHT
//
// Descr:	Inserts a new context buffer in the Node Hash Table
//
//***

VOID
AddToNodeHT(PIPXCP_CONTEXT	    contextp)
{
    int 	    hv;

    hv = ndhash(contextp->Config.RemoteNode);

    InsertTailList(&NodeHT[hv], &contextp->NodeHtLinkage);
}

//***
//
// Function:	RemoveFromNodeHT
//
// Descr:	Removes a context buffer from the Node Hash Table
//
//***

VOID
RemoveFromNodeHT(PIPXCP_CONTEXT      contextp)
{
    RemoveEntryList(&contextp->NodeHtLinkage);
}

/*++

Function:	GetUniqueHigherNetNumber

Descr:		Try to generate a network number which is higher then oldnet
		and is unique for this router's routing table

--*/

DWORD
GetUniqueHigherNetNumber(PUCHAR 	newnet,
			 PUCHAR 	oldnet,
			 PIPXCP_CONTEXT contextp)
{
    ULONG    ulnewnet, uloldnet, i;

    GETLONG2ULONG(&ulnewnet, oldnet);

    // if this connection is a remote client and global wan is set, we can't
    // change the network number
    if((contextp->InterfaceType == IF_TYPE_WAN_WORKSTATION) &&
       (GlobalConfig.RParams.EnableGlobalWanNet)) {

	// we cannot change the client's net number
	return ERROR_CAN_NOT_COMPLETE;
    }

    // if the router is not started, anything will do
    if(contextp->InterfaceType == IF_TYPE_STANDALONE_WORKSTATION_DIALOUT) {

	ulnewnet++;

	PUTULONG2LONG(newnet, ulnewnet);

	return NO_ERROR;
    }

    for(i=0, ulnewnet++; i<100000; i++, ulnewnet++) {

	if(ulnewnet > 0xFFFFFFFE) {

	    return ERROR_CAN_NOT_COMPLETE;
	}

	PUTULONG2LONG(newnet, ulnewnet);

	if(!IsRoute(newnet)) {

	    return NO_ERROR;
	}
    }

    return ERROR_CAN_NOT_COMPLETE;
}

BOOL
IsWorkstationDialoutActive(VOID)
{
    BOOL	rc = FALSE;;

    ACQUIRE_DATABASE_LOCK;

    if(WorkstationDialoutActive) {

	rc = TRUE;
    }

    RELEASE_DATABASE_LOCK;

    return rc;
}

BOOL
IsRouterStarted(VOID)
{
    BOOL	rc = FALSE;;

    ACQUIRE_DATABASE_LOCK;

    if(RouterStarted) {

	rc = TRUE;
    }

    RELEASE_DATABASE_LOCK;

    return rc;
}


//*** Routines for handling the hash table of connection ids ***

//***
//
// Function:	InitializeConnHT
//
// Descr:
//
//***

VOID
InitializeConnHT(VOID)
{
    int 	    i;
    PLIST_ENTRY     ConnHTBucketp;

    ConnHTBucketp = ConnHT;

    for(i=0; i<CONN_HASH_TABLE_SIZE; i++, ConnHTBucketp++) {

	InitializeListHead(ConnHTBucketp);
    }
}

//***
//
// Function:	AddToConnHT
//
// Descr:	Inserts a new context buffer in the Connection Hash Table
//
// Remark:	>> Called with database lock held <<
//
//***

VOID
AddToConnHT(PIPXCP_CONTEXT	    contextp)
{
    ULONG hv;

    hv = connhash(contextp->Config.ConnectionId);

    InsertTailList(&ConnHT[hv], &contextp->ConnHtLinkage);
}

//***
//
// Function:	RemoveFromConnHT
//
// Descr:	Removes a context buffer from the Node Hash Table
//
// Remark:	>> Called with database lock held <<
//
//***

VOID
RemoveFromConnHT(PIPXCP_CONTEXT	    contextp)
{
    RemoveEntryList(&contextp->ConnHtLinkage);
}

/*++

Function:	GetContextBuffer

Descr:		gets a ptr to the context buffer based on the connection id

Remark: 	>> Called with database lock held <<

--*/

PIPXCP_CONTEXT
GetContextBuffer(ULONG_PTR	ConnectionId)
{
    ULONG hv;
    PLIST_ENTRY     nextp;
    PIPXCP_CONTEXT  contextp;

    hv = (ULONG)connhash(ConnectionId);

    nextp = ConnHT[hv].Flink;

    while(nextp != &ConnHT[hv]) {

	contextp = CONTAINING_RECORD(nextp, IPXCP_CONTEXT, ConnHtLinkage);

	if(contextp->Config.ConnectionId == ConnectionId) {

	    return contextp;
	}

	nextp = contextp->ConnHtLinkage.Flink;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\rasmanif.c ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	    rasmanif.c
//
// Description:     implements the IPXCP i/f with rasman
//
//
// Author:	    Stefan Solomon (stefans)	December 2, 1993.
//
// Revision History:
//
//***

#include "precomp.h"
#pragma hdrstop


DWORD
RmAllocateRoute(ULONG	  ConnectionId)
{
    RASMAN_ROUTEINFO	routeinfo;
    DWORD		rc;

    if(rc = RasAllocateRoute((HPORT)ULongToPtr(ConnectionId),
		     IPX,
		     FALSE,
		     &routeinfo)) {

	TraceIpx(RASMANIF_TRACE, "RasAllocateRoute failed err = 0x%x\n", rc);
    }

    return rc;
}

DWORD
RmDeallocateRoute(ULONG     ConnectionId)
{
    DWORD		rc;

    if(rc = RasDeAllocateRoute((HPORT) ULongToPtr(ConnectionId), IPX)) {

	TraceIpx(RASMANIF_TRACE, "RasDeAllocateRoute failed err = 0x%x\n", rc);
    }

    return rc;
}

typedef struct _IPX_CONFIG_INFO {

    DWORD   IpxConfigLength;
    BYTE    IpxConfigInfo[sizeof(IPXCP_CONFIGURATION)];
    } IPX_CONFIG_INFO, *PIPX_CONFIG_INFO;

DWORD
RmActivateRoute(ULONG			ConnectionId,
		PIPXCP_CONFIGURATION	configp)
{
    IPX_CONFIG_INFO	configinfo;
    RASMAN_ROUTEINFO	routeinfo;
    DWORD		rc;

    configinfo.IpxConfigLength = sizeof(IPXCP_CONFIGURATION);
    memcpy(configinfo.IpxConfigInfo, configp, sizeof(IPXCP_CONFIGURATION));

    if(rc = RasActivateRoute((HPORT)ULongToPtr(ConnectionId),
		     IPX,
		     &routeinfo,
		     (PROTOCOL_CONFIG_INFO *)&configinfo)) {


	TraceIpx(RASMANIF_TRACE, "RasActivateRoute failed err = 0x%x\n", rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\registry.c ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	registry.c
//
// Description: routines for reading the registry configuration
//
// Author:	Stefan Solomon (stefans)    October 30, 1995.
//
// Revision History:
//
// Nov 5th 1996 Ram Cherala (ramc)  Changed default value of 
//                                  EnableUnnumberedWanLinks to 0
//                                  because there is no UI to disable it.
//
//***

#include "precomp.h"
#pragma  hdrstop

BOOL bAssignSpecificNode = FALSE;
DWORD LastNodeAssigned;                         // Don't initialize so it will be random

//
//*** IPXCP Registry Parameters ***
IPXCP_GLOBAL_CONFIG_PARAMS GlobalConfig = 
{
    {0,0,0, {0,0,0,0}},                         // RParams
    1,                                          // SingleClientDialout
    0,			                                // FirstWanNet
    0,			                                // WanNetPoolSize
    {0,0,0},                                    // WanNetPoolStr;
    1,			                                // EnableUnnumberedWanLinks;
    1,			                                // EnableAutoWanNetAllocation;
    0,			                                // EnableCompressionProtocol;
    0,			                                // EnableIpxwanForWorkstationDialout;
    0,                                          // AcceptRemoteNodeNumber;
    0,			                                // DebugLog;
    {0,0,0,0,0,0}                               // The specific wan node
};

// Returns a 1 byte value representing 2 hex digits
UCHAR GetHexValue (PWCHAR pszDigits) {
    DWORD dw1, dw2;

    if ((pszDigits[0] >= L'0') && (pszDigits[0] <= L'9'))
        dw1 = (pszDigits[0] - L'0');
    else if ((pszDigits[0] >= L'A') && (pszDigits[0] <= L'D'))
        dw1 = (pszDigits[0] - L'A') + 10;
    else
        dw1 = 0;

    if ((pszDigits[1] >= L'0') && (pszDigits[1] <= L'9'))
        dw2 = (pszDigits[1] - L'0');
    else if ((pszDigits[1] >= L'A') && (pszDigits[1] <= L'D'))
        dw2 = (pszDigits[1] - L'A') + 10;
    else
        dw2 = 0;

    return (UCHAR) (16 * dw1 + dw2);
}

// Assigns the first wan node as stored in pUniStrSrc and returns TRUE if this
// node is non zero.
BOOL CopyWanNode (PUCHAR puDst, UNICODE_STRING * pUniStrSrc) {
    PWCHAR pBuf = pUniStrSrc->Buffer;
    DWORD i;

    if ((!pBuf) || (pUniStrSrc->Length == 0)) {
        memset (puDst, 0, 6);
        return FALSE;
    }

    // Convert the unicode string to uppercase
    _wcsupr(pBuf);

    puDst[0] = GetHexValue(&pBuf[0]);
    puDst[1] = GetHexValue(&pBuf[2]);
    puDst[2] = GetHexValue(&pBuf[4]);
    puDst[3] = GetHexValue(&pBuf[6]);
    puDst[4] = GetHexValue(&pBuf[8]);
    puDst[5] = GetHexValue(&pBuf[10]);

    return TRUE;
}


//***
//
// Function:	GetIpxCpParameters
//
// Descr:	Reads the parameters from the registry and sets them
//
//***

VOID
GetIpxCpParameters(PIPXCP_GLOBAL_CONFIG_PARAMS pConfig)
{

    NTSTATUS Status;
    PWSTR IpxRouterParametersPath = L"RemoteAccess\\Parameters\\Ipx";
    RTL_QUERY_REGISTRY_TABLE	paramTable[14]; // table size = nr of params + 1
    DWORD InvalidNetworkAccessValue = 987654, 
          AllowNetworkAccess = InvalidNetworkAccessValue;
    WCHAR pszFirstWanNode[12] = {0,0,0,0,0,0,0,0,0,0,0,0};
    UNICODE_STRING UniStrFirstWanNode = {0, 0, NULL};

    RtlZeroMemory(&paramTable[0], sizeof(paramTable));
    RtlInitUnicodeString (&(pConfig->WanNetPoolStr), NULL);
    
    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"FirstWanNet";
    paramTable[0].EntryContext = &(pConfig->FirstWanNet);
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &(pConfig->FirstWanNet);
    paramTable[0].DefaultLength = sizeof(ULONG);
        
    paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name = L"WanNetPoolSize";
    paramTable[1].EntryContext = &(pConfig->WanNetPoolSize);
    paramTable[1].DefaultType = REG_DWORD;
    paramTable[1].DefaultData = &(pConfig->WanNetPoolSize);
    paramTable[1].DefaultLength = sizeof(ULONG);

    paramTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[2].Name = L"EnableUnnumberedWanLinks";
    paramTable[2].EntryContext = &(pConfig->EnableUnnumberedWanLinks);
    paramTable[2].DefaultType = REG_DWORD;
    paramTable[2].DefaultData = &(pConfig->EnableUnnumberedWanLinks);
    paramTable[2].DefaultLength = sizeof(ULONG);

    paramTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[3].Name = L"GlobalWanNet";
    paramTable[3].EntryContext = &(pConfig->RParams.EnableGlobalWanNet);
    paramTable[3].DefaultType = REG_DWORD;
    paramTable[3].DefaultData = &(pConfig->RParams.EnableGlobalWanNet);
    paramTable[3].DefaultLength = sizeof(ULONG);

    paramTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[4].Name = L"AutoWanNetAllocation";
    paramTable[4].EntryContext = &(pConfig->EnableAutoWanNetAllocation);
    paramTable[4].DefaultType = REG_DWORD;
    paramTable[4].DefaultData = &(pConfig->EnableAutoWanNetAllocation);
    paramTable[4].DefaultLength = sizeof(ULONG);

    paramTable[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[5].Name = L"DebugLog";
    paramTable[5].EntryContext = &(pConfig->DebugLog);
    paramTable[5].DefaultType = REG_DWORD;
    paramTable[5].DefaultData = &(pConfig->DebugLog);
    paramTable[5].DefaultLength = sizeof(ULONG);

    paramTable[6].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[6].Name = L"EnableCompressionProtocol";
    paramTable[6].EntryContext = &(pConfig->EnableCompressionProtocol);
    paramTable[6].DefaultType = REG_DWORD;
    paramTable[6].DefaultData = &(pConfig->EnableCompressionProtocol);
    paramTable[6].DefaultLength = sizeof(ULONG);

    paramTable[7].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[7].Name = L"SingleClientDialout";
    paramTable[7].EntryContext = &(pConfig->SingleClientDialout);
    paramTable[7].DefaultType = REG_DWORD;
    paramTable[7].DefaultData = &(pConfig->SingleClientDialout);
    paramTable[7].DefaultLength = sizeof(ULONG);

    paramTable[8].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[8].Name = L"AllowNetworkAccess";
    paramTable[8].EntryContext = &AllowNetworkAccess;
    paramTable[8].DefaultType = REG_DWORD;
    paramTable[8].DefaultData = &AllowNetworkAccess;
    paramTable[8].DefaultLength = sizeof(ULONG);

    paramTable[9].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[9].Name = L"EnableIpxwanForWorkstationDialout";
    paramTable[9].EntryContext = &(pConfig->EnableIpxwanForWorkstationDialout);
    paramTable[9].DefaultType = REG_DWORD;
    paramTable[9].DefaultData = &(pConfig->EnableIpxwanForWorkstationDialout);
    paramTable[9].DefaultLength = sizeof(ULONG);

    paramTable[10].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[10].Name = L"AcceptRemoteNodeNumber";
    paramTable[10].EntryContext = &(pConfig->AcceptRemoteNodeNumber);
    paramTable[10].DefaultType = REG_DWORD;
    paramTable[10].DefaultData = &(pConfig->AcceptRemoteNodeNumber);
    paramTable[10].DefaultLength = sizeof(ULONG);

    paramTable[11].Flags = RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_NOEXPAND;
    paramTable[11].Name = L"WanNetPool";
    paramTable[11].EntryContext = &(pConfig->WanNetPoolStr);
    paramTable[11].DefaultType = REG_MULTI_SZ;
    paramTable[11].DefaultData = &(pConfig->WanNetPoolStr);
    paramTable[11].DefaultLength = 0;

    paramTable[12].Flags = RTL_QUERY_REGISTRY_DIRECT|RTL_QUERY_REGISTRY_NOEXPAND;
    paramTable[12].Name = L"FirstWanNode";
    paramTable[12].EntryContext = &UniStrFirstWanNode;
    paramTable[12].DefaultType = REG_SZ;
    paramTable[12].DefaultData = &UniStrFirstWanNode;
    paramTable[12].DefaultLength = 0;
    
    Status = RtlQueryRegistryValues(
		 RTL_REGISTRY_SERVICES,
		 IpxRouterParametersPath,
		 paramTable,
		 NULL,
		 NULL);

    // The registry parameter "ThisMachineOnly" was replaced 
    // with the parameter "AllowNetworkAddress" whose semantics
    // are the inverse.  If a new value was assigned to 
    // AllowNetworkAccess, assign its inverse to pConfig->RParams.ThisMachineOnly
    // here.
    if (AllowNetworkAccess != InvalidNetworkAccessValue)
        pConfig->RParams.ThisMachineOnly = !AllowNetworkAccess;

    // Find out if a specific node number has been provided
    // in the registry. 
    bAssignSpecificNode = CopyWanNode (pConfig->puSpecificNode, &UniStrFirstWanNode);
    if (bAssignSpecificNode) {
        GETLONG2ULONG(&LastNodeAssigned,&(pConfig->puSpecificNode[2]));
		//TraceIpx(OPTIONS_TRACE, "GetIpxCpParameters: FirstWanNode: %.2x%.2x%.2x%.2x%.2x%.2x   LastNodeAssigned= %x",
			   //pConfig->puSpecificNode[0],
			   //pConfig->puSpecificNode[1],
			   //pConfig->puSpecificNode[2],
			   //pConfig->puSpecificNode[3],
			   //pConfig->puSpecificNode[4],
			   //pConfig->puSpecificNode[5],
			   //LastNodeAssigned);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\rmif.c ===
/*******************************************************************/
/*	      Copyright(c)  1995 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	    rmif.c
//
// Description:     implements the IPXCP i/f with the IPX Router Manager
//
//
// Author:	    Stefan Solomon (stefans)	October 27, 1995.
//
// Revision History:
//
//***

#include    "precomp.h"
#pragma     hdrstop

extern BOOL WanConfigDbaseInitialized;

// IPX Router Manager Entry Points

DWORD (WINAPI *RmCreateGlobalRoute)(PUCHAR	     Network);

DWORD (WINAPI *RmAddLocalWkstaDialoutInterface)
	    (IN	    LPWSTR		    InterfaceNamep,
	     IN	    LPVOID		    InterfaceInfop,
	     IN OUT  PULONG		    InterfaceIndexp);

DWORD (WINAPI *RmDeleteLocalWkstaDialoutInterface)(ULONG	InterfaceIndex);

DWORD (WINAPI *RmGetIpxwanInterfaceConfig)
	    (ULONG	InterfaceIndex,
	    PULONG	IpxwanConfigRequired);

BOOL	(WINAPI *RmIsRoute)(PUCHAR	Network);

DWORD	(WINAPI *RmGetInternalNetNumber)(PUCHAR     Network);

DWORD   (WINAPI *RmUpdateIpxcpConfig)(PIPXCP_ROUTER_CONFIG_PARAMS pParams) = NULL;

// Our Entry Points

VOID
IpxcpRouterStarted(VOID);

VOID
IpxcpRouterStopped(VOID);

// Flag to indicate router state

BOOL			 RouterStarted;

// [pmay] This will be removed when the router is modified to use MprInfo api's
typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;
typedef RTR_TOC_ENTRY IPX_TOC_ENTRY, *PIPX_TOC_ENTRY;


//***  Interface Configuration Info for the WORKSTATION_ON_ROUTER_DIALOUT ***

typedef struct _WKSTA_ON_ROUTER_INFO {

    IPX_INFO_BLOCK_HEADER	header;
    IPX_TOC_ENTRY		toc[3];
    IPX_IF_INFO 		ipxifinfo;
    RIP_IF_CONFIG		ripifinfo;
    SAP_IF_CONFIG		sapifinfo;
    IPXWAN_IF_INFO		ipxwanifinfo;

    }	WKSTA_ON_ROUTER_INFO, *PWKSTA_ON_ROUTER_INFO;

WKSTA_ON_ROUTER_INFO	WkstaOnRouterInfo;

#define ipxtoc			  WkstaOnRouterInfo.header.TocEntry[0]
#define riptoc			  WkstaOnRouterInfo.toc[0]
#define saptoc			  WkstaOnRouterInfo.toc[1]
#define ipxwantoc		  WkstaOnRouterInfo.toc[2]
#define ipxinfo			  WkstaOnRouterInfo.ipxifinfo
#define ripinfo 		  WkstaOnRouterInfo.ripifinfo.RipIfInfo
#define sapinfo 		  WkstaOnRouterInfo.sapifinfo.SapIfInfo
#define ipxwaninfo		  WkstaOnRouterInfo.ipxwanifinfo




/*++

Function:	InitializeRouterManagerIf

Descr:

Remark: 	Called from process attach

--*/


VOID
InitializeRouterManagerIf(VOID)
{
    // init wksta on router info
    WkstaOnRouterInfo.header.Version = IPX_ROUTER_VERSION_1;
    WkstaOnRouterInfo.header.Size = sizeof(WkstaOnRouterInfo);
    WkstaOnRouterInfo.header.TocEntriesCount = 4;

    ipxtoc.InfoType = IPX_INTERFACE_INFO_TYPE;
    ipxtoc.InfoSize = sizeof(IPX_IF_INFO);
    ipxtoc.Count = 1;
    ipxtoc.Offset = (ULONG)((PUCHAR)&WkstaOnRouterInfo.ipxifinfo - (PUCHAR)&WkstaOnRouterInfo);

    riptoc.InfoType = IPX_PROTOCOL_RIP;
    riptoc.InfoSize = sizeof(RIP_IF_CONFIG);
    riptoc.Count = 1;
    riptoc.Offset = ipxtoc.Offset + sizeof(IPX_IF_INFO);

    saptoc.InfoType = IPX_PROTOCOL_SAP;
    saptoc.InfoSize = sizeof(SAP_IF_CONFIG);
    saptoc.Count = 1;
    saptoc.Offset = riptoc.Offset + sizeof(RIP_IF_CONFIG);

    ipxwantoc.InfoType = IPXWAN_INTERFACE_INFO_TYPE;
    ipxwantoc.InfoSize = sizeof(IPXWAN_IF_INFO);
    ipxwantoc.Count = 1;
    ipxwantoc.Offset = saptoc.Offset + sizeof(SAP_IF_CONFIG);

    ipxinfo.AdminState = ADMIN_STATE_ENABLED;
    ipxinfo.NetbiosAccept = ADMIN_STATE_ENABLED;
    ipxinfo.NetbiosDeliver = ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP;

    ripinfo.AdminState = ADMIN_STATE_ENABLED;
    ripinfo.UpdateMode = IPX_STANDARD_UPDATE;
    ripinfo.PacketType = IPX_STANDARD_PACKET_TYPE;
    ripinfo.Supply = ADMIN_STATE_ENABLED;
    ripinfo.Listen = ADMIN_STATE_ENABLED;
    ripinfo.PeriodicUpdateInterval = 60;
    ripinfo.AgeIntervalMultiplier = 3;

    sapinfo.AdminState = ADMIN_STATE_DISABLED;
    sapinfo.UpdateMode = IPX_NO_UPDATE;
    sapinfo.PacketType = IPX_STANDARD_PACKET_TYPE;
    sapinfo.Supply = ADMIN_STATE_DISABLED;
    sapinfo.Listen = ADMIN_STATE_DISABLED;
    sapinfo.PeriodicUpdateInterval = 60;
    sapinfo.AgeIntervalMultiplier = 3;

    if(GlobalConfig.EnableIpxwanForWorkstationDialout) {

	ipxwaninfo.AdminState = ADMIN_STATE_ENABLED;
    }
    else
    {
	ipxwaninfo.AdminState = ADMIN_STATE_DISABLED;
    }
}

DWORD
IPXCP_BIND_ENTRY_POINT(PIPXCP_INTERFACE     IpxcpInterfacep)
{
    TraceIpx(RMIF_TRACE, "IpxcpBind: Entered\n");

    // Get the IPX Router Manager Entry Points

    RmCreateGlobalRoute = IpxcpInterfacep->RmCreateGlobalRoute;
    RmAddLocalWkstaDialoutInterface = IpxcpInterfacep->RmAddLocalWkstaDialoutInterface;
    RmDeleteLocalWkstaDialoutInterface = IpxcpInterfacep->RmDeleteLocalWkstaDialoutInterface;
    RmGetIpxwanInterfaceConfig = IpxcpInterfacep->RmGetIpxwanInterfaceConfig;
    RmIsRoute = IpxcpInterfacep->RmIsRoute;
    RmGetInternalNetNumber = IpxcpInterfacep->RmGetInternalNetNumber;
    RmUpdateIpxcpConfig = IpxcpInterfacep->RmUpdateIpxcpConfig;

    // Give it ours

    IpxcpInterfacep->IpxcpRouterStarted = IpxcpRouterStarted;
    IpxcpInterfacep->IpxcpRouterStopped = IpxcpRouterStopped;

    ACQUIRE_DATABASE_LOCK;

    IpxcpInterfacep->Params.ThisMachineOnly = GlobalConfig.RParams.ThisMachineOnly;

    if(WanConfigDbaseInitialized) {

	IpxcpInterfacep->Params.WanNetDatabaseInitialized = TRUE;

	IpxcpInterfacep->Params.EnableGlobalWanNet = GlobalConfig.RParams.EnableGlobalWanNet;

	if(GlobalConfig.RParams.EnableGlobalWanNet) {

	    memcpy(IpxcpInterfacep->Params.GlobalWanNet, GlobalConfig.RParams.GlobalWanNet, 4);
	}
    }
    else
    {
	IpxcpInterfacep->Params.WanNetDatabaseInitialized = FALSE;
	IpxcpInterfacep->Params.EnableGlobalWanNet = FALSE;
    }

    RELEASE_DATABASE_LOCK;

    return NO_ERROR;
}

VOID
IpxcpRouterStarted(VOID)
{
    TraceIpx(RMIF_TRACE, "IpxcpRouterStarted: Entered\n");

    ACQUIRE_DATABASE_LOCK;

    RouterStarted = TRUE;

    RELEASE_DATABASE_LOCK;
}


VOID
IpxcpRouterStopped(VOID)
{
    TraceIpx(RMIF_TRACE, "IpxcpRouterStopped: Entered\n");

    ACQUIRE_DATABASE_LOCK;

    RouterStarted = FALSE;

    RELEASE_DATABASE_LOCK;
}


DWORD
AddLocalWkstaDialoutInterface(PULONG	    InterfaceIndexp)
{
    DWORD	rc;

    ACQUIRE_DATABASE_LOCK;

    if(!RouterStarted) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    rc = (*RmAddLocalWkstaDialoutInterface)(L"LocalWorkstationDialout",
					 &WkstaOnRouterInfo,
					 InterfaceIndexp);

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD
DeleteLocalWkstaDialoutInterface(ULONG	    InterfaceIndex)
{
    DWORD	rc;

    ACQUIRE_DATABASE_LOCK;

    if(!RouterStarted) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    rc = (*RmDeleteLocalWkstaDialoutInterface)(InterfaceIndex);

    RELEASE_DATABASE_LOCK;

    return rc;
}

DWORD
GetIpxwanInterfaceConfig(ULONG	    InterfaceIndex,
			 PULONG	    IpxwanConfigRequiredp)
{
    DWORD	rc;

    ACQUIRE_DATABASE_LOCK;

    if(!RouterStarted) {

	RELEASE_DATABASE_LOCK;
	return ERROR_CAN_NOT_COMPLETE;
    }

    rc = (*RmGetIpxwanInterfaceConfig)(InterfaceIndex, IpxwanConfigRequiredp);

    RELEASE_DATABASE_LOCK;

    return rc;
}

BOOL
IsRoute(PUCHAR	    Network)
{
    BOOL	rc;

    ACQUIRE_DATABASE_LOCK;

    if(!RouterStarted) {

	RELEASE_DATABASE_LOCK;
	return FALSE;
    }

    rc = (*RmIsRoute)(Network);

    RELEASE_DATABASE_LOCK;

    return rc;
}

/*++

Function:	GetInternalNetNumber

Descr:

--*/

VOID
GetInternalNetNumber(PUCHAR	Network)
{
    DWORD		    rc;

    ACQUIRE_DATABASE_LOCK;

    if(!RouterStarted) {

	memcpy(Network, nullnet, 4);
	RELEASE_DATABASE_LOCK;
	return;
    }

    rc = RmGetInternalNetNumber(Network);

    if(rc != NO_ERROR) {

	memcpy(Network, nullnet, 4);
    }

    RELEASE_DATABASE_LOCK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\rasipxcp\wannet.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wannet.c

Abstract:

    Wan net allocation module

Author:

    Stefan Solomon  11/03/1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


extern DWORD	(WINAPI * RmCreateGlobalRoute)(PUCHAR Network);
extern HANDLE g_hRouterLog;

ULONG	LastUsedRandSeed;

//
// Variable keeping the initialization state of the IPXCP Configuration Database
//

BOOL	       WanConfigDbaseInitialized = FALSE;

// WAN net pool entry structure
typedef struct _NET_ENTRY {

    BOOL	    InUse;
    UCHAR	    Network[4];

} NET_ENTRY, *PNET_ENTRY;

// Structure represents a pool of 
// wan net numbers.  This pool dynamically 
// grows and shrinks as clients dial
// in and hang up
typedef struct _WAN_NET_POOL {
    DWORD dwMaxSize;
    DWORD dwCurSize;
    DWORD dwInUseCount;
    NET_ENTRY * pEntries;
} WAN_NET_POOL, *PWAN_NET_POOL;

#define WANNET_DEFAULT_SIZE 10
#define WANNET_DEFAULT_GROW 100
#define WANNET_MAXSIZE 64000

//
// WAN net numbers pool 
//
WAN_NET_POOL WanNetPool = {WANNET_MAXSIZE, 0, 0, NULL};

//
// Global WAN net
//

//UCHAR		GlobalConfig.RParams.GlobalWanNet[4] = {0,0,0,0};

ULONG		GlobalWanNetIndex; // when global wan net comes from pool - the index

DWORD
InitWanNetConfigDbase(VOID);

DWORD
WanNetAlloc(PUCHAR	Network,
	    PULONG	AllocatedNetworkIndexp);

DWORD
CreateWanNetPool(VOID);

DWORD 
GrowWanNetPool (WAN_NET_POOL * pPool);

DWORD
CreateGlobalWanNet(VOID);

VOID
DestroyWanNetPool(VOID);

VOID
DestroyGlobalWanNet(VOID);

DWORD
AllocWanNetFromPool(PUCHAR	Network,
		    PULONG	AllocatedNetworkIndexp);

VOID
FreeWanNetToPool(ULONG	  AllocatedNetworkIndex);

DWORD
GetRandomNetNumber(PUCHAR	Network);

/*++

Function:   GetWanNetNumber

Descr:	    This function is called by IPXCP or IPXWAN to get a network
	    number from the pool.

Parameters:

	    Network
	    AllocatedNetworkIndex - if the value returned by this param is
	    not INVALID_NETWORK_INDEX then the caller must call ReleaseWanNetNumber
	    to free the net to the pool.
	    InterfaceType

Returns     NO_ERROR - a network has been successfully allocated

--*/


DWORD
GetWanNetNumber(IN OUT PUCHAR		Network,
		IN OUT PULONG		AllocatedNetworkIndexp,
		IN     ULONG		InterfaceType)
{
    DWORD	rc;

    memcpy(Network, nullnet, 4);
    *AllocatedNetworkIndexp = INVALID_NETWORK_INDEX;

    // if this a router <-> router connection and we are configured for
    // Unnumbered RIP -> return 0.
    if((InterfaceType == IF_TYPE_WAN_ROUTER) ||
       (InterfaceType == IF_TYPE_PERSONAL_WAN_ROUTER)) {

	if(GlobalConfig.EnableUnnumberedWanLinks) {

	    return NO_ERROR;
	}
    }

    ACQUIRE_DATABASE_LOCK;

    if(!WanConfigDbaseInitialized) {

	if((rc = InitWanNetConfigDbase()) != NO_ERROR) {

	    RELEASE_DATABASE_LOCK;
	    return rc;
	}
    }

    // check the interface type
    if((InterfaceType == IF_TYPE_WAN_WORKSTATION) &&
       GlobalConfig.RParams.EnableGlobalWanNet) {

	memcpy(Network, GlobalConfig.RParams.GlobalWanNet, 4);
	*AllocatedNetworkIndexp = INVALID_NETWORK_INDEX;

	rc = NO_ERROR;
    }
    else
    {
	rc = WanNetAlloc(Network,
			 AllocatedNetworkIndexp);
    }

    RELEASE_DATABASE_LOCK;

    return rc;
}


/*++

Function:   ReleaseWanNetNumber

Descr:	    This function will be called by ipxcp to release the net number
	    used for configuring the WAN link. The call is issued when the
	    WAN link gets disconnected.

--*/

VOID
ReleaseWanNetNumber(ULONG	    AllocatedNetworkIndex)
{
    ACQUIRE_DATABASE_LOCK;

    SS_ASSERT(WanConfigDbaseInitialized);
    SS_ASSERT(AllocatedNetworkIndex != INVALID_NETWORK_INDEX);

    FreeWanNetToPool(AllocatedNetworkIndex);

    RELEASE_DATABASE_LOCK;

    return;
}

/*++

Function:	InitWanNetConfigDatabase

Descr:		Configures the database of network numbers used for incoming
		WAN links.

Remark: 	This function is called from the GetWanNetNumber (see below) when
		IPXCP has an incoming call and the router has been started and the
		database hasn't been configured yet.

Remark2:	>> called with database lock held <<

--*/


DWORD
InitWanNetConfigDbase(VOID)
{
    DWORD	rc;

    // create wan net pool
    if(!GlobalConfig.EnableAutoWanNetAllocation) {

	if((rc = CreateWanNetPool()) != NO_ERROR) {

	    return rc;
	}
    }

    // create global wan net
    if(GlobalConfig.RParams.EnableGlobalWanNet) {

	if((rc = CreateGlobalWanNet()) != NO_ERROR) {

	    return rc;
	}
    }

    WanConfigDbaseInitialized = TRUE;

    return NO_ERROR;
}

/*++

Function:	DestroyWanNetConfigDatabase

Descr:		Frees resources allocated for the wan net config database

Remark: 	called when the router stops

--*/

VOID
DestroyWanNetConfigDatabase(VOID)
{
    if(!WanConfigDbaseInitialized) {

	return;
    }

    // destroy wan net pool
    if(!GlobalConfig.EnableAutoWanNetAllocation) {

	DestroyWanNetPool();
    }

    WanConfigDbaseInitialized = FALSE;
}

/*++

Function:	WanNetAlloc

Descr:

Remark: 	>> called with database lock held <<

--*/

DWORD
WanNetAlloc(IN OUT PUCHAR		Network,
	    IN OUT PULONG		AllocatedNetworkIndexp)
{
    DWORD	rc;

    if(GlobalConfig.EnableAutoWanNetAllocation) {

	// try a number of times to generate a unique net number
	rc = GetRandomNetNumber(Network);
	*AllocatedNetworkIndexp = INVALID_NETWORK_INDEX;
    }
    else
    {
	rc = AllocWanNetFromPool(Network,
				 AllocatedNetworkIndexp);
    }

    return rc;
}

/*++

Function:	CreateWanNetPool

Descr:

Remark: 	>> called with database lock held <<

--*/

DWORD
CreateWanNetPool(VOID)
{
    ULONG	    i;
    PNET_ENTRY	    nep;
    PWSTR       nesp;
    ULONG	    wannet;
    UCHAR	    asc[9];
    PUCHAR	    ascp;

    // Create the pool of WAN network numbers to be used in configuring
    // incoming WAN links.

    if ((GlobalConfig.WanNetPoolStr.Buffer!=NULL) && (GlobalConfig.WanNetPoolStr.Length >0)) {
        DWORD   strsz = 0;
        nesp = GlobalConfig.WanNetPoolStr.Buffer;
        strsz = 0;
        while (*nesp!=0) {
            strsz += 1;
            wannet = wcstoul (nesp, NULL, 16);
            if ((wannet==0) || (wannet==0xFFFFFFFF))
                break;
            nesp += wcslen (nesp) + 1;
        }
        if ((*nesp!=0) ||
            (strsz!=(GlobalConfig.WanNetPoolSize)) ||
            ((GlobalConfig.WanNetPoolSize) > WANNET_MAXSIZE)) {

            TraceIpx(WANNET_TRACE, "Invalid wan net pool config WanNetPoolSize =%d\n,"
                                "               entries: ",
	              (GlobalConfig.WanNetPoolSize));
            nesp = GlobalConfig.WanNetPoolStr.Buffer;
            while (*nesp!=0) {
                TraceIpx(WANNET_TRACE|TRACE_NO_STDINFO, "%ls ", nesp);
                nesp += wcslen (nesp) + 1;
            }

            return ERROR_CAN_NOT_COMPLETE;
        }
    }
    else {
        if (((GlobalConfig.FirstWanNet) == 0) ||
            ((GlobalConfig.FirstWanNet) == 0xFFFFFFFF) ||
            ((GlobalConfig.WanNetPoolSize) > WANNET_MAXSIZE)) {

            TraceIpx(WANNET_TRACE, "Invalid wan net pool config, FirstWanNet=%x, WanNetPoolSize =%d\n",
	              GlobalConfig.FirstWanNet, GlobalConfig.WanNetPoolSize);

            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    // If the WanNetPoolSize is 0, then assume any size
    if ((GlobalConfig.WanNetPoolSize == 0) || 
        (GlobalConfig.WanNetPoolSize > WANNET_MAXSIZE))
    {
        GlobalConfig.WanNetPoolSize = WANNET_MAXSIZE;
    }

    // Initialize the wan net pool
    WanNetPool.dwMaxSize = GlobalConfig.WanNetPoolSize;
    WanNetPool.dwCurSize = 0;
    WanNetPool.dwInUseCount = 0;
    WanNetPool.pEntries = NULL;

    return GrowWanNetPool (&WanNetPool);
}

//
// This function resizes the wan net pool to accomodate additional
// callers.
//
DWORD GrowWanNetPool (WAN_NET_POOL * pPool) {
    PWCHAR pszNetList = GlobalConfig.WanNetPoolStr.Buffer;
    PNET_ENTRY pNewEntries, pCur;
    DWORD i, dwNewSize, dwNewNet;
    UCHAR uNetwork[9], *puNetwork;
    uNetwork[8] = 0;
    puNetwork = uNetwork;

    // Enforce that we aren't going to grow beyond our bounds
    if (pPool->dwCurSize >= pPool->dwMaxSize)
        return ERROR_CAN_NOT_COMPLETE;

    // Initialize the new size
    if (! pPool->dwCurSize)
        dwNewSize = WANNET_DEFAULT_SIZE;
    else
        dwNewSize = pPool->dwCurSize + WANNET_DEFAULT_GROW;

    // Truncate the new size to the maximum size
    if (dwNewSize > pPool->dwMaxSize)
        dwNewSize = pPool->dwMaxSize;

    // Initailize a new array of entries
    pNewEntries = GlobalAlloc(GPTR, sizeof(NET_ENTRY) * dwNewSize);
    if (pNewEntries == NULL) {
    	SS_ASSERT(FALSE);
        return ERROR_NOT_ENOUGH_MEMORY;
    }        

    // Copy over the old entries
    if (pPool->dwCurSize)
        CopyMemory (pNewEntries, pPool->pEntries, pPool->dwCurSize * sizeof(NET_ENTRY));

    // Go through the new entries verifying them on the network
    for(i = pPool->dwCurSize, pCur = &(pNewEntries[pPool->dwCurSize]); i < dwNewSize; i++, pCur++) {
        // If the user hadn't given a specific list of addresses,
        // then add test the next numeric network number
        if ((pszNetList == NULL) || (*pszNetList == L'\0'))
    	    dwNewNet = GlobalConfig.FirstWanNet + i;

    	// Otherwise, get the next number from the list
        else {
            dwNewNet = wcstoul (pszNetList, NULL, 16);
            pszNetList += wcslen (pszNetList) + 1;
        }

    	// check if this network number is unique. Generate an warning log
    	// if it isn't
        PUTULONG2LONG(pCur->Network, dwNewNet);
    	if(IsRoute(pCur->Network) || (dwNewNet == 0xFFFFFFFF) || (dwNewNet == 0)) {
    	    NetToAscii(puNetwork, pCur->Network);
    	    RouterLogWarningW(
    	        g_hRouterLog, 
    	        ROUTERLOG_IPXCP_WAN_NET_POOL_NETWORK_NUMBER_CONFLICT,
    	        1, 
    	        (PWCHAR*)&puNetwork,
    	        NO_ERROR);

    	    TraceIpx(WANNET_TRACE, "InitWanNetConfigDbase: Configured WAN pool network %.2x%.2x%.2x%.2x is in use!\n",
    			                    pCur->Network[0], pCur->Network[1], pCur->Network[2], pCur->Network[3]);
            pCur->InUse = TRUE;
            pPool->dwInUseCount++;
    	}
    	else
        	pCur->InUse = FALSE;
    }

    // Free the old pool and assign the new one
    GlobalFree (pPool->pEntries);
    pPool->pEntries = pNewEntries;
    pPool->dwCurSize = dwNewSize;

    return NO_ERROR;
}

/*++

Function:	CreateGlobalWanNet

Descr:

Remark: 	>> called with database lock held <<

--*/

DWORD
CreateGlobalWanNet(VOID)
{
    DWORD	rc;
    ULONG	i;

    if(GlobalConfig.EnableAutoWanNetAllocation) {

	// create the global wan net "automatically".
	// We do that by trying to use the system timer value
	rc = GetRandomNetNumber(GlobalConfig.RParams.GlobalWanNet);
    }
    else
    {
	rc = AllocWanNetFromPool(GlobalConfig.RParams.GlobalWanNet,
				 &GlobalWanNetIndex);
    }

    if(rc == NO_ERROR) {

	// add the global wan net to the routing table if router is started
	// if the router is not started, it will get the global wan net when
	// it will issue the IpxcpBind call
	if(RouterStarted) {

	    rc =(*RmCreateGlobalRoute)(GlobalConfig.RParams.GlobalWanNet);
	}
    }

    return rc;
}

VOID
DestroyWanNetPool(VOID)
{
    WAN_NET_POOL DefaultPool = {WANNET_MAXSIZE, 0, 0, NULL};
    
    if (WanNetPool.dwCurSize) {
        if (WanNetPool.pEntries)
            GlobalFree (WanNetPool.pEntries);
        WanNetPool = DefaultPool;
    }
}

DWORD
AllocWanNetFromPool(PUCHAR	     Network,
		    PULONG	     NetworkIndexp)
{
    ULONG	    i;
    PNET_ENTRY	    nep;
    DWORD	    rc;

    // First, see if we have to grow the pool
    if (WanNetPool.dwInUseCount >= WanNetPool.dwCurSize)
        GrowWanNetPool (&WanNetPool);

    // get a net from the pool
    for(i=0, nep=WanNetPool.pEntries; i<WanNetPool.dwCurSize; i++, nep++) {

	if(!nep->InUse) {

	    nep->InUse = TRUE;
	    WanNetPool.dwInUseCount++;
	    memcpy(Network, nep->Network, 4);
	    *NetworkIndexp = i;

	    rc = NO_ERROR;
	    goto Exit;
	}
    }

    // can't find a free net pool entry
    *NetworkIndexp = INVALID_NETWORK_INDEX;
    rc = ERROR_CAN_NOT_COMPLETE;

Exit:

    return rc;
}

VOID
FreeWanNetToPool(ULONG		AllocatedNetworkIndex)
{
    PNET_ENTRY	    nep;

    if(AllocatedNetworkIndex >= WanNetPool.dwCurSize) {

	return;
    }

    nep = &(WanNetPool.pEntries[AllocatedNetworkIndex]);

    SS_ASSERT(nep->InUse);

    nep->InUse = FALSE;
    WanNetPool.dwInUseCount--;

    return;
}

DWORD randn(DWORD	seed)
{
    seed = seed * 1103515245 + 12345;
    return seed;
}


DWORD
GetRandomNetNumber(PUCHAR	Network)
{
    DWORD	rc = ERROR_CAN_NOT_COMPLETE;
    ULONG	i, seed, high, low, netnumber;

    for(i=0; i<100000; i++) {

	seed = GetTickCount();

	// check if this isn't the same seed as last used
	if(seed == LastUsedRandSeed) {

	    seed++;
	}

	LastUsedRandSeed = seed;

	// generate a sequence of two random numbers using the time tick count
	// as seed
	low = randn(seed) >> 16;
	high = randn(randn(seed)) & 0xffff0000;

	netnumber = high + low;

	PUTULONG2LONG(Network, netnumber);

	if(!IsRoute(Network)) {

	    rc = NO_ERROR;
	    break;
	}
    }

    return rc;
}

//
// Reconfigures the wannet database
//
DWORD WanNetReconfigure() {

    ACQUIRE_DATABASE_LOCK;
    
    // Destroy the current pool
    DestroyWanNetPool();

    // Mark everything as unintialized
    WanConfigDbaseInitialized = FALSE;

    RELEASE_DATABASE_LOCK;
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raspap\raspap.c ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** raspap.c
** Remote Access PPP Password Authentication Protocol
** Core routines
**
** 11/05/93 Steve Cobb
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <crypt.h>

#include <windows.h>
#include <lmcons.h>
#include <string.h>
#include <stdlib.h>
#include <rasman.h>
#include <pppcp.h>
#include <rtutils.h>
#define INCL_PWUTIL
#define INCL_HOSTWIRE
#define INCL_RASAUTHATTRIBUTES
#define INCL_MISC
#include <ppputil.h>
#include <rasauth.h>
#define SDEBUGGLOBALS
#define RASPAPGLOBALS
#include "raspap.h"
#include <raserror.h>

#define TRACE_RASPAP        (0x00010000|TRACE_USE_MASK)

#define TRACE(a)            TracePrintfExA(g_dwTraceIdPap,TRACE_RASPAP,a )
#define TRACE1(a,b)         TracePrintfExA(g_dwTraceIdPap,TRACE_RASPAP,a,b )
#define TRACE2(a,b,c)       TracePrintfExA(g_dwTraceIdPap,TRACE_RASPAP,a,b,c )
#define TRACE3(a,b,c,d)     TracePrintfExA(g_dwTraceIdPap,TRACE_RASPAP,a,b,c,d )

#define DUMPW(X,Y)          TraceDumpExA(g_dwTraceIdPap,1,(LPBYTE)X,Y,4,1,NULL)
#define DUMPB(X,Y)          TraceDumpExA(g_dwTraceIdPap,1,(LPBYTE)X,Y,1,1,NULL)


#define REGKEY_Pap          \
            "SYSTEM\\CurrentControlSet\\Services\\RasMan\\PPP\\ControlProtocols\\BuiltIn"
#define REGVAL_FollowStrictSequencing "FollowStrictSequencing"


/*---------------------------------------------------------------------------
** External entry points
**---------------------------------------------------------------------------
*/

DWORD
PapInit(
    BOOL        fInitialize)

{
    if (fInitialize)
    {
        HKEY  hkey;
        DWORD dwType;
        DWORD dwValue;
        DWORD cb = sizeof(DWORD);

        if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Pap, &hkey ) == 0)
        {
            if (RegQueryValueEx(
                   hkey, REGVAL_FollowStrictSequencing, NULL,
                   &dwType, (LPBYTE )&dwValue, &cb ) == 0
                && dwType == REG_DWORD
                && cb == sizeof(DWORD)
                && dwValue)
            {
                fFollowStrictSequencing = TRUE;
            }

            RegCloseKey( hkey );
        }

        g_dwTraceIdPap = TraceRegisterA( "RASPAP" );
    }
    else
    {
        if ( g_dwTraceIdPap != INVALID_TRACEID )
        {
            TraceDeregisterA( g_dwTraceIdPap );
            g_dwTraceIdPap = INVALID_TRACEID;
        }
    }

    return(NO_ERROR);
}


DWORD
PapGetInfo(
    IN  DWORD       dwProtocolId,
    OUT PPPCP_INFO* pInfo )

    /* PapGetInfo entry point called by the PPP engine.  See RasCp
    ** interface documentation.
    */
{
    TRACE(("PAP: PapGetInfo\n"));

    ZeroMemory( pInfo, sizeof(*pInfo) );

    pInfo->Protocol = (DWORD )PPP_PAP_PROTOCOL;
    pInfo->Recognize = MAXPAPCODE + 1;
    pInfo->RasCpInit = PapInit;
    pInfo->RasCpBegin = PapBegin;
    pInfo->RasCpEnd = PapEnd;
    pInfo->RasApMakeMessage = PapMakeMessage;

    return 0;
}


DWORD
PapBegin(
    OUT VOID** ppWorkBuf,
    IN  VOID*  pInfo )

    /* RasCpBegin entry point called by the PPP engine thru the passed
    ** address.  See RasCp interface documentation.
    */
{
    PPPAP_INPUT* pInput = (PPPAP_INPUT* )pInfo;
    PAPWB*       pwb;

    /* Allocate work buffer.
    */
    if (!(pwb = (PAPWB* )LocalAlloc( LPTR, sizeof(PAPWB) )))
        return ERROR_NOT_ENOUGH_MEMORY;

    pwb->fServer = pInput->fServer;
	pwb->chSeed = GEN_RAND_ENCODE_SEED;

    if (!pwb->fServer)
    {
        TRACE2("PAP: PapBegin(u=%s,d=%s\n",pInput->pszUserName
            ,pInput->pszDomain);

        /* Validate credential lengths.  The credential strings will never be
        ** NULL, but may be "".
        **
        ** !!! PAP requires the domain\username length to fit in a byte.
        **     Currently, UNLEN is defined as 256 and DNLEN is defined as 15.
        **     This means that some valid domain\username combinations cannot
        **     be validated over PAP, but it's only on *really* long
        **     usernames.  Likewise, a password of exactly 256 characters
        **     cannot be validated.
        */
        {
            DWORD cbUserName = strlen( pInput->pszUserName );
            DWORD cbPassword = strlen( pInput->pszPassword );
            DWORD cbDomain = strlen( pInput->pszDomain );

            if (cbUserName > UNLEN
                || cbDomain > DNLEN
                || cbDomain + 1 + cbUserName > 255
                || cbPassword > max( PWLEN, 255 ))
            {
                LocalFree( pwb );
                return ERROR_INVALID_PARAMETER;
            }
        }

        /* "Account" refers to the domain\username format.  When domain is "",
        ** no "\" is sent (to facilitate connecting to foreign systems which
        ** use a simple string identifier).  Otherwise when username is "",
        ** the "\" is sent, i.e. "domain\".  This form will currently fail,
        ** but could be mapped to some sort of "guest" access in the future.
        */
        if (*(pInput->pszDomain) != '\0')
        {
            strcpy( pwb->szAccount, pInput->pszDomain );
            strcat( pwb->szAccount, "\\" );
        }
        strcat( pwb->szAccount, pInput->pszUserName );
        strcpy( pwb->szPassword, pInput->pszPassword );
        EncodePw( pwb->chSeed, pwb->szPassword );
    }
    else
    {
        pwb->hPort = pInput->hPort;
    }

    pwb->state = PS_Initial;

    /* Register work buffer with engine.
    */
    *ppWorkBuf = pwb;
    return 0;
}


DWORD
PapEnd(
    IN VOID* pWorkBuf )

    /* RasCpEnd entry point called by the PPP engine thru the passed address.
    ** See RasCp interface documentation.
    */
{
    TRACE("PAP: PapEnd\n");

    if ( pWorkBuf != NULL )
    {
        PAPWB* pwb = (PAPWB* )pWorkBuf;

        if ( pwb->pUserAttributes != NULL )
        {
            RasAuthAttributeDestroy( pwb->pUserAttributes );

            pwb->pUserAttributes = NULL;
        }

        ZeroMemory( pWorkBuf, sizeof(PAPWB) );

        LocalFree( (HLOCAL )pWorkBuf );
    }

    return 0;
}


DWORD
PapMakeMessage(
    IN  VOID*         pWorkBuf,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult,
    IN  PPPAP_INPUT*  pInput )

    /* RasApMakeMessage entry point called by the PPP engine thru the passed
    ** address.  See RasCp interface documentation.
    */
{
    PAPWB* pwb = (PAPWB* )pWorkBuf;

    TRACE1("PAP: PapMakeMessage,RBuf=%p\n",pReceiveBuf);

    (void )pInput;

    return
        (pwb->fServer)
          ? PapSMakeMessage(pwb, pReceiveBuf, pSendBuf, cbSendBuf, pInput,
                pResult)
          : PapCMakeMessage( pwb, pReceiveBuf, pSendBuf, cbSendBuf, pResult );
}


/*---------------------------------------------------------------------------
** Internal routines (alphabetically)
**---------------------------------------------------------------------------
*/

DWORD
PapCMakeMessage(
    IN  PAPWB*        pwb,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    OUT PPPAP_RESULT* pResult )

    /* Client side "make message" entry point.  See RasCp interface
    ** documentation.
    */
{
    /* Start over if timeout waiting for a reply.
    */
    if (!pReceiveBuf && pwb->state != PS_Initial)
        pwb->state = PS_Initial;

    switch (pwb->state)
    {
        case PS_Initial:
        {
            /* Send an Authenticate-Req packet, then wait for the reply.
            */
            pResult->bIdExpected = BNextIdPap;
            PapMakeRequestMessage( pwb, pSendBuf, cbSendBuf );
            pResult->Action = APA_SendWithTimeout;
            pwb->state = PS_RequestSent;

            break;
        }

        case PS_RequestSent:
        {
            if (pReceiveBuf->Id != pwb->bIdSent)
            {
                //
                // See bug # 22508
                //

                if ( fFollowStrictSequencing )
                {
                    /* Received a packet out of sequence.  Silently discard it.
                    */
                    pResult->Action = APA_NoAction;
                    break;
                }
            }

            pResult->fRetry = FALSE;

            PapExtractMessage( pReceiveBuf, pResult );

            if (pReceiveBuf->Code == PAPCODE_Ack)
            {
                /* Passed authentication.
                */
                pResult->Action = APA_Done;
                pResult->dwError = 0;
                pwb->state = PS_Done;
            }
            else if (pReceiveBuf->Code == PAPCODE_Nak)
            {
                /* Failed authentication.
                */
                pResult->Action = APA_Done;
                pResult->dwError = GetErrorFromNak( pReceiveBuf );
                pwb->state = PS_Done;
            }
            else
            {
                /* Received an Authenticate-Req packet.  The engine filters
                ** all others.  Shouldn't happen, but silently discard it.
                */
                RTASSERT(!"Bogus pReceiveBuf->Code");
                pResult->Action = APA_NoAction;
                break;
            }

            break;
        }
    }

    return 0;
}


DWORD
GetCredentialsFromRequest(
    IN  PPP_CONFIG* pReceiveBuf,
    OUT CHAR*       pszIdentity,
    OUT CHAR*       pszPassword
)

    /* Fill caller's 'pszIdentity' and 'pszPassword' buffers
    ** with the username and password in the request packet.
    ** Caller's buffers should be at least UNLEN+DNLEN+1 and PWLEN bytes long,
    ** respectively.
    **
    ** Returns 0 if successful, or ERRORBADPACKET if the packet is
    ** misformatted in any way.
    */
{
    BYTE* pcbPeerId;
    CHAR* pchPeerId;
    BYTE* pcbPassword;
    CHAR* pchPassword;
    WORD  cbPacket;

    cbPacket = WireToHostFormat16( pReceiveBuf->Length );

    /* Parse out username and domain from the peer ID (domain\username or
    ** username format).
    */
    if (cbPacket < PPP_CONFIG_HDR_LEN + 1)
        return ERRORBADPACKET;

    pcbPeerId = pReceiveBuf->Data;
    pchPeerId = pcbPeerId + 1;

    if (cbPacket < PPP_CONFIG_HDR_LEN + 1 + *pcbPeerId)
    {
        return ERRORBADPACKET;
    }

    /* Extract the username.
    */
    RTASSERT(*pcbPeerId <= (UNLEN+DNLEN+1));
    CopyMemory( pszIdentity, pchPeerId, *pcbPeerId );
    pszIdentity[ *pcbPeerId ] = '\0';

    /* Extract the password.
    */
    if (cbPacket < PPP_CONFIG_HDR_LEN + 1 + *pcbPeerId + 1)
        return ERRORBADPACKET;

    pcbPassword = pchPeerId + *pcbPeerId;
    pchPassword = pcbPassword + 1;
    RTASSERT(*pcbPassword<=PWLEN);

    if (cbPacket < PPP_CONFIG_HDR_LEN + 1 + *pcbPeerId + 1 + *pcbPassword)
        return ERRORBADPACKET;

    CopyMemory( pszPassword, pchPassword, *pcbPassword );
    pszPassword[ *pcbPassword ] = '\0';

    return 0;
}


DWORD
GetErrorFromNak(
    IN PPP_CONFIG* pReceiveBuf )

    /* Returns the RAS error number out of the Message portion of the
    ** Authenticate-Nak message buffer 'pReceiveBuf' or 0 if none.
    */
{
    DWORD dwError = 0;
    CHAR  szBuf[ 255 + 1 ];
    BYTE* pcbMsg = pReceiveBuf->Data;
    WORD  cbPacket = WireToHostFormat16( pReceiveBuf->Length );

    TRACE("PAP: GetErrorFromNak...\n");

    if (cbPacket > PPP_CONFIG_HDR_LEN && *pcbMsg)
    {
        CHAR* pchBuf = szBuf;
        CHAR* pchMsg = pcbMsg + 1;
        BYTE  i;

        if (*pcbMsg > 2 && pchMsg[ 0 ] == 'E' || pchMsg[ 1 ] == '=')
        {
            for (i = 2; i < *pcbMsg; ++i)
            {
                if (pchMsg[ i ] < '0' || pchMsg[ i ] > '9')
                    break;

                *pchBuf++ = pchMsg[ i ];
            }

            *pchBuf = '\0';
            dwError = (DWORD )atol( szBuf );
        }
    }

    if (dwError == 0)
    {
        TRACE("PAP: Error code not found.\n");
        dwError = ERROR_AUTHENTICATION_FAILURE;
    }

    TRACE1("PAP: GetErrorFromNak done(%d)\n",dwError);
    return dwError;
}


VOID
PapMakeRequestMessage(
    IN  PAPWB*      pwb,
    OUT PPP_CONFIG* pSendBuf,
    IN  DWORD       cbSendBuf )

    /* Builds a request packet in caller's 'pSendBuf' buffer.  'cbSendBuf' is
    ** the length of caller's buffer.  'pwb' is the address of the work
    ** buffer associated with the port.
    */
{
    BYTE* pcbPeerId;
    CHAR* pchPeerId;
    BYTE* pcbPassword;
    CHAR* pchPassword;

    RTASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+1+UNLEN+1+DNLEN+1+PWLEN);
    (void )cbSendBuf;

    /* Fill in the peer ID, i.e. the account.
    */
    pcbPeerId = pSendBuf->Data;
    *pcbPeerId = (BYTE )strlen( pwb->szAccount );

    pchPeerId = pcbPeerId + 1;
    strcpy( pchPeerId, pwb->szAccount );

    /* Fill in the password.
    */
    pcbPassword = pchPeerId + *pcbPeerId;
    *pcbPassword = (BYTE )strlen( pwb->szPassword );

    pchPassword = pcbPassword + 1;
    strcpy( pchPassword, pwb->szPassword );
    DecodePw( pwb->chSeed, pchPassword );

    /* Fill in the header.
    */
    pSendBuf->Code = (BYTE )PAPCODE_Req;
    pSendBuf->Id = pwb->bIdSent = BNextIdPap++;

    {
        WORD wLength =
            (WORD )(PPP_CONFIG_HDR_LEN + 1 + *pcbPeerId + 1 + *pcbPassword);
        HostToWireFormat16( wLength, pSendBuf->Length );
        TRACE("PAP: Request...\n");//DUMPB(pSendBuf,(DWORD )wLength);
    }
}


VOID
PapMakeResultMessage(
    IN  DWORD               dwError,
    IN  BYTE                bId,
    OUT PPP_CONFIG*         pSendBuf,
    IN  DWORD               cbSendBuf,
    IN  RAS_AUTH_ATTRIBUTE* pAttributesFromAuthenticator)

    /* Builds a result packet (Ack or Nak) in caller's 'pSendBuf' buffer.
    ** 'cbSendBuf' is the length of caller's buffer.  'dwError' indicates
    ** whether an Ack (0) or Nak (!0) should be generated, and for Nak the
    ** failure code to include.  'bId' is the packet sequence number of the
    ** corresponding request packet. pAttributesFromAuthenticator points to
    ** attributes returned by the authenticator.
    */
{
    BYTE* pcbMsg;
    BYTE  cbMsg;
    CHAR* pchMsg;
    CHAR* pszReplyMessage   = NULL;
    DWORD dwNumBytes;

    RTASSERT(cbSendBuf>=PPP_CONFIG_HDR_LEN+1+10);

    /* Fill in the header and message. If unsuccessful, the message is the
    ** decimal RAS error code in ASCII.
    */
    pSendBuf->Id = bId;
    pcbMsg = pSendBuf->Data;
    pchMsg = pcbMsg + 1;

    if (dwError == 0)
    {
        pSendBuf->Code = PAPCODE_Ack;
        cbMsg = 0;
    }
    else
    {
        pSendBuf->Code = PAPCODE_Nak;

        strcpy( pchMsg, "E=" );
        _ltoa( (long )dwError, (char* )pchMsg + 2, 10 );

        cbMsg = (BYTE )strlen( pchMsg );
    }

    if (pAttributesFromAuthenticator != NULL)
    {
        pszReplyMessage = RasAuthAttributeGetConcatString(
                            raatReplyMessage,
                            pAttributesFromAuthenticator, &dwNumBytes );
    }

    if (NULL != pszReplyMessage)
    {
        if (dwNumBytes + cbMsg > 0xFF)
        {
            dwNumBytes = 0xFF - cbMsg;
        }

        if (dwNumBytes > cbSendBuf - PPP_CONFIG_HDR_LEN - 1 - cbMsg)
        {
            dwNumBytes = cbSendBuf - PPP_CONFIG_HDR_LEN - 1 - cbMsg;
        }

        CopyMemory(pchMsg + cbMsg, pszReplyMessage, dwNumBytes);

        cbMsg += (BYTE)dwNumBytes;
    }

    LocalFree(pszReplyMessage);

    {
        WORD wLength = (WORD )(PPP_CONFIG_HDR_LEN + 1 + cbMsg);
        HostToWireFormat16( wLength, (PBYTE )pSendBuf->Length );
        *pcbMsg = cbMsg;
        TRACE("PAP: Result...\n");DUMPB(pSendBuf,(DWORD )wLength);
    }
}


VOID
PapExtractMessage(
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPPAP_RESULT* pResult )
{
    DWORD   dwNumBytes;
    CHAR*   pszReplyMessage = NULL;
    WORD    cbPacket;

    cbPacket = WireToHostFormat16(pReceiveBuf->Length);

    if (PPP_CONFIG_HDR_LEN >= cbPacket)
    {
        goto LDone;
    }

    //
    // There is one extra byte for Msg-Length
    //

    dwNumBytes = cbPacket - PPP_CONFIG_HDR_LEN - 1;

    //
    // One more for the terminating NULL.
    //

    pszReplyMessage = LocalAlloc(LPTR, dwNumBytes + 1);

    if (NULL == pszReplyMessage)
    {
        TRACE("LocalAlloc failed. Cannot extract server's message.");
        goto LDone;
    }

    CopyMemory(pszReplyMessage, pReceiveBuf->Data + 1, dwNumBytes);

    LocalFree(pResult->szReplyMessage);

    pResult->szReplyMessage = pszReplyMessage;

    pszReplyMessage = NULL;

LDone:

    LocalFree(pszReplyMessage);

    return;
}

DWORD
PapSMakeMessage(
    IN  PAPWB*        pwb,
    IN  PPP_CONFIG*   pReceiveBuf,
    OUT PPP_CONFIG*   pSendBuf,
    IN  DWORD         cbSendBuf,
    IN  PPPAP_INPUT*  pInput,
    OUT PPPAP_RESULT* pResult )

    /* Server side "make message" entry point.  See RasCp interface
    ** documentation.
    */
{
    DWORD dwErr;

    switch (pwb->state)
    {
        case PS_Initial:
        {
            /* Tell engine we're waiting for the client to initiate the
            ** conversation.
            */
            pResult->Action = APA_NoAction;
            pwb->state = PS_WaitForRequest;
            break;
        }

        case PS_WaitForRequest:
        {
            CHAR                 szIdentity[ UNLEN + DNLEN + 2 ];
            CHAR                 szPassword[ PWLEN + 1 ];

            //
            // Only process events where we received a packet, igore all other
            // events in this state.
            //

            if ( pReceiveBuf == NULL )
            {
                pResult->Action = APA_NoAction;
                break;
            }

            if (pReceiveBuf->Code != PAPCODE_Req)
            {
                /* Silently discard Ack or Nak.  Engine catches the one's that
                ** aren't even valid codes.
                */
                RTASSERT(pReceiveBuf->Code!=PAPCODE_Req);
                pResult->Action = APA_NoAction;
                break;
            }

            /* Extract user's credentials from received packet.
            */
            if ((dwErr = GetCredentialsFromRequest(
                    pReceiveBuf, szIdentity, szPassword )) != 0)
            {
                if (dwErr == ERRORBADPACKET)
                {
                    /* The packet is corrupt.  Silently discard it.
                    */
                    RTASSERT(dwErr!=ERRORBADPACKET);
                    pResult->Action = APA_NoAction;
                    break;
                }

                return dwErr;
            }

            pwb->bLastIdReceived = pReceiveBuf->Id;

            //
            // Make credentials attributes that will be used to authenticate
            // the client.
            //

            if ( pwb->pUserAttributes != NULL )
            {
                RasAuthAttributeDestroy( pwb->pUserAttributes );

                pwb->pUserAttributes = NULL;
            }

            if (( pwb->pUserAttributes = RasAuthAttributeCreate( 2 ) ) == NULL)
            {
                return( GetLastError() );
            }

            dwErr = RasAuthAttributeInsert( 0,
                                            pwb->pUserAttributes,
                                            raatUserName, 
                                            FALSE,
                                            strlen( szIdentity ),
                                            szIdentity  );

            if ( dwErr != NO_ERROR )
            {
                RasAuthAttributeDestroy( pwb->pUserAttributes );

                pwb->pUserAttributes = NULL;

                return( dwErr );
            }

            dwErr = RasAuthAttributeInsert( 1,
                                            pwb->pUserAttributes,
                                            raatUserPassword,
                                            FALSE,
                                            strlen( szPassword ),
                                            szPassword  );

            if ( dwErr != NO_ERROR )
            {
                RasAuthAttributeDestroy( pwb->pUserAttributes );

                pwb->pUserAttributes = NULL;

                return( dwErr );
            }            
    
            //
            // Start authentication with back-end module
            //

            strcpy( pwb->result.szUserName, szIdentity );

            pResult->pUserAttributes = pwb->pUserAttributes;

            pResult->Action = APA_Authenticate;

            pwb->state = PS_WaitForAuthenticationToComplete;

            break;
        }

        case PS_WaitForAuthenticationToComplete:
        {
            if ( pInput != NULL )
            {
                if ( pInput->fAuthenticationComplete )
                {
                    strcpy( pResult->szUserName, pwb->result.szUserName );

                    if ( pInput->dwAuthError != NO_ERROR )
                    {
                        return( pInput->dwAuthError );
                    }

                    if ( pInput->dwAuthResultCode != NO_ERROR )
                    {
                        pwb->result.dwError = pInput->dwAuthResultCode;
                    }

                    pwb->result.Action = APA_SendAndDone;
                    pwb->state = PS_Done;

                    /* ...fall thru...
                    */
                }
            }

            if ( ( pInput == NULL ) || ( !pInput->fAuthenticationComplete ) )
            {
                //
                // Ignore everything if authentication is not complete
                //

                if ( pReceiveBuf != NULL )
                {
                    pwb->bLastIdReceived = pReceiveBuf->Id;
                }

                pResult->Action = APA_NoAction;

                break;
            }
        }

        case PS_Done:
        {
            //
            // If we received a packet or the back-end authenticator completed
            //

            if ( ( pReceiveBuf != NULL ) ||
                 ( ( pInput != NULL ) && ( pInput->fAuthenticationComplete ) ) )
            {
                //
                // Build the Ack or Nak packet.  The same packet sent in
                // response to the first Authenticate-Req packet is sent in
                // response to all subsequent Authenticate-Req packets
                // regardless of credentials (per PAP spec).
                //

                if ( pReceiveBuf != NULL )
                {
                    pwb->bLastIdReceived = pReceiveBuf->Id;
                }

                PapMakeResultMessage( pwb->result.dwError,
                                   pwb->bLastIdReceived,
                                   pSendBuf,
                                   cbSendBuf,
                                   (pInput != NULL) ?
                                        pInput->pAttributesFromAuthenticator : 
                                        NULL );

                CopyMemory( pResult, &pwb->result, sizeof(*pResult) );
            }
            else
            {
                pResult->Action = APA_NoAction;

                break;
            }

            break;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\common\inc\defs.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  6/8/92  Gurdeep Singh Pall  Created
//
//
//  Description: This file contains all defines used in rasman
//
//****************************************************************************

#pragma once
#ifndef _DEFS_
#define _DEFS_

#define MAX_ENTRYPOINTS                 20
#define MAX_DEVICES                     20
#define QUEUE_ELEMENT_SIZE              256
#define MAX_BUFFER_SIZE                 2000
#define DISCONNECT_TIMEOUT              10      // Should be in registry?
#define PACKET_SIZE                     1500
#define MAX_RECVBUFFER_SIZE             PACKET_SIZE + 14
#define MAX_SENDRCVBUFFER_SIZE          PACKET_SIZE
#define MAX_REQBUFFERS                  1
#define MAX_DELTAQUEUE_ELEMENTS         100
#define MAX_DELTA                       5000
#define MAX_PORTS_PER_WORKER            32
#define MAX_OBJECT_NAME                 32
#define MAX_ADAPTER_NAME                128  // ???????
#define SENDRCVBUFFERS_PER_PORT         2
#define MAX_PENDING_RECEIVES            2
#define INVALID_INDEX                   0xFFFF
#define RASMANWAITEVENTOBJECT           "RAS_EO_01"
#define SENDRCVMUTEXOBJECT              "Global\\RAS_MO_01"
#define REQBUFFERMUTEXOBJECT            "RAS_MO_02"
#define IOCPMUTEXOBJECT                 "RAS_MO_O3"         // IOCP Named Mutex
#define REQBUFFEREVENTOBJECT            "RAS_EO_02"
#define RASMANCLOSEEVENTOBJECT          "RAS_EO_03"
#define IOCPEVENTOBJECT                 "RAS_EO_04"                 // IOCP Named event
#define RASMANPPTPENDPOINTCHANGEEVENT   "RasmanPptpEndPointChangeEvent"
#define RASMANFILEMAPPEDOBJECT0         "RAS_FM_00"
#define RASMANFILEMAPPEDOBJECT1         "RAS_FM_01"
#define RASMANFILEMAPPEDOBJECT2         "RAS_FM_02"
#define RASMANFILEMAPPEDOBJECT3         "RAS_FM_03"         // IOCP File Mapping
#define RASMAN_REQBUFFER_MAPPEDFILE     "RAS41766.TEM"
#define RASMAN_SENDRCV_MAPPEDFILE       "RAS42764.TEM"
#define REQBUFFERSIZE_PER_PORT          1000
#define REQBUFFERSIZE_FIXED             2000
#define RASHUB_NAME                     "\\\\.\\NDISWAN"
#define RASMAN_EXE_NAME                 "svchost.exe"
#define SCREG_EXE_NAME                  "screg.exe"
#define REQUEST_PRIORITY_THRESHOLD      16
#define STANDARD_QUALITY_OF_SERVICE     3      // ????
#define STANDARD_NUMBER_OF_VCS          20     // ????
#define INVALID_ENDPOINT                0xFFFF
#define RASMAN_REGISTRY_PATH            "System\\CurrentControlSet\\Services\\Rasman\\Parameters"
#define RASMAN_PARAMETER                "Medias"
#define MAX_ROUTE_SIZE                  128
#define WORKER_THREAD_STACK_SIZE        10000
#define IOCP_THREAD_STACK_SIZE          10000
#define TIMER_THREAD_STACK_SIZE         10000
#define REGISTRY_NETBIOS_KEY_NAME       "System\\CurrentControlSet\\Services\\NetBios\\Linkage"
#define REGISTRY_REMOTEACCESS_KEY_NAME  "System\\CurrentControlSet\\Services\\RemoteAccess\\Linkage\\Disabled"
#define REGISTRY_ROUTE                  "Route"
#define REGISTRY_LANANUM                "LanaNum"
#define REGISTRY_LANAMAP                "LanaMap"
#define REGISTRY_ENUMEXPORT             "EnumExport"

#define REGISTRY_SERVICES_KEY_NAME      "System\\CurrentControlSet\\Services\\"
#define REGISTRY_PARAMETERS_KEY         "\\Parameters"

#define REGISTRY_AUTOIPADDRESS          "AutoIPAddress"
#define REGISTRY_SERVERADAPTER          "ServerAdapter"

#define REGISTRY_NETCARDS               "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards"
#define REGISTRY_PRODUCTNAME            "ProductName"
#define REGISTRY_NDISWAN                "NdisWan"

// Only reason this is there because we are mapping 3 devices to one name:
//
#define  DEVICE_MODEMPADSWITCH          "RASMXS"
#define  DEVICE_MODEM                   "MODEM"
#define  DEVICE_PAD                     "PAD"
#define  DEVICE_SWITCH                  "SWITCH"
#define  DEVICE_NULL                    "NULL"

// Media DLL entrypoints:
//
#define PORTENUM_STR                    "PortEnum"
#define PORTENUM_ID                     0

#define PORTOPEN_STR                    "PortOpen"
#define PORTOPEN_ID                     1

#define PORTCLOSE_STR                   "PortClose"
#define PORTCLOSE_ID                    2

#define PORTGETINFO_STR                 "PortGetInfo"
#define PORTGETINFO_ID                  3

#define PORTSETINFO_STR                 "PortSetInfo"
#define PORTSETINFO_ID                  4

#define PORTDISCONNECT_STR              "PortDisconnect"
#define PORTDISCONNECT_ID               5

#define PORTCONNECT_STR                 "PortConnect"
#define PORTCONNECT_ID                  6

#define PORTGETPORTSTATE_STR            "PortGetPortState"
#define PORTGETPORTSTATE_ID             7

#define PORTCOMPRESSSETINFO_STR         "PortCompressionSetInfo" // Unsupported
#define PORTCOMPRESSSETINFO_ID          8

#define PORTCHANGECALLBACK_STR          "PortChangeCallback"
#define PORTCHANGECALLBACK_ID           9

#define PORTGETSTATISTICS_STR           "PortGetStatistics"
#define PORTGETSTATISTICS_ID            10

#define PORTCLEARSTATISTICS_STR         "PortClearStatistics"
#define PORTCLEARSTATISTICS_ID          11

#define PORTSEND_STR                    "PortSend"
#define PORTSEND_ID                     12

#define PORTTESTSIGNALSTATE_STR         "PortTestSignalState"
#define PORTTESTSIGNALSTATE_ID          13

#define PORTRECEIVE_STR                 "PortReceive"
#define PORTRECEIVE_ID                  14

#define PORTINIT_STR                    "PortInit"
#define PORTINIT_ID                     15

#define PORTCOMPLETERECEIVE_STR         "PortReceiveComplete"
#define PORTCOMPLETERECEIVE_ID          16

#define PORTSETFRAMING_STR              "PortSetFraming"
#define PORTSETFRAMING_ID               17

#define PORTGETIOHANDLE_STR             "PortGetIOHandle"
#define PORTGETIOHANDLE_ID              18

#define PORTSETIOCOMPLETIONPORT_STR     "PortSetIoCompletionPort"
#define PORTSETIOCOMPLETIONPORT_ID      19

#define MAX_MEDIADLLENTRYPOINTS         20

#define MSECS_OutOfProcessReceiveTimeOut 15000

// Macros:
//

#define PORTENUM(mediaptr,buffer,ps,pe) \
    ((PortEnum_t)(mediaptr->MCB_AddrLookUp[PORTENUM_ID]))(buffer,ps,pe)

#define PORTCONNECT(mediaptr,iohandle,wait,handle) \
    ((PortConnect_t)(mediaptr->MCB_AddrLookUp[PORTCONNECT_ID]))(iohandle, \
                                    wait,    \
                                    handle)

#define PORTGETINFO(mediaptr,iohandle,name,buffer,psize) \
    ((PortGetInfo_t)(mediaptr->MCB_AddrLookUp[PORTGETINFO_ID]))(iohandle, \
                                    name,     \
                                    buffer,   \
                                    psize)

#define PORTSETINFO(mediaptr,iohandle,portinfo) \
    ((PortSetInfo_t)(mediaptr->MCB_AddrLookUp[PORTSETINFO_ID]))(iohandle,\
                                    portinfo)

#define PORTOPEN(mediaptr,portname,phandle,handle,key) \
    ((PortOpen_t)(mediaptr->MCB_AddrLookUp[PORTOPEN_ID]))(portname, \
                                  phandle,  \
                                  handle,   \
                                  key)

#define PORTDISCONNECT(mediaptr,iohandle) \
    ((PortDisconnect_t)(mediaptr->MCB_AddrLookUp[PORTDISCONNECT_ID])) \
                                  (iohandle)


#define PORTGETSTATISTICS(mediaptr,iohandle,pstat) \
    ((PortGetStatistics_t)(mediaptr->MCB_AddrLookUp[PORTGETSTATISTICS_ID]))\
                                  (iohandle,pstat)


#define PORTCLEARSTATISTICS(mediaptr,iohandle) \
    ((PortClearStatistics_t)           \
          (mediaptr->MCB_AddrLookUp[PORTCLEARSTATISTICS_ID]))(iohandle)


#define PORTCLOSE(mediaptr,iohandle) \
    ((PortClose_t)(mediaptr->MCB_AddrLookUp[PORTCLOSE_ID]))(iohandle)



#define PORTSEND(mediaptr,iohandle,buffer,size) \
    ((PortSend_t)(mediaptr->MCB_AddrLookUp[PORTSEND_ID])) (iohandle,\
                                   buffer,  \
                                   size)

#define PORTRECEIVE(mediaptr,iohandle,buffer,size,timeout) \
    ((PortReceive_t)(mediaptr->MCB_AddrLookUp[PORTRECEIVE_ID])) ( \
                                 iohandle,\
                                 buffer,  \
                                 size,    \
                                 timeout)

#define PORTCLOSE(mediaptr,iohandle) \
    ((PortClose_t)(mediaptr->MCB_AddrLookUp[PORTCLOSE_ID]))(iohandle)


#define PORTCOMPRESSIONGETINFO(mediaptr,pc) \
    ((PortCompressionGetInfo)(mediaptr->MCB_AddrLookUp[PORTCOMPRESSGETINFO_ID]))(pc)


#define PORTTESTSIGNALSTATE(mediaptr,iohandle,devstate) \
    ((PortTestSignalState_t)    \
       (mediaptr->MCB_AddrLookUp[PORTTESTSIGNALSTATE_ID]))(iohandle,devstate)


#define PORTINIT(mediaptr,iohandle) \
    ((PortInit_t)(mediaptr->MCB_AddrLookUp[PORTINIT_ID]))(iohandle)

#define PORTCOMPLETERECEIVE(mediaptr,iohandle,bytesread) \
    ((PortReceiveComplete_t)(mediaptr->MCB_AddrLookUp[PORTCOMPLETERECEIVE_ID]))(iohandle,bytesread)

#define PORTSETFRAMING(mediaptr,iohandle,one,two,three,four) \
    ((PortSetFraming_t)(mediaptr->MCB_AddrLookUp[PORTSETFRAMING_ID]))(iohandle,one,two,three,four)

#define PORTGETIOHANDLE(mediaptr,porthandle,iohandle) \
    ((PortGetIOHandle_t)(mediaptr->MCB_AddrLookUp[PORTGETIOHANDLE_ID]))(porthandle,iohandle)

#define PORTSETIOCOMPLETIONPORT(mediaptr, hIoCompletionPort) \
    ((PortSetIoCompletionPort_t)(mediaptr->MCB_AddrLookUp[PORTSETIOCOMPLETIONPORT_ID])) (hIoCompletionPort)

// Device DLL entrypoints:
//
#define DEVICEENUM_STR              "DeviceEnum"
#define DEVICEENUM_ID               0

#define DEVICECONNECT_STR           "DeviceConnect"
#define DEVICECONNECT_ID            1

#define DEVICELISTEN_STR            "DeviceListen"
#define DEVICELISTEN_ID             2

#define DEVICEGETINFO_STR           "DeviceGetInfo"
#define DEVICEGETINFO_ID            3

#define DEVICESETINFO_STR           "DeviceSetInfo"
#define DEVICESETINFO_ID            4

#define DEVICEDONE_STR              "DeviceDone"
#define DEVICEDONE_ID               5

#define DEVICEWORK_STR              "DeviceWork"
#define DEVICEWORK_ID               6

#define DEVICESETDEVCONFIG_STR      "DeviceSetDevConfig"
#define DEVICESETDEVCONFIG_ID       7

#define DEVICEGETDEVCONFIG_STR      "DeviceGetDevConfig"
#define DEVICEGETDEVCONFIG_ID       8

#define MAX_DEVICEDLLENTRYPOINTS    9


// Macros:
//
#define DEVICEENUM(deviceptr,type,pentries,buffer,psize) \
    ((DeviceEnum_t)(deviceptr->DCB_AddrLookUp[DEVICEENUM_ID]))(type,     \
                                   pentries, \
                                   buffer,   \
                                   psize)


#define DEVICEGETINFO(deviceptr,iohandle,type,name,buffer,psize) \
    ((DeviceGetInfo_t)(deviceptr->DCB_AddrLookUp[DEVICEGETINFO_ID]))(      \
                                     iohandle, \
                                     type,     \
                                     name,     \
                                     buffer,   \
                                     psize)

#define DEVICESETINFO(deviceptr,iohandle,type,name,pinfo) \
    ((DeviceSetInfo_t)(deviceptr->DCB_AddrLookUp[DEVICESETINFO_ID]))(      \
                                     iohandle, \
                                     type,     \
                                     name,     \
                                     pinfo)

#define DEVICECONNECT(deviceptr,iohandle,type,name) \
    ((DeviceConnect_t)(deviceptr->DCB_AddrLookUp[DEVICECONNECT_ID]))(      \
                                     iohandle, \
                                     type,     \
                                     name)

#define DEVICELISTEN(deviceptr,iohandle,type,name) \
    ((DeviceListen_t)(deviceptr->DCB_AddrLookUp[DEVICELISTEN_ID]))(        \
                                     iohandle, \
                                     type,     \
                                     name)

#define DEVICEDONE(deviceptr,iohandle) \
    ((DeviceDone_t)(deviceptr->DCB_AddrLookUp[DEVICEDONE_ID]))(iohandle)


#define DEVICEWORK(deviceptr,iohandle) \
    ((DeviceWork_t)(deviceptr->DCB_AddrLookUp[DEVICEWORK_ID]))(iohandle)

#define DEVICESETDEVCONFIG(deviceptr,iohandle,config,size) \
    ((DeviceSetDevConfig_t)(deviceptr->DCB_AddrLookUp[DEVICESETDEVCONFIG_ID]))(iohandle, config, size)

#define DEVICEGETDEVCONFIG(deviceptr,iohandle,config,size) \
    ((DeviceGetDevConfig_t)(deviceptr->DCB_AddrLookUp[DEVICEGETDEVCONFIG_ID]))(iohandle, config, size)

#define PutRecvPacketOnFreeList(_pPacket)           \
{                                                   \
    _pPacket->Next = NULL;                          \
    if (ReceiveBuffers->Free == NULL) {             \
        ReceiveBuffers->Free = _pPacket;            \
    } else {                                        \
        ReceiveBuffers->LastFree->Next = _pPacket;  \
    }                                               \
    ReceiveBuffers->LastFree = _pPacket;            \
    ReceiveBuffers->FreeBufferCount++;              \
}

#define PutRecvPacketOnPcb(_ppcb, _pPacket)         \
{                                                   \
    _pPacket->Next = NULL;                          \
    if (_ppcb->PCB_RecvPackets == NULL) {           \
        _ppcb->PCB_RecvPackets = _pPacket;          \
    } else {                                        \
        _ppcb->PCB_LastRecvPacket->Next = _pPacket; \
    }                                               \
    _ppcb->PCB_LastRecvPacket = _pPacket;           \
}

#define GetRecvPacketFromPcb(_ppcb, _ppPacket)          \
{                                                       \
    if (_ppcb->PCB_RecvPackets != NULL) {               \
        *_ppPacket = _ppcb->PCB_RecvPackets;            \
        _ppcb->PCB_RecvPackets = (*_ppPacket)->Next;    \
        if (_ppcb->PCB_RecvPackets == NULL) {           \
            _ppcb->PCB_LastRecvPacket = NULL;           \
        }                                               \
    } else                                              \
        *_ppPacket = NULL;                              \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\common\inc\reghelp.h ===
/*++

Copyright (C) 1994-95 Microsft Corporation. All rights reserved.

Module Name: 

    reghelp.h

Abstract:

    This file contains helper functions to read enpoint information
    from registry

Author:

    Rao Salapaka (raos) 01-Nov-1997

Revision History:

--*/

DWORD   DwGetEndPointInfo( DeviceInfo *pInfo, PBYTE pAddress );

DWORD   DwSetEndPointInfo( DeviceInfo *pInfo, PBYTE pAddress );

LONG    lrRasEnableDevice(HKEY hkey, 
                          LPTSTR pszValue,
                          BOOL fEnable);

LONG    lrGetSetMaxEndPoints(DWORD* pdwMaxDialOut,
                             DWORD* pdwMaxDialIn,
                             BOOL   fRead);
                             
DWORD   DwSetModemInfo( DeviceInfo *pInfo);

DWORD   DwSetCalledIdInfo(HKEY hkey,
                          DeviceInfo *pInfo);

DWORD   DwGetCalledIdInfo(HKEY hkey,
                          DeviceInfo  *pInfo);
                       

LONG    lrGetProductType(PRODUCT_TYPE *ppt);

int     RegHelpStringFromGuid(REFGUID rguid, 
        				      LPWSTR lpsz, 
        				      int cchMax);
        				      
LONG    RegHelpGuidFromString(LPCWSTR pwsz,
                              GUID *pguid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raspap\raspap.h ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** raspap.h
** Remote Access PPP Password Authentication Protocol
**
** 11/05/93 Steve Cobb
*/

#ifndef _RASPAP_H_
#define _RASPAP_H_

//General macros
#define GEN_RAND_ENCODE_SEED            ((CHAR) ( 1 + rand() % 250 ))
/* PAP packet codes from PAP spec.
*/
#define PAPCODE_Req 1
#define PAPCODE_Ack 2
#define PAPCODE_Nak 3

#define MAXPAPCODE 3

/* Returned by receive buffer parsing routines that discover the packet is
** corrupt, usually because the length fields don't make sense.
*/
#define ERRORBADPACKET (DWORD )-1

/* Defines states within the PAP protocol.
*/
#define PAPSTATE enum tagPAPSTATE

PAPSTATE
{
    PS_Initial,
    PS_RequestSent,
    PS_WaitForRequest,
    PS_WaitForAuthenticationToComplete,
    PS_Done
};


/* Defines the WorkBuf stored for us by the PPP engine.
*/
#define PAPWB struct tagPAPWB

PAPWB
{
    /* True if role is server, false if client.
    */
    BOOL fServer;

    /* The domain\username and password (applies to client only).
    */
    CHAR szAccount[ DNLEN + 1 + UNLEN + 1 ];
    CHAR szPassword[ PWLEN ];

    /* The current state in the PAP protocol.
    */
    PAPSTATE state;

    /* Last sequencing ID sent on this port.  Incremented for each
    ** Authenticate-Req packet sent. Client side only.
    */
    BYTE bIdSent;

    HPORT hPort;

    /* Id of the last Authenticate-Req packet received on this port.
    ** Server side only.
    */
    BYTE bLastIdReceived;

    //
    // Used to get information to send to back-end server.
    //

    RAS_AUTH_ATTRIBUTE * pUserAttributes;

    /* The final result, used to duplicate the original response for all
    ** subsequent Authenticate-Req packets.  This is per PAP spec to cover
    ** lost Ack/Nak case without allowing malicious client to discover
    ** alternative identities under the covers during a connection.  (applies
    ** to server only)
    */
    PPPAP_RESULT result;
	CHAR				chSeed;			//Used to encode password.  Strange.  We 
										//send password cleartext on the line
										//and encode it in the program...
};


/* Prototypes.
*/
DWORD CheckCredentials( CHAR*, CHAR*, CHAR*, DWORD*, BOOL*, CHAR*,
          BYTE*, CHAR*, HANDLE* );
DWORD PapCMakeMessage( PAPWB*, PPP_CONFIG*, PPP_CONFIG*, DWORD, PPPAP_RESULT* );
DWORD GetCredentialsFromRequest( PPP_CONFIG*, CHAR*, CHAR* );
DWORD GetErrorFromNak( PPP_CONFIG* );
VOID  PapMakeRequestMessage( PAPWB*, PPP_CONFIG*, DWORD );
VOID  PapMakeResultMessage( DWORD, BYTE, PPP_CONFIG*, DWORD, RAS_AUTH_ATTRIBUTE* );
DWORD PapBegin( VOID**, VOID* );
DWORD PapEnd( VOID* );
DWORD PapMakeMessage( VOID*, PPP_CONFIG*, PPP_CONFIG*, DWORD, PPPAP_RESULT*,
          PPPAP_INPUT* pInput );
VOID PapExtractMessage(PPP_CONFIG*, PPPAP_RESULT*);
DWORD PapSMakeMessage( PAPWB*, PPP_CONFIG*, PPP_CONFIG*, DWORD, PPPAP_INPUT*  pInput, PPPAP_RESULT* );


/* Globals.
*/
#ifdef RASPAPGLOBALS
#define GLOBALS
#define EXTERN
#else
#define EXTERN extern
#endif

/* Next packet identifier to assign.  Unlike CPs, APs must handle updating
** this sequence number themselves because the engine can't make as many
** assumptions about the protocol.  It is stored global to all ports and
** authentication sessions to make it less likely that an ID will be used in
** sequential authentication sessions.  Not to be confused with the 'bIdSent'
** updated on a per-port basis and used for matching.
*/
EXTERN BYTE BNextIdPap
#ifdef GLOBALS
    = 0
#endif
;

/* This value indicates whether or not to follow strict sequencing as defined
** in the PPP RFC for PAP. The RFC says that the PAP client MUST increase the
** sequence number for every new CONFIG_REQ packet sent out. However this
** causes problems with slow servers. See bug # 22508. Default is FALSE.
*/
EXTERN BOOL fFollowStrictSequencing
#ifdef GLOBALS
    = FALSE
#endif
;

EXTERN
DWORD g_dwTraceIdPap 
#ifdef GLOBALS
    = INVALID_TRACEID;
#endif
;

#undef EXTERN
#undef GLOBALS


#endif // _RASPAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\common\inc\structs.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  6/8/92  Gurdeep Singh Pall  Created
//
//
//  Description: This file contains all structures used in rasman
//
//****************************************************************************

#ifndef _STRUCTS_
#define _STRUCTS_

#include <rasppp.h>
#include <rasapip.h>

enum ReqTypes {
    REQTYPE_NONE                        = 0,
    REQTYPE_PORTOPEN                    = 1,
    REQTYPE_PORTCLOSE                   = 2,
    REQTYPE_PORTGETINFO                 = 3,
    REQTYPE_PORTSETINFO                 = 4,
    REQTYPE_PORTLISTEN                  = 5,
    REQTYPE_PORTSEND                    = 6,
    REQTYPE_PORTRECEIVE                 = 7,
    REQTYPE_PORTGETSTATISTICS           = 8,
    REQTYPE_PORTDISCONNECT              = 9,
    REQTYPE_PORTCLEARSTATISTICS         = 10,
    REQTYPE_PORTCONNECTCOMPLETE         = 11,
    REQTYPE_DEVICEENUM                  = 12,
    REQTYPE_DEVICEGETINFO               = 13,
    REQTYPE_DEVICESETINFO               = 14,
    REQTYPE_DEVICECONNECT               = 15,
    REQTYPE_ACTIVATEROUTE               = 16,
    REQTYPE_ALLOCATEROUTE               = 17,
    REQTYPE_DEALLOCATEROUTE             = 18,
    REQTYPE_COMPRESSIONGETINFO          = 19,
    REQTYPE_COMPRESSIONSETINFO          = 20,
    REQTYPE_PORTENUM                    = 21,
    REQTYPE_GETINFO                     = 22,
    REQTYPE_GETUSERCREDENTIALS          = 23,
    REQTYPE_PROTOCOLENUM                = 24,
    REQTYPE_PORTSENDHUB                 = 25,
    REQTYPE_PORTRECEIVEHUB              = 26,
    REQTYPE_DEVICELISTEN                = 27,
    REQTYPE_NUMPORTOPEN                 = 28,
    REQTYPE_PORTINIT                    = 29,
    REQTYPE_REQUESTNOTIFICATION         = 30,
    REQTYPE_ENUMLANNETS                 = 31,
    REQTYPE_GETINFOEX                   = 32,
    REQTYPE_CANCELRECEIVE               = 33,
    REQTYPE_PORTENUMPROTOCOLS           = 34,
    REQTYPE_SETFRAMING                  = 35,
    REQTYPE_ACTIVATEROUTEEX             = 36,
    REQTYPE_REGISTERSLIP                = 37,
    REQTYPE_STOREUSERDATA               = 38,
    REQTYPE_RETRIEVEUSERDATA            = 39,
    REQTYPE_GETFRAMINGEX                = 40,
    REQTYPE_SETFRAMINGEX                = 41,
    REQTYPE_GETPROTOCOLCOMPRESSION      = 42,
    REQTYPE_SETPROTOCOLCOMPRESSION      = 43,
    REQTYPE_GETFRAMINGCAPABILITIES      = 44,
    REQTYPE_SETCACHEDCREDENTIALS        = 45,
    REQTYPE_PORTBUNDLE                  = 46,
    REQTYPE_GETBUNDLEDPORT              = 47,
    REQTYPE_PORTGETBUNDLE               = 48,
    REQTYPE_BUNDLEGETPORT               = 49,
    REQTYPE_SETATTACHCOUNT              = 50,
    REQTYPE_GETDIALPARAMS               = 51,
    REQTYPE_SETDIALPARAMS               = 52,
    REQTYPE_CREATECONNECTION            = 53,
    REQTYPE_DESTROYCONNECTION           = 54,
    REQTYPE_ENUMCONNECTION              = 55,
    REQTYPE_ADDCONNECTIONPORT           = 56,
    REQTYPE_ENUMCONNECTIONPORTS         = 57,
    REQTYPE_GETCONNECTIONPARAMS         = 58,
    REQTYPE_SETCONNECTIONPARAMS         = 59,
    REQTYPE_GETCONNECTIONUSERDATA       = 60,
    REQTYPE_SETCONNECTIONUSERDATA       = 61,
    REQTYPE_GETPORTUSERDATA             = 62,
    REQTYPE_SETPORTUSERDATA             = 63,
    REQTYPE_PPPSTOP                     = 64,
    REQTYPE_PPPSTART                    = 65,
    REQTYPE_PPPRETRY                    = 66,
    REQTYPE_PPPGETINFO                  = 67,
    REQTYPE_PPPCHANGEPWD                = 68,
    REQTYPE_PPPCALLBACK                 = 69,
    REQTYPE_ADDNOTIFICATION             = 70,
    REQTYPE_SIGNALCONNECTION            = 71,
    REQTYPE_SETDEVCONFIG                = 72,
    REQTYPE_GETDEVCONFIG                = 73,
    REQTYPE_GETTIMESINCELASTACTIVITY    = 74,
    REQTYPE_BUNDLEGETSTATISTICS         = 75,
    REQTYPE_BUNDLECLEARSTATISTICS       = 76,
    REQTYPE_CLOSEPROCESSPORTS           = 77,
    REQTYPE_PNPCONTROL                  = 78,
    REQTYPE_SETIOCOMPLETIONPORT         = 79,
    REQTYPE_SETROUTERUSAGE              = 80,
    REQTYPE_SERVERPORTCLOSE             = 81,
    REQTYPE_SENDPPPMESSAGETORASMAN      = 82,
    REQTYPE_PORTGETSTATISTICSEX         = 83,
    REQTYPE_BUNDLEGETSTATISTICSEX       = 84,
    REQTYPE_SETRASDIALINFO              = 85,
    REQTYPE_REGISTERPNPNOTIF            = 86,
    REQTYPE_PORTRECEIVEEX               = 87,
    REQTYPE_GETATTACHEDCOUNT            = 88,
    REQTYPE_SETBAPPOLICY                = 89,
    REQTYPE_PPPSTARTED                  = 90,
    REQTYPE_REFCONNECTION               = 91,
    REQTYPE_SETEAPINFO                  = 92,
    REQTYPE_GETEAPINFO                  = 93,
    REQTYPE_SETDEVICECONFIGINFO         = 94,
    REQTYPE_GETDEVICECONFIGINFO         = 95,
    REQTYPE_FINDPREREQUISITEENTRY       = 96,
    REQTYPE_PORTOPENEX                  = 97,
    REQTYPE_GETLINKSTATS                = 98,
    REQTYPE_GETCONNECTIONSTATS          = 99,
    REQTYPE_GETHPORTFROMCONNECTION      = 100,
    REQTYPE_REFERENCECUSTOMCOUNT        = 101,
    REQTYPE_GETHCONNFROMENTRY           = 102,
    REQTYPE_GETCONNECTINFO              = 103,
    REQTYPE_GETDEVICENAME               = 104,
    REQTYPE_GETCALLEDID                 = 105,
    REQTYPE_SETCALLEDID                 = 106,
    REQTYPE_ENABLEIPSEC                 = 107,
    REQTYPE_ISIPSECENABLED              = 108,
    REQTYPE_SETEAPLOGONINFO             = 109,
    REQTYPE_SENDNOTIFICATION            = 110,
    REQTYPE_GETNDISWANDRIVERCAPS        = 111,
    REQTYPE_GETBANDWIDTHUTILIZATION     = 112,
    REQTYPE_REGISTERREDIALCALLBACK      = 113,
    REQTYPE_GETPROTOCOLINFO             = 114,
    REQTYPE_GETCUSTOMSCRIPTDLL          = 115,
    REQTYPE_ISTRUSTEDCUSTOMDLL          = 116,
    REQTYPE_DOIKE                       = 117,
    REQTYPE_QUERYIKESTATUS              = 118,
    REQTYPE_SETRASCOMMSETTINGS          = 119,
    REQTYPE_ENABLERASAUDIO              = 120,
    REQTYPE_SETKEY                      = 121,
    REQTYPE_GETKEY                      = 122,
    REQTYPE_ADDRESSDISABLE             = 123,
    REQTYPE_GETDEVCONFIGEX             = 124,
    REQTYPE_SENDCREDS                  = 125,
    REQTYPE_GETUNICODEDEVICENAME       = 126,
    REQTYPE_GETDEVICENAMEW             = 127,
} ; // <---------------------------- If you change this change MAX_REQTYPES

#define MAX_REQTYPES            128

typedef enum ReqTypes ReqTypes ;



//* Function pointer for request call table
//
typedef VOID (* REQFUNC) (pPCB, PBYTE) ;
typedef VOID (* REQFUNCTHUNK) (pPCB, PBYTE, DWORD);

#define RASMAN_THUNK_VERSION        sizeof(ULONG_PTR)


//* DeltaQueueElement:
//
struct DeltaQueueElement {

    struct DeltaQueueElement *DQE_Next ;

    struct DeltaQueueElement *DQE_Last ;

    DWORD            DQE_Delta ;

    PVOID            DQE_pPcb ;

    PVOID            DQE_Function ;

    PVOID            DQE_Arg1 ;

} ;

typedef struct DeltaQueueElement DeltaQueueElement ;


//* DeltaQueue
//
struct DeltaQueue {

    DeltaQueueElement   *DQ_FirstElement ;

} ;

typedef struct DeltaQueue DeltaQueue ;


//* Media Control Block: All information pertaining to a Media type.
//
struct MediaControlBlock {

    CHAR    MCB_Name [MAX_MEDIA_NAME] ;      // "SERIAL" etc.

    FARPROC MCB_AddrLookUp [MAX_ENTRYPOINTS] ;   // All media dlls entry
                             //  points.
    WORD    MCB_Endpoints ;              // Number of ports of
                             // this Media type.

    HANDLE  MCB_DLLHandle ;

} ;

typedef struct MediaControlBlock MediaCB, *pMediaCB ;



//* Device Control Block: All information about every device type attached to.
//
struct DeviceControlBlock {

    CHAR    DCB_Name [MAX_DEVICE_NAME+1] ;       // "MODEM" etc.

    FARPROC DCB_AddrLookUp [MAX_ENTRYPOINTS] ;   // All device dll entry
                             //  points.
    WORD    DCB_UseCount ;               // Number of ports using
                             //  this device.

    HINSTANCE DCB_DLLHandle ;

} ;

typedef struct DeviceControlBlock DeviceCB, *pDeviceCB ;



//* EndpointMappingBlock: One for each MAC - contains info on what endpoints
//            belong to the MAC.
//
struct EndpointMappingBlock {

    WCHAR   EMB_MacName [MAC_NAME_SIZE] ;

    USHORT  EMB_FirstEndpoint ;

    USHORT  EMB_LastEndpoint ;
} ;

typedef struct EndpointMappingBlock EndpointMappingBlock,
                    *pEndpointMappingBlock ;



//* Protocol Info: All information about a protocol binding used by RAS.
//
struct ProtocolInfo {

    RAS_PROTOCOLTYPE   PI_Type ;            // ASYBEUI, IPX, IP etc.

    CHAR        PI_AdapterName [MAX_ADAPTER_NAME];  // "\devices\rashub01"

    CHAR        PI_XportName [MAX_XPORT_NAME];  // "\devices\nbf\nbf01"

    PVOID       PI_ProtocolHandle ;         // Used for routing

    DWORD       PI_Allocated ;          // Allocated yet?

    DWORD       PI_Activated ;          // Activated yet?

    UCHAR       PI_LanaNumber ;         // For Netbios transports.

    BOOL        PI_WorkstationNet ;         // TRUE for wrk nets.

    BOOL        PI_DialOut;
} ;

typedef struct ProtocolInfo ProtInfo, *pProtInfo ;



//* Generic List structure:
//
struct List {

    struct List *   L_Next ;

    BOOL        L_Activated ; // applies to route elements only

    PVOID       L_Element ;

} ;

typedef struct List List, *pList ;


//* Handle List structure:
//
struct HandleList {

    struct HandleList  *H_Next ;

    HANDLE      H_Handle ;

    DWORD       H_Flags;    // NOTIF_* flags

    DWORD       H_Pid;
} ;

typedef struct HandleList HandleList, *pHandleList ;

struct PnPNotifierList {

    struct PnPNotifierList  *PNPNotif_Next;

    union
    {
        PAPCFUNC            pfnPnPNotifHandler;

        HANDLE              hPnPNotifier;

    } PNPNotif_uNotifier;

    DWORD                   PNPNotif_dwFlags;

    HANDLE                  hThreadHandle;

} ;

typedef struct PnPNotifierList PnPNotifierList, *pPnPNotifierList;

//* Send/Rcv Buffers:
//
struct SendRcvBuffer {

    DWORD       SRB_NextElementIndex ;

    DWORD       SRB_Pid ;

    NDISWAN_IO_PACKET   SRB_Packet ;

    BYTE        SRB_Buffer [PACKET_SIZE] ;
} ;

typedef struct SendRcvBuffer SendRcvBuffer ;


//* Send/Rcv Buffer List:
//
struct SendRcvBufferList {

    DWORD       SRBL_AvailElementIndex ;

    HANDLE      SRBL_Mutex ;

    //CHAR        SRBL_MutexName [MAX_OBJECT_NAME] ;

    DWORD       SRBL_NumOfBuffers ;

    SendRcvBuffer   SRBL_Buffers[1] ;

} ;

typedef struct SendRcvBufferList SendRcvBufferList ;



//* Worker Element:
//
struct WorkerElement {

    HANDLE      WE_Notifier ;   // Used to signal request completion.

    ReqTypes    WE_ReqType ;    // Request type:

    DeltaQueueElement   *WE_TimeoutElement ; // points into the timeout queue.

} ;

typedef struct WorkerElement WorkerElement ;


struct RasmanPacket {

    struct  RasmanPacket    *Next;

    RAS_OVERLAPPED  RP_OverLapped ;

    NDISWAN_IO_PACKET   RP_Packet ;

    BYTE    RP_Buffer [MAX_RECVBUFFER_SIZE] ;
} ;

typedef struct RasmanPacket RasmanPacket ;


//* Struct used for supporting multiple receives from the port in the frame mode.
//
struct ReceiveBufferList {
    BOOLEAN         PacketPosted;
    DWORD           PacketNumber;
    RasmanPacket    *Packet;
} ;

typedef struct ReceiveBufferList ReceiveBufferList;

//
// Struct used for supporting bap notifications
//
struct RasmanBapPacket {

    struct RasmanBapPacket *Next;

    RAS_OVERLAPPED RBP_Overlapped;

    NDISWAN_SET_THRESHOLD_EVENT RBP_ThresholdEvent;
};

typedef struct RasmanBapPacket RasmanBapPacket;

//
// List of Bap buffers
//
struct BapBuffersList {

    DWORD dwMaxBuffers;

    DWORD dwNumBuffers;

    RasmanBapPacket *pPacketList;

};

typedef struct BapBuffersList BapBuffersList;

//* DisconnectAction
//
struct SlipDisconnectAction {

    DWORD         DA_IPAddress ;

    BOOL          DA_fPrioritize;

    WCHAR         DA_Device [MAX_ARG_STRING_SIZE] ;

    WCHAR         DA_DNSAddress[17];

    WCHAR         DA_DNS2Address[17];

    WCHAR         DA_WINSAddress[17];

    WCHAR         DA_WINS2Address[17];

} ;

typedef struct SlipDisconnectAction SlipDisconnectAction ;

//
// Opaque user data structure.
//
struct UserData {

    LIST_ENTRY UD_ListEntry;    // list of all user data objects

    DWORD UD_Tag;               // object type

    DWORD UD_Length;            // length of UD_Data field

    BYTE UD_Data[1];            // variable length data

};

typedef struct UserData UserData;

enum EpProts {

    IpOut   = 0,

    NbfOut  = 1,

    NbfIn   = 2,

    MAX_EpProts
};

typedef enum EpProts EpProts;

// #define MAX_EpProts     3

struct EpInfo {

    UINT   EP_Available;

    UINT   EP_LowWatermark;

    UINT   EP_HighWatermark;
};

typedef struct EpInfo EpInfo;

struct EpInfoContext {

    UINT    EPC_EndPoints[MAX_EpProts];
};

typedef struct EpInfoContext EpInfoContext;


//
// Values for ConnectionBlock.CB_Flags
//
#define CONNECTION_VALID             0x00000001
#define CONNECTION_DEFAULT_CREDS     0x00000002
#define CONNECTION_DEFERRING_CLOSE   0x00000004
#define CONNECTION_DEFERRED_CLOSE    0x00000008


//
// RasApi32 connection structure.  This structure is
// created before a port is opened and is always
// associated with the first port in the connection.
//
struct ConnectionBlock {

    LIST_ENTRY CB_ListEntry;    // list of all connection blocks

    HCONN CB_Handle;            // unique connection id

    DWORD CB_Signaled;          // this connection has already been signaled

    LIST_ENTRY CB_UserData;     //  list of UserData structures

    pHandleList CB_NotifierList; // notification list for this connection

    struct PortControlBlock **CB_PortHandles; // array of ports in this connection

    DWORD CB_MaxPorts;          // maximum elements in CB_PortHandles array

    DWORD CB_Ports;             // number of ports currently in this connection

    DWORD CB_SubEntries;        // Number of subentries in this connection

    HANDLE CB_Process;          // handle of creating process

    DWORD  CB_RefCount;

    DWORD  CB_Flags;

    BOOL   CB_fAlive;

    BOOL   CB_fAutoClose;

    HCONN CB_ReferredEntry;

    DWORD CB_CustomCount;

    DWORD CB_dwPid;

    GUID  CB_GuidEntry;

    RAS_CONNECTIONPARAMS CB_ConnectionParams; // bandwidth, idle, redial
};

typedef struct ConnectionBlock ConnectionBlock;

struct ClientProcessBlock {

    LIST_ENTRY  CPB_ListEntry;

    // HANDLE      CPB_hProcess;

    DWORD       CPB_Pid;

};

typedef struct ClientProcessBlock ClientProcessBlock;

//* Bundle struct is used as a place holder for all links bundled together
//
struct Bundle {

    LIST_ENTRY      B_ListEntry; //  list of all bundle blocks

    HANDLE          B_NdisHandle; // ndiswan bundle handle

    DWORD           B_Count ;    //  number of channels bundled

    pList           B_Bindings ; //  bindings allocated to this bundle

    HBUNDLE         B_Handle ;   //  unique id for the bundle

    // BOOL            B_fAmb;

} ;

typedef struct Bundle Bundle ;


//* Port Control Block: Contains all information related to a port.
//
struct PortControlBlock {

    HPORT   PCB_PortHandle ;        // the HPORT used by everybody

    CHAR    PCB_Name [MAX_PORT_NAME] ;  // "COM1", "SVC1" etc.

    RASMAN_STATUS   PCB_PortStatus ;        // OPEN, CLOSED, UNKNOWN.

    RASMAN_STATE    PCB_ConnState ;     // CONNECTING, LISTENING, etc.

    RASMAN_USAGE    PCB_CurrentUsage ;      // CALL_IN, CALL_OUT, CALL_IN_OUT

    RASMAN_USAGE    PCB_ConfiguredUsage ;   // CALL_IN, CALL_OUT, CALL_IN_OUT

    RASMAN_USAGE    PCB_OpenedUsage;        // CALL_IN, CALL_OUT, CALL_ROUTER

    WORD    PCB_OpenInstances ;     // Number of times port is opened.

    pMediaCB    PCB_Media ;         // Pointer to Media structure

    CHAR    PCB_DeviceType [MAX_DEVICETYPE_NAME];// Device type attached
                             //  to port. "MODEM" etc.
    CHAR    PCB_DeviceName [MAX_DEVICE_NAME+1] ;   // Device name, "HAYES"..

    DWORD   PCB_LineDeviceId ;      // Valid for TAPI devices only

    DWORD   PCB_AddressId ;         // Valid for TAPI devices only

    HANDLE  PCB_PortIOHandle ;      // Handle returned by media dll for the port.

    HANDLE  PCB_PortFileHandle ;    // Handle to be used for ReadFile/WriteFile etc.
                                    // This handle MAY be different than PortIOHandle (above) as in case of unimodem.

    pList   PCB_DeviceList ;        // List of devices used for the port.

    pList   PCB_Bindings ;          // Protocols routed to.

    HANDLE  PCB_LinkHandle;         // Handle to link (ndiswan)

    HANDLE  PCB_BundleHandle;       // Handle to bundle (ndiswan)

    DWORD   PCB_LastError ;         // Error code of last async API

    RASMAN_DISCONNECT_REASON    PCB_DisconnectReason;   // USER_REQUESTED, etc.

    DWORD   PCB_OwnerPID ;          // PID of the current owner of port

    CHAR    PCB_DeviceTypeConnecting[MAX_DEVICETYPE_NAME] ; // Device type
                            // through which connecting
    CHAR    PCB_DeviceConnecting[MAX_DEVICE_NAME+1] ; // Device name through
                            // which connecting.
    pHandleList PCB_NotifierList ;// Used to notify to UI/server when
                        //  disconnection occurs.
    pHandleList PCB_BiplexNotifierList ;// Same as above - used for backing
                        //  up the disconnect notifier list

    HANDLE  PCB_BiplexAsyncOpNotifier ; // Used for backing up async op
                        //  notifier in biplex ports.

    PBYTE   PCB_BiplexUserStoredBlock ; // Stored for the user

    DWORD   PCB_BiplexUserStoredBlockSize ; // Stored for the user


    DWORD   PCB_BiplexOwnerPID ;        // Used for backing up first Owner's
                        // PID.
    pEndpointMappingBlock
        PCB_MacEndpointsBlock ;     // Points to the endpoint range
                        //  for the mac.

    WorkerElement PCB_AsyncWorkerElement ;  // Used for all async operations.

    OVERLAPPED  PCB_SendOverlapped ;        // Used for overlapped SEND operations

    DWORD   PCB_ConnectDuration ;       // Tells number of milliseconds since connection

    SendRcvBuffer  *PCB_PendingReceive;     // Pointer to the pending receive buffer.

    DWORD   PCB_BytesReceived;      // Bytes received in the last receive

    RasmanPacket    *PCB_RecvPackets;   // List of completed packets for this pcb
    RasmanPacket    *PCB_LastRecvPacket;    // Last packet on the list of completed packets for this pcb

    SlipDisconnectAction PCB_DisconnectAction ;// Action to be performed when disconnect happens

    PBYTE   PCB_UserStoredBlock ;       // Stored for the user

    DWORD   PCB_UserStoredBlockSize ;   // Stored for the user

    DWORD   PCB_LinkSpeed ;         // bps

    DWORD   PCB_Stats[MAX_STATISTICS] ; // Stored stats when disconnected

    DWORD   PCB_AdjustFactor[MAX_STATISTICS] ; // "zeroed" adjustment to stats

    DWORD   PCB_BundleAdjustFactor[MAX_STATISTICS] ; // "zeroed" adjustment to bundle stats

    Bundle  *PCB_Bundle ;           // Points to the bundle context.

    Bundle  *PCB_LastBundle ;           // Points to the last bundle this port was a part of

    ConnectionBlock *PCB_Connection;    // connection this port belongs

    //HCONN   PCB_PrevConnectionHandle; // previous connection this port belonged to

    BOOL    PCB_AutoClose;           // automatically close this port on disconnect

    LIST_ENTRY PCB_UserData;         // list of UserData structures

    DWORD   PCB_SubEntry;            // phonebook entry subentry index

    HANDLE  PCB_PppEvent ;

    PPP_MESSAGE * PCB_PppQHead ;

    PPP_MESSAGE * PCB_PppQTail ;

    HANDLE  PCB_IoCompletionPort;   // rasapi32 I/O completion port

    LPOVERLAPPED PCB_OvDrop;    // addr of rasapi32 OVEVT_DIAL_DROP overlapped structure

    LPOVERLAPPED PCB_OvStateChange; // addr of rasapi32 OVEVT_DIAL_STATECHANGE overlapped structure

    LPOVERLAPPED PCB_OvPpp;     // addr of rasapi32 OVEVT_DIAL_PPP overlapped structure

    LPOVERLAPPED PCB_OvLast;    // last event marker

    CHAR *PCB_pszPhonebookPath;  // Phonebook Path if this is in a dial out connection

    CHAR *PCB_pszEntryName;  // Entry name of the connection

    // CHAR *PCB_pszEntryNameCopy; // A copy of entry name stored by rasman

    CHAR *PCB_pszPhoneNumber;

    BOOL  PCB_RasmanReceiveFlags;

    DeviceInfo *PCB_pDeviceInfo;

    PRAS_CUSTOM_AUTH_DATA PCB_pCustomAuthData;

    ULONG PCB_ulDestAddr;

    BOOL PCB_fAmb;

    PRAS_CUSTOM_AUTH_DATA PCB_pCustomAuthUserData;

    BOOL PCB_fLogon;

    HANDLE PCB_hEventClientDisconnect;

    BOOL PCB_fFilterPresent;

    DWORD   PCB_LogonId;                 // LogonId of owning pid

    HANDLE  PCB_hIkeNegotiation;

    BOOL PCB_fPppStarted;

    BOOL PCB_fRedial;

} ;

typedef struct PortControlBlock PCB, *pPCB ;

//* Request Buffers:
//
struct RequestBuffer {

    DWORD		RB_PCBIndex ; // Index for the port in the PCB array

    ReqTypes    RB_Reqtype ;  // Request type:

    DWORD       RB_Dummy;     // This is not used but don't remove it otherwise
                              // admining down level servers will break.

    DWORD       RB_Done;

    LONGLONG    Alignment;      // Added to align the following structure
                                // on a quadword boundary

    BYTE        RB_Buffer [1] ; // Request specific data.

} ;

typedef struct RequestBuffer RequestBuffer ;


//* Request Buffer List: Currently contains only one buffer.
//
struct ReqBufferList {

	PRAS_OVERLAPPED	RBL_PRAS_OvRequestEvent;			// this event is used to notify rasman of
														// availability of a request.

    HANDLE			RBL_Mutex ;

    CHAR			RBL_MutexName [MAX_OBJECT_NAME] ;

    RequestBuffer	RBL_Buffer;
} ;

typedef struct ReqBufferList ReqBufferList ;

/*
struct RedialCallbackInfo
{
    CHAR szPhonebook[MAX_PATH];
    CHAR szEntry[MAX_ENTRYNAME_SIZE];
};

typedef struct RedialCallbackInfo RedialCallbackInfo;

*/

//
// Copied from rasip.h for RegisterSlip
//

struct RasIPLinkUpInfo {

#define CALLIN	0
#define CALLOUT 1

    ULONG	    I_Usage ;	// CALLIN, or CALLOUT

    ULONG	    I_IPAddress ; // For client - the client's IP Address, for server
				  // the client's IP address.

    ULONG	    I_NetbiosFilter ; // 1 = ON, 0 - OFF.

} ;

typedef struct RasIPLinkUpInfo RasIPLinkUpInfo ;

//* DLLEntryPoints
//
struct DLLEntryPoints {

    LPTSTR  name ;

    WORD    id ;

} ;

typedef struct DLLEntryPoints MediaDLLEntryPoints, DeviceDLLEntryPoints;


// Structures used for reading in media info
//
struct MediaInfoBuffer {

    CHAR   MediaDLLName[MAX_MEDIA_NAME] ;
} ;

typedef struct MediaInfoBuffer MediaInfoBuffer ;

struct MediaEnumBuffer {

    WORD        NumberOfMedias ;

    MediaInfoBuffer MediaInfo[] ;
} ;

typedef struct MediaEnumBuffer MediaEnumBuffer ;


// Function prototype for Timer called function
//
typedef VOID (* TIMERFUNC) (pPCB, PVOID) ;



//* REQTYPECAST: this union is used to cast the generic request buffer for
//  passing information between the clients and the request thread.
//
union REQTYPECAST
{

    struct PortOpen
    {
	    DWORD   retcode;
        HANDLE  notifier;
	    HPORT   porthandle ;
	    DWORD   PID ;
	    DWORD   open ;
	    CHAR    portname [MAX_PORT_NAME] ;
	    CHAR    userkey [MAX_USERKEY_SIZE] ;
	    CHAR    identifier[MAX_IDENTIFIER_SIZE] ;
	
    } PortOpen ;

    struct PortDisconnect
    {
	    HANDLE  handle ;
	    DWORD   pid ;
	
    } PortDisconnect ;

    struct Enum
    {
	    DWORD   retcode ;
	    DWORD   size ;
	    DWORD   entries ;
	    BYTE    buffer [1] ;
	
    } Enum ;

    struct GetInfo
    {
	    DWORD   retcode ;
	    DWORD   size ;
	    BYTE    buffer [1] ;
	
    } GetInfo ;

    struct DeviceEnum
    {
	    DWORD   dwsize;
	    CHAR    devicetype [MAX_DEVICETYPE_NAME] ;
	
    } DeviceEnum ;

    struct DeviceSetInfo
    {
	    CHAR    			devicetype [MAX_DEVICETYPE_NAME] ;
	    CHAR    			devicename [MAX_DEVICE_NAME] ;
	    RASMAN_DEVICEINFO   info ;
	
    } DeviceSetInfo ;

    struct DeviceGetInfo
    {
	    DWORD   dwSize;
	    CHAR    devicetype [MAX_DEVICETYPE_NAME] ;
	    CHAR    devicename [MAX_DEVICE_NAME+1] ;
	    BYTE    buffer [1] ;
	
    } DeviceGetInfo ;

    struct PortReceive
    {
	    DWORD           size ;
	    DWORD           timeout ;
	    HANDLE  		handle ;
	    DWORD   		pid ;
	    SendRcvBuffer   *buffer ;
	
    } PortReceive ;

    struct PortReceiveEx
    {
	    DWORD           retcode;
	    SendRcvBuffer   buffer;
	    DWORD           size;
	
    } PortReceiveEx;

    struct PortListen
    {
	    DWORD   timeout ;
	    HANDLE  handle ;
	    DWORD   pid ;
	
    } PortListen ;

    struct PortClose
    {
	    DWORD   pid ;
	    DWORD   close ;
	
    } PortClose ;

    struct PortSend
    {
	    SendRcvBuffer buffer;
	    DWORD         size ;
	
    } PortSend ;

    struct PortSetInfo
    {
        RASMAN_PORTINFO info ;

    } PortSetInfo ;

    struct PortGetStatistics
    {
        DWORD           retcode ;
        RAS_STATISTICS  statbuffer ;

    } PortGetStatistics ;

    struct DeviceConnect
    {
        CHAR    devicetype [MAX_DEVICETYPE_NAME] ;
        CHAR    devicename [MAX_DEVICE_NAME + 1] ;
        DWORD   timeout ;
        HANDLE  handle ;
        DWORD   pid ;

    } DeviceConnect ;

    struct AllocateRoute
    {
        RAS_PROTOCOLTYPE type ;
        BOOL             wrknet ;

    } AllocateRoute ;

    struct ActivateRoute
    {
        RAS_PROTOCOLTYPE     type ;
        PROTOCOL_CONFIG_INFO config ;

    } ActivateRoute;

    struct ActivateRouteEx
    {
        RAS_PROTOCOLTYPE        type ;
        DWORD                   framesize ;
        PROTOCOL_CONFIG_INFO    config ;

    } ActivateRouteEx;

    struct DeAllocateRoute
    {
        HBUNDLE            hbundle;
        RAS_PROTOCOLTYPE   type ;

    } DeAllocateRoute ;

    struct Route
    {
        DWORD            retcode ;
        RASMAN_ROUTEINFO info ;

    } Route ;

    struct CompressionSetInfo
    {
        DWORD                   retcode ;
        DWORD                   dwAlign;
        RAS_COMPRESSION_INFO    send ;
        RAS_COMPRESSION_INFO    recv ;

    } CompressionSetInfo ;

    struct CompressionGetInfo
    {
        DWORD                   retcode ;
        DWORD                   dwAlign;
        RAS_COMPRESSION_INFO    send ;
        RAS_COMPRESSION_INFO    recv ;

    } CompressionGetInfo ;

    struct Info
    {
        DWORD         retcode ;
        RASMAN_INFO   info ;

    } Info ;

    struct GetCredentials
    {
        DWORD         retcode;
        BYTE          Challenge [MAX_CHALLENGE_SIZE] ;
        LUID          LogonId ;
        WCHAR         UserName [MAX_USERNAME_SIZE] ;
        BYTE          CSCResponse [MAX_RESPONSE_SIZE] ;
        BYTE          CICResponse [MAX_RESPONSE_SIZE] ;
        BYTE          LMSessionKey [MAX_SESSIONKEY_SIZE] ;
    	BYTE          UserSessionKey [MAX_USERSESSIONKEY_SIZE] ;
    	
    } GetCredentials ;

    struct SetCachedCredentials
    {
        DWORD         retcode;
        CHAR          Account[ MAX_USERNAME_SIZE + 1 ];
        CHAR          Domain[ MAX_DOMAIN_SIZE + 1 ];
        CHAR          NewPassword[ MAX_PASSWORD_SIZE + 1 ];

    } SetCachedCredentials;

    struct ReqNotification
    {
        HANDLE        handle ;
        DWORD         pid ;

    } ReqNotification ;

    struct EnumLanNets
    {
        DWORD         count ;
        UCHAR         lanas[MAX_LAN_NETS] ;

    } EnumLanNets ;

    struct InfoEx
    {
        DWORD         retcode ;
        DWORD         pid;
        DWORD         count;
        RASMAN_INFO   info ;

    } InfoEx ;

    struct EnumProtocols
    {
        DWORD         retcode ;
        RAS_PROTOCOLS protocols ;
        DWORD         count ;

    } EnumProtocols ;

    struct SetFraming
    {
        DWORD         Sendbits ;
        DWORD         Recvbits ;
        DWORD         SendbitMask ;
        DWORD         RecvbitMask ;

    } SetFraming ;

    struct RegisterSlip
    {
        DWORD         ipaddr ;
        DWORD         dwFrameSize;
        BOOL          priority ;
        WCHAR         szDNSAddress[17];
        WCHAR         szDNS2Address[17];
        WCHAR         szWINSAddress[17];
        WCHAR         szWINS2Address[17];

    } RegisterSlip ;

    struct OldUserData
    {
        DWORD         retcode ;
        DWORD         size ;
        BYTE          data[1] ;

    } OldUserData ;

    struct FramingInfo
    {
        DWORD             retcode ;
        RAS_FRAMING_INFO  info ;

    } FramingInfo ;

    struct ProtocolComp
    {
        DWORD                   retcode;
        RAS_PROTOCOLTYPE        type;
        RAS_PROTOCOLCOMPRESSION send;
        RAS_PROTOCOLCOMPRESSION recv;

    } ProtocolComp ;

    struct FramingCapabilities
    {
        DWORD                     retcode ;
        RAS_FRAMING_CAPABILITIES  caps ;

    } FramingCapabilities ;

    struct PortBundle
    {
        HPORT           porttobundle ;

    } PortBundle ;

    struct GetBundledPort
    {
        DWORD       retcode ;
        HPORT       port ;

    } GetBundledPort ;

    struct PortGetBundle
    {
        DWORD       retcode ;
        HBUNDLE     bundle ;

    } PortGetBundle ;

    struct BundleGetPort
    {
        DWORD       retcode;
        HBUNDLE     bundle ;
        HPORT       port ;

    } BundleGetPort ;

    struct AttachInfo
    {

        DWORD   dwPid;
        BOOL    fAttach;

    } AttachInfo;

    struct DialParams
    {
        DWORD           retcode;
        DWORD           dwUID;
        DWORD           dwMask;
        BOOL            fDelete;
        DWORD           dwPid;
        RAS_DIALPARAMS  params;
        WCHAR           sid[1];

    } DialParams;

    struct Connection
    {
        DWORD   retcode;
        DWORD   pid;
        HCONN   conn;
        DWORD   dwEntryAlreadyConnected;
        DWORD   dwSubEntries;
        DWORD   dwDialMode;
        GUID    guidEntry;
        CHAR    szPhonebookPath[MAX_PATH];
        CHAR    szEntryName[MAX_ENTRYNAME_SIZE];
        CHAR    szRefPbkPath[MAX_PATH];
        CHAR    szRefEntryName[MAX_ENTRYNAME_SIZE];
        BYTE    data[1];

    } Connection;

    struct AddConnectionPort
    {
        DWORD   retcode;
        HCONN   conn;
        DWORD   dwSubEntry;

    } AddConnectionPort;

    struct EnumConnectionPorts
    {
        DWORD   retcode;
        HCONN   conn;
        DWORD   size;
        DWORD   entries;
        BYTE    buffer[1];

    } EnumConnectionPorts;

    struct ConnectionParams
    {
        DWORD   retcode;
        HCONN   conn;
        RAS_CONNECTIONPARAMS params;

    } ConnectionParams;

    struct ConnectionUserData
    {
        DWORD   retcode;
        HCONN   conn;
        DWORD   dwTag;
        DWORD   dwcb;
        BYTE    data[1];

    } ConnectionUserData;

    struct PortUserData
    {
        DWORD   retcode;
        DWORD   dwTag;
        DWORD   dwcb;
        BYTE    data[1];

    } PortUserData;

    PPPE_MESSAGE PppEMsg;

    PPP_MESSAGE PppMsg;

    struct AddNotification
    {
        DWORD   retcode;
        DWORD   pid;
        BOOL    fAny;
        HCONN   hconn;
        HANDLE  hevent;
        DWORD   dwfFlags;

    } AddNotification;

    struct SignalConnection
    {
        DWORD   retcode;
        HCONN   hconn;

    } SignalConnection;

    struct SetDevConfig
    {
        DWORD  size ;
        CHAR   devicetype [MAX_DEVICETYPE_NAME] ;
        BYTE   config[1] ;

    } SetDevConfig;

    struct GetDevConfig
    {
        DWORD  retcode;
        CHAR   devicetype [MAX_DEVICETYPE_NAME] ;
        DWORD  size ;
        BYTE   config[1] ;

    } GetDevConfig;

    struct GetTimeSinceLastActivity
    {
        DWORD dwTimeSinceLastActivity;
        DWORD dwRetCode;

    } GetTimeSinceLastActivity;

    struct CloseProcessPortsInfo
    {
        DWORD pid;

    } CloseProcessPortsInfo;

    struct PnPControlInfo
    {
        DWORD dwOp;

    } PnPControlInfo;

    struct SetIoCompletionPortInfo
    {
        HANDLE          hIoCompletionPort;
        DWORD           pid;
        LPOVERLAPPED    lpOvDrop;
        LPOVERLAPPED    lpOvStateChange;
        LPOVERLAPPED    lpOvPpp;
        LPOVERLAPPED    lpOvLast;

    } SetIoCompletionPortInfo;

    struct SetRouterUsageInfo
    {
        BOOL fRouter;

    } SetRouterUsageInfo;

    struct PnPNotif
    {
        PVOID   pvNotifier;
        DWORD   dwFlags;
        DWORD   pid;
        HANDLE  hThreadHandle;
        BOOL    fRegister;

    } PnPNotif;

    //
    // Generic cast is used for all requests
    // that return only the retcode:
    //
    struct Generic
    {
        DWORD   retcode ;

    } Generic ;

    struct SetRasdialInfo
    {
        CHAR    szPhonebookPath [ MAX_PATH ];
        CHAR    szEntryName [ MAX_ENTRYNAME_SIZE ];
        CHAR    szPhoneNumber[ RAS_MaxPhoneNumber ];
        RAS_CUSTOM_AUTH_DATA rcad;

    } SetRasdialInfo;

    struct GetAttachedCount
    {
        DWORD retcode;
        DWORD dwAttachedCount;

    } GetAttachedCount;

    struct NotifyConfigChanged
    {
        RAS_DEVICE_INFO Info;

    } NotifyConfigChanged;

    struct SetBapPolicy
    {
        HCONN hConn;
        DWORD dwLowThreshold;
        DWORD dwLowSamplePeriod;
        DWORD dwHighThreshold;
        DWORD dwHighSamplePeriod;

    } SetBapPolicy;

    struct PppStarted
    {
        HPORT hPort;

    } PppStarted;

    struct RefConnection
    {
        DWORD   retcode;
        HCONN   hConn;
        BOOL    fAddref;
        DWORD   dwRef;

    } RefConnection;

    struct SetEapInfo
    {
        DWORD   retcode;
        DWORD   dwContextId;
        DWORD   dwSizeofEapUIData;
        BYTE    data[1];
    } SetEapInfo;

    struct GetEapInfo
    {
        DWORD   retcode;
        HCONN   hConn;
        DWORD   dwSubEntry;
        DWORD   dwContextId;
        DWORD   dwEapTypeId;
        DWORD   dwSizeofEapUIData;
        BYTE    data[1];
    } GetEapInfo;

    struct DeviceConfigInfo
    {
        DWORD           retcode;
        DWORD           dwVersion;
        DWORD           cbBuffer;
        DWORD           cEntries;
        BYTE            abdata[1];
    } DeviceConfigInfo;

    struct FindRefConnection
    {
        DWORD           retcode;
        HCONN           hConn;
        HCONN           hRefConn;
    } FindRefConnection;

    struct PortOpenEx
    {
        DWORD           retcode;
        DWORD           pid;
        DWORD           dwFlags;
        HPORT           hport;
        DWORD           dwOpen;
        HANDLE          hnotifier;
        DWORD           dwDeviceLineCounter;
        CHAR            szDeviceName[MAX_DEVICE_NAME + 1];
    } PortOpenEx;

    struct GetStats
    {
        DWORD           retcode;
        HCONN           hConn;
        DWORD           dwSubEntry;
        BYTE            abStats[1];
    } GetStats;

    struct GetHportFromConnection
    {
        DWORD           retcode;
        HCONN           hConn;
        HPORT           hPort;
    } GetHportFromConnection;

    struct ReferenceCustomCount
    {
        DWORD           retcode;
        BOOL            fAddRef;
        HCONN           hConn;
        DWORD           dwCount;
        CHAR            szEntryName[MAX_ENTRYNAME_SIZE + 1];
        CHAR            szPhonebookPath[MAX_PATH + 1];
    } ReferenceCustomCount;

    struct HconnFromEntry
    {
        DWORD           retcode;
        HCONN           hConn;
        CHAR            szEntryName[MAX_ENTRYNAME_SIZE + 1];
        CHAR            szPhonebookPath[MAX_PATH + 1];
    } HconnFromEntry;

    struct GetConnectInfo
    {
        DWORD                retcode;
        DWORD                dwSize;
        RASTAPI_CONNECT_INFO rci;
    } GetConnectInfo;

    struct GetDeviceName
    {
        DWORD            retcode;
        RASDEVICETYPE    eDeviceType;
        CHAR             szDeviceName[MAX_DEVICE_NAME + 1];
    } GetDeviceName;

    struct GetDeviceNameW
    {
        DWORD            retcode;
        RASDEVICETYPE    eDeviceType;
        WCHAR            szDeviceName[MAX_DEVICE_NAME + 1];
    } GetDeviceNameW;

    struct GetSetCalledId
    {
        DWORD               retcode;
        BOOL                fWrite;
        DWORD               dwSize;
        GUID                guidDevice;
        RAS_DEVICE_INFO     rdi;
        RAS_CALLEDID_INFO   rciInfo;

    } GetSetCalledId;

    struct EnableIpSec
    {
        DWORD           retcode;
        BOOL            fEnable;
        BOOL            fServer;
        RAS_L2TP_ENCRYPTION eEncryption;
    } EnableIpSec;

    struct IsIpSecEnabled
    {
        DWORD           retcode;
        BOOL            fIsIpSecEnabled;
    } IsIpSecEnabled;

    struct SetEapLogonInfo
    {
        DWORD           retcode;
        BOOL            fLogon;
        DWORD           dwSizeofEapData;
        BYTE            abEapData[1];
    } SetEapLogonInfo;

    struct SendNotification
    {
        DWORD           retcode;
        RASEVENT        RasEvent;
    } SendNotification;

    struct GetNdiswanDriverCaps
    {
        DWORD                   retcode;
        RAS_NDISWAN_DRIVER_INFO NdiswanDriverInfo;
    } GetNdiswanDriverCaps;

    struct GetBandwidthUtilization
    {
        DWORD                           retcode;
        RAS_GET_BANDWIDTH_UTILIZATION   BandwidthUtilization;
    } GetBandwidthUtilization;

    struct RegisterRedialCallback
    {
        DWORD       retcode;
        VOID        *pvCallback;
    } RegisterRedialCallback;

    struct GetProtocolInfo
    {
        DWORD                    retcode;
        RASMAN_GET_PROTOCOL_INFO Info;
    } GetProtocolInfo;

    struct GetCustomScriptDll
    {
        DWORD   retcode;
        CHAR    szCustomScript[MAX_PATH+1];
    } GetCustomScriptDll;

    struct IsTrusted
    {
        DWORD retcode;
        BOOL  fTrusted;
        WCHAR wszCustomDll[MAX_PATH+1];
        
    } IsTrusted;

    struct DoIke
    {
        DWORD   retcode;
        HANDLE  hEvent;
        DWORD   pid;
        CHAR    szEvent[20];
    } DoIke;

    struct QueryIkeStatus
    {
        DWORD   retcode;
        DWORD   dwStatus;
    } QueryIkeStatus;

    struct SetRasCommSettings
    {
        DWORD   retcode;
        RASMANCOMMSETTINGS Settings;
    } SetRasCommSettings;

    struct EnableRasAudio
    {   
        DWORD retcode;
        BOOL  fEnable;
    } EnableRasAudio;

    struct GetSetKey
    {
        DWORD retcode;
        DWORD dwPid;
        GUID  guid;
        DWORD dwMask;
        DWORD cbkey;
        BYTE  data[1];
    } GetSetKey;

    struct AddressDisable
    {
        DWORD retcode;
        BOOL  fDisable;
        WCHAR szAddress[1024+1];
    } AddressDisable;

    struct GetDevConfigEx
    {
        DWORD  retcode;
        CHAR   devicetype [MAX_DEVICETYPE_NAME] ;
        DWORD  size ;
        BYTE   config[1] ;

    } GetDevConfigEx;

    struct SendCreds
    {
        DWORD retcode;
        DWORD pid;
        CHAR   controlchar;
    } SendCreds;
    
    struct GetUDeviceName
    {
        DWORD            retcode;
        WCHAR            wszDeviceName[MAX_DEVICE_NAME + 1];
    } GetUDeviceName;
    

} ;

typedef union REQTYPECAST REQTYPECAST;


//
// This structure defines the current
// version of the shared mapped buffers.
// The version changes when the size of
// the mapped buffers changes due to
// device configuration PnP events.
//
struct ReqBufferIndex {
    DWORD       RBI_Version;
};

typedef struct ReqBufferIndex ReqBufferIndex;

//$$
//* This is the structure imposed on the file mapped shared memory
//
struct ReqBufferSharedSpace {

    DWORD         		Version;   						// must match RequestBufferIndex.RBI_Version

    WORD          		AttachedCount ;   				// This count is always shared so that
                    									// it can be incremented and decremented
                    									// by all processes attaching/detaching

    WORD          		MaxPorts ;    					// The max number of ports.

	PRAS_OVERLAPPED		PRAS_OvCloseEvent;    			// use this event to post shut down event
														// to rasman.

    ReqBufferList     	ReqBuffers;   					// Always fixed size.
} ;

typedef struct ReqBufferSharedSpace ReqBufferSharedSpace ;





//* Used to store the transport information
//
struct TransportInfo {

    DWORD   TI_Lana ;
    DWORD   TI_Wrknet ;
    CHAR    TI_Route[MAX_ROUTE_SIZE] ;
    CHAR    TI_XportName [MAX_XPORT_NAME] ;
} ;

typedef struct TransportInfo TransportInfo, *pTransportInfo ;

typedef struct _ipsec_srv_node {

    GUID  gMMPolicyID;
    GUID  gQMPolicyID;
    GUID  gMMAuthID;
    GUID  gTxFilterID;
    GUID  gMMFilterID;
    DWORD dwRefCount;
    DWORD dwIpAddress;
    LPWSTR pszQMPolicyName;
    LPWSTR pszMMPolicyName;
    HANDLE hTxFilter;
    HANDLE hMMFilter;
    RAS_L2TP_ENCRYPTION eEncryption;
    struct _ipsec_srv_node * pNext;

}IPSEC_SRV_NODE, * PIPSEC_SRV_NODE;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\common\inc\logtrdef.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\logtrdefs.c

Abstract:
    RASMAN defines for tracing and logging

Revision History:

    Gurdeep Singh Pall		8/16/96  Created

--*/

#ifndef __LOGTRDEF_H__
#define __LOGTRDEF_H__

//
// constants and macros used for tracing
//

#define RASMAN_TRACE_ANY	      ((DWORD)0xFFFF0000 | TRACE_USE_MASK | TRACE_USE_MSEC)
#define RASMAN_TRACE_ERR	      ((DWORD)0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC)
#define RASMAN_TRACE_CONNECTION	      ((DWORD)0x00020000 | TRACE_USE_MASK | TRACE_USE_MSEC)
#define RASMAN_TRACE_OPENCLOSE	      ((DWORD)0x00040000 | TRACE_USE_MASK | TRACE_USE_MSEC)
//#define RASMAN_TRACE_ROUTE	      ((DWORD)0x00080000 | TRACE_USE_MASK | TRACE_USE_MSEC)
//#define RASMAN_TRACE_MIB	      ((DWORD)0x00100000 | TRACE_USE_MASK | TRACE_USE_MSEC)
//#define RASMAN_TRACE_GLOBAL	      ((DWORD)0x00200000 | TRACE_USE_MASK | TRACE_USE_MSEC)
//#define RASMAN_TRACE_DEMAND	      ((DWORD)0x00400000 | TRACE_USE_MASK | TRACE_USE_MSEC)
//#define RASMAN_TRACE_RTRDISC	      ((DWORD)0x00800000 | TRACE_USE_MASK | TRACE_USE_MSEC)
#define RASMAN_TRACE_LOCK	      ((DWORD)0x01000000 | TRACE_USE_MASK | TRACE_USE_MSEC)

#define TRACEID 	TraceHandle

#define Trace0(l,a)             \
	    TracePrintfEx(TRACEID, RASMAN_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
	    TracePrintfEx(TRACEID, RASMAN_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
	    TracePrintfEx(TRACEID, RASMAN_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
	    TracePrintfEx(TRACEID, RASMAN_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
	    TracePrintfEx(TRACEID, RASMAN_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
	    TracePrintfEx(TRACEID, RASMAN_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g) \
	    TracePrintfEx(TRACEID, RASMAN_TRACE_ ## l, a, b, c, d, e, f, g)
#define Trace7(l,a,b,c,d,e,f,g,h) \
	    TracePrintfEx(TRACEID, RASMAN_TRACE_ ## l, a, b, c, d, e, f, g, h)

#ifdef	  RASMAN_DEBUG

#define TraceEnter(X)	TracePrintfEx(TRACEID, RASMAN_TRACE_ENTER, "Entered: "X)
#define TraceLeave(X)	TracePrintfEx(TRACEID, RASMAN_TRACE_ENTER, "Leaving: "X"\n")

#else  // RASMAN_DEBUG

#define TraceEnter(X)
#define TraceLeave(X)

#endif // RASMAN_DEBUG


#endif // __LOGTRDEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\dll\dlparams.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-95
//
//
//  Revision History
//
//
//  12/11/95    Anthony Discolo     created
//
//
//  Description: Constants for storing and retrieving user Lsa secret
//               dial parameters.
//
//****************************************************************************


#define RASMXS_DYNAMIC_LINK


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\dll\dll.c ===
/*++

Copyright(c) 1996 Microsoft Corporation

MODULE NAME
    dll.c

ABSTRACT
    DLL initialization code 

AUTHOR
    Anthony Discolo (adiscolo) 12-Sep-1996

REVISION HISTORY

--*/

#ifndef UNICODE
#define UNICODE
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include "rasrpc.h"

#include <nouiutil.h>
#include "loaddlls.h"

#include "media.h"
#include "wanpub.h"
#include "defs.h"
#include "structs.h"
#include "protos.h"

RPC_BINDING_HANDLE g_hBinding = NULL;

DWORD
RasRPCBind(
    IN  LPWSTR  lpwsServerName,
    OUT HANDLE* phServer
);

DWORD APIENTRY
RasRPCBind(
    IN  LPWSTR  lpwszServerName,
    OUT HANDLE* phServer
)
{
    RPC_STATUS RpcStatus;
    LPWSTR     lpwszStringBinding;


    RpcStatus = RpcStringBindingCompose(
                    NULL,
                    TEXT("ncacn_np"),
                    lpwszServerName,
                    TEXT("\\PIPE\\ROUTER"),     
                    TEXT("Security=Impersonation Static True"),
                    &lpwszStringBinding);

    if ( RpcStatus != RPC_S_OK )
    {
        return( I_RpcMapWin32Status( RpcStatus ) );
    }

    RpcStatus = RpcBindingFromStringBinding(
                    lpwszStringBinding,
                    (handle_t *)phServer );

    RpcStringFree( &lpwszStringBinding );

    if ( RpcStatus != RPC_S_OK )
    {
        return( I_RpcMapWin32Status( RpcStatus ) );
    }

    return( NO_ERROR );
}


DWORD APIENTRY
RasRpcConnect(
    LPWSTR lpwszServer,
    HANDLE* phServer
    )
{
    DWORD   retcode = 0;
    TCHAR   *pszComputerName;
    WCHAR   wszComputerName [ MAX_COMPUTERNAME_LENGTH + 1 ] = {0};
    DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    
    if (    lpwszServer == NULL
        &&  g_hBinding == NULL)
    {
        pszComputerName = wszComputerName;
        
        //
        // By default connect to the local server
        //
        if ( 0 == GetComputerName ( wszComputerName, &dwSize ) )
        {
            return GetLastError();
        }

        //
        // convert \\MACHINENAME to MACHINENAME
        //
        if (    wszComputerName [0] == TEXT('\\')
            &&  wszComputerName [1] == TEXT('\\' ))
            pszComputerName += 2;
    }


    //
    //  Bind with the server if we are not bound already.
    //  By default we bind to the local server
    //
    if (    lpwszServer != NULL
        ||  g_hBinding == NULL )
    {        
        RasmanOutputDebug ( "RASMAN: Binding to the server\n");
        retcode = RasRPCBind( ( lpwszServer 
                                ? lpwszServer 
                                : wszComputerName ) , 
                                &g_hBinding ) ;
    }                                

    //
    // Set the bind handle for the caller
    //
    if ( phServer )
        *phServer = g_hBinding;

    return retcode;
}


DWORD APIENTRY
RasRpcDisconnect(
    HANDLE* phServer
    )
{
    //
    // Release the binding resources.
    //

    RasmanOutputDebug ("RASMAN: Disconnecting From Server\n");

    (void)RpcBindingFree(phServer);

    g_hBinding = NULL;

    return NO_ERROR;
}


DWORD APIENTRY
RemoteSubmitRequest ( HANDLE hConnection,
                      PBYTE pBuffer,
                      DWORD dwSizeOfBuffer )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    RPC_BINDING_HANDLE hServer;

    //
    // NULL hConnection means the request is
    // for a local server. Better have a 
    // hBinding with us in the global in this
    // case.
    //
    if(NULL == hConnection)
    {
        ASSERT(NULL != g_hBinding);
        
        hServer = g_hBinding;
    }
    else
    {
        ASSERT(NULL != ((RAS_RPC *)hConnection)->hRpcBinding);
        
        hServer = ((RAS_RPC *) hConnection)->hRpcBinding;
    }
    
    RpcTryExcept
    {
        dwStatus = RasRpcSubmitRequest( hServer,
                                        pBuffer,
                                        dwSizeOfBuffer );
    }
    RpcExcept(I_RpcExceptionFilter(dwStatus = RpcExceptionCode()))
    {
        
    }
    RpcEndExcept

    return dwStatus;
}

#if 0

DWORD APIENTRY
RasRpcLoadDll(LPTSTR lpszServer)

{
    return LoadRasRpcDll(lpszServer);
}

#endif

DWORD APIENTRY
RasRpcConnectServer(LPTSTR lpszServer,
                    HANDLE *pHConnection)
{
    return InitializeConnection(lpszServer,
                                pHConnection);
}

DWORD APIENTRY
RasRpcDisconnectServer(HANDLE hConnection)
{
    UninitializeConnection(hConnection);

    return NO_ERROR;
}

DWORD
RasRpcUnloadDll()
{
    return UnloadRasRpcDll();
}

UINT APIENTRY
RasRpcRemoteGetSystemDirectory(
    HANDLE hConnection,
    LPTSTR lpBuffer, 
    UINT uSize
    )
{
	return g_pGetSystemDirectory(
	                hConnection,
	                lpBuffer, 
	                uSize);
}

DWORD APIENTRY
RasRpcRemoteRasDeleteEntry(
    HANDLE hConnection,
    LPTSTR lpszPhonebook,
    LPTSTR lpszEntry 
    )
{

    DWORD dwError = ERROR_SUCCESS;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if(NULL == hConnection)
    {
    
	    dwError = g_pRasDeleteEntry(lpszPhonebook,
                                    lpszEntry);
    }	                         
    else
    {
        //
        // Remote server case
        //
        dwError = RemoteRasDeleteEntry(hConnection,
                                       lpszPhonebook,
                                       lpszEntry);
    }

    return dwError;
}

DWORD APIENTRY
RasRpcRemoteGetUserPreferences(
    HANDLE hConnection,
	PBUSER * pPBUser,
	DWORD dwMode
	)
{
	return g_pGetUserPreferences(hConnection,
	                             pPBUser,
	                             dwMode);
}

DWORD APIENTRY
RasRpcRemoteSetUserPreferences(
    HANDLE hConnection,
	PBUSER * pPBUser,
	DWORD dwMode
	)
{
	return g_pSetUserPreferences(hConnection,
	                             pPBUser,
	                             dwMode);
}

/*
DWORD APIENTRY
RemoteRasDeviceEnum(
    PCHAR pszDeviceType,
    PBYTE lpDevices,
    PWORD pwcbDevices,
    PWORD pwcDevices
    )
{
    DWORD dwStatus;

    ASSERT(g_hBinding);
    RpcTryExcept
    {
        dwStatus = RasRpcDeviceEnum(g_hBinding,
                                    pszDeviceType,
                                    lpDevices,
                                    pwcbDevices, 
                                    pwcDevices);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
}


DWORD APIENTRY
RemoteRasGetDevConfig(
    HPORT hport,
    PCHAR pszDeviceType,
    PBYTE lpConfig,
    LPDWORD lpcbConfig
    )
{
    DWORD dwStatus;

    ASSERT(g_hBinding);
    RpcTryExcept
    {
        dwStatus = RasRpcGetDevConfig(g_hBinding, 
                                      hport, 
                                      pszDeviceType, 
                                      lpConfig, 
                                      lpcbConfig);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
} 

DWORD APIENTRY
RemoteRasPortEnum(
    PBYTE lpPorts,
    PWORD pwcbPorts,
    PWORD pwcPorts
    )
{
    DWORD dwStatus;

    ASSERT(g_hBinding);
    RpcTryExcept
    {
        dwStatus = RasRpcPortEnum(g_hBinding,
                                  lpPorts, 
                                  pwcbPorts,
                                  pwcPorts);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwStatus = RpcExceptionCode();
    }
    RpcEndExcept

    return dwStatus;
} 

DWORD
RemoteRasPortGetInfo(
	HPORT porthandle,
	PBYTE buffer,
	PWORD pSize)
{
	DWORD	dwStatus;
	
	RpcTryExcept
	{
		dwStatus = RasRpcPortGetInfo(g_hBinding,
		                             porthandle,
		                             buffer,
		                             pSize);
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		dwStatus = RpcExceptionCode();
	}
	RpcEndExcept

	return dwStatus;
}  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\dll\common.c ===
//****************************************************************************
//
//		       Microsoft NT Remote Access Service
//
//		       Copyright 1992-93
//
//
//  Revision History
//
//
//  6/2/92	Gurdeep Singh Pall	Created
//
//
//  Description: This file contains misellaneous functions used by rasman.
//
//****************************************************************************


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <raserror.h>
#include <stdarg.h>
#include <media.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include "string.h"
#include <mprlog.h>
#include <rtutils.h>
#include "logtrdef.h"
#include "rpc.h"
#include "rasrpc.h"
#include "winsock2.h"
#include "svcguid.h"

#define QUERYBUFSIZE    1024

extern RPC_BINDING_HANDLE g_hBinding;

//
// commonly used handles are cached in the process's
// global memory
//

CRITICAL_SECTION g_csRequestBuffer;

/*++

Routine Description

    Gets a free request buffer from the pool of buffers.
    If there are no buffers available it blocks for one.
    This is acceptable since the Requestor thread will be
    releasing buffers fairly quickly - also, if this thread
    does not block here it will be blocking for the Requestor
    thread to complete the request anyway. Note: Before returning
    it also ensures that this process has a handle to the
    event used to signal completion of request.

Arguments    

Returns Value

    Nothing
 
--*/

RequestBuffer*
GetRequestBuffer ()
{
    DWORD dwError;

    //
    // check to see if we are bound to the rpc server
    // bind to the server if we aren't
    //
    if (    NULL == g_hBinding 
        &&  NULL == g_fnServiceRequest)
    {
        if (NO_ERROR != (dwError = RasRpcConnect(NULL, NULL)))
        {
            RasmanOutputDebug ("Failed to connect to local server. %d\n",
                      dwError );

            g_pRequestBuffer = NULL;
            
            goto done;
        }
    }

    EnterCriticalSection( &g_csRequestBuffer );

    if ( NULL == g_pRequestBuffer )
    {
        g_pRequestBuffer = LocalAlloc (
                                LPTR,
                                sizeof (RequestBuffer)
                                + REQUEST_BUFFER_SIZE);
    }

    if (NULL == g_pRequestBuffer)
    {
        LeaveCriticalSection( &g_csRequestBuffer );
    }

done:            
    return g_pRequestBuffer;
}


/*++

Routine Description

    Frees the request buffer, and, closes the wait event
    handle which was duplicated for the calling process
    in the GetRequestBuffer() API.

Arguments

Return Value
    Nothing
 
--*/

VOID
FreeRequestBuffer (RequestBuffer *buffer)
{
    LeaveCriticalSection ( &g_csRequestBuffer );

    (void *) buffer;
    return;
}


/*++

Routine Description

    Opens a handle for object owned by the rasman process,
    for the current process.

Arguments

Return Value

    Duplicated handle.

--*/

HANDLE
OpenNamedEventHandle (CHAR* sourceobject)
{
    HANDLE  duphandle ;

    duphandle = OpenEvent (EVENT_ALL_ACCESS,
                           FALSE,
                           sourceobject);

    if (duphandle == NULL) 
    {
        GetLastError();
    	DbgUserBreakPoint() ;
    }
    
    return duphandle ;
}


/*++

Routine Description

    Opens a handle for object owned by the rasman process,
    for the current process.

Arguments    

Return Value
    Duplicated handle.

--*/

HANDLE
OpenNamedMutexHandle (CHAR* sourceobject)
{
    HANDLE  duphandle ;

    duphandle = OpenMutex (SYNCHRONIZE,
                           FALSE,
                           sourceobject);

    if (duphandle == NULL) 
    {
    	GetLastError() ;
    }

    return duphandle ;
}


/*++

Routine Description

    No queue really - just signals the other process
    to service request.

Arguments

Return Value
    Nothing
    
--*/
DWORD
PutRequestInQueue (HANDLE hConnection,
                   RequestBuffer *preqbuff,
                   DWORD dwSizeOfBuffer)
{

    DWORD dwErr = ERROR_SUCCESS;
    
    if (g_fnServiceRequest)
    {
        g_fnServiceRequest(preqbuff, dwSizeOfBuffer);
    }
    else
    {
        dwErr = RemoteSubmitRequest (hConnection,
                            (PBYTE) preqbuff,
                            dwSizeOfBuffer);
    }
    
    return dwErr;
}

/*++

Routine Description

    Copies params from one struct to another.

Arguments

Return Value

    Nothing.
--*/

VOID
CopyParams (RAS_PARAMS *src, RAS_PARAMS *dest, DWORD numofparams)
{
    WORD    i ;
    PBYTE   temp ;

    //
    // first copy all the params into dest
    //
    memcpy (dest,
            src,
            numofparams*sizeof(RAS_PARAMS)) ;

    //
    // copy the strings:
    //
    temp = (PBYTE)dest + numofparams * sizeof(RAS_PARAMS) ;
    
    for (i = 0; i < numofparams; i++) 
    {
    	if (src[i].P_Type == String) 
    	{
    	    dest[i].P_Value.String.Length = 
    	        src[i].P_Value.String.Length ;
    	    
    	    dest[i].P_Value.String.Data = temp ;
    	    
    	    memcpy (temp,
    	            src[i].P_Value.String.Data,
    	            src[i].P_Value.String.Length) ;
    	            
    	    temp += src[i].P_Value.String.Length ;
    	    
    	} 
    	else
    	{
    	    dest[i].P_Value.Number = src[i].P_Value.Number ;
    	}
    }
}

VOID
ConvParamPointerToOffset (RAS_PARAMS *params, DWORD numofparams)
{
    WORD    i ;

    for (i = 0; i < numofparams; i++) 
    {
    	if (params[i].P_Type == String) 
    	{
    	    params[i].P_Value.String_OffSet.dwOffset = 
    	        (DWORD) (params[i].P_Value.String.Data - (PCHAR) params) ;
    	}
    }
}

VOID
ConvParamOffsetToPointer (RAS_PARAMS *params, DWORD numofparams)
{
    WORD    i ;

    for (i = 0; i < numofparams; i++) 
    {
    	if (params[i].P_Type == String) 
    	{
    	    params[i].P_Value.String.Data = 
    	              params[i].P_Value.String_OffSet.dwOffset
    	            + (PCHAR) params ;
    	}
    }
}


/*++

Routine Description

    Closes the handles for different objects opened by RASMAN process.

Arguments

Return Value

--*/

VOID
FreeNotifierHandle (HANDLE handle)
{
    if ((handle != NULL) && (handle != INVALID_HANDLE_VALUE)) 
    {
    	if (!CloseHandle (handle)) 
    	{
    	    GetLastError () ;
    	}
    }
}

VOID
GetMutex (HANDLE mutex, DWORD to)
{
    WaitForSingleObject (mutex, to) ;
}

VOID
FreeMutex (HANDLE mutex)
{
    ReleaseMutex(mutex) ;

}

DWORD
DwRasGetHostByName(CHAR *pszHostName, 
                   DWORD **ppdwAddress, 
                   DWORD *pcAddresses)
{
    WCHAR *pwszHostName = NULL;
    DWORD dwErr = SUCCESS;
    HANDLE hRnr;
    PWSAQUERYSETW pQuery = NULL;
    const static GUID ServiceGuid = SVCID_INET_HOSTADDRBYNAME;
    DWORD dwQuerySize = QUERYBUFSIZE;
    DWORD dwAddress = 0;
    const static AFPROTOCOLS afProtocols[2] = 
        {
            {AF_INET, IPPROTO_UDP},
            {AF_INET, IPPROTO_TCP}
        };

    DWORD cAddresses = 0;
    DWORD *pdwAddresses = NULL;
    DWORD MaxAddresses = 5;

    ASSERT(NULL != ppdwAddress);
    ASSERT(NULL != pcAddresses);

    if (NULL != pszHostName) 
    {
        DWORD cch;

        cch = MultiByteToWideChar(
                    CP_UTF8, 
                    0, 
                    pszHostName, 
                    -1, 
                    NULL, 
                    0);

        if(0 == cch)
        {
            dwErr = GetLastError();
            goto done;
        }

        pwszHostName = LocalAlloc(LPTR, (cch + 1) * sizeof(WCHAR));

        if(NULL == pwszHostName)
        {
            dwErr = GetLastError();
            goto done;
        }
                    
        cch = MultiByteToWideChar(
                        CP_UTF8, 
                        0, 
                        pszHostName, 
                        -1, 
                        pwszHostName, 
                        cch);
        if (0 == cch)
        {
            dwErr = GetLastError();
            goto done;
        }
    }            
    else
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    if(NULL == (pQuery = LocalAlloc(LPTR, QUERYBUFSIZE)))
    {
        dwErr = GetLastError();
        goto done;
    }

    if(NULL == (pdwAddresses = LocalAlloc(LPTR, 5 * sizeof(DWORD))))
    {
        dwErr = GetLastError();
        goto done;
    }

    /*
    pdwAddresses[0] = 0x80461111;
    pdwAddresses[1] = 0x80461111;
    pdwAddresses[2] = 0x12345668;
    pdwAddresses[3] = 0x12345668;
    pdwAddresses[4] = 0x12345668;
    cAddresses = 5;

    */


    pQuery->lpszServiceInstanceName = pwszHostName;
    pQuery->dwSize = QUERYBUFSIZE;
    pQuery->dwNameSpace = NS_ALL;
    pQuery->lpServiceClassId = (GUID *) &ServiceGuid;
    pQuery->dwNumberOfProtocols = 2;
    pQuery->lpafpProtocols = (AFPROTOCOLS *) afProtocols;

    if((dwErr = WSALookupServiceBeginW(
                        pQuery,
                        LUP_RETURN_ADDR,
                        &hRnr)) == SOCKET_ERROR)
    {
        dwErr = WSAGetLastError();
        goto done;
    }

    while(NO_ERROR == dwErr)
    {
        if(NO_ERROR == (dwErr = WSALookupServiceNextW(
                                    hRnr,
                                    0,
                                    &dwQuerySize,
                                    pQuery)))
        {
            DWORD iAddress;

            for(iAddress = 0; 
                iAddress < pQuery->dwNumberOfCsAddrs;
                iAddress++)
            {                
            
                dwAddress = 
                * ((DWORD*) 
                &pQuery->lpcsaBuffer[iAddress].RemoteAddr.lpSockaddr->sa_data[2]);

                //
                // If we have run out of space to return, realloc the
                // buffer
                //
                if(cAddresses == MaxAddresses)
                {
                    BYTE *pTemp;

                    pTemp = LocalAlloc(LPTR, (MaxAddresses + 5) * sizeof(DWORD));

                    if(NULL == pTemp)
                    {
                        dwErr = GetLastError();
                        
                        if(pdwAddresses != NULL)
                        {
                            LocalFree(pdwAddresses);
                            pdwAddresses = NULL;
                        }
                        
                        goto done;
                    }

                    CopyMemory(pTemp, 
                               (PBYTE) pdwAddresses,
                               cAddresses * sizeof(DWORD));

                    LocalFree(pdwAddresses);
                    pdwAddresses = (DWORD *) pTemp;
                    MaxAddresses += 5;
                }
                

                pdwAddresses[cAddresses] = dwAddress;
                cAddresses += 1;
            }
            
        }
        else if (SOCKET_ERROR == dwErr)
        {
            dwErr = WSAGetLastError();

            if(WSAEFAULT == dwErr)
            {
                //
                // Allocate a bigger buffer and continue
                //
                LocalFree(pQuery);
                if(NULL == (pQuery = LocalAlloc(LPTR, dwQuerySize)))
                {
                    dwErr = GetLastError();
                    break;
                }
                
                dwErr = NO_ERROR;
            }
        }
    }

    WSALookupServiceEnd(hRnr);

#if 0    

    RasmanOutputDebug("RASMAN: RasGetHostByName: number of addresses=%d\n",
             cAddresses);

    {
        DWORD i;
        RasmanOutputDebug("RASMAN: addresses:");
        for(i=0; i < cAddresses; i++)
        {
            RasmanOutputDebug("%x ", pdwAddresses[i]);
        }

        RasmanOutputDebug("\n");
    }

#endif    

done:

    *ppdwAddress = pdwAddresses;
    *pcAddresses = cAddresses;

    if(WSA_E_NO_MORE == dwErr)
    {
        dwErr = NO_ERROR;
    }

    if(NO_ERROR != dwErr)
    {
        //
        // Map it to an error that says the destination
        // is not reachable.
        //
        dwErr = ERROR_BAD_ADDRESS_SPECIFIED;
    }

    if(NULL != pwszHostName)
    {
        LocalFree(pwszHostName);
    }

    if(NULL != pQuery)
    {
        LocalFree(pQuery);
    }

    return dwErr;
}

#define RASMAN_OUTPUT_DEBUG_STATEMENTS 0

VOID
RasmanOutputDebug(
    CHAR * Format,
    ...)
{
#if DBG
#if RASMAN_OUTPUT_DEBUG_STATEMENTS
    CHAR pszTrace[4096];
    va_list arglist;

    *pszTrace = '\0';

    va_start(arglist, Format);
    vsprintf(pszTrace, Format, arglist);
    va_end(arglist);

    DbgPrint(pszTrace);

#endif
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\dll\apis.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    apis.c

Abstract:

    This file contains all entry points for the RASMAN.DLL of
    RAS Manager Component.

Author:

    Gurdeep Singh Pall (gurdeep) 06-Jun-1997

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <media.h>
#include <stdio.h>
#include <raserror.h>
#include <rasppp.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <sechost.h>
#include <winsock.h>
#include "defs.h"
#include "structs.h"
#include <sechost.h>
#include "globals.h"
#include "rasmxs.h"
#include "protos.h"

#include "nouiutil.h"
#include "loaddlls.h"

#include "rpc.h"
#include "process.h"

extern CRITICAL_SECTION g_csRequestBuffer;

extern RPC_BINDING_HANDLE g_hBinding;

BOOL g_fRasInitialized = FALSE;
BOOL g_fWinsockInitialized = FALSE;
BOOL g_fRasAutoStarted = FALSE;

DWORD g_dwEventCount = 0;

#define SECS_WaitTimeOut    500

#define NET_SVCS_GROUP      "-k netsvcs"

DWORD
DwRasGetHostByName(CHAR *pszHostName, DWORD **pdwAddress, DWORD *pcAddresses);

/*++

Routine Description:

    This function is called to check if a port handle
    supplied to the the API is valid.

Arguments:

Return Value:

    TRUE (if valid)
    FALSE

--*/
BOOL
ValidatePortHandle (HPORT porthandle)
{
    if ((porthandle >= 0))
    {
        return TRUE ;
    }

    return FALSE ;
}

BOOL
ValidateConnectionHandle(HANDLE hConnection)
{
    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if(     NULL != pRasRpcConnection
        &&  NULL == pRasRpcConnection->hRpcBinding)
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
IsRasmanProcess()
{
    CHAR *pszCmdLine = NULL;
    BOOL fRet = FALSE;

    pszCmdLine = GetCommandLine();

    RasmanOutputDebug("IsRasmanProcess: CmdLine=%s\n",
             (NULL == pszCmdLine) 
             ? "NULL"
             : pszCmdLine);

    if(     (NULL != pszCmdLine)
        &&  (strstr(pszCmdLine, NET_SVCS_GROUP)))
    {
        fRet = TRUE;
    }

    RasmanOutputDebug("IsRasmanProcess: returning %d\n",
              fRet);

    return fRet;    
}

BOOL
IsKnownDll(WCHAR *pwszCustomDialerName)
{
    BOOL fRet = FALSE;
    WCHAR *pwszDialerName, *pwsz;

    if(NULL == pwszCustomDialerName)
    {
        goto done;
    }

    pwsz = pwszCustomDialerName + wcslen(pwszCustomDialerName);

    while(      (L'\\' != *pwsz)
            &&  (pwsz != pwszCustomDialerName))
    {
        pwsz--;
    }

    if(L'\\' == *pwsz)
    {
        pwsz++;
    }

    if(0 == _wcsicmp(pwsz, L"cmdial32.dll"))
    {
        fRet = TRUE;
    }

done:

    return fRet;
}

/*++

Routine Description:

    Used for detecting processes attaching and detaching
    to the DLL.

Arguments:

Return Value:

--*/
BOOL
InitRasmanDLL (HANDLE hInst, DWORD ul_reason_being_called, LPVOID lpReserved)
{
        WSADATA wsaData;

        switch (ul_reason_being_called)
        {

        case DLL_PROCESS_ATTACH:

            DisableThreadLibraryCalls(hInst);

            //
            // Before we proceed initialize this cs. This will
            // be used to synchronize threads in  the client
            // process that sends requests to rasmans.
            //
            InitializeCriticalSection( &g_csRequestBuffer );

            break ;

        case DLL_PROCESS_DETACH:

            //
            // If this is the rasman process detaching -
            // don't do anything, else check if rasman
            // service should be stopped and then stop
            // it.
            //

            if (!IsRasmanProcess())            
            {
                DWORD   dwAttachedCount;
                BOOL    fPortsOpen;

                //
                // Dereference rasman only if Ras was initialized in
                // this process
                //
                if (!g_fRasInitialized)
                {
                    DeleteCriticalSection(&g_csRequestBuffer);
                    break;
                }

                RasGetAttachedCount (&dwAttachedCount);

                SubmitRequest(NULL, REQTYPE_CLOSEPROCESSPORTS);

                fPortsOpen = SubmitRequest(NULL, REQTYPE_NUMPORTOPEN);


                RasReferenceRasman (FALSE);

                if (    !fPortsOpen
                    &&  1 == dwAttachedCount)
                {
                    WaitForRasmanServiceStop () ;
                }

                //
                // Disconnect from rasmans
                //
                if (g_hBinding)
                {
                    DWORD dwErr;

                    dwErr = RasRpcDisconnect (&g_hBinding);
                }
            }
            else
            {
                //
                // Free rasmans dll if we loaded it i.e when in
                // mprouter process
                //

                if (hInstRasmans)
                {
                    FreeLibrary (hInstRasmans);
                }

                hInstRasmans = NULL;
            }

            if(NULL != lpReserved)
            {
                DeleteCriticalSection(&g_csRequestBuffer);
                break;
            }

            //
            // Terminate winsock.
            //
            if(g_fWinsockInitialized)
            {
                WSACleanup();

                g_fWinsockInitialized = FALSE;
            }

            //
            // This has to be the very last thing to do.
            //
            DeleteCriticalSection(&g_csRequestBuffer);

            break ;
        }

        return 1;
}

/*++

Routine Description:

    Returns the product type and sku

Arguments:

    ppt - Address to receive the product type
    pps - Address to receive the sku

Return Value:

    ERROR_SUCCESS if successful
    Registry apis errors
    
--*/
LONG
GetProductTypeAndSku(
    PRODUCT_TYPE *ppt,
    PRODUCT_SKU *pps   OPTIONAL
    )
{
    LONG    lr = ERROR_SUCCESS;
    CHAR    szProductType[128] = {0};
    CHAR    szProductSku[128] = {0};
    HKEY    hkey               = NULL;
    DWORD   dwsize;
    DWORD   dwtype;
    CHAR   *pszProductType     = "ProductType";
    CHAR   *pszProductSku      = "ProductSuite";
    
    CHAR   *pszProductOptions = 
            "System\\CurrentControlSet\\Control\\ProductOptions";
            
    CHAR    *pszServerNT       = "ServerNT";
    CHAR    *pszWinNT          = "WinNT";
    CHAR    *pszPersonal       = "Personal";

    //
    // default to workstation
    //
    *ppt = PT_WORKSTATION;
    if (pps)
    {
        *pps = 0;
    }        

    //
    // Open the ProductOptions key
    //
    if (ERROR_SUCCESS != (lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                            pszProductOptions,
                                            0, KEY_READ,
                                            &hkey)))
    {
        goto done;
    }

    //
    // Query the product type
    //
    dwsize = sizeof(szProductType);
    if(ERROR_SUCCESS != (lr = RegQueryValueEx(
                                        hkey,
                                        pszProductType,
                                        NULL,
                                        &dwtype,
                                        (LPBYTE) szProductType,
                                        &dwsize)))
    {
        goto done;
    }

    if(0 == _stricmp(szProductType,
                     pszServerNT))
    {
        *ppt = PT_SERVER;
    }
    else if(0 == _stricmp(szProductType,
                          pszWinNT))
    {
        *ppt = PT_WORKSTATION;
    }

    // 
    // Query the product sku as appropriate
    //
    if (*ppt == PT_WORKSTATION && pps)
    {
        dwsize = sizeof(szProductSku);
        if(ERROR_SUCCESS != (lr = RegQueryValueEx(
                                    hkey,
                                    pszProductSku,
                                    NULL,
                                    &dwtype,
                                    (LPBYTE) szProductSku,
                                    &dwsize)))
        {
            goto done;
        }

        if (0 == _stricmp(szProductSku, pszPersonal))
        {
            *pps = PS_PERSONAL;
        }
        else
        {
            *pps = PS_PROFESSIONAL;
        }
    }

done:

    if(hkey)
    {
        RegCloseKey(hkey);
    }

    RasmanOutputDebug("GetProductType returning 0x%x\n", lr);    
    
    return lr;
}

/*++

Routine Description:

    Returns the product type

Arguments:

    ppt - Address to receive the product type

Return Value:

    ERROR_SUCCESS if successful
    Registry apis errors
    
--*/
LONG
GetProductType(PRODUCT_TYPE *ppt)
{
    return GetProductTypeAndSku(ppt, NULL);
}

DWORD
RasStartRasAutoIfRequired()
{
    SC_HANDLE       schandle        = NULL;
    SC_HANDLE       svchandle       = NULL;
    SERVICE_STATUS  status;
    DWORD           dwErr           = SUCCESS;
    BOOL            fServiceStarted = FALSE;
    BOOL            fConsumer       = FALSE;
    
    if(g_fRasAutoStarted)
    {
        RasmanOutputDebug(
            "StartRasAuto: RasAuto already started.  pid=%d\n", _getpid());
        goto done;
    }

    //
    // Check to see if this is a consumer platform
    // Return if not.
    //
    fConsumer = IsConsumerPlatform();

    if(! fConsumer)
    {
        RasmanOutputDebug(
            "StartRasAuto: not a consumer platform.  pid=%d\n", _getpid());
            
        goto done;
    }
    else
    {
        RasmanOutputDebug(
            "StartRasAuto: is consumer platform. pid=%d\n", _getpid());
    }

    if(     !(schandle = OpenSCManager(NULL,
                                       NULL,
                                       SC_MANAGER_CONNECT))
        ||  !(svchandle = OpenService(schandle,
                                      TEXT("RasAuto"),
                                      SERVICE_START |
                                      SERVICE_QUERY_STATUS)))
    {
        dwErr = GetLastError();
        RasmanOutputDebug("StartRasAuto: Failed to open SCM/Service. dwErr=%d\n",
                 dwErr);
        goto done;
    }

    while (TRUE)
    {
        //
        // Check if service is already starting:
        //
        if (QueryServiceStatus(svchandle, &status) == FALSE)
        {
            dwErr = GetLastError();
            goto done;
        }

        RasmanOutputDebug("StartRasAuto: ServiceStatus=%d\n",
                 status.dwCurrentState);

        switch (status.dwCurrentState)
        {
            case SERVICE_STOPPED:
            {
                //
                // If we had previously tried to start the service
                // and failed. Quit
                //
                if (fServiceStarted)
                {
                    RasmanOutputDebug("StartRasAuto: failed to start rasauto\n");
                    dwErr = ERROR_RASAUTO_CANNOT_INITIALIZE; 
                    goto done;
                }

                RasmanOutputDebug("StartRasAuto: Starting RasAuto...\n");

                if (StartService (svchandle, 0, NULL) == FALSE)
                {
                    dwErr = GetLastError() ;
                    RasmanOutputDebug("StartRasAuto: StartService failed. rc=0x%x",
                             dwErr);
                    if(ERROR_SERVICE_ALREADY_RUNNING == dwErr)
                    {
                        dwErr = SUCCESS;
                    }
                    else if(SUCCESS != dwErr)
                    {
                        dwErr = ERROR_RASAUTO_CANNOT_INITIALIZE;
                        goto done;
                    }
                }

                fServiceStarted = TRUE;

                break;
            }

            case SERVICE_START_PENDING:
            {
            
                Sleep (500L) ;
                break ;
            }

            case SERVICE_RUNNING:
            {
                g_fRasAutoStarted = TRUE;
                goto done;
            }

            default:
            {
                dwErr = ERROR_RASAUTO_CANNOT_INITIALIZE;
                goto done;
            }
        }
    }
        
done:

    if(NULL != schandle)
    {
        CloseServiceHandle(schandle);
    }

    if(NULL != svchandle)
    {
        CloseServiceHandle(svchandle);
    }

    RasmanOutputDebug("StartRasAuto: returning 0x%x\n",
             dwErr);

    return dwErr;
            
}

DWORD
RasmanUninitialize()
{
    DWORD dwRetcode = ERROR_SUCCESS;
    
    if (!IsRasmanProcess())            
    {
#if 0    
        DbgPrint("RasmanUninitialize: Uninitializing rasman. pid=%d\n",
                GetCurrentProcessId());
#endif                
        //
        // Dereference rasman only if Ras was initialized in
        // this process
        //
        if (!g_fRasInitialized)
        {
            // DeleteCriticalSection(&g_csRequestBuffer);
            goto done;
        }

        RasReferenceRasman (FALSE);

        //
        // Disconnect from rasmans
        //
        if (g_hBinding)
        {
            DWORD dwErr;

            dwErr = RasRpcDisconnect (&g_hBinding);
            g_hBinding = NULL;
        }
    }
    else
    {
        //
        // Free rasmans dll if we loaded it i.e when in
        // mprouter process
        //

        if (hInstRasmans)
        {
            FreeLibrary (hInstRasmans);
        }

        hInstRasmans = NULL;
    }

    //
    // Terminate winsock.
    //
    if(g_fWinsockInitialized)
    {
        WSACleanup();

        g_fWinsockInitialized = FALSE;
    }

    g_fRasInitialized = FALSE;    

done:

#if 0
    DbgPrint("\nRasmanUninitialize: uninitialized rasman\n");
#endif    
    return dwRetcode;
}

DWORD
RasInitializeNoWait ()
{
    hInstRasmans        = NULL;
    g_fnServiceRequest  = NULL;

    // GetStartupInfo(&startupinfo) ;

    if (IsRasmanProcess())
    {
        //
        // Load rasmans dll and initialize "ServiceRequest"
        // fn pointer
        //
        hInstRasmans = LoadLibrary ("rasmans.dll");

        if (NULL == hInstRasmans)
        {
            RasmanOutputDebug("RasIntializeNoWait: hInstRasmans==NULL!\n");
            return ERROR_RASMAN_CANNOT_INITIALIZE;
        }

        g_fnServiceRequest = GetProcAddress (hInstRasmans,
                                             TEXT("ServiceRequest"));

        if (NULL == g_fnServiceRequest)
        {
            FreeLibrary (hInstRasmans);

            RasmanOutputDebug("RasInitializeNoWait: g_fnServiceRequest==NULL!\n");
            return ERROR_RASMAN_CANNOT_INITIALIZE;
        }

        return SUCCESS;
    }

    //
    // Initialize winsock if we haven't done so already
    //
    if (!g_fWinsockInitialized)
    {
        int status = 0;
        WSADATA wsaData;
        status = WSAStartup(MAKEWORD(2,0), &wsaData);

        if(0 != status)
        {
            return WSAGetLastError();
        }

        g_fWinsockInitialized = TRUE;
    }

    return SUCCESS ;
}

/*++

Routine Description:

    Called to map the shared space into the attaching process.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD
RasInitialize ()
{
    SC_HANDLE       schandle = NULL;
    SC_HANDLE       svchandle = NULL;
    SERVICE_STATUS  status ;
    BOOL            fRasmanStarted = FALSE;
    DWORD           dwErr = ERROR_SUCCESS;

    dwErr = RasInitializeNoWait ();
    if (dwErr)
    {
        goto done;
    }

    //
    // Get handles to check status of service and
    // (if it is not started -) to start it.
    //
    if (    !(schandle  = OpenSCManager(NULL,
                                        NULL,
                                        SC_MANAGER_CONNECT))

        ||  !(svchandle = OpenService(schandle,
                                      RASMAN_SERVICE_NAME,SERVICE_START
                                      |SERVICE_QUERY_STATUS)))
    {
        dwErr = GetLastError();
        goto done;
    }

    while (TRUE)
    {
        //
        // Check if service is already starting:
        //
        if (QueryServiceStatus(svchandle,&status) == FALSE)
        {
            dwErr = GetLastError();
            goto done;
        }

        switch (status.dwCurrentState)
        {

        case SERVICE_STOPPED:

            //
            // If we had previously tried to start rasman
            // and failed. Quit
            //
            if (fRasmanStarted)
            {
            
                RasmanOutputDebug("RasInitialize: SERVICE_STOPPED!\n");
                dwErr = ERROR_RASMAN_CANNOT_INITIALIZE; 
                goto done;
            }

            if (StartService (svchandle, 0, NULL) == FALSE)
            {

                GlobalError = GetLastError() ;

                RasmanOutputDebug("RasInitialize: StartService returned 0x%x\n",
                         GlobalError);

                if(ERROR_SERVICE_ALREADY_RUNNING == GlobalError)
                {
                    GlobalError = SUCCESS;
                }
                else if(SUCCESS != dwErr)
                {
                    dwErr = ERROR_RASMAN_CANNOT_INITIALIZE;
                    goto done;
                }
            }

            fRasmanStarted = TRUE;

            break;

        case SERVICE_START_PENDING:
            Sleep (500L) ;
            break ;

        case SERVICE_RUNNING:
        {
            BOOL fRasmanProcess = IsRasmanProcess();
            
            //
            // This means that local rpc server is already running
            // We should be able to connect to it if we haven't
            // already
            //
            if (    !fRasmanProcess
                &&  (NULL != g_hBinding))
            {
                goto done;
            }


            if(!fRasmanProcess)
            {
#if 0           
                DbgPrint("RasInitialize: Initializing rasman. pid %d\n",
                        GetCurrentProcessId());
#endif                        

                if (dwErr = RasRpcConnect (NULL, &g_hBinding))
                {
                    RasmanOutputDebug ("RasInitialize: Failed to "
                              "connect to local server. %d\n",
                              dwErr);
                    dwErr = ERROR_RASMAN_CANNOT_INITIALIZE;
                    goto done;
                }
            }

            //
            // Reference rasman only if this is not running in
            // svchost.exe. Otherwise the service calling 
            // RasInitialize explicitly references rasman.
            // Change this to be done in a more graceful
            // way.
            //
            // GetStartupInfo(&startupinfo) ;

            if (!fRasmanProcess)
            {
                if (dwErr = RasReferenceRasman(TRUE))
                {
                    RasmanOutputDebug("RasInitialize: failed to "
                             "reference rasman. %d\n",
                             dwErr );
                    dwErr = ERROR_RASMAN_CANNOT_INITIALIZE;
                    goto done;
                }
            }

            g_fRasInitialized = TRUE;

            goto done;
        }

        default:
            RasmanOutputDebug("RasInitialize: Invalid service.status=%d\n",
                    status.dwCurrentState);
                        
            dwErr = ERROR_RASMAN_CANNOT_INITIALIZE;
            break;
        }
    }

done:    

    if(NULL != schandle)
    {
        CloseServiceHandle(schandle);
    }

    if(NULL != svchandle)
    {
        CloseServiceHandle(svchandle);
    }

    return dwErr ;
}

/*++

Routine Description:

    Opens Port for which name is specified.

Arguments:

Return Value:

    SUCCESS
    ERROR_PORT_ALREADY_OPEN
    ERROR_PORT_NOT_FOUND

--*/
DWORD APIENTRY
RasPortOpen (   PCHAR portname,
                HPORT* porthandle,
                HANDLE notifier)
{
    DWORD    pid ;

    pid = GetCurrentProcessId() ;

    return SubmitRequest( NULL,
                          REQTYPE_PORTOPEN,
                          portname,
                          notifier,
                          pid,
                          TRUE,
                          porthandle);
}

DWORD APIENTRY
RasPortOpenEx(CHAR   *pszDeviceName,
              DWORD  dwDeviceLineCounter,
              HPORT  *phport,
              HANDLE hnotifier,
              DWORD  *pdwUsageFlags)
{

    DWORD retcode =
            SubmitRequest(NULL,
                         REQTYPE_PORTOPENEX,
                         pszDeviceName,
                         dwDeviceLineCounter,
                         hnotifier,
                         TRUE,
                         pdwUsageFlags,
                         phport);

    //
    // If user name is not NULL and password is
    // NULL and this is not the svchost process,
    // get the user sid and save it in the ports
    // user data
    //
    if(     (ERROR_SUCCESS == retcode)
        && (!IsRasmanProcess()))
    {
        DWORD dwErr;
        PWCHAR pszSid = LocalAlloc(LPTR, 5000);

        if(NULL != pszSid)
        {
            dwErr = GetUserSid(pszSid, 5000);

            if(ERROR_SUCCESS == dwErr)
            {
                dwErr = RasSetPortUserData(
                            *phport,
                            PORT_USERSID_INDEX,
                            (PBYTE) pszSid,
                            5000);

            }

            LocalFree(pszSid);
        }
        else
        {
            RasmanOutputDebug("RASMAN: RasPppStart: failed to allocate sid\n");
        }
    }

    return retcode;
                         
}

/*++

Routine Description:

    Opens Port for which name is specified.

Arguments:

Return Value:

    SUCCESS
    ERROR_PORT_ALREADY_OPEN
    ERROR_PORT_NOT_FOUND

--*/
DWORD APIENTRY
RasPortReserve (PCHAR portname, HPORT* porthandle)
{
    DWORD    pid ;

    pid = GetCurrentProcessId() ;

    return SubmitRequest( NULL,
                          REQTYPE_PORTOPEN,
                          portname,
                          NULL,
                          pid,
                          FALSE,
                          porthandle) ;
}

/*++

Routine Description:

    Opens Port for which name is specified.

Arguments:

Return Value:

    SUCCESS
    ERROR_PORT_ALREADY_OPEN
    ERROR_PORT_NOT_FOUND

--*/
DWORD APIENTRY
RasPortFree (HPORT porthandle)
{
    DWORD  pid ;

    pid = GetCurrentProcessId() ;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest ( NULL,
                           REQTYPE_PORTCLOSE,
                           porthandle,
                           pid,
                           FALSE) ;
}

/*++

Routine Description:

    Closes the Port for which the handle is specified.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasPortClose (HPORT porthandle)
{
    DWORD  pid ;

    pid = GetCurrentProcessId() ;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest ( NULL,
                           REQTYPE_PORTCLOSE,
                           porthandle,
                           pid,
                           TRUE) ;
}

/*++

Routine Description:

    Enumerates all the Ports configured for RAS.

Arguments:

Return Value:

    SUCCESS
    ERROR_BUFFER_TOO_SMALL

--*/
DWORD APIENTRY
RasPortEnum (HANDLE hConnection,
             PBYTE  buffer,
             PDWORD size,
             PDWORD entries)
{
    DWORD dwError = SUCCESS;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;
    PBYTE buffer40 = NULL;
    PBYTE buffer32 = NULL;
    DWORD dwSize32 = 0;
    DWORD dwsize40 = 0;
        

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    //
    // If the request is for a remote server and the server
    // version is 4.0 - steelhead, then defer to the old way
    // of getting this information since rasman has become
    // a rpc server only in version 50.
    //
    if(     NULL != pRasRpcConnection
        &&  VERSION_40 == pRasRpcConnection->dwVersion)
    {
        //
        // Allocate 40 buffer
        //
        if(buffer != NULL)
        {
            dwsize40 =   sizeof(RASMAN_PORT_400) 
                       * ((*size)/sizeof(RASMAN_PORT));
                       
            buffer40 = LocalAlloc(LPTR, dwsize40);

            if(NULL == buffer40)
            {
                dwError = GetLastError();
                goto done;
            }
        }
    
        dwError = RemoteRasPortEnum(hConnection,
                                    buffer40,
                                    &dwsize40,
                                    entries);


        if(ERROR_SUCCESS == dwError)
        {
            DWORD i;
            RASMAN_PORT *pPort = (RASMAN_PORT *) buffer;
            RASMAN_PORT_400 *pPort400 = (RASMAN_PORT_400 *) buffer40;
            
            //
            // Copy over the information from the 40 buffer
            // to 50 buffer
            //
            for(i = 0; i < *entries; i++)
            {
                pPort[i].P_Handle = pPort400[i].P_Handle;
                
                strcpy(pPort[i].P_PortName,
                       pPort400[i].P_PortName);

                pPort[i].P_Status = pPort400[i].P_Status;
                
                pPort[i].P_ConfiguredUsage = 
                        pPort400[i].P_ConfiguredUsage;
                        
                pPort[i].P_CurrentUsage = pPort400[i].P_CurrentUsage;

                strcpy(pPort[i].P_MediaName,
                       pPort400[i].P_MediaName);

                strcpy(pPort[i].P_DeviceType,
                       pPort400[i].P_DeviceType);

                strcpy(pPort[i].P_DeviceName,
                       pPort400[i].P_DeviceName);

                pPort[i].P_LineDeviceId = pPort400[i].P_LineDeviceId;
                pPort[i].P_AddressId = pPort400[i].P_AddressId;

                if(0 == _stricmp(pPort400[i].P_DeviceType,
                                "modem"))
                {
                    pPort->P_rdtDeviceType = RDT_Modem;
                }
                else if(0 == _stricmp(pPort400[i].P_DeviceType,
                                     "isdn"))
                {
                    pPort->P_rdtDeviceType = RDT_Isdn;
                }
                else if(0 == _stricmp(pPort400[i].P_DeviceType,
                                     "x25"))
                {
                    pPort->P_rdtDeviceType = RDT_X25;
                }
                else if(0 == _stricmp(pPort400[i].P_DeviceType,
                                     "vpn"))
                {
                    pPort->P_rdtDeviceType = RDT_Tunnel_Pptp | RDT_Tunnel;
                }
                else
                {
                    pPort->P_rdtDeviceType = RDT_Other;
                }
            }
        }
        else if(ERROR_BUFFER_TOO_SMALL == dwError)
        {
            *size = sizeof(RASMAN_PORT) 
                  * (dwsize40/sizeof(RASMAN_PORT_400));
        }
    }
    else
    {

        //
        // Thunk the ports structure
        //
        if(NULL == size)
        {
            dwError = E_INVALIDARG;
            goto done;
        }

        dwSize32 = (*size/sizeof(RASMAN_PORT)) * sizeof(RASMAN_PORT_32);

        if(0 != dwSize32)
        {
            buffer32 = LocalAlloc(LPTR, dwSize32);

            if(NULL == buffer32)
            {
                dwError = E_OUTOFMEMORY;
                goto done;
            }
        }
        
        dwError = SubmitRequest(hConnection,
                                REQTYPE_PORTENUM,
                                &dwSize32, //size,
                                buffer32,  //buffer,
                                entries) ;

        if(    (dwError != ERROR_SUCCESS)
            && (dwError != ERROR_BUFFER_TOO_SMALL))
        {
            goto done;
        }

        if(*size < (dwSize32/sizeof(RASMAN_PORT_32)) * sizeof(RASMAN_PORT))
        {
            dwError = ERROR_BUFFER_TOO_SMALL;
        }

        *size = (dwSize32/sizeof(RASMAN_PORT_32)) * sizeof(RASMAN_PORT);

        if(ERROR_SUCCESS == dwError)
        {   
            DWORD i;
            RASMAN_PORT *pPort;
            RASMAN_PORT_32 *pPort32;
            
#if defined (_WIN64)
            //
            // Thunk the rasman port structures
            //
            for(i = 0; i < *entries; i++)
            {
                pPort = &((RASMAN_PORT *) buffer)[i];
                pPort32 = &((RASMAN_PORT_32 *) buffer32 )[i];

                //
                // Copy handle
                //
                pPort->P_Handle = UlongToHandle(pPort32->P_Port);

                //
                // Copy rest of the structure - this should be the
                // same for all platforms
                //
                CopyMemory(
                (PBYTE) pPort + FIELD_OFFSET(RASMAN_PORT, P_PortName),
                (PBYTE) pPort32 + FIELD_OFFSET(RASMAN_PORT_32, P_PortName),
                sizeof(RASMAN_PORT_32) - sizeof(DWORD));
                
            }
#else
            if(NULL != buffer32)
                CopyMemory(buffer, buffer32, *size);
#endif
        }
    }

done:

    if(NULL != buffer40)
    {
        LocalFree(buffer40);
    }

    if(NULL != buffer32)
    {
        LocalFree(buffer32);
    }

    return dwError;
}

/*++

Routine Description:

    Gets parameters (info) for the Port for which handle
    is supplied

Arguments:

Return Value:

    SUCCESS
    ERROR_BUFFER_TOO_SMALL
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasPortGetInfo ( HANDLE hConnection,
                 HPORT  porthandle,
                 PBYTE  buffer,
                 PDWORD size)
{
    DWORD dwError = SUCCESS;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    //
    // If the request is for a remote server and the server
    // version is 4.0 - steelhead, then defer to the old way
    // of getting this information since rasman has become
    // a rpc server only in version 50.
    //
    if(     NULL != pRasRpcConnection
        &&  VERSION_40 == pRasRpcConnection->dwVersion)
    {
        dwError = RemoteRasPortGetInfo(hConnection,
                                       porthandle,
                                       buffer,
                                       size);
    }
    else
    {

        dwError = SubmitRequest(hConnection,
                                REQTYPE_PORTGETINFO,
                                porthandle,
                                buffer,
                                size);
    }

done:
    return dwError;
}

/*++

Routine Description:

    Sets parameters (info) for the Port for which handle
    is supplied

Arguments:

Return Value:

    SUCCESS
    ERROR_CANNOT_SET_PORT_INFO
    ERROR_WRONG_INFO_SPECIFIED
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasPortSetInfo (HPORT  porthandle,
                RASMAN_PORTINFO* info)
{
    DWORD  size=info->PI_NumOfParams*sizeof(RAS_PARAMS) ;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest ( NULL,
                           REQTYPE_PORTSETINFO,
                           porthandle,
                           info) ;
}

/*++

Routine Description:

    Disconnects the port for which handle is supplied.

Arguments:

Return Value:

    PENDING
    ERROR_NOT_CONNECTED
    ERROR_EVENT_INVALID
    ERROR_INVALID_PORT_HANDLE
    anything GetLastError returns from CreateEvent calls

--*/
DWORD APIENTRY
RasPortDisconnect (HPORT    porthandle,
                   HANDLE   winevent)
{
    DWORD   pid ;
    HANDLE  hEvent;
    DWORD   dwError;
    BOOL    fCreateEvent    = FALSE;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE ;
        goto done;
    }

    fCreateEvent = !!(INVALID_HANDLE_VALUE == winevent);

    if (fCreateEvent)
    {
        hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        if (NULL == hEvent)
        {
            fCreateEvent = FALSE;
            dwError = GetLastError();
            goto done;
        }
    }
    else
    {
        hEvent = winevent;
    }

    pid = GetCurrentProcessId () ;

    dwError = SubmitRequest( NULL,
                             REQTYPE_PORTDISCONNECT,
                             porthandle,
                             hEvent,
                             pid);

    if (    fCreateEvent
        &&  PENDING == dwError)
    {
        //
        // Wait till the pending operation
        // is done. We are making this call synchronous.
        //
        WaitForSingleObject(hEvent, INFINITE);

        //
        //clear the pending error
        //
        dwError = SUCCESS;
    }

    if (ERROR_ALREADY_DISCONNECTING == dwError)
    {
        //
        // hit the rare case where there is already
        // a disconnect pending on this port and the
        // event handle was thrown away. Sleep for
        // 5s. before proceeding. The actual disconnect
        // should have happened by then. The disconnect
        // timeout is 10s in rasman.
        //
        Sleep(5000);

        dwError = ERROR_SUCCESS;
    }

done:
    if (fCreateEvent)
    {
        CloseHandle(hEvent);
    }

    return dwError;

}

/*++

Routine Description:

    Sends supplied buffer. If connected writes to RASHUB.
    Else it writes to the port directly.

Arguments:

Return Value:

    SUCCESS
    ERROR_BUFFER_INVALID
    ERROR_EVENT_INVALID
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasPortSend (   HPORT porthandle,
                PBYTE buffer,
                DWORD size)
{
    NDISWAN_IO_PACKET *pPacket;
    SendRcvBuffer *pSendRcvBuffer;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    //
    // Get Pointer to ndiswan io data
    //
    pPacket = CONTAINING_RECORD (buffer, NDISWAN_IO_PACKET, PacketData);

    //
    // Get Pointer to SendRcvBuffer
    //
    pSendRcvBuffer = CONTAINING_RECORD (pPacket, SendRcvBuffer, SRB_Packet);

    return SubmitRequest( NULL,
                          REQTYPE_PORTSEND,
                          porthandle,
                          pSendRcvBuffer,
                          size );
}

/*++

Routine Description:

    Receives in supplied buffer. If connected reads through
    RASHUB. Else, it writes to the port directly.

Arguments:

Return Value:

    PENDING
    ERROR_BUFFER_INVALID
    ERROR_EVENT_INVALID
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasPortReceive (    HPORT   porthandle,
                    PBYTE   buffer,
                    PDWORD  size,
                    DWORD   timeout,
                    HANDLE  winevent)
{
    DWORD               pid ;
    NDISWAN_IO_PACKET   *pPacket;
    SendRcvBuffer       *pSendRcvBuffer;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    pid = GetCurrentProcessId () ;

    //
    // Get Pointer to ndiswan io data
    //
    pPacket = CONTAINING_RECORD ( buffer, NDISWAN_IO_PACKET, PacketData );

    //
    // Get Pointer to SendRcvBuffer
    //
    pSendRcvBuffer = CONTAINING_RECORD ( pPacket, SendRcvBuffer, SRB_Packet );


    return SubmitRequest ( NULL,
                           REQTYPE_PORTRECEIVE,
                           porthandle,
                           pSendRcvBuffer,
                           size,
                           timeout,
                           winevent,
                           pid) ;
}


DWORD APIENTRY
RasPortReceiveEx (  HPORT   porthandle,
                    PBYTE   buffer,
                    PDWORD  size )
{

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE;
    }

    return SubmitRequest ( NULL,
                           REQTYPE_PORTRECEIVEEX,
                           porthandle,
                           buffer,
                           size);
}

/*++

Routine Description:

    Cancels a previously pending receive

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasPortCancelReceive (HPORT porthandle)
{
    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest (NULL,
                          REQTYPE_CANCELRECEIVE,
                          porthandle) ;
}

/*++

Routine Description:

    Posts a listen on the device connected to the port.

Arguments:

Return Value:

    PENDING
    ERROR_EVENT_INVALID
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasPortListen(  HPORT porthandle,
                ULONG timeout,
                HANDLE winevent)
{
    DWORD   pid ;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    pid = GetCurrentProcessId () ;

    return SubmitRequest ( NULL,
                           REQTYPE_PORTLISTEN,
                           porthandle,
                           timeout,
                           winevent,
                           pid) ;
}

/*++

Routine Description:

    Changes state of port to CONNECTED and does other
    necessary switching.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasPortConnectComplete (HPORT porthandle)
{
    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest ( NULL,
                           REQTYPE_PORTCONNECTCOMPLETE,
                           porthandle) ;
}

/*++

Routine Description:

    Fetches statistics for the port for which the handle
    is supplied

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasPortGetStatistics ( HANDLE hConnection,
                       HPORT  porthandle,
                       PBYTE  statbuffer,
                       PDWORD size)
{
    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    dwError =  SubmitRequest ( hConnection,
                               REQTYPE_PORTGETSTATISTICS,
                               porthandle,
                               statbuffer,
                               size) ;
done:
    return dwError;
}

/*++

Routine Description:

    Fetches statistics for the bundle for which the handle
    is supplied

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasBundleGetStatistics ( HANDLE hConnection,
                         HPORT  porthandle,
                         PBYTE  statbuffer,
                         PDWORD size)
{

    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest (hConnection,
                             REQTYPE_BUNDLEGETSTATISTICS,
                             porthandle,
                             statbuffer,
                             size) ;

done:
    return dwError;
}

DWORD APIENTRY
RasPortGetStatisticsEx ( HANDLE hConnection,
                         HPORT  porthandle,
                         PBYTE  statBuffer,
                         PDWORD size)
{
    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest(hConnection,
                            REQTYPE_PORTGETSTATISTICSEX,
                            porthandle,
                            statBuffer,
                            size);

done:
    return dwError;
}

DWORD APIENTRY
RasBundleGetStatisticsEx ( HANDLE hConnection,
                           HPORT  portHandle,
                           PBYTE  statbuffer,
                           PDWORD size)
{
    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (portHandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest ( hConnection,
                              REQTYPE_BUNDLEGETSTATISTICSEX,
                              portHandle,
                              statbuffer,
                              size);

done:
    return dwError;
}

/*++

Routine Description:

    Clears statistics for the port for which the handle
    is supplied

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY  RasPortClearStatistics  (HANDLE hConnection,
                                         HPORT porthandle)
{

    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest ( hConnection,
                              REQTYPE_PORTCLEARSTATISTICS,
                              porthandle) ;

done:
    return dwError;
}

/*++

Routine Description:

    Clears statistics for the bundle for which the
    handle is supplied

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY  RasBundleClearStatistics(HANDLE hConnection,
                                         HPORT porthandle)
{
    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest ( hConnection,
                              REQTYPE_BUNDLECLEARSTATISTICS,
                              porthandle) ;
done:
    return dwError;
}

DWORD APIENTRY RasBundleClearStatisticsEx(HANDLE hConnection,
                                          HCONN hconn)
{
    DWORD dwErr;
    HPORT hPort;

    dwErr = RasBundleGetPort(hConnection,
                            (HBUNDLE) hconn,
                            &hPort);
    if (dwErr)
    {
        goto done;
    }

    dwErr = SubmitRequest ( hConnection,
                            REQTYPE_BUNDLECLEARSTATISTICS,
                            hPort);

done:
    return dwErr;
}

/*++

Routine Description:

    Enumerates all the devices of a device type.

Arguments:

Return Value:

    SUCCESS
    ERROR_DEVICE_DOES_NOT_EXIST
    ERROR_BUFFER_TOO_SMALL

--*/
DWORD APIENTRY
RasDeviceEnum (HANDLE hConnection,
               PCHAR  devicetype,
               PBYTE  buffer,
               PDWORD size,
               PDWORD entries)
{

    DWORD dwError = SUCCESS;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    //
    // If the request is for a remote server and the server
    // version is 4.0 - steelhead, then defer to the old way
    // of getting this information since rasman has become
    // a rpc server only in version 50.
    //
    if(     pRasRpcConnection
        &&  VERSION_40 == pRasRpcConnection->dwVersion)
    {
        dwError = RemoteRasDeviceEnum(hConnection,
                                      devicetype,
                                      buffer,
                                      size,
                                      entries);
    }
    else
    {

        dwError = SubmitRequest ( hConnection,
                                  REQTYPE_DEVICEENUM,
                                  devicetype,
                                  size,
                                  buffer,
                                  entries
                                );
    }

done:
    return dwError;
}

/*++

Routine Description:

    Gets info for the specified device.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE
    ERROR_DEVICETYPE_DOES_NOT_EXIST
    ERROR_DEVICE_DOES_NOT_EXIST
    ERROR_BUFFER_TOO_SMALL

--*/
DWORD APIENTRY
RasDeviceGetInfo (  HANDLE  hConnection,
                    HPORT   porthandle,
                    PCHAR   devicetype,
                    PCHAR   devicename,
                    PBYTE   buffer,
                    PDWORD  size)
{
    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError =  SubmitRequest ( hConnection,
                               REQTYPE_DEVICEGETINFO,
                               porthandle,
                               devicetype,
                               devicename,
                               buffer,
                               size) ;
done:
    return dwError;
}

/*++

Routine Description:

    Sets info for the specified device.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE
    ERROR_DEVICETYPE_DOES_NOT_EXIST
    ERROR_DEVICE_DOES_NOT_EXIST
    ERROR_INVALID_INFO_SPECIFIED

--*/
DWORD APIENTRY
RasDeviceSetInfo (HPORT              porthandle,
                  PCHAR              devicetype,
                  PCHAR              devicename,
                  RASMAN_DEVICEINFO* info)
{
    DWORD i,
          dwOldIndex,
          dwcbOldString = 0,
          retcode;

    PCHAR szOldString = NULL;

    BOOL fVpn = FALSE;

    RASMAN_INFO ri;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    retcode = RasGetInfo(NULL,
                       porthandle,
                       &ri);

    if(ERROR_SUCCESS  == retcode)
    {
        if(0 == _stricmp(ri.RI_szDeviceType,
                         "vpn"))
        {
            fVpn = TRUE;
        }
    }

    if (fVpn)
    {
        for (i = 0; i < info->DI_NumOfParams; i++)
        {
            //
            // We're only looking for the
            // MXS_PHONENUMBER_KEY key.
            //
            if (    info->DI_Params[i].P_Type != String
                ||  _stricmp(info->DI_Params[i].P_Key,
                             MXS_PHONENUMBER_KEY))
            {
                continue;
            }

            //
            // We found it.  If the phone number is a
            // DNS address, convert it to an IP address.
            //
            if (inet_addr(info->DI_Params[i].P_Value.String.Data)
                                                            == -1L)
            {
                struct hostent *hostp;
                DWORD dwErr;
                DWORD *pdwAddress;
                DWORD cAddresses;
                DWORD dwAddress;

                dwErr = DwRasGetHostByName(
                            info->DI_Params[i].P_Value.String.Data,
                            &pdwAddress,
                            &cAddresses);

                //
                // If gethostbyname() succeeds, then replace
                // the DNS address with the IP address.
                //
                /*
                hostp = gethostbyname(
                    info->DI_Params[i].P_Value.String.Data
                    );

                */

                if (    (SUCCESS == dwErr)
                    &&  (0 != cAddresses)
                    &&  (0 != (dwAddress = *pdwAddress)))
                {
                    struct in_addr in;

                    in.s_addr = dwAddress;

                    //
                    // We save the old string value away,
                    // and set the new value.  The old
                    // value will be restored after the
                    // call to SubmitRequest().  This works
                    // because SubmitRequest() has to copy
                    // the user's params anyway.
                    //
                    szOldString =
                        info->DI_Params[i].P_Value.String.Data;

                    dwcbOldString =
                        info->DI_Params[i].P_Value.String.Length;

                    info->DI_Params[i].P_Value.String.Data =
                                                    inet_ntoa(in);

                    info->DI_Params[i].P_Value.String.Length =
                        strlen(info->DI_Params[i].P_Value.String.Data);

                    dwOldIndex = i;
                }

                if(NULL != pdwAddress)
                {
                    LocalFree(pdwAddress);
                }
            }
        }
    }

    retcode = SubmitRequest ( NULL,
                              REQTYPE_DEVICESETINFO,
                              porthandle,
                              devicetype,
                              devicename,
                              info) ;

    if (dwcbOldString)
    {
        info->DI_Params[dwOldIndex].P_Value.String.Data =
                                                    szOldString;

        info->DI_Params[dwOldIndex].P_Value.String.Length =
                                                    dwcbOldString;
    }

    return retcode;
}

/*++

Routine Description:

    Connects through the device specified.

Arguments:

Return Value:

    PENDING
    ERROR_INVALID_PORT_HANDLE
    ERROR_DEVICETYPE_DOES_NOT_EXIST
    ERROR_DEVICE_DOES_NOT_EXIST
    ERROR_INVALID_INFO_SPECIFIED

--*/
DWORD APIENTRY
RasDeviceConnect ( HPORT porthandle,
                   PCHAR devicetype,
                   PCHAR devicename,
                   ULONG timeout,
                   HANDLE winevent)
{
    DWORD   pid ;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    pid = GetCurrentProcessId () ;

    return SubmitRequest ( NULL,
                           REQTYPE_DEVICECONNECT,
                           porthandle,
                           devicetype,
                           devicename,
                           timeout,
                           winevent,
                           pid) ;
}

/*++

Routine Description:

    Gets general info for the port for which handle is
    supplied.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasGetInfo (HANDLE  hConnection,
            HPORT   porthandle,
            RASMAN_INFO* info)
{
    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest ( hConnection,
                              REQTYPE_GETINFO,
                              porthandle,
                              info) ;

done:
    return dwError;
}

/*++

Routine Description:

    Gets general info for all the ports.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasGetInfoEx (HANDLE hConnection,
              RASMAN_INFO* info,
              PWORD entries)
{
    return ERROR_NOT_SUPPORTED;

#if 0
    DWORD dwError = SUCCESS;

    if (info == NULL)
    {
        dwError = ERROR_BUFFER_TOO_SMALL;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest (hConnection,
                             REQTYPE_GETINFOEX,
                             info) ;

done:
    return dwError;
#endif

}

/*++

Routine Description:

    Gets a buffer to be used with send and receive.

Arguments:

Return Value:

    SUCCESS
    ERROR_OUT_OF_BUFFERS

--*/
DWORD APIENTRY
RasGetBuffer (PBYTE* buffer, PDWORD size)
{
    HANDLE  handle  = NULL;
    DWORD   retcode = SUCCESS;
    SendRcvBuffer *pSendRcvBuffer = NULL;

    handle = OpenNamedMutexHandle ( SENDRCVMUTEXOBJECT );

    if (NULL == handle)
    {
        retcode = GetLastError();

        RasmanOutputDebug ("RASMAN: RasGetBuffer Failed to open"
                  " mutex. %d\n",
                  retcode);

        goto done;

    }

    WaitForSingleObject (handle, INFINITE);

    //
    // Alloc a buffer
    //
    pSendRcvBuffer = LocalAlloc (LPTR,
                sizeof (SendRcvBuffer));

    if (NULL == pSendRcvBuffer)
    {
        retcode = GetLastError();
        RasmanOutputDebug ("RASMAN: RasGetBuffer Failed to "
                  "allocate. %d\n",
                  retcode);

        goto done;

    }

    pSendRcvBuffer->SRB_Pid = GetCurrentProcessId();

    *size = (*size < MAX_SENDRCVBUFFER_SIZE)
            ? *size
            : MAX_SENDRCVBUFFER_SIZE;

    *buffer = pSendRcvBuffer->SRB_Packet.PacketData;

done:

    if (handle)
    {
        ReleaseMutex (handle);

        CloseHandle (handle);
    }

    return retcode ;
}

/*++

Routine Description:

    Frees a buffer gotten earlier with RasGetBuffer()

Arguments:

Return Value:

    SUCCESS
    ERROR_BUFFER_INVALID

--*/
DWORD APIENTRY
RasFreeBuffer (PBYTE buffer)
{
    HANDLE              handle;
    DWORD               retcode = SUCCESS;
    SendRcvBuffer       *pSendRcvBuffer;
    NDISWAN_IO_PACKET   *pPacket;

    handle = OpenNamedMutexHandle (SENDRCVMUTEXOBJECT);

    if (NULL == handle)
    {

        retcode = GetLastError();
        RasmanOutputDebug ("RASMAN: RasFreeBuffer Failed to"
                  " OpenMutex. %d\n", retcode);

        goto done;

    }

    WaitForSingleObject (handle, INFINITE);

    //
    // Get Pointer to ndiswan io data
    //
    pPacket = CONTAINING_RECORD(buffer, NDISWAN_IO_PACKET, PacketData);

    //
    // Get Pointer to SendRcvBuffer
    //
    pSendRcvBuffer = CONTAINING_RECORD(pPacket, SendRcvBuffer, SRB_Packet);

    LocalFree (pSendRcvBuffer);

    ReleaseMutex(handle);

    CloseHandle(handle);

done:

    return retcode ;
}

/*++

Routine Description:

    Retrieves information about protocols configured
    in the system.

Arguments:

Return Value:

    SUCCESS
    ERROR_BUFFER_TOO_SMALL

--*/
DWORD APIENTRY
RasProtocolEnum (   PBYTE buffer,
                    PDWORD size,
                    PDWORD entries)
{

    return SubmitRequest ( NULL,
                           REQTYPE_PROTOCOLENUM,
                           size,
                           buffer,
                           entries) ;
}

/*++

Routine Description:

    Allocates a route (binding) without actually activating it.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE
    ERROR_ROUTE_NOT_AVAILABLE

--*/
DWORD APIENTRY
RasAllocateRoute ( HPORT porthandle,
                   RAS_PROTOCOLTYPE type,
                   BOOL  wrknet,
                   RASMAN_ROUTEINFO* info)
{
    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    //
    // Even though this can be done by this process - we pass
    // this on to the requestor thread since we get the
    // serialization for free.
    //
    return SubmitRequest ( NULL,
                           REQTYPE_ALLOCATEROUTE,
                           porthandle,
                           type,
                           wrknet,
                           info) ;
}

/*++

Routine Description:

    Activates a previously allocated route (binding).

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE
    ERROR_ROUTE_NOT_AVAILABLE

--*/
DWORD APIENTRY
RasActivateRoute ( HPORT porthandle,
                   RAS_PROTOCOLTYPE type,
                   RASMAN_ROUTEINFO* info,
                   PROTOCOL_CONFIG_INFO *config)
{
    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest ( NULL,
                           REQTYPE_ACTIVATEROUTE,
                           porthandle,
                           type,
                           config,
                           info) ;
}

/*++

Routine Description:

    Activates a previously allocated route (binding).
    Allows you to set the max frame size as well

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE
    ERROR_ROUTE_NOT_AVAILABLE

--*/
DWORD APIENTRY
RasActivateRouteEx ( HPORT porthandle,
                     RAS_PROTOCOLTYPE type,
                     DWORD framesize,
                     RASMAN_ROUTEINFO* info,
                     PROTOCOL_CONFIG_INFO *config)
{
    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest ( NULL,
                           REQTYPE_ACTIVATEROUTEEX,
                           porthandle,
                           type,
                           framesize,
                           config,
                           info) ;
}

/*++

Routine Description:

    DeAllocates a route (binding) that was previously
    activated.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE
    ERROR_ROUTE_NOT_ALLOCATED

--*/
DWORD APIENTRY
RasDeAllocateRoute (    HBUNDLE hbundle,
                        RAS_PROTOCOLTYPE type)
{
    return SubmitRequest (  NULL,
                            REQTYPE_DEALLOCATEROUTE,
                            hbundle,
                            type) ;
}

/*++

Routine Description:

    Gets compression information for the port.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasCompressionGetInfo ( HPORT porthandle,
                        RAS_COMPRESSION_INFO *send,
                        RAS_COMPRESSION_INFO *recv)
{

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest (  NULL,
                            REQTYPE_COMPRESSIONGETINFO,
                            porthandle,
                            send,
                            recv ) ;
}

/*++

Routine Description:

    Sets compression information for the port.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE
    ERROR_INVALID_COMPRESSION_SPECIFIED

--*/
DWORD APIENTRY
RasCompressionSetInfo ( HPORT porthandle,
                        RAS_COMPRESSION_INFO *send,
                        RAS_COMPRESSION_INFO *recv)
{
    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest( NULL,
                          REQTYPE_COMPRESSIONSETINFO,
                          porthandle,
                          send,
                          recv) ;
}

/*++

Routine Description:

    Gets user credentials (username, password) from LSA.

Arguments:

Return Value:

    SUCCESS
    Non zero (failure)

--*/
DWORD APIENTRY
RasGetUserCredentials(
     PBYTE  pChallenge,
     PLUID  LogonId,
     PWCHAR UserName,
     PBYTE  CaseSensitiveChallengeResponse,
     PBYTE  CaseInsensitiveChallengeResponse,
     PBYTE  LMSessionKey,
     PBYTE  UserSessionKey
     )
{

    return SubmitRequest (
              NULL,
              REQTYPE_GETUSERCREDENTIALS,
              pChallenge,
              LogonId,
              UserName,
              CaseSensitiveChallengeResponse,
              CaseInsensitiveChallengeResponse,
              LMSessionKey,
              UserSessionKey) ;
}

/*++

Routine Description:

    Changes user's cached credentials with LSA.

Arguments:

Return Value:

    SUCCESS
    Non zero (failure)

--*/
DWORD APIENTRY
RasSetCachedCredentials(
    PCHAR Account,
    PCHAR Domain,
    PCHAR NewPassword )
{
    return
        SubmitRequest(
            NULL,
            REQTYPE_SETCACHEDCREDENTIALS,
            Account,
            Domain,
            NewPassword );
}

/*++

Routine Description:

    A request event is assocaited with a port for signalling

Arguments:

Return Value:

    SUCCESS
    ERROR_EVENT_INVALID
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasRequestNotification (HPORT porthandle, HANDLE winevent)
{
    DWORD   pid ;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    pid = GetCurrentProcessId () ;

    return SubmitRequest ( NULL,
                           REQTYPE_REQUESTNOTIFICATION,
                           porthandle,
                           winevent,
                           pid) ;
}

/*++

Routine Description:

    Gets the lan nets lana numbers read from the
    registry by Rasman

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasEnumLanNets ( DWORD *count,
                 UCHAR* lanas)
{
    return SubmitRequest (  NULL,
                            REQTYPE_ENUMLANNETS,
                            count,
                            lanas) ;
}

/*++

Routine Description:

    Gets the lan nets lana numbers read from the
    registry by Rasman

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasPortEnumProtocols ( HANDLE hConnection,
                       HPORT porthandle,
                       RAS_PROTOCOLS* protocols,
                       PDWORD count)
{

    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest (hConnection,
                             REQTYPE_PORTENUMPROTOCOLS,
                             porthandle,
                             protocols,
                             count) ;

done:
    return dwError;
}

/*++

Routine Description:

    Sets the framing type once the port is connected

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasPortSetFraming ( HPORT porthandle,
                    RAS_FRAMING type,
                    RASMAN_PPPFEATURES *Send,
                    RASMAN_PPPFEATURES *Recv)
{
    DWORD sendfeatures = 0 ;
    DWORD recvfeatures = 0 ;
    DWORD sendbits = 0 ;
    DWORD recvbits = 0 ;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    if (type == PPP)
    {
        sendfeatures  = PPP_FRAMING ;
        if (Send)
        {
            sendfeatures |= (Send->ACFC
                            ? PPP_COMPRESS_ADDRESS_CONTROL
                            : 0) ;

            sendbits = Send->ACCM ;
        }

        recvfeatures  = PPP_FRAMING ;

        if (Recv)
        {
            recvfeatures |= (Recv->ACFC
                            ? PPP_COMPRESS_ADDRESS_CONTROL
                            : 0) ;

            recvbits = Recv->ACCM ;
        }

    }

    else if (type == SLIP)
    {

        sendfeatures = recvfeatures = SLIP_FRAMING ;

    }
    else if (type == SLIPCOMP)
    {

        sendfeatures = recvfeatures = SLIP_FRAMING
                                    | SLIP_VJ_COMPRESSION ;

    }
    else if (type == SLIPCOMPAUTO)
    {

        sendfeatures = recvfeatures = SLIP_FRAMING
                                    | SLIP_VJ_AUTODETECT ;
    }
    else if (type == RAS)
    {
        sendfeatures  = recvfeatures = OLD_RAS_FRAMING ;

    }
    else if (type == AUTODETECT)
    {
    }

    return SubmitRequest ( NULL,
                           REQTYPE_SETFRAMING,
                           porthandle,
                           sendfeatures,
                           recvfeatures,
                           sendbits,
                           recvbits) ;
}

DWORD APIENTRY
RasPortStoreUserData ( HPORT porthandle,
                       PBYTE data,
                       DWORD size)
{
    if (ValidatePortHandle (porthandle) == FALSE)
        return ERROR_INVALID_PORT_HANDLE ;

    return SubmitRequest (  NULL,
                            REQTYPE_STOREUSERDATA,
                            porthandle,
                            data,
                            size) ;
}

DWORD APIENTRY
RasPortRetrieveUserData (   HPORT porthandle,
                            PBYTE data,
                            DWORD *size)
{
    if (ValidatePortHandle (porthandle) == FALSE)
        return ERROR_INVALID_PORT_HANDLE ;

    return SubmitRequest (  NULL,
                            REQTYPE_RETRIEVEUSERDATA,
                            porthandle,
                            data,
                            size) ;
}

/*++

Routine Description:

    A generic scheme for apps to attach disconnect
    action that must be performed when the link drops.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE
    ERROR_PORT_NOT_OPEN

--*/
DWORD APIENTRY
RasPortRegisterSlip (HPORT porthandle,
                    DWORD  ipaddr,
                    DWORD  dwFrameSize,
                    BOOL   priority,
                    WCHAR *pszDNSAddress,
                    WCHAR *pszDNS2Address,
                    WCHAR *pszWINSAddress,
                    WCHAR *pszWINS2Address)
{

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest (NULL,
                          REQTYPE_REGISTERSLIP,
                          porthandle,
                          ipaddr,
                          dwFrameSize,
                          priority,
                          pszDNSAddress,
                          pszDNS2Address,
                          pszWINSAddress,
                          pszWINS2Address);
}

/*++

Routine Description:

    Sets the framing info once the port is connected

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasPortSetFramingEx ( HPORT porthandle,
                      RAS_FRAMING_INFO *info)
{
    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest (  NULL,
                            REQTYPE_SETFRAMINGEX,
                            porthandle,
                            info) ;
}

/*++

Routine Description:

    Gets the framing info once the port is connected

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasPortGetFramingEx ( HANDLE           hConnection,
                      HPORT            porthandle,
                      RAS_FRAMING_INFO *info)
{
    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (porthandle) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest ( hConnection,
                              REQTYPE_GETFRAMINGEX,
                              porthandle,
                              info) ;
done:
    return dwError;
}

/*++

Routine Description:

    Gets the protocol compression attributes for the port

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasPortGetProtocolCompression (HPORT porthandle,
                               RAS_PROTOCOLTYPE type,
                               RAS_PROTOCOLCOMPRESSION *send,
                               RAS_PROTOCOLCOMPRESSION *recv)
{
    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest (NULL,
                          REQTYPE_GETPROTOCOLCOMPRESSION,
                          porthandle,
                          type,
                          send,
                          recv) ;
}

/*++

Routine Description:

    Gets the protocol compression attributes for the port

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasPortSetProtocolCompression (HPORT porthandle,
                               RAS_PROTOCOLTYPE type,
                               RAS_PROTOCOLCOMPRESSION *send,
                               RAS_PROTOCOLCOMPRESSION *recv)
{
    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest (NULL,
                          REQTYPE_SETPROTOCOLCOMPRESSION,
                          porthandle,
                          type,
                          send,
                          recv) ;
}

/*++

Routine Description:

    Gets the framing capabilities for the
    port from the mac

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasGetFramingCapabilities ( HPORT porthandle,
                            RAS_FRAMING_CAPABILITIES* caps)
{
    if (ValidatePortHandle (porthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest ( NULL,
                           REQTYPE_GETFRAMINGCAPABILITIES,
                           porthandle,
                           caps) ;
}

/*++

Routine Description:

    Exported call for third party security send

Arguments:

Return Value:

    returns from RasPortSend.

--*/
DWORD APIENTRY
RasSecurityDialogSend(
    IN HPORT    hPort,
    IN PBYTE    pBuffer,
    IN WORD     BufferLength
)
{
    RASMAN_INFO RasInfo;
    DWORD       dwRetCode = RasGetInfo( NULL, hPort, &RasInfo );

    if ( RasInfo.RI_ConnState != LISTENCOMPLETED )
    {
        return( ERROR_PORT_DISCONNECTED );
    }


    return( RasPortSend( hPort, pBuffer, ( DWORD ) BufferLength ) );
}

/*++

Routine Description:

    Exported call for third party security send

Arguments:

Return Value:

    returns from RasPortSend.

--*/
DWORD APIENTRY
RasSecurityDialogReceive(
    IN HPORT    hPort,
    IN PBYTE    pBuffer,
    IN PWORD    pBufferLength,
    IN DWORD    Timeout,
    IN HANDLE   hEvent
)
{
    RASMAN_INFO RasInfo;
    DWORD       dwRetCode = RasGetInfo( NULL, hPort, &RasInfo );
    DWORD       dwBufLength;

    if(ERROR_SUCCESS != dwRetCode)
    {
        return dwRetCode;
    }

    if ( RasInfo.RI_ConnState != LISTENCOMPLETED )
    {
        return( ERROR_PORT_DISCONNECTED );
    }

    dwBufLength = ( DWORD ) *pBufferLength;

    dwRetCode = RasPortReceive( hPort,
                            pBuffer,
                            &dwBufLength,
                            Timeout,
                            hEvent );

    return dwRetCode;
}

/*++

Routine Description:

    Gets parameters (info) for the
    Port for which handle is supplied

Arguments:

Return Value:

    returns from RasPortGetInfo

--*/
DWORD APIENTRY
RasSecurityDialogGetInfo(
    IN HPORT                hPort,
    IN RAS_SECURITY_INFO*   pBuffer
)
{
    RASMAN_INFO RasInfo;
    DWORD       dwRetCode = RasGetInfo( NULL, hPort, &RasInfo );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    memcpy( pBuffer->DeviceName,
            RasInfo.RI_DeviceConnecting,
            MAX_DEVICE_NAME + 1);

    pBuffer->BytesReceived = RasInfo.RI_BytesReceived;

    pBuffer->LastError = RasInfo.RI_LastError;

    return( NO_ERROR );
}

/*++

Routine Description:

    Sets second HPORT to be multilinked
    (bundled) with the first HPORT

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasPortBundle (HPORT firstporthandle, HPORT secondporthandle)
{
    if (ValidatePortHandle (firstporthandle) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    if (ValidatePortHandle (secondporthandle) == FALSE)
        return ERROR_INVALID_PORT_HANDLE ;

    return SubmitRequest (  NULL,
                            REQTYPE_PORTBUNDLE,
                            firstporthandle,
                            secondporthandle) ;
}

/*++

Routine Description:

    Given a port this API returns a connected
    port handle from the same bundle this port
    is or was (if not connected) part of.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasPortGetBundledPort (HPORT oldport, HPORT *pnewport)
{
    if (ValidatePortHandle (oldport) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest (NULL,
                          REQTYPE_GETBUNDLEDPORT,
                          oldport,
                          pnewport) ;
}

/*++

Routine Description:

    Given a port this API returns handle to a bundle

Arguments:

Return Value:

    SUCCESS
    ERROR_PORT_DISCONNECTED

--*/
DWORD APIENTRY
RasPortGetBundle (HANDLE  hConnection,
                  HPORT   hport,
                  HBUNDLE *phbundle)
{
    DWORD dwError = SUCCESS;

    if (ValidatePortHandle (hport) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest (hConnection,
                             REQTYPE_PORTGETBUNDLE,
                             hport,
                             phbundle) ;

done:
    return dwError;
}

/*++

Routine Description:

    Given a bundle this API returns a connected
    port handle part of the bundle.

Arguments:

Return Value:

    SUCCESS
    ERROR_INVALID_PORT_HANDLE

--*/
DWORD APIENTRY
RasBundleGetPort (HANDLE  hConnection,
                  HBUNDLE hbundle,
                  HPORT   *phport)
{
    DWORD dwError = SUCCESS;

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest (hConnection,
                             REQTYPE_BUNDLEGETPORT,
                             hbundle,
                             phport) ;

done:
    return dwError;
}

/*++

Routine Description:

    Increment/decrement the shared buffer attach count for
    use with other services inside the rasman.exe process.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasReferenceRasman (BOOL fAttach)
{
    return SubmitRequest (NULL,
                          REQTYPE_SETATTACHCOUNT,
                          fAttach);
}

/*++

Routine Description:

    Retrieve the stored dial parameters for an entry UID.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasGetDialParams(
    DWORD dwUID,
    LPDWORD pdwMask,
    PRAS_DIALPARAMS pDialParams
    )
{
    return SubmitRequest (  NULL,
                            REQTYPE_GETDIALPARAMS,
                            dwUID,
                            pdwMask,
                            pDialParams);
}

/*++

Routine Description:

    Store new dial parameters for an entry UID.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasSetDialParams(
    DWORD dwUID,
    DWORD dwMask,
    PRAS_DIALPARAMS pDialParams,
    BOOL fDelete
    )
{
    return SubmitRequest (  NULL,
                            REQTYPE_SETDIALPARAMS,
                            dwUID,
                            dwMask,
                            pDialParams,
                            fDelete);
}

/*++

Routine Description:

    Create a rasapi32 connection.

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasCreateConnection(
    HCONN   *lphconn,
    DWORD   dwSubEntries,
    DWORD   *lpdwEntryAlreadyConnected,
    DWORD   *lpdwSubEntryInfo,
    DWORD   dwDialMode,
    GUID    *pGuidEntry,
    CHAR    *lpszPhonebookPath,
    CHAR    *lpszEntryName,
    CHAR    *lpszRefPbkPath,
    CHAR    *lpszRefEntryName
    )
{
    return SubmitRequest (  NULL,
                            REQTYPE_CREATECONNECTION,
                            GetCurrentProcessId(),
                            dwSubEntries,
                            dwDialMode,
                            pGuidEntry,
                            lpszPhonebookPath,
                            lpszEntryName,
                            lpszRefPbkPath,
                            lpszRefEntryName,
                            lphconn,
                            lpdwEntryAlreadyConnected,
                            lpdwSubEntryInfo);
}

/*++

Routine Description:

    Return a list of active HCONNs

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasConnectionEnum(
    HANDLE  hConnection,
    HCONN   *lphconn,
    LPDWORD lpdwcbConnections,
    LPDWORD lpdwcConnections
    )
{
    DWORD dwError = SUCCESS;

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError =  SubmitRequest (hConnection,
                              REQTYPE_ENUMCONNECTION,
                              lpdwcbConnections,
                              lphconn,
                              lpdwcConnections);

done:
    return dwError;
}

/*++

Routine Description:

    Associate a rasapi32 connection with a port

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasAddConnectionPort(
    HCONN hconn,
    HPORT hport,
    DWORD dwSubEntry
    )
{
    return SubmitRequest (  NULL,
                            REQTYPE_ADDCONNECTIONPORT,
                            hconn,
                            hport,
                            dwSubEntry);
}

/*++

Routine Description:

    Enumerate all ports in a connection

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasEnumConnectionPorts(
    HANDLE      hConnection,
    HCONN       hconn,
    RASMAN_PORT *lpPorts,
    LPDWORD     lpdwcbPorts,
    LPDWORD     lpdwcPorts
    )
{
    DWORD dwError = SUCCESS;

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest (hConnection,
                             REQTYPE_ENUMCONNECTIONPORTS,
                             hconn,
                             lpdwcbPorts,
                             lpPorts,
                             lpdwcPorts);

done:
    return dwError;
}

/*++

Routine Description:

    Destroy a rasapi32 connection.

Arguments:

Return Value:

    SUCCESS
    ERROR_NOT_ENOUGH_MEMORY
    ERROR_ACCESS_DENIED
    whatever RasEnumConnectionPorts returns

--*/
DWORD APIENTRY
RasDestroyConnection(
    HCONN hconn
    )
{

    RASMAN_PORT     *lpPorts    = NULL;
    DWORD           dwPort;
    DWORD           dwcbPorts;
    DWORD           dwcPorts;
    DWORD           dwError = SUCCESS;
    DWORD           dwLastError = SUCCESS;

    //
    // allocate buffer for 2 ports up front
    // We don't have to make more than one
    // rasman call in base cases.
    //
    lpPorts = LocalAlloc(LPTR,
                        2 * sizeof(RASMAN_PORT));
    if (NULL == lpPorts)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    dwcbPorts = 2 * sizeof(RASMAN_PORT);

    do {
        //
        // enumerate the ports in this connection
        //
        dwError = RasEnumConnectionPorts(NULL,
                                        hconn,
                                        lpPorts,
                                        &dwcbPorts,
                                        &dwcPorts);

        if (ERROR_BUFFER_TOO_SMALL == dwError)
        {
            LocalFree(lpPorts);

            lpPorts = NULL;

            //
            // allocate a larger buffer and call the api again
            //
            lpPorts = LocalAlloc(LPTR, dwcbPorts);

            if (NULL == lpPorts)
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            }

        }

    } while (ERROR_BUFFER_TOO_SMALL == dwError);

    if (SUCCESS != dwError)
    {

        goto done;
    }

    for (dwPort = 0; dwPort < dwcPorts; dwPort++)
    {
        //
        //disconnect the port
        //
        dwError = RasPortDisconnect( lpPorts[dwPort].P_Handle,
                                      INVALID_HANDLE_VALUE);

        if(ERROR_SUCCESS != dwError)
        {
            dwLastError = dwError;
        }
        
        //
        // close the port
        //
        dwError = RasPortClose( lpPorts[dwPort].P_Handle );

        if(ERROR_SUCCESS != dwError)
        {
            dwLastError = dwError;
        }

    }

done:
    if (lpPorts)
    {
        LocalFree(lpPorts);
    }

    if(     (ERROR_SUCCESS == dwError)
        &&  (ERROR_SUCCESS != dwLastError))
    {
        dwError = dwLastError;
    }

    return dwError;
}

/*++

Routine Description:

    Retrieve rasapi32 bandwidth-on-demand, idle disconnect,
    and redial-on-link-failure parameters for a bundle

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasGetConnectionParams(
    HCONN hconn,
    PRAS_CONNECTIONPARAMS pConnectionParams
    )
{
    return SubmitRequest (  NULL,
                            REQTYPE_GETCONNECTIONPARAMS,
                            hconn,
                            pConnectionParams);
}

/*++

Routine Description:

    Store rasapi32 bandwidth-on-demand, idle disconnect,
    and redial-on-link-failure parameters for a bundle

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasSetConnectionParams(
    HCONN hconn,
    PRAS_CONNECTIONPARAMS pConnectionParams
    )
{
    return SubmitRequest (  NULL,
                            REQTYPE_SETCONNECTIONPARAMS,
                            hconn,
                            pConnectionParams);
}

/*++

Routine Description:

    Retrieve tagged user data for a connection

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasGetConnectionUserData(
    HCONN hconn,
    DWORD dwTag,
    PBYTE pBuf,
    LPDWORD lpdwcbBuf
    )
{
    return SubmitRequest (  NULL,
                            REQTYPE_GETCONNECTIONUSERDATA,
                            hconn,
                            dwTag,
                            pBuf,
                            lpdwcbBuf);
}

/*++

Routine Description:

    Store tagged user data for a connection

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasSetConnectionUserData(
    HCONN hconn,
    DWORD dwTag,
    PBYTE pBuf,
    DWORD dwcbBuf
    )
{
    return SubmitRequest (  NULL,
                            REQTYPE_SETCONNECTIONUSERDATA,
                            hconn,
                            dwTag,
                            pBuf,
                            dwcbBuf);
}

/*++

Routine Description:

    Retrieve tagged user data for a port

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasGetPortUserData(
    HPORT hport,
    DWORD dwTag,
    PBYTE pBuf,
    LPDWORD lpdwcbBuf
    )
{
    return SubmitRequest (  NULL,
                            REQTYPE_GETPORTUSERDATA,
                            hport,
                            dwTag,
                            pBuf,
                            lpdwcbBuf);
}

/*++

Routine Description:

    Store tagged user data for a port

Arguments:

Return Value:

    SUCCESS

--*/
DWORD APIENTRY
RasSetPortUserData(
    HPORT hport,
    DWORD dwTag,
    PBYTE pBuf,
    DWORD dwcbBuf
    )
{
    return SubmitRequest (  NULL,
                            REQTYPE_SETPORTUSERDATA,
                            hport,
                            dwTag,
                            pBuf,
                            dwcbBuf);
}

/*++

Routine Description:

    Sends message to rasman.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasSendPppMessageToRasman (
        IN HPORT hPort,
        LPBYTE lpPppMessage
)
{

    return SubmitRequest (  NULL,
                            REQTYPE_SENDPPPMESSAGETORASMAN,
                            hPort,
                            lpPppMessage);
}

/*++

Routine Description:

    Stops PPP on 'hPort'.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasPppStop(
    IN HPORT hPort
)
{
    if (ValidatePortHandle (hPort) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest( NULL,
                          REQTYPE_PPPSTOP,
                          hPort  );
}

/*++

Routine Description:

    Called in response to a "CallbackRequest" notification to
    set the  callback number (or not) for the "set-by-caller"
    user.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasPppCallback(
    IN HPORT hPort,
    IN CHAR* pszCallbackNumber
)
{
    if (ValidatePortHandle (hPort) == FALSE)
        return ERROR_INVALID_PORT_HANDLE ;

    return SubmitRequest (  NULL,
                            REQTYPE_PPPCALLBACK,
                            hPort,
                            pszCallbackNumber  );
}

/*++

Routine Description:

    Called in response to a "ChangePwRequest" notification
    to set a new password (replacing the one that has expired)
    of 'pszNewPassword'.  The username and old password are
    specified because in the auto-logon case they have not
    yet been specified in change password useable form.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasPppChangePassword(
    IN HPORT hPort,
    IN CHAR* pszUserName,
    IN CHAR* pszOldPassword,
    IN CHAR* pszNewPassword )

{
    if (ValidatePortHandle (hPort) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest( NULL,
                          REQTYPE_PPPCHANGEPWD,
                          hPort,
                          pszUserName,
                          pszOldPassword,
                          pszNewPassword  );

}

/*++

Routine Description:

    Called when the PPP event is set to retrieve the latest PPP
    ** notification info which is loaded into caller's 'pMsg'
    buffer.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasPppGetInfo(
    IN  HPORT        hPort,
    OUT PPP_MESSAGE* pMsg
)
{
    if (ValidatePortHandle (hPort) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest( NULL,
                          REQTYPE_PPPGETINFO,
                          hPort,
                          pMsg );
}

/*++

Routine Description:

    Called in response to an "AuthRetry" notification to retry
    authentication with the new credentials, 'pszUserName',
    'pszPassword', and 'pszDomain'.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasPppRetry(
    IN HPORT hPort,
    IN CHAR* pszUserName,
    IN CHAR* pszPassword,
    IN CHAR* pszDomain
)
{
    if (ValidatePortHandle (hPort) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest( NULL,
                          REQTYPE_PPPRETRY,
                          hPort,
                          pszUserName,
                          pszPassword,
                          pszDomain );
}

/*++

Routine Description:

    Starts PPP on open and connected RAS Manager port 'hPort'.
    If successful, 'hEvent' (a manual-reset event) is thereafter
    set whenever a PPP notification is available (via  RasPppGetInfo).
    'pszUserName', 'pszPassword', and 'pszDomain' specify the
    credentials to be authenticated during authentication phase.
    'pConfigInfo' specifies further configuration info such as
    which CPs to request, callback and compression parameters,
    etc.  'pszzParameters' is a buffer of length PARAMETERBUFLEN
    containing a string of NUL-terminated key=value strings,
    all terminated by a double-NUL.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasPppStart(
    IN HPORT                hPort,
    IN CHAR*                pszPortName,
    IN CHAR*                pszUserName,
    IN CHAR*                pszPassword,
    IN CHAR*                pszDomain,
    IN LUID*                pLuid,
    IN PPP_CONFIG_INFO*     pConfigInfo,
    IN LPVOID               pInterfaceInfo,
    IN CHAR*                pszzParameters,
    IN BOOL                 fThisIsACallback,
    IN HANDLE               hEvent,
    IN DWORD                dwAutoDisconnectTime,
    IN BOOL                 fRedialOnLinkFailure,
    IN PPP_BAPPARAMS*       pBapParams,
    IN BOOL                 fNonInteractive,
    IN DWORD                dwEapTypeId,
    IN DWORD                dwFlags
)
{
    PPP_INTERFACE_INFO * pPppInterfaceInfo = pInterfaceInfo;

    if (ValidatePortHandle (hPort) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    //
    // If user name is not NULL and password is
    // NULL and this is not the svchost process,
    // get the user sid and save it in the ports
    // user data
    //
    if(!IsRasmanProcess())
    {
        DWORD dwErr;
        PWCHAR pszSid = LocalAlloc(LPTR, 5000);

        if(NULL != pszSid)
        {
            dwErr = GetUserSid(pszSid, 5000);

            if(ERROR_SUCCESS == dwErr)
            {
                dwErr = RasSetPortUserData(
                            hPort,
                            PORT_USERSID_INDEX,
                            (PBYTE) pszSid,
                            5000);

            }

            LocalFree(pszSid);
        }
        else
        {
            RasmanOutputDebug("RASMAN: RasPppStart: failed to allocate sid\n");
        }
    }

    return SubmitRequest( NULL,
                          REQTYPE_PPPSTART,
                          hPort,
                          pszPortName,
                          pszUserName,
                          pszPassword,
                          pszDomain,
                          pLuid,
                          pConfigInfo,
                          pPppInterfaceInfo,
                          pszzParameters,
                          fThisIsACallback,
                          hEvent,
                          GetCurrentProcessId(),
                          dwAutoDisconnectTime,
                          fRedialOnLinkFailure,
                          pBapParams,
                          fNonInteractive,
                          dwEapTypeId,
                          dwFlags);
}

/*++

Routine Description:

    Adds an event to be signalled on disconnect
    state for either an existing connection, or an
    existing port.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasAddNotification(
    IN HCONN hconn,
    IN HANDLE hevent,
    IN DWORD dwfFlags
)
{
    DWORD pid = GetCurrentProcessId();

    return SubmitRequest (  NULL,
                            REQTYPE_ADDNOTIFICATION,
                            pid,
                            hconn,
                            hevent,
                            dwfFlags  );
}

/*++

Routine Description:

    Allows rasapi32 to notify rasman when a new connection
    is ready to have data sent over it.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasSignalNewConnection(
    IN HCONN hconn
)
{
    return SubmitRequest( NULL,
                          REQTYPE_SIGNALCONNECTION,
                          hconn );
}

/*++

Routine Description:

    Allows apps to set dev config that is specific to the device.
    This is passed on to the approp. media dll

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasSetDevConfig( IN HPORT  hport,
                 IN CHAR   *devicetype,
                 IN PBYTE  config,
                 IN DWORD  size)
{
    if (ValidatePortHandle (hport) == FALSE)
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest (  NULL,
                            REQTYPE_SETDEVCONFIG,
                            hport,
                            devicetype,
                            config,
                            size);
}

/*++

Routine Description:

    Allows apps to get dev config that is specific to the device.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasGetDevConfig ( IN HANDLE     hConnection,
                  IN HPORT      hport,
                  IN CHAR       *devicetype,
                  IN PBYTE      config,
                  IN OUT DWORD  *size)
{
    DWORD dwError = SUCCESS;

    RAS_RPC *pRasRpcConnection = (RAS_RPC *) hConnection;

    if (ValidatePortHandle (hport) == FALSE)
    {
        dwError = ERROR_INVALID_PORT_HANDLE;
        goto done;
    }

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    //
    // If the request is for a remote server and the server
    // version is 4.0 - steelhead, then defer to the old way
    // of getting this information since rasman has become
    // a rpc server only in version 50.
    //
    if(     NULL != pRasRpcConnection
        &&  VERSION_40 == pRasRpcConnection->dwVersion)
    {
        DWORD dwSizeRequired = *size;
        
        dwError = RemoteRasGetDevConfig(hConnection,
                                        hport,
                                        devicetype,
                                        config,
                                        &dwSizeRequired);

        //
        // Since this is a buffer returned from a 4.0
        // server, we need to change this to a format
        // that nt 5.0 understands.
        //
        if(     (SUCCESS == dwError)
            &&  (dwSizeRequired > 0)
            &&  (*size >= (dwSizeRequired + sizeof(RAS_DEVCONFIG))))
        {
            RAS_DEVCONFIG *pDevConfig = (RAS_DEVCONFIG *) config;
            
            MoveMemory((PBYTE) pDevConfig->abInfo,
                        config,
                        dwSizeRequired);

            pDevConfig->dwOffsetofModemSettings = 
                    FIELD_OFFSET(RAS_DEVCONFIG, abInfo);

            pDevConfig->dwSizeofModemSettings = dwSizeRequired;

            pDevConfig->dwSizeofExtendedCaps = 0;
            pDevConfig->dwOffsetofExtendedCaps = 0;
        }
        else if (   (dwSizeRequired > 0)
                &&  (*size < (dwSizeRequired + sizeof(RAS_DEVCONFIG))))
        {
            dwError = ERROR_BUFFER_TOO_SMALL;
        }
        else if (dwSizeRequired > 0)
        {
            *size = dwSizeRequired + sizeof(RAS_DEVCONFIG);
        }
        else
        {
            *size = dwSizeRequired;
        }
    }
    else
    {

        dwError = SubmitRequest (hConnection,
                                 REQTYPE_GETDEVCONFIG,
                                 hport,
                                 devicetype,
                                 config,
                                 size);
    }

done:
    return dwError;
}

/*++

Routine Description:

    Gets time in seconds from NDISWAN since the last activity on
    this port

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasGetTimeSinceLastActivity(
    IN  HPORT   hport,
    OUT LPDWORD lpdwTimeSinceLastActivity
)
{
    if (ValidatePortHandle (hport) == FALSE)
    {
        return( ERROR_INVALID_PORT_HANDLE );
    }

    return SubmitRequest(   NULL,
                            REQTYPE_GETTIMESINCELASTACTIVITY,
                            hport,
                            lpdwTimeSinceLastActivity );
}

/*++

Routine Description:

    Debug routine to test PnP operations

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasPnPControl(
    IN DWORD dwOp,
    IN HPORT hport
)
{
    return SubmitRequest( NULL,
                          REQTYPE_PNPCONTROL,
                          dwOp,
                          hport );
}

/*++

Routine Description:

    Set the I/O Completion Port associated with a port.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasSetIoCompletionPort(
    IN HPORT hport,
    IN HANDLE hIoCompletionPort,
    IN PRAS_OVERLAPPED lpOvDrop,
    IN PRAS_OVERLAPPED lpOvStateChange,
    IN PRAS_OVERLAPPED lpOvPpp,
    IN PRAS_OVERLAPPED lpOvLast
)
{
    return SubmitRequest(
             NULL,
             REQTYPE_SETIOCOMPLETIONPORT,
             hport,
             hIoCompletionPort,
             lpOvDrop,
             lpOvStateChange,
             lpOvPpp,
             lpOvLast);

}

/*++

Routine Description:

    Set the I/O Completion Port associated with a port.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasSetRouterUsage(
    IN HPORT hport,
    IN BOOL fRouter
)
{
    return SubmitRequest(
             NULL,
             REQTYPE_SETROUTERUSAGE,
             hport,
             fRouter);

}

/*++

Routine Description:

    Close the server's side of a port.

Arguments:

Return Value:

    SUCCESS
    Non-zero returns - Failure

--*/
DWORD APIENTRY
RasServerPortClose(
    IN HPORT hport
)
{
    DWORD pid = GetCurrentProcessId();

    if (!ValidatePortHandle (hport))
    {
        return ERROR_INVALID_PORT_HANDLE ;
    }

    return SubmitRequest (  NULL,
                            REQTYPE_SERVERPORTCLOSE,
                            hport,
                            pid,
                            TRUE) ;
}

DWORD APIENTRY
RasSetRasdialInfo (
        IN HPORT hport,
        IN CHAR  *pszPhonebookPath,
        IN CHAR  *pszEntryName,
        IN CHAR  *pszPhoneNumber,
        IN DWORD cbCustomAuthData,
        IN PBYTE pbCustomAuthData)
{
    if (!ValidatePortHandle (hport))
    {
        return ERROR_INVALID_PORT_HANDLE;
    }

    return SubmitRequest (  NULL,
                            REQTYPE_SETRASDIALINFO,
                            hport,
                            pszPhonebookPath,
                            pszEntryName,
                            pszPhoneNumber,
                            cbCustomAuthData,
                            pbCustomAuthData);
}

DWORD
RasRegisterPnPCommon ( PVOID pvNotifier,
                       HANDLE hAlertableThread,
                       DWORD dwFlags,
                       BOOL  fRegister)
{
    DWORD   dwErr;
    DWORD   pid = GetCurrentProcessId();
    HANDLE  hThreadHandle = NULL;

    if (    NULL == pvNotifier
        ||  (   0 == ( dwFlags & PNP_NOTIFEVENT )
            &&  0 == ( dwFlags & PNP_NOTIFCALLBACK )))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if ( dwFlags & PNP_NOTIFCALLBACK )
    {

        if (fRegister )

        {
            if(NULL == hAlertableThread )
            {

                RasmanOutputDebug ("RasRegisterPnPCommon: "
                          "hAlertableThread == NULL\n");
                dwErr = ERROR_INVALID_PARAMETER;
                goto done;
            }

            if ( !DuplicateHandle( GetCurrentProcess(),
                                   hAlertableThread,
                                   GetCurrentProcess(),
                                   &hThreadHandle,
                                   0,
                                   FALSE,
                                   DUPLICATE_SAME_ACCESS ) )
            {

                RasmanOutputDebug("RasRegisterPnPCommon: Failed to"
                          " duplicate handle\n");
                dwErr = GetLastError();
                goto done;
            }
        }

    }

    dwErr = SubmitRequest (  NULL,
                             REQTYPE_REGISTERPNPNOTIF,
                             pvNotifier,
                             dwFlags,
                             pid,
                             hThreadHandle,
                             fRegister);

done:

    return dwErr;
}

DWORD APIENTRY
RasRegisterPnPEvent ( HANDLE hEvent, BOOL fRegister )
{
    DWORD pid = GetCurrentProcessId ();

    return RasRegisterPnPCommon ( (PVOID) hEvent,
                                  NULL,
                                  PNP_NOTIFEVENT,
                                  fRegister);
}

DWORD APIENTRY
RasRegisterPnPHandler(PAPCFUNC pfnPnPHandler,
                      HANDLE hAlertableThread,
                      BOOL   fRegister)
{
    return RasRegisterPnPCommon ( (PVOID) pfnPnPHandler,
                                   hAlertableThread,
                                   PNP_NOTIFCALLBACK,
                                   fRegister);
}


DWORD APIENTRY
RasGetAttachedCount ( DWORD *pdwAttachedCount )
{
    return SubmitRequest (  NULL,
                            REQTYPE_GETATTACHEDCOUNT,
                            pdwAttachedCount );
}

DWORD APIENTRY
RasGetNumPortOpen (void)
{
    return SubmitRequest ( NULL,
                           REQTYPE_NUMPORTOPEN );
}

DWORD APIENTRY
RasSetBapPolicy ( HCONN hConn,
                  DWORD dwLowThreshold,
                  DWORD dwLowSamplePeriod,
                  DWORD dwHighThreshold,
                  DWORD dwHighSamplePeriod)
{
    return SubmitRequest ( NULL,
                           REQTYPE_SETBAPPOLICY,
                           hConn,
                           dwLowThreshold,
                           dwLowSamplePeriod,
                           dwHighThreshold,
                           dwHighSamplePeriod );
}

DWORD APIENTRY
RasPppStarted ( HPORT hPort )
{
    return SubmitRequest ( NULL,
                           REQTYPE_PPPSTARTED,
                           hPort );
}

DWORD APIENTRY
RasRefConnection( HCONN hConn,
                  BOOL  fAddref,
                  DWORD *pdwRefCount )
{
    return SubmitRequest ( NULL,
                           REQTYPE_REFCONNECTION,
                           hConn,
                           fAddref,
                           pdwRefCount );
}

DWORD APIENTRY
RasPppGetEapInfo( HCONN hConn,
                  DWORD dwSubEntry,
                  DWORD *pdwContextId,
                  DWORD *pdwEapTypeId,
                  DWORD *pdwSizeOfUIData,
                  PBYTE pbdata )
{
    return SubmitRequest( NULL,
                          REQTYPE_GETEAPINFO,
                          hConn,
                          dwSubEntry,
                          pdwSizeOfUIData,
                          pbdata,
                          pdwContextId,
                          pdwEapTypeId);

}

DWORD APIENTRY
RasPppSetEapInfo( HPORT hPort,
                  DWORD dwContextId,
                  DWORD dwSizeOfEapUIData,
                  PBYTE pbdata)
{
    return SubmitRequest( NULL,
                          REQTYPE_SETEAPINFO,
                          hPort,
                          dwContextId,
                          dwSizeOfEapUIData,
                          pbdata);
}

DWORD APIENTRY
RasSetDeviceConfigInfo( HANDLE hConnection,
                        DWORD cEntries,
                        DWORD cbBuffer,
                        BYTE  *pbBuffer
                      )
{
    DWORD dwError = SUCCESS;

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest( hConnection,
                             REQTYPE_SETDEVICECONFIGINFO,
                             cEntries,
                             cbBuffer,
                             pbBuffer);

done:
    return dwError;
}

DWORD APIENTRY
RasGetDeviceConfigInfo( HANDLE hConnection,
                        DWORD  *pdwVersion,
                        DWORD  *pcEntries,
                        DWORD  *pcbdata,
                        BYTE   *pbBuffer)
{
    DWORD dwError = SUCCESS;

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest( hConnection,
                             REQTYPE_GETDEVICECONFIGINFO,
                             pdwVersion,
                             pcbdata,
                             pbBuffer,
                             pcEntries);
done:
    return dwError;

}

DWORD APIENTRY
RasFindPrerequisiteEntry( HCONN hConn,
                          HCONN *phConnPrerequisiteEntry)
{
    return SubmitRequest( NULL,
                          REQTYPE_FINDPREREQUISITEENTRY,
                          hConn,
                          phConnPrerequisiteEntry);
}

DWORD APIENTRY
RasLinkGetStatistics( HANDLE hConnection,
                      HCONN hConn,
                      DWORD dwSubEntry,
                      PBYTE pbStats)
{
    DWORD dwError = SUCCESS;

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest( hConnection,
                             REQTYPE_GETLINKSTATS,
                             hConn,
                             dwSubEntry,
                             pbStats);

done:
    return dwError;
}

DWORD APIENTRY
RasConnectionGetStatistics(HANDLE hConnection,
                           HCONN  hConn,
                           PBYTE  pbStats)
{
    DWORD dwError = SUCCESS;

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest( hConnection,
                             REQTYPE_GETCONNECTIONSTATS,
                             hConn,
                             pbStats);

done:
    return dwError;
}

DWORD APIENTRY
RasGetHportFromConnection(HANDLE hConnection,
                          HCONN hConn,
                          HPORT *phport)
{

    DWORD dwError = SUCCESS;

    if(!ValidateConnectionHandle(hConnection))
    {
        dwError = E_INVALIDARG;
        goto done;
    }

    dwError = SubmitRequest(hConnection,
                            REQTYPE_GETHPORTFROMCONNECTION,
                            hConn,
                            phport);

done:
    return dwError;
}

DWORD APIENTRY
RasReferenceCustomCount(HCONN  hConn,
                        BOOL   fAddref,
                        CHAR*  pszPhonebookPath,
                        CHAR*  pszEntryName,
                        DWORD* pdwCount)
{
    return SubmitRequest(NULL,
                         REQTYPE_REFERENCECUSTOMCOUNT,
                         hConn,
                         fAddref,
                         pszPhonebookPath,
                         pszEntryName,
                         pdwCount);
}

DWORD APIENTRY
RasGetHConnFromEntry(HCONN *phConn,
                     CHAR  *pszPhonebookPath,
                     CHAR  *pszEntryName)
{
    return SubmitRequest(NULL,
                         REQTYPE_GETHCONNFROMENTRY,
                         pszPhonebookPath,
                         pszEntryName,
                         phConn);
}


DWORD APIENTRY
RasGetConnectInfo(HPORT            hPort,
                  DWORD            *pdwSize,
                  RAS_CONNECT_INFO *pConnectInfo)
{

    if(NULL == pdwSize)
    {
        return E_INVALIDARG;
    }

    return SubmitRequest(NULL,
                         REQTYPE_GETCONNECTINFO,
                         hPort,
                         pdwSize,
                         pConnectInfo);
}

DWORD APIENTRY
RasGetDeviceName(RASDEVICETYPE      eDeviceType,
                 CHAR               *pszDeviceName)
{
    if(NULL == pszDeviceName)
    {
        return E_INVALIDARG;
    }

    return SubmitRequest(NULL,
                         REQTYPE_GETDEVICENAME,
                         eDeviceType,
                         pszDeviceName);
}

DWORD APIENTRY
RasGetCalledIdInfo(HANDLE               hConnection,
                   RAS_DEVICE_INFO      *pDeviceInfo,
                   DWORD                *pdwSize,
                   RAS_CALLEDID_INFO    *pCalledIdInfo)
{
    
    if(     (NULL == pDeviceInfo)
        ||  (NULL == pdwSize))
    {
        return E_INVALIDARG;
    }

    return SubmitRequest(hConnection,
                         REQTYPE_GETCALLEDID,
                         pDeviceInfo,
                         pdwSize,
                         pCalledIdInfo);
                         
}

DWORD APIENTRY
RasSetCalledIdInfo(HANDLE               hConnection,
                   RAS_DEVICE_INFO      *pDeviceInfo,
                   RAS_CALLEDID_INFO    *pCalledIdInfo,
                   BOOL                 fWrite)
{
    if(     (NULL == pDeviceInfo)
        ||  (NULL == pCalledIdInfo))
    {
        return E_INVALIDARG;
    }

    return SubmitRequest(hConnection,
                         REQTYPE_SETCALLEDID,
                         pDeviceInfo,
                         pCalledIdInfo,
                         fWrite);
}

DWORD APIENTRY
RasEnableIpSec(HPORT hPort,
               BOOL  fEnable,
               BOOL  fServer,
               RAS_L2TP_ENCRYPTION eEncryption)
{
    DWORD retcode = ERROR_SUCCESS;
    
    retcode = SubmitRequest(NULL,
                            REQTYPE_ENABLEIPSEC,
                            hPort,
                            fEnable,
                            fServer,
                            eEncryption);

    if(     (ERROR_SUCCESS != retcode)
        &&  (ERROR_CERT_FOR_ENCRYPTION_NOT_FOUND != retcode)
        &&  (ERROR_NO_CERTIFICATE != retcode))
    {
        if(!fServer)
        {
            return ERROR_FAILED_TO_ENCRYPT;
        }
    }

    return retcode;
}

DWORD APIENTRY
RasIsIpSecEnabled(HPORT hPort,
                  BOOL  *pfIsIpSecEnabled)
{
    if(NULL == pfIsIpSecEnabled)
    {
        return E_INVALIDARG;
    }

    return SubmitRequest(NULL,
                         REQTYPE_ISIPSECENABLED,
                         hPort,
                         pfIsIpSecEnabled);
}

DWORD APIENTRY
RasGetEapUserInfo(HANDLE hToken,
                 PBYTE pbEapInfo,
                 DWORD *pdwInfoSize,
                 GUID  *pGuid,
                 BOOL  fRouter,
                 DWORD dwEapTypeId)
{
    return DwGetEapUserInfo(hToken,
                            pbEapInfo,
                            pdwInfoSize,
                            pGuid,
                            fRouter,
                            dwEapTypeId);
}

DWORD APIENTRY
RasSetEapUserInfo(HANDLE hToken,
                  GUID   *pGuid,
                  PBYTE pbUserInfo,
                  DWORD dwInfoSize,
                  BOOL  fClear,
                  BOOL  fRouter,
                  DWORD dwEapTypeId)
{
    return DwSetEapUserInfo(hToken,
                            pGuid,
                            pbUserInfo,
                            dwInfoSize,
                            fClear,
                            fRouter,
                            dwEapTypeId);
}


DWORD APIENTRY
RasSetEapLogonInfo(HPORT hPort,
                   BOOL  fLogon,
                   RASEAPINFO *pEapInfo)
{

    ASSERT(NULL != pEapInfo);

    return SubmitRequest(NULL,
                         REQTYPE_SETEAPLOGONINFO,
                         hPort,
                         fLogon,
                         pEapInfo);
}

DWORD APIENTRY
RasSendNotification(RASEVENT *pRasEvent)
{
    ASSERT(NULL != pRasEvent);

    return SubmitRequest(NULL,
                         REQTYPE_SENDNOTIFICATION,
                         pRasEvent);
}


DWORD APIENTRY RasGetNdiswanDriverCaps(
                HANDLE                  hConnection,
                RAS_NDISWAN_DRIVER_INFO *pInfo)
{
    if(NULL == pInfo)
    {
        return E_INVALIDARG;
    }
    
    return SubmitRequest(hConnection,  
                        REQTYPE_GETNDISWANDRIVERCAPS,
                        pInfo);
}


DWORD APIENTRY RasGetBandwidthUtilization(
                HPORT hPort,
                RAS_GET_BANDWIDTH_UTILIZATION *pUtilization)
{

    if(NULL == pUtilization)
    {   
        return E_INVALIDARG;
    }

    return SubmitRequest(NULL,
                         REQTYPE_GETBANDWIDTHUTILIZATION,
                         hPort,
                         pUtilization);
}

/*++

Routine Description:

    This function allows rasauto.dll to provide
    a callback procedure that gets invoked when
    a connection is terminated due to hardware
    failure on its remaining link.

Arguments:

Return Value:

--*/
VOID
RasRegisterRedialCallback(
    LPVOID func
    )
{
    if(NULL == g_fnServiceRequest)
    {
        goto done;
    }

    (void) SubmitRequest(NULL,
                         REQTYPE_REGISTERREDIALCALLBACK,
                         func);
    

done:
    return;
}

DWORD APIENTRY RasGetProtocolInfo(
                    HANDLE hConnection,
                     RASMAN_GET_PROTOCOL_INFO *pInfo)
{
    if(NULL == pInfo)
    {
        return E_INVALIDARG;
    }

    return SubmitRequest(NULL,
                         REQTYPE_GETPROTOCOLINFO,
                         pInfo);
}

DWORD APIENTRY RasGetCustomScriptDll(
                    CHAR *pszCustomDll)
{
    if(NULL == pszCustomDll)
    {
        return E_INVALIDARG;
    }

    return SubmitRequest(
                        NULL,
                        REQTYPE_GETCUSTOMSCRIPTDLL,
                        pszCustomDll);
}

DWORD APIENTRY RasIsTrustedCustomDll(
                    HANDLE hConnection,
                    WCHAR *pwszCustomDll,
                    BOOL *pfTrusted)

{
    if(     (NULL == pwszCustomDll)
        ||  (wcslen(pwszCustomDll) > MAX_PATH)
        ||  (NULL == pfTrusted))
    {
        return E_INVALIDARG;
    }

    *pfTrusted = FALSE;

    if(IsKnownDll(pwszCustomDll))
    {
        *pfTrusted = TRUE;
        return SUCCESS;
    }

    return SubmitRequest(
                NULL,
                REQTYPE_ISTRUSTEDCUSTOMDLL,
                pwszCustomDll,
                pfTrusted);
}

DWORD APIENTRY RasDoIke(
                    HANDLE hConnection,
                    HPORT hPort,
                    DWORD *pdwStatus)
{
    DWORD retcode = ERROR_SUCCESS;

    HANDLE hEvent = NULL;

    ASSERT(NULL != pdwStatus);


/*	

    sprintf(szEventName,
           "Global\\RASIKEEVENT%d-%d",
           g_dwEventCount,
           GetCurrentProcessId());

    g_dwEventCount += 1;

*/

    if(NULL == (hEvent = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL)))
    {
        retcode = GetLastError();
        goto done;
    }

    retcode = SubmitRequest(
                NULL,
                REQTYPE_DOIKE,
                hPort,
                hEvent);

    if(SUCCESS == retcode)
    {
        DWORD dwRet;

        for(;;)
        {
            //
            // go into wait and keep checking to see
            // if the port has been disconnected.
            //
            dwRet = WaitForSingleObject(hEvent, SECS_WaitTimeOut);

            if(WAIT_TIMEOUT == dwRet)
            {
                RASMAN_INFO ri;

                retcode = SubmitRequest(
                            NULL,
                            REQTYPE_GETINFO,
                            hPort,
                            &ri);

                if(     (ERROR_SUCCESS == retcode)
                    &&  (CLOSED != ri.RI_PortStatus)
                    &&  (LISTENING != ri.RI_ConnState))
                {
                    continue;
                }
                else
                {
                    break;
                }
                            
            }
            else
            {
                if (WAIT_OBJECT_0 == dwRet)
                {
                    retcode = SubmitRequest(
                            NULL,
                            REQTYPE_QUERYIKESTATUS,
                            hPort,
                            pdwStatus);
                }                    

                break;
            }
        }
    }

    if(E_ABORT == retcode)
    {
        retcode = SUCCESS;
    }

done:

    if(NULL != hEvent)
    {
        CloseHandle(hEvent);
    }
    
    return retcode;
}

DWORD APIENTRY RasSetCommSettings(
                HPORT hPort,
                RASCOMMSETTINGS *pRasCommSettings,
                PVOID pv)
{
    UNREFERENCED_PARAMETER(pv);

    if(NULL == pRasCommSettings)
    {
        E_INVALIDARG;
    }
    
    if(     (sizeof(RASCOMMSETTINGS) != pRasCommSettings->dwSize)
        ||  sizeof(RASMANCOMMSETTINGS) != sizeof(RASCOMMSETTINGS))
    {
        ASSERT(FALSE);
        return ERROR_INVALID_SIZE;
    }
    
    return SubmitRequest(
            NULL,
            REQTYPE_SETRASCOMMSETTINGS,
            hPort,
            pRasCommSettings);
}


DWORD
RasEnableRasAudio(
    HANDLE hConnection,
    BOOL fEnable)
{
    return SubmitRequest(
                hConnection,
                REQTYPE_ENABLERASAUDIO,
                fEnable);
                
}

DWORD
RasSetKey(
    HANDLE hConnection,
    GUID   *pGuid,
    DWORD  dwMask,
    DWORD  cbkey,
    PBYTE  pbkey)
{
    return SubmitRequest(
                hConnection,
                REQTYPE_SETKEY,
                pGuid,
                dwMask,
                cbkey,
                pbkey);
}

DWORD
RasGetKey(
    HANDLE hConnection,
    GUID   *pGuid,
    DWORD  dwMask,
    DWORD  *pcbkey,
    PBYTE  pbkey)
{
    return SubmitRequest(
                hConnection,
                REQTYPE_GETKEY,
                pGuid,
                dwMask,
                pcbkey,
                pbkey);
}

DWORD
RasSetAddressDisable(
    WCHAR *pszAddress,
    BOOL   fDisable)
{
    return SubmitRequest(
                NULL,
                REQTYPE_ADDRESSDISABLE,
                pszAddress,
                fDisable);
}

DWORD APIENTRY
RasGetDevConfigEx ( IN HANDLE     hConnection,
                  IN HPORT      hport,
                  IN CHAR       *devicetype,
                  IN PBYTE      config,
                  IN OUT DWORD  *size)
{
    return SubmitRequest(
                hConnection,
                REQTYPE_GETDEVCONFIGEX,
                hport,
                devicetype,
                config,
                size
                );
}

DWORD APIENTRY
RasSendCreds(IN HPORT hport,
                 IN CHAR controlchar)
{
    return SubmitRequest(
                NULL,
                REQTYPE_SENDCREDS,
                hport,
                controlchar);
}

DWORD APIENTRY
RasGetUnicodeDeviceName(IN HPORT hport,
                        IN WCHAR *wszDeviceName)
{
    return SubmitRequest(
                NULL,
                REQTYPE_GETUNICODEDEVICENAME,
                hport,
                wszDeviceName);
}

DWORD APIENTRY
RasGetDeviceNameW(RASDEVICETYPE      eDeviceType,
                  WCHAR               *pszDeviceName)
{
    if(NULL == pszDeviceName)
    {
        return E_INVALIDARG;
    }

    return SubmitRequest(NULL,
                         REQTYPE_GETDEVICENAMEW,
                         eDeviceType,
                         pszDeviceName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\common\reghelp\reghelp.cpp ===
/*++

Copyright (C) 1994-95 Microsft Corporation. All rights reserved.

Module Name: 

    reghelp.cpp

Abstract:

    Helper functions to read endpoint information from registry.
    
Author:

    Rao Salapaka (raos) 01-Nov-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <comdef.h>
#include <tchar.h>
#include <rtutils.h>
#include <initguid.h>
#include <devguid.h>
#include <rasman.h>

#define REGISTRY_DEVCLASS   TEXT("system\\CurrentControlSet\\Control\\Class")

#define REGISTRY_CALLEDID   TEXT("CalledIDInformation")

extern "C"
{
    DWORD  DwGetEndPointInfo(DeviceInfo *pInfo, 
                             PBYTE pAddress);
                             
    DWORD  DwSetEndPointInfo(DeviceInfo *pInfo, 
                             PBYTE pAddress );
                             
    LONG   lrRasEnableDevice(HKEY hkey, 
                             LPTSTR pszValue, 
                             BOOL fEnable);
                             
    LONG   lrGetSetMaxEndPoints(DWORD* pdwMaxDialOut,
                                DWORD* pdwMaxDialIn,
                                BOOL   fRead);

    DWORD  DwSetModemInfo(DeviceInfo *pInfo);                                

    DWORD   DwSetCalledIdInfo(HKEY hkey,
                              DeviceInfo *pInfo);

    DWORD   DwGetCalledIdInfo(HKEY hkey,
                              DeviceInfo  *pInfo);

    LONG lrGetProductType(PRODUCT_TYPE *ppt);
    
	int 
	RegHelpStringFromGuid(REFGUID rguid, 
					      LPWSTR lpsz, 
					      int cchMax);

	LONG
	RegHelpGuidFromString(LPCWSTR pwsz,
						  GUID *pguid);
}

int 
RegHelpStringFromGuid(REFGUID rguid, LPWSTR lpsz, int cchMax)
{
    if (cchMax < GUIDSTRLEN)
    {
	    return 0;
	}

    wsprintf(lpsz, 
            L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rguid.Data1, rguid.Data2, rguid.Data3,
            rguid.Data4[0], rguid.Data4[1],
            rguid.Data4[2], rguid.Data4[3],
            rguid.Data4[4], rguid.Data4[5],
            rguid.Data4[6], rguid.Data4[7]);

    return GUIDSTRLEN;
}

/*++

Routine Description:

    Converts a guid passed in to a string format and returns it in
    the buffer supplied. Implementing this since may not be a good
    idea to pull in ole/rpc just for this function. This doesn't do
    much parameter validation and expects the string passed to be a
    correctly formatted string.
    
Arguments:

    pwsz -  The buffer to receive the stringized guid

    pguid - Pointer to guid that is to be converted to a string
            format

Return Value:

    E_INVALIDARG
    ERROR_SUCCESS
    
--*/
LONG
RegHelpGuidFromString(LPCWSTR pwsz, GUID *pguid)
{
    WCHAR   wszBuf[GUIDSTRLEN];
    LPWSTR  pendptr;

    if (    NULL == pwsz
        ||  wcslen(pwsz) < GUIDSTRLEN - 1 )
    {
        return E_INVALIDARG;
    }

    wcscpy(wszBuf, &pwsz[1]);

    wszBuf[36] = 0;
    pguid->Data4[7] = (unsigned char) wcstoul(&wszBuf[34], &pendptr, 16);

    wszBuf[34] = 0;
    pguid->Data4[6] = (unsigned char) wcstoul(&wszBuf[32], &pendptr, 16);

    wszBuf[32] = 0;
    pguid->Data4[5] = (unsigned char) wcstoul(&wszBuf[30], &pendptr, 16);

    wszBuf[30] = 0;
    pguid->Data4[4] = (unsigned char) wcstoul(&wszBuf[28], &pendptr, 16);

    wszBuf[28] = 0;
    pguid->Data4[3] = (unsigned char) wcstoul(&wszBuf[26], &pendptr, 16);

    wszBuf[26] = 0;
    pguid->Data4[2] = (unsigned char) wcstoul(&wszBuf[24], &pendptr, 16);

    wszBuf[23] = 0;
    pguid->Data4[1] = (unsigned char) wcstoul(&wszBuf[21], &pendptr, 16);

    wszBuf[21] = 0;
    pguid->Data4[0] = (unsigned char) wcstoul(&wszBuf[19], &pendptr, 16);

    wszBuf[18] = 0;
    pguid->Data3    = (unsigned short ) wcstoul(&wszBuf[14], &pendptr, 16);

    wszBuf[13] = 0;
    pguid->Data2    = (unsigned short ) wcstoul(&wszBuf[9], &pendptr, 16);

    wszBuf[8] = 0;
    pguid->Data1 = wcstoul(wszBuf, &pendptr, 16);

    return ERROR_SUCCESS;
}

/*++

Routine Description:

    Returns the product type

Arguments:

    ppt - Address to receive the product type

Return Value:

    ERROR_SUCCESS if successful
    Registry apis errors
    
--*/
LONG
lrGetProductType(PRODUCT_TYPE *ppt)
{
    LONG lr = ERROR_SUCCESS;
    
    TCHAR   szProductType[128] = {0};

    HKEY    hkey = NULL;

    DWORD   dwsize;

    DWORD   dwtype;
    
    static const TCHAR c_szProductType[] =
                            TEXT("ProductType");

    static const TCHAR c_szProductOptions[] =
      TEXT("System\\CurrentControlSet\\Control\\ProductOptions");

    static const TCHAR c_szServerNT[] =
                            TEXT("ServerNT");

    static const TCHAR c_szWinNT[] =
                            TEXT("WinNT");

    //
    // default to workstation
    //
    *ppt = PT_WORKSTATION;

    //
    // Open the ProductOptions key
    //
    if (ERROR_SUCCESS != (lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                            c_szProductOptions,
                                            0, KEY_READ,
                                            &hkey)))
    {
        goto done;
    }

    dwsize = sizeof(szProductType);
    
    //
    // Query the product type
    //
    if(ERROR_SUCCESS != (lr = RegQueryValueEx(hkey,
                                              c_szProductType,
                                              NULL,
                                              &dwtype,
                                              (LPBYTE) szProductType,
                                              &dwsize)))
    {
        goto done;
    }

    if(0 == lstrcmpi(szProductType,
                    c_szServerNT))
    {
        *ppt = PT_SERVER;
    }
    else if(0 == lstrcmpi(szProductType,
                          c_szWinNT))
    {
        *ppt = PT_WORKSTATION;
    }

done:

    if(hkey)
    {
        RegCloseKey(hkey);
    }
    
    return lr;
}

/*++

Routine Description:

    Sets of gets the max simultaneous connections allowed

Arguments:

    pdwMaxDialOut - an OUT/IN parameter to receive the max dial
                    out connections allowed, set the max dial
                    in connections allowed

    pdwMaxDialIn -  an OUT/IN parameter to receive the max dial
                    in connections allowed, set the max dial
                    in connections allowed

    fRead - Gets the information if TRUE, Sets the information
            if FALSE

Return Value:

    ERROR_SUCCESS if successful
    Registry apis errors
    
--*/
LONG
lrGetSetMaxEndPoints(
        DWORD*      pdwMaxDialOut,
        DWORD*      pdwMaxDialIn,
        BOOL        fRead)
{
    LONG lr;
    HKEY hkey;
    
    static const TCHAR c_szRasmanParamKey[] =
        TEXT("System\\CurrentControlSet\\Services\\Rasman\\Parameters");

    
    //            
    // Open rasmans parameters key
    //
    if(S_OK == (lr = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                c_szRasmanParamKey,
                                0, 
                                KEY_QUERY_VALUE | KEY_WRITE,
                                &hkey)))
    {
        static const TCHAR c_szMaxIn[] =
            TEXT("LimitSimultaneousIncomingCalls");

        static const TCHAR c_szMaxOut[] =
            TEXT("LimitSimultaneousOutgoingCalls");
            
        DWORD dwsize = sizeof(DWORD);
        DWORD dwtype;

        if(fRead)
        {
            //        
            // Query for LimitSimultaneousIncomingCalls and
            // LimitSimultaneousOutgoingCalls values
            //
            if(ERROR_SUCCESS == (lr = RegQueryValueEx(
                                            hkey,
                                            c_szMaxIn,
                                            NULL,
                                            &dwtype,
                                            (LPBYTE) pdwMaxDialIn,
                                            &dwsize)))
            {                                        
                    
                dwsize = sizeof(DWORD);
                lr = RegQueryValueEx(
                            hkey,
                            c_szMaxOut,
                            NULL,
                            &dwtype,
                            (LPBYTE) pdwMaxDialOut,
                            &dwsize);
            }
        }
        else
        {
            //
            // Set the values passed in if fRead is not
            // set.
            //
            if(ERROR_SUCCESS == (lr = RegSetValueEx(
                                        hkey,
                                        c_szMaxIn,
                                        0,
                                        REG_DWORD,
                                        (PBYTE) pdwMaxDialIn,
                                        sizeof(DWORD))))
            {
                lr = RegSetValueEx(hkey,
                                   c_szMaxOut,
                                   0, REG_DWORD,
                                   (PBYTE) pdwMaxDialOut,
                                   sizeof(DWORD));
            }
        }
        
        RegCloseKey(hkey);
    }

    if(     lr 
        &&  fRead)
    {
        //
        // Default the restrictions
        //
        PRODUCT_TYPE pt;

        lrGetProductType(&pt);

        if(PT_WORKSTATION == pt)
        {
            *pdwMaxDialIn   = 3;
            *pdwMaxDialOut  = 4;
        }
        else
        {
            *pdwMaxDialOut = 3;
            *pdwMaxDialIn = 0x7FFFFFFF;
        }
    }

    //
    // By default we create the miniports
    //
    lr = ERROR_SUCCESS;

    return lr;
}

/*++

Routine Description:

    Checks to see if the NetCfgInstanceID value for the
    key passed is the same as the pbguid passed in.
    
Arguments:

    hkey - key of the miniport instance in the registry

    pbuid - Guid we are checkin for

    pfFound - OUT paramter set to TRUE if this is the key
              whose NetCfgInstanceID is same as the guid
              FALSE otherwise

Return Value:

    ERROR_SUCCESS if successful
    Registry apis errors
    
--*/
LONG
lrCheckKey(HKEY hkey, PBYTE pbguid, BOOL *pfFound)
{
    LONG    lr              = 0;
    DWORD   dwdataLen       = 0;
    LPBYTE  lpdata          = NULL;
    DWORD   dwType;

#if DBG
    ASSERT( NULL != pbguid );
#endif

    *pfFound = FALSE;
    
    //
    // Get size of the instance id
    //
    lr = RegQueryValueEx( hkey,
                          TEXT("NetCfgInstanceID"),
                          NULL,
                          &dwType,
                          NULL,
                          &dwdataLen);
                          
    if ( ERROR_SUCCESS != lr )
    {
        goto done;                       
    }
    
    //
    // Localalloc data size. 
    // TODO OPT: consider alloca
    //
    lpdata = (LPBYTE) LocalAlloc ( LPTR, dwdataLen );

    if ( NULL == lpdata )
    {
        lr = (LONG) GetLastError();
        goto done;                        
    }

    //
    // Query the value
    //
    lr = RegQueryValueEx( hkey,
                          TEXT("NetCfgInstanceID"),
                          NULL,
                          &dwType,
                          lpdata,
                          &dwdataLen );
                          
    if ( ERROR_SUCCESS != lr )                          
    {
        goto done;                        
    }
                          
    //
    // Check to see if this is the adapter we
    // are interested in
    //
    {
        WCHAR   wsz[GUIDSTRLEN] = {0};

        if (0 == RegHelpStringFromGuid( (REFGUID) *pbguid,
                                        wsz,
                                        GUIDSTRLEN))
        {
            goto done;
        }

        if ( 0 == _wcsicmp(wsz, (WCHAR *) lpdata) )
        {
            *pfFound = TRUE;
        }
    }

done:
    if ( ERROR_FILE_NOT_FOUND == lr )
    {
        lr = ERROR_SUCCESS;
    }

    if ( lpdata )
    {
        LocalFree(lpdata);
    }
    
    return lr;
}

/*++

Routine Description:

    Checks to see if the Description specified in 
    the "FriendlyName" in the modems instance key
    
Arguments:

    hkey - key of the modem instance in the registry

    pbDescription - The DeviceName to check for

    pfFound - OUT paramter set to TRUE if this is the key
              whose FriendlyName is same as the description,
              FALSE otherwise

Return Value:

    ERROR_SUCCESS if successful
    Registry apis errors
    
--*/
LONG
lrCheckModemKey(HKEY hkey, PBYTE pbDescription, BOOL *pfFound)
{
    LONG    lr                   = 0;
    HKEY    hkeyRas              = NULL;
    WCHAR   wszFriendlyName[256] = {0};
    PWCHAR  pwszDesc             = (WCHAR *) pbDescription;
    DWORD   dwType;
    DWORD   dwSize               = sizeof(wszFriendlyName);

#if DBG
    ASSERT(NULL != pbDescription);
    ASSERT(NULL != hkey);
#endif    

    *pfFound = FALSE;
    
    //
    // Query the Friendly name of the modem
    //
    lr = RegQueryValueEx(hkey,
                         TEXT("FriendlyName"),
                         0,
                         &dwType,
                         (LPBYTE) wszFriendlyName,
                         &dwSize);

    if( ERROR_SUCCESS != lr )
    {
        goto done;
    }

    //
    // Check to see if this is the modem we are
    // looking for
    //
    if (lstrcmpi(pwszDesc, wszFriendlyName))
    {
        goto done;
    }

    *pfFound = TRUE;

done:

    return lr;
}

/*++

Routine Description:

    Gets the hkey of the miniport instance or the modem
    instance correspondig to the guid or devicename
    passed in as the pbguidDescription
    
Arguments:

    pbguidDescription - guid of the miniport instance if
                        fModem is FALSE, DeviceName of the
                        modem if fModem is TRUE

    phkey - OUT paramter to receive the hkey corresponding
            to the miniport instance/ modem instance in the
            registry

    pdwInstanceNumber - OUT parameter to receive the instance
                        number of the instance corresponding
                        to the guid passed in. This is used to
                        make up unique port names in rasman
                        
    fModem - TRUE if this is a modem, FALSE otherwise

Return Value:

    E_FAIL
    Registry apis errors
    ERROR_SUCCESS if successful
    
--*/
LONG
lrGetRegKeyFromGuid(
    PBYTE pbguidDescription, 
    HKEY *phkey, 
    PDWORD pdwInstanceNumber,
    BOOL fModem
    )
{
    LONG        lr               = 0;
    WCHAR       wszKey[256]      = {0};
    WCHAR       wsz[GUIDSTRLEN]  = {0};
    HKEY        hkey             = NULL;
    HKEY        hSubkey          = NULL;
    DWORD       dwIndex          = 0;
    DWORD       dwSize;
    FILETIME    ft;
    BOOL        fFound = FALSE;
    DWORD       dwMaxSubkeyLen   = 0;
    LPWSTR      pwsz             = NULL;

#if DBG
    ASSERT( pbguidDescription != NULL );
#endif

    if(!fModem)
    {
        //
        // Open 
        // \\HKLM\System\CurrentControlSet\Control\Class\
        // GUID_DEVCLASS_NET
        //
        if ( 0 == RegHelpStringFromGuid(GUID_DEVCLASS_NET,
                                        wsz,
                                        GUIDSTRLEN))
        {
            lr = (LONG) E_FAIL;
            goto done;                        
        }
    }
    else
    {
        //
        // Open 
        // \\HKLM\System\CurrentControlSet\Control\Class\
        // GUID_DEVCLASS_MODEM
        //
        if ( 0 == RegHelpStringFromGuid(GUID_DEVCLASS_MODEM,
                                        wsz,
                                        GUIDSTRLEN))
        {
            lr = (LONG) E_FAIL;
            goto done;                        
        }
        
    }
    
    //
    // Construct the string we use to open the devclass key
    // and open the key
    //
    wsprintf( wszKey, TEXT("%s\\%s"), 
             (LPTSTR) REGISTRY_DEVCLASS, 
             (LPTSTR) wsz );

    //
    // Enumerate adapters under GUID_DEVCLASS_NET/MODEM
    // and find the one matching either the modem desc
    // or the guid whichever is provided.
    //
    lr = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                        wszKey,
                        0,
                        KEY_ALL_ACCESS,
                        &hkey );
                        
    if ( ERROR_SUCCESS != lr )
    {
        goto done;                        
    }

    //
    // Find the size of the largest subkey name and allocate
    // the string
    //
    if ( lr = RegQueryInfoKey( hkey,
                               NULL, NULL, NULL, NULL,
                               &dwMaxSubkeyLen,
                               NULL, NULL, NULL, NULL,
                               NULL, &ft))
    {
        goto done;
    }

    dwMaxSubkeyLen += 1;

    //
    // TODO OPT: consider _alloca
    //
    pwsz = (LPWSTR) LocalAlloc(LPTR, 
                    (dwMaxSubkeyLen + 1) 
                    * sizeof(WCHAR) );
                    
    if (NULL == pwsz)
    {
        lr = (DWORD) GetLastError();
        goto done;
    }

    dwSize = dwMaxSubkeyLen;
    
    ZeroMemory(pwsz, dwSize * sizeof(WCHAR) );

    while ( ERROR_SUCCESS == ( lr = RegEnumKeyEx( hkey,
                                                  dwIndex,
                                                  pwsz,
                                                  &dwSize,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  &ft )))
                                                  
    {
        //
        // Open the subkey
        //
        lr = RegOpenKeyEx( hkey,
                           pwsz,
                           0,
                           KEY_ALL_ACCESS,
                           &hSubkey );
                           
        if ( ERROR_SUCCESS != lr )
        {
            break;                                        
        }

        if(!fModem)
        {
            lr = lrCheckKey( hSubkey,
                             pbguidDescription, 
                             &fFound );
        }
        else
        {
            lr = lrCheckModemKey( hSubkey, 
                                  pbguidDescription,
                                  &fFound);
        }

        if (    ERROR_SUCCESS != lr
            ||  fFound )
        {
            LPWSTR pendptr;
            
            if ( ERROR_SUCCESS != lr )
            {
                RegCloseKey (hSubkey );
                hSubkey = NULL;
            }
            
            *phkey = hSubkey;

            //
            // Convert the subkey to instance number
            //
            if (pdwInstanceNumber)
            {
                *pdwInstanceNumber = wcstoul(pwsz, &pendptr, 10);
            }
            
            break;
        }

        RegCloseKey( hSubkey );

        dwSize = dwMaxSubkeyLen;
        dwIndex += 1;
    }

done:
    if ( hkey )
    {
        RegCloseKey ( hkey );
    }

    if (pwsz)
    {
        LocalFree(pwsz);
    }
    
    return lr;
}

/*++

Routine Description:

    Updates the registry to enable a device for Ras Dial In
    or Enable the device for routing.
    
Arguments:

    hkey - hkey of the registry location corresponding to the
           miniport instance or modem instance

Return Value:

    Registry apis errors
    ERROR_SUCCESS if successful
    
--*/
LONG
lrRasEnableDevice( HKEY hkey, LPTSTR pszValue, BOOL fEnable )
{
    LONG lr;
    DWORD dwdata = (fEnable ? 1 : 0);                    

    lr = RegSetValueEx( hkey,
                        pszValue,
                        0,
                        REG_DWORD,
                        (LPBYTE) &dwdata,
                        sizeof(DWORD));

    return lr;                        
}

/*++

Routine Description:

    Queries registry for the value specified. Truncates the
    data to size of the buffer specified.
    
    
Arguments:

    Same as for RegQueryValueEx

Return Value:

    Registry apis errors
    ERROR_SUCCESS if successful
    
--*/
LONG
lrRegQueryValueEx(HKEY      hkey,
                  LPCTSTR   lpValueName,
                  LPDWORD   lpType,
                  LPBYTE    lpdata,
                  LPDWORD   lpcbdata)
{
    DWORD dwcbData  = *lpcbdata;
    LONG  lr        = ERROR_SUCCESS;
    PBYTE pbBuffer  = NULL;

    lr = RegQueryValueEx(hkey,
                         lpValueName,
                         NULL,
                         lpType,
                         lpdata,
                         lpcbdata);

    if(ERROR_MORE_DATA != lr)
    {
        goto done;
    }

    //
    // Allocate the memory required
    //
    pbBuffer = (LPBYTE) LocalAlloc(LPTR, *lpcbdata);

    if(NULL == pbBuffer)
    {
        lr = (LONG) GetLastError();
        goto done;
    }

    lr = RegQueryValueEx(hkey,
                         lpValueName,
                         NULL,
                         lpType,
                         pbBuffer,
                         lpcbdata);

    if(ERROR_SUCCESS != lr)
    {
        goto done;
    }

    //
    // copy the data to the buffer passed in -
    // truncate the buffer to the size of the
    // buffer passed in
    //
    memcpy(lpdata,
           pbBuffer,
           dwcbData);

done:

    if(pbBuffer)
    {
        LocalFree(pbBuffer);
    }

    return lr;
}

/*++

Routine Description:

    Reads/Writes to registry with the information passed in
    regarding the miniport instancecorresponding to the hkey
    passed in
    
Arguments:

    hkey - hkey of the registry location corresponding to the
           miniport instance

    pInfo - DeviceInformation to be saved in registry/Read
            From registry.

    fRead - TRUE if the information is to be read, FALSE if it
            is to be written.

Return Value:

    Registry apis errors
    ERROR_SUCCESS if successful
    
--*/
LONG
lrGetSetInfo ( HKEY       hkey,
               DeviceInfo *pInfo,
               BOOL       fRead)
{
    WCHAR wsz[GUIDSTRLEN] = {0};
    
    struct EndPointInfo
    {
        LPCTSTR pszValue;
        LPBYTE  pdata;
        DWORD   dwsize;
        DWORD   dwtype;
    };

    //
    // If you add/remove a value from the table
    // s_aEndPointInfo, you also need to add/remove
    // the corresponding value to the enum _ValueTag
    // defined below.
    //
    struct EndPointInfo s_aEndPointInfo[] =
    {
    
        { 
            TEXT("WanEndpoints"),               
            (LPBYTE) &pInfo->rdiDeviceInfo.dwNumEndPoints,
            sizeof (DWORD) ,
            REG_DWORD
        },
        
        {
            TEXT("EnableForRas"),
            (LPBYTE) &pInfo->rdiDeviceInfo.fRasEnabled,
            sizeof(DWORD),
            REG_DWORD
        },

    	{
    	    TEXT("EnableForRouting"),
    	    (LPBYTE) &pInfo->rdiDeviceInfo.fRouterEnabled,
    	    sizeof(DWORD),
    	    REG_DWORD
    	},

        {
            TEXT("EnableForOutboundRouting"),
            (LPBYTE) &pInfo->rdiDeviceInfo.fRouterOutboundEnabled,
            sizeof(DWORD),
            REG_DWORD
        },

        {
            TEXT("MinWanEndPoints"),
            (LPBYTE) &pInfo->rdiDeviceInfo.dwMinWanEndPoints,
            sizeof(DWORD),
            REG_DWORD
        },

        {
            TEXT("MaxWanEndPoints"),
            (LPBYTE) &pInfo->rdiDeviceInfo.dwMaxWanEndPoints,
            sizeof(DWORD),
            REG_DWORD
        },
        
        {
            TEXT("DriverDesc"),
            (LPBYTE) pInfo->rdiDeviceInfo.wszDeviceName,
            sizeof(WCHAR) * (MAX_DEVICE_NAME + 1),
            REG_SZ
        },
        
        { 
            TEXT("NetCfgInstanceID"),           
            (LPBYTE) wsz,                           
            sizeof (wsz),
            REG_SZ
        },

        {
        	TEXT("fClientRole"),
        	(LPBYTE) &pInfo->dwUsage,
        	sizeof(DWORD),
        	REG_DWORD
        },
        
    };  

    //
    // if you change this table add a value to the enum
    // below
    //
    enum _ValueTag 
    {

        WANENDPOINTS = 0,
        RASENABLED,
        ROUTERENABLED,
        OUTBOUNDROUTERENABLED,
        MINWANENDPOINTS,
        MAXWANENDPOINTS,
        DESCRIPTION,
        NETCFGINSTANCEID,
        USAGE

    } eValueTag  ;

    DWORD cValues = sizeof ( s_aEndPointInfo) \
                    / sizeof ( s_aEndPointInfo[0] );
    DWORD i;
    DWORD dwsize;
    DWORD dwdata;
    DWORD dwtype;
    LONG  lr;

    for ( i = 0; i < cValues; i++ )
    {
        dwsize = s_aEndPointInfo[i].dwsize;
        
        //
        // Query the value
        //
        if (fRead)
        {
            lr = lrRegQueryValueEx( hkey,
                                    s_aEndPointInfo[i].pszValue,
                                    &dwtype,
                                    (PBYTE) s_aEndPointInfo[i].pdata,
                                    &dwsize );

        }                              
        else
        {
            //
            // Set the values. We don't want to set
            // the guid. It doesn't change. Also don't
            // allow description to be changed.
            //
            if (    (i != (DWORD) NETCFGINSTANCEID)
                &&  (i != (DWORD) DESCRIPTION)
                &&	(i != (DWORD) USAGE))
            {
                dwtype = s_aEndPointInfo[i].dwtype;
                lr = RegSetValueEx( hkey,
                                    s_aEndPointInfo[i].pszValue,
                                    NULL,
                                    dwtype,
                                    (PBYTE) s_aEndPointInfo[i].pdata,
                                    dwsize );
            }
        }

        if (fRead)
        {
            if(     (ERROR_SUCCESS != lr)
                &&  (i == (DWORD) WANENDPOINTS))
            {
                pInfo->rdiDeviceInfo.dwNumEndPoints = 0xFFFFFFFF;
                lr = ERROR_SUCCESS;
            }

            if (i == (DWORD) NETCFGINSTANCEID)
            {
                //
                // Convert the guid string to guid
                //
                lr = RegHelpGuidFromString(wsz, 
                            &pInfo->rdiDeviceInfo.guidDevice);
                
                if ( lr )
                {
                    break;
                }
            }

            if (    (i == (DWORD) RASENABLED)
                &&  (ERROR_FILE_NOT_FOUND == lr))
            {
                //
                // If this key is not found create it
                // and default the device to be enabled
                // with Ras if its a server. Otherwise
                // the device is not enabled for Ras. Don't
                // post a listen if its parallel port. Ow
                // we hog all the parallel ports. Not good.
                //
                
                PRODUCT_TYPE pt;

                (void) lrGetProductType(&pt);

                if(     (PT_SERVER == pt)
                    &&  (RDT_Parallel != 
                        RAS_DEVICE_TYPE(pInfo->rdiDeviceInfo.eDeviceType)))
                {
                    lr = lrRasEnableDevice(
                                        hkey,
                                        TEXT("EnableForRas"),
                                        TRUE);

                    if(ERROR_SUCCESS == lr)
                    {
                        pInfo->rdiDeviceInfo.fRasEnabled = TRUE;
                    }
                }                                    
                else
                {
                    lr = lrRasEnableDevice(
                                        hkey,
                                        TEXT("EnableForRas"),
                                        FALSE);
                                        
                    if(ERROR_SUCCESS == lr)
                    {
                        pInfo->rdiDeviceInfo.fRasEnabled = FALSE;
                    }
                }
            }

            if(		(i == (DWORD) USAGE)
            	&&	(ERROR_SUCCESS == lr))
			{
			    if(1 == pInfo->dwUsage)
			    {
			        pInfo->dwUsage = CALL_OUT_ONLY;
			    }
			    else if(0 == pInfo->dwUsage)
			    {
			        pInfo->dwUsage = CALL_IN_ONLY;
			    }
			}
			else if(i == USAGE)
			{
			    pInfo->dwUsage = 0;
			    lr = ERROR_SUCCESS;
			}

            if(     (i == (DWORD) ROUTERENABLED)
                &&  (ERROR_FILE_NOT_FOUND == lr))
            {
                //
                // If this key is not found and its an ntserver
                // create it and default the device to be disabled
                // for routing
                //
                lr = lrRasEnableDevice( 
                                    hkey,
                                    TEXT("EnableForRouting"),
                                    FALSE);
                if(ERROR_SUCCESS == lr)
                {
                    pInfo->rdiDeviceInfo.fRouterEnabled = FALSE;
                }
            }

            if(     (i == (DWORD) OUTBOUNDROUTERENABLED)
                && (ERROR_FILE_NOT_FOUND == lr))
            {
                //
                // if this key is not found create it and default
                // to disabled.
                //
                lr = lrRasEnableDevice(
                                    hkey,
                                    TEXT("EnableForOutboundRouting"),
                                    FALSE);

                if(ERROR_SUCCESS == lr)
                {
                    pInfo->rdiDeviceInfo.fRouterOutboundEnabled = FALSE;
                }
            }

            if(     (i == (DWORD) MINWANENDPOINTS)
                &&  (ERROR_FILE_NOT_FOUND == lr))
            {
                pInfo->rdiDeviceInfo.dwMinWanEndPoints =
                    pInfo->rdiDeviceInfo.dwNumEndPoints;
            }

            if(     (i == (DWORD) MAXWANENDPOINTS)
                &&  (ERROR_FILE_NOT_FOUND == lr))
            {
                pInfo->rdiDeviceInfo.dwMaxWanEndPoints =
                    pInfo->rdiDeviceInfo.dwNumEndPoints;
            }

            if ( i == (DWORD) DESCRIPTION)
            {
                //
                // Convert the string to ansi-rastapi is not unicode
                //
                if (!WideCharToMultiByte (
                                CP_ACP,
                               0,
                               pInfo->rdiDeviceInfo.wszDeviceName,
                               -1,
                               pInfo->rdiDeviceInfo.szDeviceName,
                               MAX_DEVICE_NAME + 1,
                               NULL,
                               NULL))
                {
                    *pInfo->rdiDeviceInfo.szDeviceName = '\0';
                }
            }
        }
    }

    return lr;
}

DWORD DwGetCalledIdInfo(
        HKEY        hkeyDevice,
        DeviceInfo  *pInfo
        )
{
    LONG  lr     = ERROR_SUCCESS;
    DWORD dwSize = 0;
    DWORD dwType;
    HKEY  hkey   = NULL;
    HKEY hkeyRas = NULL;
            

    if(NULL == hkeyDevice)
    {   
        BOOL fModem = (RDT_Modem ==
                       RAS_DEVICE_TYPE(
                       pInfo->rdiDeviceInfo.eDeviceType));

        WCHAR wszModem[256] = {0};                        

        //
        // convert the ascii string to unicode before
        // passing it to the routine.
        //
        if(!MultiByteToWideChar(
                        CP_ACP,
                        0, 
                        pInfo->rdiDeviceInfo.szDeviceName,
                        -1, 
                        wszModem,
                        256))
        {   
            lr = (LONG) GetLastError();
            goto done;
        }
                        
        lr = lrGetRegKeyFromGuid(
                  (fModem) 
                ? (PBYTE) wszModem
                : (PBYTE) &pInfo->rdiDeviceInfo.guidDevice,
                &hkey,
                NULL,
                fModem);

        if(ERROR_SUCCESS != lr)
        {
            goto done;
        }

        if(fModem)
        {
            //
            // Open the Ras subkey
            //
            lr = RegOpenKeyEx( hkey,
                               TEXT("Clients\\Ras"),
                               0,
                               KEY_ALL_ACCESS,
                               &hkeyRas);
                               
            if(ERROR_SUCCESS != lr)                       
            {
                goto done;
            }

        }

        if(!fModem)
        {
            hkeyDevice = hkey;
        }
        else
        {
            hkeyDevice = hkeyRas;
        }
    }

    pInfo->pCalledID = NULL;
    
    //
    // Query the called id to get the size
    //
    if(     (ERROR_SUCCESS != (lr = RegQueryValueEx(
                                hkeyDevice,
                                REGISTRY_CALLEDID,
                                NULL,
                                &dwType,
                                NULL,
                                &dwSize)))
                                
        &&  (ERROR_MORE_DATA != lr))
    {
        goto done;
    }

    //
    // Allocate the called id structure
    //
    pInfo->pCalledID = (RAS_CALLEDID_INFO *) LocalAlloc(LPTR,
                                      sizeof(RAS_CALLEDID_INFO)
                                    + dwSize);

    if(NULL == pInfo->pCalledID)
    {
        lr = (LONG) GetLastError();
        goto done;
    }

    //
    // Query the called id again
    //
    if(ERROR_SUCCESS != (lr = RegQueryValueEx(
                                hkeyDevice,
                                REGISTRY_CALLEDID,
                                NULL,
                                &dwType,
                                pInfo->pCalledID->bCalledId,
                                &dwSize)))
    {
        goto done;
    }

    //
    // Save the size of the calledid
    //
    pInfo->pCalledID->dwSize = dwSize;

done:

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    if(NULL != hkeyRas)
    {
        RegCloseKey(hkeyRas);
    }

    if(     (ERROR_SUCCESS != lr)
        &&  (NULL != pInfo->pCalledID))
    {
        LocalFree(pInfo->pCalledID);

        pInfo->pCalledID = NULL;
    }

    if(ERROR_FILE_NOT_FOUND == lr)
    {
        lr = ERROR_SUCCESS;
    }

    return (DWORD) lr;
}

DWORD DwSetCalledIdInfo(
        HKEY hkeyDevice,
        DeviceInfo *pInfo
        )
{
    LONG lr = ERROR_SUCCESS;
    HKEY hkey = NULL;
    HKEY hkeyRas = NULL;

    //
    // the called id information should not be
    // null at this point
    //
    ASSERT(NULL != pInfo->pCalledID);

    if(NULL == hkeyDevice)
    {
        BOOL fModem = (RDT_Modem ==
                      RAS_DEVICE_TYPE(
                      pInfo->rdiDeviceInfo.eDeviceType));

        WCHAR wszModem[256] = {0};                        

        //
        // convert the ascii string to unicode before
        // passing it to the routine.
        //
        if(!MultiByteToWideChar(
                        CP_ACP,
                        0, 
                        pInfo->rdiDeviceInfo.szDeviceName,
                        -1, 
                        wszModem,
                        256))
        {   
            lr = (LONG) GetLastError();
            goto done;
        }
                        
        lr = lrGetRegKeyFromGuid(
                  (fModem) 
                ? (PBYTE) wszModem
                : (PBYTE) &pInfo->rdiDeviceInfo.guidDevice,
                &hkey,
                NULL,
                fModem);

        if(ERROR_SUCCESS != lr)
        {
            goto done;
        }

        if(fModem)
        {
            //
            // Open the Ras subkey
            //
            lr = RegOpenKeyEx( hkey,
                               TEXT("Clients\\Ras"),
                               0,
                               KEY_ALL_ACCESS,
                               &hkeyRas);
                               
            if(ERROR_SUCCESS != lr)                       
            {
                goto done;
            }
        }

        if(fModem)
        {
            hkeyDevice = hkeyRas;
        }
        else
        {
            hkeyDevice = hkey;
        }
    }
                             
    if(ERROR_SUCCESS != (lr = RegSetValueEx(
                                hkeyDevice,
                                REGISTRY_CALLEDID,
                                NULL,
                                REG_MULTI_SZ,
                                pInfo->pCalledID->bCalledId,
                                pInfo->pCalledID->dwSize)))
    {
        goto done;
    }

done:

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    if(NULL != hkeyRas)
    {
        RegCloseKey(hkeyRas);
    }

    return (DWORD) lr;

}

/*++

Routine Description:

    Reads the EndPoint information of the miniport instance
    specified by guid passed in from the registry
    
Arguments:

    pInfo - DeviceInfo to receive the information to be read
            from registry

    pbDeviceGuid - NetCfgInstanceId of the miniport instance
                   whose information is to be read

Return Value:

    Registry apis errors
    ERROR_SUCCESS if successful
    
--*/
DWORD 
DwGetEndPointInfo( DeviceInfo     *pInfo,
                   PBYTE          pbDeviceGuid )
{
    LONG    lr;
    HKEY    hkey = NULL;
    DWORD   dwInstanceNumber;

    lr = lrGetRegKeyFromGuid(pbDeviceGuid,
                             &hkey,
                             &dwInstanceNumber,
                             FALSE);

    if ( ERROR_SUCCESS != lr )
    {
        goto done;
    }

    lr = lrGetSetInfo(hkey,
                      pInfo,
                      TRUE);

    if( ERROR_SUCCESS != lr )
    {
        goto done;
    }
    
    lr = lrGetSetMaxEndPoints(
            &pInfo->rdiDeviceInfo.dwMaxOutCalls,
            &pInfo->rdiDeviceInfo.dwMaxInCalls,
            TRUE);

    pInfo->dwInstanceNumber = dwInstanceNumber;

    //
    // Get the calledid info if we don't have
    // one.
    //
    if(NULL == pInfo->pCalledID)
    {
        lr = DwGetCalledIdInfo(hkey,
                               pInfo);
    }

done:
    if ( hkey)
    {
        RegCloseKey(hkey);
    }

    return (DWORD) lr;
}

/*++

Routine Description:

    Writes the EndPoint information of the miniport instance
    specified by guid passed in from the registry
    
Arguments:

    pInfo - DeviceInfo with the information to be written
            to registry

    pbDeviceGuid - NetCfgInstanceId of the miniport instance
                   whose information is to be read

Return Value:

    Registry apis errors
    ERROR_SUCCESS if successful
    
--*/
DWORD
DwSetEndPointInfo( DeviceInfo *pInfo,
                   PBYTE      pbDeviceGuid)
{
    LONG lr;
    HKEY hkey = NULL;

    lr = lrGetRegKeyFromGuid(pbDeviceGuid,
                             &hkey, 
                             NULL,
                             FALSE);

    if ( ERROR_SUCCESS != lr )
    {
        goto done;
    }

    lr = lrGetSetInfo(hkey,
                      pInfo,
                      FALSE);
                      
    if(ERROR_SUCCESS != lr)
    {
        goto done;
    }

    //
    // Set the max endpoint information
    //
    lr = lrGetSetMaxEndPoints(
            &pInfo->rdiDeviceInfo.dwMaxOutCalls,
            &pInfo->rdiDeviceInfo.dwMaxInCalls,
            FALSE);

done:
    if ( hkey)
    {
        RegCloseKey(hkey);
    }

    return (DWORD) lr;
}

/*++

Routine Description:

    Writes the EndPoint information of the modem instance
    specified by the description passed in through pInfo.
    
Arguments:

    pInfo - Device Information for the modem that has to
            be written to registry.
            
Return Value:

    Errors returned from MultiByteToWideChar
    Registry apis errors
    ERROR_SUCCESS if successful
    
--*/
DWORD
DwSetModemInfo(DeviceInfo *pInfo)
{
    LONG    lr = ERROR_SUCCESS;
    
    HKEY    hkey = NULL;
    
    WCHAR   wszDesc[MAX_DEVICE_NAME + 1] = {0};
    
    CHAR    *pszDesc = pInfo->rdiDeviceInfo.szDeviceName;
    
    HKEY    hkeyRas = NULL;

    DWORD   dwData;

    //
    // Convert the description of modem
    // to wchar
    //
    if (0 == MultiByteToWideChar( CP_ACP,
                                  0,
                                  pszDesc,
                                  -1,
                                  wszDesc,
                                  strlen(pszDesc) + 1))
    {
        lr = (LONG) GetLastError();
        goto done;
    }

    //
    // Get the modems instance key
    //
    lr = lrGetRegKeyFromGuid( (PBYTE) wszDesc,
                              &hkey,
                              NULL,
                              TRUE);

    if(     ERROR_SUCCESS != lr                              
        ||  NULL == hkey)
    {
        goto done;
    }

    //
    // Open the Ras subkey
    //
    lr = RegOpenKeyEx( hkey,
                       TEXT("Clients\\Ras"),
                       0,
                       KEY_ALL_ACCESS,
                       &hkeyRas);
                       
    if(ERROR_SUCCESS != lr)                       
    {
        goto done;
    }

    //
    // Set the value of the RasEnabled to whatever was
    // passed in
    //
    lr = RegSetValueEx(hkeyRas,
                       TEXT("EnableForRas"),
                       0,
                       REG_DWORD,
                       (PBYTE)
                       &pInfo->rdiDeviceInfo.fRasEnabled,
                       sizeof(DWORD));

    if(ERROR_SUCCESS != lr)
    {
        goto done;
    }

    //
    // Set the value of RouterEnabled to whatever was
    // passed in
    //
    lr = RegSetValueEx(hkeyRas,
                       TEXT("EnableforRouting"),
                       0,
                       REG_DWORD,
                       (PBYTE)
                       &pInfo->rdiDeviceInfo.fRouterEnabled,
                       sizeof(DWORD));

    if(ERROR_SUCCESS != lr)
    {
        goto done;
    }

done:
    if(hkey)
    {
        RegCloseKey(hkey);
    }

    if(hkeyRas)
    {
        RegCloseKey(hkeyRas);
    }
    
    return (DWORD) lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\dll\dlparams.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name: 

    dlparams.c

Abstract:

    Routines for storing and retrieving user Lsa secret
    dial parameters.

Author:

    Gurdeep Singh Pall (gurdeep) 06-Jun-1997

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#define RASMXS_DYNAMIC_LINK

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <llinfo.h>
#include <rasman.h>
#include <lm.h>
#include <lmwksta.h>
#include <wanpub.h>
#include <raserror.h>
// #include <rasarp.h>
#include <media.h>
#include <device.h>
#include <stdlib.h>
#include <string.h>
#include <ntlsa.h>

#define MAX_REGISTRY_VALUE_LENGTH   ((64*1024) - 1)

#define cszEapKeyRas   TEXT("Software\\Microsoft\\RAS EAP\\UserEapInfo")

#define cszEapKeyRouter TEXT("Software\\Microsoft\\Router EAP\\IfEapInfo")

#define cszEapValue TEXT("EapInfo")

#define EAP_SIG         0x31504145
#define EAP_SIG_2       0x32504145

typedef struct _EAP_USER_INFO
{
    DWORD dwSignature;
    DWORD dwEapTypeId;
    GUID  Guid;
    DWORD dwSize;
    BYTE  abdata[1];
} EAP_USER_INFO, *PEAP_USER_INFO;

typedef struct _EAP_USER_INFO_0
{
    DWORD dwUID;
    DWORD dwSize;
    BYTE  abdata[1];
} EAP_USER_INFO_0, *PEAP_USER_INFO_0;
            

DWORD
DwGetSidFromHtoken(
        HANDLE hToken,
        PWCHAR pszSid,
        USHORT cbSid
        )
{    
    DWORD cbNeeded, dwErr;
    BOOL  fThreadTokenOpened = FALSE;
    
    UNICODE_STRING unicodeString;
    
    TOKEN_USER *pUserToken = NULL;

    if(     (NULL == hToken)
        ||  (INVALID_HANDLE_VALUE == hToken))
    {
        fThreadTokenOpened = TRUE;

        if (!OpenThreadToken(
              GetCurrentThread(),
              TOKEN_QUERY,
              TRUE,
              &hToken))
        {
            dwErr = GetLastError();
            if (dwErr == ERROR_NO_TOKEN) 
            {
                //
                // This means we are not impersonating
                // anyone.  Instead, get the token out
                // of the process.
                //
                if (!OpenProcessToken(
                      GetCurrentProcess(),
                      TOKEN_QUERY,
                      &hToken))
                {
                    return GetLastError();
                }
            }
            else
            {
                return dwErr;
            }
        }
    }
    
    //
    // Call GetTokenInformation once to determine
    // the number of bytes needed.
    //
    cbNeeded = 0;
    
    GetTokenInformation(hToken,
                        TokenUser,
                        NULL, 0,
                        &cbNeeded);
    if (!cbNeeded) 
    {
        dwErr = GetLastError();
        goto done;
    }
    
    //
    // Allocate the memory and call it again.
    //
    pUserToken = LocalAlloc(LPTR, cbNeeded);
    
    if (pUserToken == NULL)
    {
        return GetLastError();
    }
    
    if (!GetTokenInformation(
          hToken,
          TokenUser,
          pUserToken,
          cbNeeded,
          &cbNeeded))
    {
        dwErr = GetLastError();
        goto done;
    }
    
    //
    // Format the SID as a Unicode string.
    //
    unicodeString.Length = 0;
    
    unicodeString.MaximumLength = cbSid;
    
    unicodeString.Buffer = pszSid;
    
    dwErr = RtlConvertSidToUnicodeString(
              &unicodeString,
              pUserToken->User.Sid,
              FALSE);

done:
    if (pUserToken != NULL)
    {
        LocalFree(pUserToken);
    }
    
    if (    (NULL != hToken)
        &&  (INVALID_HANDLE_VALUE != hToken)
        &&  fThreadTokenOpened)
    {
        CloseHandle(hToken);
    }

    return dwErr;
}

DWORD
GetUserSid(
    IN PWCHAR pszSid,
    IN USHORT cbSid
    )
{
    return DwGetSidFromHtoken(NULL,
                              pszSid,
                              cbSid);
}

LONG
lrGetEapKeyFromToken(HANDLE hToken,
                     HKEY   *phkey)
{
    LONG lr = ERROR_SUCCESS;

    WCHAR szSid[260];

    HKEY hkeyUser = NULL;

    HKEY hkeyEap = NULL;

    DWORD dwDisposition;

    ASSERT(NULL != phkey);

    //
    // Get sid of the user from the htoken
    // 
    lr = (LONG) DwGetSidFromHtoken(hToken,
                                   szSid,
                                   sizeof(szSid));

    if(ERROR_SUCCESS != lr)
    {
        goto done;
    }

    //
    // Open the users registry key
    //
    lr = RegOpenKeyExW(HKEY_USERS,
                       szSid,
                       0,
                       KEY_ALL_ACCESS,
                       &hkeyUser);

     if(ERROR_SUCCESS != lr)
     {
        goto done;
     }

     //
     // Create the eap key if required.
     //
     lr = RegCreateKeyEx(hkeyUser,
                         cszEapKeyRas,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hkeyEap,
                         &dwDisposition);

    if(ERROR_SUCCESS != lr)
    {
        goto done;
    }
                    

done:

    if(NULL != hkeyUser)
    {
        RegCloseKey(hkeyUser);
    }

    *phkey = hkeyEap;

    return lr;
    
}

DWORD
DwUpgradeEapInfo(PBYTE *ppbInfo, 
                 DWORD *pdwSize)
{
    BYTE *pbInfo;
    DWORD dwErr = ERROR_SUCCESS;
    EAP_USER_INFO UNALIGNED *pEapInfo;
    DWORD dwSize;
    DWORD dwRequiredSize = 0;
    BYTE *pbNewInfo = NULL;
    EAP_USER_INFO *pNewEapInfo;
    
    if(     (NULL == ppbInfo)
        ||  (NULL == pdwSize))
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    dwSize = *pdwSize;
    pbInfo = *ppbInfo;
    pEapInfo = (EAP_USER_INFO *) pbInfo;

    while((BYTE *) pEapInfo < pbInfo + dwSize)
    {
        dwRequiredSize += RASMAN_ALIGN8(
                          sizeof(EAP_USER_INFO)
                        + pEapInfo->dwSize);

        ((PBYTE) pEapInfo) += (sizeof(EAP_USER_INFO)
                              + pEapInfo->dwSize);  
    }

    pbNewInfo = LocalAlloc(LPTR, dwRequiredSize);

    if(NULL == pbNewInfo)
    {
        dwErr = GetLastError();
        goto done;
    }

    pEapInfo = (EAP_USER_INFO *) pbInfo;
    pNewEapInfo = (EAP_USER_INFO *) pbNewInfo;

    while((BYTE *) pEapInfo < pbInfo + dwSize)
    {
        CopyMemory(
            (BYTE *) pNewEapInfo,
            (BYTE *) pEapInfo,
            sizeof(EAP_USER_INFO) + pEapInfo->dwSize);

        pNewEapInfo->dwSignature = EAP_SIG_2;

        (BYTE *) pNewEapInfo += RASMAN_ALIGN8(sizeof(EAP_USER_INFO)
                            + pEapInfo->dwSize);

        (BYTE *) pEapInfo += (sizeof(EAP_USER_INFO) + pEapInfo->dwSize);
    }

    *ppbInfo = pbNewInfo;
    *pdwSize = dwRequiredSize;

    if(NULL != pbInfo)
    {
        LocalFree(pbInfo);
    }

done:
    return dwErr;
}

DWORD
DwGetEapInfo(HANDLE hToken,
             BOOL  fRouter,
             PBYTE *ppbInfo,
             DWORD *pdwSize,
             HKEY  *phkey
             )
{
    LONG lr = ERROR_SUCCESS;

    HKEY hkey = NULL;

    DWORD dwDisposition;

    DWORD dwInfoSize = 0;

    DWORD dwType;

    PBYTE pbInfo = NULL;

    if(     (NULL == ppbInfo)
        ||  (NULL == pdwSize))
    {
        lr = (LONG) E_INVALIDARG;
        goto done;
    }

    if(     (NULL != hToken)
        &&  (INVALID_HANDLE_VALUE != hToken)
        &&  !fRouter)
    {
        //
        // If a valid token is passed then its most likely
        // a service trying to open users registry. Get the
        // sid of the user and open HKU in this case.
        //
        if(ERROR_SUCCESS != (lr = lrGetEapKeyFromToken(hToken,
                                  &hkey)))
        {
            goto done;
        }
    }
    else
    {
        //
        // Open the key. Create the key if its not present
        //
        if(ERROR_SUCCESS != (lr = RegCreateKeyEx(
                                    (fRouter)
                                  ? HKEY_LOCAL_MACHINE
                                  : HKEY_CURRENT_USER,
                                    (fRouter)
                                  ? cszEapKeyRouter
                                  : cszEapKeyRas,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hkey,
                                    &dwDisposition)))
        {
            goto done;
        }
    }

    //
    // Get size of the binary value. If the value is not
    // found, return no information. This value will be
    // set the first time we store any eap information.
    //
    if(     (ERROR_SUCCESS != (lr = RegQueryValueEx(
                                    hkey,
                                    cszEapValue,
                                    NULL,
                                    &dwType,
                                    NULL,
                                    &dwInfoSize)))
        &&  (ERROR_SUCCESS != lr))                                    
    {
        goto done;
    }

#if DBG
    ASSERT(REG_BINARY == dwType);
#endif

    //
    // Allocate a buffer to hold the binary value
    //
    pbInfo = LocalAlloc(LPTR, dwInfoSize);
    if(NULL == pbInfo)
    {
        lr = (LONG) GetLastError();
        goto done;
    }

    //
    // Get the binary value
    //
    if(ERROR_SUCCESS != (lr = RegQueryValueEx(
                                hkey,
                                cszEapValue,
                                NULL,
                                &dwType,
                                pbInfo,
                                &dwInfoSize)))
    {
        goto done;
    }

done:

    if(NULL != phkey)
    {
        *phkey = hkey;
    }
    else if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    if(NULL != ppbInfo)
    {
        *ppbInfo = pbInfo;
    }
    else if(NULL != pbInfo)
    {
        LocalFree(pbInfo);
    }

    if(NULL != pdwSize)
    {
        *pdwSize = dwInfoSize;
    }

    if(ERROR_FILE_NOT_FOUND == lr)
    {
        lr = ERROR_SUCCESS;
    }

    return (DWORD) lr;
}

DWORD
DwSetEapInfo(HKEY hkey,
             PBYTE pbInfo,
             DWORD dwSize)
{
    LONG lr = ERROR_SUCCESS;

    if(ERROR_SUCCESS != (lr = RegSetValueEx(
                                hkey,
                                cszEapValue,
                                0,
                                REG_BINARY,
                                pbInfo,
                                dwSize)))
    {
        goto done;
    }

done:
    return (DWORD) lr;
}

DWORD
DwRemoveEapUserInfo(GUID   *pGuid,
                    PBYTE  pbInfo,
                    PDWORD pdwSize,
                    HKEY   hkey,
                    BOOL   fWrite,
                    DWORD  dwEapTypeId)
{
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwcb = 0;

    EAP_USER_INFO *pEapInfo = (EAP_USER_INFO *) pbInfo;

    DWORD dwNewSize;

    DWORD dwSize = *pdwSize;

    //
    // Find the binary blob with the
    // UID
    //
    while(dwcb < dwSize)
    {
        if(     (0 == memcmp(
                        (PBYTE) pGuid, 
                        (PBYTE) &pEapInfo->Guid, 
                        sizeof(GUID)))
            &&  (dwEapTypeId == pEapInfo->dwEapTypeId))
        {
            break;
        }

        dwcb += RASMAN_ALIGN8((sizeof(EAP_USER_INFO) + pEapInfo->dwSize));

        pEapInfo = (EAP_USER_INFO *) (pbInfo + dwcb);
    }
    
    if(dwcb >= dwSize)
    {
        goto done;
    }

#if DBG
    ASSERT(dwSize >= dwcb 
                  + RASMAN_ALIGN8(pEapInfo->dwSize 
                  + sizeof(EAP_USER_INFO)));
#endif    

    dwNewSize = dwSize - 
        RASMAN_ALIGN8(pEapInfo->dwSize + sizeof(EAP_USER_INFO));

    //
    // Remove the info
    //
    MoveMemory(
        pbInfo + dwcb,
        pbInfo + dwcb 
               + RASMAN_ALIGN8(sizeof(EAP_USER_INFO) + pEapInfo->dwSize),
        dwSize - dwcb 
               - RASMAN_ALIGN8(sizeof(EAP_USER_INFO) + pEapInfo->dwSize));

    if(fWrite)
    {

        dwErr = DwSetEapInfo(
                    hkey,
                    pbInfo,
                    dwNewSize);
    }
    else
    {
        *pdwSize = dwNewSize;
    }

done:
    return dwErr;
    
}

DWORD
DwReplaceEapUserInfo(GUID  *pGuid,
                     PBYTE pbUserInfo,
                     DWORD dwUserInfo,
                     PBYTE pbInfo,
                     DWORD dwSize,
                     HKEY  hkey,
                     DWORD dwEapTypeId)
{
    DWORD dwErr = ERROR_SUCCESS;

    DWORD dwNewSize = dwSize;

    PBYTE pbNewInfo = NULL;

    EAP_USER_INFO UNALIGNED *pEapInfo;

    if(NULL == pGuid)
    {
        ASSERT(FALSE);
        goto done;
    }

    //
    // Remove the existing eap information corresponding
    // to dwUID if any.
    //
    if(ERROR_SUCCESS != (dwErr = DwRemoveEapUserInfo(
                                    pGuid,
                                    pbInfo,
                                    &dwNewSize,
                                    hkey,
                                    FALSE,
                                    dwEapTypeId)))
    {
        goto done;
    }

    //
    // Local Alloc a new blob with enough space for the
    // eap information of the new entry
    //
    pbNewInfo = LocalAlloc(LPTR,
                           dwNewSize 
                         + RASMAN_ALIGN8(sizeof(EAP_USER_INFO) 
                         +  dwUserInfo));

    if(NULL == pbNewInfo)
    {   
        dwErr = GetLastError();
        goto done;
    }

    RtlCopyMemory(
            pbNewInfo,
            pbInfo,
            dwNewSize);

    pEapInfo = (EAP_USER_INFO *) (pbNewInfo + dwNewSize);
    pEapInfo->Guid = *pGuid;
    pEapInfo->dwEapTypeId = dwEapTypeId;
    pEapInfo->dwSize = dwUserInfo;
    pEapInfo->dwSignature = EAP_SIG_2;

    dwNewSize += RASMAN_ALIGN8((sizeof(EAP_USER_INFO) + dwUserInfo));

    RtlCopyMemory(
            pEapInfo->abdata,
            pbUserInfo,
            dwUserInfo);

    dwErr = DwSetEapInfo(
                    hkey,
                    pbNewInfo,
                    dwNewSize);
            
done:

    if(NULL != pbNewInfo)
    {
        LocalFree(pbNewInfo);
    }

    return dwErr;
}
        

DWORD
DwSetEapUserInfo(HANDLE hToken,
                 GUID  *pGuid,
                 PBYTE pbUserInfo,
                 DWORD dwInfoSize,
                 BOOL  fClear,
                 BOOL  fRouter,
                 DWORD dwEapTypeId)
{
    DWORD dwErr = ERROR_SUCCESS;

    PBYTE pbInfo = NULL;

    DWORD dwSize = 0;

    HKEY hkey = NULL;

    if(NULL == pGuid)
    {
        ASSERT(FALSE);
        goto done;
    }

    if(ERROR_SUCCESS != (dwErr = DwGetEapInfo(
                                    hToken,
                                    fRouter,
                                    &pbInfo,
                                    &dwSize,
                                    &hkey)))
    {
        goto done;
    }

#if DBG
    ASSERT(NULL != hkey);
#endif

    //
    // Check to see if the blob is one we recognize
    //
    if(     !fClear
        &&  (   (sizeof(DWORD) > dwSize)
            ||  (((*((DWORD *) pbInfo)) != EAP_SIG))
            &&  ( (*((DWORD *) pbInfo)) != EAP_SIG_2)))
    {
        EAP_USER_INFO *pEapInfo;
        
        //
        // Upgrade?? How? We will just blow away all the old data.
        //
        pEapInfo = (EAP_USER_INFO *) LocalAlloc(LPTR,
                               RASMAN_ALIGN8(
                               sizeof(EAP_USER_INFO) 
                             + dwInfoSize));

        if(NULL == pEapInfo)
        {   
            dwErr = GetLastError();
            goto done;
        }

        pEapInfo->Guid = *pGuid;
        pEapInfo->dwEapTypeId = dwEapTypeId;
        pEapInfo->dwSize = dwInfoSize;
        pEapInfo->dwSignature = EAP_SIG_2;

        RtlCopyMemory(
                pEapInfo->abdata,
                pbUserInfo,
                dwInfoSize);
        
        dwErr = DwSetEapInfo(hkey,
                     (PBYTE) pEapInfo,
                     RASMAN_ALIGN8(sizeof(EAP_USER_INFO)
                     + dwInfoSize));
                     
        goto done;
    }
    else if (   (fClear)
            &&  (   (sizeof(DWORD) > dwSize)
                ||  (((*((DWORD *) pbInfo)) != EAP_SIG))
                &&  ( (*((DWORD *) pbInfo)) != EAP_SIG_2)))
    {
        //
        // Blow away the old information
        //
        dwErr = RegDeleteValue(
                    hkey,
                    cszEapValue);

        goto done;                    
    }

    if(*((DWORD *) pbInfo) == EAP_SIG)
    {
        //
        // upgrade the blob so that its aligned
        // at 8-byte boundaries
        // 
        dwErr = DwUpgradeEapInfo(&pbInfo, &dwSize);

        if(ERROR_SUCCESS != dwErr)
        {
            goto done;
        }
    }

    if(fClear)
    {
        dwErr = DwRemoveEapUserInfo(pGuid,
                                    pbInfo,
                                    &dwSize,
                                    hkey,
                                    TRUE,
                                    dwEapTypeId);
    }
    else
    {
        dwErr = DwReplaceEapUserInfo(
                             pGuid,
                             pbUserInfo,
                             dwInfoSize,
                             pbInfo,
                             dwSize,
                             hkey,
                             dwEapTypeId);
    }

done:

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }


    if(NULL != pbInfo)
    {
        LocalFree(pbInfo);
    }

    return dwErr;
}

DWORD
DwGetEapUserInfo(HANDLE hToken,
                 PBYTE pbEapInfo,
                 DWORD *pdwInfoSize,
                 GUID  *pGuid,
                 BOOL  fRouter,
                 DWORD dwEapTypeId)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    PBYTE pbInfo = NULL;

    DWORD dwSize;

    DWORD dwcb = 0;

    EAP_USER_INFO UNALIGNED *pEapUserInfo = NULL;

    HKEY hkey = NULL;

    if(NULL == pdwInfoSize)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    // *pdwInfoSize = 0;

    if(NULL == pGuid)
    {
        ASSERT(FALSE);
        *pdwInfoSize = 0;
        goto done;
    }

    //
    // Get the binary blob from the registry
    //
    dwErr = DwGetEapInfo(hToken,
                         fRouter,
                         &pbInfo,
                         &dwSize,
                         &hkey);

    if(     (ERROR_SUCCESS != dwErr)
        ||  (0 == dwSize))
    {
        goto done;
    }

    //
    // Check to see if the blob is one we recognize
    //
    if(     (sizeof(DWORD) > dwSize)
        ||  (((*((DWORD *) pbInfo)) != EAP_SIG)
        &&  ( (*((DWORD *) pbInfo)) != EAP_SIG_2)))
    {
        //
        // Upgrade?? How? We will just blow away all the old data.
        //
        RegDeleteValue(hkey, cszEapValue);

        *pdwInfoSize = 0;                        
        goto done;
    }

    if(*((DWORD *) pbInfo) == EAP_SIG)
    {
        //
        // Upgrade the blob so that its
        // aligned correctly.
        //
        dwErr = DwUpgradeEapInfo(&pbInfo, &dwSize);
        if(ERROR_SUCCESS != dwErr)
        {
            goto done;
        }
    }

    //
    // Loop through the binary blob and look for the
    // eap info corresponding to the UID passed in.
    //
    pEapUserInfo = (EAP_USER_INFO *) pbInfo;

    while(dwcb < dwSize)
    {
        if(     (0 == memcmp(
                        (PBYTE) pGuid, 
                        (PBYTE) &pEapUserInfo->Guid, 
                        sizeof(GUID)))
            &&  (dwEapTypeId == pEapUserInfo->dwEapTypeId))
        {
            break;
        }

        dwcb += RASMAN_ALIGN8((sizeof(EAP_USER_INFO) 
                    + pEapUserInfo->dwSize));
        
        pEapUserInfo = (EAP_USER_INFO *) (pbInfo + dwcb);
    }

    if(dwcb >= dwSize)
    {
        *pdwInfoSize = 0;
        goto done;
    }

    if(     (NULL != pbEapInfo)
        &&  (*pdwInfoSize >= pEapUserInfo->dwSize))
    {
        RtlCopyMemory(pbEapInfo,
                   pEapUserInfo->abdata,
                   pEapUserInfo->dwSize);
    }
    else
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    *pdwInfoSize = pEapUserInfo->dwSize;

done:    

    if(NULL != pbInfo)
    {
        LocalFree(pbInfo);
    }

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\dll\dllinit.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name: 

    dllinit.c

Abstract:

    This file contains init code called from DLL's init routine    
    
Author:

    Gurdeep Singh Pall (gurdeep) 06-Jun-1997

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <raserror.h>
#include <rasppp.h>
#include <media.h>
#include <devioctl.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"

/*++

Routine Description

  Function: Used to close any open ports when rasman exits

Arguments

Return Value

    FALSE to allow other handlers to run.
--*/

BOOL
HandlerRoutine (DWORD ctrltype)
{
    WORD    i ;
    BYTE    buffer [10] ;

    if (ctrltype == CTRL_SHUTDOWN_EVENT) 
    {
    } 

    return FALSE ;
}

/*++

Routine Description

    Used to check if the service is already running: if not,
    to start it.

Arguments

Return Value

    SUCCESS
    1	(failure to start)
    Error codes from service control APIs. "
    
--*/
/*
DWORD
RasmanServiceCheck()
{
    SC_HANDLE	    schandle ;
    SC_HANDLE	    svchandle ;
    SERVICE_STATUS  status ;
    STARTUPINFO     startupinfo ;
    
    //
    // If this is the Service DLL attaching, let it: no
    // initializations required. NOTE: We do not increment
    // AttachedCount for RASMAN service: its used *only* 
    // for rasman client processes like UI, Gateway, etc.
    //
    GetStartupInfo(&startupinfo) ;

    if (strstr (startupinfo.lpTitle, SCREG_EXE_NAME) != NULL)
    {
    	return SUCCESS ;
    }

    if (strstr (startupinfo.lpTitle, RASMAN_EXE_NAME) != NULL) 
    {
    	SetConsoleCtrlHandler (HandlerRoutine, TRUE) ;
    	return SUCCESS ;
    }
    
    //
    // This is put in as a work-around for the SC bug which
    // does not allow OpenService call to be made when 
    // Remoteaccess is starting
    //
    if (strstr (startupinfo.lpTitle, "rassrv.exe") != NULL)
    {
    	return SUCCESS ;
    }

    //
    // Get handles to check status of service and (if it
    // is not started -) to start it.
    //
    if (    !(schandle  = OpenSCManager(
                                NULL,
                                NULL,
                                SC_MANAGER_CONNECT)) 
                                
        ||	!(svchandle = OpenService(
                                schandle,
                                RASMAN_SERVICE_NAME,
                                 SERVICE_START 
                                |SERVICE_QUERY_STATUS)))
    {
        DWORD retcode;
        
        retcode = GetLastError();

#if DBG
        RasmanOutputDebug("RASMAN: Failed to openservice %s. error=%d\n",
                 RASMAN_SERVICE_NAME,
                 retcode );
#endif

        if (ERROR_SERVICE_DOES_NOT_EXIST == retcode)
        {

#if DBG        
            RasmanOutputDebug ("RASMAN: RAS is not installed. %d\n",
                      retcode);
#endif

            //
            // let rasman.dll load eventhough RAS is not
            // installed. Any Ras call when made through
            // this dll will fail with rasman service not
            // installed error.
            //
        	return SUCCESS;
    	}

    	return retcode;
    }

    //
    // Check if service is already starting:
    //
    if (QueryServiceStatus(svchandle,&status) == FALSE)
    {
        DWORD retcode;

        retcode = GetLastError();

#if DBG
        RasmanOutputDebug ("RASMAN: Failed to query rasman. %d\n",
                  retcode );
#endif

	    return retcode;
	}

    switch (status.dwCurrentState) 
    {
        case SERVICE_STOPPED:
        
            	break ;

        case SERVICE_START_PENDING:
        case SERVICE_RUNNING:
        	break ;

        default:
    	    return 1 ;
    }

    CloseServiceHandle (schandle) ;
    CloseServiceHandle (svchandle) ;
    
    return SUCCESS ;
} */


/*++

Routine Description

    Waits until the rasman service is stopped before returning.

Arguments

Return Value

    Nothing.
    
--*/

VOID
WaitForRasmanServiceStop ()
{
    SC_HANDLE	    schandle = NULL;
    SC_HANDLE	    svchandle = NULL;
    SERVICE_STATUS  status ;
    DWORD i;

    //
    // Get handles to check status of service
    //
    if (    !(schandle  = OpenSCManager(
                                    NULL,
                                    NULL,
                                    SC_MANAGER_CONNECT)) 
                                    
        ||	!(svchandle = OpenService(
                                    schandle,
                                    RASMAN_SERVICE_NAME,
                                      SERVICE_START 
                                    | SERVICE_QUERY_STATUS))) 
    {
    	GetLastError() ;
    	goto done ;
    }

    //
    // Loop here for the service to stop.
    //
    for (i = 0; i < 60; i++) 
    {
        //
    	// Check if service is already starting:
    	//
    	if (QueryServiceStatus(svchandle,&status) == FALSE) 
    	{
    	    GetLastError () ;
    	    goto done ;
    	}

    	switch (status.dwCurrentState) 
    	{
        	case SERVICE_STOPPED:
        	    goto done ;

        	case SERVICE_STOP_PENDING:
        	case SERVICE_RUNNING:
        	    Sleep (250L) ;
        	    break ;

        	default:
        	    goto done ;
    	}
    }

done:

    if(NULL != schandle)
    {
        CloseServiceHandle(schandle);
    }

    if(NULL != svchandle)
    {
        CloseServiceHandle(svchandle);
    }

    return;    
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\dll\globals.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  6/8/92  Gurdeep Singh Pall  Created
//
//
//  Description: This file contains all globals entities used in rasman32.
//
//****************************************************************************


DWORD    GlobalError ;

HANDLE   hLogEvents;


DWORD TraceHandle ;             // Trace Handle used for traces/logging

FARPROC g_fnServiceRequest;

HINSTANCE hInstRasmans;

RequestBuffer *g_pRequestBuffer;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\dll\rpc.c ===
#include "rasrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\dll\submit.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name: 

    dlparams.c

Abstract:

    Contains the code for submitting rpc request to the 
    rasman service
    
Author:

    Gurdeep Singh Pall (gurdeep) 06-Jun-1997

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <raserror.h>
#include <rasppp.h>
#include <media.h>
#include <devioctl.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "ras.h"   // for RAS_STATS structure
#include "rasapip.h"

DWORD
AllocateBuffer(DWORD dwSize, 
               PBYTE *ppbuf, 
               PDWORD pdwSizeofBuffer)
{
    DWORD retcode = SUCCESS;
    DWORD dwSizeRequired;

    *ppbuf = NULL;

    dwSizeRequired = dwSize + 
                     sizeof( RequestBuffer ) + 
                     sizeof (REQTYPECAST);

    if ( dwSizeRequired <= *pdwSizeofBuffer )
    {
        goto done;
    }

    *ppbuf = LocalAlloc(LPTR, dwSizeRequired);

    if ( NULL == *ppbuf )
    {
        retcode = GetLastError();
        goto done;
    }

    ((RequestBuffer *) *ppbuf)->RB_Dummy = sizeof(ULONG_PTR);

    *pdwSizeofBuffer = dwSizeRequired;

done:
    return retcode;
    
}

/* SubmitRequest ()

Function: This function submits the different types
          of requests and waits for their completion.
          Since the different requests require different 
          number of arguments and require different 
          information to be passed to and from the 
          Requestor thread - case statements are
          used to send and retrieve information in 
          the request buffer.

Returns:  Error codes returned by the request.

*/
DWORD _cdecl
SubmitRequest (HANDLE hConnection, WORD reqtype, ...)
{
    RequestBuffer   *preqbuf ;
    DWORD           retcode ;
    DWORD           i ;
    va_list         ap ;
    RequestBuffer   *pBuffer = NULL;
    DWORD           *pdwSize;
    DWORD           *pdwEntries;
    DWORD           dwSizeofBuffer = sizeof ( RequestBuffer ) 
                                   + REQUEST_BUFFER_SIZE;
    RequestBuffer   *pbTemp;
    PBYTE           pUserBuffer;
    PDWORD          pdwVersion;
    PDWORD          pdwMaskDialParams;
    PDWORD          pdwFlags = 0;

    preqbuf = GetRequestBuffer();

    if (NULL == preqbuf)
    {
        //
    	// couldn't get a req. buffer. can't do
    	// much in this case. this can happen
    	// if we are not able to initialize the
    	// shared memory.
    	//
    	return GetLastError();
    }

    va_start (ap, reqtype) ;
    
    preqbuf->RB_Reqtype = reqtype;
    preqbuf->RB_Dummy = sizeof(ULONG_PTR);

    pbTemp = preqbuf;

    switch (reqtype) 
    { 
    case REQTYPE_DEVICEENUM:
    {
        PCHAR   devicetype  = va_arg( ap, PCHAR ) ;

        pdwSize      = va_arg(ap, PDWORD );

        pUserBuffer = va_arg( ap, PBYTE );

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }
        
        if ( *pdwSize )
        {
            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);

            if(retcode) 
            {   //
                // failed to allocate
                //
                goto done;
            }

            if (pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
            
        }
        else
        {
            pbTemp = preqbuf;
        }

        ((REQTYPECAST *) pbTemp->RB_Buffer )->DeviceEnum.dwsize 
                                                        = *pdwSize;            

        memcpy (((REQTYPECAST *)
                pbTemp->RB_Buffer)->DeviceEnum.devicetype,
                devicetype,
                MAX_DEVICETYPE_NAME) ;
                        
    }
    break ;

    case REQTYPE_DEVICECONNECT:
    {
        HPORT  porthandle = va_arg(ap, HPORT);
        PCHAR  devicetype = va_arg(ap, PCHAR);
        PCHAR  devicename = va_arg(ap, PCHAR);
        DWORD  timeout    = va_arg(ap, DWORD);
        HANDLE handle     = va_arg(ap, HANDLE);
        DWORD  pid        = va_arg(ap, DWORD);

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle) ;
        
        strcpy(((REQTYPECAST *)
                preqbuf->RB_Buffer)->DeviceConnect.devicetype,
                devicetype) ;
               
        strcpy(((REQTYPECAST *)
                preqbuf->RB_Buffer)->DeviceConnect.devicename,
                devicename) ;
               
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->DeviceConnect.timeout = timeout;
                                                                
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->DeviceConnect.handle = handle;
                                                                
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->DeviceConnect.pid = pid;
    }
    break ;

    case REQTYPE_DEVICEGETINFO:
    {
        HPORT  porthandle = va_arg(ap, HPORT) ;
        PCHAR  devicetype = va_arg(ap, PCHAR) ;
        PCHAR  devicename = va_arg(ap, PCHAR) ;

        pUserBuffer = va_arg( ap, PBYTE );

        pdwSize = va_arg( ap, PDWORD );

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }
        
        if ( *pdwSize )
        {

            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);

            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;             
            }
            
        }
        else
        {
            pbTemp = preqbuf;
        }

        pbTemp->RB_PCBIndex = PtrToUlong( porthandle) ;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->DeviceGetInfo.dwSize = (DWORD) *pdwSize;
        
        strcpy(((REQTYPECAST *)
                pbTemp->RB_Buffer)->DeviceGetInfo.devicetype,
                devicetype) ;
               
        strcpy(((REQTYPECAST *)
               pbTemp->RB_Buffer)->DeviceGetInfo.devicename,
               devicename) ;
               
    }
    break ;

    case REQTYPE_GETINFOEX:
    {
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->InfoEx.pid = GetCurrentProcessId();
    }
    break;

    case REQTYPE_PORTENUM:
    {
        pdwSize = va_arg ( ap, DWORD * );

        pUserBuffer = (PBYTE ) va_arg ( ap, PBYTE ) ;

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }
        
        if ( *pdwSize )
        {
        
            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);

            if ( retcode )
            {
                goto done;
            }

            if ( pBuffer )
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;                
            }

        }
        else
        {
            //
            // Use default buffer
            //
            pbTemp = preqbuf;
        }

        ((REQTYPECAST *) 
        pbTemp->RB_Buffer)->Enum.size = *pdwSize;
    
    }
    break;
    
    case REQTYPE_ENUMCONNECTION:
    {
    
        pdwSize = va_arg ( ap, DWORD * );

        pUserBuffer = (PBYTE ) va_arg ( ap, HCONN * ) ;

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }
        
        if ( *pdwSize )
        {
            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);
            if (retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;                
                pbTemp = pBuffer;                
            }
        }
        else
        {
            //
            // Use default buffer
            //
            pbTemp = preqbuf;
        }

        ((REQTYPECAST *) 
        pbTemp->RB_Buffer)->Enum.size = *pdwSize;
        
    }
    break;
    
    case REQTYPE_PROTOCOLENUM:
    {
        pdwSize = va_arg ( ap, DWORD * );

        pUserBuffer = (PBYTE ) va_arg ( ap, PBYTE ) ;

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }
        
        if ( *pdwSize )
        {
            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);
            if(retcode)
            {   
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;                
            }

        }
        else
        {
            //
            // Use default buffer
            //
            pbTemp = preqbuf;
        }

        ((REQTYPECAST *) 
        pbTemp->RB_Buffer)->Enum.size = *pdwSize;
        
    }
    break;
    
    case REQTYPE_ENUMLANNETS:
    case REQTYPE_GETATTACHEDCOUNT:
    break ;

    case REQTYPE_RETRIEVEUSERDATA:
    {
        HPORT porthandle = va_arg ( ap, HPORT );

        pUserBuffer = va_arg ( ap, PBYTE );
        pdwSize = va_arg ( ap, DWORD * );

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }
        
        if ( *pdwSize )
        {
            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);
            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->OldUserData.size = *pdwSize;            

        pbTemp->RB_PCBIndex = PtrToUlong( porthandle);
        
    }
    break;
    
    case REQTYPE_PORTGETINFO:
    {
        HPORT porthandle = va_arg ( ap, HPORT );

        pUserBuffer = va_arg ( ap, PBYTE );

        pdwSize = va_arg( ap, PDWORD );

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }
        
        if ( *pdwSize )
        {
            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);
            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        pbTemp->RB_PCBIndex = PtrToUlong( porthandle );

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetInfo.size = *pdwSize;
        
    }
    
    break;
    
    case REQTYPE_GETINFO:
    case REQTYPE_CANCELRECEIVE:
    case REQTYPE_PORTCLEARSTATISTICS:
    case REQTYPE_PORTGETSTATISTICS:
    case REQTYPE_BUNDLECLEARSTATISTICS:
    case REQTYPE_BUNDLEGETSTATISTICS:
    case REQTYPE_PORTGETSTATISTICSEX:
    case REQTYPE_BUNDLEGETSTATISTICSEX:
    case REQTYPE_COMPRESSIONGETINFO:
    case REQTYPE_PORTCONNECTCOMPLETE:
    case REQTYPE_PORTENUMPROTOCOLS:
    case REQTYPE_GETFRAMINGCAPABILITIES:
    case REQTYPE_GETFRAMINGEX:
    case REQTYPE_GETBUNDLEDPORT:
    case REQTYPE_PORTGETBUNDLE:
    case REQTYPE_PORTRECEIVEEX:
    case REQTYPE_PPPSTARTED:
    {
        HPORT porthandle = va_arg(ap, HPORT) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
    }
    break ;

    case REQTYPE_BUNDLEGETPORT:
    {
        HBUNDLE bundlehandle = va_arg(ap, HBUNDLE) ;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->BundleGetPort.bundle = bundlehandle;
    }
    break ;

    case REQTYPE_PORTCLOSE:
    case REQTYPE_SERVERPORTCLOSE:
    {
        HPORT porthandle = va_arg(ap, HPORT) ;
        DWORD pid = va_arg(ap, DWORD) ;
        DWORD close = va_arg(ap, DWORD) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortClose.pid = pid;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortClose.close = close ;
    }
    break ;

    case REQTYPE_REQUESTNOTIFICATION:
    {
        HPORT  porthandle = va_arg(ap, HPORT) ;
        HANDLE handle     = va_arg(ap, HANDLE) ;
        DWORD pid         = va_arg(ap, DWORD) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ReqNotification.handle = handle;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ReqNotification.pid = pid;
    }
    break ;

    case REQTYPE_PORTLISTEN:
    {
        HPORT  porthandle = va_arg(ap, HPORT) ;
        DWORD  timeout    = va_arg(ap, DWORD) ;
        HANDLE handle     = va_arg(ap, HANDLE) ;
        DWORD pid         = va_arg(ap, DWORD) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortListen.timeout  = timeout;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortListen.handle   = handle;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortListen.pid  = pid ;
    }
    break ;

    case REQTYPE_PORTSETINFO:
    {
        HPORT porthandle          = va_arg(ap, HPORT) ;
        RASMAN_PORTINFO *info     = va_arg(ap, RASMAN_PORTINFO *) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST*)
        preqbuf->RB_Buffer)->PortSetInfo.info.PI_NumOfParams =
                                  info->PI_NumOfParams ;
        CopyParams (
            info->PI_Params,
            ((REQTYPECAST*)
            preqbuf->RB_Buffer)->PortSetInfo.info.PI_Params,
            info->PI_NumOfParams) ;
    }
    
    //
    // So that we don't get hit by the shared memory being mapped to
    // different addresses we convert pointers to offsets:
    //
    ConvParamPointerToOffset(
        ((REQTYPECAST*)
        preqbuf->RB_Buffer)->PortSetInfo.info.PI_Params,
        ((REQTYPECAST*)
        preqbuf->RB_Buffer)->PortSetInfo.info.PI_NumOfParams);

    break ;

    case REQTYPE_DEVICESETINFO:
    {
        HPORT  porthandle = va_arg(ap, HPORT) ;
        PCHAR  devicetype = va_arg(ap, PCHAR) ;
        PCHAR  devicename = va_arg(ap, PCHAR) ;
        RASMAN_DEVICEINFO* info = va_arg(ap, RASMAN_DEVICEINFO*) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        strcpy(((REQTYPECAST *)
                preqbuf->RB_Buffer)->DeviceSetInfo.devicetype,
                devicetype) ;
               
        strcpy(((REQTYPECAST *)
                preqbuf->RB_Buffer)->DeviceSetInfo.devicename,
                devicename) ;
               
        ((REQTYPECAST*)
        preqbuf->RB_Buffer)->DeviceSetInfo.info.DI_NumOfParams =
                                  info->DI_NumOfParams ;
        CopyParams (
            info->DI_Params,
            ((REQTYPECAST*)
            preqbuf->RB_Buffer)->DeviceSetInfo.info.DI_Params,
            info->DI_NumOfParams) ;
    }
    
    //
    // So that we don't get hit by the shared memory being mapped to
    // different addresses we convert pointers to offsets:
    //
    ConvParamPointerToOffset(
        ((REQTYPECAST*)
        preqbuf->RB_Buffer)->DeviceSetInfo.info.DI_Params,
        ((REQTYPECAST*)
        preqbuf->RB_Buffer)->DeviceSetInfo.info.DI_NumOfParams) ;

    break ;

    case REQTYPE_PORTOPEN:
    {
        PCHAR portname = va_arg(ap, PCHAR) ;
        HANDLE notifier= va_arg(ap, HANDLE) ;
        DWORD pid      = va_arg(ap, DWORD) ;
        DWORD open     = va_arg(ap, DWORD) ;

        strcpy(
            ((REQTYPECAST *)
            preqbuf->RB_Buffer)->PortOpen.portname, 
            portname);
            
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortOpen.notifier = notifier ;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortOpen.PID = pid ;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortOpen.open = open ;
    }
    break ;

    case REQTYPE_PORTOPENEX:
    {
        PCHAR   pszDeviceName   = va_arg(ap, PCHAR);
        DWORD   dwCounter       = va_arg(ap, DWORD);
        HANDLE  hnotifier       = va_arg(ap, HANDLE);
        DWORD   pid             = GetCurrentProcessId();
        DWORD   dwOpen          = va_arg(ap, DWORD);
        
        pdwFlags       = va_arg(ap, DWORD *);

        strcpy(
            ((REQTYPECAST *)
            preqbuf->RB_Buffer)->PortOpenEx.szDeviceName,
            pszDeviceName);

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortOpenEx.dwDeviceLineCounter 
                                = dwCounter;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortOpenEx.hnotifier = hnotifier;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortOpenEx.pid = pid;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortOpenEx.dwFlags = *pdwFlags;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortOpenEx.dwOpen = dwOpen;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortOpenEx.hnotifier = hnotifier;
    }
    break;

    case REQTYPE_PORTDISCONNECT:
    {
        HPORT  porthandle = va_arg(ap, HPORT) ;
        HANDLE handle     = va_arg(ap, HANDLE) ;
        DWORD  pid    = va_arg(ap, DWORD) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortDisconnect.handle = handle;
        
        ((REQTYPECAST *)
         preqbuf->RB_Buffer)->PortDisconnect.pid    = pid;
    }
    break ;

    case REQTYPE_PORTSEND:
    {
        HPORT  porthandle       = va_arg(ap, HPORT) ;
        SendRcvBuffer *pbuffer  = va_arg(ap, SendRcvBuffer *) ;
        DWORD  size             = va_arg(ap, DWORD) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortSend.size = size;

        memcpy (&(( (REQTYPECAST *) 
                preqbuf->RB_Buffer)->PortSend.buffer),
                pbuffer,
                sizeof ( SendRcvBuffer ) );
                    
    }
    break ;

    case REQTYPE_PORTRECEIVE:
    {
        HPORT           porthandle      = va_arg(ap, HPORT) ;
        SendRcvBuffer   *pSendRcvBuffer = va_arg(ap, SendRcvBuffer *) ;
        PDWORD          size            = va_arg(ap, PDWORD) ;
        DWORD           timeout         = va_arg(ap, DWORD) ;
        HANDLE          handle          = va_arg(ap, HANDLE) ;
        DWORD           pid             = va_arg(ap, DWORD) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortReceive.size = *size;
                                                            
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortReceive.handle = handle;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortReceive.pid = pid;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortReceive.timeout = timeout;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortReceive.buffer = pSendRcvBuffer;

    }
    break ;

    case REQTYPE_ALLOCATEROUTE:
    {
        HPORT  porthandle = va_arg(ap, HPORT) ;
        
        RAS_PROTOCOLTYPE type = va_arg(ap, RAS_PROTOCOLTYPE) ;
        
        BOOL   wrknet     = va_arg(ap, BOOL) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->AllocateRoute.type = type ;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->AllocateRoute.wrknet = wrknet ;
    }
    break ;

    case REQTYPE_DEALLOCATEROUTE:
    {
        HBUNDLE hbundle = va_arg(ap, HBUNDLE) ;
        
        RAS_PROTOCOLTYPE type = va_arg(ap, RAS_PROTOCOLTYPE) ;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->DeAllocateRoute.hbundle = 
                                                   hbundle;
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->DeAllocateRoute.type = type ;
    }
    break ;

    case REQTYPE_ACTIVATEROUTE:
    {
        HPORT  porthandle = va_arg(ap, HPORT) ;
        
        RAS_PROTOCOLTYPE type = va_arg(ap, RAS_PROTOCOLTYPE) ;
        
        PROTOCOL_CONFIG_INFO *config = va_arg(ap, 
                                    PROTOCOL_CONFIG_INFO*) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ActivateRoute.type = type ;
        
        memcpy (
            &((REQTYPECAST *)
            preqbuf->RB_Buffer)->ActivateRoute.config.P_Info,
            config->P_Info, 
            config->P_Length) ;
            
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ActivateRoute.config.P_Length = 
                                                 config->P_Length ;
    }
    break ;

    case REQTYPE_ACTIVATEROUTEEX:
    {
        HPORT  porthandle = va_arg(ap, HPORT) ;
        
        RAS_PROTOCOLTYPE type = va_arg(ap, RAS_PROTOCOLTYPE) ;
        
        DWORD framesize = va_arg(ap, DWORD) ;
        
        PROTOCOL_CONFIG_INFO *config = va_arg(ap, 
                                PROTOCOL_CONFIG_INFO*) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ActivateRouteEx.type = type ;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ActivateRouteEx.framesize = framesize ;
        
        memcpy (
            &((REQTYPECAST *)
            preqbuf->RB_Buffer)->ActivateRouteEx.config.P_Info, 
            config->P_Info, 
            config->P_Length) ;
            
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ActivateRouteEx.config.P_Length = 
                                            config->P_Length ;
    }
    break ;

    case REQTYPE_COMPRESSIONSETINFO:
    {
        HPORT  porthandle = va_arg(ap, HPORT) ;
        
        RAS_COMPRESSION_INFO *send = va_arg(ap, RAS_COMPRESSION_INFO *) ;
        
        RAS_COMPRESSION_INFO *recv = va_arg(ap, RAS_COMPRESSION_INFO *) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        memcpy (&((REQTYPECAST *)
                preqbuf->RB_Buffer)->CompressionSetInfo.send,
                send,
                sizeof (RAS_COMPRESSION_INFO)) ;

        memcpy (&((REQTYPECAST *)
                preqbuf->RB_Buffer)->CompressionSetInfo.recv,
                recv,
                sizeof (RAS_COMPRESSION_INFO)) ;
    }
    break ;

    case REQTYPE_GETUSERCREDENTIALS:
    {
        PBYTE   pChallenge = va_arg(ap, PBYTE) ;
        PLUID   LogonId    = va_arg(ap, PLUID) ;

        memcpy (((REQTYPECAST*)
            preqbuf->RB_Buffer)->GetCredentials.Challenge,
            pChallenge, 
            MAX_CHALLENGE_SIZE) ;
            
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->GetCredentials.LogonId = *LogonId;
    }
    break ;

    case REQTYPE_SETCACHEDCREDENTIALS:
    {
        PCHAR   Account = va_arg( ap, PCHAR );
        
        PCHAR   Domain = va_arg( ap, PCHAR );
        
        PCHAR   NewPassword = va_arg( ap, PCHAR );

        strcpy(
            ((REQTYPECAST* )
            preqbuf->RB_Buffer)->SetCachedCredentials.Account,
            Account );
            
        strcpy(
            ((REQTYPECAST* )
            preqbuf->RB_Buffer)->SetCachedCredentials.Domain,
            Domain );
            
        strcpy(
            ((REQTYPECAST* )
            preqbuf->RB_Buffer)->SetCachedCredentials.NewPassword,
            NewPassword );
    }
    break;

    case REQTYPE_SETFRAMING:
    {
        HPORT porthandle = va_arg(ap, HPORT) ;
        
        DWORD SendFeatureBits = va_arg(ap, DWORD) ;
        
        DWORD RecvFeatureBits = va_arg(ap, DWORD) ;
        
        DWORD SendBitMask     = va_arg(ap, DWORD) ;
        
        DWORD RecvBitMask     = va_arg(ap, DWORD) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetFraming.Sendbits =  SendFeatureBits ;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetFraming.Recvbits =  RecvFeatureBits ;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetFraming.SendbitMask = SendBitMask ;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetFraming.RecvbitMask = RecvBitMask ;
    }
    break ;

    case REQTYPE_SETFRAMINGEX:
    {
        HPORT porthandle = va_arg(ap, HPORT) ;
        
        RAS_FRAMING_INFO *info = va_arg(ap, RAS_FRAMING_INFO *) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        memcpy (&((REQTYPECAST *)
            preqbuf->RB_Buffer)->FramingInfo.info,
            info,
            sizeof (RAS_FRAMING_INFO)) ;
    }
    break ;


    case REQTYPE_REGISTERSLIP:
    {
        HPORT porthandle = va_arg(ap, HPORT) ;
        
        DWORD ipaddr     = va_arg(ap, DWORD) ;
        
        DWORD dwFrameSize = va_arg ( ap, DWORD ) ;
        
        BOOL  priority   = va_arg(ap, BOOL) ;
        
        WCHAR *pszDNSAddress = va_arg(ap, WCHAR*);
        
        WCHAR *pszDNS2Address = va_arg(ap, WCHAR*);
        
        WCHAR *pszWINSAddress = va_arg(ap, WCHAR*);
        
        WCHAR *pszWINS2Address = va_arg(ap, WCHAR*);

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );

        ((REQTYPECAST*)
        preqbuf->RB_Buffer)->RegisterSlip.dwFrameSize = dwFrameSize;
                                                            
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->RegisterSlip.ipaddr = ipaddr ;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->RegisterSlip.priority = priority   ;
        
        if (pszDNSAddress != NULL) 
        {
            memcpy (
              ((REQTYPECAST *)
              preqbuf->RB_Buffer)->RegisterSlip.szDNSAddress,
              pszDNSAddress,
              ( wcslen(pszDNSAddress) + 1 ) * sizeof (WCHAR)) ;
        }
        else 
        {
            memset(
              ((REQTYPECAST *)
              preqbuf->RB_Buffer)->RegisterSlip.szDNSAddress,
              0,
              17 * sizeof (WCHAR));
        }
        if (pszDNS2Address != NULL) 
        {
            memcpy (
              ((REQTYPECAST *)
              preqbuf->RB_Buffer)->RegisterSlip.szDNS2Address,
              pszDNS2Address,
              ( wcslen(pszDNS2Address) + 1 ) * sizeof (WCHAR)) ;
        }
        else 
        {
            memset(
              ((REQTYPECAST *)
              preqbuf->RB_Buffer)->RegisterSlip.szDNS2Address,
              0,
              17 * sizeof (WCHAR));
        }
        if (pszWINSAddress != NULL) 
        {
            memcpy (
              ((REQTYPECAST *)
              preqbuf->RB_Buffer)->RegisterSlip.szWINSAddress,
              pszWINSAddress,
              ( wcslen(pszWINSAddress) + 1 ) * sizeof (WCHAR)) ;
        }
        else 
        {
            memset(
              ((REQTYPECAST *)
              preqbuf->RB_Buffer)->RegisterSlip.szWINSAddress,
              0,
              17 * sizeof (WCHAR));
        }
        if (pszWINS2Address != NULL) 
        {
            memcpy (
              ((REQTYPECAST *)
              preqbuf->RB_Buffer)->RegisterSlip.szWINS2Address,
              pszWINS2Address,
              ( wcslen(pszWINS2Address) + 1 ) * sizeof (WCHAR)) ;
        }
        else 
        {
            memset(
              ((REQTYPECAST *)
              preqbuf->RB_Buffer)->RegisterSlip.szWINS2Address,
              0,
              17 * sizeof (WCHAR));
        }
    }
    break ;

    case REQTYPE_GETPROTOCOLCOMPRESSION:
    {
        HPORT porthandle          = va_arg(ap, HPORT) ;
        
        RAS_PROTOCOLTYPE type         = va_arg(ap, RAS_PROTOCOLTYPE) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ProtocolComp.type = type ;
    }
    break ;

    case REQTYPE_PORTBUNDLE:
    {
        HPORT porthandle         = va_arg(ap, HPORT) ;
        
        HPORT porttobundle       = va_arg(ap, HPORT) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PortBundle.porttobundle = porttobundle ;
    }
    break ;

    case REQTYPE_SETPROTOCOLCOMPRESSION:
    {
        HPORT porthandle          = va_arg(ap, HPORT) ;
        
        RAS_PROTOCOLTYPE type         = va_arg(ap, RAS_PROTOCOLTYPE) ;
        
        RAS_PROTOCOLCOMPRESSION *send = va_arg(ap, RAS_PROTOCOLCOMPRESSION *) ;
        
        RAS_PROTOCOLCOMPRESSION *recv = va_arg(ap, RAS_PROTOCOLCOMPRESSION *) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ProtocolComp.type = type ;
        
        memcpy (&((REQTYPECAST *)
                preqbuf->RB_Buffer)->ProtocolComp.send,
                send,
                sizeof (RAS_PROTOCOLCOMPRESSION)) ;

        memcpy (&((REQTYPECAST *)
                preqbuf->RB_Buffer)->ProtocolComp.recv,
                recv,
                sizeof (RAS_PROTOCOLCOMPRESSION)) ;
    }
    break ;

    case REQTYPE_STOREUSERDATA:
    {
        HPORT porthandle    = va_arg(ap, HPORT) ;
        
        PBYTE data          = va_arg(ap, PBYTE) ;
        
        DWORD size          = va_arg(ap, DWORD) ;

        retcode = AllocateBuffer(size, 
                                (PBYTE *) &pBuffer, 
                                &dwSizeofBuffer);

        if (retcode)
        {
            goto done;
        }

        if(pBuffer)
        {
            pBuffer->RB_Reqtype = reqtype;
            
            pBuffer->RB_PCBIndex = PtrToUlong( porthandle );
            
            pbTemp = pBuffer;            
        }
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->OldUserData.size = (size < 5000 ? 
                                                size : 5000) ;
        
        memcpy (((REQTYPECAST *)
                pbTemp->RB_Buffer)->OldUserData.data,
                data,
                (size < 5000 ? size : 5000)) ; // max 5000 bytes copied


    }
    break ;

    case REQTYPE_SETATTACHCOUNT:
    {
        BOOL fAttach = va_arg(ap, BOOL);
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->AttachInfo.dwPid = GetCurrentProcessId();
                                                    
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->AttachInfo.fAttach = fAttach;
    }
    break;

    case REQTYPE_GETDIALPARAMS:
    {
        DWORD dwUID     = va_arg(ap, DWORD);

        pdwMaskDialParams = va_arg(ap, LPDWORD);

        dwSizeofBuffer  = sizeof ( RequestBuffer ) 
                        + sizeof( REQTYPECAST ) 
                        + 5000 * sizeof( WCHAR );

        pBuffer = LocalAlloc( LPTR, dwSizeofBuffer );

        if ( NULL == pBuffer )
        {
            retcode = GetLastError();
            goto done;
        }

        pBuffer->RB_Reqtype = reqtype;

        pBuffer->RB_PCBIndex = 0;

        ((REQTYPECAST *)
        pBuffer->RB_Buffer)->DialParams.dwUID = dwUID;
        
        ((REQTYPECAST *)
        pBuffer->RB_Buffer)->DialParams.dwMask = *pdwMaskDialParams;

        ((REQTYPECAST *)
        pBuffer->RB_Buffer)->DialParams.dwPid = GetCurrentProcessId();
                                                    
        GetUserSid(((REQTYPECAST *)
                    pBuffer->RB_Buffer)->DialParams.sid, 
                    5000);

        pbTemp = pBuffer;
        
    }
    break;

    case REQTYPE_SETDIALPARAMS:
    {
        DWORD dwUID                 = va_arg(ap, DWORD);
        
        DWORD dwMask                = va_arg(ap, DWORD);
        
        PRAS_DIALPARAMS pDialParams = va_arg(ap, PRAS_DIALPARAMS);
        
        BOOL fDelete                = va_arg(ap, BOOL);

        dwSizeofBuffer = sizeof ( RequestBuffer ) 
                       + sizeof ( REQTYPECAST )
                       + 5000 * sizeof ( WCHAR );

        pBuffer = LocalAlloc( LPTR, dwSizeofBuffer );

        if ( NULL == pBuffer )
        {
            retcode = GetLastError();
            goto done;
        }

        pBuffer->RB_PCBIndex = 0;

        pBuffer->RB_Reqtype = reqtype;

        ((REQTYPECAST *)
        pBuffer->RB_Buffer)->DialParams.dwUID = dwUID;
        
        ((REQTYPECAST *)
        pBuffer->RB_Buffer)->DialParams.dwMask = dwMask;

        ((REQTYPECAST *)
        pBuffer->RB_Buffer)->DialParams.dwPid = GetCurrentProcessId();

        if(NULL != pDialParams)
        {
        
            RtlCopyMemory(
              &(((REQTYPECAST *)
              pBuffer->RB_Buffer)->DialParams.params),
              pDialParams,
              sizeof (RAS_DIALPARAMS));
        }
          
        ((REQTYPECAST *)
        pBuffer->RB_Buffer)->DialParams.fDelete = fDelete;
        
        GetUserSid(((REQTYPECAST *)
                   pBuffer->RB_Buffer)->DialParams.sid, 
                   5000);

        pbTemp = pBuffer;
    }
    break;

    case REQTYPE_CREATECONNECTION:
    {
        DWORD   pid                 = va_arg (ap, DWORD);
        
        DWORD   dwSubEntries        = va_arg (ap, DWORD );

        DWORD   dwDialMode          = va_arg (ap, DWORD );
        
        GUID    *pGuidEntry         = va_arg (ap, GUID *);
        
        CHAR    *pszPhonebookPath   = va_arg (ap, CHAR *);    
        
        CHAR    *pszEntryName       = va_arg (ap, CHAR *);

        CHAR    *pszRefPbkPath      = va_arg (ap, CHAR *);

        CHAR    *pszRefEntryName    = va_arg (ap, CHAR *);
        
        retcode = AllocateBuffer(dwSubEntries * sizeof(DWORD), 
                                (PBYTE *) &pBuffer, 
                                &dwSizeofBuffer);

        if(retcode)
        {
            goto done;
        }

        if(pBuffer)
        {
            pBuffer->RB_Reqtype = reqtype;
            pBuffer->RB_PCBIndex = 0;
            pbTemp = pBuffer;          
        }
        
        strcpy (((REQTYPECAST *)
                pbTemp->RB_Buffer)->Connection.szPhonebookPath,
                pszPhonebookPath);    

        strcpy (((REQTYPECAST *)
                pbTemp->RB_Buffer)->Connection.szEntryName,
                 pszEntryName);

        strcpy (((REQTYPECAST *)
                pbTemp->RB_Buffer)->Connection.szRefPbkPath,
                pszRefPbkPath);

        strcpy (((REQTYPECAST *)
                pbTemp->RB_Buffer)->Connection.szRefEntryName,
                pszRefEntryName);

        if(NULL != pGuidEntry)
        {
            memcpy(&((REQTYPECAST *)
                   pbTemp->RB_Buffer)->Connection.guidEntry,
                   pGuidEntry,
                   sizeof(GUID));
        }

        ((REQTYPECAST *) 
        pbTemp->RB_Buffer)->Connection.dwSubEntries = dwSubEntries;
        
        ((REQTYPECAST *) 
        pbTemp->RB_Buffer)->Connection.dwDialMode = dwDialMode;

        ((REQTYPECAST *)pbTemp->RB_Buffer)->Connection.pid = pid;
    }
    break;

    case REQTYPE_DESTROYCONNECTION:
    {
        HCONN conn = va_arg(ap, HCONN);
        
        DWORD pid = va_arg(ap, DWORD);

        ((REQTYPECAST *)preqbuf->RB_Buffer)->Connection.conn = conn;
        
        ((REQTYPECAST *)preqbuf->RB_Buffer)->Connection.pid = pid;
    }
    break;

    case REQTYPE_ENUMCONNECTIONPORTS:
    {
        HCONN conn = va_arg ( ap, HCONN );

        pdwSize = va_arg ( ap, DWORD *);
        
        pUserBuffer = (PBYTE ) va_arg ( ap, RASMAN_PORT *);

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }
        
        if ( *pdwSize ) 
        {

            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);
            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->EnumConnectionPorts.conn = conn;
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->EnumConnectionPorts.size = *pdwSize;
        
    }
    break;
    case REQTYPE_GETCONNECTIONPARAMS:
    {
        HCONN conn = va_arg(ap, HCONN);

        ((REQTYPECAST *)preqbuf->RB_Buffer)->Connection.conn = conn;
    }
    break;

    case REQTYPE_ADDCONNECTIONPORT:
    {
        HCONN conn = va_arg(ap, HCONN);
        
        HPORT porthandle = va_arg(ap, HPORT);
        
        DWORD dwSubEntry = va_arg(ap, DWORD);

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->AddConnectionPort.conn = conn;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->AddConnectionPort.dwSubEntry = dwSubEntry;
        
    }
    break;

    case REQTYPE_SETCONNECTIONPARAMS:
    {
        HCONN conn = va_arg(ap, HCONN) ;
        
        PRAS_CONNECTIONPARAMS pParams = va_arg(ap, PRAS_CONNECTIONPARAMS);

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ConnectionParams.conn = conn;
        
        RtlCopyMemory(
          &(((REQTYPECAST *)
          preqbuf->RB_Buffer)->ConnectionParams.params),
          pParams,
          sizeof (RAS_CONNECTIONPARAMS));
    }
    break;

    case REQTYPE_GETCONNECTIONUSERDATA:
    {
        HCONN conn = va_arg(ap, HCONN);
        DWORD dwTag = va_arg(ap, DWORD);

        pUserBuffer = va_arg ( ap, PBYTE );
        pdwSize     = va_arg ( ap, DWORD *);

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }
        
        if ( *pdwSize )
        {
            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);
            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->ConnectionUserData.dwcb = *pdwSize;
                                                                
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->ConnectionUserData.conn = conn;
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->ConnectionUserData.dwTag = dwTag;
    }
    break;

    case REQTYPE_SETCONNECTIONUSERDATA:
    {
        HCONN conn = va_arg(ap, HCONN) ;
        
        DWORD dwTag = va_arg(ap, DWORD);
        
        PBYTE pBuf = va_arg(ap, PBYTE);
        
        DWORD dwcb = va_arg(ap, DWORD);

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ConnectionUserData.conn = conn;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ConnectionUserData.dwTag = dwTag;
                                                                    
        dwcb = (dwcb < 5000 ? dwcb : 5000);
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->ConnectionUserData.dwcb = dwcb;
        
        memcpy (
          ((REQTYPECAST *)
          preqbuf->RB_Buffer)->ConnectionUserData.data,
          pBuf,
          dwcb);
    }
    break;

    case REQTYPE_GETPORTUSERDATA:
    {
        HPORT port = va_arg(ap, HPORT);
        DWORD dwTag = va_arg(ap, DWORD);

        pUserBuffer = va_arg ( ap, PBYTE );
        pdwSize     = va_arg ( ap, DWORD *);

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }

        if ( *pdwSize )
        {
            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);
            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        pbTemp->RB_PCBIndex = PtrToUlong( port);
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->PortUserData.dwTag = dwTag;
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->PortUserData.dwcb = *pdwSize;
    }
    break;

    case REQTYPE_SETPORTUSERDATA:
    {
        HPORT port  = va_arg(ap, HPORT);
        
        DWORD dwTag = va_arg(ap, DWORD);
        
        PBYTE pBuf  = va_arg(ap, PBYTE);
        
        DWORD dwcb  = va_arg(ap, DWORD);

        if ( dwcb )
        {
            retcode = AllocateBuffer(dwcb, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);
            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }
        

        pbTemp->RB_PCBIndex = PtrToUlong( port);
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->PortUserData.dwTag = dwTag;
        
        dwcb = (dwcb < 5000 ? dwcb : 5000);
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->PortUserData.dwcb = dwcb;
        
        memcpy (
          ((REQTYPECAST *)pbTemp->RB_Buffer)->PortUserData.data,
          pBuf,
          dwcb);

    }
    break;

    case REQTYPE_PPPCALLBACK:
    {
        HPORT porthandle = va_arg(ap, HPORT) ;
        
        CHAR * pszCallbackNumber = va_arg(ap, CHAR *) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );

        ((REQTYPECAST *)preqbuf->RB_Buffer)->PppEMsg.dwMsgId = 
                                                PPPEMSG_Callback;
                                                
        ((REQTYPECAST *)preqbuf->RB_Buffer)->PppEMsg.hPort = 
                                                    porthandle;

        strcpy(((REQTYPECAST *)
               preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Callback.
               szCallbackNumber,
               pszCallbackNumber );

    }
    break;

    case REQTYPE_PPPSTOP:
    {
        HPORT porthandle = va_arg(ap, HPORT) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.dwMsgId = PPPEMSG_Stop;
                                                        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.hPort = porthandle;
    }
    break;

    case REQTYPE_PPPSTART:
    {
        HPORT               porthandle = va_arg(ap, HPORT) ;
        
        CHAR *              pszPortName = va_arg(ap, CHAR *) ;
        
        CHAR *              pszUserName = va_arg(ap, CHAR *) ;
        
        CHAR *              pszPassword = va_arg(ap, CHAR *) ;
        
        CHAR *              pszDomain = va_arg(ap, CHAR *) ;
        
        LUID *              pLuid = va_arg(ap, LUID *) ;
        
        PPP_CONFIG_INFO*    pConfigInfo = va_arg(ap, PPP_CONFIG_INFO *) ;
        
        PPP_INTERFACE_INFO* pPppInterfaceInfo = va_arg(ap, 
                                            PPP_INTERFACE_INFO*);
        
        CHAR *              pszzParameters = va_arg(ap, CHAR *) ;
        
        BOOL                fThisIsACallback = va_arg(ap, BOOL) ;
        
        HANDLE              hEvent = va_arg(ap, HANDLE) ;
        
        DWORD               dwPid  = va_arg(ap, DWORD) ;
        
        DWORD               dwAutoDisconnectTime  = va_arg(ap, DWORD) ;
        
        BOOL                fRedialOnLinkFailure  = va_arg(ap, BOOL);
        
        PPP_BAPPARAMS       *pBapParams = va_arg(ap, PPP_BAPPARAMS *);

        BOOL                fNonInteractive = va_arg(ap, BOOL);

        DWORD               dwEapTypeId = va_arg(ap, DWORD);

        DWORD               dwFlags = va_arg(ap, DWORD);

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)preqbuf->RB_Buffer)->PppEMsg.dwMsgId =
                                                        PPPEMSG_Start;
                                                        
        ((REQTYPECAST *)preqbuf->RB_Buffer)->PppEMsg.hPort = porthandle;

        strcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.szPortName,
                pszPortName );

        strcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.szUserName,
                pszUserName );

        strcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.szPassword,
                pszPassword );

        strcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.szDomain,
                pszDomain );

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.Luid = *pLuid;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.ConfigInfo = 
                                                        *pConfigInfo;

        if ( pPppInterfaceInfo != NULL )
        {
            ((REQTYPECAST *)
            preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.PppInterfaceInfo
                                                        = *pPppInterfaceInfo;
        }
        else
        {
            ((REQTYPECAST *)
            preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.
            PppInterfaceInfo.IfType = (DWORD)-1;
        }

        memcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.szzParameters,
                pszzParameters, PARAMETERBUFLEN );

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.fThisIsACallback =
                                                        fThisIsACallback;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.hEvent = hEvent;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.dwPid = dwPid;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.dwAutoDisconnectTime
                                                    = dwAutoDisconnectTime;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.fRedialOnLinkFailure
                                                    = fRedialOnLinkFailure;

        memcpy( &(((REQTYPECAST *)
        
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.BapParams),
        
        pBapParams, sizeof (PPP_BAPPARAMS));

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.fNonInteractive
                                                    = fNonInteractive;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.dwEapTypeId =
                                                    dwEapTypeId;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Start.dwFlags =
                                                    dwFlags;
                                                    

    }
    break;

    case REQTYPE_PPPRETRY:
    {
        HPORT   porthandle = va_arg(ap, HPORT) ;
        
        CHAR *  pszUserName = va_arg(ap, CHAR *) ;
        
        CHAR *  pszPassword = va_arg(ap, CHAR *) ;
        
        CHAR *  pszDomain = va_arg(ap, CHAR *) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle);
        
        ((REQTYPECAST *)preqbuf->RB_Buffer)->PppEMsg.dwMsgId =
                                                        PPPEMSG_Retry;
                                                        
        ((REQTYPECAST *)preqbuf->RB_Buffer)->PppEMsg.hPort = porthandle;

        strcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Retry.szUserName,
                pszUserName );

        strcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Retry.szPassword,
                pszPassword );

        strcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.Retry.szDomain,
                pszDomain );
    }
    break;

    case REQTYPE_PPPGETINFO:
    {
        HPORT porthandle = va_arg(ap, HPORT) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
    }
    break;

    case REQTYPE_GETTIMESINCELASTACTIVITY:
    {
        HPORT porthandle = va_arg(ap, HPORT) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
    }
    break;

    case REQTYPE_PPPCHANGEPWD:
    {
        HPORT   porthandle = va_arg(ap, HPORT) ;
        
        CHAR *  pszUserName = va_arg(ap, CHAR *) ;
        
        CHAR *  pszOldPassword = va_arg(ap, CHAR *) ;
        
        CHAR *  pszNewPassword = va_arg(ap, CHAR *) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.dwMsgId = PPPEMSG_ChangePw;
                                                        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->PppEMsg.hPort = porthandle;

        strcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.ChangePw.szUserName,
                pszUserName );

        strcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.ChangePw.szOldPassword,
                pszOldPassword );

        strcpy( ((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppEMsg.ExtraInfo.ChangePw.szNewPassword,
                pszNewPassword );
    }
    break;

    case REQTYPE_ADDNOTIFICATION:
    {
        DWORD pid = va_arg(ap, DWORD);
        
        HCONN hconn = va_arg(ap, HCONN);
        
        HANDLE hevent = va_arg(ap, HANDLE);
        
        DWORD dwfFlags = va_arg(ap, DWORD);

        //
        // Either a HPORT or a HCONN can be passed
        // in as the HCONN argument.
        //
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->AddNotification.pid = pid;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->AddNotification.fAny = 
                                (hconn == INVALID_HPORT);
                                
        if (    hconn == INVALID_HPORT 
            ||  (HandleToUlong(hconn) & 0xffff0000))
        {
            ((REQTYPECAST *)
            preqbuf->RB_Buffer)->AddNotification.hconn = hconn;
        }
        else 
        {
            preqbuf->RB_PCBIndex = PtrToUlong( hconn );
            
            ((REQTYPECAST *)
            preqbuf->RB_Buffer)->AddNotification.hconn = 0;//(HCONN)NULL;
        }
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->AddNotification.hevent = hevent;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->AddNotification.dwfFlags = dwfFlags;
    }
    break;

    case REQTYPE_SIGNALCONNECTION:
    {
        HCONN hconn = va_arg(ap, HCONN);

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SignalConnection.hconn = hconn;
    }
    break;

    case REQTYPE_SETDEVCONFIG:
    {
        HPORT   porthandle = va_arg(ap, HPORT) ;
        
        PCHAR   devicetype = va_arg(ap, PCHAR) ;
        
        PBYTE   config     = va_arg(ap, PBYTE) ;
        
        DWORD   size       = va_arg(ap, DWORD) ;

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle );
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetDevConfig.size  = size ;
        
        strcpy(((REQTYPECAST *)
                preqbuf->RB_Buffer)->SetDevConfig.devicetype, 
                devicetype) ;
                
        memcpy (((REQTYPECAST *)
                preqbuf->RB_Buffer)->SetDevConfig.config, 
                config, 
                size) ;
    }
    break;

    case REQTYPE_GETDEVCONFIG:
    {
        HPORT   porthandle = va_arg(ap, HPORT) ;
        PCHAR   devicetype = va_arg(ap, PCHAR) ;

        pUserBuffer = va_arg ( ap, PBYTE );
        pdwSize     = va_arg ( ap, DWORD *);

        if (NULL == pUserBuffer)
        {
            *pdwSize = 0;
        }

        if (*pdwSize)
        {
            retcode = AllocateBuffer(*pdwSize,
                                    (PBYTE *) &pBuffer,
                                    &dwSizeofBuffer);
            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        pbTemp->RB_PCBIndex = PtrToUlong( porthandle );
        
        strcpy(((REQTYPECAST *)
                pbTemp->RB_Buffer)->GetDevConfig.devicetype, 
                devicetype) ;

        ((REQTYPECAST *)
         pbTemp->RB_Buffer)->GetDevConfig.size = *pdwSize;

    }
    break;

    case REQTYPE_GETDEVCONFIGEX:
    {
    
        HPORT   porthandle = va_arg(ap, HPORT) ;
        PCHAR   devicetype = va_arg(ap, PCHAR) ;

        pUserBuffer = va_arg ( ap, PBYTE );
        pdwSize     = va_arg ( ap, DWORD *);

        if (NULL == pUserBuffer)
        {
            *pdwSize = 0;
        }

        if (*pdwSize)
        {
            retcode = AllocateBuffer(*pdwSize,
                                    (PBYTE *) &pBuffer,
                                    &dwSizeofBuffer);
            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        pbTemp->RB_PCBIndex = PtrToUlong( porthandle );
        
        strcpy(((REQTYPECAST *)
                pbTemp->RB_Buffer)->GetDevConfigEx.devicetype, 
                devicetype) ;

        ((REQTYPECAST *)
         pbTemp->RB_Buffer)->GetDevConfigEx.size = *pdwSize;
        break;
    }

    case REQTYPE_CLOSEPROCESSPORTS:
    {
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->CloseProcessPortsInfo.pid = 
                                                    GetCurrentProcessId();
    }
    break;

    case REQTYPE_PNPCONTROL:
    {
        DWORD dwOp = va_arg(ap, DWORD);
        
        HPORT porthandle = va_arg(ap, HPORT);

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle);
        
        ((REQTYPECAST *)preqbuf->RB_Buffer)->PnPControlInfo.dwOp = dwOp;
    }
    break;

    case REQTYPE_SETIOCOMPLETIONPORT:
    {
        HPORT porthandle = va_arg(ap, HPORT);
        
        HANDLE hIoCompletionPort = va_arg(ap, HANDLE);
        
        LPOVERLAPPED lpOvDrop = va_arg(ap, LPOVERLAPPED);
        
        LPOVERLAPPED lpOvStateChange = va_arg(ap, LPOVERLAPPED);
        
        LPOVERLAPPED lpOvPpp = va_arg(ap, LPOVERLAPPED);
        
        LPOVERLAPPED lpOvLast = va_arg(ap, LPOVERLAPPED);

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle);
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetIoCompletionPortInfo.hIoCompletionPort = 
                                                     hIoCompletionPort;
        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetIoCompletionPortInfo.pid = 
                                                GetCurrentProcessId();
                                                
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetIoCompletionPortInfo.lpOvDrop = 
                                                            lpOvDrop;
                                                        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetIoCompletionPortInfo.lpOvStateChange = 
                                                        lpOvStateChange;
                                            
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetIoCompletionPortInfo.lpOvPpp = lpOvPpp;
                                                        
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetIoCompletionPortInfo.lpOvLast = lpOvLast;
    }
    break;

    case REQTYPE_SETROUTERUSAGE:
    {
        HPORT porthandle = va_arg(ap, HPORT);
        BOOL fRouter = va_arg(ap, BOOL);

        preqbuf->RB_PCBIndex = PtrToUlong( porthandle);
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->SetRouterUsageInfo.fRouter = fRouter;
    }
    break;

    case REQTYPE_SENDPPPMESSAGETORASMAN:
    {
    	HPORT		hPort	= va_arg(ap, HPORT);
    	
    	PPP_MESSAGE *pppMsg = (PPP_MESSAGE *) va_arg(ap, PPP_MESSAGE *);

        memcpy( &(((REQTYPECAST *)preqbuf->RB_Buffer)->PppMsg),
        		pppMsg,
                sizeof( PPP_MESSAGE ) );

    }
	break;

    case REQTYPE_SETRASDIALINFO:
    {
        HPORT       hPort = va_arg (ap, HPORT);
        
        CHAR        *pszPhonebookPath = va_arg (ap, CHAR *);    
        
        CHAR        *pszEntryName = va_arg (ap, CHAR *);
        
        CHAR        *pszPhoneNumber = va_arg(ap, CHAR *);

        DWORD       cbCustomAuthData = va_arg(ap, DWORD);

        PBYTE       pbCustomAuthData = va_arg(ap, PBYTE);

        DWORD       dwRequiredSize;

        dwRequiredSize =    strlen(pszPhonebookPath) + 1
                          + strlen(pszEntryName) + 1
                          + strlen(pszPhoneNumber)
                          + sizeof(RAS_CUSTOM_AUTH_DATA)
                          + cbCustomAuthData;

        retcode = AllocateBuffer(dwRequiredSize,
                                (PBYTE *) &pBuffer,
                                &dwSizeofBuffer);

        if(retcode)
        {
            goto done;
        }

        if(pBuffer)
        {
            pBuffer->RB_Reqtype = reqtype;
            pbTemp = pBuffer;
        }

        pbTemp->RB_PCBIndex = PtrToUlong( hPort);
        
        strcpy (((REQTYPECAST *) 
                pbTemp->RB_Buffer)->SetRasdialInfo.szPhonebookPath,
                pszPhonebookPath);    

        strcpy (((REQTYPECAST *) 
                pbTemp->RB_Buffer)->SetRasdialInfo.szEntryName,
                pszEntryName);

        strcpy (((REQTYPECAST *) 
                pbTemp->RB_Buffer)->SetRasdialInfo.szPhoneNumber,
                pszPhoneNumber);

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->SetRasdialInfo.rcad.cbCustomAuthData
                                        = cbCustomAuthData;

        if(cbCustomAuthData > 0)
        {
            memcpy(
             ((REQTYPECAST *)
             pbTemp->RB_Buffer)->SetRasdialInfo.rcad.abCustomAuthData,
             pbCustomAuthData,
             cbCustomAuthData);
        }

        break;
    }

	case REQTYPE_REGISTERPNPNOTIF:
	{
	    PVOID   pvNotifier      = va_arg ( ap, PVOID );
	    
	    DWORD   dwFlags         = va_arg ( ap, DWORD );
	    
	    DWORD   pid             = va_arg ( ap, DWORD );
	    
	    HANDLE  hThreadHandle   = va_arg ( ap, HANDLE );

	    BOOL    fRegister       = va_arg( ap, BOOL );

	    (( REQTYPECAST *) 
	    preqbuf->RB_Buffer )->PnPNotif.pvNotifier = pvNotifier;
	                                                    
	    (( REQTYPECAST *) 
	    preqbuf->RB_Buffer )->PnPNotif.dwFlags = dwFlags;
	                                                    
	    (( REQTYPECAST *) 
	    preqbuf->RB_Buffer )->PnPNotif.pid = pid;
	                                                    
	    (( REQTYPECAST *) 
	    preqbuf->RB_Buffer )->PnPNotif.hThreadHandle = hThreadHandle;

	    ((REQTYPECAST *)
	    preqbuf->RB_Buffer)->PnPNotif.fRegister = fRegister;
	                                                    
	    preqbuf->RB_PCBIndex = 0;
	    
	}
    break;

    /*
    case REQTYPE_NOTIFYCONFIGCHANGE:
    {
        GUID *pGuid = va_arg( ap, GUID * );

        memcpy (&((REQTYPECAST *)
                preqbuf->RB_Buffer)->NotifyConfigChanged.
                Info.guidDevice ,
                pGuid,
                sizeof(GUID));
    }

    break; 

    */

    case REQTYPE_SETBAPPOLICY:
    {
        HCONN hConn                 = va_arg ( ap, HCONN );
        
        DWORD dwLowThreshold        = va_arg ( ap, DWORD );
        
        DWORD dwLowSamplePeriod     = va_arg ( ap, DWORD );
        
        DWORD dwHighThreshold       = va_arg ( ap, DWORD );
        
        DWORD dwHighSamplePeriod    = va_arg ( ap, DWORD );

        ((REQTYPECAST *) 
        preqbuf->RB_Buffer)->SetBapPolicy.hConn = hConn;
        
        ((REQTYPECAST *) 
        preqbuf->RB_Buffer)->SetBapPolicy.dwLowThreshold = 
                                                dwLowThreshold;
        
        ((REQTYPECAST *) 
        preqbuf->RB_Buffer)->SetBapPolicy.dwLowSamplePeriod = 
                                                dwLowSamplePeriod;
        
        ((REQTYPECAST *) 
        preqbuf->RB_Buffer)->SetBapPolicy.dwHighThreshold = 
                                                dwHighThreshold;
        
        ((REQTYPECAST *) 
        preqbuf->RB_Buffer)->SetBapPolicy.dwHighSamplePeriod = 
                                                dwHighSamplePeriod;
        
    }
    break;

    case REQTYPE_REFCONNECTION:
    {
        HCONN   hConn = va_arg ( ap, HCONN );
        BOOL    fAddref = va_arg ( ap, BOOL );

        preqbuf->RB_PCBIndex = 0;

        ((REQTYPECAST * ) 
        preqbuf->RB_Buffer)->RefConnection.hConn = hConn;
        
        ((REQTYPECAST * ) 
        preqbuf->RB_Buffer)->RefConnection.fAddref = fAddref;
    }
    break;

    case REQTYPE_GETEAPINFO:
    {
        HCONN   hConn = va_arg( ap, HCONN);
        DWORD   dwSubEntry = va_arg( ap, DWORD);

        pdwSize = va_arg(ap, DWORD *);
        pUserBuffer = va_arg(ap, PBYTE);

        if ( NULL == pUserBuffer )
        {
            *pdwSize = 0;
        }

        if ( *pdwSize )
        {
            retcode = AllocateBuffer(*pdwSize, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);
            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        pbTemp->RB_PCBIndex = 0;
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetEapInfo.hConn = hConn;
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetEapInfo.dwSubEntry = dwSubEntry;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetEapInfo.dwSizeofEapUIData = *pdwSize;
        
    }
    break;

    case REQTYPE_SETEAPINFO:
    {
        HPORT port              = va_arg(ap, HPORT);
        DWORD dwContextId       = va_arg(ap, DWORD);
        DWORD dwcb              = va_arg(ap, DWORD);
        PBYTE pbdata            = va_arg(ap, PBYTE);

        if ( dwcb )
        {
            retcode = AllocateBuffer(dwcb, 
                                    (PBYTE *) &pBuffer, 
                                    &dwSizeofBuffer);
            if(retcode)
            {
                goto done;
            }

            if (pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        pbTemp->RB_PCBIndex = PtrToUlong( port);
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->SetEapInfo.dwContextId = dwContextId;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->SetEapInfo.dwSizeofEapUIData = dwcb;

        memcpy (
          ((REQTYPECAST *)pbTemp->RB_Buffer)->SetEapInfo.data,
          pbdata,
          dwcb);

    }
    break;

    case REQTYPE_SETDEVICECONFIGINFO:
    {
        DWORD cEntries  = va_arg(ap, DWORD);
        
        DWORD cbData    = va_arg(ap, DWORD);
        
        pUserBuffer     = va_arg(ap, BYTE *);

        retcode = AllocateBuffer(cbData,
                                 (PBYTE *) &pBuffer,
                                 &dwSizeofBuffer);
        if(retcode)
        {
            goto done;
        }

        if(pBuffer)
        {
            pBuffer->RB_Reqtype = reqtype;
            pbTemp = pBuffer;
        }

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->DeviceConfigInfo.cEntries = cEntries;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->DeviceConfigInfo.cbBuffer = cbData;

        memcpy(
            ((REQTYPECAST *)
            pbTemp->RB_Buffer)->DeviceConfigInfo.abdata,
            pUserBuffer,
            cbData);
        
    }
    break;                                                                
    
    case REQTYPE_GETDEVICECONFIGINFO:
    {
        pdwVersion = va_arg(ap, DWORD *);
        
        pdwSize = va_arg(ap, DWORD *);

        pUserBuffer = (PBYTE) va_arg(ap, PBYTE);

        if(NULL == pUserBuffer)
        {
            *pdwSize = 0;
        }

        if(*pdwSize)
        {
            retcode = AllocateBuffer(*pdwSize,
                                    (PBYTE *) &pBuffer,
                                    &dwSizeofBuffer);

            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->DeviceConfigInfo.dwVersion = *pdwVersion;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->DeviceConfigInfo.cbBuffer = *pdwSize;
        
    }
    break;

    case REQTYPE_FINDPREREQUISITEENTRY:
    {
        HCONN hConn = va_arg(ap, HCONN);

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->FindRefConnection.hConn = hConn;

        break;
    }

    case REQTYPE_GETLINKSTATS:
    {
        HCONN hConn = va_arg(ap, HCONN);
        DWORD dwSubEntry = va_arg(ap, DWORD);

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->GetStats.hConn = hConn;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->GetStats.dwSubEntry = dwSubEntry;

        break;
    }

    case REQTYPE_GETCONNECTIONSTATS:
    {
        HCONN hConn = va_arg(ap, HCONN);

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->GetStats.hConn = hConn;

        break;
    }
    
    case REQTYPE_GETHPORTFROMCONNECTION:
    {
        HCONN hConn = va_arg(ap, HCONN);

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->GetHportFromConnection.hConn = hConn;

        break;
    }

    case REQTYPE_REFERENCECUSTOMCOUNT:
    {
        HCONN hConn = va_arg(ap, HCONN);
        
        BOOL  fAddref = va_arg(ap, BOOL);

        CHAR *pszPhonebook = NULL;
        
        CHAR *pszEntry = NULL;

        if(fAddref)
        {
            pszPhonebook = va_arg(ap, CHAR *);
            
            pszEntry = va_arg(ap, CHAR *);
        }

        if(     pszPhonebook
            &&  pszEntry)
        {
            strcpy(
             ((REQTYPECAST *)
             preqbuf->RB_Buffer)->ReferenceCustomCount.szPhonebookPath,
             pszPhonebook);

            strcpy(
             ((REQTYPECAST *)
             preqbuf->RB_Buffer)->ReferenceCustomCount.szEntryName,
             pszEntry);
        }    

        ((REQTYPECAST *)
         preqbuf->RB_Buffer)->ReferenceCustomCount.fAddRef = fAddref;

        ((REQTYPECAST *)
         preqbuf->RB_Buffer)->ReferenceCustomCount.hConn = hConn;

       break;
    }

    case REQTYPE_GETHCONNFROMENTRY:
    {
        CHAR *pszPhonebookPath = va_arg(ap, CHAR *);
        
        CHAR *pszEntryName = va_arg(ap, CHAR *);

        strcpy(
            ((REQTYPECAST *)
            preqbuf->RB_Buffer)->HconnFromEntry.szPhonebookPath,
            pszPhonebookPath);

        strcpy(
            ((REQTYPECAST *)
            preqbuf->RB_Buffer)->HconnFromEntry.szEntryName,
            pszEntryName);

        break;            
    }

    case REQTYPE_GETCONNECTINFO:
    {
        HPORT hPort = va_arg(ap, HPORT);
        
        pdwSize = va_arg(ap, DWORD *);

        pUserBuffer = (PBYTE) va_arg(ap, RAS_CONNECT_INFO *);

        if(NULL == pUserBuffer)
        {
            *pdwSize = 0;
        }

        if(*pdwSize)
        {
            retcode = AllocateBuffer(*pdwSize,
                                    (PBYTE *) &pBuffer,
                                    &dwSizeofBuffer);

            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        pbTemp->RB_PCBIndex = PtrToUlong( hPort);

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetConnectInfo.dwSize = *pdwSize;

        break;        
    }

    case REQTYPE_GETDEVICENAME:
    {

        RASDEVICETYPE eDeviceType = va_arg(ap, RASDEVICETYPE);

        //
        // dummy - this won't be looked at
        //
        pbTemp->RB_PCBIndex = 0;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetDeviceName.eDeviceType = eDeviceType;

        break;
    }

    case REQTYPE_GETDEVICENAMEW:
    {

        RASDEVICETYPE eDeviceType = va_arg(ap, RASDEVICETYPE);

        //
        // dummy - this won't be looked at
        //
        pbTemp->RB_PCBIndex = 0;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetDeviceNameW.eDeviceType = eDeviceType;

        break;
    }

    case REQTYPE_GETCALLEDID:
    {
        RAS_DEVICE_INFO *pDeviceInfo = va_arg(ap, RAS_DEVICE_INFO *);

        pdwSize = va_arg(ap, DWORD *);

        pUserBuffer = (PBYTE) va_arg(ap, RAS_CALLEDID_INFO *);

        if(NULL == pUserBuffer)
        {
            *pdwSize = 0;
        }

        if(*pdwSize)
        {
            retcode = AllocateBuffer(*pdwSize,
                                     (PBYTE *) &pBuffer,
                                     &dwSizeofBuffer);

            if(retcode)
            {
                goto done;
            }

            if(pBuffer)
            {
                pBuffer->RB_Reqtype = reqtype;
                pbTemp = pBuffer;
            }
        }
        else
        {
            pbTemp = preqbuf;
        }

        pbTemp->RB_PCBIndex = 0;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetSetCalledId.dwSize = *pdwSize;

        memcpy(
            (PBYTE) &((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetSetCalledId.rdi,
            pDeviceInfo,
            sizeof(RAS_DEVICE_INFO));

        break;
    }

    case REQTYPE_SETCALLEDID:
    {
        RAS_DEVICE_INFO *pDeviceInfo = va_arg(ap, RAS_DEVICE_INFO *);

        RAS_CALLEDID_INFO *pCalledId = va_arg(ap, RAS_CALLEDID_INFO *);

        BOOL fWrite = va_arg(ap, BOOL);

        retcode = AllocateBuffer(pCalledId->dwSize,
                                 (PBYTE *) &pBuffer,
                                 &dwSizeofBuffer);

        if(retcode)
        {
            goto done;
        }

        if(pBuffer)
        {
            pBuffer->RB_Reqtype = reqtype;
            pbTemp = pBuffer;
        }

        pbTemp->RB_PCBIndex = 0;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetSetCalledId.fWrite = fWrite;

        memcpy(
            (LPBYTE) &((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetSetCalledId.rdi,
            (LPBYTE) pDeviceInfo,
            sizeof(RAS_DEVICE_INFO));

        memcpy(
            (LPBYTE) ((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetSetCalledId.rciInfo.bCalledId,
            pCalledId->bCalledId,
            pCalledId->dwSize);

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetSetCalledId.rciInfo.dwSize =
                                                pCalledId->dwSize;

        break;            
    }

    case REQTYPE_ENABLEIPSEC:
    {
        HPORT hPort   = va_arg(ap, HPORT);
        BOOL  fEnable = va_arg(ap, BOOL);
        BOOL  fServer = va_arg(ap, BOOL);

        RAS_L2TP_ENCRYPTION eEncryption =
                va_arg(ap, RAS_L2TP_ENCRYPTION);

        preqbuf->RB_PCBIndex = PtrToUlong( hPort);

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->EnableIpSec.fEnable = fEnable;

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->EnableIpSec.fServer = fServer;
    
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->EnableIpSec.eEncryption = eEncryption;

        break;
    }

    case REQTYPE_ISIPSECENABLED:
    {
        HPORT hPort = va_arg(ap, HPORT);

        preqbuf->RB_PCBIndex = PtrToUlong( hPort);

        break;
    }

    case REQTYPE_SETEAPLOGONINFO:
    {
        HPORT hPort = va_arg(ap, HPORT);

        BOOL  fLogon = va_arg(ap, BOOL);
        
        RASEAPINFO * pEapInfo = va_arg(ap, RASEAPINFO *);

        retcode = AllocateBuffer(pEapInfo->dwSizeofEapInfo,
                                 (PBYTE *) &pBuffer,
                                 &dwSizeofBuffer);

        if(retcode)
        {   
            goto done;
        }

        if(pBuffer)
        {
            pBuffer->RB_Reqtype = reqtype;
            pbTemp = pBuffer;
        }

        pbTemp->RB_PCBIndex = PtrToUlong( hPort);

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->SetEapLogonInfo.dwSizeofEapData = 
                                    pEapInfo->dwSizeofEapInfo;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->SetEapLogonInfo.fLogon = fLogon;

        memcpy(((REQTYPECAST *)
                pbTemp->RB_Buffer)->SetEapLogonInfo.abEapData,
                pEapInfo->pbEapInfo,
                pEapInfo->dwSizeofEapInfo);

        break;                
    }

    case REQTYPE_SENDNOTIFICATION:
    {
        RASEVENT *pRasEvent = va_arg(ap, RASEVENT *);

        //
        // dummy - this won't be looked at
        //
        pbTemp->RB_PCBIndex = 0;

        memcpy(
            (PBYTE) &((REQTYPECAST *)
            pbTemp->RB_Buffer)->SendNotification.RasEvent,
            (PBYTE) pRasEvent,
            sizeof(RASEVENT));

        break;
    }

    case REQTYPE_GETNDISWANDRIVERCAPS:
    {
        pbTemp->RB_PCBIndex = 0;
        
        break;
    }

    case REQTYPE_GETBANDWIDTHUTILIZATION:
    {
        HPORT hPort = va_arg(ap, HPORT);

        pbTemp->RB_PCBIndex = PtrToUlong( hPort);
        
        break;
    }

    case REQTYPE_REGISTERREDIALCALLBACK:
    {
        PVOID pvfn = va_arg(ap, PVOID);

        pbTemp->RB_PCBIndex = 0;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->RegisterRedialCallback.pvCallback
                                                    = pvfn;

        break;                                                    
    }

    case REQTYPE_GETPROTOCOLINFO:
    {
        pbTemp->RB_PCBIndex = 0;

        break;
    }

    case REQTYPE_GETCUSTOMSCRIPTDLL:
    {
        pbTemp->RB_PCBIndex = 0;

        break;
    }

    case REQTYPE_ISTRUSTEDCUSTOMDLL:
    {
        WCHAR *pwszCustomDll = va_arg( ap, WCHAR * );

        
        pbTemp->RB_PCBIndex = 0;

        wcscpy(
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->IsTrusted.wszCustomDll,
        pwszCustomDll);

        break;        
    }

    case REQTYPE_DOIKE:
    {
        HPORT   hPort = va_arg(ap, HPORT);
        HANDLE  hEvent = va_arg(ap, HANDLE);

        pbTemp->RB_PCBIndex = PtrToUlong( hPort);

        ((REQTYPECAST *) pbTemp->RB_Buffer)->DoIke.hEvent = hEvent;
        ((REQTYPECAST *) pbTemp->RB_Buffer)->DoIke.pid = 
                                        GetCurrentProcessId();
        break;                                        
    }

    case REQTYPE_QUERYIKESTATUS:
    {
        HPORT hPort = va_arg(ap, HPORT);

        pbTemp->RB_PCBIndex = PtrToUlong(hPort);

        break;
    }

    case REQTYPE_SETRASCOMMSETTINGS:
    {
        HPORT hPort = va_arg(ap, HPORT);

        RASCOMMSETTINGS *rs = va_arg(ap, RASCOMMSETTINGS *);

        pbTemp->RB_PCBIndex = PtrToUlong(hPort);

        ((REQTYPECAST *) 
        pbTemp->RB_Buffer)->SetRasCommSettings.Settings.bParity 
                                                    = rs->bParity;

        ((REQTYPECAST *) 
        pbTemp->RB_Buffer)->SetRasCommSettings.Settings.bStop
                                                    = rs->bStop;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->SetRasCommSettings.Settings.bByteSize
                                                    = rs->bByteSize;

        break;        
    }

    case REQTYPE_ENABLERASAUDIO:
    {
        //
        // This is ignored
        //
        pbTemp->RB_PCBIndex = 0;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->EnableRasAudio.fEnable =
                                va_arg(ap, BOOL);

        break;                                
    }

    case REQTYPE_SETKEY:
    {
        GUID  *pGuid = va_arg(ap, GUID *);
        DWORD dwMask = va_arg(ap, DWORD);
        DWORD cbkey = va_arg(ap, DWORD);
        PBYTE pbkey = va_arg(ap, PBYTE);

        retcode = AllocateBuffer(cbkey,
                                 (PBYTE *) &pBuffer,
                                 &dwSizeofBuffer);

        if(retcode)
        {
            goto done;
        }

        pbTemp->RB_PCBIndex = 0;

        if(pBuffer)
        {
            pBuffer->RB_Reqtype = reqtype;
            pbTemp = pBuffer;
        }

        if(NULL != pGuid)
        {
            memcpy(
            &((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetSetKey.guid,
            pGuid,
            sizeof(GUID));
        }
        else
        {
            memset(
            &((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetSetKey.guid,
            0, sizeof(GUID));
        }

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetSetKey.dwMask = dwMask;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetSetKey.cbkey = cbkey;

        if(cbkey > 0)
        {
            memcpy(
            ((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetSetKey.data,
            pbkey,
            cbkey);
        }
        
        break;
    }

    case REQTYPE_GETKEY:
    {
        GUID *pGuid  = va_arg(ap, GUID *);
        DWORD dwMask = va_arg(ap, DWORD);
        pdwSize = va_arg(ap, DWORD *);

        retcode = AllocateBuffer(*pdwSize,
                                (PBYTE *) &pBuffer,
                                &dwSizeofBuffer);

        if(retcode)
        {
            goto done;
        } 
        
        pbTemp->RB_PCBIndex = 0;

        if(pBuffer)
        {
            pBuffer->RB_Reqtype = reqtype;
            pbTemp = pBuffer;
        }

        if(NULL != pGuid)
        {
            memcpy(
            &((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetSetKey.guid,
            pGuid,
            sizeof(GUID));
        }
        
        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetSetKey.dwMask = dwMask;

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->GetSetKey.cbkey = *pdwSize;

        break;
    }

    case REQTYPE_ADDRESSDISABLE:
    {
        WCHAR *pszAddress = va_arg( ap, WCHAR * );
        BOOL  fDisable = va_arg(ap, BOOL);

        pbTemp->RB_PCBIndex = 0;

        wcscpy(((REQTYPECAST *)
                pbTemp->RB_Buffer)->AddressDisable.szAddress,
                pszAddress);

        ((REQTYPECAST *)
        pbTemp->RB_Buffer)->AddressDisable.fDisable = fDisable;

        break;
    }

    case REQTYPE_SENDCREDS:
    {
        HPORT hport = va_arg(ap, HPORT);
        CHAR  controlchar = va_arg(ap, CHAR);

        pbTemp->RB_PCBIndex = PtrToUlong(hport);
        
        ((REQTYPECAST *)
         pbTemp->RB_Buffer)->SendCreds.pid =
                    GetCurrentProcessId();

        ((REQTYPECAST *)
         pbTemp->RB_Buffer)->SendCreds.controlchar =
                    controlchar;

        break;                    
    }

    case REQTYPE_GETUNICODEDEVICENAME:
    {
        HPORT hport = va_arg(ap, HPORT);

        //
        // dummy - this won't be looked at
        //
        pbTemp->RB_PCBIndex = HandleToUlong(hport);

        break;
    }

    } // switch(reqtype)
    
    //
    // The request packet is now ready. Pass it on to 
    // the request thread:
    //
    retcode = PutRequestInQueue (hConnection, pbTemp, dwSizeofBuffer) ;

    if(ERROR_SUCCESS != retcode)
    {
        goto done;
    }

#if DBG
    ASSERT(reqtype == pbTemp->RB_Reqtype);
#endif

    //
    // The request has been completed by the requestor thread: 
    // copy the results into the user supplied arguments:
    //
    switch (reqtype) {

    case REQTYPE_PORTENUM:
    case REQTYPE_DEVICEENUM:
    {
        PDWORD entries = va_arg(ap, PDWORD) ;

        if (*pdwSize >= ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.size)
        {  
            retcode = ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.retcode ;
        }   
        else
        {
            retcode = ERROR_BUFFER_TOO_SMALL ;
        }
        
        *pdwSize   = ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.size ;
        
        *entries = ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.entries ;
        
        if (retcode == SUCCESS)
        {
            memcpy (pUserBuffer,
                    ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.buffer,
                    *pdwSize);
        }
    }
    break ;

    case REQTYPE_PROTOCOLENUM:
    {
        PBYTE buffer	= pUserBuffer ;
        
        PDWORD size		= pdwSize ;
        
        PDWORD entries	= va_arg(ap, PDWORD) ;

        if (*size >= ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.size)
        {
            retcode = ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.retcode ;
        }   
        else
        {
            retcode = ERROR_BUFFER_TOO_SMALL ;
        }
        
        *size   = ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.size ;
        
        *entries = ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.entries ;
        
        if (retcode == SUCCESS)
        {
            memcpy (buffer,
                    ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.buffer,
                    *size);
        }       
    }
    break;
    
    case REQTYPE_PORTGETINFO:
    case REQTYPE_DEVICEGETINFO:
    {
        PBYTE buffer   = pUserBuffer ;
        PDWORD size    = pdwSize ;

        if (*size >= ((REQTYPECAST *)
                      pbTemp->RB_Buffer)->GetInfo.size)
        {    
            retcode = ((REQTYPECAST *)
                      pbTemp->RB_Buffer)->GetInfo.retcode ;
        }   
        else
        {
            retcode = ERROR_BUFFER_TOO_SMALL ;
        }
        
        *size = ((REQTYPECAST *)pbTemp->RB_Buffer)->GetInfo.size ;

        if (retcode == SUCCESS) 
        {
            RASMAN_DEVICEINFO *devinfo =
               (RASMAN_DEVICEINFO *)
               ((REQTYPECAST*)pbTemp->RB_Buffer)->GetInfo.buffer ;
               
            //
            // Convert the offset based param structure into 
            // pointer based.
            //
            ConvParamOffsetToPointer (devinfo->DI_Params,
                          devinfo->DI_NumOfParams);
            CopyParams (
               devinfo->DI_Params,
               ((RASMAN_DEVICEINFO *) buffer)->DI_Params,
               devinfo->DI_NumOfParams);
               
            ((RASMAN_DEVICEINFO*)buffer)->DI_NumOfParams = 
                                    devinfo->DI_NumOfParams;
        }
    }
    break ;

    case REQTYPE_PORTOPEN:
    {
        HPORT *handle = va_arg(ap, HPORT*) ;

        if ((retcode = ((REQTYPECAST *)
                        preqbuf->RB_Buffer)->PortOpen.retcode)
                                       == SUCCESS)
        {                                       
            *handle = ((REQTYPECAST*)
                      preqbuf->RB_Buffer)->PortOpen.porthandle;
        }
    }
    break ;

    case REQTYPE_PORTOPENEX:
    {
        HPORT *phport = va_arg(ap, HPORT *);

        if(SUCCESS == (retcode = ((REQTYPECAST *)
                      preqbuf->RB_Buffer)->PortOpenEx.retcode))
        {
            *phport = ((REQTYPECAST *)
                      preqbuf->RB_Buffer)->PortOpenEx.hport;
        }

        *pdwFlags = ((REQTYPECAST *)
                    preqbuf->RB_Buffer)->PortOpenEx.dwFlags;
    }
    break;

    case REQTYPE_PORTGETSTATISTICS:
    case REQTYPE_BUNDLEGETSTATISTICS:
    case REQTYPE_PORTGETSTATISTICSEX:
    case REQTYPE_BUNDLEGETSTATISTICSEX:
    {
        RAS_STATISTICS *statbuffer = va_arg(ap, RAS_STATISTICS*) ;
        PDWORD          size    = va_arg(ap, PDWORD) ;
        
        //
        // some local variables...
        //
        DWORD           returnedsize ;
        
        RAS_STATISTICS *temp = &((REQTYPECAST*)
                        preqbuf->RB_Buffer)->PortGetStatistics.statbuffer;

        retcode = ((REQTYPECAST *)
                   preqbuf->RB_Buffer)->PortGetStatistics.retcode;

        returnedsize = ((temp->S_NumOfStatistics - 1) * sizeof(ULONG))
                        + sizeof(RAS_STATISTICS);

        if (    (SUCCESS == retcode)
            &&  (*size < returnedsize))
        {
            retcode = ERROR_BUFFER_TOO_SMALL ;
        }
        
        /*
        else
        {
            retcode = ((REQTYPECAST*)
                      preqbuf->RB_Buffer)->PortGetStatistics.retcode;
        } */

        if (    (retcode == SUCCESS) 
            ||  (retcode == ERROR_BUFFER_TOO_SMALL))
        {
            memcpy (statbuffer, temp, *size) ;
        }

        *size = returnedsize ;
    }
    break ;

    case REQTYPE_GETINFO:
    {
        RASMAN_INFO *info = va_arg(ap, RASMAN_INFO*) ;

        retcode = ((REQTYPECAST*)preqbuf->RB_Buffer)->Info.retcode ;
        
        memcpy (info,
               &((REQTYPECAST *)preqbuf->RB_Buffer)->Info.info,
               sizeof (RASMAN_INFO));
               
        //
        // Now we set the OwnershipFlag in the GetInfo 
        // structure to tell us whether the caller owns 
        // the port or not.
        //
        if (info->RI_OwnershipFlag == GetCurrentProcessId())
        {
            info->RI_OwnershipFlag = TRUE ;
        }
        else
        {
            info->RI_OwnershipFlag = FALSE ;
        }
    }
    break ;

    case REQTYPE_GETINFOEX:
    {
        RASMAN_INFO *info = va_arg(ap, RASMAN_INFO*) ;

        retcode = ((REQTYPECAST*)preqbuf->RB_Buffer)->InfoEx.retcode;
        
        memcpy (info,
               &((REQTYPECAST *)preqbuf->RB_Buffer)->InfoEx.info,
               sizeof (RASMAN_INFO) 
               * ((REQTYPECAST *)preqbuf->RB_Buffer)->InfoEx.count);

    }
    break ;


    case REQTYPE_ACTIVATEROUTEEX:
    case REQTYPE_ACTIVATEROUTE:
    case REQTYPE_ALLOCATEROUTE:
    {
        RASMAN_ROUTEINFO *info = va_arg(ap,RASMAN_ROUTEINFO*) ;

        retcode= ((REQTYPECAST*)preqbuf->RB_Buffer)->Route.retcode ;
        
        if ((retcode == SUCCESS) && info)
        {
            memcpy(info,
                   &((REQTYPECAST*)preqbuf->RB_Buffer)->Route.info,
                   sizeof(RASMAN_ROUTEINFO));
        }
    }
    break ;

    case REQTYPE_GETUSERCREDENTIALS:
    {
        PWCHAR  UserName    = va_arg(ap, PWCHAR);
        PBYTE   CSCResponse = va_arg(ap, PBYTE);
        PBYTE   CICResponse = va_arg(ap, PBYTE);
        PBYTE   LMSessionKey= va_arg(ap, PBYTE);
    	PBYTE	UserSessionKey = va_arg(ap, PBYTE);

        memcpy (UserName,
               ((REQTYPECAST*)
               preqbuf->RB_Buffer)->GetCredentials.UserName,
               sizeof(WCHAR) * MAX_USERNAME_SIZE) ;
               
        memcpy(CSCResponse,
               ((REQTYPECAST*)
               preqbuf->RB_Buffer)->GetCredentials.CSCResponse,
               MAX_RESPONSE_SIZE);
               
        memcpy(CICResponse,
               ((REQTYPECAST*)
               preqbuf->RB_Buffer)->GetCredentials.CICResponse,
               MAX_RESPONSE_SIZE);
               
        memcpy(LMSessionKey,
               ((REQTYPECAST*)
               preqbuf->RB_Buffer)->GetCredentials.LMSessionKey,
               MAX_SESSIONKEY_SIZE);
               
        memcpy(UserSessionKey,
               ((REQTYPECAST*)
               preqbuf->RB_Buffer)->GetCredentials.UserSessionKey,
               MAX_USERSESSIONKEY_SIZE);

        retcode = ((REQTYPECAST *)
                  preqbuf->RB_Buffer)->GetCredentials.retcode ;
    }
    break ;

    case REQTYPE_SETCACHEDCREDENTIALS:
    {
        retcode = ((REQTYPECAST *)
                    preqbuf->RB_Buffer)->SetCachedCredentials.retcode;
    }
    break;

    case REQTYPE_COMPRESSIONGETINFO:
    {
        RAS_COMPRESSION_INFO *send = va_arg(ap, RAS_COMPRESSION_INFO *) ;
        
        RAS_COMPRESSION_INFO *recv = va_arg(ap, RAS_COMPRESSION_INFO *) ;

        memcpy (send,
            &((REQTYPECAST *)preqbuf->RB_Buffer)->CompressionGetInfo.
            send,
            sizeof (RAS_COMPRESSION_INFO)) ;

        memcpy (recv,
            &((REQTYPECAST *)preqbuf->RB_Buffer)->CompressionGetInfo.
            recv,
            sizeof (RAS_COMPRESSION_INFO)) ;

        retcode = ((REQTYPECAST*)
                   preqbuf->RB_Buffer)->CompressionGetInfo.retcode;
    }
    break ;

    case REQTYPE_ENUMLANNETS:
    {
        DWORD *count    = va_arg (ap, DWORD*) ;
        
        UCHAR *lanas    = va_arg (ap, UCHAR*) ;

        *count =
          (((REQTYPECAST*)preqbuf->RB_Buffer)->EnumLanNets.count <
            MAX_LAN_NETS) ?
           ((REQTYPECAST*)preqbuf->RB_Buffer)->EnumLanNets.count :
           MAX_LAN_NETS ;
           
        memcpy (lanas,
            ((REQTYPECAST *)preqbuf->RB_Buffer)->EnumLanNets.lanas,
            (*count) * sizeof (UCHAR)) ;
            
        retcode = SUCCESS ;
    }
    break ;

    case REQTYPE_RETRIEVEUSERDATA:
    {

        if ((retcode = 
            ((REQTYPECAST *)pbTemp->RB_Buffer)->OldUserData.retcode) 
            != SUCCESS)
        {                
            break ;
        }

        if (*pdwSize < ((REQTYPECAST *)pbTemp->RB_Buffer)->OldUserData.size) 
        {
            *pdwSize    = ((REQTYPECAST *)pbTemp->RB_Buffer)->OldUserData.
                            size ;
            
            retcode     = ERROR_BUFFER_TOO_SMALL ;
            
            break ;
        }

        *pdwSize = ((REQTYPECAST *)pbTemp->RB_Buffer)->OldUserData.size ;

        memcpy (pUserBuffer,
            ((REQTYPECAST *)pbTemp->RB_Buffer)->OldUserData.data,
            *pdwSize) ;

        retcode = SUCCESS ;

    }
    break ;

    case REQTYPE_GETFRAMINGEX:
    {
        RAS_FRAMING_INFO *info = va_arg(ap, RAS_FRAMING_INFO *) ;

        if ((retcode = 
            ((REQTYPECAST *)preqbuf->RB_Buffer)->FramingInfo.retcode) 
            != SUCCESS)
        {
            break ;
        }

        memcpy (info,
            &((REQTYPECAST *)preqbuf->RB_Buffer)->FramingInfo.info,
            sizeof (RAS_FRAMING_INFO)) ;

        retcode = SUCCESS ;

    }
    break ;

    case REQTYPE_GETPROTOCOLCOMPRESSION:
    {
        RAS_PROTOCOLCOMPRESSION *send = va_arg(ap, 
                                    RAS_PROTOCOLCOMPRESSION *) ;
        
        RAS_PROTOCOLCOMPRESSION *recv = va_arg(ap, 
                                    RAS_PROTOCOLCOMPRESSION *) ;

        if ((retcode = 
            ((REQTYPECAST *)preqbuf->RB_Buffer)->ProtocolComp.retcode) 
            != SUCCESS)
        {
            break ;
        }

        memcpy (send,
            &((REQTYPECAST *)
            preqbuf->RB_Buffer)->ProtocolComp.send,
            sizeof (RAS_PROTOCOLCOMPRESSION)) ;

        memcpy (recv,
            &((REQTYPECAST *)preqbuf->RB_Buffer)->ProtocolComp.recv,
            sizeof (RAS_PROTOCOLCOMPRESSION)) ;
    }
    break ;

    case REQTYPE_PORTENUMPROTOCOLS:
    {
        RAS_PROTOCOLS *protocols = va_arg (ap, RAS_PROTOCOLS*) ;
        PDWORD         count  = va_arg (ap, PDWORD) ;

        memcpy (protocols,
            &((REQTYPECAST *)
            preqbuf->RB_Buffer)->EnumProtocols.protocols,
            sizeof (RAS_PROTOCOLS)) ;
            
        *count = ((REQTYPECAST *)
                 preqbuf->RB_Buffer)->EnumProtocols.count ;

        retcode = ((REQTYPECAST *)
                  preqbuf->RB_Buffer)->EnumProtocols.retcode ;
    }
    break ;

    case REQTYPE_GETFRAMINGCAPABILITIES:
    {
        RAS_FRAMING_CAPABILITIES* caps = va_arg (ap, 
                                RAS_FRAMING_CAPABILITIES*) ;

        memcpy (caps,
            &((REQTYPECAST *)
            preqbuf->RB_Buffer)->FramingCapabilities.caps,
            sizeof (RAS_FRAMING_CAPABILITIES)) ;

        retcode = ((REQTYPECAST *)
                  preqbuf->RB_Buffer)->FramingCapabilities.retcode ;
    }
    break ;

    case REQTYPE_GETBUNDLEDPORT:
    {
        HPORT *phport = va_arg (ap, HPORT*) ;

        *phport = ((REQTYPECAST *)
                   preqbuf->RB_Buffer)->GetBundledPort.port ;

        retcode = ((REQTYPECAST *)
                  preqbuf->RB_Buffer)->GetBundledPort.retcode ;
    }
    break ;

    case REQTYPE_PORTGETBUNDLE:
    {
        HBUNDLE *phbundle = va_arg(ap, HBUNDLE *) ;

        *phbundle = ((REQTYPECAST *)
                    preqbuf->RB_Buffer)->PortGetBundle.bundle;
        
        retcode = ((REQTYPECAST *)
                   preqbuf->RB_Buffer)->PortGetBundle.retcode ;
    }
    break ;

    case REQTYPE_BUNDLEGETPORT:
    {
        HPORT *phport = va_arg (ap, HPORT*) ;

        *phport = ((REQTYPECAST *)
                  preqbuf->RB_Buffer)->BundleGetPort.port ;
        
        retcode = ((REQTYPECAST *)
                  preqbuf->RB_Buffer)->BundleGetPort.retcode ;
    }
    break ;

    case REQTYPE_GETDIALPARAMS:
    {
        PRAS_DIALPARAMS pDialParams = va_arg(ap, PRAS_DIALPARAMS);
        
        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->DialParams.retcode;

        if(retcode == SUCCESS)
        {
            *pdwMaskDialParams = ((REQTYPECAST *)
                                pbTemp->RB_Buffer)->DialParams.dwMask;
            
            RtlCopyMemory(
              pDialParams,
              &(((REQTYPECAST *)
              pbTemp->RB_Buffer)->DialParams.params),
              sizeof (RAS_DIALPARAMS));
        }
    }
    break;

    case REQTYPE_SETDIALPARAMS:
    {
        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->DialParams.retcode;
    }
    break;

    case REQTYPE_CREATECONNECTION:
    {
        HCONN *lphconn              = va_arg(ap, HCONN *);
        
        DWORD *pdwAlreadyConnected  = va_arg(ap, DWORD *);
        
        DWORD *pdwSubEntryInfo      = va_arg(ap, DWORD * );

        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->Connection.retcode;
        
        if (retcode == SUCCESS)
        {
            DWORD dwSubEntries = ((REQTYPECAST *)
                pbTemp->RB_Buffer)->Connection.dwSubEntries;
            
            *lphconn = ((REQTYPECAST *)
                pbTemp->RB_Buffer)->Connection.conn;
            
            *pdwAlreadyConnected = ((REQTYPECAST *)
                            pbTemp->RB_Buffer)->Connection.
                            dwEntryAlreadyConnected;

            if ( *pdwAlreadyConnected )
            {
                memcpy ( pdwSubEntryInfo,
                       ((REQTYPECAST *)
                       pbTemp->RB_Buffer)->Connection.data,
                       dwSubEntries * sizeof ( DWORD ) );
            }
        }
    }
    break;

    case REQTYPE_DESTROYCONNECTION:
    {
        retcode = ((REQTYPECAST *)
                  preqbuf->RB_Buffer)->Connection.retcode;
    }
    break;

    case REQTYPE_ENUMCONNECTION:
    {
        HCONN   *lphconn            = (HCONN *) pUserBuffer;
        
        LPDWORD lpdwcbConnections   = pdwSize;
        
        LPDWORD lpdwcConnections    = va_arg(ap, LPDWORD);

        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->Enum.retcode;
        
        if (lphconn != NULL) 
        {
            if (*lpdwcbConnections >=
                ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.size)
            {
                memcpy(
                  lphconn,
                  &((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.buffer,
                  ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.size);
            }
            else
                retcode = ERROR_BUFFER_TOO_SMALL;
        }
        *lpdwcbConnections =
          ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.size;
          
        *lpdwcConnections =
          ((REQTYPECAST *)pbTemp->RB_Buffer)->Enum.entries;
    }
    break;

    case REQTYPE_ADDCONNECTIONPORT:
    {
        retcode = ((REQTYPECAST *)
                  preqbuf->RB_Buffer)->AddConnectionPort.retcode;
    }
    break;

    case REQTYPE_ENUMCONNECTIONPORTS:
    {
        RASMAN_PORT *lpPorts        = ( RASMAN_PORT *) pUserBuffer;
        
        LPDWORD     lpdwcbPorts     = pdwSize;
        
        LPDWORD     lpdwcPorts      = va_arg(ap, LPDWORD);

        if (*lpdwcbPorts >= ((REQTYPECAST *)
                pbTemp->RB_Buffer)->EnumConnectionPorts.size)
        {
            retcode = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->EnumConnectionPorts.retcode;
        }
        else
        {
            retcode = ERROR_BUFFER_TOO_SMALL;
        }
            
        *lpdwcbPorts = ((REQTYPECAST *)
                pbTemp->RB_Buffer)->EnumConnectionPorts.size;
          
        *lpdwcPorts = ((REQTYPECAST *)
                pbTemp->RB_Buffer)->EnumConnectionPorts.entries;
          
        if (    retcode == SUCCESS 
            &&  lpPorts != NULL) 
        {
            memcpy(
              lpPorts,
              ((REQTYPECAST *)
              pbTemp->RB_Buffer)->EnumConnectionPorts.buffer,
              ((REQTYPECAST *)
              pbTemp->RB_Buffer)->EnumConnectionPorts.size);
        }
    }
    break;

    case REQTYPE_GETCONNECTIONPARAMS:
    {
        PRAS_CONNECTIONPARAMS pParams = va_arg(ap, PRAS_CONNECTIONPARAMS);

        memcpy(
          pParams,
          &(((REQTYPECAST *)
          preqbuf->RB_Buffer)->ConnectionParams.params),
          sizeof (RAS_CONNECTIONPARAMS));
          
        retcode = ((REQTYPECAST *)
                preqbuf->RB_Buffer)->ConnectionParams.retcode;
    }
    break;

    case REQTYPE_SETCONNECTIONPARAMS:
    {
        retcode = ((REQTYPECAST *)
                preqbuf->RB_Buffer)->ConnectionParams.retcode;
    }
    break;

    case REQTYPE_GETCONNECTIONUSERDATA:
    {
        PBYTE   pBuf    = pUserBuffer ;
        LPDWORD lpdwcb  = pdwSize;

        if ((retcode = 
           ((REQTYPECAST *)
           pbTemp->RB_Buffer)->ConnectionUserData.retcode) 
           != SUCCESS)
        {
            break ;
        }
            
        if (lpdwcb != NULL) 
        {
            if (*lpdwcb <
                ((REQTYPECAST *)
                pbTemp->RB_Buffer)->ConnectionUserData.dwcb)
            {
                *lpdwcb = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->ConnectionUserData.dwcb;
                
                retcode = ERROR_BUFFER_TOO_SMALL ;
                break ;
            }
            
            *lpdwcb = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->ConnectionUserData.dwcb;
        }
        
        if (pBuf != NULL) 
        {
            memcpy(
              pBuf,
              ((REQTYPECAST *)
              pbTemp->RB_Buffer)->ConnectionUserData.data,
              ((REQTYPECAST *)
              pbTemp->RB_Buffer)->ConnectionUserData.dwcb);
        }
        
        retcode = SUCCESS ;
    }
    break;

    case REQTYPE_SETCONNECTIONUSERDATA:
    {
        retcode = ((REQTYPECAST *)
            preqbuf->RB_Buffer)->ConnectionUserData.retcode;
    }
    break;

    case REQTYPE_GETPORTUSERDATA:
    {
        PBYTE pBuf      = pUserBuffer;
        LPDWORD lpdwcb  = pdwSize;

        if ((retcode = 
            ((REQTYPECAST *)
            pbTemp->RB_Buffer)->PortUserData.retcode) 
            != SUCCESS)
        {
            break ;
        }
            
        if (lpdwcb != NULL) 
        {
            if (*lpdwcb < ((REQTYPECAST *)
                pbTemp->RB_Buffer)->PortUserData.dwcb)
            {
                *lpdwcb = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->PortUserData.dwcb;
                    
                retcode = ERROR_BUFFER_TOO_SMALL ;
                
                break ;
            }
            
            *lpdwcb = ((REQTYPECAST *)
                      pbTemp->RB_Buffer)->PortUserData.dwcb;
        }
        
        if (pBuf != NULL) 
        {
            memcpy(
              pBuf,
              ((REQTYPECAST *)
              pbTemp->RB_Buffer)->PortUserData.data,
              ((REQTYPECAST *)
              pbTemp->RB_Buffer)->PortUserData.dwcb);
        }
        
        retcode = SUCCESS ;
    }
    
    break;

    case REQTYPE_SETPORTUSERDATA:
    {
        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->PortUserData.retcode;
    }
    break;

    case REQTYPE_PPPGETINFO:
    {
        PPP_MESSAGE * pPppMsg = va_arg(ap, PPP_MESSAGE*);

        memcpy( pPppMsg,
                &(((REQTYPECAST *)
                preqbuf->RB_Buffer)->PppMsg),
                sizeof( PPP_MESSAGE ) );

        retcode = pPppMsg->dwError;
    }
    break;

    case REQTYPE_GETTIMESINCELASTACTIVITY:
    {
        LPDWORD lpdwTimeSinceLastActivity = va_arg(ap, LPDWORD);

        *lpdwTimeSinceLastActivity =
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->GetTimeSinceLastActivity.dwTimeSinceLastActivity;

        retcode =
        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->GetTimeSinceLastActivity.dwRetCode;
    }
    break;

    case REQTYPE_ADDNOTIFICATION:
    {
        retcode = ((REQTYPECAST *)
                preqbuf->RB_Buffer)->AddNotification.retcode;
    }
    break;

    case REQTYPE_SIGNALCONNECTION:
    {
        retcode = ((REQTYPECAST *)
                preqbuf->RB_Buffer)->SignalConnection.retcode;
    }
    break;

    case REQTYPE_GETDEVCONFIG:
    {
        if ((retcode = 
            ((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetDevConfig.retcode) 
            != SUCCESS)
        {
            ;
        }
        else if (((REQTYPECAST *)
                pbTemp->RB_Buffer)->GetDevConfig.size > *pdwSize)

        {
            retcode = ERROR_BUFFER_TOO_SMALL ;
        }
        else
        {
            memcpy (pUserBuffer,
                    ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->GetDevConfig.config,
                    ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->GetDevConfig.size) ;
        }

        *pdwSize = ((REQTYPECAST *)
                pbTemp->RB_Buffer)->GetDevConfig.size ;
    }
    break ;

    case REQTYPE_GETDEVCONFIGEX:
    {

        if ((retcode = 
            ((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetDevConfigEx.retcode) 
            != SUCCESS)
        {
            ;
        }
        else if (((REQTYPECAST *)
                pbTemp->RB_Buffer)->GetDevConfigEx.size > *pdwSize)

        {
            retcode = ERROR_BUFFER_TOO_SMALL ;
        }
        else
        {
            memcpy (pUserBuffer,
                    ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->GetDevConfigEx.config,
                    ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->GetDevConfigEx.size) ;
        }

        *pdwSize = ((REQTYPECAST *)
                pbTemp->RB_Buffer)->GetDevConfigEx.size ;
    
        break;
    }

    case REQTYPE_PORTRECEIVEEX:
    {
        PBYTE pBuffer = va_arg ( ap, PBYTE );
        
        PDWORD size  = va_arg (ap, DWORD * );
        
        DWORD  dwSize;
        
        if ((retcode = 
            ((REQTYPECAST *)
            preqbuf->RB_Buffer)->PortReceiveEx.retcode ) 
            == SUCCESS )
        {
            memcpy (pBuffer,
                    &((REQTYPECAST *)
                    preqbuf->RB_Buffer)->PortReceiveEx.
                    buffer.SRB_Packet.PacketData,
                    MAX_SENDRCVBUFFER_SIZE);

            dwSize = ((REQTYPECAST *)
                     preqbuf->RB_Buffer)->PortReceiveEx.size;

            *size = ((dwSize > MAX_SENDRCVBUFFER_SIZE)
                    ? MAX_SENDRCVBUFFER_SIZE : dwSize );
        }
        break;
    }

    case REQTYPE_GETATTACHEDCOUNT:
    {
        DWORD *pdwAttachedCount = va_arg ( ap, DWORD * );

        if ((retcode = 
            ((REQTYPECAST *)
            preqbuf->RB_Buffer)->GetAttachedCount.retcode ) 
            == SUCCESS )
        {
            *pdwAttachedCount = ((REQTYPECAST *)
                                 preqbuf->RB_Buffer)->GetAttachedCount.
                                 dwAttachedCount;
        }

        break;
    }

    case REQTYPE_REFCONNECTION:
    {
        PDWORD pdwRefCount = va_arg ( ap, DWORD * );

        retcode = ((REQTYPECAST*)
                    preqbuf->RB_Buffer)->RefConnection.retcode;

        if (    SUCCESS == retcode
            &&  pdwRefCount )
        {
            *pdwRefCount = ((REQTYPECAST *)
                            preqbuf->RB_Buffer )->RefConnection.dwRef;
        }
    }
    break;

    case REQTYPE_GETEAPINFO:
    {
        PBYTE   pBuf          = pUserBuffer;
        
        LPDWORD lpdwcb        = pdwSize;
        
        DWORD   *pdwContextId = va_arg(ap, DWORD *);
        
        DWORD   *pdwEapTypeId = va_arg(ap, DWORD *);

        if ((retcode = 
            ((REQTYPECAST *)pbTemp->RB_Buffer)->GetEapInfo.retcode) 
            != SUCCESS)
        {
            break ;
        }

        if ( pdwContextId )
        {
            *pdwContextId = ((REQTYPECAST *)
                             pbTemp->RB_Buffer)->GetEapInfo.dwContextId;
        }
        if ( pdwEapTypeId )
        {
            *pdwEapTypeId = ((REQTYPECAST *)
                             pbTemp->RB_Buffer)->GetEapInfo.dwEapTypeId;
        }
        
        if (lpdwcb != NULL) 
        {
            if (*lpdwcb <
                ((REQTYPECAST *)
                pbTemp->RB_Buffer)->GetEapInfo.dwSizeofEapUIData)
            {
                *lpdwcb = ((REQTYPECAST *)
                          pbTemp->RB_Buffer)->GetEapInfo.dwSizeofEapUIData;
                          
                retcode = ERROR_BUFFER_TOO_SMALL ;
                
                break ;
            }
            
            *lpdwcb = ((REQTYPECAST *)
                      pbTemp->RB_Buffer)->GetEapInfo.dwSizeofEapUIData;
        }
        
        if (pBuf != NULL) 
        {
            memcpy(
              pBuf,
              ((REQTYPECAST *)pbTemp->RB_Buffer)->GetEapInfo.data,
              ((REQTYPECAST *)
              pbTemp->RB_Buffer)->GetEapInfo.dwSizeofEapUIData);
        }
        
        retcode = SUCCESS ;
    }
    break;

    case REQTYPE_SETEAPINFO:
    {
        retcode = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->SetEapInfo.retcode;
    }
    break;

    case REQTYPE_GETDEVICECONFIGINFO:
    {
        DWORD *pcEntries = va_arg(ap, DWORD *);

        if(*pdwSize >= ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->DeviceConfigInfo.cbBuffer)
        {
            retcode = ((REQTYPECAST *)
                      pbTemp->RB_Buffer)->DeviceConfigInfo.retcode;
        }
        else
        {
            retcode = ERROR_BUFFER_TOO_SMALL;
        }

        *pcEntries = ((REQTYPECAST *)
                     pbTemp->RB_Buffer)->DeviceConfigInfo.cEntries;

        *pdwSize = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->DeviceConfigInfo.cbBuffer;

        *pdwVersion = ((REQTYPECAST *)
                      pbTemp->RB_Buffer)->DeviceConfigInfo.dwVersion;
        
        if(SUCCESS == retcode)
        {
            memcpy(pUserBuffer,
                   ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->DeviceConfigInfo.abdata,
                   *pdwSize);
        }
                   
        break;
    }

    case REQTYPE_SETDEVICECONFIGINFO:
    {

        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->DeviceConfigInfo.retcode;
                  
        if(retcode)
        {
            //
            // Copy the buffer to users buffer.
            // the Buffer may have error information
            //
            memcpy(pUserBuffer,
                   ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->DeviceConfigInfo.abdata,
                   ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->DeviceConfigInfo.cbBuffer);
        }

        break;                  
    }

    case REQTYPE_FINDPREREQUISITEENTRY:
    {
        HCONN *phRefConn = va_arg(ap, HCONN *);
        
        retcode = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->FindRefConnection.retcode;

        if(SUCCESS == retcode)
        {
            *phRefConn = 
                ((REQTYPECAST *)
                pbTemp->RB_Buffer)->FindRefConnection.hRefConn;
        }

        break;
    }

    case REQTYPE_GETLINKSTATS:
    case REQTYPE_GETCONNECTIONSTATS:
    {
        PBYTE pStats = va_arg(ap, PBYTE);

        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetStats.retcode;

        if(SUCCESS == retcode)
        {
            //
            // Copy everything except the dwVersion parameter
            // of the RAS_STATS structure. This is what is
            // returned by the rasman server
            //
            memcpy(pStats,
                   ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetStats.abStats,
                   (sizeof(RAS_STATS) - sizeof(DWORD)));
        }

        break;
        
    }

    case REQTYPE_GETHPORTFROMCONNECTION:
    {
        HPORT *phport = va_arg(ap, HPORT *);

        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetHportFromConnection.retcode;

        if(SUCCESS == retcode)
        {
            *phport = ((REQTYPECAST *)
                      pbTemp->RB_Buffer)->GetHportFromConnection.hPort;
        }

        break;
    }

    case REQTYPE_REFERENCECUSTOMCOUNT:
    {
        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->ReferenceCustomCount.retcode;

        if(SUCCESS == retcode)
        {
            BOOL fAddref;
            DWORD *pdwCount;

            fAddref = ((REQTYPECAST *)
                      pbTemp->RB_Buffer)->ReferenceCustomCount.fAddRef;

            if(!fAddref)
            {
                CHAR  *pszPhonebook = va_arg(ap, CHAR *);
                CHAR  *pszEntry     = va_arg(ap, CHAR *);
                DWORD *pdwCount     = va_arg(ap, DWORD *);

                *pdwCount = 
                    ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->ReferenceCustomCount.dwCount;

                if(     NULL == pszPhonebook
                    ||  NULL == pszEntry)
                {
                    
                    break;
                }

                strcpy(
                pszPhonebook,
                ((REQTYPECAST *)
                pbTemp->RB_Buffer)->ReferenceCustomCount.szPhonebookPath);

                strcpy(
                pszEntry,
                ((REQTYPECAST *)
                pbTemp->RB_Buffer)->ReferenceCustomCount.szEntryName);
            }
            else
            {
                DWORD *pdwCount = va_arg(ap, DWORD *);

                if(NULL != pdwCount)
                {
                    *pdwCount = 
                        ((REQTYPECAST *)
                        pbTemp->RB_Buffer)->ReferenceCustomCount.dwCount;
                }
            }
        }

        break;
    }

    case REQTYPE_GETHCONNFROMENTRY:
    {
        HCONN *phConn = va_arg(ap, HCONN *);
        
        retcode = ((REQTYPECAST *)
                  preqbuf->RB_Buffer)->HconnFromEntry.retcode;

        if(ERROR_SUCCESS == retcode)
        {
            *phConn = ((REQTYPECAST *)
                      preqbuf->RB_Buffer)->HconnFromEntry.hConn;
        }

        break;
    }

    case REQTYPE_GETCONNECTINFO:
    {
        DWORD dwRequiredSize;

        dwRequiredSize = ((REQTYPECAST *)
                       pbTemp->RB_Buffer)->GetConnectInfo.dwSize
                       + sizeof(RAS_CONNECT_INFO)
                       - sizeof(RASTAPI_CONNECT_INFO);

        if(*pdwSize < dwRequiredSize)
        {
            retcode = ERROR_BUFFER_TOO_SMALL;
        }
        else
        {
            retcode = ((REQTYPECAST *)
                       pbTemp->RB_Buffer)->GetConnectInfo.retcode;
        }

        *pdwSize = dwRequiredSize;

        if(ERROR_SUCCESS == retcode)
        {
            RAS_CONNECT_INFO     *pConnectInfo;
            RASTAPI_CONNECT_INFO *pRasTapiConnectInfo;

            //
            // Fixup users buffer to change
            // offsets to pointers.
            //
            pConnectInfo = (RAS_CONNECT_INFO *) pUserBuffer;

            pRasTapiConnectInfo = (RASTAPI_CONNECT_INFO *)
                                    &((REQTYPECAST *)
                               pbTemp->RB_Buffer)->GetConnectInfo.rci;

            // DebugBreak();                      
            
            pConnectInfo->dwCallerIdSize =
                        pRasTapiConnectInfo->dwCallerIdSize;

            pConnectInfo->dwCalledIdSize =
                        pRasTapiConnectInfo->dwCalledIdSize;

            pConnectInfo->dwConnectResponseSize = 
                        pRasTapiConnectInfo->dwConnectResponseSize;

            pConnectInfo->dwAltCalledIdSize =
                        pRasTapiConnectInfo->dwAltCalledIdSize;

            if(pConnectInfo->dwCallerIdSize > 0)
            {
                //
                // Note abdata is already aligned at 8-byte boundary
                //
                pConnectInfo->pszCallerId = 
                    (CHAR *) pConnectInfo->abdata;

                memcpy(
                    pConnectInfo->pszCallerId,
                    ((PBYTE) pRasTapiConnectInfo)
                    + pRasTapiConnectInfo->dwCallerIdOffset,
                    pRasTapiConnectInfo->dwCallerIdSize);
                    

            }
            else
            {
                pConnectInfo->pszCallerId = NULL;
            }

            if(pConnectInfo->dwCalledIdSize > 0)
            {
                pConnectInfo->pszCalledId =
                         (CHAR *) pConnectInfo->abdata
                       + RASMAN_ALIGN8(pConnectInfo->dwCallerIdSize);

                memcpy(pConnectInfo->pszCalledId,
                       ((PBYTE) pRasTapiConnectInfo)
                       + pRasTapiConnectInfo->dwCalledIdOffset,
                       pRasTapiConnectInfo->dwCalledIdSize);
                       
            }
            else
            {
                pConnectInfo->pszCalledId = NULL;
            }

            if(pConnectInfo->dwConnectResponseSize > 0)
            {
                pConnectInfo->pszConnectResponse =
                        (CHAR *) pConnectInfo->abdata
                      + RASMAN_ALIGN8(pConnectInfo->dwCallerIdSize)
                      + RASMAN_ALIGN8(pConnectInfo->dwCalledIdSize);

                memcpy(pConnectInfo->pszConnectResponse,
                       ((PBYTE) pRasTapiConnectInfo)
                       + pRasTapiConnectInfo->dwConnectResponseOffset,
                       pRasTapiConnectInfo->dwConnectResponseSize);

                       
            }
            else
            {
                pConnectInfo->pszConnectResponse = NULL;
            }

            if(pConnectInfo->dwAltCalledIdSize > 0)
            {
                pConnectInfo->pszAltCalledId =
                        (CHAR *) pConnectInfo->abdata
                      + RASMAN_ALIGN8(pConnectInfo->dwCallerIdSize)
                      + RASMAN_ALIGN8(pConnectInfo->dwCalledIdSize)
                      + RASMAN_ALIGN8(pConnectInfo->dwConnectResponseSize);

                memcpy(pConnectInfo->pszAltCalledId,
                       ((PBYTE) pRasTapiConnectInfo)
                       + pRasTapiConnectInfo->dwAltCalledIdOffset,
                       pRasTapiConnectInfo->dwAltCalledIdSize);

                       
            }
            else
            {
                pConnectInfo->pszAltCalledId = NULL;
            }


            // DebugBreak();            
        }

        break;
    }

    case REQTYPE_GETDEVICENAME:
    {
        CHAR *pszDeviceName = va_arg(ap, CHAR *);
        
        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->GetDeviceName.retcode;

        if(ERROR_SUCCESS == retcode)
        {
            strcpy(pszDeviceName,
                   ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetDeviceName.szDeviceName);
        
        }

        break;
    }

    case REQTYPE_GETDEVICENAMEW:
    {
        WCHAR *pszDeviceName = va_arg(ap, WCHAR *);

        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->GetDeviceNameW.retcode;

        if(ERROR_SUCCESS == retcode)
        {
            wcscpy(pszDeviceName,
                    //MAX_DEVICE_NAME + 1,
                   ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetDeviceNameW.szDeviceName);

        }

        break;
    }

    case REQTYPE_GETCALLEDID:
    {
        RAS_CALLEDID_INFO *pCalledId = 
                            &((REQTYPECAST *)
                            pbTemp->RB_Buffer)->GetSetCalledId.rciInfo;
                            
        retcode = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->GetSetCalledId.retcode;

        if(     (ERROR_SUCCESS == retcode)
            &&  (*pdwSize < ((REQTYPECAST *)
                        pbTemp->RB_Buffer)->GetSetCalledId.dwSize))
        {
            retcode = ERROR_BUFFER_TOO_SMALL;
        }

        *pdwSize = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->GetSetCalledId.dwSize;
                        
        if(ERROR_SUCCESS == retcode)
        {
            memcpy(((RAS_CALLEDID_INFO *)pUserBuffer)->bCalledId,
                   pCalledId->bCalledId,
                   pCalledId->dwSize);

            ((RAS_CALLEDID_INFO *)pUserBuffer)->dwSize = 
                    pCalledId->dwSize;
        }

        break;
    }

    case REQTYPE_SETCALLEDID:
    {
        retcode = ((REQTYPECAST *)  
                  pbTemp->RB_Buffer)->GetSetCalledId.retcode;

        break;                  
    }
    
    case REQTYPE_ENABLEIPSEC:
    {
        retcode = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->EnableIpSec.retcode;

        break;                    
    }

    case REQTYPE_ISIPSECENABLED:
    {
        BOOL *pfIsIpSecEnabled = va_arg(ap, BOOL *);

        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->IsIpSecEnabled.retcode;

        if(ERROR_SUCCESS == retcode)
        {
            *pfIsIpSecEnabled = 
                ((REQTYPECAST *)
                pbTemp->RB_Buffer)->IsIpSecEnabled.fIsIpSecEnabled;
        }

        break;
    }

    case REQTYPE_SETEAPLOGONINFO:
    {
        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->SetEapLogonInfo.retcode;
        break;                   
    }

    case REQTYPE_SENDNOTIFICATION:
    {
        retcode = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->SendNotification.retcode;

        break;                    
    }

    case REQTYPE_GETNDISWANDRIVERCAPS:
    {
        RAS_NDISWAN_DRIVER_INFO *pInfo =
                        va_arg(ap, RAS_NDISWAN_DRIVER_INFO *);

        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetNdiswanDriverCaps.retcode;

        if(SUCCESS == retcode)
        {
            memcpy(
            (PBYTE) pInfo,
            (PBYTE) &((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetNdiswanDriverCaps.NdiswanDriverInfo,
            sizeof(RAS_NDISWAN_DRIVER_INFO));
        }

        break;
    }

    case REQTYPE_GETBANDWIDTHUTILIZATION:
    {
        RAS_GET_BANDWIDTH_UTILIZATION *pUtilization = 
                va_arg(ap, RAS_GET_BANDWIDTH_UTILIZATION *);


        retcode = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->GetBandwidthUtilization.retcode;

        if(SUCCESS == retcode)
        {
            memcpy(
            (PBYTE) pUtilization,
            (PBYTE) &((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetBandwidthUtilization.BandwidthUtilization,
            sizeof(RAS_GET_BANDWIDTH_UTILIZATION));
        }

        break;
                
    }

    case REQTYPE_REGISTERREDIALCALLBACK:
    {
        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->RegisterRedialCallback.retcode;

        break;                   
    }

    case REQTYPE_GETPROTOCOLINFO:
    {
        RASMAN_GET_PROTOCOL_INFO *pInfo = 
                va_arg(ap, RASMAN_GET_PROTOCOL_INFO *);
                
        retcode = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->GetProtocolInfo.retcode;

        if(SUCCESS != retcode)
        {
            break;
        }

        memcpy(pInfo,
               (PBYTE) &((REQTYPECAST *)
               pbTemp->RB_Buffer)->GetProtocolInfo.Info,
               sizeof(RASMAN_GET_PROTOCOL_INFO));

        break;               
    }

    case REQTYPE_GETCUSTOMSCRIPTDLL:
    {
        CHAR *pszCustomScriptDll = 
                va_arg(ap, CHAR *);

        retcode = ((REQTYPECAST *)
            pbTemp->RB_Buffer)->GetCustomScriptDll.retcode;

        if(ERROR_SUCCESS == retcode)
        {
            strcpy(pszCustomScriptDll,
                  ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetCustomScriptDll.szCustomScript);
        }

        break;
    }

    case REQTYPE_ISTRUSTEDCUSTOMDLL:
    {
        BOOL *pfTrusted = va_arg( ap, BOOL * );
    
        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->IsTrusted.retcode;

        if(SUCCESS == retcode)
        {
            *pfTrusted = ((REQTYPECAST *)
                         pbTemp->RB_Buffer)->IsTrusted.fTrusted;
        }

        break;
    }

    case REQTYPE_DOIKE:
    {
        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->DoIke.retcode;

        break;                   
    }

    case REQTYPE_QUERYIKESTATUS:
    {
        DWORD * pdwStatus = va_arg(ap, DWORD *);
        
        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->QueryIkeStatus.retcode;

        if(SUCCESS == retcode)
        {
            *pdwStatus = ((REQTYPECAST *)
                          pbTemp->RB_Buffer)->QueryIkeStatus.dwStatus;
        }

        break;                   
    }

    case REQTYPE_SETRASCOMMSETTINGS:
    {
        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->SetRasCommSettings.retcode;

        break;                   
    }

    case REQTYPE_ENABLERASAUDIO:
    {
        retcode = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->EnableRasAudio.retcode;

        break;                    
    }

    case REQTYPE_SETKEY:
    {
        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->GetSetKey.retcode;
 
        break;
    }

    case REQTYPE_GETKEY:
    {
        PBYTE pbkey = va_arg(ap, PBYTE);

        retcode = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetSetKey.retcode;

        *pdwSize = ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetSetKey.cbkey;

        if(ERROR_SUCCESS == retcode)
        {
            memcpy(pbkey,
                   ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetSetKey.data,
                   ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetSetKey.cbkey);
        }
        break;
    }

    case REQTYPE_ADDRESSDISABLE:
    {
        retcode = ((REQTYPECAST *)
                    pbTemp->RB_Buffer)->AddressDisable.retcode;
        break;
    }

    case REQTYPE_SENDCREDS:
    {
        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->SendCreds.retcode;

        break;                  
    }

    case REQTYPE_GETUNICODEDEVICENAME:
    {
        WCHAR *pwszDeviceName = va_arg(ap, WCHAR *);
        
        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->GetUDeviceName.retcode;

        if(ERROR_SUCCESS == retcode)
        {
            wcscpy(pwszDeviceName,
                   ((REQTYPECAST *)
                   pbTemp->RB_Buffer)->GetUDeviceName.wszDeviceName);
        
        }

        break;
    }
    
    case REQTYPE_REQUESTNOTIFICATION:
    case REQTYPE_COMPRESSIONSETINFO:
    case REQTYPE_DEALLOCATEROUTE:
    case REQTYPE_PORTCLEARSTATISTICS:
    case REQTYPE_BUNDLECLEARSTATISTICS:
    case REQTYPE_PORTDISCONNECT:
    case REQTYPE_PORTCLOSE:
    case REQTYPE_SERVERPORTCLOSE:
    case REQTYPE_PORTSETINFO:
    case REQTYPE_PORTSEND:
    case REQTYPE_PORTRECEIVE:
    case REQTYPE_PORTCONNECTCOMPLETE:
    case REQTYPE_DEVICESETINFO:
    case REQTYPE_DEVICECONNECT:
    case REQTYPE_PORTLISTEN:
    case REQTYPE_CANCELRECEIVE:
    case REQTYPE_STOREUSERDATA:
    case REQTYPE_REGISTERSLIP:
    case REQTYPE_SETFRAMING:
    case REQTYPE_SETFRAMINGEX:
    case REQTYPE_SETPROTOCOLCOMPRESSION:
    case REQTYPE_PORTBUNDLE:
    case REQTYPE_SETATTACHCOUNT:
    case REQTYPE_PPPCHANGEPWD:
    case REQTYPE_PPPSTOP:
    case REQTYPE_PPPSTART:
    case REQTYPE_PPPRETRY:
    case REQTYPE_PPPCALLBACK:
    case REQTYPE_SETDEVCONFIG:
    case REQTYPE_CLOSEPROCESSPORTS:
    case REQTYPE_PNPCONTROL:
    case REQTYPE_SETIOCOMPLETIONPORT:
    case REQTYPE_SETROUTERUSAGE:
    case REQTYPE_SENDPPPMESSAGETORASMAN:
    case REQTYPE_SETRASDIALINFO:
    case REQTYPE_REGISTERPNPNOTIF:
    case REQTYPE_SETBAPPOLICY:
    case REQTYPE_PPPSTARTED:
    default:
    {
        retcode = ((REQTYPECAST *)
                  pbTemp->RB_Buffer)->Generic.retcode ;
    }
    break ;
    }

done:
    if ( pBuffer ) 
    {
        LocalFree ( pBuffer );
    }
        
    va_end (ap) ;
    
    FreeRequestBuffer(preqbuf) ;
    
    return retcode ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\mxs32\mxspriv.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: mxspriv.h
//
//  Revision History
//
//  Jun  5, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains structure and constant definitions
//               and API prototypes for RASMXS.DLL.  This file is used
//               used only by RASMXS.DLL source files, and is not public
//               in any way.
//
//****************************************************************************


#ifndef _MXSPRIV_
#define _MXSPRIV_




//*  Defines  ****************************************************************
//

#define  INITIAL_PARAMS             13           //Inital buffer size in params
#define  MAX_LEN_STR_FROM_NUMBER    10
#define  MIN_LINK_SPEED             2400

#define  LOOP_TXT                   "LOOP"
#define  SERIAL_DLL_FILENAME        "RASSER.DLL"
#define  RAS_PATH                   "\\RAS\\"

#define  PAD_INF_FILENAME           "PAD.INF"
#define  MODEM_INF_FILENAME         "MODEM.INF"
#define  SWITCH_INF_FILENAME        "SWITCH.INF"

#define  LOG_FILENAME               "DEVICE.LOG"

#define  ALL_MACROS                 0               //Used by MacroCount()
#define  BINARY_MACROS              1               //Used by MacroCount()

#define  ON_SUFFIX                  1
#define  OFF_SUFFIX                 2
#define  NOT_BINARY_MACRO           FALSE

#define  WAITFORCOMPLETION          TRUE
#define  INVALID_INDEX              0xffffffff
#define  MODEM_RETRIES              3


#define  NO_RESPONSE_DELAY        2000      //Time to wait in mS

                                            //ReadFile time outs in mS

#define  TO_WRITE                 2000      //Write timeout
#define  TO_ECHO                  2000      //WaitForEcho

#define  TO_FIRSTCHARAFTERECHO  120000      //WaitForFirstChar following echo
#define  TO_FIRSTCHARNOECHO      10000      //WaitForFirstChar when no echo
#define  TO_PARTIALRESPONSE      25000      //WaitForFirstChar of 2nd part

#define  TO_RCV_INTERVAL           500      //ReceiveString
#define  TO_RCV_CONSTANT          3000      //ReceiveString


#define  MXS_COMPRESSION_OFF_KEY    MXS_COMPRESSION_KEY##""##MXS_OFF_SUFX
#define  MXS_COMPRESSION_ON_KEY     MXS_COMPRESSION_KEY##""##MXS_ON_SUFX
#define  MXS_HDWFLOWCONTROL_OFF_KEY MXS_HDWFLOWCONTROL_KEY##""##MXS_OFF_SUFX
#define  MXS_HDWFLOWCONTROL_ON_KEY  MXS_HDWFLOWCONTROL_KEY##""##MXS_ON_SUFX
#define  MXS_PROTOCOL_OFF_KEY       MXS_PROTOCOL_KEY##""##MXS_OFF_SUFX
#define  MXS_PROTOCOL_ON_KEY        MXS_PROTOCOL_KEY##""##MXS_ON_SUFX
#define  MXS_SPEAKER_OFF_KEY        MXS_SPEAKER_KEY##""##MXS_OFF_SUFX
#define  MXS_SPEAKER_ON_KEY         MXS_SPEAKER_KEY##""##MXS_ON_SUFX
#define  MXS_AUTODIAL_OFF_KEY       MXS_AUTODIAL_KEY##""##MXS_OFF_SUFX
#define  MXS_AUTODIAL_ON_KEY        MXS_AUTODIAL_KEY##""##MXS_ON_SUFX


#define RASMAN_REGISTRY_PATH "System\\CurrentControlSet\\Services\\Rasman\\Parameters"
#define RASMAN_LOGGING_VALUE "Logging"





//*  Macros  *****************************************************************
//

#define  ATTRIBCPY(DEST,SRC)  (((ATTRIB_ENABLED)&(SRC))?\
                               ((DEST)|=(ATTRIB_ENABLED)):\
                               ((DEST)&=(~ATTRIB_ENABLED)))


#define  XOR(A,B)  (((A)||(B))&&!((A)&&(B)))


// Note: The following macro assumes that CreateAttributes() has already
//       been called to set attribute bits.

#define  ISUNARYMACRO(P) (!((ATTRIB_VARIABLE|ATTRIB_BINARYMACRO)&(P)))


#define  STRICMP  _stricmp


#ifdef DEBUG

#define DebugPrintf(_args_) DbgPrntf _args_
#define DebugString(_args_) DbgStr _args_

#else

#define DebugPrintf(_args_)
#define DebugString(_args_)

#endif


#ifdef DBGCON

#define ConsolePrintf(_args_) ConPrintf _args_

#else

#define ConsolePrintf(_args_)

#endif





//*  Data Structures  ********************************************************
//

typedef struct DEVICE_CB DEVICE_CB;

struct DEVICE_CB                      // Device Control Block
{
  DEVICE_CB   *pNextDeviceCB;
  HANDLE      hPort;
  TCHAR       szDeviceName[MAX_DEVICE_NAME+1];
  TCHAR       szDeviceType[MAX_DEVICETYPE_NAME];
  DEVICETYPE  eDeviceType;

  RASMAN_DEVICEINFO  *pInfoTable;
  MACROXLATIONTABLE  *pMacros;

  HRASFILE    hInfFile;
  TCHAR       *pszResponseStart;      // Start of response following echo
  DWORD       cbRead;                 // Bytes read per FileRead
  DWORD       cbTotal;                // Cumulative bytes read & kept
  HANDLE      hNotifier;              // Event signaled when async I/O finished
  DWORD       dCmdLen;                // Indicates length of echo string
  BOOL        bResponseExpected;      // Some commands have no responses
  BOOL        fPartialResponse;
  BOOL        bErrorControlOn;

  DWORD       dwRetries;              // Num retries on modem hardware errors
  NEXTACTION  eDevNextAction;         // DeviceStateMachine() State
  CMDTYPE     eCmdType;               // Used by DeviceStateMachine()
  CMDTYPE     eNextCmdType;           // Used by DeviceStateMachine()
  BOOL        fEndOfSection;          // Used by DeviceStateMachine()
  RCVSTATE    eRcvState;              // ReceiveStateMachine() State

  RAS_OVERLAPPED  Overlapped;             // Struct used by Win32 async file I/O
  TCHAR       szPortBps[MAX_LEN_STR_FROM_NUMBER];
  TCHAR       szCommand[MAX_CMD_BUF_LEN];
  TCHAR       szResponse[MAX_RCV_BUF_LEN];
  TCHAR       szPortName[MAX_PORT_NAME + 1];
};


typedef struct ERROR_ELEM ERROR_ELEM;

struct ERROR_ELEM
{
  TCHAR  szKey[MAX_PARAM_KEY_SIZE];
  DWORD  dwErrorCode;
};


typedef struct RESPSECTION RESPSECTION ;

struct RESPSECTION
{
  HRASFILE  Handle ;
  WORD      UseCount ;
  HANDLE    Mutex ;
} ;

struct SavedSections {
	struct	    SavedSections* Next ;
	TCHAR	    FileName[MAX_PATH] ;
	TCHAR	    SectionName[MAX_DEVICE_NAME+1] ;
	HRASFILE    hFile ;
	BOOL	    InUse ;
} ;
typedef struct SavedSections SavedSections ;





//*  Internal Prototypes  ****************************************************
//

//*  From mxsutils.c  --------------------------------------------------------
//

#ifdef DEBUG

void DbgPrntf(const char * format, ...);

void DbgStr(char Str[], DWORD StrLen);

#endif

#ifdef DBGCON

VOID  ConPrintf ( char *Format, ... );

#endif


DWORD AddDeviceToList(DEVICE_CB **ppDeviceList,
                      HANDLE    hIOPort,
                      LPTSTR    lpDeviceType,
                      LPTSTR    lpDeviceName,
                      DEVICE_CB **ppDevice);

DWORD AddInternalMacros(DEVICE_CB *pDev, RASMAN_DEVICEINFO *pDI);

WORD  BinarySuffix(TCHAR *pch);

DWORD BuildOutputTable(DEVICE_CB *pDevice, BYTE *pbInfo, DWORD *pdwSize);

BOOL  DeviceAttachedToPort(RASMAN_PORTINFO *pPortInfo,
                           char            *pszDeviceType,
                           char            *pszDeviceName);

DWORD ReceiveStateMachine(DEVICE_CB *pDevice, HANDLE hIOPort);

BOOL  CheckForOverruns(HANDLE hIOPort);

char* CmdTypeToStr(char *pszStr, CMDTYPE eCmdType);

DWORD ConnectListen(HANDLE  hIOPort,
                    char    *pszDeviceType,
                    char    *pszDeviceName,
                    CMDTYPE eCmd);

BOOL  CoreMacroNameMatch(LPTSTR lpszShortName, LPTSTR lpszFullName);

DWORD CreateAttributes(DEVICE_CB *pDevice);

void  CreateDefaultOffString(DEVICE_CB *pDev, char *pszDefaultOff);

DWORD CreateInfoTable(DEVICE_CB *pDevice);

DEVICETYPE DeviceTypeStrToEnum(LPTSTR lpszDeviceType);

DEVICE_CB* FindDeviceInList(DEVICE_CB *pDev,
                            HANDLE    hIOPort,
                            TCHAR     *pszDeviceType,
                            TCHAR     *pszDeviceName);

DEVICE_CB* FindPortInList(DEVICE_CB *pDeviceList,
                          HANDLE    hIOPort,
                          DEVICE_CB **pPrevDev);

DWORD GetCoreMacroName(LPTSTR lpszFullName, LPTSTR lpszCoreName);

DWORD GetDeviceCB(HANDLE    hIOPort,
                  char      *pszDeviceType,
                  char      *pszDeviceName,
                  DEVICE_CB **ppDev);

void  GetInfFileName(LPTSTR pszDeviceType,
                     LPTSTR pszFileName,
                     DWORD  dwFileNameLen);

void  GetMem(DWORD dSize, BYTE **ppMem);

void  GetNextParameter(TCHAR **ppch, TCHAR *pchEnd);

BOOL  GetPortDefaultOff(RASMAN_PORTINFO *pPortInfo, TCHAR **lpszValue);

void  GetPcbString(RASMAN_PORTINFO *pPortInfo, char *pszPcbKey, char *pszDest);

void  InitLog(void);

void  InitParameterStr(TCHAR *pch, TCHAR **ppchEnd);

BOOL  IsBinaryMacro(TCHAR *pch);

BOOL  IsLoggingOn(void);

BOOL  IsUnaryMacro(RAS_PARAMS Param);

BOOL  IsVariable(RAS_PARAMS Param);

DWORD LoadRasserDll(PortGetInfo_t *pPortGetInfo, PortSetInfo_t *pPortSetInfo);

void  LogString(DEVICE_CB *pDev,
                TCHAR  *pszLabel,
                TCHAR  *psString,
                DWORD  dwStringLen);

WORD  MacroCount(RASMAN_DEVICEINFO *pInfo, WORD wType);

DWORD UpdateInfoTable(DEVICE_CB *pDevice, RASMAN_DEVICEINFO *pNewInfo);

DWORD OpenResponseSection (PCHAR) ;

// VOID  CloseResponseSection () ;

BOOL  FindOpenDevSection (PTCH, PTCH, HRASFILE *) ;

VOID  AddOpenDevSection (PTCH, PTCH, HRASFILE) ;

VOID  CloseOpenDevSection (HRASFILE) ;




//*  From mxsstate.c  --------------------------------------------------------
//

DWORD BuildMacroXlationTable(DEVICE_CB *pDevice);

DWORD CheckBpsMacros(DEVICE_CB *pDev);

DWORD CheckResponse(DEVICE_CB *pDev, LPTSTR szKey);

DWORD CommWait(DEVICE_CB *pDevice, HANDLE hIOPort, DWORD dwPause);

DWORD DeviceStateMachine(DEVICE_CB *pDevice, HANDLE hIOPort);

UINT  FindTableEntry(RASMAN_DEVICEINFO *pTable, TCHAR *pszKey);

DWORD MapKeyToErrorCode(TCHAR *pszKey);

DWORD PortSetStringInfo(HANDLE hIOPort,
                        char   *pszKey,
                        char   *psStr,
                        DWORD  sStrLen);

DWORD PutInMessage(DEVICE_CB *pDevice, LPTSTR lpszStr, DWORD dwStrLen);

BOOL  ReceiveString(DEVICE_CB   *pDevice, HANDLE hIOPort);

DWORD ResetBPS(DEVICE_CB *pDev);

DWORD ModemResponseLen(DEVICE_CB *pDev);

BOOL  WaitForFirstChar(DEVICE_CB *pDevice, HANDLE hIOPort);

BOOL  WaitForEcho(DEVICE_CB *pDevice, HANDLE hIOPort, DWORD cbEcho);



#endif // _MXSPRIV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\mxs32\mxsutils.c ===
//****************************************************************************
//                                                                           *
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: mxsutils.c
//
//  Revision History
//
//  Jun 10, 1992   J. Perry Hannah      Created
//
//
//  Description: This file contains utility functions used by RASMXS.DLL.
//
//****************************************************************************

#include <nt.h>             //These first five headers are used by media.h
#include <ntrtl.h>          //The first three(?) are used by DbgUserBreakPoint
#include <nturtl.h>
#include <windows.h>
#include <wanpub.h>
#include <asyncpub.h>

#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>


#include <rasman.h>
#include <raserror.h>
#include <rasfile.h>
#include <media.h>
#include <serial.h>
#include <mprlog.h>
#include <rtutils.h>

#include <rasmxs.h>
#include <mxsint.h>
#include <mxspriv.h>
#include "mxswrap.h"       // inf file wrapper



//*  Global Variables  *******************************************************
//
extern RESPSECTION    ResponseSection ;    //Shared response section
extern DEVICE_CB      *pDeviceList;        //Points to DCB linked list
extern HANDLE         *pDeviceListMutex ;  //Mutex for above list

extern PortGetInfo_t  PortGetInfo;         //API typedef defined in media.h
extern PortSetInfo_t  PortSetInfo;         //API typedef defined in media.h

extern BOOL           gbLogDeviceDialog;   //Indicates logging is on if TRUE
extern HANDLE         ghLogFile;           //Handle of device log file
extern SavedSections  *gpSavedSections ;   // Pointer to cached sections

#define NUM_INTERNAL_MACROS	21

TCHAR  *gszInternalMacroNames[] =
         {
           MXS_CARRIERBPS_KEY,
           MXS_CONNECTBPS_KEY,
           MXS_MESSAGE_KEY,
           MXS_PHONENUMBER_KEY,

           MXS_DIAGNOSTICS_KEY,
           MXS_FACILITIES_KEY,
           MXS_USERDATA_KEY,
           MXS_X25PAD_KEY,
           MXS_X25ADDRESS_KEY,

           MXS_COMPRESSION_OFF_KEY,
           MXS_COMPRESSION_ON_KEY,
           MXS_HDWFLOWCONTROL_OFF_KEY,
           MXS_HDWFLOWCONTROL_ON_KEY,
           MXS_PROTOCOL_OFF_KEY,
           MXS_PROTOCOL_ON_KEY,
           MXS_SPEAKER_OFF_KEY,
           MXS_SPEAKER_ON_KEY,
           MXS_AUTODIAL_OFF_KEY,
	   MXS_AUTODIAL_ON_KEY,
	   MXS_USERNAME_KEY,
	   MXS_PASSWORD_KEY,
         };




//*  Utility Functions  ******************************************************
//


//*  GetDeviceCB  ------------------------------------------------------------
//
// Function: Looks for a Device Control Block in the global Device linked
//           list.  If no DCB is found that contains an hIOPort matching
//           the input parameter, one is created, initalized, and added
//           to the list.
//
// Returns: Pointer to the DEVICE_CB which contains an hIOPort matching the
//          the second input parameter.
//*

DWORD
GetDeviceCB(HANDLE    hIOPort,
            char      *pszDeviceType,
            char      *pszDeviceName,
            DEVICE_CB **ppDev)
{
  DWORD  dRC = SUCCESS ;

  *ppDev = FindDeviceInList(pDeviceList, hIOPort, pszDeviceType, pszDeviceName);


  if (*ppDev == NULL)
  {
    dRC = AddDeviceToList(&pDeviceList,
                          hIOPort,
                          pszDeviceType,
                          pszDeviceName,
                          ppDev);

    if (dRC != SUCCESS)
      goto getdcbend ;

    dRC = CreateInfoTable(*ppDev);
    if (dRC != SUCCESS)
      goto getdcbend ;


    dRC = CreateAttributes(*ppDev) ;

  }

getdcbend:

  return (dRC);
}





//*  FindDeviceInList  -------------------------------------------------------
//
// Function: Finds the Device Control Block in the global Device linked
//           list which contains the hIOPort handle, device type, and
//           device name.
//
// Returns: Pointer to the DEVICE_CB which contains matches for the second,
//          third, and fourth parameters, or NULL if no such DEVICE_CB
//          is found.
//*

DEVICE_CB*
FindDeviceInList(DEVICE_CB *pDev,
                 HANDLE    hIOPort,
                 TCHAR     *pszDeviceType,
                 TCHAR     *pszDeviceName)
{
  while (pDev != NULL)
  {
    pDev = FindPortInList(pDev, hIOPort, NULL);
    if (pDev == NULL)
      break;

    if (_stricmp(pDev->szDeviceType, pszDeviceType) == 0 &&
        _stricmp(pDev->szDeviceName, pszDeviceName) == 0)
      break;

    pDev = pDev->pNextDeviceCB;
  }

  return(pDev);
}




//*  FindPortInList  ---------------------------------------------------------
//
// Function: Finds the first Device Control Block in the global Device linked
//           list which contains the hIOPort handle.
//
//           If pPrevDev is not NULL on input, then on output it *pPrevDev
//           points to the DCB just prior to the "found" DCB pointed to by
//           the returned pointer.  If the function return value is not NULL
//           *pPrevDev will be valid.
//
//           NOTE: If the found DCB is at the head of the list, pPrevDev
//           will be the same as the return value.
//
// Returns: Pointer to the DEVICE_CB which contains an hIOPort matching the
//          the second input parameter, or NULL if no such DEVICE_CB is found.
//*

DEVICE_CB*
FindPortInList(DEVICE_CB *pDeviceList, HANDLE hIOPort, DEVICE_CB **pPrevDev)
{
  DEVICE_CB  *pDev;


  pDev = pDeviceList;             //Allow for case of only one DCB on list

  while(pDeviceList != NULL && pDeviceList->hPort != hIOPort)
  {
    pDev = pDeviceList;
    pDeviceList = pDeviceList->pNextDeviceCB;
  }

  if (pPrevDev != NULL)
    *pPrevDev = pDev;

  return(pDeviceList);
}





//*  AddDeviceToList  --------------------------------------------------------
//
// Function: Creates a Device Control Block and adds it to the head of the
//           global Device linked list.
//
// Returns: SUCCESS
//          ERROR_UNKNOWN_DEVICE_TYPE
//          ERROR_ALLOCATING_MEMORY
//*

DWORD
AddDeviceToList(DEVICE_CB **ppDeviceList,
                HANDLE    hIOPort,
                LPTSTR    lpszDeviceType,
                LPTSTR    lpszDeviceName,
                DEVICE_CB **ppDevice)
{
  DEVICE_CB  *pDev;
  DEVICETYPE eDeviceType;
  DWORD      dRC;
  TCHAR      szFileName[MAX_PATH];
  DEVICE_CB  *origpDeviceList ;

  origpDeviceList = *ppDeviceList ; // save this pointer since it may be restored later

  // Check input

  eDeviceType = DeviceTypeStrToEnum(lpszDeviceType);
  if (eDeviceType == DT_UNKNOWN)
    return(ERROR_UNKNOWN_DEVICE_TYPE);


  // INF file sections are opened before the DCB is created because the
  // open/close count must be kept balanced even when errors occur.  (If
  // OpenResponseSection fails it does not increment the count, and because
  // the DCB does not exist DeviceWork does not decrement the count.)


  // Open global response section for modems
  *szFileName = TEXT('\0');
  GetInfFileName(lpszDeviceType, szFileName, sizeof(szFileName));
  if (eDeviceType == DT_MODEM) {
    dRC = OpenResponseSection (szFileName) ;
    if (dRC != SUCCESS)
      return dRC ;
  }


  // Put new DCB at head of list

  pDev = *ppDeviceList;

  GetMem(sizeof(DEVICE_CB), (BYTE **)ppDeviceList);
  if (*ppDeviceList == NULL)
    return(ERROR_ALLOCATING_MEMORY);

  *ppDevice = *ppDeviceList;
  (*ppDevice)->pNextDeviceCB = pDev;


  // Initialize New Device Control Block

  pDev = *ppDevice;
  pDev->hPort = hIOPort;
  strcpy(pDev->szDeviceName, lpszDeviceName);
  strcpy(pDev->szDeviceType, lpszDeviceType);
  pDev->eDeviceType = eDeviceType;
  pDev->pInfoTable = NULL;
  pDev->pMacros = NULL;
  pDev->hInfFile = INVALID_HRASFILE;
  pDev->fPartialResponse = FALSE;
  pDev->bErrorControlOn = FALSE;

  pDev->Overlapped.RO_Overlapped.Internal = 0;
  pDev->Overlapped.RO_Overlapped.InternalHigh = 0;
  pDev->Overlapped.RO_Overlapped.Offset = 0;
  pDev->Overlapped.RO_Overlapped.OffsetHigh = 0;
  pDev->Overlapped.RO_Overlapped.hEvent = NULL;
  pDev->Overlapped.RO_EventType = OVEVT_DEV_ASYNCOP;

  pDev->dwRetries = 1;


  // Initialize State variables

  pDev->eDevNextAction = SEND;          // DeviceStateMachine() State
  pDev->eCmdType = CT_GENERIC;          // Used by DeviceStateMachine()
  pDev->eNextCmdType = CT_GENERIC;      // Used by DeviceStateMachine()
  pDev->fEndOfSection = FALSE;          // Used by DeviceStateMachine()

  pDev->eRcvState = GETECHO;            // ReceiveStateMachine() State


  // Open device section of INF file
  if (FindOpenDevSection (szFileName, lpszDeviceName, &(pDev->hInfFile)) == TRUE)
    return SUCCESS ;

  dRC = RasDevOpen(szFileName, lpszDeviceName, &(pDev->hInfFile));
  if (dRC != SUCCESS) {

    // restore the pointers
    //
    *ppDeviceList = origpDeviceList ;
    *ppDevice = NULL ;
    free (pDev) ;
    return(dRC);

  } else
    AddOpenDevSection (szFileName, lpszDeviceName, pDev->hInfFile) ; // Add to the opened list

  return(SUCCESS);
}





//*  CreateInfoTable  --------------------------------------------------------
//
// Function: Creates an InfoTable and initalizes it by reading the variables
//           and macros found in the INF file into it.  The InfoTable is
//           attached to the Device Control Block pointed to by the input
//           parameter.
//
//           This function allocates memory.
//
// Returns: SUCCESS
//          ERROR_ALLOCATING_MEMORY
//          Return value from RasDevOpen() or RasDevGetParams().
//*

DWORD
CreateInfoTable(DEVICE_CB *pDevice)
{
  DWORD               dRC, dSize = 0;
  RASMAN_DEVICEINFO   *pInfoTable = NULL ;


  // Read variables and macros into InfoTable from INF file

  dRC = RasDevGetParams(pDevice->hInfFile, (BYTE *)(pInfoTable), &dSize);
  if (dRC == ERROR_BUFFER_TOO_SMALL)
  {
    dSize += sizeof(RAS_PARAMS) * NUM_INTERNAL_MACROS;

    GetMem(dSize, (BYTE **)&pInfoTable);
    if (pInfoTable == NULL)
      return(ERROR_ALLOCATING_MEMORY);

    dRC = RasDevGetParams(pDevice->hInfFile, (BYTE *)(pInfoTable), &dSize);
  }
  if (dRC != SUCCESS)
  {
    free(pInfoTable);
    return(dRC);
  }


  if ((dRC = AddInternalMacros(pDevice, pInfoTable)) != SUCCESS)
  {
    free(pInfoTable);
    return(dRC);
  }


  // Attach InfoTable to Device Control Block

  pDevice->pInfoTable = pInfoTable;

  return(SUCCESS);
}





//*  AddInternalMacros  ------------------------------------------------------
//
// Function: Adds internal macros to existing InfoTable.
//
// Asumptions: The InfoTable buffer was created with room enough for
//             the internal macros.
//
// Returns: SUCCESS
//          ERROR_ALLOCATING_MEMORY
//*

DWORD
AddInternalMacros(DEVICE_CB *pDev, RASMAN_DEVICEINFO *pDI)
{
  WORD        i;
  RAS_PARAMS  *pParam;


  // Get pointer to next unused param

  pParam = &(pDI->DI_Params[pDI->DI_NumOfParams]);


  // Fill in params for internal macros

  for (i=0; i<NUM_INTERNAL_MACROS; i++)
  {
    strcpy(pParam->P_Key, gszInternalMacroNames[i]);

    pParam->P_Type = String;
    pParam->P_Attributes = 0;
    pParam->P_Value.String.Length = 0;

    GetMem(1, &(pParam->P_Value.String.Data));
    if (pParam->P_Value.String.Data == NULL)
      return(ERROR_ALLOCATING_MEMORY);

    *(pParam->P_Value.String.Data) = '\0';

    pParam++;
  }

  pDI->DI_NumOfParams += NUM_INTERNAL_MACROS;

  return(SUCCESS);
}





//*  CreateAttributes  -------------------------------------------------------
//
// Function: This function is used to set attributes for the first time
//           when the InfoTable is created.  UpdateInfoTable() is used
//           to later change attributes.
//
//           First, all attributes are set according to the parameter
//           key with all binary macros being enabled.  Then the
//           DEFAULTOFF variable is parsed, and macros listed there are
//           disabled.
//
// Assumptions: - The ATTRIB_VARIABLE attribute bit has already been set
//                by RasDevGetParams().
//              - Parameters in InfoTable are sorted by P_Key.
//              - Both parts of binary macros are present.
//              These assumptions imply that if somename_off is in InfoTable
//              somename_on is also present and is adjacent to somename_off.
//
// Returns: SUCCESS
//          ERROR_DEFAULTOFF_MACRO_NOT_FOUND
//          ERROR_ALLOCATING_MEMORY
//          Return codes from PortGetInfo
//*

DWORD
CreateAttributes(DEVICE_CB *pDevice)
{
  int         iDefaultOff = -1;
  DWORD       i, dwMemSize;
  DWORD       dwRC;
  BOOL        fFound;
  TCHAR       *lpszDefaultOff, *lpszEOS, szCoreName[MAX_PARAM_KEY_SIZE];
  RAS_PARAMS  *pParam;

  RASMAN_DEVICEINFO  *pInfo = pDevice->pInfoTable;
  RASMAN_PORTINFO    *pPortInfo;



    //DebugPrintf(("mxsutils CreateAttributes\n"));

  // Set attributes according to Keyword type,
  //  defaulting user settable parameters to enabled.

  for (i=0; i < pInfo->DI_NumOfParams; i++)
  {
    pParam = &(pInfo->DI_Params[i]);
    //DebugPrintf(("%32s  %s\n", pParam, pParam->P_Value.String.Data));

    if (IsVariable(*pParam))
      pParam->P_Attributes = ATTRIB_VARIABLE;

    else if (IsBinaryMacro(pParam->P_Key))
      pParam->P_Attributes = ATTRIB_BINARYMACRO |
                             ATTRIB_USERSETTABLE |
                             ATTRIB_ENABLED;
    else
      pParam->P_Attributes = ATTRIB_ENABLED;


    // Remember location of DEFAULTOFF variable

    if (_stricmp(pInfo->DI_Params[i].P_Key, MXS_DEFAULTOFF_KEY) == 0)
      iDefaultOff = i;
  }


  // Call PortGetInfo (first loading the rasser.dll if necessary)

  if (PortGetInfo == NULL)
  {
    if ((dwRC = LoadRasserDll(&PortGetInfo, &PortSetInfo)) != SUCCESS)
      return(dwRC);
  }

  dwMemSize = 256;

  GetMem(dwMemSize, (BYTE **)&pPortInfo);
  if (pPortInfo == NULL)
    return(ERROR_ALLOCATING_MEMORY);


  dwRC = PortGetInfo(pDevice->hPort, NULL, (BYTE *)pPortInfo, &dwMemSize);
  if (dwRC == ERROR_BUFFER_TOO_SMALL)
  {
    free(pPortInfo);

    GetMem(dwMemSize, (BYTE **)&pPortInfo);
    if (pPortInfo == NULL)
      return(ERROR_ALLOCATING_MEMORY);

    PortGetInfo(pDevice->hPort, NULL, (BYTE *)pPortInfo, &dwMemSize);
  }
  else if ( dwRC )
  {
    dwRC = SUCCESS;
    return dwRC;
  }

  dwRC = SUCCESS ;


  // Save the Port name in the DCB

  GetPcbString(pPortInfo, SER_PORTNAME_KEY, pDevice->szPortName);


  // Get the current Bps of the port.
  // If the modem does not report the connect bps we will use this one.

  GetPcbString(pPortInfo, SER_CONNECTBPS_KEY, pDevice->szPortBps);


  // Does serial.ini file contain a DEFAULTOFF variable?

  if (!GetPortDefaultOff(pPortInfo, &lpszDefaultOff))
  {
    // No DEFAULTOFF in port INI file
    // Check that DEFAULTOFF variable was found in device Info table

    if (iDefaultOff == -1)                //DEFAULTOFF not found
    {                                     //Assume none are to be disabled
      free(pPortInfo);
      return(SUCCESS);
    }

    lpszDefaultOff = pInfo->DI_Params[iDefaultOff].P_Value.String.Data;
  }


  // Prepare DEFALULTOFF string

  InitParameterStr(lpszDefaultOff, &lpszEOS);



  // Disable parameters listed in DEFAULTOFF variable.

  while (lpszDefaultOff < lpszEOS)
  {
    fFound = FALSE;

    for (i=0; i < pInfo->DI_NumOfParams; i++)
    {
      if (IsBinaryMacro(pInfo->DI_Params[i].P_Key))
      {
        GetCoreMacroName(pInfo->DI_Params[i].P_Key, szCoreName);
        if (_stricmp(lpszDefaultOff, szCoreName) == 0)
        {
          pInfo->DI_Params[i].P_Attributes &= ~ATTRIB_ENABLED;   //One suffix
          pInfo->DI_Params[i+1].P_Attributes &= ~ATTRIB_ENABLED; //Other suffix
          fFound = TRUE;
          break;
        }
      }
    }

    if (!fFound)
    {
      free(pPortInfo);
      return(ERROR_DEFAULTOFF_MACRO_NOT_FOUND);
    }

    GetNextParameter(&lpszDefaultOff, lpszEOS);
  }

  free(pPortInfo);
  return(SUCCESS);
}





//*  GetPortDefaultOff  ------------------------------------------------------
//
// Function: This function finds the DEFAULTOFF key in the RASMAN_PORTINFO
//           table supplied by the first parameter.  A pointer to the value
//           string is the output in the second parameter.
//
//           If the DEFAULTOFF key is not found, the function returns FALSE,
//           and the second parameter is undefined.
//
// Arguments:
//           pPortInfo  IN   Pointer to Port Info Table from PortGetInfo()
//           lpszValue  OUT  DEFAULTOFF value string
//
// Returns: TRUE if DEFAULTOFF key is found, otherwise FALSE
//
//*

BOOL
GetPortDefaultOff(RASMAN_PORTINFO *pPortInfo, TCHAR **lpszValue)
{
  WORD  i;


  for (i=0; i<pPortInfo->PI_NumOfParams; i++)

    if (_stricmp(SER_DEFAULTOFFSTR_KEY, pPortInfo->PI_Params[i].P_Key) == 0)
      break;

  if (i >= pPortInfo->PI_NumOfParams)
    return(FALSE);

  *lpszValue = pPortInfo->PI_Params[i].P_Value.String.Data;
  return(TRUE);
}





//*  GetPcbString  -----------------------------------------------------------
//
// Funciton: Searches a RASMAN_PORTINFO struct for a P_Key that matches
//           the second parameter, pszPcbKey.  The P_Value.String.Data
//           is copied to the third parameter, pszDest which is the
//           output parameter.
//
//           Note: This function may only be called for keys that have
//           P_Type String values (and never for P_Type Number values).
//
// Assumptions: The first parameter has been initalize by a call to
//              PortGetInfo.
//
// Returns: nothing.
//
//*

void
GetPcbString(RASMAN_PORTINFO *pPortInfo, char *pszPcbKey, char *pszDest)
{
  WORD  i;


  for (i=0; i<pPortInfo->PI_NumOfParams; i++)

    if (_stricmp(pszPcbKey, pPortInfo->PI_Params[i].P_Key) == 0)
      break;

  if (i >= pPortInfo->PI_NumOfParams ||
      pPortInfo->PI_Params[i].P_Type != String)
    return;

  strncpy(pszDest,
          pPortInfo->PI_Params[i].P_Value.String.Data,
          pPortInfo->PI_Params[i].P_Value.String.Length);

  *(pszDest + pPortInfo->PI_Params[i].P_Value.String.Length) = '\0';
}





//*  UpdateInfoTable  --------------------------------------------------------
//
// Function: This function is used to update attributes when DeviceSetInfo()
//           is called.  The nested for loops search the Info Table for each
//           input param to be set.
//
//           If the full macro name (including _off or _on for binary macros)
//           is given in the input P_Key, the P_Value is copied and the
//           Enable bit in P_Attributes is copied.  If the core name
//           is given for binary macros, only the Enable bit is copied.
//
// Assumptions: - Parameters in InfoTable are sorted by P_Key.
//              - Both parts of binary macros are present in the InfoTable.
//              These assumptions imply that if somename_off is in InfoTable
//              somename_on is also present and is adjacent to somename_off.
//
// Pseudo Code: for (each input param to be set)
//                for (each item in InfoTable)
//                  if (P_Keys match && !IsVariable)
//                    copy P_Value
//                    copy Enable Attribute bit
//                  else if (P_Keys binary macro core names match)
//                    copy Enable Attribute bit
//
// Returns: SUCCESS
//          ERROR_WRONG_KEY_SPECIFIED
//
//*

DWORD
UpdateInfoTable(DEVICE_CB *pDevice, RASMAN_DEVICEINFO *pNewInfo)
{
  WORD      i, j;
  BOOL      fFound;
  DWORD     dwRC, dwSrcLen, dwNumber;
  TCHAR     *pszSrc, szNumberStr[MAX_LEN_STR_FROM_NUMBER + 1];

  RASMAN_DEVICEINFO  *pInfoTable = pDevice->pInfoTable;



  for (i=0; i < pNewInfo->DI_NumOfParams; i++)        //For each param to set,
  {
    fFound = FALSE;


    for (j=0; j < pInfoTable->DI_NumOfParams; j++)    //check InfoTable entries
    {
      // Check for unary macro match

      if (IsUnaryMacro(pInfoTable->DI_Params[j]) &&

          _stricmp(pNewInfo->DI_Params[i].P_Key,
                  pInfoTable->DI_Params[j].P_Key) == 0)
      {

          // Check format of P_Value field; convert to string if necessary

          if (pNewInfo->DI_Params[i].P_Type == String)
          {
            pszSrc = pNewInfo->DI_Params[i].P_Value.String.Data;
            dwSrcLen = pNewInfo->DI_Params[i].P_Value.String.Length;
          }
          else
          {                                                  //P_Type == Number
            _itoa(pNewInfo->DI_Params[i].P_Value.Number,
                 szNumberStr,
                 10);
            pszSrc = szNumberStr;
            dwSrcLen = strlen(szNumberStr);
          }


          // Copy P_Value (allocating more memory as necessary)

          dwRC = UpdateParamString(&(pInfoTable->DI_Params[j]),
                                   pszSrc,
                                   dwSrcLen);
          if (dwRC != SUCCESS)
            return(dwRC);


          fFound = TRUE;
          break;
      }


      // Check for Binary Macro match

      else if(CoreMacroNameMatch(pNewInfo->DI_Params[i].P_Key,
                                 pInfoTable->DI_Params[j].P_Key))
      {

        // Convert string to number, if necessary

        if (pNewInfo->DI_Params[i].P_Type == String)
        {
          strncpy(szNumberStr,
                  pNewInfo->DI_Params[i].P_Value.String.Data,
                  pNewInfo->DI_Params[i].P_Value.String.Length);

          szNumberStr[pNewInfo->DI_Params[i].P_Value.String.Length] = '\0';

          dwNumber = atoi(szNumberStr);
        }
        else
          dwNumber = pNewInfo->DI_Params[i].P_Value.Number;


        // Set macro enabled bit in Attributes field

        if (dwNumber == 0)
        {
          pInfoTable->DI_Params[j].P_Attributes &= ~ATTRIB_ENABLED; //Clear bit
          pInfoTable->DI_Params[j+1].P_Attributes &= ~ATTRIB_ENABLED;
        }
        else
        {
          pInfoTable->DI_Params[j].P_Attributes |= ATTRIB_ENABLED;  //Set bit
          pInfoTable->DI_Params[j+1].P_Attributes |= ATTRIB_ENABLED;
        }

        fFound = TRUE;
        break;
      }
    }

    if (!fFound)
      return(ERROR_WRONG_KEY_SPECIFIED);
  }

  return(SUCCESS);
}





//*  DeviceAttachedToPort  ---------------------------------------------------
//
// Funciton: Searched through a port info block for DeviceType and
//           DeviceName and compares the found strings to the second
//           and third input parameters.
//
// Assumptions: The first parameter has been initalize by a call to
//              PortGetInfo.
//              SER_DEVCIETYPE_KEY and SER_DEVICENAME_KEY each appear
//              only once in the RASMAN_PORTINFO block.
//
// Returns: TRUE if pszDeviceType and pszDeviceName are found in
//          pPortInfo, else FALSE.
//*

BOOL
DeviceAttachedToPort(RASMAN_PORTINFO *pPortInfo,
                     char            *pszDeviceType,
                     char            *pszDeviceName)
{
  WORD   i;
  BOOL   bTypeMatch = FALSE, bNameMatch = FALSE;


  for (i=0; i<pPortInfo->PI_NumOfParams; i++)
  {
    if (_stricmp(SER_DEVICETYPE_KEY, pPortInfo->PI_Params[i].P_Key) == 0)
    {
      if ( strlen(pszDeviceType) ==
           pPortInfo->PI_Params[i].P_Value.String.Length
         &&
           _strnicmp(pszDeviceType,
                    pPortInfo->PI_Params[i].P_Value.String.Data,
                    pPortInfo->PI_Params[i].P_Value.String.Length) == 0)

        bTypeMatch = TRUE;
      else
        break;
    }

    if (_stricmp(SER_DEVICENAME_KEY, pPortInfo->PI_Params[i].P_Key) == 0)
    {
      if ( strlen(pszDeviceName) ==
           pPortInfo->PI_Params[i].P_Value.String.Length
         &&
           _strnicmp(pszDeviceName,
                    pPortInfo->PI_Params[i].P_Value.String.Data,
                    pPortInfo->PI_Params[i].P_Value.String.Length) == 0)

        bNameMatch = TRUE;
      else
        break;
    }

    if (bTypeMatch && bNameMatch)
      break;
  }


  return(bTypeMatch && bNameMatch);
}





//*  CreateDefaultOffString  -------------------------------------------------
//
// Funciton:
//           DeviceName and compares the found strings to the second
//           and third input parameters.
//
// Assumptions: Buffer pointed to by pszDefaultOff is large enough for
//              all DefaultOff macros.
//
// Returns: Nothing
//*

void
CreateDefaultOffString(DEVICE_CB *pDev, char *pszDefaultOff)
{
  WORD    i, k, wLen;

  char    *szDefaultOffMacros[] = { MXS_SPEAKER_KEY ,
                                    MXS_HDWFLOWCONTROL_KEY ,
                                    MXS_PROTOCOL_KEY ,
                                    MXS_COMPRESSION_KEY };


  *pszDefaultOff = '\0';


  // Find each macro and if it is off then add its name to DefaultOff string

  for (i=0; i < sizeof(szDefaultOffMacros)/sizeof(char *); i++)
  {
    k = (WORD) FindTableEntry(pDev->pInfoTable, szDefaultOffMacros[i]);

    if (k == INVALID_INDEX)
      continue;


    // If macro is turned off then copy its key to the DefaultOff string

    if ( ! (pDev->pInfoTable->DI_Params[k].P_Attributes & ATTRIB_ENABLED))
    {
      strcat(pszDefaultOff, szDefaultOffMacros[i]);
      strcat(pszDefaultOff, " ");                       //Add deliminting space
    }
  }


  // Remove last delimiting space

  wLen = (WORD)strlen(pszDefaultOff);
  if (wLen > 0)
    pszDefaultOff[wLen - 1] = '\0';
}





//*  BuildOutputTable  -------------------------------------------------------
//
// Function: Copies macros from internal InfoTable to the caller's buffer.
//            For Parameter:    Function copies:
//             Variable          Entire RASMAN_DEVICEINFO struct
//             Unary Macro       Entire RASMAN_DEVICEINFO struct
//             Binary Macro      Everything except P_Value field
//
// Assumptions: - Output buffer will ALWAYS be large enough.
//              - Parameters in InfoTable are sorted by P_Key (except
//                  internal macros).
//              - Both parts of binary macros are present.
//              These assumptions imply that if somename_off is in InfoTable
//              somename_on is also present and is adjacent to somename_off.
//
// Returns: SUCCESS
//          ERROR_BUFFER_TOO_SMALL
//
//*

DWORD
BuildOutputTable(DEVICE_CB *pDevice, BYTE *pInfo, DWORD *pdwSize)
{
  WORD        i, j;
  DWORD     cOutputParams = 0;
  LPTCH       pValue;
  TCHAR       szCoreName[MAX_PARAM_KEY_SIZE];

  RASMAN_DEVICEINFO  *pInfoTable = pDevice->pInfoTable,
                     *pOutputTable = (RASMAN_DEVICEINFO *)pInfo;


  // Compute location of first value string (follows RAS_PARAMS)

  cOutputParams =
         pInfoTable->DI_NumOfParams - MacroCount(pInfoTable, BINARY_MACROS);
  *pdwSize =
         sizeof(RASMAN_DEVICEINFO) + sizeof(RAS_PARAMS) * (cOutputParams - 1);
  pValue = pInfo + *pdwSize;


  // Set NumOfParams

  pOutputTable->DI_NumOfParams = cOutputParams;


  // Copy macros

  for (i=0, j=0; i < pInfoTable->DI_NumOfParams; i++)
  {
    if (IsBinaryMacro(pInfoTable->DI_Params[i].P_Key))
    {
      // copy core macro name, Type, and Attributes, but not Value

      GetCoreMacroName(pInfoTable->DI_Params[i].P_Key, szCoreName);
      strcpy(pOutputTable->DI_Params[j].P_Key, szCoreName);

      pOutputTable->DI_Params[j].P_Type = pInfoTable->DI_Params[i].P_Type;
      pOutputTable->DI_Params[j].P_Attributes =
                                        pInfoTable->DI_Params[i].P_Attributes;

      pOutputTable->DI_Params[j].P_Value.String.Data = pValue;
      *pValue++ = '\0';

      pOutputTable->DI_Params[j].P_Value.String.Length = 0;

      i++;
      j++;
    }
    else  // Is Unary Macro or Variable
    {
      // copy everything including Value

      pOutputTable->DI_Params[j] = pInfoTable->DI_Params[i];

      pOutputTable->DI_Params[j].P_Value.String.Data = pValue;
      strncpy(pValue, pInfoTable->DI_Params[i].P_Value.String.Data,
                      pInfoTable->DI_Params[i].P_Value.String.Length);

      pOutputTable->DI_Params[j].P_Value.String.Length
        = pInfoTable->DI_Params[i].P_Value.String.Length;

      pValue += pInfoTable->DI_Params[i].P_Value.String.Length;
      *pValue++ = '\0';
      j++;
    }
  }

  *pdwSize = (DWORD) (pValue - pInfo);
  return(SUCCESS);
}







//*  ConnectListen()  --------------------------------------------------------
//
// Function: Worker routine for DeviceConnect and DeviceListen.
//
// Returns: ERROR_NO_COMMAND_FOUND
//          ERROR_STATE_MACHINES_ALREADY_STARTED
//          and codes returned by DeviceStateMachine()
//*

DWORD
ConnectListen(HANDLE  hIOPort,
              char    *pszDeviceType,
              char    *pszDeviceName,
              CMDTYPE eCmd)
{
  DWORD      dRC;
  DEVICE_CB  *pDevice;


  // Get Device Control Block for this hIOPort

  dRC = GetDeviceCB(hIOPort, pszDeviceType, pszDeviceName, &pDevice);
  if (dRC != SUCCESS)
    return(dRC);


  // Check that DeviceStateMachine is not started (but is reset)

  if (pDevice->eDevNextAction != SEND)
    return(ERROR_STATE_MACHINES_ALREADY_STARTED);


  // Create Macro Translation Table for use by RasDevAPIs

  if ((dRC = BuildMacroXlationTable(pDevice)) != SUCCESS)
    return(dRC);


  // Do the next block only once for most devices,
  // but retry a few times when getting modem hardware errors

  do
  {
    // Initialize command types

    switch(RasDevIdFirstCommand(pDevice->hInfFile))
    {
      case CT_INIT:
        pDevice->eCmdType = CT_INIT;
        pDevice->eNextCmdType = eCmd;
        break;

      case CT_DIAL:                      //If 1st cmd is DIAL or LISTEN assume
      case CT_LISTEN:                    //the other is also present
        pDevice->eCmdType = eCmd;
        break;

      case CT_GENERIC:
        pDevice->eCmdType = CT_GENERIC;
        break;

      default:
        return(ERROR_NO_COMMAND_FOUND);
    }


    // Reseting state variables and purging com ports are not needed on
    // first time through loop, but are need on subsequent loops.

    // Reset state variables to initial values

    pDevice->eDevNextAction = SEND;
    pDevice->eRcvState = GETECHO;


    // Cancel any pending com port action and purge com buffers

    PurgeComm(hIOPort,
              PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR);


    // Start state machine

    dRC = DeviceStateMachine(pDevice, hIOPort);

  } while(dRC == ERROR_PORT_OR_DEVICE &&
          pDevice->eDeviceType == DT_MODEM &&
          pDevice->dwRetries++ < MODEM_RETRIES );


  return(dRC);
}


//*  DeviceTypeStrToEnum  ----------------------------------------------------
//
// Function: Converts a device type string into a device type enum.
//
// Returns: The device type code.
//
//*

DEVICETYPE
DeviceTypeStrToEnum(LPTSTR lpszDeviceType)
{
  if (_strnicmp(lpszDeviceType, MXS_NULL_TXT, MAX_DEVICETYPE_NAME) == 0)
    return(DT_NULL);

  if (_strnicmp(lpszDeviceType, MXS_MODEM_TXT, MAX_DEVICETYPE_NAME) == 0)
    return(DT_MODEM);

  if (_strnicmp(lpszDeviceType, MXS_PAD_TXT, MAX_DEVICETYPE_NAME) == 0)
    return(DT_PAD);

  if (_strnicmp(lpszDeviceType, MXS_SWITCH_TXT, MAX_DEVICETYPE_NAME) == 0)
    return(DT_SWITCH);

  return(DT_UNKNOWN);
}




//*  GetInfFileName  ---------------------------------------------------------
//
// Function: Converts a device type string into the full path name for the
//           appropriate INF file.
//
//           The RAS_PATH define contains leading and trailin backslashes.
//           It looks like "\\RAS\\".
//
// Returns: Nothing.
//
//*

void
GetInfFileName(LPTSTR pszDeviceType, LPTSTR pszFileName, DWORD dwFileNameLen)
{
  UINT  uLen;


  uLen = GetSystemDirectory(pszFileName, dwFileNameLen);

  strcat(pszFileName, RAS_PATH);

  switch(DeviceTypeStrToEnum(pszDeviceType))
  {
    case DT_NULL:
    case DT_MODEM:
      strcat(pszFileName, MODEM_INF_FILENAME);
      break;

    case DT_PAD:
      strcat(pszFileName, PAD_INF_FILENAME);
      break;

    case DT_SWITCH:
      strcat(pszFileName, SWITCH_INF_FILENAME);
      break;

    default:
      strcat(pszFileName, "");
   }
}





//*  IsVariable  -------------------------------------------------------------
//
// Function: Returns TRUE if parameter's "Variable" attribute bit is set.
//           Note that FALSE implies that the paramater is a macro.
//
//*

BOOL
IsVariable(RAS_PARAMS Param)
{
    return(ATTRIB_VARIABLE & Param.P_Attributes);
}





//*  IsUnaryMacro  -----------------------------------------------------------
//
// Function: Returns TRUE if param is a unary macro, otherwise FALSE.
//
//*

BOOL
IsUnaryMacro(RAS_PARAMS Param)
{
    return(!IsVariable(Param) && !IsBinaryMacro(Param.P_Key));
}





//*  IsBinaryMacro  ----------------------------------------------------------
//
// Function: Returns TRUE if the string ends with off suffix or on suffix.
//
//           FALSE inmplies that the string is a unary macro or a variable
//           name.
//
//*

BOOL
IsBinaryMacro(TCHAR *pch)
{
  return((BOOL)BinarySuffix(pch));
}





//*  BinarySuffix  -----------------------------------------------------------
//
// Function: This function indicates whether the input string ends in
//           _off or _on.
//
// Returns: ON_SUFFIX, OFF_SUFFIX, or FALSE if neither is the case
//
//*
WORD
BinarySuffix(TCHAR *pch)
{
  while (*pch != '\0')
    pch++;

  pch -= strlen(MXS_ON_SUFX);
  if (_stricmp(pch, MXS_ON_SUFX) == 0)
    return(ON_SUFFIX);

  while (*pch != '\0')
    pch++;

  pch -= strlen(MXS_OFF_SUFX);
  if (_stricmp(pch, MXS_OFF_SUFX) == 0)
    return(OFF_SUFFIX);

  return(FALSE);
}





//*  GetCoreMacroName  -------------------------------------------------------
//
// Function: Copies FullName to CoreName, but omits the angle brackets, <>,
//           for all macros, and omits the "_ON" or "_OFF" suffix for binary
//           macros.
//
// Returns: SUCCESS
//          ERROR_NOT_BINARY_MACRO
//
//*

DWORD
GetCoreMacroName(LPTSTR lpszFullName, LPTSTR lpszCoreName)
{
  LPTCH lpch;


  strcpy(lpszCoreName, lpszFullName);           // Copy FullName

  lpch = lpszCoreName;

  while (*lpch != '\0')                         // Check for _ON suffix
    lpch++;

  lpch -= strlen(MXS_ON_SUFX);
  if (_stricmp(lpch, MXS_ON_SUFX) == 0)
  {
    *lpch = '\0';
    return(SUCCESS);
  }


  while (*lpch != '\0')                         // Check for _OFF suffix
    lpch++;

  lpch -= strlen(MXS_OFF_SUFX);
  if (_stricmp(lpch, MXS_OFF_SUFX) == 0)
  {
    *lpch = '\0';
    return(SUCCESS);
  }

  return(ERROR_NOT_BINARY_MACRO);
}





//*  CoreMacroNameMatch  -----------------------------------------------------
//
// Function: Assumes that lpszShortName is in the form of a unary macro
//           name, <macro>, and that lpszFullName is a binary macro.
//           If either assumption is false the function returns FALSE.
//           Only if the names (without the angle brackets, <>, and without
//           the _on or _off suffixes) match exactly is TRUE returned.
//
//           <speaker> will match <speaker_off> or <speaker_on>, but
//           will not match <speakers_off>.
//
// Returns: TRUE/FALSE
//
//*

BOOL
CoreMacroNameMatch(LPTSTR lpszShortName, LPTSTR lpszFullName)
{
  TCHAR  szCoreName[MAX_PARAM_KEY_SIZE];
  DWORD   dRC;


  dRC = GetCoreMacroName(lpszFullName, szCoreName);
  if (dRC != SUCCESS)
    return(FALSE);

  return(_stricmp(lpszShortName, szCoreName) == 0);
}





//*  InitParameterStr  -------------------------------------------------------
//
// Function: Changes all spaces in the first parameter to NULL characters.
//           On return the second parameter is a pointer to the NULL
//           character at the end of the input string.
//
//           This function converts space separated parameters into NULL
//           terminated strings.  GetNextParameter() is then used to move
//           a pointer from one string to the next.
//
// Caution: This function alters the input string.
//
// Returns: Nothing.
//
//*

void
InitParameterStr(TCHAR *pch, TCHAR **ppchEnd)
{
  while (*pch != '\0')
  {
    if ((*pch == ' ') || (*pch == ','))
      *pch = '\0';
    pch++;
  }

  *ppchEnd = pch;
}





//*  GetNextParameter  -------------------------------------------------------
//
// Function: If the first parameter points to a consecutive series of null
//           terminated strings, this function advances the first parameter
//           to the beginning of the next null terminated string.
//           It will not move past the second parameter which is a pointer
//           to the end of the consecutive series.
//
// Returns: Nothing.
//
//*
void
GetNextParameter(TCHAR **ppch, TCHAR *pchEnd)
{
  while (**ppch != '\0')                      //Move to next zero character
    (*ppch)++;

  while (*ppch < pchEnd && **ppch == '\0')    //Move to 1st char of next substr
    (*ppch)++;
}





//*  MacroCount  -------------------------------------------------------------
//
// Function: This function returns a count of macros in the RASMAN_DEVICEINFO
//           struct that the input parameter points to.
//             ALL_MACROS:   Unary and binary macros are counted.
//             BINARY_MACRO: Only binary macros are counted.
//           In either case the ON and OFF parts of a binary macro
//           together count as one macro (not two).
//
// Returns: Count of macros in *pInfo.
//
//*

WORD
MacroCount(RASMAN_DEVICEINFO *pInfo, WORD wType)
{
  WORD  i, cMacros;


  for(i=0, cMacros=0; i < pInfo->DI_NumOfParams; i++)
  {
    if (IsVariable(pInfo->DI_Params[i]))
      ;

    else if (IsBinaryMacro(pInfo->DI_Params[i].P_Key))
    {
      i++;                        // Step thru each part of a binary macro
      cMacros++;                  // But count only once
    }
    else                          // Unary macro
      if (wType == ALL_MACROS)
        cMacros++;
  }

  return(cMacros);
}





//*  CmdTypeToStr  -----------------------------------------------------------
//
// Function: This function takes an enum CMDTYPE and converts it to a
//           zero terminated ASCII string which it places in the buffer
//           passed in the first parameter.
//
// Returns: Pointer to first parameter
//
//*

PTCH
CmdTypeToStr(PTCH pszStr, CMDTYPE eCmdType)
{
  switch(eCmdType)
  {
    case CT_GENERIC:
      *pszStr = '\0';
      break;

    case CT_INIT:
      strcpy(pszStr, "_INIT");
      break;

    case CT_DIAL:
      strcpy(pszStr, "_DIAL");
      break;

    case CT_LISTEN:
      strcpy(pszStr, "_LISTEN");
      break;
  }

  return(pszStr);
}





//*  IsLoggingOn  -----------------------------------------------------------
//
// Funciton: Reads the registry to determine if the device dialog is to
//           be logged in a file.
//
// Returns: TRUE if logging is to take place; otherwise FALSE
//
//*

BOOL
IsLoggingOn(void)
{
  HKEY  hKey;
  LONG  lRC;
  DWORD dwType, dwValue, dwValueSize = sizeof(dwValue);


  lRC = RegOpenKey(HKEY_LOCAL_MACHINE, RASMAN_REGISTRY_PATH, &hKey);
  if (lRC != ERROR_SUCCESS)
    return(FALSE);

  lRC = RegQueryValueEx(hKey,
                        RASMAN_LOGGING_VALUE,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwValue,
                        &dwValueSize);

  RegCloseKey(hKey);                        

  if (lRC != ERROR_SUCCESS)
    return(FALSE);

  if (dwType != REG_DWORD)
    return(FALSE);


  return(dwValue ? TRUE : FALSE);
}





//*  InitLog  ---------------------------------------------------------------
//
// Funciton: Opens the log file in overwrite mode and writes a header
//           which includes date and time.
//
// Returns: Nothing.
//
//*

void
InitLog(void)
{
  TCHAR       szBuffer[MAX_CMD_BUF_LEN];
  int         iSize;
  DWORD       dwBytesWritten;
  SYSTEMTIME  st;


  // Create log file path

  GetSystemDirectory(szBuffer, sizeof(szBuffer));
  strcat(szBuffer, RAS_PATH);
  strcat(szBuffer, LOG_FILENAME);


  ghLogFile = CreateFile(szBuffer,
                     GENERIC_WRITE,
                     FILE_SHARE_READ,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                     NULL);

  if (ghLogFile == INVALID_HANDLE_VALUE)
  {
    gbLogDeviceDialog = FALSE;
    return;
  }


  // Create header

  GetLocalTime(&st);

  iSize = sprintf(szBuffer,
           "Remote Access Service Device Log  %02d/%02d/%d  %02d:%02d:%02d\r\n",
           st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);

  WriteFile(ghLogFile, szBuffer, (DWORD)iSize, &dwBytesWritten, NULL);

  strcpy(szBuffer,
    "---------------------------------------------------------------\r\n\r\n");

  WriteFile(ghLogFile, szBuffer, strlen(szBuffer), &dwBytesWritten, NULL);
}





//*  LogString  -------------------------------------------------------------
//
// Funciton: Writes label and string to the Device Log file.
//
// Assumptions: Total length of labels and port handle string will be < 80
//              characters.
//
// Returns: nothing.
//
//*

void
LogString(DEVICE_CB *pDev, TCHAR *pszLabel, TCHAR *psString, DWORD dwStringLen)
{
  TCHAR  sBuffer[MAX_CMD_BUF_LEN + 80];
  TCHAR  szPortLabel[] = "Port:";
  DWORD  dwBytesWritten, dwTotalLen;


  // If file is getting large, start over with new file

  if (GetFileSize(ghLogFile, NULL) > 100000)
  {
    CloseHandle(ghLogFile);
    InitLog();
  }


  strcpy(sBuffer, szPortLabel);
  dwTotalLen = strlen(szPortLabel);

  strcpy(sBuffer + dwTotalLen, pDev->szPortName);
  dwTotalLen += strlen(pDev->szPortName);

  strcpy(sBuffer + dwTotalLen, " ");
  dwTotalLen++;

  strcpy(sBuffer + dwTotalLen, pszLabel);
  dwTotalLen += strlen(pszLabel);

  memcpy(sBuffer + dwTotalLen, psString, dwStringLen);
  dwTotalLen += dwStringLen;

  strcpy(sBuffer + dwTotalLen, "\r\n");
  dwTotalLen += 2;

  WriteFile(ghLogFile, sBuffer, dwTotalLen, &dwBytesWritten, NULL);
}





//*  CheckForOverruns -------------------------------------------------------
//
// Funciton: Checks for com port overrun errors.
//
// Assumptions: Com port errors have been cleared before rasmxs dll APIs
//              are called, that is, serial dll API PortInit was called
//              prior to using the port, or PortClose and PortOpen were
//              called.
//
// Returns: TRUE if an overrun error has occured; otherwise FALSE.
//
//*

BOOL
CheckForOverruns(HANDLE hIOPort)
{
  DWORD  dwErrors = 0;


  ClearCommError(hIOPort, &dwErrors, NULL);

  return((dwErrors & CE_OVERRUN) ? TRUE : FALSE);
}





//*  LoadRasserDll  ---------------------------------------------------------
//
// Funciton: Loads rasser.dll and gets entry points for two APIs.
//
// Returns: SUCCESS
//          ERROR_PORT_NOT_CONFIGURED
//*

DWORD
LoadRasserDll(PortGetInfo_t *pPortGetInfo, PortSetInfo_t *pPortSetInfo)
{
  HANDLE     hLib;


  // Load DLL

  hLib = LoadLibrary(SERIAL_DLL_FILENAME);
  if (hLib == NULL)
  {
    LogError(ROUTERLOG_CANNOT_LOAD_SERIAL_DLL, 0, NULL, NO_ERROR);
    return(ERROR_PORT_NOT_CONFIGURED);
  }


  // Get entry points
  // Note: Create a new, more appropriate error code to use here,
  // such as, ERROR_CORRUPT_DLL.

  PortSetInfo = (PortSetInfo_t) GetProcAddress(hLib, "PortSetInfo");
  if (PortSetInfo == NULL)
    return(ERROR_PORT_NOT_CONFIGURED);

  PortGetInfo = (PortGetInfo_t) GetProcAddress(hLib, "PortGetInfo");
  if (PortGetInfo == NULL)
    return(ERROR_PORT_NOT_CONFIGURED);


  return(SUCCESS);
}




//*  OpenResponseSection  ---------------------------------------------------
//
// Funciton: This function is only called if the device is a modem.
//
//           7-9-93 We now open the modem response section when a DCB
//           is created for the first modem.  Then we leave it open
//           (while the RASMXS DLL is in memory).
//
// Returns: Error values from RasDevOpen.
//
//*
DWORD
OpenResponseSection (PCHAR szFileName)
{
    DWORD  dRC = SUCCESS ;


    // **** Exclusion Begin ****
    WaitForSingleObject(ResponseSection.Mutex, INFINITE) ;

    if (ResponseSection.UseCount == 0)
      dRC = RasDevOpen(szFileName,
                       RESPONSES_SECTION_NAME,
                       &ResponseSection.Handle) ;

    if (dRC == SUCCESS)
      ResponseSection.UseCount = 1 ;            //This used to be an increment.


    // *** Exclusion End ***
    ReleaseMutex(ResponseSection.Mutex);

    return dRC ;
}




//*  OpenResponseSection  ---------------------------------------------------
//
// Funciton: This function should never be called.
//
//           7-9-93 We now open the modem response section when a DCB
//           is created for the first modem.  Then we leave it open
//           (while the RASMXS DLL is in memory).
//
// Returns: nothing.
//
//*

/***
VOID
CloseResponseSection ()
{

    // **** Exclusion Begin ****
    WaitForSingleObject(ResponseSection.Mutex, INFINITE) ;

    ResponseSection.UseCount-- ;

    if (ResponseSection.UseCount == 0)
      RasDevClose (ResponseSection.Handle) ;

    // *** Exclusion End ***
    ReleaseMutex(ResponseSection.Mutex);

}
***/


//* FindOpenDevSection
//
//
// Returns: TRUE if found, FALSE if not.
//*
BOOL
FindOpenDevSection (PTCH lpszFileName, PTCH lpszSectionName, HRASFILE *hFile)
{

    SavedSections* temp ;

    for (temp = gpSavedSections; temp; temp=temp->Next)	{
	if (!_strcmpi (temp->FileName, lpszFileName) &&
	    !_strcmpi (temp->SectionName, lpszSectionName) &&
	    !temp->InUse) {
		*hFile = temp->hFile ;
		temp->InUse = TRUE ;
		RasDevResetCommand (*hFile) ;
		return TRUE ;
	    }
    }

    return FALSE ;
}


//*
//
//
//
//*
VOID
AddOpenDevSection (PTCH lpszFileName, PTCH lpszSectionName, HRASFILE hFile)
{
    SavedSections *temp ;

    GetMem(sizeof(SavedSections), (char **)&temp) ;
    if (temp == NULL)
	return ;    // section not saved - no problem
    strcpy (temp->FileName, lpszFileName) ;
    strcpy (temp->SectionName, lpszSectionName) ;
    temp->InUse = TRUE ;
    temp->hFile = hFile ;

    if (gpSavedSections)
	temp->Next = gpSavedSections ;
    else
	temp->Next = NULL ;

    gpSavedSections = temp ;
}


//*
//
//
//
//*
VOID
CloseOpenDevSection (HRASFILE hFile)
{
    SavedSections* temp ;

    for (temp = gpSavedSections; temp; temp=temp->Next)	{
	if (temp->hFile == hFile) {
	    temp->InUse = FALSE ;
	    return ;
	}
    }
}





//*  DbgPrntf  --------------------------------------------------------------
//
// Funciton: DbgPrntf -- printf to the debugger console
//           Takes printf style arguments.
//           Expects newline characters at the end of the string.
//           Written by BruceK.
//
// Returns: nothing
//
//*

#ifdef DEBUG

#include <stdarg.h>
#include <stdio.h>


void DbgPrntf(const char * format, ...) {
    va_list marker;
    char String[512];

    va_start(marker, format);
    vsprintf(String, format, marker);
    OutputDebugString(String);
}

#endif //DEBUG





//*  DbgStr  ----------------------------------------------------------------
//
// Funciton: Writes an unterminated string to the debugger.
//
// Returns: nothing
//
//*

#ifdef DEBUG


void DbgStr(char Str[], DWORD StrLen)
{
  DWORD i;
  char  Char[] = " ";


  for (i=0; i<StrLen; i++)
  {
    Char[0] = Str[i];
    OutputDebugString(Char);
  }

  if (StrLen > 0)
    OutputDebugString("\n");
}

#endif //DEBUG





//*  ConPrintf  -------------------------------------------------------------
//
// Funciton: Writes debug information to the process's console window.
//           Written by StefanS.
//
// Returns: nothing
//
//*

#ifdef DBGCON

VOID
ConPrintf ( char *Format, ... )

{
    va_list arglist;
    char    OutputBuffer[1024];
    DWORD   length;


    va_start( arglist, Format );
    vsprintf( OutputBuffer, Format, arglist );
    va_end( arglist );

    length = strlen( OutputBuffer );

    WriteFile( GetStdHandle(STD_OUTPUT_HANDLE),
               (LPVOID )OutputBuffer,
               length,
               &length,
               NULL );

}

#endif //DBGCON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\mxs32\mxsstate.c ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: rasstate.c
//
//  Revision History
//
//  Jul  1, 1992   J. Perry Hannah      Created
//
//
//  Description: This file contains the state machine functions for the
//               RASMXS.DLL and related funcitons.
//
//****************************************************************************

#include <nt.h>             //These first five headers are used by media.h
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <string.h>
#include <malloc.h>
#include <stdlib.h>


#include <rasman.h>
#include <raserror.h>
#include <serial.h>
#include <rasfile.h>
#include <media.h>
#include <mprlog.h>
#include <rtutils.h>

#include <rasmxs.h>
#include <mxsint.h>
#include <mxspriv.h>
#include "mxswrap.h"        // inf file wrapper
 



//*  Global Variables  *******************************************************
//
extern RESPSECTION    ResponseSection ;    //Shared response section

extern PortSetInfo_t  PortSetInfo;         //API typedef defined in media.h

extern BOOL           gbLogDeviceDialog;   //Indicates logging on if TRUE
extern HANDLE         ghLogFile;           //Handle of device log file




//*  BuildMacroXlationsTable  ------------------------------------------------
//
// Function: Creates a table of macros and their expansions for use by
//           the RasDevAPIs.  Memory is allocated for the table and the
//           pMacros pointer in the device control block points to it.
//           Since this function depends on a valid InfoTable being present
//           CreateInfoTable and CreateAttributes must be called before
//           this function is called.
//
// Assumptions: - Parameters in InfoTable are sorted by P_Key.
//              - Both parts of binary macros are present.
//              These assumptions imply that if somename_off is in InfoTable
//              somename_on is also present and is adjacent to somename_off.
//
// Returns: SUCCESS
//          ERROR_ALLOCATING_MEMORY
//*

DWORD
BuildMacroXlationTable(DEVICE_CB *pDevice)
{
  WORD        i, j, k, cMacros;
  DWORD       dSize;
  TCHAR       szCoreName[MAX_PARAM_KEY_SIZE];

  RASMAN_DEVICEINFO  *pInfo = pDevice->pInfoTable;
  MACROXLATIONTABLE  *pMacros;



  // Calucate size and allocate memory

  cMacros = MacroCount(pInfo, ALL_MACROS);
  dSize = sizeof(MACROXLATIONTABLE) + sizeof(MXT_ENTRY) * (cMacros - 1);

  GetMem(dSize, (BYTE **) &(pDevice->pMacros));
  if (pDevice->pMacros == NULL)
    return(ERROR_ALLOCATING_MEMORY);


  // Copy macro names and pointers to new Macro Translation Table

  pMacros = pDevice->pMacros;
  pMacros->MXT_NumOfEntries = cMacros;

  for (i=0, j=0; i < pInfo->DI_NumOfParams; i++)
  {
    if (IsVariable(pInfo->DI_Params[i]))
      ;

      // copy nothing

    else if (IsBinaryMacro(pInfo->DI_Params[i].P_Key))
    {
      // copy Core Macro Name and pointer to Param

      GetCoreMacroName(pInfo->DI_Params[i].P_Key, szCoreName);
      strcpy(pMacros->MXT_Entry[j].E_MacroName, szCoreName);


      // copy Param ptr for ON macro if enabled, else copy Off Param ptr

      if (XOR(pInfo->DI_Params[i].P_Attributes & ATTRIB_ENABLED,
              BinarySuffix(pInfo->DI_Params[i].P_Key) == ON_SUFFIX))
        k = i + 1;
      else
        k = i;

      pMacros->MXT_Entry[j].E_Param = &(pInfo->DI_Params[k]);

      i++;
      j++;
    }
    else  // Is Unary Macro
    {
      // copy Core Macro Name and pointer to Param

      strcpy(pMacros->MXT_Entry[j].E_MacroName, pInfo->DI_Params[i].P_Key);
      pMacros->MXT_Entry[j].E_Param = &(pInfo->DI_Params[i]);
      j++;
    }
  }

  return(SUCCESS);

///***
#ifdef DEBUG    //Printout Macro Translation Table

  for(i=0; i<cMacros; i++)
    DebugPrintf(("%32s  %s\n", pMacros->MXT_Entry[i].E_MacroName,
                 pMacros->MXT_Entry[i].E_Param->P_Value.String.Data));

#endif // DEBUG
//***/
}



//*  DeviceStateMachine  -----------------------------------------------------
//
// Function: This is the main state machine used by the DLL to control
//           asynchronous actions (writing and reading to/from devices).
//
// Returns: PENDING
//          SUCCESS
//          ERROR_CMD_TOO_LONG from RasDevGetCommand
//          Error return codes from GetLastError()
//
//*

DWORD
DeviceStateMachine(DEVICE_CB *pDevice, HANDLE hIOPort)
{
  DWORD         dRC, lpcBytesWritten;
  BOOL          fIODone, fEndOfSection = FALSE;
  TCHAR         szCmdSuffix[MAX_CMDTYPE_SUFFIX_LEN + 1];
  COMMTIMEOUTS  CT;



  while(1)
  {
    //DebugPrintf(("DeviceStateMachine state: %d\n", pDevice->eDevNextAction));

    switch(pDevice->eDevNextAction)
    {

      // Send a Command to the device

      case SEND:
                                                    // Get Command string
        dRC = RasDevGetCommand(pDevice->hInfFile,
                               CmdTypeToStr(szCmdSuffix, pDevice->eCmdType),
                               pDevice->pMacros,
                               pDevice->szCommand,
                               &(pDevice->dCmdLen));

        switch(dRC)
        {
          case SUCCESS:

            // Check to see if a response is expected

            pDevice->bResponseExpected =
              RasDevResponseExpected(pDevice->hInfFile, pDevice->eDeviceType);


            // Log the Command

            if (gbLogDeviceDialog)
              LogString(pDevice, "Command to Device:", pDevice->szCommand,
                                                       pDevice->dCmdLen);


            // Check for null command with no response expected

            if (pDevice->dCmdLen == 0 && !pDevice->bResponseExpected)
            {
              // Pause between commands

              if (CommWait(pDevice, hIOPort, NO_RESPONSE_DELAY))
                return(ERROR_UNEXPECTED_RESPONSE);

              else if ((dRC = GetLastError()) == ERROR_IO_PENDING)
              {
                pDevice->eDevNextAction = DONE;
                return(PENDING);
              }
              else
                return(dRC);
            }


            // Send the command to the Port

            CT.WriteTotalTimeoutMultiplier = 0;
            CT.WriteTotalTimeoutConstant = TO_WRITE;
            SetCommTimeouts(hIOPort, &CT);

            fIODone = WriteFile(hIOPort,            // Send Cmd string to modem
                                pDevice->szCommand,
                                pDevice->dCmdLen,
                                &lpcBytesWritten,
                                (LPOVERLAPPED)&(pDevice->Overlapped));

            pDevice->eDevNextAction = RECEIVE;

            if ( ! fIODone)
            {
              if ((dRC = GetLastError()) == ERROR_IO_PENDING)
                return(PENDING);

              else
                return(dRC);
            }

            return(PENDING);

          case ERROR_END_OF_SECTION:

            fEndOfSection = TRUE;
            pDevice->eDevNextAction = DONE;
            break;

          default:
            return(dRC);
        }
        break;


      // Recieve Response string from device

      case RECEIVE:

        dRC = ReceiveStateMachine(pDevice, hIOPort);
        switch(dRC)
        {
          case SUCCESS:
            pDevice->eDevNextAction = DONE;
            pDevice->eRcvState = GETECHO;       //Reset Recieve State Machine
            break;

          case PENDING:
            return(PENDING);

          default:
            pDevice->eRcvState = GETECHO;       //Reset Recieve State Machine
            return(dRC);
        }
        break;


      // A Command-Response cycle is complete

      case DONE:

        if (fEndOfSection)
          switch(pDevice->eCmdType)         //Last cmd of this type is now done
          {
            case CT_INIT:
              pDevice->eCmdType = pDevice->eNextCmdType;  //Reset command type
              RasDevResetCommand(pDevice->hInfFile);      //Reset INF file ptr
              break;

            case CT_DIAL:
            case CT_LISTEN:
              if ((dRC = CheckBpsMacros(pDevice)) != SUCCESS)
                return(dRC);
              return(ResetBPS(pDevice));

            case CT_GENERIC:
              return(SUCCESS);
          }

        pDevice->eDevNextAction = SEND;                   //Reset state machine
        break;

    } /* Switch */
  } /* While */
} /* DeviceStateMachine */



//*  ReceiveStateMachine  ----------------------------------------------------
//
// Function: This state machine controls asynchronously reading from the
//           device.  First the command echo is read promptly after the
//           command is sent.  Then after a delay the the response begins
//           arriving.  An asynchronous read with a long time out is done
//           for the first character.  Then the rest of the string is read
//           (also asynchronously).
//
// Returns: PENDING
//          SUCCESS
//          ERROR_REPEATED_PARTIAL_RESPONSE
//          Error return codes from GetLastError(), RasDevCheckResponse()
//
//*

DWORD
ReceiveStateMachine(DEVICE_CB *pDevice, HANDLE hIOPort)
{
  DWORD     dRC;
  BOOL      fKeyIsOK;
  TCHAR     szKey[MAX_PARAM_KEY_SIZE];


  while(1)
  {
    //DebugPrintf(("ReceiveStateMachine state: %d\n", pDevice->eRcvState));

    switch (pDevice->eRcvState)
    {

      case GETECHO:

        // Check if an echo is expected.
        // 1. If there is no command there is no echo.
        // 2. Null modems require that if there is no response there is no echo
        //    so we require it for all devices.
        // 3. If the current line of INF file is "NoEcho", there is no echo.

        if (pDevice->dCmdLen == 0 ||
            !pDevice->bResponseExpected ||
            !RasDevEchoExpected(pDevice->hInfFile))
        {
          pDevice->eRcvState = GETFIRSTCHAR;
          break;
        }


        // Clear buffer used for echo and device response, and Reset Event

        memset(pDevice->szResponse, '\0', sizeof(pDevice->szResponse));

        ResetEvent(pDevice->hNotifier);                 //Reset event handle


        ConsolePrintf(("WaitForEcho    hIOPort: 0x%08lx  hNotifier: 0x%08x\n",
                        hIOPort, pDevice->hNotifier));

        // Get Echo

        if (WaitForEcho(pDevice, hIOPort, pDevice->dCmdLen))
        {
          pDevice->eRcvState = CHECKECHO;
          return(PENDING);
        }
        else if ((dRC = GetLastError()) == ERROR_IO_PENDING)
        {
          pDevice->eRcvState = GETNUMBYTESECHOD;
          return(PENDING);
        }
        else
          return(dRC);

        break;


      case GETNUMBYTESECHOD:

        if (!GetOverlappedResult(hIOPort,
                                 (LPOVERLAPPED)&pDevice->Overlapped,
                                 &pDevice->cbRead,
                                 !WAITFORCOMPLETION))
          return(GetLastError());

        pDevice->eRcvState = CHECKECHO;                 //Set Next state
        break;


      case CHECKECHO:

        // Log the Echo received

        DebugPrintf(("Echo:%s!\n cbEcohed:%d\n",
                      pDevice->szResponse, pDevice->cbRead));

        if (gbLogDeviceDialog && !pDevice->fPartialResponse)
          LogString(pDevice, "Echo from Device :", pDevice->szResponse,
                                                   pDevice->cbRead);


        // Check for echo different from command

        switch(pDevice->eDeviceType)
        {
          case DT_MODEM:
            if (pDevice->cbRead != pDevice->dCmdLen ||
                _strnicmp(pDevice->szCommand,
                         pDevice->szResponse, pDevice->dCmdLen) != 0)
            {
              if (CheckForOverruns(hIOPort))
                return(ERROR_OVERRUN);
              else
                return(ERROR_PORT_OR_DEVICE);
            }
            break;

          case DT_PAD:
          case DT_SWITCH:
            if (RasDevSubStr(pDevice->szResponse,
                             pDevice->cbRead,
                             "NO CARRIER",
                             strlen("NO CARRIER")))

              return(ERROR_NO_CARRIER);
            break;
        }


        pDevice->eRcvState = GETFIRSTCHAR;              //Set Next state
        break;


      case GETFIRSTCHAR:

        // Check if a response is expected

        if ( ! pDevice->bResponseExpected)
        {
          if ((dRC = PutInMessage(pDevice, "", 0)) != SUCCESS)
            return(dRC);

          pDevice->cbTotal = 0;                     //Reset for next response
          return(SUCCESS);
        }


        // Save starting point for a receive following an echo

        if (!pDevice->fPartialResponse)
        {
          (pDevice->cbTotal) += pDevice->cbRead;
          pDevice->pszResponseStart = pDevice->szResponse + pDevice->cbTotal;
        }

        ResetEvent(pDevice->hNotifier);                 //Reset event handle

        if (WaitForFirstChar(pDevice, hIOPort))
        {
          pDevice->eRcvState = GETRECEIVESTR;
          return(PENDING);
        }
        else if ((dRC = GetLastError()) == ERROR_IO_PENDING)
        {
          pDevice->eRcvState = GETNUMBYTESFIRSTCHAR;
          return(PENDING);
        }
        else
          return(dRC);

        break;


      case GETNUMBYTESFIRSTCHAR:

        DebugPrintf(("After 1st char:%s! cbTotal:%d\n",
                      pDevice->szResponse, pDevice->cbTotal));

        if (!GetOverlappedResult(hIOPort,
                                 (LPOVERLAPPED)&pDevice->Overlapped,
                                 &pDevice->cbRead,
                                 !WAITFORCOMPLETION))
          return(GetLastError());

        pDevice->eRcvState = GETRECEIVESTR;              //Set Next state
        break;


      case GETRECEIVESTR:

        (pDevice->cbTotal)++;                   //FIRSTCAR always rcvs 1 byte

        ResetEvent(pDevice->hNotifier);                 //Reset event handle

        if (ReceiveString(pDevice, hIOPort))
        {
          pDevice->eRcvState = CHECKRESPONSE;
          return(PENDING);
        }
        else if ((dRC = GetLastError()) == ERROR_IO_PENDING)
        {
          pDevice->eRcvState = GETNUMBYTESRCVD;
          return(PENDING);
        }
        else
          return(dRC);

        break;


      case GETNUMBYTESRCVD:

        if (!GetOverlappedResult(hIOPort,
                                 (LPOVERLAPPED)&pDevice->Overlapped,
                                 &pDevice->cbRead,
                                 !WAITFORCOMPLETION))
          return(GetLastError());

        pDevice->eRcvState = CHECKRESPONSE;             //Set Next state
        break;


      case CHECKRESPONSE:

        (pDevice->cbTotal) += pDevice->cbRead;


        // Always put response string where UI can get it

        if (pDevice->eDeviceType == DT_MODEM)
          dRC = PutInMessage(pDevice,
                             pDevice->pszResponseStart,
                             ModemResponseLen(pDevice));
        else
          dRC = PutInMessage(pDevice, pDevice->szResponse, pDevice->cbTotal);

        if (dRC != SUCCESS)
          return(dRC);



        // Check the response

        dRC = CheckResponse(pDevice, szKey);


        // Log the response received

        if (gbLogDeviceDialog && dRC != ERROR_PARTIAL_RESPONSE)
          LogString(pDevice,
                    "Response from Device:",
                    pDevice->pszResponseStart,
                    ModemResponseLen(pDevice));

        switch(dRC)
        {
          case ERROR_UNRECOGNIZED_RESPONSE:
          default:                                              // Other errors
            return(dRC);


          case ERROR_PARTIAL_RESPONSE:

            if (pDevice->fPartialResponse)
              return(ERROR_PARTIAL_RESPONSE_LOOPING);

            pDevice->fPartialResponse = TRUE;
            pDevice->eRcvState = GETFIRSTCHAR;

            ConsolePrintf(("Partial Response\n"));
            break;


          case SUCCESS:                           // Response found in INF file

            pDevice->cbTotal = 0;                 // Reset for next response

            fKeyIsOK = !_strnicmp(szKey, MXS_OK_KEY, strlen(MXS_OK_KEY));


            // Do we need to loop and get another response from device

	    if (((_stricmp(szKey, LOOP_TXT) == 0) && (pDevice->eCmdType != CT_INIT)) ||
                (fKeyIsOK && pDevice->eCmdType == CT_LISTEN) )
            {
              pDevice->eRcvState = GETFIRSTCHAR;
              break;
            }


            // Check if device has error contol on

            pDevice->bErrorControlOn = _stricmp(szKey, MXS_CONNECT_EC_KEY) == 0;


            // Determine return code

            if (fKeyIsOK)
              if (pDevice->eCmdType == CT_DIAL)
                return(ERROR_PORT_OR_DEVICE);
              else
                return(SUCCESS);

            if (_strnicmp(szKey, MXS_CONNECT_KEY, strlen(MXS_CONNECT_KEY)) == 0)
              return(SUCCESS);

            else if (_strnicmp(szKey, MXS_ERROR_KEY, strlen(MXS_ERROR_KEY)) == 0)
              return(MapKeyToErrorCode(szKey));

            else if (CheckForOverruns(hIOPort))
              return(ERROR_OVERRUN);

            else
              return(ERROR_UNKNOWN_RESPONSE_KEY);
        }
        break;

    } /* Switch */
  } /* While */
} /* ReceiveStateMachine */



//*  CheckResponse  ----------------------------------------------------------
//
// Function: If DeviceType is Modem this function checks first for a
//           response in that particular modem's section of the INF
//           file and returns if it finds one. If there is no response
//           there, it checks for a response in the Modems Responses
//           section.
//
//           If DeviceType is not Modem the function checks only in
//           the particular device's section of the INF file.
//
// Returns: Error return codes from RasDevCheckResponse()
//
//*

DWORD
CheckResponse(DEVICE_CB *pDev, LPTSTR szKey)
{
  DWORD  dRC, dResponseLen;


  if (pDev->cbTotal > sizeof(pDev->szResponse))
    return(ERROR_RECV_BUF_FULL);


  dResponseLen = ModemResponseLen(pDev);

  DebugPrintf(("Device Response:%s! cbResponse:%d\n",
               pDev->pszResponseStart, dResponseLen));

  dRC = RasDevCheckResponse(pDev->hInfFile,
                            pDev->pszResponseStart,
                            dResponseLen,
                            pDev->pMacros,
                            szKey);

  if (pDev->eDeviceType == DT_MODEM &&
      dRC != SUCCESS &&
      dRC != ERROR_PARTIAL_RESPONSE) {

      // **** Exclusion Begin ****
      WaitForSingleObject(ResponseSection.Mutex, INFINITE) ;

      dRC = RasDevCheckResponse(ResponseSection.Handle,
                                pDev->pszResponseStart,
                                dResponseLen,
                                pDev->pMacros,
                                szKey);

      // *** Exclusion End ***
      ReleaseMutex(ResponseSection.Mutex);

    }



  if (dRC == ERROR_UNRECOGNIZED_RESPONSE)
  {

    // Maybe there was no echo.
    // Try again assuming string starts at beginning of buffer.

    dRC = RasDevCheckResponse(pDev->hInfFile,
                              pDev->szResponse,
                              pDev->cbTotal,
                              pDev->pMacros,
                              szKey);

    if (pDev->eDeviceType == DT_MODEM &&
        dRC != SUCCESS &&
        dRC != ERROR_PARTIAL_RESPONSE) {

      // **** Exclusion Begin ****
      WaitForSingleObject(ResponseSection.Mutex, INFINITE) ;

      dRC = RasDevCheckResponse(ResponseSection.Handle,
                                  pDev->szResponse,
                                  pDev->cbTotal,
                                  pDev->pMacros,
                                  szKey);

      // *** Exclusion End ***
      ReleaseMutex(ResponseSection.Mutex);

    }
  }

  return(dRC);
}



//*  ModemResponseLen  -------------------------------------------------------
//
// Function: This function returns the length of the portion of the
//           response in the response buffer which follows the echo.
//
// Returns: Total length - (start of response - beginning of buffer)
//
//*

DWORD
ModemResponseLen(DEVICE_CB *pDev)
{
  return(DWORD)(pDev->cbTotal - (pDev->pszResponseStart - pDev->szResponse));
}



//*  CommWait  ---------------------------------------------------------------
//
// Function: This function causes an asynchronous delay by reading the
//           com port when no characters are expected.  When the ReadFile
//           times out the calling process is signaled via hNotifier.
//
// Returns: Values from Win32 api calls.
//
//*

DWORD
CommWait(DEVICE_CB *pDevice, HANDLE hIOPort, DWORD dwPause)
{
  DWORD         dwBytesRead;
  TCHAR         Buffer[2048];
  COMMTIMEOUTS  CT;


  CT.ReadIntervalTimeout = 0;
  CT.ReadTotalTimeoutMultiplier = 0;
  CT.ReadTotalTimeoutConstant = dwPause;

  if ( ! SetCommTimeouts(hIOPort, &CT))
    return(FALSE);


  return(ReadFile(hIOPort,
                  Buffer,
                  sizeof(Buffer),
                  &dwBytesRead,
                  (LPOVERLAPPED)&pDevice->Overlapped));
}



//*  WaitForEcho  ------------------------------------------------------------
//
// Function: This function reads the echo of the command sent to the
//           device.  The echo is not used and is simply ignored.
//           Since the length of the echo is the length of the command
//           sent, cbEcho is the size of the command sent.
//
//           ReadFile is asynchronous (because the port was opened in
//           overlapped mode), and completes when the buffer is full
//           (cbEcho bytes) or after TO_ECHO mS, whichever comes first.
//
// Returns: Error return codes from ReadFile(), or GetLastError().
//
//*

BOOL
WaitForEcho(DEVICE_CB *pDevice, HANDLE hIOPort, DWORD cbEcho)
{
  COMMTIMEOUTS  CT;


  CT.ReadIntervalTimeout = 0;
  CT.ReadTotalTimeoutMultiplier = 0;
  CT.ReadTotalTimeoutConstant = TO_ECHO;            // Comm time out = TO_ECHO

  if ( ! SetCommTimeouts(hIOPort, &CT))
    return(FALSE);


  return(ReadFile(hIOPort,
                  pDevice->szResponse,
                  cbEcho,
                  &pDevice->cbRead,
                  (LPOVERLAPPED)&pDevice->Overlapped));
}



//*  WaitForFirstChar  -------------------------------------------------------
//
// Function: This function reads the first character received from the
//           device in response to the last command.  (This follows the
//           echo of the command.)
//
//           ReadFile is asynchronous (because the port was opened in
//           overlapped mode), and completes after one character is
//           received, or after CT.ReadToalTimeoutConstant, whichever
//           comes first.
//
// Returns: Error return codes from ReadFile(), or GetLastError().
//
//*

BOOL
WaitForFirstChar(DEVICE_CB *pDevice, HANDLE hIOPort)
{
  TCHAR         *pszResponse;
  COMMTIMEOUTS  CT;


  CT.ReadIntervalTimeout = 0;
  CT.ReadTotalTimeoutMultiplier = 0;


  if (pDevice->fPartialResponse)
    CT.ReadTotalTimeoutConstant = TO_PARTIALRESPONSE;

  else if (pDevice->eCmdType == CT_LISTEN)
    CT.ReadTotalTimeoutConstant = 0;                 //Never timeout for LISTEN

  else if (pDevice->cbTotal == 0)                        //Implies no Echo
    CT.ReadTotalTimeoutConstant = TO_FIRSTCHARNOECHO;    //Probably not a modem

  else
    CT.ReadTotalTimeoutConstant = TO_FIRSTCHARAFTERECHO; //Probably a modem


  if ( ! SetCommTimeouts(hIOPort, &CT))
    return(FALSE);

  pszResponse = pDevice->szResponse;
  pszResponse += pDevice->cbTotal;

  return(ReadFile(hIOPort,
                 pszResponse,
                 1,
                 &pDevice->cbRead,
                 (LPOVERLAPPED)&pDevice->Overlapped));
}



//*  ReceiveString  ----------------------------------------------------------
//
// Function: This function reads the string received from the device in
//           response to the last command.  The first byte of this string
//           has already been received by WaitForFirstChar().
//
//           ReadFile is asynchronous (because the port was opened in
//           overlapped mode), and times out after a total time of
//           TO_RCV_CONSTANT, or if the time between characters exceeds
//           TO_RCV_INTERVAL.
//
// Returns: Error return codes from ReadFile(), or GetLastError().
//
//*

BOOL
ReceiveString(DEVICE_CB *pDevice, HANDLE hIOPort)
{
  TCHAR         *pszResponse;
  COMMTIMEOUTS  CT;


  CT.ReadIntervalTimeout = TO_RCV_INTERVAL;
  CT.ReadTotalTimeoutMultiplier = 0;
  CT.ReadTotalTimeoutConstant = TO_RCV_CONSTANT;

  if ( ! SetCommTimeouts(hIOPort, &CT))
    return(FALSE);


  pszResponse = pDevice->szResponse;
  pszResponse += pDevice->cbTotal;

  return(ReadFile(hIOPort,
                  pszResponse,
                  sizeof(pDevice->szResponse) - pDevice->cbTotal,
                  &pDevice->cbRead,
                  (LPOVERLAPPED)&pDevice->Overlapped));
}



//*  PutInMessage  -----------------------------------------------------------
//
// Function: This function finds the message macro in the Macro Translations
//           table, and copies the second parameter, a string, into the
//           message macro's value field.
//
// Returns: SUCCESS
//          ERROR_MESSAGE_MACRO_NOT_FOUND
//          Return codes from UpdateparmString
//*

DWORD
PutInMessage(DEVICE_CB *pDevice, LPTSTR lpszStr, DWORD dwStrLen)
{
  WORD      i;
  MACROXLATIONTABLE   *pMacros = pDevice->pMacros;


  for (i=0; i<pMacros->MXT_NumOfEntries; i++)

    if (_stricmp(MXS_MESSAGE_KEY, pMacros->MXT_Entry[i].E_MacroName) == 0)
      break;

  if (i >= pMacros->MXT_NumOfEntries)
    return(ERROR_MESSAGE_MACRO_NOT_FOUND);

  return(UpdateParamString(pMacros->MXT_Entry[i].E_Param,
                           lpszStr,
                           dwStrLen));
}



//*  PortSetStringInfo  -----------------------------------------------------
//
// Function: Formats a RASMAN_PORTINFO struct for string data and calls
//           PortSetInfo.
//
// Returns: Return codes from PortSetInfo
//*

DWORD
PortSetStringInfo(HANDLE hIOPort, char *pszKey, char *psStr, DWORD sStrLen)
{
  BYTE             chBuffer[sizeof(RASMAN_PORTINFO) + RAS_MAXLINEBUFLEN];
  RASMAN_PORTINFO  *pSetInfo;


  pSetInfo = (RASMAN_PORTINFO *)chBuffer;
  pSetInfo->PI_NumOfParams = 1;

  strcpy(pSetInfo->PI_Params[0].P_Key, pszKey);
  pSetInfo->PI_Params[0].P_Type = String;
  pSetInfo->PI_Params[0].P_Attributes = 0;
  pSetInfo->PI_Params[0].P_Value.String.Data =
                                   (PCHAR)pSetInfo + sizeof(RASMAN_PORTINFO);

  strncpy(pSetInfo->PI_Params[0].P_Value.String.Data, psStr, sStrLen);
  pSetInfo->PI_Params[0].P_Value.String.Length = sStrLen;

  PortSetInfo(hIOPort, pSetInfo) ;

  return(SUCCESS);
}



//*  ResetBPS  --------------------------------------------------------------
//
// Function: This function calls the serial dll API, PortSetInfo, and
//           1. sets the Error Control Flag in the Serial PCB,
//           2. sets the Hardware Flow Conrol Flag,
//           3. sets the Carrier BPS rate in the Serial PCB,
//           4. if the Connect BPS macro is non-null the Port BPS is
//              is set to the macro value, otherwise it is unchanged.
//
//           See the truth table in the CheckBpsMacros() function notes.
//
// Assumptions: ConnectBps and CarrierBps macros are filled in,
//              that is, RasDevCheckResponse has been called successfully.
//
// Returns: Error codes from GetLastError().
//
//*

DWORD
ResetBPS(DEVICE_CB *pDev)
{
  UINT      i;
  DWORD     dwRC;
  TCHAR     *pStrData, *pArgs[1];
  BYTE      chBuffer[sizeof(RASMAN_PORTINFO) + (MAX_LEN_STR_FROM_NUMBER + 1)];

  RAS_PARAMS         *pParam;
  RASMAN_PORTINFO    *pPortInfo;
  RASMAN_DEVICEINFO  *pInfoTable = pDev->pInfoTable;



  pPortInfo = (RASMAN_PORTINFO *)chBuffer;
  pParam    = pPortInfo->PI_Params;
  pStrData  = (PCHAR)pPortInfo + sizeof(RASMAN_PORTINFO);

  pPortInfo->PI_NumOfParams = 1;


  // Make Error Control Flag Entry

  strcpy(pParam->P_Key, SER_ERRORCONTROLON_KEY);
  pParam->P_Type = Number;
  pParam->P_Attributes = 0;
  pParam->P_Value.Number = pDev->bErrorControlOn;

  PortSetInfo(pDev->hPort, pPortInfo) ;

  // Make HwFlowControl Flag Entry

  strcpy(pParam->P_Key, SER_HDWFLOWCTRLON_KEY);
  pParam->P_Type = Number;
  pParam->P_Attributes = 0;

  i = FindTableEntry(pInfoTable, MXS_HDWFLOWCONTROL_KEY);

  if (i == INVALID_INDEX)
    return(ERROR_MACRO_NOT_FOUND);


  pParam->P_Value.Number =
                     pInfoTable->DI_Params[i].P_Attributes & ATTRIB_ENABLED;

  PortSetInfo(pDev->hPort, pPortInfo) ;

  // Make Carrier BPS Entry

  i = FindTableEntry(pInfoTable, MXS_CARRIERBPS_KEY);

  if (i == INVALID_INDEX)
    return(ERROR_MACRO_NOT_FOUND);

  dwRC = PortSetStringInfo(pDev->hPort,
                           SER_CARRIERBPS_KEY,
                           pInfoTable->DI_Params[i].P_Value.String.Data,
                           pInfoTable->DI_Params[i].P_Value.String.Length);

  if (dwRC != SUCCESS)
    return(dwRC);



  // Make Connect BPS Entry

  i = FindTableEntry(pInfoTable, MXS_CONNECTBPS_KEY);

  if (i == INVALID_INDEX)
    return(ERROR_MACRO_NOT_FOUND);

  dwRC = PortSetStringInfo(pDev->hPort,
                           SER_CONNECTBPS_KEY,
                           pInfoTable->DI_Params[i].P_Value.String.Data,
                           pInfoTable->DI_Params[i].P_Value.String.Length);

  if (dwRC == ERROR_INVALID_PARAMETER)
  {
    pArgs[0] = pDev->szPortName;
    LogError(ROUTERLOG_UNSUPPORTED_BPS, 1, pArgs, NO_ERROR);
    return(ERROR_UNSUPPORTED_BPS);
  }
  else if (dwRC != SUCCESS)
    return(dwRC);


  return(SUCCESS);
}



//*  CheckBpsMacros  ---------------------------------------------------------
//
// Function: If the connectbps macro string converts to zero (no connect BPS
//           rate was received from the device, or it was a word, eg, FAST),
//           then the value for the Port BPS saved in the DCB is copied to
//           connectbps.
//
//           If the carrierbps macro string converts to zero, then the value
//           for the carrierbps is estimated as max(2400, connectbps/4),
//           unless the connectbps <= 2400, in which case carrerbps is set to
//           the value for connectbps.
//
// Returns: SUCCESS
//          Return codes from UpdateparmString
//*

DWORD
CheckBpsMacros(DEVICE_CB *pDev)
{
  UINT               i, j;
  DWORD              dwRC, dwConnectBps, dwCarrierBps, dwCarrierBpsEstimate;
  TCHAR              szConnectBps[MAX_LEN_STR_FROM_NUMBER];
  TCHAR              szCarrierBps[MAX_LEN_STR_FROM_NUMBER];
  RASMAN_DEVICEINFO  *pInfoTable = pDev->pInfoTable;



  // Find Carrier BPS rate in InfoTable

  j = FindTableEntry(pInfoTable, MXS_CONNECTBPS_KEY);
  i = FindTableEntry(pInfoTable, MXS_CARRIERBPS_KEY);

  if (j == INVALID_INDEX || i == INVALID_INDEX)
    return(ERROR_MACRO_NOT_FOUND);


  // Get Connect Bps rate from macro

  strncpy(szConnectBps,
          pInfoTable->DI_Params[j].P_Value.String.Data,
          pInfoTable->DI_Params[j].P_Value.String.Length);

  szConnectBps[pInfoTable->DI_Params[j].P_Value.String.Length] = '\0';

  dwConnectBps = atoi(szConnectBps);


  // If Connect BPS macro value is zero copy Port BPS to Connect BPS

  if (dwConnectBps == 0)
  {
    dwRC = UpdateParamString(&(pInfoTable->DI_Params[j]),
                             pDev->szPortBps,
                             strlen(pDev->szPortBps));
    if (dwRC != SUCCESS)
      return(dwRC);

    dwConnectBps = atoi(pDev->szPortBps);
  }



  // Get Carrier Bps rate from macro

  strncpy(szCarrierBps,
          pInfoTable->DI_Params[i].P_Value.String.Data,
          pInfoTable->DI_Params[i].P_Value.String.Length);

  szCarrierBps[pInfoTable->DI_Params[i].P_Value.String.Length] = '\0';

  dwCarrierBps = atoi(szCarrierBps);


  // If Carrier BPS macro value is zero estimate Carrier BPS

  if (dwCarrierBps == 0)
  {
    if (dwConnectBps <= MIN_LINK_SPEED)                             //2400 bps

      dwCarrierBpsEstimate = dwConnectBps;

    else
    {
      UINT k ;

      k = FindTableEntry(pInfoTable, MXS_HDWFLOWCONTROL_KEY);

      if (k == INVALID_INDEX)
        return(ERROR_MACRO_NOT_FOUND);


      if (pInfoTable->DI_Params[k].P_Attributes & ATTRIB_ENABLED)
        dwCarrierBpsEstimate = dwConnectBps/4 ;
      else
        dwCarrierBpsEstimate = dwConnectBps ;

      if (dwCarrierBpsEstimate < MIN_LINK_SPEED)
        dwCarrierBpsEstimate = MIN_LINK_SPEED;
    }

    _itoa(dwCarrierBpsEstimate, szCarrierBps, 10);

    dwRC = UpdateParamString(&(pInfoTable->DI_Params[i]),
                             szCarrierBps,
                             strlen(szCarrierBps));
    if (dwRC != SUCCESS)
      return(dwRC);
  }



  // Log BPS Macros

  if (gbLogDeviceDialog)
  {
    LogString(pDev,
              "Connect BPS:",
              pInfoTable->DI_Params[j].P_Value.String.Data,
              pInfoTable->DI_Params[j].P_Value.String.Length);

    LogString(pDev,
              "Carrier BPS:",
              pInfoTable->DI_Params[i].P_Value.String.Data,
              pInfoTable->DI_Params[i].P_Value.String.Length);
  }

  DebugPrintf(("ConnectBps: %s\n", pInfoTable->DI_Params[j].P_Value.String.Data));
  DebugPrintf(("CarrierBps: %s\n", pInfoTable->DI_Params[i].P_Value.String.Data));


  return(SUCCESS);
}



//*  FindTableEntry  ---------------------------------------------------------
//
// Function: Finds a key in Info Table.  This function matches the length
//           up to the lenght of the input parameter (pszKey).  If a binary
//           macro name is given without the suffix the first of the two
//           binary macros will be found.  If the full binary macro name is
//           given the exact binary macro will be found.
//
// Assumptions: The input parameter, pszKey, is
//              1. a full unary macro name, or
//              2. a "core" binary macro name, or
//              3. a full binary macro name.
//
// Returns: Index of DI_Params in Info Table.
//
//*

UINT
FindTableEntry(RASMAN_DEVICEINFO *pTable, TCHAR *pszKey)
{
  WORD  i;


  for (i=0; i<pTable->DI_NumOfParams; i++)

    if (_strnicmp(pszKey, pTable->DI_Params[i].P_Key, strlen(pszKey)) == 0)
      break;

  if (i >= pTable->DI_NumOfParams)
    return(INVALID_INDEX);

  return(i);
}



//*  MapKeyToErrorCode  ------------------------------------------------------
//
// Function: Maps the error key from the device.ini file to an error code
//           number to be returned to the UI.
//
// Returns: An error code that represents the error returned from the device.
//
//*

DWORD
MapKeyToErrorCode(TCHAR *pszKey)
{
  int         i;
  ERROR_ELEM  ErrorTable[] = {
                              MXS_ERROR_BUSY_KEY ,        ERROR_LINE_BUSY ,
                              MXS_ERROR_NO_ANSWER_KEY ,   ERROR_NO_ANSWER ,
                              MXS_ERROR_VOICE_KEY ,       ERROR_VOICE_ANSWER ,
                              MXS_ERROR_NO_CARRIER_KEY ,  ERROR_NO_CARRIER ,
                              MXS_ERROR_NO_DIALTONE_KEY , ERROR_NO_DIALTONE ,
                              MXS_ERROR_DIAGNOSTICS_KEY , ERROR_X25_DIAGNOSTIC
                             };

  for (i=0; i < sizeof(ErrorTable)/sizeof(ERROR_ELEM); i++)

    if (_stricmp(pszKey, ErrorTable[i].szKey) == 0)

      return(ErrorTable[i].dwErrorCode);

  return(ERROR_FROM_DEVICE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\dll\protos.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  6/8/92  Gurdeep Singh Pall  Created
//
//
//  Description: This file contains all prototypes used in rasman32
//
//****************************************************************************


// apis.c
//
DWORD  _RasmanInit () ;

VOID   _RasmanEngine () ;

// submit.c
//
DWORD   SubmitRequest (HANDLE, WORD, ...) ;

// common.c
//
BOOL    ValidatePortHandle (HPORT) ;

RequestBuffer*  GetRequestBuffer () ;

VOID    FreeRequestBuffer (RequestBuffer *) ;

HANDLE  OpenNamedMutexHandle (CHAR *) ;

DWORD    PutRequestInQueue (HANDLE hConnection, RequestBuffer *, DWORD) ;

VOID    CopyParams (RAS_PARAMS *, RAS_PARAMS *, DWORD) ;

VOID    ConvParamPointerToOffset (RAS_PARAMS *, DWORD) ;

VOID    ConvParamOffsetToPointer (RAS_PARAMS *, DWORD) ;

VOID    FreeNotifierHandle (HANDLE) ;

VOID    GetMutex (HANDLE, DWORD) ;

VOID    FreeMutex (HANDLE) ;

BOOL    BufferAlreadyFreed (PBYTE) ;

// request.c
//

//* dlparams.c
//
DWORD   GetUserSid(PWCHAR pszSid, USHORT cbSid);

DWORD   DwSetEapUserInfo(HANDLE hToken,
                         GUID   *pGuid,
                         PBYTE  pbUserInfo,
                         DWORD  dwInfoSize,
                         BOOL   fClear,
                         BOOL   fRouter,
                         DWORD  dwEapTypeId
                         );

DWORD   DwGetEapUserInfo(HANDLE hToken,
                         PBYTE  pbEapInfo,
                         DWORD  *pdwInfoSize,
                         GUID   *pGuid,
                         BOOL   fRouter,
                         DWORD  dwEapTypeId
                         );
                         


//* Dllinit.c
//

VOID    WaitForRasmanServiceStop () ;

//* dll.c
//
DWORD
RemoteSubmitRequest (HANDLE hConnection,
                     PBYTE pbBuffer,
                     DWORD dwSizeOfBuffer);

VOID
RasmanOutputDebug(
    CHAR * Format,
    ...
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\mxswrap\mxswrap.h ===
/***************************************************************************** 
**              Microsoft RAS Device INF Library wrapper                    **
**                Copyright (C) Microsoft Corp., 1992                       **
**                                                                          **
** File Name : mxswrap.h                                                    **
**                                                                          **
** Revision History :                                                       **
**      July 23, 1992   David Kays  Created                                 **
**                                                                          **
** Description :                                                            **
**      RAS Device INF File Library wrapper above RASFILE Library for       **
**      modem/X.25/switch DLL (RASMXS).                                     **
*****************************************************************************/

#ifndef _RASWRAP_
#define _RASWRAP_



DWORD APIENTRY  RasDevEnumDevices(PTCH, DWORD *, BYTE *, DWORD *);
DWORD APIENTRY  RasDevOpen(PTCH, PTCH, HRASFILE *) ;
void  APIENTRY  RasDevClose(HRASFILE) ;
DWORD APIENTRY  RasDevGetParams(HRASFILE, BYTE *, DWORD *) ;
DWORD APIENTRY  RasDevGetCommand(HRASFILE, PTCH,
                                 MACROXLATIONTABLE *, PTCH, DWORD *);
DWORD APIENTRY  RasDevResetCommand(HRASFILE);
DWORD APIENTRY  RasDevCheckResponse(HRASFILE, PTCH, DWORD,
                                    MACROXLATIONTABLE *, PTCH);

BOOL  APIENTRY  RasDevResponseExpected( HRASFILE hFile, DEVICETYPE eDevType );
BOOL  APIENTRY  RasDevEchoExpected( HRASFILE hFile );

CMDTYPE APIENTRY RasDevIdFirstCommand( HRASFILE hFile );
LPTSTR  APIENTRY RasDevSubStr( LPTSTR, DWORD, LPTSTR, DWORD );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\mxswrap\mxswrap.c ===
/***************************************************************************** 
**      Microsoft RAS Device INF Library wrapper                            **
**      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.    **
**                                                                          **
** File Name : msxwrap.c                                                    **
**                                                                          **
** Revision History :                                                       **
**  July 23, 1992   David Kays      Created                                 **
**  Feb  22, 1993   Perryh Hannah   Changed static routines to global to    **
**                                  ease degugging.                         **
**                                                                          **
** Description :                                                            **
**  RAS Device INF File Library wrapper above RASFILE Library for           **
**  modem/X.25/switch DLL (RASMXS).                                         **
*****************************************************************************/

#define _CTYPE_DISABLE_MACROS
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <windef.h>
#include <winnt.h>
#include "rasfile.h"
#include "rasman.h"     // RASMAN_DEVICEINFO, RAS_PARAMS struct, etc.
#include "raserror.h"   // SUCCESS & ERROR_BUFFER_TOO_SMALL
#include "rasmxs.h"     // Public rasmxs DLL error messages
#include "mxsint.h"     // Internal rasmxs DLL error messages
#include "wrapint.h"
#include "mxswrap.h"

// local 
BOOL  rasDevGroupFunc( LPTSTR );
BOOL  rasDevIsDecimalMacro ( LPTSTR );
void  rasDevGetMacroValue ( LPTSTR *, DWORD *, LPTSTR );
void  rasDevGetDecimalMacroValue ( LPTSTR *, DWORD *, LPTSTR );
BOOL  rasDevExpandMacros( LPTSTR, LPTSTR, DWORD *, BYTE,
                          MACROXLATIONTABLE *);
BOOL  rasDevLookupMacro( LPTSTR, LPTSTR *, MACROXLATIONTABLE *);
DWORD rasDevMacroInsert( MACRO *, WORD, MACROXLATIONTABLE *);
void  rasDevExtractKey ( LPTSTR , LPTSTR );
void  rasDevExtractValue ( LPTSTR , LPTSTR, DWORD, HRASFILE );
void  rasDevSortParams( LPTSTR *, DWORD );
void  rasDevCheckParams( LPTSTR *, DWORD *);
void  rasDevCheckMacros( LPTSTR *, LPTSTR *, DWORD *);
BYTE  ctox( char );
void GetMem(DWORD dSize, BYTE **ppMem);

/* 
 * RasDevEnumDevices :
 *  Returns in pBuffer an array of RASMAN_DEVICE structures which contain
 *  all the devices in the INF file (i.e. all header names).
 *
 * Arguments :
 *  lpszFileName (IN) - File path name of device file
 *  pNumEntries (OUT) - Number of devices found in the INF file
 *  pBuffer     (OUT) - Buffer to contain the RASMAN_DEVICE structures
 *  pwSize    (INOUT) - Size of pBuffer, this parameter filled with
 *                       the needed size of pBuffer if too small
 *
 * Return Value :
 *  ERROR_BUFFER_TOO_SMALL if pBuffer not big enough to hold all of the
 *  RASMAN_DEVICE structs,  SUCCESS otherwise.
 */
DWORD APIENTRY 
RasDevEnumDevices( PTCH lpszFileName, DWORD *pNumEntries,
                   BYTE *pBuffer, DWORD *pdwSize )
{
    HRASFILE       hFile;
    RASMAN_DEVICE  DeviceName;
    DWORD          dwCurSize;

    if ( (hFile = RasfileLoad(lpszFileName,RFM_ENUMSECTIONS,NULL,NULL)) == -1 )
		return ERROR_FILE_COULD_NOT_BE_OPENED;
  
    *pNumEntries = 0;
    if ( ! RasfileFindFirstLine(hFile,RFL_SECTION,RFS_FILE) ) {
		*pBuffer = '\0';
		*pdwSize = 0;
		RasfileClose(hFile);
		return SUCCESS;
    }

    // copy RASMAN_DEVICE structs
    dwCurSize = 0;
    do {
        // get the section name
		RasfileGetSectionName(hFile,(LPTSTR) &DeviceName);
        // ignore the Modem Responses section
        if ( ! _stricmp(RESPONSES_SECTION_NAME,(LPTSTR) &DeviceName) )
            continue;

  		dwCurSize += sizeof(RASMAN_DEVICE);
		// if current size exceeds the size of the buffer then just
		// continue counting the size needed
		if ( dwCurSize > *pdwSize ) 
	    	continue;

		strcpy(pBuffer,(LPTSTR) &DeviceName);
		pBuffer += sizeof(RASMAN_DEVICE);
		(*pNumEntries)++;
    } while ( RasfileFindNextLine(hFile,RFL_SECTION,RFS_FILE) );
	
    RasfileClose(hFile);
    if ( dwCurSize > *pdwSize ) {
		*pdwSize = dwCurSize;
		return ERROR_BUFFER_TOO_SMALL;
    }
    else
	*pdwSize = dwCurSize;

    return SUCCESS;
}

/* 
 * RasDevOpen : 
 *  Open an INF file for use by the device DLL.
 *
 * Arguments :
 *  lpszFileName    (IN) - File path name of device file
 *  lpszSectionName (IN) - Section of device file to be loaded (by Rasfile)
 *  hFile          (OUT) - File handle obtained from RasfileLoad()
 *
 * Return Value :
 *  ERROR_FILE_COULD_NOT_BE_OPENED if the file could not be found or opened.
 *  ERROR_DEVICENAME_NOT_FOUND if the section name was not found in the
 *    INF file.
 *  ERROR_DEVICENAME_TOO_LONG if the section name is too long.
 *  SUCCESS otherwise.
 */
DWORD APIENTRY 
RasDevOpen( PTCH lpszFileName, PTCH lpszSectionName, HRASFILE *hFile ) 
{
    HRASFILE hRasfile;

    if ( strlen(lpszSectionName) > MAX_DEVICE_NAME )
        return ERROR_DEVICENAME_TOO_LONG;

    // send RasfileLoad() the rasDevGroupFunc() to identify command lines
    // as group headers
    if ( (hRasfile = RasfileLoad(lpszFileName,RFM_READONLY,
                                 lpszSectionName,rasDevGroupFunc)) == -1 )
        return ERROR_FILE_COULD_NOT_BE_OPENED;

    // if there is no section header loaded then the device name is invalid
    if ( ! RasfileFindFirstLine(hRasfile,RFL_SECTION,RFS_FILE) ) {
        RasfileClose(hRasfile);
        return ERROR_DEVICENAME_NOT_FOUND;
    }

    // check if this section has an ALIAS 
    // current Rasfile line is the section header
    if ( RasfileFindNextKeyLine(hRasfile,"ALIAS",RFS_SECTION) ) {
        TCHAR  szSection[MAX_DEVICE_NAME + 1];
        RasfileGetKeyValueFields(hRasfile,NULL,szSection);
        RasfileClose(hRasfile);
        if ( (hRasfile = RasfileLoad(lpszFileName,RFM_READONLY,
                                     szSection,rasDevGroupFunc)) == -1 )
            return ERROR_FILE_COULD_NOT_BE_OPENED;
        if ( ! RasfileFindFirstLine(hRasfile,RFL_SECTION,RFS_FILE) ) {
            RasfileClose(hRasfile);
            return ERROR_DEVICENAME_NOT_FOUND;
        }
    }

    // set the Rasfile current line to the first keyvalue line
    RasfileFindFirstLine(hRasfile,RFL_KEYVALUE,RFS_SECTION);

    *hFile = hRasfile;
    return SUCCESS;
}

/* 
 * RasDevClose :
 *  Close an INF file used by the device DLL.
 *
 * Arguments :
 *  hFile (IN) - the Rasfile handle of the file to close
 *
 * Return Value :
 *	ERROR_INVALID_HANDLE if hFile is invalid, SUCCESS otherwise.
 */
void APIENTRY 
RasDevClose( HRASFILE hFile ) 
{
    RasfileClose(hFile); 
}

/* 
 * RasDevGetParams :
 *   Returns in pBuffer a RASMAN_DEVICEINFO structure which contains all of the
 *   keyword=value pairs between the top of the section loaded and the
 *   first command.
 *
 * Assumptions:
 *  All strings read from INF files are zero terminated.
 *
 * Arguments :
 *  hFile     (IN) - the Rasfile handle of the opened INF file
 *  pBuffer  (OUT) - the buffer to hold the RASMAN_DEVICEINFO structure
 *  pdSize (INOUT) - the size of pBuffer, this is filled in with the needed
 *                    buffer size to hold the RASMAN_DEVICEINFO struct if
 *                    pBuffer is too small
 *
 * Return Value :
 *      ERROR_BUFFER_TOO_SMALL if pBuffer is too small to contain the
 *      RASMAN_DEVICEINFO structure, SUCCESS otherwise.
 */
DWORD APIENTRY 
RasDevGetParams( HRASFILE hFile, BYTE *pBuffer, DWORD *pdSize ) 
{
    RASMAN_DEVICEINFO   *pDeviceInfo;
    DWORD   dParams, dCurrentSize, i, dValueLen;
    LPTSTR  *alpszLines, *alpszLinesSave, *lppszLine, *alpszMallocedLines;
    BOOL    bBufferTooSmall = FALSE;
    TCHAR   szString[RAS_MAXLINEBUFLEN];

    if ( ! RasfileFindFirstLine(hFile,RFL_KEYVALUE,RFS_SECTION) ) {

        if (*pdSize >= sizeof(DWORD)) {
            *((DWORD *)pBuffer) = 0;
            *pdSize = sizeof(DWORD);
            return SUCCESS;
        }
        else {
            *pdSize = sizeof(DWORD);
            return ERROR_BUFFER_TOO_SMALL;
        }
    }

    // count the number of keyvalue lines between the top of section and 
    // the first command, and the number of bytes to hold all of the lines 
    dParams = 0;
    do {
        if ( RasfileGetLineType(hFile) & RFL_GROUP )
            break;
        dParams++;
    } while ( RasfileFindNextLine(hFile,RFL_KEYVALUE,RFS_SECTION) );

    RasfileFindFirstLine(hFile,RFL_KEYVALUE,RFS_SECTION);

    // malloc enough for two times as many lines as currently exist
    lppszLine = alpszLines = malloc(2 * dParams * sizeof(LPTSTR));
    alpszMallocedLines = malloc(dParams * sizeof(LPTSTR));

    if(     (NULL == lppszLine)
        ||  (NULL == alpszMallocedLines))
    {
        DWORD retcode = GetLastError();
        
        if(NULL != lppszLine)
        {
            free(lppszLine);
        }

        if(NULL != alpszMallocedLines)
        {
            free(alpszMallocedLines);
        }
        
        return retcode;
    }

    // record all Rasfile keyvalue lines until a group header or end of 
    // section is found
    do { 
        if ( RasfileGetLineType(hFile) & RFL_GROUP )
            break;
        *lppszLine++ = (LPTSTR)RasfileGetLine(hFile);
    } while ( RasfileFindNextLine(hFile,RFL_KEYVALUE,RFS_SECTION) );

    // sort the lines by key
    rasDevSortParams( alpszLines, dParams );
    // check for duplicate keys and remove any that are found 
    rasDevCheckParams( alpszLines, &dParams );
    // insert missing _ON or _OFF macros into the list 
    rasDevCheckMacros( alpszLines, alpszMallocedLines, &dParams );
   
    // check if given buffer is large enough 
    dCurrentSize = sizeof(RASMAN_DEVICEINFO)
                                       + ((dParams - 1) * sizeof(RAS_PARAMS));
    if (    (NULL == pBuffer)
        ||  (dCurrentSize > *pdSize )) {
        *pdSize = dCurrentSize;
        lppszLine = alpszMallocedLines;
        while ( *lppszLine != NULL )
            free(*lppszLine++);
        free(alpszMallocedLines);
        free(alpszLines);
        return ERROR_BUFFER_TOO_SMALL;
    }

    // fill in pBuffer with RASMAN_DEVICEINFO struct
    pDeviceInfo = (RASMAN_DEVICEINFO *) pBuffer;
    pDeviceInfo->DI_NumOfParams = (WORD) dParams;

    for ( i = 0, alpszLinesSave = alpszLines; i < dParams; i++, alpszLines++) {
        RAS_PARAMS   *pParam;
        pParam = &(pDeviceInfo->DI_Params[i]);

        if (!bBufferTooSmall) {
            // set the Type and Attributes field
            pParam->P_Type = String;
            if ( strcspn(*alpszLines,LMS) < strcspn(*alpszLines,"=") )
                pParam->P_Attributes = 0;
            else
                pParam->P_Attributes = ATTRIB_VARIABLE;

            // get the key
            rasDevExtractKey(*alpszLines,pParam->P_Key);

            // if there are continuation lines for this keyword=value pair,
            // then set Rasfile line to the proper line
            if ( strcspn(*alpszLines,"\\") <  strlen(*alpszLines) ) {
                TCHAR   szFullKey[MAX_PARAM_KEY_SIZE];

                if ( ! pParam->P_Attributes ) {
                    strcpy(szFullKey,LMS);
                    strcat(szFullKey,pParam->P_Key);
                    strcat(szFullKey,RMS);
                }
                else
                    strcpy(szFullKey,pParam->P_Key);

                // find the last occurence of this key
                RasfileFindFirstLine(hFile,RFL_KEYVALUE,RFS_SECTION);
                while ( RasfileFindNextKeyLine(hFile,szFullKey,RFS_SECTION) )
                    ;
            }
        }

        // get the value string
        rasDevExtractValue(*alpszLines,
                           szString,
                           sizeof(szString),
                           hFile);

        dValueLen = strlen(szString);
        pParam->P_Value.String.Length = dValueLen;
        pParam->P_Value.String.Data = malloc(dValueLen + 1);
        if(NULL != pParam->P_Value.String.Data)
        {
            strcpy(pParam->P_Value.String.Data, szString);
        }
    }

    // free up all mallocs 
    lppszLine = alpszMallocedLines;
    while ( *lppszLine != NULL ) 
    free(*lppszLine++);
    free(alpszMallocedLines);
    free(alpszLinesSave);

    return SUCCESS;
}

/* 
 * RasDevGetCommand :
 *  Returns the next command line of the given type and advances
 *  the Rasfile file pointer to the first line following this command
 *  line.
 *
 * Arguments :
 *  hFile            (IN) - the Rasfile file handle for the INF file
 *  pszCmdTypeSuffix (IN) - the type of command line to search for :
 *                           GENERIC, INIT, DIAL, or LISTEN.
 *  pMacroXlations   (IN) - the Macro Translation table used to expand
 *                           all macros in the command line
 *  lpsCommand      (OUT) - buffer to hold the value string of the found
 *                            command line
 *  pdwCmdLen       (OUT) - length of output string with expanded macros
 *
 * Return Value :
 *  ERROR_END_OF_SECTION if no command lines of the given type could
 *      be found.
 *  ERROR_MACRO_NOT_DEFINED if no entry in the given Macro Translation table
 *      for a macro found in the command line could be found.
 *  SUCCESS otherwise.
 */
DWORD APIENTRY 
RasDevGetCommand( HRASFILE hFile, PTCH pszCmdTypeSuffix,
                  MACROXLATIONTABLE *pMacroXlations, PTCH lpsCommand,
                  DWORD *pdwCmdLen )
{
    TCHAR   szLineKey[MAX_PARAM_KEY_SIZE], sCommand[MAX_PARAM_KEY_SIZE];
    TCHAR   szValue[RAS_MAXLINEBUFLEN];
    TCHAR   sCommandValue[2*MAX_CMD_BUF_LEN];// WARNING : if we ever
                                             // get a command line > this
                                             // size msxwrap could bomb!

    LPTSTR lpszLine;                                             

    if ( ! (RasfileGetLineType(hFile) & RFL_GROUP) ) {
        if ( ! RasfileFindNextLine(hFile,RFL_GROUP,RFS_SECTION) )
            return ERROR_END_OF_SECTION;
    }
    else if ( RasfileGetLineMark(hFile) == EOS_COOKIE ) {
        RasfilePutLineMark(hFile,0);
        return ERROR_END_OF_SECTION;
    }

    strcpy(sCommand,"command");
    strcat(sCommand,pszCmdTypeSuffix);

    for ( ;; ) {

        lpszLine = (LPTSTR) RasfileGetLine(hFile);

        if(NULL == lpszLine)
        {
            break;
        }
        
        rasDevExtractKey(lpszLine,szLineKey);
        if ( ! _stricmp(sCommand,szLineKey) ) {
            // get the value string
            lpszLine = (LPTSTR) RasfileGetLine(hFile);
            if(!lpszLine)
                return ERROR_END_OF_SECTION;
            rasDevExtractValue((LPTSTR)lpszLine,szValue,
                               RAS_MAXLINEBUFLEN,hFile);
            // expand all macros in the value string
            if ( ! rasDevExpandMacros(szValue, sCommandValue, pdwCmdLen,
                                      EXPAND_ALL, pMacroXlations) )
                return ERROR_MACRO_NOT_DEFINED;
            if ( *pdwCmdLen > MAX_CMD_BUF_LEN )
                return ERROR_CMD_TOO_LONG;
            else
                memcpy(lpsCommand, sCommandValue, *pdwCmdLen);
            break;
        }
        if ( ! RasfileFindNextLine(hFile,RFL_GROUP,RFS_SECTION) )
            return ERROR_END_OF_SECTION;
    } 

    // advance to the first response following the command or 
    // to the next command line; if no such line exists mark the 
    // current line as the end of the section 
    if ( ! RasfileFindNextLine(hFile,RFL_ANYACTIVE,RFS_SECTION) )
        RasfilePutLineMark(hFile,EOS_COOKIE);

    return SUCCESS;
}

/* 
 * RasDevResetCommand :
 *  Moves the Rasfile file pointer to the first command of any type
 *  in the loaded section.
 *
 * Arguments :
 *  hFile (IN) - the Rasfile handle to the loaded file
 *
 * Return Value :
 *  ERROR_NO_COMMAND_FOUND if no command line could be found,
 *  SUCCESS otherwise.
 */
DWORD APIENTRY 
RasDevResetCommand( HRASFILE hFile ) 
{
    if ( ! RasfileFindFirstLine(hFile,RFL_GROUP,RFS_SECTION) ) 
        return ERROR_NO_COMMAND_FOUND;
    else
        return SUCCESS;
}

/* 
 * RasDevCheckResponse : 
 *  Returns the keyword found in the line whose value string matches
 *  the string in lpszReceived.  Any macros other than fixed macros
 *  which are found in the received string have their values copied
 *  into the Macro Translation table.
 *  All lines in a Command-Response Set are checked.
 *
 * Arguments :
 *  hFile (IN) - the Rasfile handle to the loaded file
 *  lpszReceived      (IN) - the string received from the modem or X25 net
 *  dReceivedLength   (IN) - length of the received string
 *  pMacroXlations (INOUT) - the Macro Translation table
 *  lpszResponse     (OUT) - buffer to copy the found keyword into
 *
 * Return Value :
 *  ERROR_PARTIAL_RESPONSE if a line is matched up to the APPEND_MACRO.
 *  ERROR_MACRO_NOT_DEFINED if a value for "carrierbaud", "connectbaud",
 *      or "diagnotics" is found in the received string, but could
 *      not be found in the given Macro Translation table.
 *  ERROR_UNRECOGNIZED_RESPONSE if no matching reponse could be
 *      found.
 *  ERROR_NO_REPSONSES if when called, the Rasfile current line is a
 *      command, section header, or is invalid.
 *  SUCCESS otherwise.
 */
DWORD APIENTRY 
RasDevCheckResponse( HRASFILE hFile, PTCH lpsReceived, DWORD dReceivedLength,
                     MACROXLATIONTABLE *pMacroXlations, PTCH lpszResponse )
{
    LPTSTR  lpszValue, lpsRec, lpszResponseLine;
    TCHAR   szValueString[RAS_MAXLINEBUFLEN], szValue[RAS_MAXLINEBUFLEN];
    MACRO   aszMacros[10];        
    DWORD   dwRC, dRecLength, dwValueLen;
    WORD    wMacros;
    BYTE    bMatch;
  
    // find the nearest previous COMMAND line (Modem section) or 
    // the section header (Modem Responses section)

    if ( RasfileGetLineMark(hFile) != EOS_COOKIE ) {
        RasfileFindPrevLine(hFile,RFL_ANYHEADER,RFS_SECTION);
        // set Rasfile line to the first keyvalue line in the response set
        RasfileFindNextLine(hFile,RFL_KEYVALUE,RFS_SECTION);
    }

    // else this line is a COMMAND line and the last line of the section
    // and ERROR_NO_RESPONSES will be returned

    if ( RasfileGetLine(hFile) == NULL || 
        RasfileGetLineType(hFile) & RFL_ANYHEADER )
        return ERROR_NO_RESPONSES;
 
    for ( ;; ) {
        lpszResponseLine = (LPTSTR)RasfileGetLine(hFile);

        if(NULL == lpszResponseLine)
        {
            return ERROR_NO_RESPONSES;
        }
        
        rasDevExtractValue(lpszResponseLine,szValueString,
                           RAS_MAXLINEBUFLEN,hFile);

        // expand <cr> and <lf> macros only
        //*** Warning: this could expand line beyond array size!

        if ( ! rasDevExpandMacros(szValueString, szValue, &dwValueLen,
                                  EXPAND_FIXED_ONLY, NULL) )
            return ERROR_MACRO_NOT_DEFINED;

        lpsRec = lpsReceived;
        dRecLength = dReceivedLength;
        bMatch = 0;
        wMacros = 0;

        for ( lpszValue = szValue; *lpszValue != '\0' && dRecLength > 0; ) {

            // check for a macro
            if ( *lpszValue == LMSCH ) {

                // check for <<
                if (*(lpszValue + 1) == LMSCH) {
                    if (*lpsRec == LMSCH) {
                        lpszValue +=2;
                        lpsRec++;
                        dRecLength--;
                    }
                    else
                        break;      // fond a mismatch
                }

                // check for <append> macro and simply advance past it
                else if ( ! _strnicmp(lpszValue,APPEND_MACRO,
                               strlen(APPEND_MACRO)) )
                    lpszValue += strlen(APPEND_MACRO);

                // check for <ignore> macro
                else if ( ! _strnicmp(lpszValue,IGNORE_MACRO,
                                    strlen(IGNORE_MACRO)) ) {
                    bMatch = FULL_MATCH;
                    break;
                }

                // check for <match> macro 
                else if ( ! _strnicmp(lpszValue,MATCH_MACRO,
                                    strlen(MATCH_MACRO)) ) {
                    TCHAR   szSubString[RAS_MAXLINEBUFLEN];
                    memset(szSubString,0,RAS_MAXLINEBUFLEN);
                    // advance value string to first char in match string
                    lpszValue += strcspn(lpszValue,"\"") + 1;
                    // extract match string
                    strncpy(szSubString,lpszValue,strcspn(lpszValue,"\""));
                    if ( RasDevSubStr(lpsRec,
                                      dRecLength,
                                      szSubString,
                                      strlen(szSubString)) != NULL ) {
                        rasDevExtractKey(lpszResponseLine,lpszResponse);
                        return SUCCESS;
                    }
                    else
                        break;  // value string does not match
                }

                // check for hex macro 
                else if ( (lpszValue[1] == 'h' || lpszValue[1] == 'H') &&
                          isxdigit(lpszValue[2]) && isxdigit(lpszValue[3]) &&
                          lpszValue[4] == RMSCH ) {
                    char c;
                    c = (char) (ctox(lpszValue[2]) * 0x10 + ctox(lpszValue[3]));
                    if ( c == *lpsRec++ ) {
                        lpszValue += 5; // '<', 'h', two hex digits, and '>'
                        dRecLength--;
                        continue;
                    }
                    else  // does not match
                        break;
                }

                // check for wildcard character
                else if ( ! _strnicmp(lpszValue,WILDCARD_MACRO,
                                    strlen(WILDCARD_MACRO)) ) {
                    lpszValue += strlen(WILDCARD_MACRO);
                    lpsRec++;  // advance Receive string one character
                    dRecLength--;
                }

                else {  // get macro name and value
                    memset(aszMacros[wMacros].MacroName,0,MAX_PARAM_KEY_SIZE);

                    // copy macro name
                    strncpy(aszMacros[wMacros].MacroName, lpszValue + 1,
                            strcspn(lpszValue,RMS) - 1);

                    // advance the value string over the macro
                    lpszValue += strcspn(lpszValue,RMS) + 1 /* past RMS */;

                    // get macro value
                    if (rasDevIsDecimalMacro(aszMacros[wMacros].MacroName))
                      rasDevGetDecimalMacroValue(&lpsRec, &dRecLength,
                                          aszMacros[wMacros++].MacroValue);
                    else
                      rasDevGetMacroValue(&lpsRec, &dRecLength,
                                          aszMacros[wMacros++].MacroValue);
                }
            }

            else if ( *lpszValue == *lpsRec ) {
                if (*lpszValue == RMSCH && *(lpszValue + 1) == RMSCH)
                    lpszValue++;
                lpszValue++;
                lpsRec++;
                dRecLength--;
                continue;
            }
            else  // found a mismatch
                break;
        } // for


        // If we already have a match break out pf outer loop now

        if (bMatch != 0)
            break;

        // full match. When there is trailing line noise dRecLength will not
        // be zero, so check for full match aganist length of expected
        // response.  Also make sure expected response is not empty.

        if ( *lpszValue == '\0' && lpszValue != szValue) {
            bMatch |= FULL_MATCH;
            break;
        }
        // partial match
        else if ( dRecLength == 0 &&
                  ! _strnicmp(lpszValue,APPEND_MACRO,strlen(APPEND_MACRO)) ) {
            bMatch |= PARTIAL_MATCH;
            break;
        }

        if ( ! RasfileFindNextLine(hFile,RFL_KEYVALUE,RFS_SECTION) )
            return ERROR_UNRECOGNIZED_RESPONSE;
        if ( RasfileGetLineType(hFile) & RFL_GROUP )
            return ERROR_UNRECOGNIZED_RESPONSE;
    } // for

    // sanity check 
    if ( ! (bMatch & (FULL_MATCH | PARTIAL_MATCH)) )
        return ERROR_UNRECOGNIZED_RESPONSE;

    // only get this far if a full or partial match was made 

    // insert any macro values found in the received string 
    // into the macro translation table
    if ((dwRC = rasDevMacroInsert(aszMacros,wMacros,pMacroXlations)) != SUCCESS)
        return(dwRC);

    // finally, copy the keyword string into lpszResponse string
    rasDevExtractKey(lpszResponseLine,lpszResponse);
    return ( bMatch & FULL_MATCH ) ? SUCCESS : ERROR_PARTIAL_RESPONSE;
}

/* 
 * RasDevResponseExpected :
 *  Checks the INF for presence of reponses to the current command.
 *  If the key work "NoResponse" is found on the current line the
 *  function returns FALSE.  Otherwise modems always expect responses.
 *
 * Arguments :
 *  hFile    (IN) - Rasfile file handle for the INF file.
 *  eDevType (IN) - The type of the device. (Modem, PAD, or Switch)
 *
 * Return Value :
 *  FALSE if the current Rasfile line points to a command line or the
 *  current line starts with "NoResponse", TRUE otherwise.  Except
 *  modems always return TRUE unless "NoResponse" key word is found.
 *  (See code.)
 */
BOOL APIENTRY 
RasDevResponseExpected( HRASFILE hFile, DEVICETYPE eDevType )
{
    TCHAR  szLine[RAS_MAXLINEBUFLEN];

    szLine[0] = TEXT('\0');

    RasfileGetLineText( hFile, szLine );
    if ( _strnicmp(szLine, MXS_NORESPONSE, strlen(MXS_NORESPONSE)) == 0 )
        return( FALSE );

    if (eDevType == DT_MODEM)
        return( TRUE );

    if ( RasfileGetLineType(hFile) & RFL_ANYHEADER )
        return( FALSE );
    else
        return( TRUE );
}

/* 
 * RasDevEchoExpected :
 *  Checks the current line of the INF file for the keyword NoEcho.
 *  If found the function returns FALSE.  Otherwise, it returns TRUE.
 *
 * Arguments :
 *  hFile (IN) - Rasfile file handle for the INF file.
 *
 * Return Value :
 *  FALSE if the current line is "NoEcho", else TRUE.
 */
BOOL APIENTRY 
RasDevEchoExpected( HRASFILE hFile )
{
    TCHAR  szLine[RAS_MAXLINEBUFLEN];

    szLine[0] = TEXT('\0');

    RasfileGetLineText( hFile, szLine );
    return( ! (_strnicmp(szLine, MXS_NOECHO, strlen(MXS_NOECHO)) == 0) );
}

/* 
 * RasDevIdFistCommand :
 *  Determines the type of the first command in the section.
 *
 * Arguments :
 *  hFile   (IN)  - Rasfile file handle for the INF file.
 *
 * Assumptions :
 *  RasDevGetParams has been called previously, that is, the current
 *  line is the first command.
 *
 * Return Value :
 *  FALSE if current line is not a command, otherwise TRUE.
 */
CMDTYPE APIENTRY
RasDevIdFirstCommand( HRASFILE hFile )
{
  TCHAR  szKey[MAX_PARAM_KEY_SIZE + 1];


  // Find the first command

  if ( ! RasfileFindFirstLine(hFile,RFL_GROUP,RFS_SECTION))
    return(CT_UNKNOWN);

  if ( ! RasfileGetKeyValueFields(hFile, szKey, NULL))
    return(CT_UNKNOWN);


  // Convert Key from the line into an enum

  if (_stricmp(MXS_GENERIC_COMMAND, szKey) == 0)
    return(CT_GENERIC);

  else if (_stricmp(MXS_DIAL_COMMAND, szKey) == 0)
    return(CT_DIAL);

  else if (_stricmp(MXS_INIT_COMMAND, szKey) == 0)
    return(CT_INIT);

  else if (_stricmp(MXS_LISTEN_COMMAND, szKey) == 0)
    return(CT_LISTEN);

  else
    return(CT_UNKNOWN);
}

/*
 * RasDevSubStr :
 *  Finds a substring and returns a pointer to it.  This function works like
 *  the C runtime function strstr, but works in strings that contain zeros.
 *
 * Arguments :
 *  psStr       (IN) - the string to be searched for a substring
 *  dwStrLen    (IN) - length of the string to be searched
 *  psSubStr    (IN) - the substring to search for
 *  dwSubStrLen (IN) - length of the substring
 *
 * Return Value :
 *  A pointer to the beginning of the substring, or NULL if the substring
 *  was not found.
 */
LPTSTR APIENTRY
RasDevSubStr( LPTSTR psStr,
              DWORD  dwStrLen,
              LPTSTR psSubStr,
              DWORD  dwSubStrLen )
{
    LPTSTR ps;


    if (dwSubStrLen > dwStrLen)
        return NULL;

    for (ps = psStr; ps <= psStr + dwStrLen - dwSubStrLen; ps++)

        if (memcmp(ps, psSubStr, dwSubStrLen) == 0)
            return ps;

    return NULL;
}


/*****************************************************************************
 **     Rasfile Wrapper internal routines                                   **
 ****************************************************************************/

/*
 * rasDevGroupFunc :
 *  The PFBISGROUP function passed to RasfileLoad().
 *
 * Arguments :
 *  lpszLine (IN) - a Rasfile line
 *
 * Return Value :
 *  TRUE if the line is a command line, FALSE otherwise.
 */
BOOL rasDevGroupFunc( LPTSTR lpszLine ) 
{
    TCHAR	szKey[MAX_PARAM_KEY_SIZE], *lpszKey;

    if ( strcspn(lpszLine,"=") == strlen(lpszLine) ) 
        return FALSE;

    while ( *lpszLine == ' ' || *lpszLine == '\t' ) 
        lpszLine++;

    lpszKey = szKey;
    while ( *lpszLine != ' ' && *lpszLine != '\t' && *lpszLine != '=' ) 
        *lpszKey++ = *lpszLine++;
    *lpszKey = '\0';

    if ( ! _stricmp(szKey,"COMMAND")      || ! _stricmp(szKey,"COMMAND_INIT") ||
         ! _stricmp(szKey,"COMMAND_DIAL") || ! _stricmp(szKey,"COMMAND_LISTEN") )
        return TRUE;
    else
        return FALSE;
}

/*
 * rasDevIsDecimalMacro :
 *  Indicates whether or not a given macro must have only ascii
 *  decimal digits for its value.
 *
 * Arguments:
 *  lpszMacroName    (IN) - macro name
 *
 * Return Value:
 *  TRUE if only digits are legal in the macro value; otherwise FALSE.
 *
 * Remarks:
 *  Called by API RasDevCheckResponse().
 */
BOOL rasDevIsDecimalMacro ( LPTSTR lpszMacroName )
{
  if (_stricmp(lpszMacroName, MXS_CONNECTBPS_KEY) == 0 ||
      _stricmp(lpszMacroName, MXS_CARRIERBPS_KEY) == 0)
    return(TRUE);
  else
    return(FALSE);
}

/* 
 * rasDevGetMacroValue :
 *  Extracts a macro value from string *lppszReceived and copies it
 *  to string lpszMacro.  Also updates the string pointer of
 *  lppszValue and lppszReceived, and updates dRecLength.
 *
 * Arguments :
 *  lppszReceived (INOUT) - received string (from a modem)
 *  dRecLength    (INOUT) - remaining length of the received string
 *  lpszMacro       (OUT) - buffer to receive the macro value
 *
 * Return Value :
 *  None.
 * 
 * Remarks : 
 *  Called by API RasDevCheckResponse().
 */
void rasDevGetMacroValue ( LPTSTR *lppszReceived, DWORD *dRecLength,
                                  LPTSTR lpszMacroValue )
{
    while ( **lppszReceived != CR && **lppszReceived != '\0' ) {
        *lpszMacroValue++ = *(*lppszReceived)++;
        (*dRecLength)--;
    }
    *lpszMacroValue = '\0';     // Null terminate the Macro value string
}

/* 
 * rasDevGetDecimalMacroValue :
 *  Extracts a macro value from string *lppszReceived and copies it
 *  to string lpszMacro.  Also updates the string pointer of
 *  lppszReceived, and updates dRecLength.
 *  This functions only extracts characters which are ascii decimal
 *  digits.
 *
 * Arguments :
 *  lppszReceived (INOUT) - received string (from a modem)
 *  dRecLength    (INOUT) - remaining length of the received string
 *  lpszMacro       (OUT) - buffer to receive the macro value
 *
 * Return Value :
 *  None.
 * 
 * Remarks : 
 *  Called by API RasDevCheckResponse().
 */
void rasDevGetDecimalMacroValue ( LPTSTR *lppszReceived,
                                         DWORD *dRecLength,
                                         LPTSTR lpszMacroValue )
{
    TCHAR szBuffer[16], *pBuf = szBuffer;
    WORD  wcRightHandDigits = 0;
    BOOL  bDpFound = FALSE;
    ULONG lBps;


    while ( isdigit(**lppszReceived) || **lppszReceived == '.' ) {

        if (isdigit(**lppszReceived)) {
            *pBuf++ = *(*lppszReceived)++;
            (*dRecLength)--;
            if (bDpFound)
              wcRightHandDigits++;
        }
        else if (!bDpFound && **lppszReceived == '.') {
            (*lppszReceived)++;
            (*dRecLength)--;
            bDpFound = TRUE;
        }
        else
            break;
    }
    *pBuf = '\0';               // Null terminate the Macro value string

    lBps = atol(szBuffer);

    switch(wcRightHandDigits)
    {
      case 0: case 3:
        break;
      case 1:
        lBps *= 100;
        break;
      case 2:
        lBps *= 10;
        break;
    }

    _ltoa(lBps, lpszMacroValue, 10);
}

/* 
 * rasDevExpandMacros :
 *  Takes the string lpszLine, and copies it to lpszVal, using
 *  Macro Translation table pMacroXlations to expand macros.
 *  <cr>, <lf>, and <hxx> macros are always expanded directly.
 *  If bFlag == EXPAND_ALL << and >> are converted to < and >.
 *  (A single > which is not at the end of a macro is simply copied.
 *  An error could be raised here for such a >, but it is left to
 *  be caught later when the device chokes on the unexpected >.
 *  This has the advantage that a > where a >> should be will work.)
 *
 * Assumptions:
 *  Expanded macros may contain zeros, therefore output command string
 *  may contain zeros.
 *
 * Arguments :
 *  lpszLine       (IN) - a value string from a Rasfile keyword=value line
 *  lpsVal        (OUT) - buffer to copied to with expanded macros
 *  pdwValLen     (OUT) - length of output string with expanded macros
 *  bFlag          (IN) - EXPAND_FIXED_ONLY if only the fixed macros <cr>
 *                         and <lf> macros are to be expanded, and
 *                         EXPAND_ALL if all macros should be expanded
 *  pMacroXlations (IN) - the Macro Translation table
 *
 * Return Value :
 *  FALSE if a needed macro translation could not be found in the
 *  pMacroXlations table, TRUE otherwise.
 *
 * Remarks : 
 *  Called by APIs RasDevGetCommand() and RasDevCheckResponse().
 */
BOOL rasDevExpandMacros( LPTSTR lpszLine,
                                LPTSTR lpsVal,
                                DWORD  *pdwValLen,
                                BYTE   bFlag,
                                MACROXLATIONTABLE *pMacroXlations )
{
    TCHAR   szMacro[RAS_MAXLINEBUFLEN];
    LPTSTR  lpsValue;


    lpsValue = lpsVal;

    for ( ; *lpszLine != '\0'; ) {
        // check for RMSCH
        // if EXPAND_ALL convert double RMSCH to single RMSCH, and
        // simply copy single RMSCH.
        if ((bFlag & EXPAND_ALL) && *lpszLine == RMSCH) {
            *lpsValue++ = *lpszLine++;
            if (*lpszLine == RMSCH)
                lpszLine++;
        }
        // check for a macro or double LMSCH
        else if ( *lpszLine == LMSCH ) {
            if ((bFlag & EXPAND_ALL) && *(lpszLine + 1) == LMSCH) {
                *lpsValue++ = *lpszLine;
                lpszLine += 2;
            }
            else if ( ! _strnicmp(lpszLine,CR_MACRO,4) ) {
                *lpsValue++ = CR;
                lpszLine += 4;
            }
            else if ( ! _strnicmp(lpszLine,LF_MACRO,4) ) {
                *lpsValue++ = LF;
                lpszLine += 4;
            }
            else if ( ! _strnicmp(lpszLine,APPEND_MACRO,8) &&
                      (bFlag & EXPAND_ALL) )
                lpszLine += 8;

            // Hex macro stuff
            //
            else if ((lpszLine[1] == 'h' || lpszLine[1] == 'H') &&
                     isxdigit(lpszLine[2]) && isxdigit(lpszLine[3]) &&
                     (lpszLine[4] == RMSCH) &&
                     ( bFlag & EXPAND_ALL )) {
                char c;
                c = (char) (ctox(lpszLine[2]) * 0x10 + ctox(lpszLine[3]));
                lpszLine += 5; // '<', 'h', two hex digits, and '>'

                *lpsValue++ = c;
            }
            else if ( bFlag & EXPAND_ALL ) {
                LPTSTR  lpszStr;
                char buf[256];

                for ( lpszLine++, lpszStr = szMacro; *lpszLine != RMSCH; )
                    *lpszStr++ = *lpszLine++;
                lpszLine++;                    // advance past RMSCH
                *lpszStr = '\0';               // Null terminate szMacro string

                if ( ! rasDevLookupMacro(szMacro,&lpsValue,pMacroXlations) )
                    return FALSE;
            }
            else {
                // just copy the macro if EXPAND_ALL is not set
                while ( *lpszLine != RMSCH )
                    *lpsValue++ = *lpszLine++;
                *lpsValue++ = *lpszLine++;
            }
        }
        else
            *lpsValue++ = *lpszLine++;
    } // for

    *lpsValue = '\0';
    *pdwValLen = (DWORD) (lpsValue - lpsVal);

    return TRUE;
}

/* 
 * rasDevLookupMacro :
 *  Lookup macro lpszMacro in the given Macro Translation table, and
 *  return it's value in *lppszExpanded if found.
 *
 * Arguments :
 *  lpszMacro      (IN) - the macro whose value is sought
 *  lppszExpanded (OUT) - double pointer to increment and copy the
 *                         macro's value to
 *  pMacroXlations (IN) - the Macro Translation table
 *
 * Return Value :
 *  FALSE if the macro could not be found in the given Macro Translation
 *  table, TRUE otherwise.
 *
 * Remarks :
 *  Called by internal function rasDevExpandMacros().
 */
BOOL rasDevLookupMacro( LPTSTR lpszMacro, LPTSTR *lppszExpanded,
                               MACROXLATIONTABLE *pMacroXlations )
{
    WORD    i;
    LPTSTR  lpszMacroValue;

    for ( i = 0; i < pMacroXlations->MXT_NumOfEntries; i++ ) {
        if ( ! _stricmp(pMacroXlations->MXT_Entry[i].E_MacroName, lpszMacro) ) {
            lpszMacroValue =
                    pMacroXlations->MXT_Entry[i].E_Param->P_Value.String.Data;

            while (*lpszMacroValue != 0) {
                **lppszExpanded = *lpszMacroValue;   // copy macro char by char

                if ((*lpszMacroValue == LMSCH && *(lpszMacroValue+1) == LMSCH)
                 || (*lpszMacroValue == RMSCH && *(lpszMacroValue+1) == RMSCH))
                    lpszMacroValue++;      // skip one of double angle brackets

                lpszMacroValue++;
                (*lppszExpanded)++;
            }

            return TRUE;
        }
    }
    return FALSE;
}

/* 
 * rasDevMacroInsert :
 *  Updates the value of macro lpszMacro with new value lpszNewValue
 *  in the given Macro Translation table.
 *
 * Arguments :
 *  aszMacros         (IN) - array of macro name and value pairs
 *  wMacros           (IN) - number of elements of aszMacros array
 *  pMacroXlations (INOUT) - the Macro Translation table
 *
 * Return Value : SUCCESS
 *                ERROR_MACRO_NOT_DEFINED
 *
 * Remarks : 
 *  Called by API RasDevCheckResponse().
 */
DWORD rasDevMacroInsert( MACRO *aszMacros, WORD wMacros,
                               MACROXLATIONTABLE *pMacroXlations )
{
    int     iMacros;
    WORD    iXlations;
    DWORD   dwRC;

    for ( iMacros = (int)(wMacros - 1); iMacros >= 0; iMacros-- ) {

      for ( iXlations = 0; iXlations < pMacroXlations->MXT_NumOfEntries;
            iXlations++ ) {

        if ( ! _stricmp(pMacroXlations->MXT_Entry[iXlations].E_MacroName,
                      aszMacros[iMacros].MacroName) ) {

          dwRC = UpdateParamString(pMacroXlations->MXT_Entry[iXlations].E_Param,
                                   aszMacros[iMacros].MacroValue,
                                   strlen(aszMacros[iMacros].MacroValue));
          if (dwRC != SUCCESS)
            return dwRC;

          break;
        }
      }
      if ( iXlations == pMacroXlations->MXT_NumOfEntries )
          return ERROR_MACRO_NOT_DEFINED;
    }
    return SUCCESS;
} 


/* 
 * rasDevExtractKey :
 *	Extracts the keyvalue from a Rasfile line.
 *
 * Arguments :
 *	lpszString (IN) - Rasfile line pointer.
 *	lpszKey	  (OUT) - buffer to hold the keyvalue
 *
 * Return Value :
 * 	None.
 *
 * Remarks :
 *	Called by APIs RasDevGetParams(), RasDevGetCommand(), and
 *	RasDevCheckResponse(), and internal functions rasDevCheckParams()
 *	and rasDevCheckMacros().
 */
void rasDevExtractKey ( LPTSTR lpszString, LPTSTR lpszKey )
{
    // skip to beginning of keyword (skip '<' if present)
    while ( *lpszString == ' ' ||  *lpszString == '\t' ||
     	    *lpszString == LMSCH ) 	
		lpszString++;

    while ( *lpszString != RMSCH && *lpszString != '=' &&
	    	*lpszString != ' ' && *lpszString != '\t' ) 
		*lpszKey++ = *lpszString++;
    *lpszKey = '\0';	// Null terminate keyword string
}

/* 
 * rasDevExtractValue :
 *  Extracts the value string for a keyword=value string which
 *  begins on Rasfile line lpszString.  This function recongizes a
 *  backslash \ as a line continuation character and a double
 *  backslash \\ as a backslash character.
 *
 * Assumptions: lpszValue output buffer is ALWAYS large enough.
 *
 * Arguments :
 *  lpszString (IN) - Rasfile line where the keyword=value string begins
 *  lpszValue (OUT) - buffer to hold the value string
 *  dSize      (IN) - size of the lpszValue buffer
 *  hFile      (IN) - Rasfile handle, the current line must be the line
 *                    which lpszString points to
 *
 * Return Value :
 *  None.
 * 
 * Remarks : 
 *  Called by APIs RasDevGetParams(), RasDevGetCommand(), and
 *  RasDevCheckResponse().
 */
void rasDevExtractValue ( LPTSTR lpszString, LPTSTR lpszValue,
                                 DWORD dSize, HRASFILE hFile )
{
    LPTSTR  lpszInputStr;
    BOOL    bLineContinues;


    // skip to beginning of value string 
    for ( lpszString += strcspn(lpszString,"=") + 1;
          *lpszString == ' ' || *lpszString == '\t'; lpszString++ )
        ;

    // check for continuation lines 
    if ( strcspn(lpszString,"\\") == strlen(lpszString) )
        strcpy(lpszValue,lpszString);                      // copy value string

    else {
        memset(lpszValue,0,dSize);
        lpszInputStr = lpszString;

        for (;;) {
            // copy the current line
            bLineContinues = FALSE;

            while (*lpszInputStr != '\0') {
                if (*lpszInputStr == '\\')
                    if (*(lpszInputStr + 1) == '\\') {
                      *lpszValue++ = *lpszInputStr;       // copy one backslash
                      lpszInputStr += 2;
                    }
                    else {
                      bLineContinues = TRUE;
                      break;
                    }

                else
                    *lpszValue++ = *lpszInputStr++;
            }

            if ( ! bLineContinues)
              break;

            // get the next line
            if ( ! RasfileFindNextLine(hFile,RFL_ANYACTIVE,RFS_SECTION) )
                break;
            lpszInputStr = (LPTSTR)RasfileGetLine(hFile);
        }

    }
}

/* 
 * rasDevSortParams : 
 *  Sorts an array of Rasfile lines by keyvalue.
 *
 * Arguments :
 *  alpszLines (INOUT) - the array of line pointers
 *  dParams       (IN) - number of elements in the array
 *
 * Return Value :
 *  None.
 * 
 * Remarks : 
 *  Called by API RasDevGetParams().
 */
void rasDevSortParams( LPTSTR *alpszLines, DWORD dParams )
{
    TCHAR   szKey1[MAX_PARAM_KEY_SIZE], szKey2[MAX_PARAM_KEY_SIZE];
    LPTSTR  lpszTemp;
    DWORD   i,j;
    BOOL    changed;

    // If there is nothing to sort, don't try
    if (dParams < 2)
        return;

    /* Bubble sort - it's stable */
    for ( i = dParams - 1; i > 0; i-- ) {
        changed = FALSE;
        for ( j = 0; j < i; j++ ) {
            rasDevExtractKey(alpszLines[j],szKey1);
            rasDevExtractKey(alpszLines[j+1],szKey2);
            // sort by keyvalue
            if ( _stricmp(szKey1,szKey2) > 0 ) {
                lpszTemp = alpszLines[j];
                alpszLines[j] = alpszLines[j+1];
                alpszLines[j+1] = lpszTemp;
                changed = TRUE;
            }
        }
        if ( ! changed )
            return;
    }
}

/* 
 * rasDevCheckParams : 
 *	Removes duplicate lines from the alpszLines array of lines.
 *	Duplicates lines are those whose keyvalue is identical.  The
 *	line with the lesser index is removed.
 *
 * Arguments :
 *	alpszLines    (INOUT) - the array of line pointers
 *	pdTotalParams (INOUT) - number of array entries, this is updated
 *							if duplicates are removed
 *
 * Return Value :
 * 	None.
 *
 * Remarks :
 *	Called by API RasDevGetParams().
 */
void rasDevCheckParams( LPTSTR *alpszLines, DWORD *pdTotalParams )
{
    TCHAR 	szKey1[MAX_PARAM_KEY_SIZE], szKey2[MAX_PARAM_KEY_SIZE];
    DWORD	dParams, i;

    dParams = *pdTotalParams;
    for ( i = 1; i < *pdTotalParams ; i++ ) {
		rasDevExtractKey(alpszLines[i-1],szKey1);
		rasDevExtractKey(alpszLines[i],szKey2);
		if ( _stricmp(szKey1,szKey2) == 0 ) {
	    	memcpy(&(alpszLines[i-1]),&(alpszLines[i]),
				    (*pdTotalParams - i) * sizeof(LPTSTR *));
	    	(*pdTotalParams)--;
		}
    }
}

/* 
 * rasDevCheckMacros :
 *  Checks the array of lines for missing _ON or _OFF macros
 *  in binary macro pairs and inserts any such missing macro
 *  into the array of lines.
 *
 * Arguments :
 *  alpszLines       (INOUT) - array of lines
 *  alpszMallocedLines (OUT) - array of newly malloced lines for
 *                             this routine
 *  pdTotalParams    (INOUT) - total number of elements in alpszLines
 *                             array, this is updated if new entries are
 *                             added
 *
 * Return Value :
 *  None.
 *
 * Remarks :
 *  Called by API RasDevGetParams().
 */
void rasDevCheckMacros( LPTSTR *alpszLines, LPTSTR *alpszMallocedLines,
                               DWORD *pdTotalParams )
{
    TCHAR   szKey1[MAX_PARAM_KEY_SIZE], szKey2[MAX_PARAM_KEY_SIZE];
    DWORD   i, j;
    BYTE    bMissing;

    if(alpszLines == NULL)
    {
        return;
    }

    // insert missing _ON and _OFF macros 
    for ( i = 0; i < *pdTotalParams; i++ ) {
        if ( strcspn(alpszLines[i],LMS) > strcspn(alpszLines[i],"=") )
            continue;   // not a macro

        bMissing = NONE;
        rasDevExtractKey(alpszLines[i],szKey1);

		// if current key is an _OFF macro, check for a missing _ON 
		if ( strstr(szKey1,"_OFF") != NULL || strstr(szKey1,"_off") != NULL ) {
	    	if ( i+1 == *pdTotalParams )   // looking at last parameter
				bMissing = ON;
	    	// get next key
	    	else {
	    		rasDevExtractKey(alpszLines[i+1],szKey2);
	    		if (_strnicmp(szKey1,szKey2,strlen(szKey1) - strlen("OFF")) != 0)
		    		bMissing = ON;
	    	}
		}

		// if current key is an _ON macro, check for a missing _OFF
		if ( strstr(szKey1,"_ON") != NULL || strstr(szKey1,"_on") != NULL ) {
	    	if ( i == 0 )   // looking at first parameter
				bMissing = OFF;
	    	// get previous key 
	    	else { 
	    		rasDevExtractKey(alpszLines[i-1],szKey2);
	    		if (_strnicmp(szKey1,szKey2,strlen(szKey1) - strlen("ON")) != 0)
		    		bMissing = OFF;
	    	}
		}

		if ( bMissing != NONE ) {
	    	// shift everything over one position 
	    	for ( j = *pdTotalParams - 1; 
		  		  j >= i + ((bMissing == ON) ? 1 : 0); j-- ) 
				alpszLines[j+1] = alpszLines[j];

	    	// point j to the new empty array entry
	    	j = (bMissing == OFF) ? i : i + 1;

	    	alpszLines[j] = malloc(sizeof(TCHAR) * RAS_MAXLINEBUFLEN);

	    	if(NULL == alpszLines[j])
	    	{
	    	    *alpszMallocedLines = NULL;
	    	    return;
	    	}
	    	
	    	*alpszMallocedLines++ = alpszLines[j]; 

	    	memset(alpszLines[j],0,sizeof(TCHAR) * RAS_MAXLINEBUFLEN);
	    	strcpy(alpszLines[j],LMS);
	    	if ( bMissing == ON ) 
	         	strncat(alpszLines[j],szKey1, 
					    strlen(szKey1) - strlen(OFF_STR));
	    	else // bMissing == OFF
	        	strncat(alpszLines[j],szKey1,
		    		    strlen(szKey1) - strlen(ON_STR));
	    	strcat(alpszLines[j], bMissing == ON ? ON_STR : OFF_STR );
            strcat(alpszLines[j], RMS);
	    	strcat(alpszLines[j], "=");

	    	(*pdTotalParams)++;
	    	i++;  	// increment i to compensate for the new entry 
		}

    } // for 

    // Null terminate the Malloced Lines array 
    *alpszMallocedLines = NULL;
} 

/*
 * ctox :
 *  Convert char hex digit to decimal number.
 */
BYTE ctox( char ch )
{
    if ( isdigit(ch) ) 
        return ch - '0';
    else
        return (tolower(ch) - 'a') + 10;
}

//*  UpdateParamString  ------------------------------------------------------
//
// Function: This function copys a new string into a PARAM.P_Value
//           allocating new memory of the new string is longer than
//           the old.  The copied string is then zero terminated.
//
//           NOTE: This function frees and allocates memory and is not
//           suitable for copying into an existing buffer.  Use with
//           InfoTable and other RAS_PARAMS with 'unpacked' strings.
//
// Arguments:
//           pParam      OUT     Pointer to Param to update
//           psStr       IN      Input string
//           dwStrLen    IN      Length of input string
//
// Returns: SUCCESS
//          ERROR_ALLOCATING_MEMORY
//*

DWORD
UpdateParamString(RAS_PARAMS *pParam, TCHAR *psStr, DWORD dwStrLen)
{

  if (dwStrLen > pParam->P_Value.String.Length)
  {
    free(pParam->P_Value.String.Data);

    GetMem(dwStrLen + 1, &(pParam->P_Value.String.Data));
    if (pParam->P_Value.String.Data == NULL)
      return(ERROR_ALLOCATING_MEMORY);
  }
  pParam->P_Value.String.Length = dwStrLen;

  memcpy(pParam->P_Value.String.Data, psStr, dwStrLen);
  pParam->P_Value.String.Data[dwStrLen] = '\0';              //Zero Terminate

  return(SUCCESS);
}

//*  GetMem  -----------------------------------------------------------------
//
// Function: Allocates memory. If the memory allocation fails the output
//           parameter will be NULL.
//
// Returns: Nothing.
//
//*

void
GetMem(DWORD dSize, BYTE **ppMem)
{

  *ppMem = (BYTE *) calloc(dSize, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\mxswrap\wrapint.h ===
/***************************************************************************** 
**      Microsoft RAS Device INF Library wrapper                            **
**      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.    **
**                                                                          **
** File Name : wrapint.h                                                    **
**                                                                          **
** Revision History :                                                       **
**  July 23, 1992   David Kays  Created                                     **
**                                                                          **
** Description :                                                            **
**  RAS Device INF File Library wrapper above RASFILE Library for           **
**  modem/X.25/switch DLL (RASMXS).                                         **
*****************************************************************************/

typedef struct {
    CHAR  MacroName[MAX_PARAM_KEY_SIZE];
    CHAR  MacroValue[RAS_MAXLINEBUFLEN];
} MACRO;

#define NONE    0
#define OFF     1
#define ON      2

#define LMS     "<"
#define RMS     ">"
#define LMSCH   '<'
#define RMSCH   '>'

#define APPEND_MACRO        LMS##"append"##RMS
#define IGNORE_MACRO        LMS##"ignore"##RMS
#define MATCH_MACRO         LMS##"match"##RMS
#define WILDCARD_MACRO      LMS##"?"##RMS
#define CR_MACRO            LMS##"cr"##RMS
#define LF_MACRO            LMS##"lf"##RMS

#define ON_STR              "_on"
#define OFF_STR             "_off"

#define CR                  '\r'        // 0x0D
#define LF                  '\n'        // 0x0A

#define EXPAND_FIXED_ONLY   0x01        // <cr> and <lf> only
#define EXPAND_ALL          0x02

#define PARTIAL_MATCH       0x01
#define FULL_MATCH          0x02

#define EOS_COOKIE          1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\dlparams.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-95
//
//
//  Revision History
//
//
//  12/11/95    Anthony Discolo     created
//
//
//  Description: Constants for storing and retrieving user Lsa secret
//               dial parameters.
//
//****************************************************************************


#define RASMXS_DYNAMIC_LINK


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\certmgmt.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    rasipsec.c

Abstract:

    All code corresponding to the interface between ras and the
    IPSEC Policy Agent lives here

Author:

    Rao Salapaka (raos) 03-Mar-1998

Revision History:

--*/

#ifndef UNICODE
#define UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <tchar.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "winipsec.h"
#include "memory.h"
#include "certmgmt.h"

#define MY_ENCODING_TYPE X509_ASN_ENCODING


fIsCertStoreEmpty(
    HCERTSTORE hCertStore
    )
{
    PCCERT_CONTEXT pCertContext = NULL;
    BOOL fResult = FALSE;

    pCertContext = CertEnumCertificatesInStore(
                        hCertStore,
                        NULL);

    if(NULL == pCertContext)
    {
        fResult = TRUE;
    }
    else
    {
        CertFreeCertificateContext(pCertContext);
    }

    return fResult;
}

DWORD
ListCertsInStore(
    HCERTSTORE hCertStore,
    IPSEC_MM_AUTH_INFO ** ppAuthInfo,
    PDWORD pdwNumCertificates
    )
{
    PCCERT_CONTEXT    pPrevCertContext = NULL;
    PCCERT_CONTEXT    pCertContext = NULL;
    CERT_NAME_BLOB    NameBlob;
    DWORD dwError = 0;

    PCERT_NODE pCertificateList = NULL;
    PCERT_NODE pTemp = NULL;
    IPSEC_MM_AUTH_INFO * pAuthInfo = NULL;
    IPSEC_MM_AUTH_INFO * pCurrentAuth = NULL;
    DWORD i = 0;
    DWORD dwNumCertificates = 0;

    while(TRUE)
    {
        pCertContext = CertEnumCertificatesInStore(
                            hCertStore,
                            pPrevCertContext
                            );
        if (!pCertContext)
        {
            break;
        }

        NameBlob = pCertContext->pCertInfo->Issuer;

        if (!FindCertificateInList(pCertificateList, &NameBlob)) {


            //
            // Append this CA to the list of CAs
            //
            pCertificateList = AppendCertificateNode(
                                        pCertificateList,
                                        &NameBlob
                                        );
            dwNumCertificates++;

        } 

        pPrevCertContext = pCertContext;
    }


    pAuthInfo = (IPSEC_MM_AUTH_INFO *)AllocADsMem(
                                    sizeof(IPSEC_MM_AUTH_INFO)*dwNumCertificates
                                    );
    if (!pAuthInfo) {

        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pCertificateList;

    for (i = 0; i < dwNumCertificates; i++) {

        pCurrentAuth = pAuthInfo + i;

        dwError = CopyCertificateNode(
                        pCurrentAuth,
                        pTemp
                        );
        if (dwError) {
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pTemp = pTemp->pNext;
    }

    if (pCertificateList) {
        FreeCertificateList(pCertificateList);
    }

    *ppAuthInfo = pAuthInfo;
    *pdwNumCertificates = dwNumCertificates;

    return(dwError);


error:

    if (pCertificateList) {

        FreeCertificateList(pCertificateList);
    }

    if(NULL != pAuthInfo)
    {
        FreeADsMem(pAuthInfo);
    }

    *ppAuthInfo = NULL;
    *pdwNumCertificates = 0;

    return(dwError);

}

DWORD
CopyCertificateNode(
    PIPSEC_MM_AUTH_INFO pCurrentAuth,
    PCERT_NODE pTemp
    )
{
    LPWSTR pszSubjectName = NULL;
    LPBYTE pLocalIssuerDN;
    
    pCurrentAuth->AuthMethod = IKE_RSA_SIGNATURE;
    pLocalIssuerDN = (PBYTE)AllocADsMem(pTemp->dwIssuerDNLength);
    if (!pLocalIssuerDN) {
        return(GetLastError());
    }
    memcpy(pLocalIssuerDN,pTemp->pIssuerDN,pTemp->dwIssuerDNLength);
    pCurrentAuth->pAuthInfo = (LPBYTE)pLocalIssuerDN;

    pCurrentAuth->dwAuthInfoSize = pTemp->dwIssuerDNLength;

    return(ERROR_SUCCESS);
}

PCERT_NODE
AppendCertificateNode(
    PCERT_NODE pCertificateList,
    PCERT_NAME_BLOB pNameBlob
    )
{

    PCERT_NODE pCertificateNode = NULL;

    pCertificateNode = (PCERT_NODE)AllocADsMem(
                            sizeof(CERT_NODE)
                            );
    if (!pCertificateNode) {
        return(pCertificateList);
    }
    pCertificateNode->pIssuerDN=(PBYTE)AllocADsMem(pNameBlob->cbData);
    if (!pCertificateNode) {
        FreeADsMem(pCertificateNode);
        return(pCertificateList);
    }
    memcpy(pCertificateNode->pIssuerDN,pNameBlob->pbData,pNameBlob->cbData);

    pCertificateNode->dwIssuerDNLength=pNameBlob->cbData;

    pCertificateNode->pNext = pCertificateList;

    return(pCertificateNode);
}

void
FreeCertificateList(
    PCERT_NODE pCertificateList
    )
{
    PCERT_NODE pTemp = NULL;

    pTemp = pCertificateList;
    while (pCertificateList) {

        pTemp = pCertificateList;

        pCertificateList = pCertificateList->pNext;

        if (pTemp) {
            FreeADsMem(pTemp->pIssuerDN);
            FreeADsMem(pTemp);
        }
    }

    return;
}



DWORD
GenerateCertificatesList(
    IPSEC_MM_AUTH_INFO  ** ppAuthInfo,
    PDWORD pdwNumCertificates,
    BOOL *pfIsMyStoreEmpty
    )

{

    // HCRYPTPROV hCryptProv = 0; // Handle returned here
    HCERTSTORE RootStore = NULL;
    DWORD dwError = 0;
    HCERTSTORE MyStore = NULL;

    /*
    if (!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL,
                             CRYPT_MACHINE_KEYSET|CRYPT_VERIFYCONTEXT))
    {
        dwError = GetLastError();
        goto done;
    }
    */

    if(NULL != pfIsMyStoreEmpty)
    {
        *pfIsMyStoreEmpty = TRUE;
    }


    RootStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                          X509_ASN_ENCODING,
                          0,
                          CERT_SYSTEM_STORE_LOCAL_MACHINE,
                          L"My");
    if (RootStore == 0)
    {
        dwError = GetLastError();
        goto done;

    }

    dwError = ListCertChainsInStore(RootStore, ppAuthInfo, pdwNumCertificates);

    if(ERROR_SUCCESS != dwError)
    {
        goto done;
    }

    if(NULL != pfIsMyStoreEmpty)
    {
        *pfIsMyStoreEmpty = FALSE;

        MyStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
                            X509_ASN_ENCODING,
                            0,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE,
                            L"MY");

        if(NULL != MyStore)
        {
            *pfIsMyStoreEmpty = fIsCertStoreEmpty(MyStore);
        }
    }

done:

    if(NULL != RootStore)
    {
        CertCloseStore(RootStore, 0);
    }

    if(NULL != MyStore)
    {
        CertCloseStore(MyStore, 0);
    }

    return(dwError);
}


void
FreeCertificatesList(
    IPSEC_MM_AUTH_INFO * pAuthInfo,
    DWORD dwNumCertificates
    )
{
    DWORD i = 0;
    IPSEC_MM_AUTH_INFO * pThisAuthInfo = NULL;

    if (!pAuthInfo) {
        return;
    }

    for (i = 0; i < dwNumCertificates; i++) {

        pThisAuthInfo = pAuthInfo + i;

        if (pThisAuthInfo->pAuthInfo) {

            FreeADsMem(pThisAuthInfo->pAuthInfo);
            pThisAuthInfo->pAuthInfo = NULL;
        }

    }

    FreeADsMem(pAuthInfo);
    return;
}

BOOL
FindCertificateInList(
    PCERT_NODE pCertificateList,
    PCERT_NAME_BLOB pNameBlob
    )
{

    while (pCertificateList) {

        if (pCertificateList->dwIssuerDNLength == pNameBlob->cbData &&
            (memcmp(pCertificateList->pIssuerDN,pNameBlob->pbData,pNameBlob->cbData) == 0)) {
            return(TRUE);
        }

        pCertificateList = pCertificateList->pNext;

    }

    return(FALSE);
}



DWORD
ListCertChainsInStore(
    HCERTSTORE hCertStore,
    IPSEC_MM_AUTH_INFO ** ppAuthInfo,
    PDWORD pdwNumCertificates
    )
{

    PCCERT_CHAIN_CONTEXT pPrevChain=NULL;
    PCCERT_CHAIN_CONTEXT pCertChain = NULL;
    DWORD dwError = 0;
    CERT_CHAIN_FIND_BY_ISSUER_PARA FindPara;
    CERT_NAME_BLOB *NameArray=NULL;
    DWORD ArraySize=0;
    PCERT_SIMPLE_CHAIN pSimpChain = NULL;
    PCERT_CHAIN_ELEMENT pRoot = NULL;
    DWORD dwRootIndex = 0;
    PCERT_NODE pCertificateList = NULL;
    PCERT_NODE pTemp = NULL;
    IPSEC_MM_AUTH_INFO * pAuthInfo = NULL;
    IPSEC_MM_AUTH_INFO * pCurrentAuth = NULL;
    DWORD i = 0;
    DWORD dwNumCertificates = 0;

    memset(&FindPara, 0, sizeof(FindPara));
    FindPara.cbSize = sizeof(FindPara);
    FindPara.pszUsageIdentifier = 0;
    FindPara.dwKeySpec = 0;
    FindPara.cIssuer = ArraySize;
    FindPara.rgIssuer = NameArray;
    FindPara.pfnFindCallback = NULL;
    FindPara.pvFindArg = NULL;


    while (TRUE) {

        pCertChain=CertFindChainInStore(
                        hCertStore,
                        X509_ASN_ENCODING,
                        CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG |
                        CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG |
                        CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG |
                        CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG,
                        CERT_CHAIN_FIND_BY_ISSUER,
                        &FindPara,
                        pPrevChain
                        );

        if (!pCertChain) {

            break;
        }

        pSimpChain=*(pCertChain->rgpChain);
        dwRootIndex=pSimpChain->cElement-1;
        pRoot=pSimpChain->rgpElement[dwRootIndex];

        if (!FindCertificateInList(pCertificateList, &(pRoot->pCertContext->pCertInfo->Issuer))) {


            //
            // Append this CA to the list of CAs
            //
            pCertificateList = AppendCertificateNode(
                                        pCertificateList,
                                        &(pRoot->pCertContext->pCertInfo->Issuer)
                                        );
            dwNumCertificates++;

        }
        pPrevChain = pCertChain;

    }

    if (!dwNumCertificates) {
        dwError = ERROR_NO_MORE_ITEMS;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Allocate one more authinfo for pre-sharedkey.
    //
    pAuthInfo = (IPSEC_MM_AUTH_INFO *)AllocADsMem(
                  sizeof(IPSEC_MM_AUTH_INFO) * (1 + dwNumCertificates)
                                    );
    if (!pAuthInfo) {

        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pCertificateList;

    for (i = 0; i < dwNumCertificates; i++) {

        pCurrentAuth = pAuthInfo + i;

        dwError = CopyCertificateNode(
                        pCurrentAuth,
                        pTemp
                        );
        if (dwError) {
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pTemp = pTemp->pNext;
    }

    if (pCertificateList) {
        FreeCertificateList(pCertificateList);
    }

    *ppAuthInfo = pAuthInfo;
    *pdwNumCertificates = dwNumCertificates;

    return(dwError);


error:

    if (pCertificateList) {

        FreeCertificateList(pCertificateList);
    }

    *ppAuthInfo = NULL;
    *pdwNumCertificates = 0;

    return(dwError);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\certmgmt.h ===
typedef struct _cert_node {
    PBYTE pIssuerDN;
    DWORD dwIssuerDNLength;
    struct _cert_node * pNext;
} CERT_NODE, *PCERT_NODE;


DWORD
ListCertsInStore(
    HCERTSTORE hCertStore,
    IPSEC_MM_AUTH_INFO ** ppAuthInfo,
    PDWORD pdwNumCertificates
    );


DWORD
CopyCertificateNode(
    PIPSEC_MM_AUTH_INFO pCurrentAuth,
    PCERT_NODE pTemp
    );


PCERT_NODE
AppendCertificateNode(
    PCERT_NODE pCertificateList,
    PCERT_NAME_BLOB pNameBlob
    );

void
FreeCertificateList(
    PCERT_NODE pCertificateList
    );

DWORD
GetCertificateName(
    CERT_NAME_BLOB * pCertNameBlob,
    LPWSTR * ppszSubjectName
    );

DWORD
GenerateCertificatesList(
    IPSEC_MM_AUTH_INFO  ** ppAuthInfo,
    PDWORD pdwNumCertificates,
    BOOL *pfIsMyStoreEmpty
    );

void
FreeCertificatesList(
    IPSEC_MM_AUTH_INFO * pAuthInfo,
    DWORD dwNumCertificates
    );


BOOL
FindCertificateInList(
    PCERT_NODE pCertificateList,
    PCERT_NAME_BLOB pNameBlob
    );

DWORD
ListCertChainsInStore(
    HCERTSTORE hCertStore,
    IPSEC_MM_AUTH_INFO ** ppAuthInfo,
    PDWORD pdwNumCertificates
    );


BOOL
fIsCertStoreEmpty(
        HCERTSTORE hCertStore);

#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) { \
        goto error; \
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\mxs32\rasmxs.c ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: rasmxs.c
//
//  Revision History
//
//  Jun  5, 1992   J. Perry Hannah      Created
//
//
//  Description: This file contains all entry points for the RASMXS.DLL
//               which is the device dll for modems, pads, and switches.
//
//****************************************************************************

#include <nt.h>             //These first five headers are used by media.h
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <wanpub.h>
#include <asyncpub.h>

#include <malloc.h>

#include <rasman.h>
#include <raserror.h>
#include <serial.h>
#include <rasfile.h>
#include <media.h>
#include <mprlog.h>
#include <rtutils.h>

#include <rasmxs.h>
#include <mxsint.h>
#include <mxspriv.h>
#include "mxswrap.h"          //Inf file wrapper



//*  Global Variables  *******************************************************
//

RESPSECTION    ResponseSection ;           //Shared response section
DEVICE_CB      *pDeviceList;               //Points to DCB linked list
HANDLE         *pDeviceListMutex;          //Mutex for above list

PortSetInfo_t  PortSetInfo = NULL;         //API typedef defined in media.h
PortGetInfo_t  PortGetInfo = NULL;         //API typedef defined in media.h

BOOL           gbLogDeviceDialog = FALSE;  //Indicates logging on if TRUE
HANDLE         ghLogFile;                  //Handle of device log file
SavedSections  *gpSavedSections = NULL;   // Pointer to cached sections

#ifdef DBGCON

BOOL           gbConsole = TRUE;           //Indicates console logging on

#endif




//*  RasmxsDllEntryPoint  ****************************************************
//

//*  RasmxsDllEntryPoint()
//
// Function: Used for detecting processes attaching and detaching to the DLL.
//
//*

BOOL APIENTRY
RasmxsDllEntryPoint(HANDLE hDll, DWORD dwReason, LPVOID pReserved)
{

  DebugPrintf(("RasmxsDllEntryPoint\n"));

  switch (dwReason)
  {

    case DLL_PROCESS_ATTACH:

      // Init global variables

      pDeviceList = NULL;
      if ((pDeviceListMutex = CreateMutex (NULL,FALSE,NULL)) == NULL)
      {  
        return FALSE ;
      }

      if ((ResponseSection.Mutex = CreateMutex (NULL,FALSE,NULL)) == NULL)
      {
        CloseHandle(pDeviceListMutex);
        pDeviceListMutex = NULL;
        return FALSE ;
      }


      // Open device log file

      if (gbLogDeviceDialog = IsLoggingOn())
        InitLog();


      // Open degugging console window

#ifdef DBGCON

      if (gbConsole)
      {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        COORD coord;
        AllocConsole( );
        GetConsoleScreenBufferInfo( GetStdHandle(STD_OUTPUT_HANDLE), &csbi );
        coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
        coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
        SetConsoleScreenBufferSize( GetStdHandle(STD_OUTPUT_HANDLE), coord );

        gbConsole = FALSE;
      }

#endif
      break;


    case DLL_PROCESS_DETACH:
    {
        if(NULL != pDeviceListMutex)
        {
            CloseHandle(pDeviceListMutex);
            pDeviceListMutex = NULL;
        }

        if(NULL != ResponseSection.Mutex)
        {
            CloseHandle(ResponseSection.Mutex);
            ResponseSection.Mutex = NULL;
        }
        break;
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
      break;
  }

  return(TRUE);

  UNREFERENCED_PARAMETER(hDll);
  UNREFERENCED_PARAMETER(pReserved);
}






//*  RAS Modem/X.25/Switch APIS  *********************************************
//


//*  DeviceEnum()  -----------------------------------------------------------
//
// Function: Enumerates all devices in the device INF file for the
//           specified DevictType.
//
// Returns: Return codes from RasDevEnumDevices
//
//*

DWORD APIENTRY
DeviceEnum (char  *pszDeviceType,
            DWORD  *pcEntries,
            BYTE   *pBuffer,
            DWORD  *pdwSize)
{
  TCHAR      szFileName[MAX_PATH];


  ConsolePrintf(("DeviceEnum     DeviceType: %s\n", pszDeviceType));


  *szFileName = TEXT('\0');
  GetInfFileName(pszDeviceType, szFileName, sizeof(szFileName));
  return(RasDevEnumDevices(szFileName, pcEntries, pBuffer, pdwSize));
}



//*  DeviceGetInfo()  --------------------------------------------------------
//
// Function: Returns a summary of current information from the InfoTable
//           for the device on the port in Pcb.
//
// Returns: Return codes from GetDeviceCB, BuildOutputTable
//*

DWORD APIENTRY
DeviceGetInfo(HANDLE hIOPort,
              char   *pszDeviceType,
              char   *pszDeviceName,
              BYTE   *pInfo,
              DWORD  *pdwSize)
{
  DWORD      dRC;
  DEVICE_CB  *pDevice;


  ConsolePrintf(("DeviceGetInfo  hIOPort: 0x%08lx\n", hIOPort));

  // **** Exclusion Begin ****
  WaitForSingleObject(pDeviceListMutex, INFINITE) ;


  // Get Device Control Block for this hIOPort

  dRC = GetDeviceCB(hIOPort, pszDeviceType, pszDeviceName, &pDevice);
  if (dRC != SUCCESS) {
    // *** Exclusion End ***
    ReleaseMutex(pDeviceListMutex);
    return(dRC);
  }

  // Write summary of InfoTable in DCB to caller's buffer

  dRC = BuildOutputTable(pDevice, pInfo, pdwSize) ;


  // *** Exclusion End ***
  ReleaseMutex(pDeviceListMutex);

  return dRC ;
}



//*  DeviceSetInfo()  --------------------------------------------------------
//
// Function: Sets attributes in the InfoTable for the device on the
//           port in Pcb.
//
// Returns: Return codes from GetDeviceCB, UpdateInfoTable
//*

DWORD APIENTRY
DeviceSetInfo(HANDLE            hIOPort,
              char              *pszDeviceType,
              char              *pszDeviceName,
              RASMAN_DEVICEINFO *pInfo)
{
  DWORD      dwRC;
  DEVICE_CB  *pDevice;
  DWORD      dwMemSize = 0;
  char       szDefaultOff[RAS_MAXLINEBUFLEN];

  RASMAN_PORTINFO    *pPortInfo = NULL;



  ConsolePrintf(("DeviceSetInfo  hIOPort: 0x%08lx\n", hIOPort));

  // **** Exclusion Begin ****
  WaitForSingleObject(pDeviceListMutex, INFINITE) ;


  // Get Device Control Block for this hIOPort

  dwRC = GetDeviceCB(hIOPort, pszDeviceType, pszDeviceName, &pDevice);
  if (dwRC != SUCCESS) {
    // *** Exclusion End ***
    ReleaseMutex(pDeviceListMutex);
    return(dwRC);
  }


  // Write input data to InfoTable

  dwRC = UpdateInfoTable(pDevice, pInfo);
  if (dwRC != SUCCESS) {
    // *** Exclusion End ***
    ReleaseMutex(pDeviceListMutex);
    return(dwRC);
  }

  // Get port info data

  dwRC = PortGetInfo(hIOPort, NULL, (BYTE *)NULL, &dwMemSize);
  if (dwRC == ERROR_BUFFER_TOO_SMALL)
  {
    GetMem(dwMemSize, (BYTE **)&pPortInfo);
    if (pPortInfo == NULL) {
      // *** Exclusion End ***
      ReleaseMutex(pDeviceListMutex);
      return(ERROR_ALLOCATING_MEMORY);
    }

    dwRC = PortGetInfo(hIOPort, NULL, (BYTE *)pPortInfo, &dwMemSize);
  }

  /*
  else
  {
    if(ERROR_SUCCESS == dwRC)
    {
        dwRC = ERROR_PORT_NOT_FOUND;
    }
    return dwRC;
  }
  */



  // Save current values of DefaultOff macros as new defaults if this
  // device is immediately attached to its port.

  if (dwRC == SUCCESS  && DeviceAttachedToPort(pPortInfo, pszDeviceType, pszDeviceName))
  {
    CreateDefaultOffString(pDevice, szDefaultOff);

    dwRC = PortSetStringInfo(hIOPort,
                             SER_DEFAULTOFF_KEY,
                             szDefaultOff,
                             strlen(szDefaultOff));
  } else

      dwRC = SUCCESS ;

  free(pPortInfo);

  // *** Exclusion End ***
  ReleaseMutex(pDeviceListMutex);

  return(dwRC);
}



//*  DeviceConnect()  --------------------------------------------------------
//
// Function: Initiates the process of connecting a device.
//
// Returns: Return codes from ConnectListen
//*

DWORD APIENTRY
DeviceConnect(HANDLE hIOPort,
              char   *pszDeviceType,
              char   *pszDeviceName)
{
  DWORD      dRC;

  ConsolePrintf(("DeviceConnect  hIOPort: 0x%08lx\n", hIOPort));

  // **** Exclusion Begin ****
  WaitForSingleObject(pDeviceListMutex, INFINITE) ;

  dRC = ConnectListen(hIOPort,
                       pszDeviceType,
                       pszDeviceName,
                       CT_DIAL);

  // *** Exclusion End ***
  ReleaseMutex(pDeviceListMutex);

  return dRC ;
}



//*  DeviceListen()  ---------------------------------------------------------
//
// Function: Initiates the process of listening for a remote device
//           to connect to a local device.
//
// Returns: Return codes from ConnectListen
//*

DWORD APIENTRY
DeviceListen(HANDLE hIOPort,
             char   *pszDeviceType,
             char   *pszDeviceName)
{
  DWORD  dwRC;


  ConsolePrintf(("DeviceListen   hIOPort: 0x%08lx\n", hIOPort));

  // **** Exclusion Begin ****
  WaitForSingleObject(pDeviceListMutex, INFINITE) ;

  dwRC = ConnectListen(hIOPort,
                       pszDeviceType,
                       pszDeviceName,
                       CT_LISTEN);

  ConsolePrintf(("DeviceListen returns: %d\n", dwRC));

  // *** Exclusion End ***
  ReleaseMutex(pDeviceListMutex);

  return(dwRC);
}



//*  DeviceDone()  -----------------------------------------------------------
//
// Function: Informs the device dll that the attempt to connect or listen
//           has completed.
//
// Returns: nothing
//*

VOID APIENTRY
DeviceDone(HANDLE hIOPort)
{
  DEVICE_CB  *pDevice, *pRemainder, *pPrevDev;
  WORD       i;



  // **** Exclusion Begin ****
  WaitForSingleObject(pDeviceListMutex, INFINITE) ;

  ConsolePrintf(("DeviceDone\n"));


  for (pRemainder = pDeviceList; 1; )
  {
    // Find device control block for this port

    pDevice = FindPortInList(pRemainder, hIOPort, &pPrevDev);
    if (pDevice == NULL)
      break;                                                     //Loop Exit

    pRemainder = pDevice->pNextDeviceCB;


    // Now clean up the found DCB

    // Close INF file section(s)

    if (pDevice->hInfFile != INVALID_HRASFILE)
	CloseOpenDevSection (pDevice->hInfFile) ;

    // See notes on OpenResponseSecion, mxsutils.c
    //if (pDevice->eDeviceType == DT_MODEM)
    //  CloseResponseSection() ;

    // Drop device control block from linked list

    if (pDevice == pDeviceList)                  //DCB to drop is 1st on list
      pDeviceList = pRemainder;
    else
      pPrevDev->pNextDeviceCB = pRemainder;


    // Free all value strings in InfoTable, then free InfoTable

    if (pDevice->pInfoTable != NULL)
    {
      for (i=0; i < pDevice->pInfoTable->DI_NumOfParams; i++)
        if (pDevice->pInfoTable->DI_Params[i].P_Type == String &&
            pDevice->pInfoTable->DI_Params[i].P_Value.String.Data != NULL)
          free(pDevice->pInfoTable->DI_Params[i].P_Value.String.Data);

      free(pDevice->pInfoTable);
    }


    // Free Macro Table and DCB

    if (pDevice->pMacros != NULL)
      free(pDevice->pMacros);

    free(pDevice);
  }

  // *** Exclusion End ***
  ReleaseMutex(pDeviceListMutex);

}



//*  DeviceWork()  -----------------------------------------------------------
//
// Function: This function is called following DeviceConnect or
//           DeviceListen to further the asynchronous process of
//           connecting or listening.
//
// Returns: ERROR_DCB_NOT_FOUND
//          ERROR_STATE_MACHINES_NOT_STARTED
//          Return codes from DeviceStateMachine
//*

DWORD APIENTRY
DeviceWork(HANDLE hIOPort)
{
  DEVICE_CB  *pDevice;
  DWORD      dwRC;


  ConsolePrintf(("DeviceWork     hIOPort: 0x%08lx  hNotifier: 0x%08x\n",
                 hIOPort, hNotifier));


  // Find device control block for this port

  // **** Exclusion Begin ****
  WaitForSingleObject(pDeviceListMutex, INFINITE) ;

  pDevice = FindPortInList(pDeviceList, hIOPort, NULL);



  if (pDevice == NULL) {
    // *** Exclusion End ***
    ReleaseMutex(pDeviceListMutex);
    return(ERROR_DCB_NOT_FOUND);
  }

  // Check that DeviceStateMachine is started (not reset)

  if (pDevice->eDevNextAction == SEND) {
    // *** Exclusion End ***
    ReleaseMutex(pDeviceListMutex);
    return(ERROR_STATE_MACHINES_NOT_STARTED);
  }


  // Advance state machine


  while(1)
  {
    dwRC = DeviceStateMachine(pDevice, hIOPort);

    ConsolePrintf(("DeviceWork returns: %d\n", dwRC));

    if (dwRC == ERROR_PORT_OR_DEVICE &&
        pDevice->eDeviceType == DT_MODEM &&
        pDevice->dwRetries++ < MODEM_RETRIES )
    {

      // Initialize command types

      switch(RasDevIdFirstCommand(pDevice->hInfFile))
      {
        case CT_INIT:
          pDevice->eCmdType = CT_INIT;          //Reset eCmdType
          break;

        case CT_DIAL:
        case CT_LISTEN:
        case CT_GENERIC:
          break;                                //Use old value for eCmdType

        default:
	  // *** Exclusion End ***
	  ReleaseMutex(pDeviceListMutex);
	  return(ERROR_NO_COMMAND_FOUND);
      }


      // Reset state variables to initial values

      pDevice->eDevNextAction = SEND;
      pDevice->eRcvState = GETECHO;


      // Cancel any pending com port action and purge com buffers

      PurgeComm(hIOPort,
                PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR);

    }
    else
      break;
  }

  // *** Exclusion End ***
  ReleaseMutex(pDeviceListMutex);

  return(dwRC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\dllinit.c ===
//****************************************************************************
//
//		       Microsoft NT Remote Access Service
//
//		       Copyright 1992-93
//
//
//  Revision History
//
//
//  9/23/92	Gurdeep Singh Pall	Created
//
//
//  Description: This file contains init code called from DLL's init routine
//
//****************************************************************************


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <winsvc.h>
#include <wanpub.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <raserror.h>
#include <media.h>
#include <devioctl.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"

/*++

Routine Description

    Used to close any open ports when rasman exits

Arguments

Return Value

    FALSE to allow other handlers to run.
    
--*/
BOOL
HandlerRoutine (DWORD ctrltype)
{
    pPCB    ppcb ;
    ULONG   i ;
    BYTE    buffer [10] ;

    if (ctrltype == CTRL_SHUTDOWN_EVENT) 
    {
        //
    	// Close all the ports that are open
    	//
    	for (i = 0; i < MaxPorts; i++) 
    	{
    	    ppcb = GetPortByHandle((HPORT) UlongToPtr(i));
    	    
            if (ppcb != NULL) 
            {
        	    memset (buffer, 0xff, 4) ;
        	    
        	    if (ppcb->PCB_PortStatus == OPEN)
        	    {
            		PortCloseRequest (ppcb, buffer) ;
                }
            }
    	}

    }

    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\dlparams.c ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-95
//
//
//  Revision History
//
//
//  11/02/95    Anthony Discolo     created
//
//
//  Description: Routines for storing and retrieving user Lsa secret
//               dial parameters.
//
//****************************************************************************


#define RASMXS_DYNAMIC_LINK

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <llinfo.h>
#include <rasman.h>
#include <lm.h>
#include <lmwksta.h>
#include <wanpub.h>
#include <raserror.h>
//#include <rasarp.h>
#include <media.h>
#include <device.h>
#include <stdlib.h>
#include <string.h>
#include <rtutils.h>
#include "logtrdef.h"
#include <ntlsa.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"


#define MAX_REGISTRY_VALUE_LENGTH   ((64*1024) - 1)

#define RAS_DUMMY_PASSWORD_W          L"****************"
#define RAS_DUMMY_PASSWORD_A          "****************"

#define INVALID_PID                  (DWORD) -1

#define RAS_DEFAULT_CREDENTIALS       L"L$_RasDefaultCredentials#%d"
#define RAS_USER_CREDENTIALS          L"L$_RasUserCredentials#%d"

#define VERSION_WHISTLER                    5

//
// A RASDIALPARAMS structure created from
// parsing a string value in the registry.
// See DialParamsStringToList().
//
// The dwMask field stores which fields have
// been initialized (stored at least once).
//
typedef struct _DIALPARAMSENTRY
{
    LIST_ENTRY ListEntry;
    DWORD dwSize;
    DWORD dwUID;
    DWORD dwMask;
    WCHAR szPhoneNumber[MAX_PHONENUMBER_SIZE + 1];
    WCHAR szCallbackNumber[MAX_CALLBACKNUMBER_SIZE + 1];
    WCHAR szUserName[MAX_USERNAME_SIZE + 1];
    WCHAR szPassword[MAX_PASSWORD_SIZE + 1];
    WCHAR szDomain[MAX_DOMAIN_SIZE + 1];
    DWORD dwSubEntry;
} DIALPARAMSENTRY, *PDIALPARAMSENTRY;

typedef struct _RAS_LSA_KEY
{
    DWORD dwSize;
    WORD  wType;
    WORD  wVersion;
    GUID  guid;
    DWORD cbKey;
    BYTE  bKey[1];
} RAS_LSA_KEY, *PRAS_LSA_KEY;

typedef struct _RAS_LSA_KEYENTRY
{
    LIST_ENTRY ListEntry;
    RAS_LSA_KEY lsaKey;
} RAS_LSA_KEYENTRY, *PRAS_LSA_KEYENTRY;

DWORD
WriteDialParamsBlob(
    IN PWCHAR pszSid,
    IN BOOL   fOldStyle,
    IN PVOID  pvData,
    IN DWORD  dwcbData,
    IN DWORD  dwStore
    );
    
PVOID 
KeyListToBlob(
        LIST_ENTRY *pUserKeys,
        DWORD dwSize);
        
RAS_LSA_KEYENTRY *
BlobToKeyList(
        PVOID pvData,
        DWORD cbdata,
        GUID  *pGuid,
        DWORD dwSetMask, 
        LIST_ENTRY *pUserKeys);

//
// defines to indicate which store in lsa to get information from
// or write information to.
//
typedef enum
{
    RAS_LSA_DEFAULT_STORE,
    RAS_LSA_USERCONNECTION_STORE,
    RAS_LSA_CONNECTION_STORE,
    RAS_LSA_SERVER_STORE,
    RAS_LSA_INVALID_STORE,
} RAS_LSA_STORE;

WCHAR *g_pwszStore[] =
    {
        L"L$_RasDefaultCredentials#%d",    // RAS_LSA_DEFAULT_STORE
        L"RasDialParams!%s#%d",           // RAS_LSA_USERCONNECTION_STORE
        L"L$_RasConnectionCredentials#%d", // RAS_LSA_CONNECTION_STORE
        L"L$_RasServerCredentials#%d",     // RAS_LSA_SERVER_STORE
        NULL                               // RAS_LSA_INVALID_STORE
    };

typedef enum
{
    TYP_USER_PRESHAREDKEY,
    TYP_SERVER_PRESHAREDKEY,
    TYP_DDM_PRESHAREDKEY,
    TYP_INVALID_TYPE
} TYP_KEY;

RAS_LSA_STORE
MaskToLsaStore(DWORD dwMask)
{
    RAS_LSA_STORE eStore = RAS_LSA_INVALID_STORE;
    
    switch(dwMask)
    {
        case DLPARAMS_MASK_PRESHAREDKEY:
        case DLPARAMS_MASK_DDM_PRESHAREDKEY:
        {   
            eStore = RAS_LSA_CONNECTION_STORE;
            break;
        }

        case DLPARAMS_MASK_SERVER_PRESHAREDKEY:
        {
            eStore = RAS_LSA_SERVER_STORE;
            break;
        }

        default:
        {
            ASSERT(FALSE);
        }
    }

    return eStore;
}

VOID
FormatKey(
    IN LPWSTR lpszUserKey,
    IN PWCHAR pszSid,
    IN DWORD  dwIndex,
    IN RAS_LSA_STORE eStore
    )
{
    switch(eStore)
    {
        case RAS_LSA_DEFAULT_STORE:
        case RAS_LSA_SERVER_STORE:
        case RAS_LSA_CONNECTION_STORE:
        {
            wsprintfW(
                lpszUserKey,
                g_pwszStore[eStore],
                dwIndex);
                
            break;
        }
        
        case RAS_LSA_USERCONNECTION_STORE:
        {
            wsprintfW(
                lpszUserKey,
                g_pwszStore[eStore],
                pszSid,
                dwIndex);
                
            break;
        }
    }
}


DWORD
ReadDialParamsBlob(
    IN   PWCHAR        pszSid,
    IN   BOOL          fOldStyle,
    OUT  PVOID         *ppvData,
    OUT  LPDWORD       lpdwSize,
    IN   RAS_LSA_STORE eStore
    )
{
    NTSTATUS status;

    DWORD dwErr = 0, dwSize = 0, i = 0;

    PVOID pvData = NULL, pvNewData;

    UNICODE_STRING unicodeKey;

    PUNICODE_STRING punicodeValue = NULL;

    LPWSTR lpszUserKey = NULL;

    OBJECT_ATTRIBUTES objectAttributes;

    LSA_HANDLE hPolicy;

    //
    // Initialize return value.
    //
    *ppvData = NULL;
    *lpdwSize = 0;

    //
    // Open the LSA secret space for reading.
    //
    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               0L,
                               NULL,
                               NULL);

    status = LsaOpenPolicy(NULL,
                           &objectAttributes,
                           POLICY_READ,
                           &hPolicy);

    if (status != STATUS_SUCCESS)
    {
        return LsaNtStatusToWinError(status);
    }

    //
    // Allocate a string big enough to format
    // the user registry keys.
    //
    lpszUserKey = (LPWSTR)LocalAlloc(LPTR,
                         ((pszSid ? wcslen(pszSid) : 0) + 64)
                         * sizeof (WCHAR));
                                         
    if (lpszUserKey == NULL)
    {
        return GetLastError();
    }

    for (;;)
    {

        FormatKey(lpszUserKey, pszSid, i++, eStore);

        RtlInitUnicodeString(&unicodeKey, lpszUserKey);

        //
        // Get the value.
        //
        status = LsaRetrievePrivateData(hPolicy,
                                        &unicodeKey,
                                        &punicodeValue);

        if (status != STATUS_SUCCESS)
        {
            if (i > 1)
            {
                dwErr = 0;
            }

            else
            {
                dwErr = LsaNtStatusToWinError(status);
            }

            goto done;
        }

        if(NULL == punicodeValue)
        {
            goto done;
        }

        //
        // Concatenate the strings.
        //
        pvNewData = LocalAlloc(LPTR,
                               dwSize
                               + punicodeValue->Length);

        if (pvNewData == NULL)
        {
            dwErr = GetLastError();
            goto done;
        }

        if (pvData != NULL)
        {
            RtlCopyMemory(pvNewData, pvData, dwSize);
            ZeroMemory( pvData, dwSize );
            LocalFree(pvData);
        }

        RtlCopyMemory((PBYTE)pvNewData + dwSize,
                      punicodeValue->Buffer,
                      punicodeValue->Length);

        pvData = pvNewData;

        dwSize += punicodeValue->Length;

        LsaFreeMemory(punicodeValue);

        punicodeValue = NULL;
    }

done:
    if (dwErr && pvData != NULL)
    {
        ZeroMemory( pvData, dwSize );
        LocalFree(pvData);
        pvData = NULL;
    }

    if (punicodeValue != NULL)
    {
        LsaFreeMemory(punicodeValue);
    }

    LsaClose(hPolicy);

    LocalFree(lpszUserKey);

    *ppvData = pvData;

    *lpdwSize = dwSize;

    return dwErr;
}

VOID
FreeKeyList(LIST_ENTRY *pHead)
{
    LIST_ENTRY *pEntry;
    RAS_LSA_KEYENTRY *pKeyEntry;
    
    while(!IsListEmpty(pHead))
    {
        pEntry = RemoveHeadList(pHead);

        pKeyEntry = (RAS_LSA_KEYENTRY *) 
                    CONTAINING_RECORD(pEntry, RAS_LSA_KEYENTRY, ListEntry);

        ZeroMemory(pKeyEntry->lsaKey.bKey, pKeyEntry->lsaKey.cbKey);
        LocalFree(pKeyEntry);
    }
}

WORD
TypeFromMask(DWORD dwSetMask)
{
    WORD wType = (WORD) TYP_INVALID_TYPE;
    
    if(dwSetMask & DLPARAMS_MASK_PRESHAREDKEY)
    {
        wType = (WORD) TYP_USER_PRESHAREDKEY;
    }

    if(dwSetMask & DLPARAMS_MASK_SERVER_PRESHAREDKEY)
    {
        wType = (WORD) TYP_SERVER_PRESHAREDKEY;
    }

    if(dwSetMask & DLPARAMS_MASK_DDM_PRESHAREDKEY)
    {
        wType = (WORD) TYP_DDM_PRESHAREDKEY;
    }

    return wType;
}

RAS_LSA_KEYENTRY *
BlobToKeyList(
        PVOID pvData,
        DWORD cbdata,
        GUID  *pGuid,
        DWORD dwSetMask, 
        LIST_ENTRY *pKeysList)
{
    RAS_LSA_KEYENTRY *pKeyEntry = NULL;
    RAS_LSA_KEY *pKey = NULL;
    DWORD cbCurrent = 0;
    RAS_LSA_KEYENTRY *pFoundEntry = NULL;

    while(cbCurrent < cbdata)
    {
        pKey = (RAS_LSA_KEY *) ((PBYTE) pvData + cbCurrent);

        ASSERT(pKey->dwSize + cbCurrent <= cbdata);

        pKeyEntry = (RAS_LSA_KEYENTRY *) LocalAlloc(LPTR,
                            sizeof(RAS_LSA_KEYENTRY)
                            + pKey->cbKey);

        if(NULL == pKeyEntry)
        {
            break;
        }

        memcpy((PBYTE) &pKeyEntry->lsaKey,
               (PBYTE) pKey,
               sizeof(RAS_LSA_KEY) + pKey->cbKey);

        if(TypeFromMask(dwSetMask) == pKey->wType)
        {
            if(     (NULL == pGuid)
                ||  (pKey->wType == TYP_SERVER_PRESHAREDKEY)
                ||  (0 == memcmp(pGuid, &pKey->guid, sizeof(GUID))))
            {
                pFoundEntry = pKeyEntry;
            }
        }

        InsertTailList(pKeysList, &pKeyEntry->ListEntry);

        cbCurrent += pKey->dwSize;
    }

    return pFoundEntry;
}

PVOID
KeyListToBlob(LIST_ENTRY *pKeys, DWORD dwSize)
{
    PVOID pvData = NULL;
    RAS_LSA_KEY *pKey = NULL;
    RAS_LSA_KEYENTRY *pKeyEntry = NULL;
    LIST_ENTRY *pEntry = NULL;

    pKey = pvData = LocalAlloc(LPTR, dwSize);

    if(NULL == pvData)
    {
        goto done;
    }

    for(pEntry = pKeys->Flink;
        pEntry != pKeys;
        pEntry = pEntry->Flink)

    {
        pKeyEntry = (RAS_LSA_KEYENTRY *) CONTAINING_RECORD(
                                        pEntry, RAS_LSA_KEYENTRY, ListEntry);

        memcpy((PBYTE) pKey,
               (PBYTE) &pKeyEntry->lsaKey,
               sizeof(RAS_LSA_KEY) + pKeyEntry->lsaKey.cbKey);

        pKey = (RAS_LSA_KEY *) ((BYTE *)pKey + pKeyEntry->lsaKey.dwSize);
    }

done:
    return pvData;
}

DWORD
GetKey(
    WCHAR *pszSid,
    GUID  *pGuid,
    DWORD dwMask,
    DWORD *pcbKey,
    PBYTE  pbKey,
    BOOL   fDummy)
{
    DWORD dwErr = ERROR_SUCCESS;
    LIST_ENTRY KeyList;
    RAS_LSA_KEYENTRY *pKeyEntry = NULL;
    PVOID pvData;
    DWORD dwSize;
    DWORD cbKey;
    RAS_LSA_STORE eStore = MaskToLsaStore(dwMask);

    InitializeListHead(&KeyList);

    if(     (NULL == pcbKey)
        ||  (RAS_LSA_INVALID_STORE == eStore))
    {
        dwErr = E_INVALIDARG;
        goto done;
    }
    
    ASSERT( (dwMask == DLPARAMS_MASK_PRESHAREDKEY)
        ||  (dwMask == DLPARAMS_MASK_SERVER_PRESHAREDKEY)
        ||  (dwMask == DLPARAMS_MASK_DDM_PRESHAREDKEY));

    //
    // Read the key blob from lsa secrets
    //
    dwErr = ReadDialParamsBlob(pszSid,
                               TRUE,
                               &pvData,
                               &dwSize,
                               eStore);

    if(SUCCESS != dwErr)
    {
        goto done;
    }

    //
    // Convert the blob to list
    //
    if(NULL != pvData)
    {
        pKeyEntry = BlobToKeyList(
                            pvData,
                            dwSize,
                            pGuid,
                            dwMask,
                            &KeyList);
        ZeroMemory(pvData, dwSize);
        LocalFree(pvData);
        pvData = NULL;
    }

    if(NULL == pKeyEntry)
    {
        dwErr = E_FAIL;
        *pcbKey = 0;
        goto done;
    }

    if(pKeyEntry->lsaKey.cbKey > 0)
    {
        DWORD cbKeyInt = 
            (fDummy) 
            ? sizeof(WCHAR) * (1 + wcslen(RAS_DUMMY_PASSWORD_W))
            : pKeyEntry->lsaKey.cbKey;
        
        if(     (NULL == pbKey)
            ||  (0 == *pcbKey)
            ||  (*pcbKey < cbKeyInt))
        {
            *pcbKey = cbKeyInt;
            dwErr = ERROR_BUFFER_TOO_SMALL;
            goto done;
        }

        //
        // If we have pre-sharedkey available, just return
        // RAS_DUMMY_PASSWORD - we don't want the key to
        // leave rasman process.
        //
        
        memcpy(pbKey,
               (fDummy)
               ? (PBYTE) RAS_DUMMY_PASSWORD_W
               : pKeyEntry->lsaKey.bKey,
               cbKeyInt);

        *pcbKey = cbKeyInt;               
    }           
    else
    {
        *pcbKey = 0;
    }
    
done:

    FreeKeyList(&KeyList);

    return dwErr;
}
                
DWORD
SetKey(
    WCHAR *pszSid,
    GUID  *pGuid,
    DWORD dwSetMask,
    BOOL  fClear,
    DWORD cbKey,
    BYTE *pbKey
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwSize = 0;
    PVOID pvData = NULL;
    LIST_ENTRY KeyList;
    RAS_LSA_STORE eStore = MaskToLsaStore(dwSetMask);
    RAS_LSA_KEYENTRY *pKeyEntry = NULL;

    InitializeListHead(&KeyList);

    ASSERT(     (dwSetMask == DLPARAMS_MASK_PRESHAREDKEY)
            ||  (dwSetMask == DLPARAMS_MASK_SERVER_PRESHAREDKEY)
            ||  (dwSetMask == DLPARAMS_MASK_DDM_PRESHAREDKEY));
            
    
    if(     (RAS_LSA_INVALID_STORE == eStore)
        ||  ((NULL == pbKey) && !fClear))
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    if(     (cbKey > 0)
        &&  (0 == memcmp(pbKey, RAS_DUMMY_PASSWORD_W, 
                  min(cbKey, sizeof(WCHAR) * wcslen(RAS_DUMMY_PASSWORD_W)))))
    {
        RasmanTrace("SetKey: Ignore");
        goto done;
    }

    //
    // Read the key blob from lsa secrets
    //
    dwErr = ReadDialParamsBlob(pszSid,
                               TRUE,
                               &pvData,
                               &dwSize,
                               eStore);

    //
    // Convert the blob to list
    //
    if(NULL != pvData)
    {
        pKeyEntry = BlobToKeyList(
                            pvData,
                            dwSize,
                            pGuid,
                            dwSetMask,
                            &KeyList);
                            
        ZeroMemory(pvData, dwSize);
        LocalFree(pvData);
        pvData = NULL;
    }

    if(NULL != pKeyEntry)
    {
        //
        // There is an existing user key for this
        // type/ID. Remove it from the list and free.
        // This will be replaced with the new key.
        //

        dwSize -= pKeyEntry->lsaKey.dwSize;

        RemoveEntryList(&pKeyEntry->ListEntry);

        ZeroMemory(pKeyEntry->lsaKey.bKey, pKeyEntry->lsaKey.cbKey);
        LocalFree(pKeyEntry);
    }

    if(     !fClear
        &&  (0 != cbKey)
        &&  (NULL != pbKey))
    {        
        //
        // Allocate and insert key into list
        //
        pKeyEntry = (RAS_LSA_KEYENTRY *) LocalAlloc(LPTR,
                                sizeof(LIST_ENTRY) +
                                RASMAN_ALIGN(sizeof(RAS_LSA_KEY) + cbKey));

        if(NULL == pKeyEntry)
        {
            goto done;
        }

        pKeyEntry->lsaKey.dwSize = RASMAN_ALIGN(sizeof(RAS_LSA_KEY) + cbKey);
        dwSize += pKeyEntry->lsaKey.dwSize;
        pKeyEntry->lsaKey.wType = TypeFromMask(dwSetMask);
        pKeyEntry->lsaKey.wVersion = VERSION_WHISTLER;
        memcpy(&pKeyEntry->lsaKey.guid, pGuid, sizeof(GUID));
        pKeyEntry->lsaKey.cbKey = cbKey;

        memcpy(pKeyEntry->lsaKey.bKey, pbKey, cbKey);

        InsertTailList(&KeyList, &pKeyEntry->ListEntry);
    }    

    pvData = KeyListToBlob(
                    &KeyList,
                    dwSize);

    if(NULL != pvData)
    {
        //
        // Write back the blob
        //
        dwErr = WriteDialParamsBlob(
                        pszSid, 
                        TRUE, 
                        pvData, 
                        dwSize,
                        eStore);
    }                        
    

done:

    FreeKeyList(&KeyList);

    return dwErr;
}

BOOL
IsPasswordSavingDisabled(VOID)
{
    LONG lResult;
    HKEY hkey;
    DWORD dwType, dwfDisabled, dwSize;

    lResult = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                "System\\CurrentControlSet\\Services\\Rasman\\Parameters",
                0,
                KEY_READ,
                &hkey);

    if (lResult != ERROR_SUCCESS)
    {
        return FALSE;
    }

    dwSize = sizeof (DWORD);

    lResult = RegQueryValueEx(
                hkey,
                "DisableSavePassword",
                NULL,
                &dwType,
                (PBYTE)&dwfDisabled,
                &dwSize);

    RegCloseKey(hkey);

    if (lResult != ERROR_SUCCESS)
    {
        return FALSE;
    }

    return (dwType == REG_DWORD && dwfDisabled);
}


DWORD
WriteDialParamsBlob(
    IN PWCHAR pszSid,
    IN BOOL   fOldStyle,
    IN PVOID  pvData,
    IN DWORD  dwcbData,
    IN RAS_LSA_STORE eStore
    )
{
    NTSTATUS status;

    BOOL fSaveDisabled;

    DWORD dwErr = 0, dwcb, i = 0;

    UNICODE_STRING unicodeKey, unicodeValue;

    LPWSTR lpszUserKey;

    OBJECT_ATTRIBUTES objectAttributes;

    LSA_HANDLE hPolicy;

    //
    // Allocate a string big enough to format
    // the user registry keys.
    //
    lpszUserKey = (LPWSTR)LocalAlloc(LPTR,
                            (((pszSid) ? wcslen(pszSid) : 0) + 64)
                            * sizeof (WCHAR));

    if (lpszUserKey == NULL)
    {
        return GetLastError();
    }

    //
    // Open the LSA secret space for writing.
    //
    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               0L,
                               NULL,
                               NULL);

    status = LsaOpenPolicy(NULL,
                           &objectAttributes,
                           POLICY_WRITE,
                           &hPolicy);

    if (status != STATUS_SUCCESS)
    {
        LocalFree(lpszUserKey);
        return LsaNtStatusToWinError(status);
    }

    if(NULL != pvData)
    {
        //
        // Check to see if saving passwords has been disabled.
        //
        fSaveDisabled = IsPasswordSavingDisabled();

        if (!fSaveDisabled)
        {
            while (dwcbData)
            {
                FormatKey(lpszUserKey, pszSid, i++, eStore);
            
                RtlInitUnicodeString(&unicodeKey, lpszUserKey);

                //
                // Write some of the key.
                //
                dwcb = (dwcbData > MAX_REGISTRY_VALUE_LENGTH
                        ? MAX_REGISTRY_VALUE_LENGTH
                        : dwcbData);

                unicodeValue.Length =
                unicodeValue.MaximumLength = (USHORT)dwcb;

                unicodeValue.Buffer = pvData;

                status = LsaStorePrivateData(hPolicy,
                                             &unicodeKey,
                                             &unicodeValue);

                if (status != STATUS_SUCCESS)
                {
                    dwErr = LsaNtStatusToWinError(status);
                    goto done;
                }

                //
                // Move the pointer to the unwritten part
                // of the value.
                //
                pvData = (PBYTE)pvData + dwcb;

                dwcbData -= dwcb;
            }
        }
    }

    //
    // Delete any extra keys.
    //
    for (;;)
    {

        FormatKey(lpszUserKey, pszSid, i++, eStore);
    
        RtlInitUnicodeString(&unicodeKey, lpszUserKey);

        //
        // Delete the key.
        //
        status = LsaStorePrivateData(hPolicy,
                                     &unicodeKey,
                                     NULL);

        if (status != STATUS_SUCCESS)
        {
            break;
        }
    }

done:
    LocalFree(lpszUserKey);
    LsaClose(hPolicy);

    return dwErr;
}


PDIALPARAMSENTRY
DialParamsBlobToList(
    IN PVOID pvData,
    IN DWORD dwUID,
    OUT PLIST_ENTRY pHead
    )

/*++

Description

    Take a string read from the user's registry key
    and produce a list of DIALPARAMSENTRY structures.
    If one of the structures has the same dwUID field
    as the dwUID passed in, then this function returns
    a pointer to this structure.

    This string encodes the data for multiple
    RASDIALPARAMS structures.  The format of
    an encoded RASDIALPARAMS is as follows:

        <uid>\0<dwSize>\0<dwMask>\0<szPhoneNumber>
        \0<szCallbackNumber>\0<szUserName>\0<szPassword>
        \0<szDomain>\0<dwSubEntry>\0

Arguments

    lpszValue: a pointer to the registry value string

    dwUID: the entry to search for.  If this entry is found,
        a pointer is returned as the return value of
        this function.

    pHead: a pointer to the head of the list

Return Value

    If an entry is found with a matching dwUID field,
    then a pointer to the DIALPARAMSENTRY is returned;
    if not, NULL is returned.

--*/

{
    PWCHAR p;
    PDIALPARAMSENTRY pParams, pFoundParams;

    p = (PWCHAR)pvData;

    pFoundParams = NULL;

    for (;;)
    {
        pParams = LocalAlloc(LPTR, sizeof (DIALPARAMSENTRY));
        if (pParams == NULL)
        {
            break;
        }

        pParams->dwUID = _wtol(p);

        if (pParams->dwUID == dwUID)
        {
            pFoundParams = pParams;
        }

        while (*p) p++; p++;

        pParams->dwSize = _wtol(p);
        while (*p) p++; p++;

        pParams->dwMask = _wtol(p);
        while (*p) p++; p++;

        wcscpy(pParams->szPhoneNumber, p);
        while (*p) p++; p++;

        wcscpy(pParams->szCallbackNumber, p);
        while (*p) p++; p++;

        wcscpy(pParams->szUserName, p);
        while (*p) p++; p++;

        wcscpy(pParams->szPassword, p);
        while (*p) p++; p++;

        wcscpy(pParams->szDomain, p);
        while (*p) p++; p++;

        pParams->dwSubEntry = _wtol(p);
        while (*p) p++; p++;

        InsertTailList(pHead, &pParams->ListEntry);
        if (*p == L'\0') break;
    }

    return pFoundParams;
}


PVOID
DialParamsListToBlob(
    IN PLIST_ENTRY pHead,
    OUT LPDWORD lpcb
    )
{
    DWORD dwcb, dwSize;
    PVOID pvData;
    PWCHAR p;
    PLIST_ENTRY pEntry;
    PDIALPARAMSENTRY pParams;


    if(IsListEmpty(pHead))
    {
        *lpcb = 0;
        return NULL;
    }
    
    //
    // Estimate a buffer size large enough
    // to hold the new entry.
    //
    dwSize = *lpcb + sizeof (DIALPARAMSENTRY) + 32;

    pvData = LocalAlloc(LPTR, dwSize);

    if (pvData == NULL)
    {
        return NULL;
    }

    //
    // Enumerate the list and convert each entry
    // back to a string.
    //
    dwSize = 0;
    p = (PWCHAR)pvData;

    for (pEntry = pHead->Flink;
         pEntry != pHead;
         pEntry = pEntry->Flink)
    {
        pParams = CONTAINING_RECORD(pEntry, DIALPARAMSENTRY, ListEntry);

        _ltow(pParams->dwUID, p, 10);
        dwcb = wcslen(p) + 1;
        p += dwcb; dwSize += dwcb;

        _ltow(pParams->dwSize, p, 10);
        dwcb = wcslen(p) + 1;
        p += dwcb; dwSize += dwcb;

        _ltow(pParams->dwMask, p, 10);
        dwcb = wcslen(p) + 1;
        p += dwcb; dwSize += dwcb;

        wcscpy(p, pParams->szPhoneNumber);
        dwcb = wcslen(pParams->szPhoneNumber) + 1;
        p += dwcb; dwSize += dwcb;

        wcscpy(p, pParams->szCallbackNumber);
        dwcb = wcslen(pParams->szCallbackNumber) + 1;
        p += dwcb; dwSize += dwcb;

        wcscpy(p, pParams->szUserName);
        dwcb = wcslen(pParams->szUserName) + 1;
        p += dwcb; dwSize += dwcb;

        wcscpy(p, pParams->szPassword);
        dwcb = wcslen(pParams->szPassword) + 1;
        p += dwcb; dwSize += dwcb;

        wcscpy(p, pParams->szDomain);
        dwcb = wcslen(pParams->szDomain) + 1;
        p += dwcb; dwSize += dwcb;

        _ltow(pParams->dwSubEntry, p, 10);
        dwcb = wcslen(p) + 1;
        p += dwcb; dwSize += dwcb;
    }
    *p = L'\0';
    dwSize++;
    dwSize *= sizeof (WCHAR);
    //
    // Set the exact length here.
    //
    *lpcb = dwSize;

    return pvData;
}


VOID
FreeParamsList(
    IN PLIST_ENTRY pHead
    )
{
    PLIST_ENTRY pEntry;
    PDIALPARAMSENTRY pParams;

    while (!IsListEmpty(pHead))
    {
        pEntry = RemoveHeadList(pHead);

        pParams = CONTAINING_RECORD(pEntry, DIALPARAMSENTRY, ListEntry);

        ZeroMemory( pParams, sizeof( DIALPARAMSENTRY ) );

        LocalFree(pParams);
    }
}

DWORD
DeleteDefaultPw(DWORD dwSetMask,
                PWCHAR pszSid,
                DWORD dwUID
                )
{

    DWORD dwErr = ERROR_SUCCESS, 
          dwSize;
    PVOID pvData = NULL;
    LIST_ENTRY paramList;
    BOOL fDefault = FALSE;
    PDIALPARAMSENTRY pParams = NULL;

    ASSERT(0 != (dwSetMask & (DLPARAMS_MASK_DELETEALL 
                            | DLPARAMS_MASK_DELETE)));
    
    RasmanTrace("DeleteDefaultPw");

    //
    // if this is DLPARAMS__MASK_DELETEALL or DLPARAMS_MASK_DELETE
    // then do the same with the default store that we did with
    // the ras credentials store
    //
    dwErr = ReadDialParamsBlob(pszSid,
                               TRUE,
                               &pvData,
                               &dwSize,
                               RAS_LSA_DEFAULT_STORE);

    //
    // Parse the string into a list, and
    // search for the dwUID entry.
    //
    InitializeListHead(&paramList);

    if (pvData != NULL)
    {
        pParams = DialParamsBlobToList(pvData,
                                       dwUID,
                                       &paramList);

        //
        // We're done with pvData, so free it.
        //
        ZeroMemory( pvData, dwSize );
        LocalFree(pvData);
        pvData = NULL;
    }
    
    if(dwSetMask & DLPARAMS_MASK_DELETEALL)
    {
        LIST_ENTRY *pEntry;
        
        while(!IsListEmpty(&paramList))
        {
            pEntry = RemoveTailList(&paramList);
            pParams = CONTAINING_RECORD(pEntry, DIALPARAMSENTRY, ListEntry);
            ZeroMemory(pParams, sizeof(DIALPARAMSENTRY));
            LocalFree(pParams);
        }
    }

    else if(dwSetMask & DLPARAMS_MASK_DELETE)
    {
        if(NULL != pParams)
        {
            //
            // Remove this entry from list
            //
            RasmanTrace(
                   "SetEntryDialParams: Removing uid=%d from lsa",
                   pParams->dwUID);
                   
            RemoveEntryList(&pParams->ListEntry);
            ZeroMemory(pParams, sizeof(DIALPARAMSENTRY));
            LocalFree(pParams);
        }
        else
        {
            RasmanTrace(
                   "SetEntrydialParams: No info for uid=%d in lsa",
                   dwUID);
                   
            dwErr = ERROR_NO_CONNECTION;
            goto done;
        }
    }
        
    //
    // Convert the new list back to a string,
    // so we can store it back into the registry.
    //
    pvData = DialParamsListToBlob(&paramList, &dwSize);

    //
    // Write it back to the registry.
    //
    dwErr = WriteDialParamsBlob(
                    pszSid, 
                    TRUE, 
                    pvData, 
                    dwSize,
                    RAS_LSA_DEFAULT_STORE);
    if (dwErr)
    {
        goto done;
    }

done:

    if (pvData != NULL)
    {
        ZeroMemory( pvData, dwSize );
        LocalFree(pvData);
    }

    FreeParamsList(&paramList);

    return dwErr;
}


DWORD
SetEntryDialParams(
    IN PWCHAR pszSid,
    IN DWORD dwUID,
    IN DWORD dwSetMask,
    IN DWORD dwClearMask,
    IN PRAS_DIALPARAMS lpRasDialParams
    )
{
    DWORD dwErr, dwSize;

    BOOL fOldStyle;

    PVOID pvData = NULL;

    LIST_ENTRY paramList;

    BOOL fDefault = FALSE;

    PDIALPARAMSENTRY pParams = NULL;

    //
    // Parse the string into a list, and
    // search for the dwUID entry.
    //
    InitializeListHead(&paramList);

    //
    // Read the existing dial params string
    // from the registry.
    //
    fOldStyle =     (dwSetMask & DLPARAMS_MASK_OLDSTYLE)
               ||   (dwClearMask & DLPARAMS_MASK_OLDSTYLE);

    fDefault =   (dwSetMask & DLPARAMS_MASK_DEFAULT_CREDS)
             ||  (dwClearMask & DLPARAMS_MASK_DEFAULT_CREDS);
                 
    dwErr = ReadDialParamsBlob(pszSid,
                               fOldStyle,
                               &pvData,
                               &dwSize,
                               (fDefault) ? 
                                 RAS_LSA_DEFAULT_STORE
                               : RAS_LSA_USERCONNECTION_STORE);


    if (pvData != NULL)
    {
        pParams = DialParamsBlobToList(pvData,
                                       dwUID,
                                       &paramList);

        //
        // We're done with pvData, so free it.
        //
        ZeroMemory( pvData, dwSize );

        LocalFree(pvData);

        pvData = NULL;
    }

    if( (dwSetMask & DLPARAMS_MASK_DELETEALL)
    ||  (dwClearMask & DLPARAMS_MASK_DELETEALL))
    {
        LIST_ENTRY *pEntry;
        
        while(!IsListEmpty(&paramList))
        {
            pEntry = RemoveTailList(&paramList);
            pParams = CONTAINING_RECORD(pEntry, DIALPARAMSENTRY, ListEntry);
            LocalFree(pParams);
        }
    }

    else if(    (dwSetMask & DLPARAMS_MASK_DELETE)
            ||  (dwClearMask & DLPARAMS_MASK_DELETE))
    {
        if(NULL != pParams)
        {
            //
            // Remove this entry from list
            //
            RasmanTrace(
                   "SetEntryDialParams: Removing uid=%d from lsa",
                   pParams->dwUID);
                   
            RemoveEntryList(&pParams->ListEntry);

            LocalFree(pParams);
        }
        else
        {
            RasmanTrace(
                   "SetEntrydialParams: No info for uid=%d in lsa",
                   dwUID);
        }
    }
    else
    {

        //
        // If there is no existing information
        // for this entry, create a new one.
        //
        if (pParams == NULL)
        {
            pParams = LocalAlloc(LPTR, sizeof (DIALPARAMSENTRY));

            if (pParams == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto done;
            }

            RasmanTrace(
                   "SetEntryDialParams: Adding %d to lsa",
                   dwUID);

            InsertTailList(&paramList, &pParams->ListEntry);
        }

        //
        // Set the new uid for the entry.
        //
        pParams->dwUID = lpRasDialParams->DP_Uid;

        pParams->dwSize = sizeof (DIALPARAMSENTRY);

        if (dwSetMask & DLPARAMS_MASK_PHONENUMBER)
        {
            RtlCopyMemory(
              pParams->szPhoneNumber,
              lpRasDialParams->DP_PhoneNumber,
              sizeof (pParams->szPhoneNumber));

            pParams->dwMask |= DLPARAMS_MASK_PHONENUMBER;
        }

        if (dwClearMask & DLPARAMS_MASK_PHONENUMBER)
        {
            *pParams->szPhoneNumber = L'\0';
            pParams->dwMask &= ~DLPARAMS_MASK_PHONENUMBER;
        }

        if (dwSetMask & DLPARAMS_MASK_CALLBACKNUMBER)
        {
            RtlCopyMemory(
              pParams->szCallbackNumber,
              lpRasDialParams->DP_CallbackNumber,
              sizeof (pParams->szCallbackNumber));

            pParams->dwMask |= DLPARAMS_MASK_CALLBACKNUMBER;
        }

        if (dwClearMask & DLPARAMS_MASK_CALLBACKNUMBER)
        {
            *pParams->szCallbackNumber = L'\0';
            pParams->dwMask &= ~DLPARAMS_MASK_CALLBACKNUMBER;
        }

        if (dwSetMask & DLPARAMS_MASK_USERNAME)
        {
            RtlCopyMemory(
              pParams->szUserName,
              lpRasDialParams->DP_UserName,
              sizeof (pParams->szUserName));

            pParams->dwMask |= DLPARAMS_MASK_USERNAME;
        }

        if (dwClearMask & DLPARAMS_MASK_USERNAME)
        {
            *pParams->szUserName = L'\0';
            pParams->dwMask &= ~DLPARAMS_MASK_USERNAME;
        }

        if (dwSetMask & DLPARAMS_MASK_PASSWORD)
        {
            if(0 != wcscmp(lpRasDialParams->DP_Password,
                           RAS_DUMMY_PASSWORD_W))
            {                       
                RtlCopyMemory(
                  pParams->szPassword,
                  lpRasDialParams->DP_Password,
                  sizeof (pParams->szPassword));
            }

            pParams->dwMask |= DLPARAMS_MASK_PASSWORD;
        }

        if (dwClearMask & DLPARAMS_MASK_PASSWORD)
        {
            *pParams->szPassword = L'\0';
            pParams->dwMask &= ~DLPARAMS_MASK_PASSWORD;
        }

        if (dwSetMask & DLPARAMS_MASK_DOMAIN)
        {
            RtlCopyMemory(
              pParams->szDomain,
              lpRasDialParams->DP_Domain,
              sizeof (pParams->szDomain));

            pParams->dwMask |= DLPARAMS_MASK_DOMAIN;
        }

        if (dwClearMask & DLPARAMS_MASK_DOMAIN)
        {
            *pParams->szDomain = L'\0';
            pParams->dwMask &= ~DLPARAMS_MASK_DOMAIN;
        }

        if (dwSetMask & DLPARAMS_MASK_SUBENTRY)
        {
            pParams->dwSubEntry = lpRasDialParams->DP_SubEntry;
            pParams->dwMask |= DLPARAMS_MASK_SUBENTRY;
        }

        if (dwClearMask & DLPARAMS_MASK_SUBENTRY)
        {
            pParams->dwSubEntry = 0;
            pParams->dwMask &= ~DLPARAMS_MASK_SUBENTRY;
        }
    }

    //
    // Convert the new list back to a string,
    // so we can store it back into the registry.
    //
    pvData = DialParamsListToBlob(&paramList, &dwSize);

    RasmanTrace("SetEntryDialParams: Writing to fDefault=%d",
                fDefault);

    //
    // Write it back to the registry.
    //
    dwErr = WriteDialParamsBlob(
                    pszSid, 
                    fOldStyle, 
                    pvData, 
                    dwSize,
                    (fDefault) ? 
                    RAS_LSA_DEFAULT_STORE
                    : RAS_LSA_USERCONNECTION_STORE);
    if (dwErr)
    {
        goto done;
    }

    /*
    if(     (0 != (dwSetMask & (DLPARAMS_MASK_DELETEALL | DLPARAMS_MASK_DELETE)))
        ||  (0 != (dwClearMask & (DLPARAMS_MASK_DELETEALL | DLPARAMS_MASK_DELETE))))
    {   
        dwErr = DeleteDefaultPw(
                    dwSetMask | dwClearMask,
                    pszSid,
                    dwUID);

        if(ERROR_NO_CONNECTION == dwErr)
        {
            //
            // Ignore error if the password was never saved
            //
            dwErr = ERROR_SUCCESS;
        }
    }

    */

done:
    if (pvData != NULL)
    {
        ZeroMemory( pvData, dwSize );
        LocalFree(pvData);
    }

    FreeParamsList(&paramList);

    return dwErr;
}

DWORD
GetParamsListFromLsa(IN PWCHAR pszSid,
                     IN BOOL fOldStyle,
                     IN BOOL fDefault,
                     IN DWORD dwUID,
                     OUT LIST_ENTRY *pparamList,
                     OUT PDIALPARAMSENTRY *ppParams)
{
    DWORD dwErr = ERROR_SUCCESS;
    PVOID pvData = NULL;
    DWORD dwSize = 0;

    RasmanTrace("GetParamsListFromLsa Default=%d",
                fDefault);

    ASSERT(NULL != ppParams);
    ASSERT(NULL != pparamList);
    
    dwErr = ReadDialParamsBlob(pszSid,
                               fOldStyle,
                               &pvData,
                               &dwSize,
                               (  fDefault ?
                                  RAS_LSA_DEFAULT_STORE
                                : RAS_LSA_USERCONNECTION_STORE));

    if (ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    if (pvData != NULL)
    {
        *ppParams = DialParamsBlobToList(pvData,
                                       dwUID,
                                       pparamList);

        //
        // We're done with pvData, so free it.
        //
        ZeroMemory( pvData, dwSize );

        LocalFree(pvData);
        pvData = NULL;
    }

done:

    RasmanTrace("GetParamsListFromLsa. 0x%x", dwErr);

    return dwErr;
}

DWORD
GetEntryDialParams(
    IN PWCHAR pszSid,
    IN DWORD dwUID,
    IN LPDWORD lpdwMask,
    OUT PRAS_DIALPARAMS lpRasDialParams,
    DWORD dwPid
    )
{
    DWORD dwErr = ERROR_SUCCESS, dwSize = 0;

    BOOL fOldStyle;

    PVOID pvData = NULL;

    LIST_ENTRY paramList;

    PDIALPARAMSENTRY pParams = NULL;

    BOOL fDefault = FALSE;

    //
    // Initialize return values.
    //
    RtlZeroMemory(lpRasDialParams, sizeof (RAS_DIALPARAMS));

    if(*lpdwMask & DLPARAMS_MASK_SERVER_PRESHAREDKEY)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    if(*lpdwMask & DLPARAMS_MASK_DEFAULT_CREDS)
    {
        fDefault = TRUE;
    }

    *lpdwMask &= ~(DLPARAMS_MASK_DEFAULT_CREDS);

    //
    // Parse the string into a list, and
    // search for the dwUID entry.
    //
    InitializeListHead(&paramList);
    
    //
    // Read the existing dial params string
    // from the registry.
    //
    fOldStyle = (*lpdwMask & DLPARAMS_MASK_OLDSTYLE);

    if(!fDefault)
    {
        dwErr = GetParamsListFromLsa(pszSid,
                                     fOldStyle,
                                     FALSE,
                                     dwUID,
                                     &paramList,
                                     &pParams);
    }                                 

    if(     (ERROR_SUCCESS != dwErr)
        ||  (NULL == pParams))
    {
        FreeParamsList(&paramList);

        //
        // Now try the default store
        //
        dwErr = GetParamsListFromLsa(pszSid,
                                     fOldStyle,
                                     TRUE,
                                     dwUID,
                                     &paramList,
                                     &pParams);

        if(     (ERROR_SUCCESS != dwErr)
            ||  (NULL == pParams))
        {
            *lpdwMask = 0;
            dwErr = 0;
            goto done;
        }

        //
        // Set the mask to tell that the pwd is 
        // coming from the default store
        //
        *lpdwMask |= DLPARAMS_MASK_DEFAULT_CREDS;
    }
                                 
    
    //
    // Otherwise, copy the fields to
    // the caller's buffer.
    //
    if (    (*lpdwMask & DLPARAMS_MASK_PHONENUMBER)
        &&  (pParams->dwMask & DLPARAMS_MASK_PHONENUMBER))
    {
        RtlCopyMemory(
          lpRasDialParams->DP_PhoneNumber,
          pParams->szPhoneNumber,
          sizeof (lpRasDialParams->DP_PhoneNumber));
    }
    else
    {
        *lpdwMask &= ~DLPARAMS_MASK_PHONENUMBER;
    }

    if (    (*lpdwMask & DLPARAMS_MASK_CALLBACKNUMBER)
        &&  (pParams->dwMask & DLPARAMS_MASK_CALLBACKNUMBER))
    {
        RtlCopyMemory(
          lpRasDialParams->DP_CallbackNumber,
          pParams->szCallbackNumber,
          sizeof (lpRasDialParams->DP_CallbackNumber));
    }
    else
    {
        *lpdwMask &= ~DLPARAMS_MASK_CALLBACKNUMBER;
    }

    if (    (*lpdwMask & DLPARAMS_MASK_USERNAME)
        &&  (pParams->dwMask & DLPARAMS_MASK_USERNAME))
    {
        RtlCopyMemory(
          lpRasDialParams->DP_UserName,
          pParams->szUserName,
          sizeof (lpRasDialParams->DP_UserName));
    }
    else
    {
        *lpdwMask &= ~DLPARAMS_MASK_USERNAME;
    }

    if (    (*lpdwMask & DLPARAMS_MASK_PASSWORD)
        &&  (pParams->dwMask & DLPARAMS_MASK_PASSWORD))
    {
        if(GetCurrentProcessId() == dwPid)
        {
            RtlCopyMemory(
              lpRasDialParams->DP_Password,
              pParams->szPassword,
              sizeof (lpRasDialParams->DP_Password));
        }
        else
        {
            wcscpy(lpRasDialParams->DP_Password,
                   RAS_DUMMY_PASSWORD_W);
                
        }
    }
    else
    {
        *lpdwMask &= ~DLPARAMS_MASK_PASSWORD;
    }

    if (    (*lpdwMask & DLPARAMS_MASK_DOMAIN)
        &&  (pParams->dwMask & DLPARAMS_MASK_DOMAIN))
    {
        RtlCopyMemory(
          lpRasDialParams->DP_Domain,
          pParams->szDomain,
          sizeof (lpRasDialParams->DP_Domain));
    }
    else
    {
        *lpdwMask &= ~DLPARAMS_MASK_DOMAIN;
    }

    if (    (*lpdwMask & DLPARAMS_MASK_SUBENTRY)
        &&  (pParams->dwMask & DLPARAMS_MASK_SUBENTRY))
    {
        lpRasDialParams->DP_SubEntry = pParams->dwSubEntry;
    }
    else
    {
        *lpdwMask &= ~DLPARAMS_MASK_SUBENTRY;
    }

done:
    FreeParamsList(&paramList);
    return dwErr;
}

BOOL
IsDummyPassword(CHAR *pszPassword)
{
    ASSERT(NULL != pszPassword);

    return !strcmp(pszPassword, RAS_DUMMY_PASSWORD_A);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\common.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name: 

    common.c

Abstract:

    Common code shared by rasmans.dll
    
Author:

    Gurdeep Singh Pall (gurdeep) 16-Jun-1992

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <raserror.h>
#include <stdarg.h>
#include <media.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include "string.h"
#include <mprlog.h>
#include <rtutils.h>
#include "logtrdef.h"


/*++

Routine Description

    Duplicates a handle owned by this process for
    the Rasman Process.

Arguments

Return Value

    Duplicated handle.

--*/
HANDLE
DuplicateHandleForRasman (HANDLE sourcehandle, DWORD pid)
{
    HANDLE  duphandle ;
    HANDLE  clienthandle ;
    HANDLE  selfhandle ;

    if(pid != GetCurrentProcessId())
    {
        //
        // Get Rasman process handle
        //
        clienthandle = OpenProcess(
                          STANDARD_RIGHTS_REQUIRED 
                        // | SPECIFIC_RIGHTS_ALL,
                        | PROCESS_DUP_HANDLE,
			            FALSE,
			            pid) ;
    }
    else
    {
        clienthandle = GetCurrentProcess();
    }

    if(NULL == clienthandle)
    {
        DWORD dwError = GetLastError();


        RasmanTrace(
               "Failed to open process pid=%d"
               " GLE=0x%x",
               pid,
               dwError);

        // DbgPrint("DuplicateHandleForRasman: failed to openprocess %d"
        //         " GLE=0x%x\n",
        //         pid,
        //        dwError);
                 
        // DebugBreak();
    }

    //
    // Get own handle
    //
    selfhandle = GetCurrentProcess () ;

    //
    // Duplicate the handle: this should never fail!
    //
    if(!DuplicateHandle (clienthandle,
                     sourcehandle,
                     selfhandle,
                     &duphandle,
        		     0,
        		     FALSE,
        		     DUPLICATE_SAME_ACCESS))
    {
        DWORD dwError;
        dwError = GetLastError();


        RasmanTrace(
               "DuplicateHandleForRasman: failed to duplicatehandle"
               " pid=%d, handle=0x%x, GLE=0x%x",
               pid,
               sourcehandle,
               dwError); 

        // DbgPrint("DuplicateHandleForRasman: failed to duplicatehandle"
        //        " pid=%d, handle=0x%x, GLE=0x%x\n",
        //        pid,
        //        sourcehandle,
        //        GetLastError());

        // DebugBreak();
    }

    if(pid != GetCurrentProcessId())
    {
        //
        // Now close the handle to the rasman process
        //
        CloseHandle (clienthandle) ;
    }

    return duphandle ;
}


/*++

Routine Description

    This function is called to validate and convert the handle
    passed in. This handle can be NULL - meaning the calling
    program does not want to be notified of the completion of
    the async request. Or, it can be a Window Handle - meaning
    a completion message must be passed to the Window when the
    async operation is complete. Or, it can be an Event handle
    that must be signalled when the operation is complete. In 
    the last case, a handle should be got for the Rasman process
    by calling the DuplicateHandle API.

Arguments

Return Value

    Handle
    INVALID_HANDLE_VALUE
    
--*/
HANDLE
ValidateHandleForRasman (HANDLE handle, DWORD pid)
{
    HANDLE  convhandle ;

    //
    // If the handle is NULL or is a Window handle then
    // simply return it there is no conversion required.
    //
    if (    (handle == NULL)
        ||  (INVALID_HANDLE_VALUE == handle))
    {
    	return handle ;
    }

    //
    // Else, get a handle that for the event passed so
    // that the Rasman process can signal it when the
    // operation is complete.
    //
    if (!(convhandle = DuplicateHandleForRasman (handle, pid)))
    {
	    return INVALID_HANDLE_VALUE ;
	}

    return convhandle ;
}

/*++

Routine Description

    Called to signal completion of an async operation by
    signaling the appropriate event.

Arguments

Return Value

    Nothing.
    
--*/
VOID
CompleteAsyncRequest (pPCB ppcb)
{
    HANDLE h = ppcb->PCB_AsyncWorkerElement.WE_Notifier;
    DWORD dwType = ppcb->PCB_AsyncWorkerElement.WE_ReqType;

    if (    NULL != h
        &&  INVALID_HANDLE_VALUE != h )
    {
        // DbgPrint("CompleteASyncRequest: Setting Event 0x%x\n",
        //         h);

        SetEvent(h);
    }
        
    //
    // When we are in "send packets directly to PPP" mode, this
    // handle might be invalid but we still need to post status
    // to rasapi clients.
    //
    
    if (    (   ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPSTARTED
            &&  dwType == REQTYPE_PORTDISCONNECT )
       ||   (   ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPLISTEN
            &&  dwType == REQTYPE_DEVICELISTEN )
       ||   (   NULL != h
            &&  INVALID_HANDLE_VALUE != h ) )
    {
        //
        // Signal the I/O completion port on completed
        // listen, connect, or disconnect operations.
        //
        if (    ppcb->PCB_IoCompletionPort != INVALID_HANDLE_VALUE 
            &&  (   dwType == REQTYPE_DEVICELISTEN 
                ||  dwType == REQTYPE_DEVICECONNECT 
                ||  dwType == REQTYPE_PORTDISCONNECT))
        {
            RasmanTrace(
              "CompleteAsyncRequest: pOverlapped=0x%x",
              ppcb->PCB_OvStateChange);
              
            PostQueuedCompletionStatus(
              ppcb->PCB_IoCompletionPort,
              0,
              0,
              ppcb->PCB_OvStateChange);
        }
    }
            
    return;

}

VOID
ConvParamPointerToOffset (RAS_PARAMS *params, DWORD numofparams)
{
    WORD    i ;

    for (i=0; i < numofparams; i++) 
    {
    	if (params[i].P_Type == String) 
    	{
    	    params[i].P_Value.String_OffSet.dwOffset = 
    	        (DWORD) (params[i].P_Value.String.Data - (PCHAR) params) ;
    	}
    }
}

VOID
CopyParams (RAS_PARAMS *src, RAS_PARAMS *dest, DWORD numofparams)
{
    WORD    i ;
    PBYTE   temp ;
    
    //
    // first copy all the params into dest
    //
    memcpy (dest, src, numofparams*sizeof(RAS_PARAMS)) ;

    //
    // copy the strings:
    //
    
    temp = (PBYTE)dest + numofparams*sizeof(RAS_PARAMS) ;
    
    for (i = 0; i < numofparams; i++) 
    {
    
    	if (src[i].P_Type == String) 
    	{
    	    dest[i].P_Value.String.Length = 
    	        src[i].P_Value.String.Length ;
    	        
    	    dest[i].P_Value.String.Data = temp ;
    	    
    	    memcpy (temp,
    	            src[i].P_Value.String.Data,
    	            src[i].P_Value.String.Length) ;
    	            
    	    temp += src[i].P_Value.String.Length ;
    	    
    	} 
    	else
    	{
    	    dest[i].P_Value.Number = src[i].P_Value.Number ;
    	}
    }
}


VOID
ConvParamOffsetToPointer (RAS_PARAMS *params, DWORD numofparams)
{
    WORD    i ;

    for (i=0; i < numofparams; i++) 
    {
    	if (params[i].P_Type == String) 
    	{
    	    params[i].P_Value.String.Data = 
	              params[i].P_Value.String_OffSet.dwOffset
	            + (PCHAR) params ;
    	}
    }
}


/*++

Routine Description

    Closes the handles for different objects opened
    by RASMAN process.

Arguments

Return Value

--*/
VOID
FreeNotifierHandle (HANDLE handle)
{

    if (    (handle != NULL)
        &&  (handle != INVALID_HANDLE_VALUE)) 
    {
    	if (!CloseHandle (handle)) 
    	{
    	    GetLastError () ;
    	}
    }
}

VOID
GetMutex (HANDLE mutex, DWORD to)
{
    WaitForSingleObject (mutex, to) ;

}

VOID
FreeMutex (HANDLE mutex)
{
    ReleaseMutex(mutex) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\memory.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

LPVOID
AllocADsMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    return(LocalAlloc(LPTR, cb));
}

BOOL
FreeADsMem(
   LPVOID pMem
)
{
    return(LocalFree(pMem) == NULL);
}

LPVOID
ReallocADsMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocADsMem(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreeADsMem(pOldMem);
    }

    return pNewMem;
}

LPWSTR
AllocADsStr(
    LPWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPWSTR)AllocADsMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
FreeADsStr(
   LPWSTR pStr
)
{
   return pStr ? FreeADsMem(pStr)
               : FALSE;
}

BOOL
ReallocADsStr(
   LPWSTR *ppStr,
   LPWSTR pStr
)
{
   FreeADsStr(*ppStr);
   *ppStr=AllocADsStr(pStr);

   return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\ep.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    ep.c

Abstract:

    All code to allocate/remove endpoints lives here
    
Author:

	Rao Salapaka (raos) 09-Oct-1998
	
Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <llinfo.h>
#include <rasman.h>
#include <lm.h>
#include <lmwksta.h>
#include <wanpub.h>
#include <stdlib.h>
#include <string.h>
#include <rtutils.h>
#include "logtrdef.h"
#include "defs.h"
#include "media.h"
#include "device.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "reghelp.h"
#include "ddwanarp.h"

#if DBG
#include "reghelp.h"    // for PrintGuids function
#endif

EpInfo  *g_pEpInfo;

extern DWORD g_dwRasDebug;

BOOL g_fIpInstalled;
BOOL g_fNbfInstalled;

/*++

Routine Description

    Uninitializes the global EndPoint information.

Arguments

    None

Return Value

    void

--*/
VOID
EpUninitialize()
{
    DWORD i;

    //
    // Loop till the work item queued returns. This is sort
    // of a busy wait but this thread doesn't have to do
    // anything in this state since rasman is shutting down.
    //
    while(1 == g_lWorkItemInProgress)
    {
        RasmanTrace("EpUninitialize: Waiting for WorkItem to complete..");
        
        Sleep(5000);
    }

    if(INVALID_HANDLE_VALUE != g_hWanarp)
    {
        CloseHandle(g_hWanarp);
        g_hWanarp = INVALID_HANDLE_VALUE;
    }

    if(NULL != g_pEpInfo)
    {
        LocalFree(g_pEpInfo);
        g_pEpInfo = NULL;
    }
}

DWORD
DwUninitializeEpForProtocol(EpProts protocol)
{
    struct EpRegInfo
    {
        const CHAR *c_pszLowWatermark;
        const CHAR *c_pszHighWatermark;
    };
    
    //
    // !!NOTE!!
    // Make sure that the following table is indexed
    // in the same order as the EpProts enumeration
    //
    struct EpRegInfo aEpRegInfo[] =   
    {
        {
            "IpOutLowWatermark",
            "IpOutHighWatermark",
        },

        {
            "NbfOutLowWatermark",
            "NbfOutHighWatermark",
        },

        {
            "NbfInLowWatermark",
            "NbfInHighWatermark",
        },
    };

    HKEY hkey = NULL;
    
    const CHAR c_szRasmanParms[] =
            "System\\CurrentControlSet\\Services\\Rasman\\Parameters";
    
    LONG lr = ERROR_SUCCESS;

    DWORD dwData = 0;
    
    if(ERROR_SUCCESS != (lr = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        c_szRasmanParms,
                        0,
                        KEY_ALL_ACCESS,
                        &hkey)))
    {
        RasmanTrace("DwUninitializeEpForProtocol: failed to open rasman"
                " params. lr=0x%x",
                lr);

        goto done;                
    }

    if(ERROR_SUCCESS != (lr = RegSetValueEx(
                            hkey,
                            aEpRegInfo[protocol].c_pszLowWatermark,
                            0,
                            REG_DWORD,
                            (PBYTE) &dwData,
                            sizeof(DWORD))))
    {
        RasmanTrace("DwUninitializeEpForProtocol: Failed to set %s"
                " lr=0x%x", lr);
    }

    if(ERROR_SUCCESS != (lr = RegSetValueEx(
                            hkey,
                            aEpRegInfo[protocol].c_pszHighWatermark,
                            0,
                            REG_DWORD,
                            (PBYTE) &dwData,
                            sizeof(DWORD))))
    {
        RasmanTrace("DwUninitializeEpForProtocol: Failed to set %s"
                " lr=0x%x", lr);
    }

done:

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    return (DWORD) lr;

}

DWORD
DwInitializeWatermarksForProtocol(EpProts protocol)
{
    HKEY hkey = NULL;

    const CHAR c_szRasmanParms[] =
            "System\\CurrentControlSet\\Services\\Rasman\\Parameters";
    
    LONG lr = ERROR_SUCCESS;

    DWORD dwType,
          dwSize = sizeof(DWORD);

    DWORD i;          

    struct EpRegInfo
    {
        const CHAR *c_pszLowWatermark;
        const CHAR *c_pszHighWatermark;
        DWORD dwLowWatermark;
        DWORD dwHighWatermark;
    };

    struct EpProtInfo
    {
        const CHAR *pszWatermark;
        DWORD dwWatermark;
        DWORD *pdwWatermark;
    };

    struct EpRegInfo aEpRegInfo[] =
    {
        {
            "IpOutLowWatermark",
            "IpOutHighWatermark",
            1,
            5,
        },

        {
            "NbfOutLowWatermark",
            "NbfOutHighWatermark",
            1,
            5,
        },

        {
            "NbfInLowWatermark",
            "NbfInHighWatermark",
            1,
            5,
        },
    };

    struct EpProtInfo aEpProtInfo[2];

    RasmanTrace("DwInitializeWMForProtocol: protocol=%d",
            protocol);


    if(protocol >= MAX_EpProts)
    {
        lr = E_INVALIDARG;
        goto done;
    }

    if(ERROR_SUCCESS != (lr = RegOpenKeyEx(
                                    HKEY_LOCAL_MACHINE,
                                    c_szRasmanParms,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hkey)))
    {   
        RasmanTrace("DwInitializeEpForProtocol: failed to open "
                "rasman key. rc=0x%x",
                (DWORD) lr);

        goto done;                
    }

    aEpProtInfo[0].pszWatermark = aEpRegInfo[protocol].c_pszLowWatermark;
    aEpProtInfo[0].dwWatermark  = aEpRegInfo[protocol].dwLowWatermark;
    aEpProtInfo[0].pdwWatermark = &g_pEpInfo[protocol].EP_LowWatermark;
    
    aEpProtInfo[1].pszWatermark = aEpRegInfo[protocol].c_pszHighWatermark;
    aEpProtInfo[1].dwWatermark  = aEpRegInfo[protocol].dwHighWatermark;
    aEpProtInfo[1].pdwWatermark = &g_pEpInfo[protocol].EP_HighWatermark;

    for(i = 0; i < 2; i++)
    {

        lr = RegQueryValueEx(
                    hkey,
                    aEpProtInfo[i].pszWatermark,
                    NULL,
                    &dwType,
                    (PBYTE) aEpProtInfo[i].pdwWatermark,
                    &dwSize);

        if(     (ERROR_FILE_NOT_FOUND == lr)
            ||  (   (ERROR_SUCCESS == lr)
                &&  (0 == (DWORD) *(aEpProtInfo[i].pdwWatermark))))
        {
            //
            // Set the default value
            //
            if(ERROR_SUCCESS != (lr = RegSetValueEx(
                        hkey,
                        aEpProtInfo[i].pszWatermark,
                        0,
                        REG_DWORD,
                        (PBYTE) &aEpProtInfo[i].dwWatermark,
                        sizeof(DWORD))))
            {
                RasmanTrace("DwInitializeWMForProtocol failed to set"
                        " a default value. rc=0x%x",
                        lr);
            }

            //
            // Update the value
            //
            (DWORD) *(aEpProtInfo[i].pdwWatermark) = 
                                        aEpProtInfo[i].dwWatermark;
        }
    }

done:

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    return (DWORD) lr;
}

/*++

Routine Description

    This routine initializes the EndPoint Information used in
    dynamically allocating/removing Wan EndPoint bindings.

Arguments

    None

Return Value

    SUCCESS if the initialization is successful.

--*/
DWORD
DwEpInitialize()
{
    HKEY hkey = NULL;

    DWORD dwErr = ERROR_SUCCESS;

    DWORD i;                      
    DWORD dwType, 
          dwSize = sizeof(UINT),
          bytesrecvd;

    NDISWAN_GET_PROTOCOL_INFO Info;          

    g_hWanarp = INVALID_HANDLE_VALUE;          

    g_pEpInfo = LocalAlloc(LPTR, MAX_EpProts * sizeof(EpInfo));

    if(NULL == g_pEpInfo)
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Check to see what protocols are installed.
    //
    if(!DeviceIoControl(
            RasHubHandle,
            IOCTL_NDISWAN_GET_PROTOCOL_INFO,
            NULL,
            0,
            &Info,
            sizeof(NDISWAN_GET_PROTOCOL_INFO),
            &bytesrecvd,
            NULL))
    {
        dwErr = GetLastError();
        RasmanTrace(
                "GetProtocolInfo: failed 0x%x",
               dwErr);
    }

    g_fIpInstalled = FALSE;
    g_fNbfInstalled = FALSE;
    
    for(i = 0; i < Info.ulNumProtocols; i++)
    {
        if(IP == Info.ProtocolInfo[i].ProtocolType)
        {
            g_fIpInstalled = TRUE;
        }
        else if(ASYBEUI == Info.ProtocolInfo[i].ProtocolType)
        {
            g_fNbfInstalled = TRUE;
        }
    }

    //
    // If IP is installed set the default Watermarks for IP
    // if required.
    //
    if(g_fIpInstalled)
    {
        dwErr = DwInitializeWatermarksForProtocol(IpOut);

        if(ERROR_SUCCESS != dwErr)
        {
            RasmanTrace("Failed to initialize watermarks for IpOut."
                    " dwErr=0x%x",
                    dwErr);
        }

        //
        // March on and see if we can proceed - No point in failing
        //
        dwErr = ERROR_SUCCESS;
    }

    if(g_fNbfInstalled)
    {
        dwErr = DwInitializeWatermarksForProtocol(NbfOut);

        if(ERROR_SUCCESS != dwErr)
        {
            RasmanTrace("Failed to initialize watermarks for NbfOut"
                    " dwErr=0x%x",
                    dwErr);
            
        }
        
        dwErr = DwInitializeWatermarksForProtocol(NbfIn);

        if(ERROR_SUCCESS != dwErr)
        {
            RasmanTrace("Failed to initialize watermarks for NbfIn"
                    " dwErr=0x%x",
                    dwErr);
        }

        //
        // March on and see if we can proceed - No point in failing
        //
        dwErr = ERROR_SUCCESS;
    }

    g_lWorkItemInProgress = 0;

    g_plCurrentEpInUse = (LONG *) LocalAlloc(
                                    LPTR, 
                                    MAX_EpProts * sizeof(LONG));

    if(NULL == g_plCurrentEpInUse)
    {
        dwErr = GetLastError();
        goto done;
    }

    // 
    // Intialize the available endpoints.
    //
    dwErr = (DWORD) RasCountBindings(
                &g_pEpInfo[IpOut].EP_Available,
                &g_pEpInfo[NbfIn].EP_Available,
                &g_pEpInfo[NbfOut].EP_Available
                );
                
    RasmanTrace("EpInitialize: RasCountBindings returned 0x%x",
             dwErr);

    RasmanTrace("EpInitialze: Available. IpOut=%d, NbfIn=%d, NbfOut=%d",
                g_pEpInfo[IpOut].EP_Available,
                g_pEpInfo[NbfIn].EP_Available,
                g_pEpInfo[NbfOut].EP_Available
                );
                
    //
    // Add bindings if required.
    //
    dwErr = DwAddEndPointsIfRequired();

    if(ERROR_SUCCESS != dwErr)
    {
        RasmanTrace("DwEpInitialize: DwAddEndPointsIfRequired rc=0x%x",
                  dwErr);
    }

    dwErr = DwRemoveEndPointsIfRequired();

    if(ERROR_SUCCESS != dwErr)
    {
        RasmanTrace("DwEpInitialize: DwRemoveEndPointsIfRequired rc=0x%x",
                 dwErr);
    }

    dwErr = ERROR_SUCCESS;

done:
    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    
    return dwErr;
}

#if DBG
void
PrintGuids(WANARP_DELETE_ADAPTERS_INFO *pInfo)
{
    UINT i;
    WCHAR szGuid[40];

    RasmanTrace("RASMAN: Number of adapters deleted = %d",
             pInfo->ulNumAdapters);

    for(i = 0; i < pInfo->ulNumAdapters; i++)
    {
        if(0 == i)
        {
            RasmanTrace("Guid removed:");
        }
        
        ZeroMemory(szGuid, sizeof(szGuid));
        
        (void) RegHelpStringFromGuid(&pInfo->rgAdapterGuid[i], szGuid, 40);

        RasmanTrace("%ws", szGuid);
    }
}
#endif

/*++

Routine Description

    This routine removes Wan Ip Adaters. It opens wanarp if 
    its not already opened.
    
Arguments

    cNumAdapters - Number of adapters to remove.

    ppAdapterInfo - Address to store the Adapter information 
                    returned by Wanarp. The memory for this
                    information is LocalAllocated here and 
                    is expected to be LocalFreed by the 
                    caller of this function. Note that
                    wanarp removes as many adapters as
                    possible and may not be able to remove
                    the number specified by cNumAdapters.

Return Value

    SUCCESS if removal was successful.

--*/
DWORD
DwRemoveIpAdapters(
        UINT                         cNumAdapters,
        WANARP_DELETE_ADAPTERS_INFO  **ppAdapterInfo
        )
{
    DWORD dwErr = ERROR_SUCCESS;

    WANARP_DELETE_ADAPTERS_INFO *pInfo = NULL;

    DWORD cBytes;
    DWORD cBytesReturned;

    if(INVALID_HANDLE_VALUE == g_hWanarp)
    {
        if (INVALID_HANDLE_VALUE == 
                (g_hWanarp = CreateFile (
                            WANARP_DOS_NAME_A,
                            GENERIC_READ 
                          | GENERIC_WRITE,
                            FILE_SHARE_READ 
                          | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL
                          | FILE_FLAG_OVERLAPPED,
                            NULL)))
        {
            dwErr = GetLastError();
            RasmanTrace("CreateFile WANARP failed. 0x%x",
                    dwErr);
                    
            goto done;
        }
    }

    //
    // Allocate enough memory so that wanarp
    // can pass information back to us about
    // the adapter names.
    //
    cBytes = sizeof(WANARP_DELETE_ADAPTERS_INFO)
           + (  (cNumAdapters)
              * (sizeof(GUID)));
              
    pInfo = LocalAlloc(LPTR, cBytes);

    if(NULL == pInfo)
    {
        dwErr = GetLastError();
        goto done;
    }

    pInfo->ulNumAdapters = cNumAdapters;

    //
    // Ask Wanarp to remove the ip adapters
    //
    if(!DeviceIoControl(    
            g_hWanarp,
            IOCTL_WANARP_DELETE_ADAPTERS,
            pInfo,
            cBytes,
            pInfo,
            cBytes,
            &cBytesReturned,
            NULL))
    {
        dwErr = GetLastError();
        RasmanTrace("IOCTL_WANARP_DELETE_ADAPTERS failed. 0x%x",
                dwErr);
                
        goto done;
    }

#if DBG
    PrintGuids(pInfo);
#endif
    
    *ppAdapterInfo = pInfo;

done:
    return dwErr;
}

/*++

Routine Description

    This is a callback function called by ntdlls worker thread.
    The work item should be queued from RemoveEndPoints and the
    function queueing the workitem should increment the global
    g_lWorkItemInProgress value atomically. This function calls
    into netman to remove nbf/ipout bindings. This call may take
    a long time since the netman call may block on the INetCfg
    lock.

Arguments

    pvContext - EndPointInfo context passed to the workitem by
                RemoveEndPoints.

Return Value

    void

--*/
VOID
RemoveEndPoints(PVOID pvContext)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    WANARP_DELETE_ADAPTERS_INFO *pAdapterInfo = NULL;

    DWORD i;

    UINT auEndPoints[MAX_EpProts];

    BOOL fNbfCountChanged = FALSE;

    ZeroMemory((PBYTE) auEndPoints, sizeof(auEndPoints));

    for(i = 0; i < MAX_EpProts; i++)
    {

        if(i != IpOut)
        {
            RasmanTrace("RemoveEndPoints: Ignoring ep removal for %d",
                    i);
            continue;                    
        }
        
        if(g_pEpInfo[i].EP_Available < (UINT) g_plCurrentEpInUse[i])
        {
            RasmanTrace("RemoveEndPoints: Available < InUse!. %d < %d"
                    " Ignoring..",
                    g_pEpInfo[i].EP_Available,
                    g_plCurrentEpInUse[i]);

            continue;                    
        }
        
        if((g_pEpInfo[i].EP_Available - g_plCurrentEpInUse[i])
            >= g_pEpInfo[i].EP_HighWatermark)
        {
            auEndPoints[i] = (  g_pEpInfo[i].EP_Available
                              - g_plCurrentEpInUse[i])
                           - (( g_pEpInfo[i].EP_HighWatermark
                             + g_pEpInfo[i].EP_LowWatermark)
                             / 2) ;

            if(     (auEndPoints[i] != 0)
                &&  (i != IpOut))
            {
                fNbfCountChanged = TRUE;
            }
        }
    }

    //
    // Check to see if theres something we need to remove.
    //
    if(     (0 == auEndPoints[IpOut])
        &&  (0 == auEndPoints[NbfOut])
        &&  (0 == auEndPoints[NbfIn]))
    {
        RasmanTrace("RemoveEndPoints: Nothing to remove");
        goto done;
    }

    //
    // If We want to remove Ip Endpoints, ask wanarp to
    // remove the bindings and get the names of the
    // adapters it removed.
    //
    if(0 != auEndPoints[IpOut])
    {
        RasmanTrace("Removing %d IpOut from wanarp", auEndPoints[IpOut]);
        dwErr = DwRemoveIpAdapters(
                            auEndPoints[IpOut],
                            &pAdapterInfo);
    }

    if(NULL != pAdapterInfo)
    {
        auEndPoints[IpOut] = pAdapterInfo->ulNumAdapters;
    }
    else
    {
        auEndPoints[IpOut] = 0;
    }

#if DBG
    if(g_dwRasDebug)
        DbgPrint("RasRemoveBindings: ipout=%d, nbfout=%d, nbfin=%d\n",
             auEndPoints[IpOut],
             auEndPoints[NbfOut],
             auEndPoints[NbfIn]);
#endif

    //
    // Ask netman to remove the adapter bindings. On return the
    // the counts will reflect the current number of bindings
    // in the system.
    //
    dwErr = (DWORD) RasRemoveBindings(
                            &auEndPoints[IpOut],
                            (NULL != pAdapterInfo)
                            ? pAdapterInfo->rgAdapterGuid
                            : NULL,
                            &auEndPoints[NbfIn],
                            &auEndPoints[NbfOut]
                            );

    if(S_OK != dwErr)
    {
        RasmanTrace("RemoveEndPoints: RasRemoveBindings failed. 0x%x",
                dwErr);
        goto done;
    }

    for(i = 0; i < MAX_EpProts; i++)
    {
        RasmanTrace("i = %d, Available=%d, auEp=%d",
                i, g_pEpInfo[i].EP_Available, auEndPoints[i]);
                
        ASSERT(g_pEpInfo[i].EP_Available >= auEndPoints[i]);

        //
        // Ssync up our availability count with netmans
        //
        if(g_pEpInfo[i].EP_Available >= auEndPoints[i])
        {
            InterlockedExchange(
                &g_pEpInfo[i].EP_Available,
                auEndPoints[i]
                );
        }
        else
        {
            //
            // This is bad dood!
            //
            ASSERT(FALSE);
            g_pEpInfo[i].EP_Available = 0;

            RasmanTrace("%d: Available < Total EndPoints!!!. %d < %d",
                    i,
                    g_pEpInfo[i].EP_Available,
                    auEndPoints[i]);
        }
    }

    RasmanTrace("RemoveEndPoints: Available.IpOut=%d, NbfIn=%d, NbfOut=%d",
            g_pEpInfo[IpOut].EP_Available,
            g_pEpInfo[NbfIn].EP_Available,
            g_pEpInfo[NbfOut].EP_Available);
            
    if(fNbfCountChanged)
    {
        EnterCriticalSection(&g_csSubmitRequest);

        RasmanTrace("RemoveEndPoints: ReIntiializing Protinfo");

        InitializeProtocolInfoStructs();

        LeaveCriticalSection(&g_csSubmitRequest);
    }   

done:

    if(NULL != pAdapterInfo)
    {
        LocalFree(pAdapterInfo);
    }

    //
    // Release the lock
    //
    if(1 != InterlockedExchange(&g_lWorkItemInProgress, 0))
    {
        //
        // This is bad! This work item was queued without
        // holding a lock
        //
        ASSERT(FALSE);
    }

    return;    
}

/*++

Routine Description

    This is a callback function called by ntdlls worker thread.
    The work item should be queued from DwEpAllocateEndPoints.
    The function queueing the workitem should increment the 
    global g_lWorkItemInProgress value atomically. This function 
    calls into netman to add ipout/nbf bindings. This call may 
    take a long time since the netman call may block on the 
    INetCfg lock.
    

Arguments

    pvContext - EpInfoContext passed to the workitem by
                DwEpaAllocateEndPoints.

Return Value

    void

--*/
VOID
AllocateEndPoints(PVOID pvContext)
{
    DWORD dwErr = ERROR_SUCCESS;

    DWORD i;

    UINT  auEndPointsToAdd[MAX_EpProts] = {0};

    BOOL fNbfCountChanged = FALSE;

    RasmanTrace("AllocateEndPoints: WorkItem scheduled");

    for(i = 0; i < MAX_EpProts; i++)
    {
        if(     (g_pEpInfo[i].EP_Available >= (UINT) g_plCurrentEpInUse[i])
            &&  ((g_pEpInfo[i].EP_Available - g_plCurrentEpInUse[i])
                    <= g_pEpInfo[i].EP_LowWatermark))
        {
            auEndPointsToAdd[i] = (( g_pEpInfo[i].EP_HighWatermark
                                  + g_pEpInfo[i].EP_LowWatermark)
                                  / 2) 
                                - (  g_pEpInfo[i].EP_Available
                                   - g_plCurrentEpInUse[i]);

            if(     (i != IpOut)
                &&  (0 != auEndPointsToAdd[i]))
            {
                fNbfCountChanged = TRUE;
            }

            ASSERT(auEndPointsToAdd[i] <= g_pEpInfo[i].EP_HighWatermark);                                   
        }
    }

    if(     (0 == auEndPointsToAdd[IpOut])
        &&  (0 == auEndPointsToAdd[NbfOut])
        &&  (0 == auEndPointsToAdd[NbfIn]))
    {
        RasmanTrace("AllocateEndPoints: Nothing to allocate");
        goto done;
    }
    
    //
    // Tell Netman to add the requisite number of bindings
    //
    dwErr = (DWORD) RasAddBindings(
                        &auEndPointsToAdd[IpOut],
                        &auEndPointsToAdd[NbfIn],
                        &auEndPointsToAdd[NbfOut]);

    //
    // We assume the netman apis are atomic and will not change
    // the state in case of errors. We are in trouble if the state
    // is not consistent in case of an error - we assume that
    // the state didn't change if an error was returned.
    //
    if(ERROR_SUCCESS != dwErr)
    {
        RasmanTrace("AllocateEndPoints: RasAddBindings failed. 0x%x",
                 dwErr);
                 
        goto done;
    }

    //
    // Ssync up our available endpoints value with netmans
    //
    for(i = 0; i < MAX_EpProts; i++)
    {
        InterlockedExchange(
            &g_pEpInfo[i].EP_Available,
            auEndPointsToAdd[i]
            );
    }

    RasmanTrace("AllocateEndPoints: Available. IpOut=%d, NbfIn=%d, NbfOut=%d",
            g_pEpInfo[IpOut].EP_Available,
            g_pEpInfo[NbfIn].EP_Available,
            g_pEpInfo[NbfOut].EP_Available);
            
    if(fNbfCountChanged)
    {
        EnterCriticalSection(&g_csSubmitRequest);

        RasmanTrace("AllocateEndPoints: Reinitializing protinfo");

        InitializeProtocolInfoStructs();

        LeaveCriticalSection(&g_csSubmitRequest);
    }   
    
done:

    //
    // Release the lock
    //
    if(1 != InterlockedExchange(&g_lWorkItemInProgress, 0))
    {
        //
        // This is bad! This work item was queued without
        // holding a lock
        //
        ASSERT(FALSE);
    }

    return;
}

/*++

Routine Description

    This is a helper routine that queues a workitem to 
    add or remove endpoints.

Arguments

    fnCallback - Callback function to be called when the
                 workitem is scheduled. This is Set to
                 RemoveEndPoints for removal of endpoints
                 and AllocateEndPoints for addition of
                 endpoints.
Return Value

    SUCCESS if the workitem is successfully queued.
    E_FAIL if there is already a workitem in progress.
    E_OUTOFMEMORY if failed to allocate memory.

--*/
DWORD
DwAdjustEndPoints(
    WORKERCALLBACKFUNC fnCallback
                  )
{
    DWORD dwErr = ERROR_SUCCESS;

    if(1 == InterlockedExchange(&g_lWorkItemInProgress, 1))
    {
        RasmanTrace("DwAdjustEndPoints: workitem in progress");
        
        //
        // WorkItem is already in progress
        //
        dwErr = E_FAIL;
        goto done;
    }

    dwErr = RtlQueueWorkItem(
                    fnCallback,
                    (PVOID) NULL,
                    WT_EXECUTEDEFAULT);

    if(ERROR_SUCCESS != dwErr)
    {
        InterlockedExchange(&g_lWorkItemInProgress, 0);
        RasmanTrace("DwAdjustEndPoints: failed to q workitem. 0x%x",
                dwErr);
                
        goto done;
    }

    RasmanTrace("DwAdjustEndPoints: successfully queued workitem - 0x%x",
            fnCallback);

done:
    return dwErr;
    
}
                  
/*++

Routine Description

    Checks to see if endpoints needs to be added and
    adds endpoints if required.

Arguments

    None

Return Value

    SUCCESS if successfully queued a workitem to add
    endpoints.
    
--*/
DWORD
DwAddEndPointsIfRequired()
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD i;

    if(g_lWorkItemInProgress)
    {
        RasmanTrace("DwAddEndPointsIfRequired: WorkItem in progress..");
        goto done;
    }

    for(i = 0; i < MAX_EpProts; i++)
    {
        if(     (0 != g_pEpInfo[i].EP_LowWatermark)
            &&  (0 != g_pEpInfo[i].EP_HighWatermark)
            &&  ((g_pEpInfo[i].EP_Available - g_plCurrentEpInUse[i])
                 <= g_pEpInfo[i].EP_LowWatermark))
        {
            break;
        }
    }

    if(i == MAX_EpProts)
    {
        RasmanTrace("DwAddEndPointsIfRequired: nothing to add");
        goto done;
    }

    dwErr = DwAdjustEndPoints(AllocateEndPoints);
    
done:
    return dwErr;
}

/*++

Routine Description

    Checks to see if endpoints needs to be removed and
    removes endpoints if required.

Arguments

    None

Return Value

    SUCCESS if successfully queued a workitem to remove
    endpoints.
    
--*/
DWORD
DwRemoveEndPointsIfRequired()
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD i;
    BOOL  fRemove = FALSE;

    if(1 == g_lWorkItemInProgress)
    {
        goto done;
    }

    for(i = 0; i < MAX_EpProts; i++)
    {
        if(i != IpOut)
        {
            RasmanTrace("Ignoring removal request for %d",
                    i);
        }
        
        if(     (0 != g_pEpInfo[i].EP_HighWatermark)
            &&  ((g_pEpInfo[i].EP_Available - g_plCurrentEpInUse[i])
                >= g_pEpInfo[i].EP_HighWatermark))
        {   
            break;
        }
    }

    if(i == MAX_EpProts)
    {
        RasmanTrace("DwRemoveEndPointsifRequired: Nothing to remove");
        goto done;
    }

    dwErr = DwAdjustEndPoints(RemoveEndPoints);

done:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\globals.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  6/8/92  Gurdeep Singh Pall  Created
//
//
//  Description: This file contains all globals entities used in rasman32.
//
//****************************************************************************


PCB  **Pcb ;

CRITICAL_SECTION PcbLock;

DWORD PcbEntries;

MediaCB  *Mcb ;

DeviceCB Dcb[MAX_DEVICES] ;

WORD     *EndpointTable ;

WORD     MaxEndpoints ;

ProtInfo *ProtocolInfo ;

ProtInfo *ProtocolInfoSave;

pTransportInfo XPortInfoSave;

DWORD    MaxProtocolsSave;

ULONG     MaxPorts ;

WORD     MaxMedias ;

WORD     MaxProtocols ;

HANDLE   RasHubHandle ;

HANDLE   g_hWanarp;

DWORD    GlobalError ;

HANDLE   hLogEvents;

DWORD    g_dwAttachedCount;

DWORD    g_dwRasAutoStarted;

DWORD    g_cNbfAllocated;

DeviceInfo *g_pDeviceInfoList;

DeltaQueue TimerQueue ;

BOOL     IsTimerThreadRunning ;                         // Flag used to figure out if timer
				                                        // thread is running
				
HANDLE	 hDummyOverlappedEvent;

RAS_OVERLAPPED	RO_TimerEvent;

RAS_OVERLAPPED	RO_CloseEvent;			                // Global Event used by different
										                // processes to signal shutdown of
										                // rasman process

RAS_OVERLAPPED	RO_FinalCloseEvent;		                // Event used to ppp engine to signal
										                // its shutting down

RAS_OVERLAPPED  RO_RasConfigChangeEvent;

RAS_OVERLAPPED  RO_RasAdjustTimerEvent;                 // event used when a new element is added to the
                                                        // timer queue.
RAS_OVERLAPPED  RO_HibernateEvent;                      // Ndiswan is asking rasman to hibernate

RAS_OVERLAPPED  RO_ProtocolEvent;                       // Ndiswan is indicating a change in protocols

RAS_OVERLAPPED  RO_PostRecvPkt;                         // Post receive packet in rasmans permanent thread
										
HINSTANCE hinstPpp;                                     // rasppp.dll library handle

HINSTANCE hinstIphlp;                                   // rasiphlp.dll library handle

HINSTANCE hinstRasAudio;                                // rasaudio.dll module

HANDLE hIoCompletionPort;                               // I/O completion port used by media DLLs


                                                        // of a threshold event

HANDLE   HLsa;                                          // handle used in all Lsa calls

DWORD    AuthPkgId;                                     // package id of MSV1_0 auth package

SECURITY_ATTRIBUTES RasmanSecurityAttribute ;

SECURITY_DESCRIPTOR RasmanSecurityDescriptor ;

HBUNDLE  NextBundleHandle ;                             // monotonically increasing bundled id

HCONN NextConnectionHandle;                             // monotonically increasing connection id

LIST_ENTRY ConnectionBlockList;                         // list of ConnectionBlocks

LIST_ENTRY ClientProcessBlockList;                      // list of Client Process Information blocks

ReceiveBufferList   *ReceiveBuffers;                    // Global ndiswan recv buffer pool

BapBuffersList *BapBuffers;                           // Global ndiswan bap buffer list

pHandleList pConnectionNotifierList;                    // list of global notifications

DWORD TraceHandle ;                                     // Trace Handle used for traces/logging

VOID (*RedialCallbackFunc)();                           // rasauto.dll redial-on-link failure callback

WCHAR * IPBindingName ;

DWORD IPBindingNameSize ;


LIST_ENTRY BundleList;

pPnPNotifierList g_pPnPNotifierList;

DWORD *g_pdwEndPoints;

GUID  *g_pGuidComps;

CRITICAL_SECTION g_csSubmitRequest;

HANDLE g_hReqBufferMutex;

HANDLE g_hSendRcvBufferMutex;

PPPE_MESSAGE *g_PppeMessage;                            // used to send information from rasman to ppp

REQTYPECAST  *g_pReqPostReceive;

RASEVENT g_RasEvent;

RAS_NDISWAN_DRIVER_INFO g_NdiswanDriverInfo;

BOOL g_fNdiswanDriverInfo;

LONG g_lWorkItemInProgress;

LONG *g_plCurrentEpInUse;

//
// PPP engine functions
//
FARPROC RasStartPPP;

FARPROC RasStopPPP;

FARPROC RasHelperResetDefaultInterfaceNetEx;

FARPROC RasHelperSetDefaultInterfaceNetEx;

FARPROC RasSendPPPMessageToEngine;

FARPROC RasPppHalt;

//
// rasaudio functions
//
FARPROC RasStartRasAudio;

FARPROC RasStopRasAudio;

//
// Rastapi functions to be used for pnp
//
FARPROC RastapiAddPorts;

FARPROC RastapiRemovePort;

FARPROC RastapiEnableDeviceForDialIn;

FARPROC RastapiGetConnectInfo;

FARPROC RastapiGetCalledIdInfo;

FARPROC RastapiSetCalledIdInfo;

FARPROC RastapiGetZeroDeviceInfo;

FARPROC RastapiUnload;

FARPROC RastapiSetCommSettings;

FARPROC RastapiGetDevConfigEx;


//
// IPSEC Globals
//
DWORD dwServerConnectionCount;

//
// IpHlp
// 
FARPROC RasGetBestInterface;
FARPROC RasGetIpAddrTable;
FARPROC RasAllocateAndGetInterfaceInfoFromStack;
HINSTANCE hIphlp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\init.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    Init.c

Abstract:

    All Initialization code for rasman service

Author:

    Gurdeep Singh Pall (gurdeep) 16-Jun-1992

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <raserror.h>
#include <media.h>
#include <devioctl.h>
#include <tchar.h>
#include <stdlib.h>
#include <string.h>
#include <mprlog.h>
#include <rtutils.h>
#include "logtrdef.h"
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "nouiutil.h"
#include "loaddlls.h"

#if SENS_ENABLED
#include "sensapip.h"
#endif

//
// Shared buffer macros.
//
#define REQBUFFERBYTES(wcPorts)     (sizeof(ReqBufferSharedSpace) \
                                    + REQBUFFERSIZE_FIXED \
                                    + (REQBUFFERSIZE_PER_PORT * \
                                    (wcPorts ? wcPorts : 1)))

#define SNDRCVBUFFERBYTES(wcPorts)  (sizeof(SendRcvBuffer) * \
                                    (wcPorts) * \
                                    SENDRCVBUFFERS_PER_PORT)

#define LOW_ORDER_BIT               (DWORD) 1

#define ROUTER_SERVICE_NAME         TEXT("Rasman")

DWORD InitializeRecvBuffers();

VOID  UpgradePortMediaInfoStruct (
        PVOID buffer,
        DWORD entries
        );

DWORD g_dwRasDebug = 0;

extern DWORD g_dwProhibitIpsec;

#ifdef DBG
#define RasmanDebugTrace(a) \
    if ( g_dwRasDebug) DbgPrint(a)

#define RasmanDebugTrace1(a1, a2) \
    if ( g_dwRasDebug) DbgPrint(a1, a2)

#define RasmanDebugTrace2(a1, a2, a3) \
    if ( g_dwRasDebug) DbgPrint(a1, a2, a3)

#define RasmanDebugTrace3(a1, a2, a3, a4) \
    if ( g_dwRasDebug) DbgPrint(a1, a2, a3, a4)

#define RasmanDebugTrace4(a1, a2, a3, a4, a5) \
    if ( g_dwRasDebug) DbgPrint(a1, a2, a3, a4, a5)

#define RasmanDebugTrace5(a1, a2, a3, a4, a5, a6) \
    if ( g_dwRasDebug) DbgPrint(a1, a2, a3, a4, a5, a6)

#define RasmanDebugTrace6(a1, a2, a3, a4, a5, a6, a7) \
    if ( g_dwRasDebug) DbgPrint(a1, a2, a3, a4, a5, a6, a7)

#else

#define RasmanDebugTrace(a)
#define RasmanDebugTrace1(a1, a2)
#define RasmanDebugTrace2(a1, a2, a3)
#define RasmanDebugTrace3(a1, a2, a3, a4)
#define RasmanDebugTrace4(a1, a2, a3, a4, a5)
#define RasmanDebugTrace5(a1, a2, a3, a4, a5, a6)
#define RasmanDebugTrace6(a1, a2, a3, a4, a5, a6, a7)

#endif

BOOL g_fRasRpcInitialized = FALSE;
BOOL g_fPcbLockInitialized = FALSE;
BOOLEAN RasmanShuttingDown = TRUE; 

VOID UnInitializeRas();


/*++

Routine Description

    Used for detecting processes attaching and detaching
    to the DLL.

Arguments

Return Value

--*/
BOOL
InitRasmansDLL (HANDLE hInst,
                DWORD ul_reason_being_called,
                LPVOID lpReserved)
{

    switch (ul_reason_being_called)
    {

    case DLL_PROCESS_ATTACH:

        dwServerConnectionCount = 0;

        DisableThreadLibraryCalls(hInst);
        break ;

    case DLL_PROCESS_DETACH:

        //
        // Terminate winsock.
        //
        //WSACleanup();

        break ;
    }

    return 1;
}

void InitializeOverlappedEvents(void)
{
    RO_TimerEvent.RO_EventType = OVEVT_RASMAN_TIMER;

    RO_CloseEvent.RO_EventType = OVEVT_RASMAN_CLOSE;

    RO_FinalCloseEvent.RO_EventType = OVEVT_RASMAN_FINAL_CLOSE;

    RO_RasConfigChangeEvent.RO_EventType = OVEVT_DEV_RASCONFIGCHANGE;

    RO_RasAdjustTimerEvent.RO_EventType = OVEVT_RASMAN_ADJUST_TIMER;

    RO_HibernateEvent.RO_EventType = OVEVT_RASMAN_HIBERNATE;

    RO_ProtocolEvent.RO_EventType = OVEVT_RASMAN_PROTOCOL_EVENT;

    RO_PostRecvPkt.RO_EventType = OVEVT_RASMAN_POST_RECV_PKT;

    return;
}

DeviceInfo *
GetDeviceInfo(
    PBYTE pbAddress,
    BOOL fModem)
{
    DeviceInfo *pDeviceInfo = g_pDeviceInfoList;

    while ( pDeviceInfo )
    {
        if(     fModem
            &&  !_stricmp(
                    (CHAR *) pbAddress,
                    pDeviceInfo->rdiDeviceInfo.szDeviceName))
        {
            break;
        }
        else if(    !fModem
                &&  0 == memcmp(pbAddress,
                        &pDeviceInfo->rdiDeviceInfo.guidDevice,
                        sizeof (GUID)))
        {
            break;
        }

        pDeviceInfo = pDeviceInfo->Next;
    }

    return pDeviceInfo;
}

DeviceInfo *
AddDeviceInfo( DeviceInfo *pDeviceInfo)
{
    DeviceInfo *pDeviceAdd;
    DWORD       retcode;

#if DBG
    ASSERT( NULL != pDeviceInfo );
#endif

    pDeviceAdd = LocalAlloc(
                    LPTR,
                    sizeof(DeviceInfo));

    if ( NULL == pDeviceAdd)
    {
        goto done;
    }

    *pDeviceAdd = *pDeviceInfo;

    pDeviceAdd->Next    = g_pDeviceInfoList;
    g_pDeviceInfoList   = pDeviceAdd;

done:
    return pDeviceAdd;
}

DWORD
DwSetEvents()
{
    DWORD retcode;
    
    //
    // Do this only if ndiswan is being started after
    // rasman started up. In the other case where ndiswan
    // is getting started at rasman startup time, the
    // irp for protocol event will be set when the request
    // thread is created.
    //
    retcode = DwSetProtocolEvent();

    if(ERROR_SUCCESS != retcode)
    {   
        if((DWORD) -1 != TraceHandle)
        {
            RasmanTrace(
                   "SetProtocolEvent failed. 0x%x\n",
                    retcode);
        }
    }
    
    retcode = DwSetHibernateEvent();

    if(ERROR_SUCCESS != retcode)
    {
        if((DWORD) -1 != TraceHandle)
        {
            RasmanTrace(
                   "SetHibernateEvent failed. 0x%x\n",
                    retcode);
        }
    }

    return retcode;    
}

DWORD
DwStartNdiswan()
{
    DWORD retcode = SUCCESS;

    //
    // Get a handle to RASHub.
    //
    if (INVALID_HANDLE_VALUE == (RasHubHandle = CreateFile (
                                    RASHUB_NAME,
                                    GENERIC_READ
                                  | GENERIC_WRITE,
                                    FILE_SHARE_READ
                                  | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL
                                  | FILE_FLAG_OVERLAPPED,
                                    NULL)))
    {
        retcode = GetLastError() ;

        RouterLogWarning(
                        hLogEvents,
                        ROUTERLOG_CANNOT_OPEN_RASHUB,
                        0, NULL, retcode) ;

        RasmanDebugTrace1 (
                "RASMANS: Failed to CreateFile ndiswan. 0x%x\n",
                retcode );

        if((DWORD) -1 != TraceHandle)
        {
            RasmanTrace(
                   "Failed to CreateFile ndiswan. 0x%x\n",
                    retcode);
        }

        if((DWORD) -1 != TraceHandle)
        {
            RasmanTrace(
                   "Failed to CreateFile ndiswan. 0x%x\n",
                    retcode);
        }

        goto done;
    }

    //
    // Initialize Endpoint information
    //
    if(ERROR_SUCCESS != (retcode = DwEpInitialize()))
    {
        if((DWORD) -1 != TraceHandle)
        {
            RasmanTrace(
                   "EpInitialize failed. 0x%x\n",
                    retcode);
        }
    }


done:

    return retcode;
}

VOID
RasmanCleanup()
{
    //
    // If Ipsec is initialize uninitialize it
    //
    DwUnInitializeIpSec();

    //
    // Stop the RPC server.
    //
    if(g_fRasRpcInitialized)
    {
        UninitializeRasRpc();
        g_fRasRpcInitialized = FALSE;
    }

    //
    // Time to shut down: Close all ports if they
    // are still open.
    //
    RasmanShuttingDown = TRUE;

    if(NULL != HLsa)
    {
        LsaDeregisterLogonProcess (HLsa);
        HLsa = NULL;
    }

    if(     (NULL != hIoCompletionPort)
        && (INVALID_HANDLE_VALUE != hIoCompletionPort))
    {        
        CloseHandle(hIoCompletionPort);
        hIoCompletionPort = NULL;
    }

    //
    // Unload dynamically-loaded libraries
    //
    if (hinstIphlp != NULL)
    {
        FreeLibrary(hinstIphlp);
        hinstIphlp = NULL;
    }

    if (hinstPpp != NULL)
    {
        FreeLibrary(hinstPpp);
        hinstPpp = NULL;
    }

    UnloadMediaDLLs();
    UnloadDeviceDLLs();
    FreePorts();
    FreeBapPackets();

    UnloadRasmanDll();
    UnloadRasapi32Dll();

    if(NULL != g_hReqBufferMutex)
    {
        CloseHandle(g_hReqBufferMutex);
        g_hReqBufferMutex = NULL;
    }

    if(NULL != g_hSendRcvBufferMutex)
    {
        CloseHandle(g_hSendRcvBufferMutex);
        g_hSendRcvBufferMutex = NULL;
    }

    //
    // Restore default control-C processing.
    //
    SetConsoleCtrlHandler(NULL, FALSE);

    g_dwRasAutoStarted = 0;

    //
    // Detach from trace dll
    //
    if(INVALID_TRACEID != TraceHandle)
    {
        TraceDeregister(TraceHandle) ;
    }

    //
    // Close Event Logging Handle
    //
    RouterLogDeregister(hLogEvents);

    if(INVALID_HANDLE_VALUE != RasHubHandle)
    {
        CloseHandle(RasHubHandle);
        RasHubHandle = INVALID_HANDLE_VALUE;
    }

    if(g_fPcbLockInitialized)
    {
        DeleteCriticalSection(&PcbLock);
        g_fPcbLockInitialized = FALSE;
    }

    UnInitializeRas();

    UninitializeIphlp();
    return;    
}

/*++

Routine Description

    Initialize RASMAN Service including:
    starting threads, control blocks,
    resource pools etc.

Arguments

Return Value

    SUCCESS
    Non zero - any error

--*/
DWORD
InitRasmanService ( LPDWORD pNumPorts )
{
    DWORD       retcode ;
    HKEY        hkey = NULL;

    TraceHandle = (DWORD) -1;

    do
    {

        RasmanShuttingDown = TRUE;

        HLsa = NULL;
        hIoCompletionPort = NULL;
        hinstIphlp = NULL;
        hinstPpp = NULL;
        g_hReqBufferMutex = NULL;
        g_hSendRcvBufferMutex = NULL;
        TraceHandle = INVALID_TRACEID;
        
        
        g_fRasRpcInitialized = FALSE;
        g_fPcbLockInitialized = FALSE;
        //
        // Read the registrykey to enable tracing
        //
        if ( ERROR_SUCCESS == RegOpenKeyEx(
                               HKEY_LOCAL_MACHINE,
                               "System\\CurrentControlSet\\Services\\Rasman\\Parameters",
                               0,
                               KEY_QUERY_VALUE | KEY_READ,
                               &hkey))
        {
            DWORD dwType;
            DWORD cbData;
            DWORD dwRasDebug;

            cbData = sizeof ( DWORD );

            if ( ERROR_SUCCESS == RegQueryValueEx (
                                    hkey,
                                    "ProhibitIpSec",
                                    NULL,
                                    &dwType,
                                    (LPBYTE) &dwRasDebug,
                                    &cbData))
            {                                    
                g_dwProhibitIpsec = dwRasDebug;
            }
            else
            {
                g_dwProhibitIpsec = 0;
            }
            

#if DBG
            if ( ERROR_SUCCESS == RegQueryValueEx (
                                    hkey,
                                    "RasDebug",
                                    NULL,
                                    &dwType,
                                    (LPBYTE) &dwRasDebug,
                                    &cbData))
                g_dwRasDebug = dwRasDebug;
#endif
        }

        if ( NULL != hkey)
        {
            RegCloseKey ( hkey );
        }


        hLogEvents = RouterLogRegister(ROUTER_SERVICE_NAME);

        if (NULL == hLogEvents)
        {
            retcode = GetLastError();

            RasmanDebugTrace1(
                    "RASMANS: RouterLogRegister Failed.  %d\n",
                    retcode);

            // break;
            //
            // This should not be a fatal error. We should continue.
            //
            retcode = SUCCESS;
        }

        //
        // Initialize Critical Section to synchronize
        // submit Request rpc thread and the worker thread
        //
        InitializeCriticalSection (&g_csSubmitRequest);

        if(SUCCESS != (retcode = DwStartNdiswan()))
        {
            RasmanDebugTrace("RASMANS: couldn't start ndiswan\n");

            if(ERROR_FILE_NOT_FOUND == retcode)
            {
                //
                // This means ndiswan is not loaded yet. We will
                // still go ahead and try to start rasman. We will
                // attempt starting ndiswan when required.
                //
                retcode = SUCCESS;
            }
            else
            {
                break;
            }
        }

        //
        // Initialize CPBs
        //
        InitializeListHead( &ClientProcessBlockList );

        //
        // initialize the global overlapped events
        //
        InitializeOverlappedEvents();

        ReceiveBuffers = NULL;

        //
        // First of all create a security attribute struct used
        // for all Rasman object creations:
        //
        if (retcode = InitRasmanSecurityAttribute())
        {
            RouterLogErrorString (
                        hLogEvents,
                        ROUTERLOG_CANNOT_INIT_SEC_ATTRIBUTE,
                        0, NULL, retcode, 0) ;

            RasmanDebugTrace1 (
                    "RASMANS: Failed to initialize security "
                    "attributes. %d\n",
                    retcode );


            break ;
        }

        //
        // Load all the medias attached to RASMAN
        //
        if (retcode = InitializeMediaControlBlocks())
        {
            RouterLogErrorString (hLogEvents,
                                  ROUTERLOG_CANNOT_GET_MEDIA_INFO,
                                  0, NULL, retcode, 0) ;

            RasmanDebugTrace1 (
                "RASMANS: InitializeMediaControlBlocks failed. %d\n",
                retcode );

            break ;
        }

        g_pDeviceInfoList = NULL;

        InitializeCriticalSection(&PcbLock);

        g_fPcbLockInitialized = TRUE;

        //
        // Init all the port related structures.
        //
        if (retcode = InitializePortControlBlocks())
        {
            RouterLogErrorString (hLogEvents,
                                  ROUTERLOG_CANNOT_GET_PORT_INFO,
                                  0, NULL, retcode, 0) ;

            RasmanDebugTrace1 (
                "RASMANS: InitializePortControlBlocks Failed. %d\n",
                retcode );

            break ;
        }

        //
        // Initialize the global receive buffers.
        //
        if (retcode = InitializeRecvBuffers())
        {

            RouterLogErrorString (hLogEvents,
                                  ROUTERLOG_CANNOT_GET_PORT_INFO,
                                  0, NULL, retcode, 0) ;

            RasmanDebugTrace1 (
                "RASMANS: InitializeRecvBuffers Failed. %d\n",
                retcode );

            break ;
        }

        g_cNbfAllocated = 0;

        //
        // Initialize protocol information structures.
        //
        if (retcode = InitializeProtocolInfoStructs())
        {
            RouterLogErrorString (hLogEvents,
                                  ROUTERLOG_CANNOT_GET_PROTOCOL_INFO,
                                  0, NULL, retcode, 0) ;

            RasmanDebugTrace1 (
                "RASMANS: InitializeProtocolInfoStructs Failed. %d\n",
                retcode );

            break ;
        }

        //
        // LSA related initializations.
        //
        if (retcode = RegisterLSA ())
        {
            RouterLogErrorString (hLogEvents,
                                  ROUTERLOG_CANNOT_REGISTER_LSA,
                                  0, NULL, retcode, 0) ;

            RasmanDebugTrace1("RASMANS: RegisterLSA Failed. %d\n",
                              retcode );

            break ;
        }

        if ((g_hReqBufferMutex =
            CreateMutex ( &RasmanSecurityAttribute,
                          FALSE,
                          REQBUFFERMUTEXOBJECT)) == NULL)
        {
            retcode = GetLastError();

            RouterLogErrorString (hLogEvents,
                                  ROUTERLOG_CANNOT_INIT_BUFFERS,
                                  0, NULL, retcode, 0) ;

            RasmanDebugTrace1 (
                "RASMANS: Failed to create REQBUFFERMUTEXOBJECT. %d\n",
                retcode );

            break ;

        }

        if ((g_hSendRcvBufferMutex =
            CreateMutex ( &RasmanSecurityAttribute,
                          FALSE,
                          SENDRCVMUTEXOBJECT)) == NULL )
        {
            retcode = GetLastError();

            RouterLogErrorString (hLogEvents,
                                  ROUTERLOG_CANNOT_INIT_BUFFERS,
                                  0, NULL, retcode, 0) ;

            RasmanDebugTrace1(
                "RASMANS: Failed to create SENDRCVMUTEXOBJECT. %d\n",
                retcode );

            break ;
        }


        hDummyOverlappedEvent = CreateEvent(&RasmanSecurityAttribute,
                                            FALSE, FALSE,
                                            NULL);
        if (NULL == hDummyOverlappedEvent)
        {

            retcode = GetLastError();

            RasmanDebugTrace1(
                "RASMANS: Failed to Create hDummyOverlappedEvent. %d\n",
                retcode );

            break;

        }

        //
        // set the low order bit of the event handle.
        //
        hDummyOverlappedEvent =
            (HANDLE) (((ULONG_PTR) hDummyOverlappedEvent) | LOW_ORDER_BIT);

        g_dwAttachedCount = 0;

        InitializeListHead(&ConnectionBlockList);

        InitializeListHead(&BundleList);

        g_pPnPNotifierList = NULL;

        g_dwRasAutoStarted = 0;

        //
        // Allocate resources to be used with the Request Thread:
        //
        if (retcode = InitializeRequestThreadResources())
        {

            RouterLogErrorString (hLogEvents,
                                  ROUTERLOG_CANNOT_INIT_REQTHREAD,
                                  0, NULL, retcode, 0) ;

            RasmanDebugTrace1(
                "RASMANS: Failed to InitializeRequestThreadResources. %d\n",
                retcode );

            break ;
        }

        RasmanShuttingDown = FALSE;

        //
        // Load PPP entry points
        //
        hinstPpp = LoadLibrary( "rasppp.dll" );

        if (hinstPpp == (HINSTANCE) NULL)
        {
            retcode = GetLastError();

            RasmanDebugTrace2(
                "RASMANS: Logging Event. hLogEvents=0x%x. retcode = %d\n",
                hLogEvents,
                retcode);

            RouterLogErrorString(hLogEvents,
                                 ROUTERLOG_CANNOT_INIT_PPP,
                                 0,NULL,retcode, 0);

            break;
        }

        RasStartPPP     = GetProcAddress( hinstPpp, "StartPPP" );
        RasStopPPP      = GetProcAddress( hinstPpp, "StopPPP" );

        RasPppHalt  = GetProcAddress(hinstPpp, "PppStop");

        RasSendPPPMessageToEngine = GetProcAddress(
                                      hinstPpp,
                                      "SendPPPMessageToEngine" );

        if (    (RasStartPPP == NULL)
            ||  (RasStopPPP == NULL)
            ||  (RasPppHalt == NULL)
            ||  (RasSendPPPMessageToEngine == NULL))
        {
            retcode = GetLastError();

            RouterLogErrorString(hLogEvents,
                                 ROUTERLOG_CANNOT_INIT_PPP,
                                 0,NULL,retcode, 0);

            RasmanDebugTrace1(
                "RASMANS: Failed to Get PPP entry point. %d\n",
                retcode );

            break;
        }

        g_PppeMessage = LocalAlloc (LPTR, sizeof (PPPE_MESSAGE));

        if (NULL == g_PppeMessage)
        {
            retcode = GetLastError();
            break;
        }

        *pNumPorts = MaxPorts;

        //
        // Initialize rpc server and listen
        //
        retcode = InitializeRasRpc();

        if (retcode)
        {
            RouterLogErrorString( hLogEvents,
                                  ROUTERLOG_CANNOT_INIT_RASRPC,
                                  0, NULL, retcode, 0);

            RasmanDebugTrace1 (
                "RASMANS: Failed to initialize RasRpc. %d\n",
                retcode );

            break;
        }

        g_fRasRpcInitialized = TRUE;

        //
        // Initialize rasman and rasapi32 entry points
        //
        if (retcode = LoadRasmanDll())
        {
            RouterLogErrorString( hLogEvents,
                                  ROUTERLOG_CANNOT_INIT_RASRPC,
                                  0, NULL, retcode, 0);

            RasmanDebugTrace1(
                "RASMANS: Failed to load rasman. %d\n",
                retcode);

            break;
        }

        //
        // Initialize rasman dll.
        //
        if (retcode = g_pRasInitializeNoWait())
        {
            RouterLogErrorString( hLogEvents,
                                  ROUTERLOG_CANNOT_INIT_RASRPC,
                                  0, NULL, retcode, 0);

            RasmanDebugTrace1 (
                "RASMANS: Failed to initialize RAS. %d\n",
                retcode);

            break;
        }

        if (retcode = LoadRasapi32Dll())
        {
            RouterLogErrorString( hLogEvents,
                                  ROUTERLOG_CANNOT_INIT_RASRPC,
                                  0, NULL, retcode, 0);

            RasmanDebugTrace1 (
                "RASMANS: Failed to load rasapi32. %d\n",
                retcode );

            break;
        }

        g_pReqPostReceive = LocalAlloc (LPTR, sizeof(REQTYPECAST));

        if (NULL == g_pReqPostReceive)
        {
            retcode = GetLastError();

            break;
        }

        g_pReqPostReceive->PortReceive.buffer =
                        LocalAlloc ( LPTR, REQUEST_BUFFER_SIZE ) ;

        if (NULL == g_pReqPostReceive->PortReceive.buffer)
        {
            retcode = GetLastError();
            break;
        }

        g_pReqPostReceive->PortReceive.pid = GetCurrentProcessId();

        //
        // Initialize the list of Bap buffers to NULL
        //
        BapBuffers = NULL;

#if SENS_ENABLED

        //
        // Tell sens that we are on
        //
        SendSensNotification(SENS_NOTIFY_RAS_STARTED, NULL);

#endif

        g_RasEvent.Type    = SERVICE_EVENT;
        g_RasEvent.Event   = RAS_SERVICE_STARTED;
        g_RasEvent.Service = RASMAN;

        g_hWanarp = INVALID_HANDLE_VALUE;

        (void) DwSendNotificationInternal(NULL, &g_RasEvent);

        TraceHandle = TraceRegister("RASMAN");

        hinstRasAudio = NULL;

    } while (FALSE);


    //DbgPrint("RASMANS: InitRasmanService done. rc=0x%x\n", retcode);

    if(SUCCESS != retcode)
    {   
        RasmanCleanup();
    }

    return retcode ;
}

/*++

Routine Description

    Get the endpoint resource information from the RASHUB and
    fill in the EndpointMappingBlock structure array - so that
    there is one block for each MAC. An array of flags indicating
    if a endpoint is in use is also created.

Arguments

Return Value

    SUCCESS
    ERROR_NO_ENDPOINTS

--*/
DWORD
InitializeEndpointInfo ()
{
    return SUCCESS ;
}


/*++

Routine Description

    Used to initialize the MCBs for all the medias attached to
    RASMAN.

Arguments

Return Value

    SUCCESS
    error codes returned by LocalAlloc or registry APIs

--*/
DWORD
InitializeMediaControlBlocks ()
{
    WORD            i ;
    DWORD           retcode = 0 ;
    DWORD           dwsize ;
    DWORD           dwentries ;
    BYTE            buffer[MAX_BUFFER_SIZE]  ;
    PBYTE           enumbuffer = NULL;
    MediaEnumBuffer *pmediaenumbuffer ;

    //
    // Get Media information from the Registry
    //
    pmediaenumbuffer = (MediaEnumBuffer *)&buffer ;

    if (retcode = ReadMediaInfoFromRegistry (pmediaenumbuffer))
    {
        return retcode ;
    }

    MaxMedias = pmediaenumbuffer->NumberOfMedias ;

    //
    // Allocate memory for the Media Control Blocks
    //
    Mcb =  (MediaCB *) LocalAlloc(
                        LPTR,
                        sizeof(MediaCB) * MaxMedias) ;

    if (Mcb == NULL)
    {
        return GetLastError() ;
    }

    //
    // Initialize the Media Control Buffers for all the Medias
    //
    for (i = 0; i < MaxMedias; i++)
    {
        //
        // Copy Media name:
        //
        strcpy (
            Mcb[i].MCB_Name,
            pmediaenumbuffer->MediaInfo[i].MediaDLLName) ;

        dwsize = 0 ;
        dwentries = 0 ;

        //
        // Load the Media DLL and get all the entry points:
        //
        if (retcode = LoadMediaDLLAndGetEntryPoints (&Mcb[i]))
        {
#if DBG
            DbgPrint("RASMANS: Failed to load %s. 0x%x\n",
                     Mcb[i].MCB_Name, retcode);
#endif
            Mcb[i].MCB_Name[0] = '\0' ;
            continue ;
        }

        //
        // Get port count for the media. This API will always fail -
        // because we do not supply a buffer - however it will tell
        // us the number of entries (ports) for
        // the media
        //
        retcode = PORTENUM((&Mcb[i]),enumbuffer,&dwsize,&dwentries) ;

        //
        // if we didnt get BUFFER_TOO_SMALL or there are no ports
        // - unload the dll.
        //
        if (    (retcode != ERROR_BUFFER_TOO_SMALL)
            |   (dwentries == 0))
        {
            //
            // Mark that media as bogus.
            //
            Mcb[i].MCB_Name[0] = '\0' ;

            FreeLibrary (Mcb[i].MCB_DLLHandle);

        }
    }

    LocalFree (enumbuffer) ;

    return SUCCESS ;
}


DWORD
ReadMediaInfoFromRegistry (MediaEnumBuffer *medias)
{
    HKEY    hkey  = NULL;
    // BYTE    buffer [MAX_BUFFER_SIZE] ;
    WORD    i ;
    PCHAR   pvalue ;
    DWORD   retcode ;
    DWORD   type ;
    DWORD   size = MAX_BUFFER_SIZE ;
	BYTE    *pBuffer;
	    
	pBuffer = LocalAlloc(LPTR, MAX_BUFFER_SIZE);

	if(NULL == pBuffer)
	{
	    return GetLastError();
	}

    if (retcode = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    RASMAN_REGISTRY_PATH, 0,
                    KEY_QUERY_VALUE, &hkey))
    {
        goto done;
    }

    if (retcode = RegQueryValueEx (
                        hkey, RASMAN_PARAMETER,
                        NULL,
                        &type,
                        pBuffer,
                        &size))
    {
        goto done ;
    }

    //
    // Parse the multi strings into the medias structure
    //
    for (i = 0, pvalue = (PCHAR) &pBuffer[0]; *pvalue != '\0'; i++)
    {
        strcpy (medias->MediaInfo[i].MediaDLLName, pvalue) ;

        pvalue += (strlen(pvalue) +1) ;
    }

    medias->NumberOfMedias = i ;

done:
    if ( hkey )
        RegCloseKey (hkey) ;

    LocalFree(pBuffer);

    return retcode ;
}




/*++

Routine Description

    Loads media DLL and gets entry points:

Arguments

Return Value

    SUCCESS
    error codes returned by LoadLibrary()
    and GetProcAddress() APIs

--*/
DWORD
LoadMediaDLLAndGetEntryPoints (pMediaCB media)
{
    WORD    i ;
    HANDLE  modulehandle ;

    //
    // MediaDLLEntryPoints - This is necessary for
    // loading Media DLL.
    //
    MediaDLLEntryPoints MDEntryPoints [] =
    {

        PORTENUM_STR,                   PORTENUM_ID,
        PORTOPEN_STR,                   PORTOPEN_ID,
        PORTCLOSE_STR,                  PORTCLOSE_ID,
        PORTGETINFO_STR,                PORTGETINFO_ID,
        PORTSETINFO_STR,                PORTSETINFO_ID,
        PORTDISCONNECT_STR,             PORTDISCONNECT_ID,
        PORTCONNECT_STR,                PORTCONNECT_ID,
        PORTGETPORTSTATE_STR,           PORTGETPORTSTATE_ID,
        PORTCOMPRESSSETINFO_STR,        PORTCOMPRESSSETINFO_ID,
        PORTCHANGECALLBACK_STR,         PORTCHANGECALLBACK_ID,
        PORTGETSTATISTICS_STR,          PORTGETSTATISTICS_ID,
        PORTCLEARSTATISTICS_STR,        PORTCLEARSTATISTICS_ID,
        PORTSEND_STR,                   PORTSEND_ID,
        PORTTESTSIGNALSTATE_STR,        PORTTESTSIGNALSTATE_ID,
        PORTRECEIVE_STR,                PORTRECEIVE_ID,
        PORTINIT_STR,                   PORTINIT_ID,
        PORTCOMPLETERECEIVE_STR,        PORTCOMPLETERECEIVE_ID,
        PORTSETFRAMING_STR,             PORTSETFRAMING_ID,
        PORTGETIOHANDLE_STR,            PORTGETIOHANDLE_ID,
        PORTSETIOCOMPLETIONPORT_STR,    PORTSETIOCOMPLETIONPORT_ID,
    } ;

    //
    // Load the DLL:
    //
    if ((modulehandle = LoadLibrary(media->MCB_Name)) == NULL)
    {
        return GetLastError () ;
    }

    media->MCB_DLLHandle = modulehandle ;

    //
    // Get all the media DLL entry points:
    //
    for (i = 0; i < MAX_MEDIADLLENTRYPOINTS; i++)
    {
        media->MCB_AddrLookUp[i] = GetProcAddress (
                                    modulehandle,
                                    MDEntryPoints[i].name) ;

    }

    //
    // If the media is rastapi load the functions we use for
    // pnp
    //
    if (0 == _stricmp(media->MCB_Name, TEXT("rastapi")))
    {
        if(     (NULL == (RastapiAddPorts =
                            GetProcAddress(modulehandle,
                                           "AddPorts")))
            ||  (NULL == (RastapiGetConnectInfo =
                            GetProcAddress(
                                    modulehandle,
                                    "GetConnectInfo")))

            ||  (NULL == (RastapiRemovePort =
                            GetProcAddress(modulehandle,
                                           "RemovePort")))

            ||  (NULL == (RastapiEnableDeviceForDialIn =
                            GetProcAddress(modulehandle,
                                "EnableDeviceForDialIn")))

            ||  (NULL == (RastapiGetCalledIdInfo =
                            GetProcAddress(modulehandle,
                                "RastapiGetCalledID")))

            ||  (NULL == (RastapiSetCalledIdInfo =
                            GetProcAddress(modulehandle,
                                "RastapiSetCalledID")))

            ||  (NULL == (RastapiGetZeroDeviceInfo =
                            GetProcAddress(modulehandle,
                                "GetZeroDeviceInfo")))
            ||  (NULL == (RastapiUnload = 
                            GetProcAddress(modulehandle,
                                    "UnloadRastapiDll")))
            ||  (NULL == (RastapiSetCommSettings =
                            GetProcAddress(modulehandle,
                                    "SetCommSettings")))
            ||  (NULL == (RastapiGetDevConfigEx =
                            GetProcAddress(modulehandle,
                                    "DeviceGetDevConfigEx"))))
        {
            DWORD dwErr = GetLastError();
#if DBG
            DbgPrint("Failed to GetProcAddress AddPorts/RemovePort"
                    "/EnableDeviceForDialIn. 0x%08x\n", dwErr);
#endif
            return dwErr;
        }
    }

    return SUCCESS ;
}


/*++

Routine Description

    Unloads all dynamically loaded media DLLs.

Arguments

Return Value

--*/
VOID
UnloadMediaDLLs ()
{
    DWORD i;

    for (i = 0; i < MaxMedias; i++)
    {
        if (    *Mcb[i].MCB_Name != '\0'
            &&  Mcb[i].MCB_DLLHandle != NULL)
        {
            if (0 == _stricmp(Mcb[i].MCB_Name, TEXT("rastapi")))
            {
                RastapiUnload();
            }
            
            FreeLibrary(Mcb[i].MCB_DLLHandle);
        }
    }
}

/*++

Routine Description

    Initializes all the PCBs for ports belonging to all medias.

Arguments

Return Value

    SUCCESS
    Return codes from WIN32 resources APIs

--*/
DWORD
InitializePortControlBlocks ()
{
    WORD            i ;
    DWORD           dwsize ;
    DWORD           dwentries ;
    DWORD           retcode ;
    PBYTE           buffer;
    PortMediaInfo   *pportmediainfo ;
    DWORD           dwnextportid = 0    ;


    //
    // Create the I/O completion port that
    // is used by the media DLLs.
    //
    hIoCompletionPort = CreateIoCompletionPort(
                          RasHubHandle,
                          NULL,
                          0,
                          0);

    if (hIoCompletionPort == NULL)
    {
        return GetLastError();
    }

    //
    // Initialize PCBs for all ports for all the Medias
    //
    for (i = 0; i < MaxMedias; i++)
    {
        //
        // Check if media could not be loaded, or if it
        // equals a media DLL that we no longer support.
        // If so, skip it.
        //
        if (Mcb[i].MCB_Name[0] == '\0')
        {
            continue ;
        }

        PORTSETIOCOMPLETIONPORT((&Mcb[i]), hIoCompletionPort);

        //
        // For the Media Loaded - Get all the port info
        // from the Media DLL. First get the size
        //
        dwsize      = 0 ;
        dwentries   = 0 ;

        PORTENUM((&Mcb[i]),NULL,&dwsize,&dwentries) ;

        dwsize = dwentries * sizeof(PortMediaInfo) ;

        //
        // Allocate memory for the portenum buffer
        //
        buffer = (BYTE *) LocalAlloc (LPTR, dwsize) ;

        if (buffer == NULL)
        {
            return GetLastError() ;
        }

        if (retcode = PORTENUM((&Mcb[i]), buffer, &dwsize, &dwentries))
        {
            LocalFree (buffer) ;
            return retcode ;
        }

        //
        // For all ports of the media store the information
        // in the PCBs
        //
        pportmediainfo = (PortMediaInfo *) buffer ;

        //
        // Initialize the PCB for the port with the information:
        //
        if (retcode = InitializePCBsPerMedia(
                                    i,
                                    dwentries,
                                    pportmediainfo) )
        {
            LocalFree (buffer) ;
            return retcode ;
        }

        LocalFree (buffer) ;

    }

    return SUCCESS ;
}

/*++

Routine Description

    Allocates a recv buffer for each port.  These
    recv buffers are then submitted to ndiswan when a
    port is opened by the client.

Arguments

Return Value

    SUCCESS
    Return codes from WIN32 resources APIs

--*/

DWORD
InitializeRecvBuffers()
{
    DWORD   AllocationSize;
    DWORD   retcode = PENDING;
    PUCHAR  AllocatedMemory;
    RasmanPacket *Packet;

    //
    // Check to see if we are already
    // initialized
    //
    if (ReceiveBuffers != NULL) {
        return SUCCESS;
    }

    ReceiveBuffers = LocalAlloc (
                        LPTR,
                        sizeof(ReceiveBufferList));

    if (NULL == ReceiveBuffers) {
        retcode = GetLastError();
        goto done;
    }

    Packet = LocalAlloc (LPTR, sizeof (RasmanPacket));

    if (NULL == Packet) {
        retcode = GetLastError();
        goto done;
    }

    ReceiveBuffers->Packet = Packet;

    retcode = SUCCESS;

done:
    return(retcode);
}

/*++

Routine Description

    Fills up the PCBs for all ports of a media type.

Arguments

Return Value

    SUCCESS
    Return codes from WIN32 resources APIs

--*/
DWORD
InitializePCBsPerMedia (
    WORD   mediaindex,
    DWORD   dwnumofports,
    PortMediaInfo *pmediainfo
    )
{
    DWORD    i ;
    DeviceInfo *pdi = NULL;
    DeviceInfo *pdiTemp;

    for (i = 0 ; i < dwnumofports ; i++)
    {
        pdiTemp = pmediainfo->PMI_pDeviceInfo;

        //
        // Add the deviceinfo about this device
        // if we don't have it already
        //
        if (pdiTemp)
        {
            if (NULL == (pdi = GetDeviceInfo(
                    (RDT_Modem ==
                        RAS_DEVICE_TYPE(
                        pdiTemp->rdiDeviceInfo.eDeviceType
                        ))
                    ? (PBYTE) pdiTemp->rdiDeviceInfo.szDeviceName
                    : (PBYTE) &pdiTemp->rdiDeviceInfo.guidDevice,
                    RDT_Modem ==
                        RAS_DEVICE_TYPE(
                        pdiTemp->rdiDeviceInfo.eDeviceType
                        ))))
            {
                pdi = AddDeviceInfo(pdiTemp);

                if(NULL == pdi)
                {
                    //
                    // In case of memory allocation failure
                    // we just drop this device - this device
                    // won't be in the list. Can't do anything
                    // else in this case..
                    //
                    return GetLastError();
                }

                //
                // Initialize this device to be
                // not available. This device will
                // be available when all ports on
                // this device are added. Initialize
                // the current number of endpoints on
                // this device to 0. We will count the
                // current endpoints in CreatePort
                //
                pdi->eDeviceStatus = DS_Unavailable;
                pdi->dwCurrentEndPoints = 0;
            }

            pmediainfo->PMI_pDeviceInfo = pdi;
        }


        //
        // The iteration here is per media - in
        // order to map the interation counter
        // to the real PCB array index we use
        // portnumber:
        //
        CreatePort(&Mcb[mediaindex], pmediainfo);

        pmediainfo->PMI_pDeviceInfo = pdiTemp;

        pmediainfo++ ;
    }

    //
    // There may still be devices in rastapi layer
    // with 0 endpoints - like pptp/l2tp. There
    // won't be ports reported for thse devices.
    // So, get these from rastapi.
    //
    if(0 == _stricmp(Mcb[mediaindex].MCB_Name,
                    "rastapi"))
    {
        DeviceInfo **ppDeviceInfo = NULL;
        DWORD      cDeviceInfo = 0;

        RastapiGetZeroDeviceInfo(&cDeviceInfo,
                                 &ppDeviceInfo);

        for(i = 0; i < cDeviceInfo; i++)
        {
            pdiTemp = ppDeviceInfo[i];

            AddDeviceInfo(pdiTemp);
        }

        if(ppDeviceInfo)
        {
            LocalFree(ppDeviceInfo);
        }
    }

    return SUCCESS ;
}

/*++

Routine Description

    Create a new port and add it to the list of ports

Arguments

Return Value

    SUCCESS
    Non Zero (failure)

--*/
DWORD
CreatePort(
    MediaCB *pMediaControlBlock,
    PortMediaInfo *pPortMediaInfo
    )
{
    DWORD dwErr = SUCCESS;
    PCB **pNewPcb, *ppcb = NULL;

    //
    // Acquire the PCB lock.
    //
    EnterCriticalSection(&PcbLock);

    //
    // Check to see if we need to
    // reallocate the port index list.
    //
    if (MaxPorts == PcbEntries)
    {
        pNewPcb = LocalAlloc(
                    LPTR,
                    (PcbEntries + 10) * sizeof (pPCB));

        if (pNewPcb == NULL)
        {
            dwErr = GetLastError();
            goto done;
        }

        if (PcbEntries)
        {
            RtlCopyMemory(
                pNewPcb,
                Pcb,
                PcbEntries * sizeof (pPCB));

            LocalFree(Pcb);
        }

        Pcb = pNewPcb;
        PcbEntries += 10;
    }

    //
    // Allocate a new port control block.
    //
    ppcb = LocalAlloc(LPTR, sizeof (PCB));
    if (ppcb == NULL)
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Initialize the new port control block.
    //
    ppcb->PCB_PortHandle        = (HANDLE) UlongToPtr(MaxPorts);
    ppcb->PCB_PortStatus        = UNAVAILABLE;
    ppcb->PCB_ConfiguredUsage   = pPortMediaInfo->PMI_Usage;
    ppcb->PCB_CurrentUsage      = CALL_NONE;
    ppcb->PCB_OpenedUsage       = CALL_NONE;
    ppcb->PCB_LineDeviceId      = pPortMediaInfo->PMI_LineDeviceId;
    ppcb->PCB_AddressId         = pPortMediaInfo->PMI_AddressId;
    ppcb->PCB_Media             = pMediaControlBlock;
    ppcb->PCB_Bindings          = NULL;
    ppcb->PCB_DeviceList        = NULL;
    ppcb->PCB_LinkHandle        = INVALID_HANDLE_VALUE;
    ppcb->PCB_BundleHandle      = INVALID_HANDLE_VALUE;
    ppcb->PCB_PppEvent          = INVALID_HANDLE_VALUE;
    ppcb->PCB_IoCompletionPort  = INVALID_HANDLE_VALUE;
    ppcb->PCB_pDeviceInfo       = pPortMediaInfo->PMI_pDeviceInfo;

    ppcb->PCB_AsyncWorkerElement.WE_ReqType = REQTYPE_NONE;

    strcpy (
        ppcb->PCB_Name,
        pPortMediaInfo->PMI_Name);

    strcpy(
        ppcb->PCB_DeviceType,
        pPortMediaInfo->PMI_DeviceType);

    strcpy(
        ppcb->PCB_DeviceName,
        pPortMediaInfo->PMI_DeviceName);

    //
    // Activate the port and increment the
    // maximum ports count.
    //
    Pcb[MaxPorts++] = ppcb;

    //
    // Increment the CurrenEndpoint count
    // for this adapter.
    //
    if(RDT_Modem == RAS_DEVICE_TYPE(
            ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType))
    {            
        ppcb->PCB_pDeviceInfo->dwCurrentEndPoints = 1;
    }
    else
    {
        ppcb->PCB_pDeviceInfo->dwCurrentEndPoints += 1;
    }

#if DBG
    if ( g_dwRasDebug )
    {
        DbgPrint(
          "RASMANS: Created Port Name %s, Device "
          "Name %s, Device Type %s\n",
          ppcb->PCB_Name,
          ppcb->PCB_DeviceName,
          ppcb->PCB_DeviceType) ;
    }

    ASSERT(ppcb->PCB_pDeviceInfo->dwCurrentEndPoints <=
            ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwNumEndPoints);

    if(ppcb->PCB_pDeviceInfo->dwCurrentEndPoints >
        ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwNumEndPoints)
    {
        DbgPrint("CurrentEndPoints=%d > NumEndPoints=%d!!\n",
            ppcb->PCB_pDeviceInfo->dwCurrentEndPoints,
            ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwNumEndPoints);
    }

#endif

    //
    // Change device status if done adding all
    // ports for this device. This will happen
    // when user checks the box and enables the
    // device for ras where it was previously
    // disabled.
    //
    if(     (ppcb->PCB_pDeviceInfo->dwCurrentEndPoints ==
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwNumEndPoints)
        &&  (  (DS_Unavailable == ppcb->PCB_pDeviceInfo->eDeviceStatus)
            || (DS_Disabled == ppcb->PCB_pDeviceInfo->eDeviceStatus)
            || (DS_Removed == ppcb->PCB_pDeviceInfo->eDeviceStatus)))
    {
        //
        // mark the device as available and enabled for Ras
        //
        ppcb->PCB_pDeviceInfo->eDeviceStatus = DS_Enabled;

        ppcb->PCB_pDeviceInfo->fValid = TRUE;
        
    }
    else if(    (RDT_Tunnel_Pptp == RAS_DEVICE_TYPE(
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.eDeviceType))
            &&  (DS_Unavailable ==
                ppcb->PCB_pDeviceInfo->eDeviceStatus))
    {
        //
        // Enable the device if we have even one pptp port. 
        // This is being done since ow we run into a problem 
        // when some one increases the wan miniport count 
        // for pptp to more than what the driver has and 
        // we will fail pptp in that case.
        //
        ppcb->PCB_pDeviceInfo->eDeviceStatus = DS_Enabled;

        ppcb->PCB_pDeviceInfo->fValid = TRUE;
    }

    EnablePort(ppcb->PCB_PortHandle);

done:
    if (dwErr)
    {
        if (ppcb)
            LocalFree(ppcb);
        Pcb[MaxPorts] = NULL;
    }

    LeaveCriticalSection(&PcbLock);

    return dwErr;
}


/*++

Routine Description

    Enables a port

Arguments

Return Value

    SUCCESS
    Non Zero (failure)

--*/
DWORD
EnablePort(
    HPORT hPortHandle
    )
{
    DWORD dwErr = SUCCESS;
    pPCB ppcb;
    ULONG hPort = HandleToUlong(hPortHandle);

    EnterCriticalSection(&PcbLock);
    ppcb = Pcb[hPort];
    if (ppcb == NULL)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto done;
    }

    if (ppcb->PCB_PortStatus != UNAVAILABLE)
    {
        dwErr = ERROR_PORT_NOT_AVAILABLE;
        goto done;
    }

    ppcb->PCB_PortStatus = CLOSED;

#if DBG
    if ( g_dwRasDebug )
        DbgPrint(
          "RASMANS: Enabled Port Name %s, Device Name %s,"
          " Device Type %s\n",
          ppcb->PCB_Name,
          ppcb->PCB_DeviceName,
          ppcb->PCB_DeviceType) ;
#endif

done:

    LeaveCriticalSection(&PcbLock);

    return dwErr;
}


/*++

Routine Description

    Temporarily disables a port

Arguments

Return Value

    SUCCESS
    Non Zero (failure)

--*/
DWORD
DisablePort(
    HPORT hPortHandle
    )
{
    DWORD dwErr = SUCCESS;
    pPCB ppcb;
    ULONG hPort = HandleToUlong(hPortHandle);

    EnterCriticalSection(&PcbLock);

    ppcb = Pcb[hPort];

    if (ppcb == NULL)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto done;
    }

    if (ppcb->PCB_PortStatus == OPEN)
    {
        dwErr = ERROR_PORT_NOT_AVAILABLE;
        goto done;
    }

    ppcb->PCB_PortStatus = UNAVAILABLE;

#if DBG
    DbgPrint(
      "RASMANS: Disabled Port Name %s, Device Name %s,"
      " Device Type %s\n",
      ppcb->PCB_Name,
      ppcb->PCB_DeviceName,
      ppcb->PCB_DeviceType) ;
#endif

done:

    LeaveCriticalSection(&PcbLock);
    return dwErr;
}

/*++

Routine Description

    Permanently removes a port

Arguments

Return Value

    SUCCESS
    Non Zero (failure)

--*/
DWORD
RemovePort(
    HPORT hPortHandle
    )
{
    DWORD dwErr = SUCCESS;
    pPCB ppcb;
    ULONG hPort = HandleToUlong(hPortHandle);

    EnterCriticalSection(&PcbLock);

    ppcb = Pcb[hPort];

    if (ppcb == NULL)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto done;
    }

    if (ppcb->PCB_PortStatus == OPEN)
    {
        dwErr = ERROR_PORT_NOT_AVAILABLE;
        goto done;
    }

    ppcb->PCB_PortStatus = REMOVED;

    if(ppcb->PCB_pDeviceInfo->dwCurrentEndPoints)
    {
        ppcb->PCB_pDeviceInfo->dwCurrentEndPoints -= 1;
    }

    if(     (0 == ppcb->PCB_pDeviceInfo->dwCurrentEndPoints)
        &&  (ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwMaxWanEndPoints ==
             ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwMinWanEndPoints))
    {
        //
        // The last of the endpoints on this device
        // has been removed. Invalidate the device
        //
        ppcb->PCB_pDeviceInfo->fValid = FALSE;

        ppcb->PCB_pDeviceInfo->eDeviceStatus = DS_Disabled;
    }

    //
    // Change the device status if we are done removing
    // all ports of this device. This will happen when
    // the user unchecks the box from the ui and disables
    // this device for usage with ras.
    //
    if(     ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwNumEndPoints ==
            ppcb->PCB_pDeviceInfo->dwCurrentEndPoints
        &&  DS_Unavailable == ppcb->PCB_pDeviceInfo->eDeviceStatus)
    {
        if(ppcb->PCB_pDeviceInfo->dwCurrentEndPoints)
        {
            ppcb->PCB_pDeviceInfo->eDeviceStatus = DS_Enabled;
        }
        else
        {
            ppcb->PCB_pDeviceInfo->eDeviceStatus = DS_Disabled;
        }
    }


#if DBG

    DbgPrint(
      "RASMANS: Removed Port Name %s, Device Name %s,"
      " Device Type %s\n",
      ppcb->PCB_Name,
      ppcb->PCB_DeviceName,
      ppcb->PCB_DeviceType) ;

#endif

done:
    LeaveCriticalSection(&PcbLock);

    return dwErr;
}


/*++

Routine Description

    Return a port given its handle

Arguments

Return Value

    pPCB or NULL

--*/
pPCB
GetPortByHandle(
    HPORT hPortHandle
    )
{
    pPCB ppcb = NULL;
    ULONG hPort = HandleToUlong(hPortHandle);

    if ((DWORD)hPort < MaxPorts)
    {
        EnterCriticalSection(&PcbLock);

        ppcb = (    Pcb[hPort] != NULL
                &&  (Pcb[hPort]->PCB_PortStatus != REMOVED)
                    ? Pcb[hPort]
                    : NULL);

        LeaveCriticalSection(&PcbLock);
    }

    return ppcb;
}


/*++

Routine Description

    Return a port given its name

Arguments

Return Value

    pPCB or NULL

--*/
pPCB
GetPortByName(
    CHAR *pszName
    )
{
    DWORD i;
    BOOL fFound = FALSE;
    pPCB ppcb;

    EnterCriticalSection(&PcbLock);

    for (i = 0; i < MaxPorts; i++)
    {
        ppcb = Pcb[i];

        if (    ppcb != NULL
            &&  ppcb->PCB_PortStatus != REMOVED
            &&  !strcmp(ppcb->PCB_Name, pszName))
        {
            fFound = TRUE;
            break;
        }
    }

    LeaveCriticalSection(&PcbLock);
    return fFound ? ppcb : NULL;
}


/*++

Routine Description

    Free resources associated with port control blocks

Arguments

Return Value

    None
--*/
VOID
FreePorts(
    VOID
    )
{
    DWORD i;
    pPCB ppcb;

    for (i = 0; i < MaxPorts; i++)
    {
        ppcb = Pcb[i];
        if (ppcb != NULL)
        {
            LocalFree(ppcb);
        }
    }

    LocalFree(Pcb);
    PcbEntries = MaxPorts = 0;
}


/*++

Routine Description


    Initialization required for getting user credentials:

Arguments

Return Value

    SUCCESS
    Non Zero (failure)

--*/
DWORD
RegisterLSA ()
{
    NTSTATUS    ntstatus;
    STRING  LsaName;
    LSA_OPERATIONAL_MODE LSASecurityMode ;

    //
    // To be able to do authentications, we have to
    // register with the Lsa as a logon process.
    //
    RtlInitString(&LsaName, RASMAN_SERVICE_NAME);

    HLsa = NULL;

    ntstatus = LsaRegisterLogonProcess(&LsaName,
                                       &HLsa,
                                       &LSASecurityMode);

    if (ntstatus != STATUS_SUCCESS)
    {
        return (1);
    }

    //
    // We use the MSV1_0 authentication package for LM2.x
    // logons.  We get to MSV1_0 via the Lsa.  So we call
    // Lsa to get MSV1_0's package id, which we'll use in
    // later calls to Lsa.
    //
    RtlInitString(&LsaName, MSV1_0_PACKAGE_NAME);

    ntstatus = LsaLookupAuthenticationPackage(HLsa,
                                              &LsaName,
                                              &AuthPkgId);

    if (ntstatus != STATUS_SUCCESS)
    {
        return (1);
    }

    return SUCCESS;
}

static const TCHAR c_szNdisWanNbfSubstring[] = TEXT("NdisWanNbf");

static const TCHAR c_szRegKeyNbfLinkage[] =
    TEXT("System\\CurrentControlSet\\Services\\Nbf\\Linkage");

static const TCHAR c_szRegValBind[]          = TEXT("Bind");

/*++

Routine Description

    Queries a value from the registry.  Allocates the
    neccessary memory.  Free the returned buffer with free.

Arguments

Returns

    DWORD: Win32 error code

--*/

DWORD
RegQueryValueWithAlloc (
    HKEY        hkey,
    LPCTSTR     szValueName,
    DWORD*      pdwType,
    LPBYTE*     ppbBuffer,
    DWORD*      pdwSize)
{
    int     cLoop       = 0;
    int     cLoopMax    = 2;
    DWORD   dwErr       = ERROR_SUCCESS;
    DWORD   dwQuerySize = 0;
    LPBYTE  pbNewBuffer = NULL;

    ASSERT (hkey);
    ASSERT (pdwType);
    ASSERT (ppbBuffer);

    //
    // Initialize the output parameters.
    //
    *ppbBuffer = NULL;
    if (pdwSize)
    {
        *pdwSize = 0;
    }

    do
    {
        if (dwQuerySize)
        {
            pbNewBuffer = (LPBYTE)LocalAlloc (LMEM_FIXED,
                                              dwQuerySize);

            if (!pbNewBuffer)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        dwErr = RegQueryValueEx(hkey,
                                szValueName,
                                NULL,
                                pdwType,
                                pbNewBuffer,
                                &dwQuerySize);

    }
    while (     !dwErr
            &&  !pbNewBuffer
            &&  (++cLoop < cLoopMax));

    if (!dwErr)
    {
        //
        // Fill in the return values.
        //
        if (pdwSize)
        {
            *pdwSize = dwQuerySize;
        }

        *ppbBuffer = pbNewBuffer;
    }
    else
    {
        if (pbNewBuffer)
        {
            LocalFree (pbNewBuffer);
        }
    }

    return dwErr;
}


/*++

Routine Description

    Queries a string or multi-sz value from the registry.
    Allocates the neccessary memory.  Free the returned
    *ppszValue with LocalFree.

Arguments

Returns

    DWORD: Win32 error code


--*/

DWORD
RegQueryTypeSzWithAlloc (
    HKEY    hkey,
    LPCTSTR szValueName,
    DWORD   dwType,
    LPTSTR* ppszValue,
    DWORD*  pcbValue)
{
    DWORD  dwTypeRet;
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  dwErr;

    ASSERT (hkey);
    ASSERT (ppszValue);

    //
    // Only string types accepted.
    //
    ASSERT (    (REG_SZ == dwType)
            ||  (REG_MULTI_SZ == dwType));

    //
    // Get the value.
    //
    dwErr = RegQueryValueWithAlloc (hkey,
                                    szValueName,
                                    &dwTypeRet,
                                    &pbData,
                                    &cbData);

    //
    // It's type should be REG_SZ. (duh).
    //
    if (    !dwErr
        &&  (dwTypeRet != dwType))
    {
        LocalFree (pbData);
        dwErr = ERROR_INVALID_DATATYPE;
    }

    //
    // Assign the output parameters.
    //
    if (!dwErr)
    {
        *ppszValue = (LPTSTR)pbData;

        if (pcbValue)
        {
            *pcbValue = cbData;
        }
    }
    else
    {
        *ppszValue = NULL;
        if (pcbValue)
        {
            *pcbValue = 0;
        }
    }

    return dwErr;
}

/*++

Routine Description

    Returns the multi-sz bind string for a protocol.
    Free the returned string with LocalFree.

Arguments

Returns

    DWORD: Win32 error code


*/

DWORD
RegQueryBindString(
    IN  LPCTSTR pszRegKeyProtocolLinkage,
    OUT LPTSTR* ppmszBind)
{
    HKEY hkey;
    DWORD dwErr;

    ASSERT( pszRegKeyProtocolLinkage );

    dwErr = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                          pszRegKeyProtocolLinkage,
                          0,
                          KEY_READ,
                          &hkey);

    if (!dwErr)
    {
        //
        // Get the Bind string as a multi-sz.
        //
        dwErr = RegQueryTypeSzWithAlloc (hkey,
                                         c_szRegValBind,
                                         REG_MULTI_SZ,
                                         ppmszBind,
                                         NULL);

        RegCloseKey (hkey);
    }

    return dwErr;
}

DWORD
GetNbfProtocolInfo(
    ProtInfo*   paInfo,
    WORD*       pcInfo)
{
    DWORD  dwErr;
    LPTSTR pmszBind;

    //
    // If paInfo is NULL, it means return the count only.
    //
    if (!paInfo)
    {
        *pcInfo = 0;
    }
    else
    {
        ASSERT (*pcInfo);
        ZeroMemory( paInfo, sizeof(ProtInfo) * (*pcInfo));
    }

    //
    // Open the bind key of Nbf.  Count strings with
    // NdisWanNbf in them.
    //
    dwErr = RegQueryBindString (c_szRegKeyNbfLinkage, &pmszBind);

    if (!dwErr)
    {
        //
        // Iterate the multi-sz and increment for each
        // that contains "NdisWanNbf" as a substring.
        //
        LPTSTR pszBind;
        ProtInfo* pInfo = paInfo;

        for (pszBind = pmszBind;
             *pszBind;
             pszBind += lstrlen (pszBind) + 1)
        {
            if (!_tcsstr(pszBind, c_szNdisWanNbfSubstring))
            {
                continue;
            }

            //
            // Get the info.
            //
            if (paInfo)
            {
                pInfo->PI_Type = ASYBEUI;
                lstrcpyn (pInfo->PI_AdapterName,
                          _strupr(pszBind),
                          MAX_ADAPTER_NAME);
                pInfo++;
            }

            //
            // Just count it.
            //
            else
            {
                (*pcInfo)++;
            }
        }

        LocalFree (pmszBind);
    }

    return dwErr;
}

/*++

Routine Description

    Initializes the protocol resource data structs by picking up
    info from the HUB and the registry.

Arguments

Return Value

    SUCCESS
    Error codes returned by Ioctls or registry parsing routines.

--*/
DWORD
InitializeProtocolInfoStructs ()
{
    int         cLoop       = 0;
    int         cLoopMax    = 2;
    DWORD       dwErr       = ERROR_SUCCESS;

/*
    if(0 !=MaxProtocols)
    {
        DbgPrint("Waiting for nbf registry to update...\n");
        Sleep(10000);
    }

*/

    //
    // Save the previous information. This will be required to patch
    // up the pcb's if we are reinitialing the protocol info structs
    // as a result of an adapter/device being added or removed.
    //
    ProtocolInfoSave = ProtocolInfo;
    MaxProtocolsSave = MaxProtocols;

    ProtocolInfo = NULL;
    MaxProtocols = 0;
    do
    {
        //
        // If we have the count, allocate the memory.
        //
        if (MaxProtocols)
        {
            ProtocolInfo = (ProtInfo*)LocalAlloc(
                                        LMEM_FIXED,
                                        sizeof(ProtInfo)
                                        * MaxProtocols);
            if (!ProtocolInfo)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        dwErr = GetNbfProtocolInfo (ProtocolInfo, &MaxProtocols);
    }
    while (     !dwErr
            &&  !ProtocolInfo
            &&  MaxProtocols
            &&  (++cLoop < cLoopMax));

    if (    !dwErr
        &&  MaxProtocols)
    {
        //
        // Get Lana numbers and names of XportNames from the
        // registry and put into the ProtocolInfo struct:
        //
        GetProtocolInfoFromRegistry ();
    }
    else
    {
        LocalFree(ProtocolInfo);
        ProtocolInfo = NULL;
        MaxProtocols = 0;

        //
        // Nbf may not be installed in which case
        // ERROR_FILE_NOT_FOUND is returned from
        // GetNbfProtocolInfo.  This is okay.
        //
        if (ERROR_FILE_NOT_FOUND == dwErr)
        {
            dwErr = ERROR_SUCCESS;
        }
    }

    return dwErr;
}


/*++

Routine Description

    Construct a versioned name of the form
    <base>.<version>

Arguments

Return Value

    Nothing

--*/
VOID
FormatObjectName(
    CHAR *pszObjectName,
    CHAR *pszBaseName,
    DWORD dwVersion
    )
{
    wsprintf(pszObjectName, "%s.%d", pszBaseName, dwVersion);
}

/*++

Routine Description

    Initialize the resources needed by the request thread:

Arguments

Return Value

    SUCCESS
    Return codes from Win32 resource APIs

--*/
DWORD
InitializeRequestThreadResources()
{
    DWORD retcode ;

    //
    // Since the Timer function is handled by the request
    // thread we initialize the timer queue here:
    //
    if (retcode = InitDeltaQueue())
    {
        return retcode ;
    }

    return SUCCESS ;
}

/*++

Routine Description

    Initializes the security attribute used in creation
    of all rasman objects.

Arguments

Return Value

    SUCCESS
    non-zero returns from security functions

--*/
DWORD
InitRasmanSecurityAttribute ()
{
    DWORD   retcode ;

    //
    // Initialize the descriptor
    //
    if (retcode = InitSecurityDescriptor(&RasmanSecurityDescriptor))
    {
        return  retcode ;
    }

    //
    // Initialize the Attribute structure
    //
    RasmanSecurityAttribute.nLength = sizeof(SECURITY_ATTRIBUTES) ;

    RasmanSecurityAttribute.lpSecurityDescriptor = &RasmanSecurityDescriptor ;

    RasmanSecurityAttribute.bInheritHandle = TRUE ;

    return SUCCESS ;
}

/*++

Routine Description

    This procedure will set up the WORLD security descriptor that
    is used in creation of all rasman objects.

Arguments

Return Value

    SUCCESS
    non-zero returns from security functions

--*/
DWORD
InitSecurityDescriptor (PSECURITY_DESCRIPTOR SecurityDescriptor)
{
    DWORD    dwRetCode;
    DWORD    cbDaclSize;
    PULONG   pSubAuthority;
    PSID     pRasmanObjSid    = NULL;
    PACL     pDacl        = NULL;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWorldAuth
                  = SECURITY_WORLD_SID_AUTHORITY;
    DWORD   dwAcls;                  


    //
    // The do - while(FALSE) statement is used so that the
    // break statement maybe used insted of the goto statement,
    // to execute a clean up and and exit action.
    //
    do
    {
        dwRetCode = SUCCESS;

        //
        // Set up the SID for the admins that will be allowed
        // to have access. This SID will have 1 sub-authorities
        // SECURITY_BUILTIN_DOMAIN_RID.
        //
        pRasmanObjSid = (PSID)LocalAlloc(
                            LPTR,
                            GetSidLengthRequired(1) );

        if ( pRasmanObjSid == NULL )
        {
            dwRetCode = GetLastError() ;
            break;
        }

        if ( !InitializeSid(
                    pRasmanObjSid,
                    &SidIdentifierWorldAuth,
                    1) )
        {
            dwRetCode = GetLastError();
            break;
        }

        //
        // Set the sub-authorities
        //
        pSubAuthority = GetSidSubAuthority( pRasmanObjSid, 0 );

        *pSubAuthority = SECURITY_WORLD_RID;

        //
        // Set up the DACL that will allow all processeswith the
        // above SID all access. It should be large enough to
        // hold all ACEs.
        //
        cbDaclSize =  sizeof(ACCESS_ALLOWED_ACE)
                    + GetLengthSid(pRasmanObjSid)
                    + sizeof(ACL);

        if ( (pDacl = (PACL)LocalAlloc(
                        LPTR,
                        cbDaclSize ) ) == NULL )
        {
            dwRetCode = GetLastError ();
            break;
        }

        if ( !InitializeAcl(
                        pDacl,
                        cbDaclSize,
                        ACL_REVISION2 ) )
        {
            dwRetCode = GetLastError();
            break;
        }

        dwAcls = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;

        dwAcls &= ~(WRITE_DAC | WRITE_OWNER | DELETE);
        
        //
        // Add the ACE to the DACL
        //
        if ( !AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION2,
                        dwAcls,
                        pRasmanObjSid ))
        {
            dwRetCode = GetLastError();
            break;
        }

        //
        // Create the security descriptor an put the DACL in it.
        //
        if ( !InitializeSecurityDescriptor(
                        SecurityDescriptor,
                        1 ))
        {
            dwRetCode = GetLastError();
            break;
        }

        if ( !SetSecurityDescriptorDacl(
                         SecurityDescriptor,
                         TRUE,
                         pDacl,
                         FALSE ) )
        {
            dwRetCode = GetLastError();
            break;
        }

        //
        // Set owner for the descriptor
        //
        if ( !SetSecurityDescriptorOwner(
                          SecurityDescriptor,
                          NULL,
                          FALSE) )
        {
            dwRetCode = GetLastError();
            break;
        }

        //
        // Set group for the descriptor
        //
        if ( !SetSecurityDescriptorGroup(
                          SecurityDescriptor,
                          NULL,
                          FALSE) )
        {
            dwRetCode = GetLastError();
            break;
        }

    } while( FALSE );

    return( dwRetCode );
}

VOID
UpgradePortMediaInfoStruct (PVOID buffer, DWORD entries)
{

    struct oldPortMediaInfo
    {
        CHAR          PMI_Name [16] ;
        CHAR          PMI_MacBindingName[MAC_NAME_SIZE] ;
        RASMAN_USAGE  PMI_Usage ;
        CHAR          PMI_DeviceType [16] ;
        CHAR          PMI_DeviceName [32] ;
    } ;

    struct oldPortMediaInfo *pold ;

    PortMediaInfo *pnew ;

    BYTE *tempbuffer ;

    DWORD i ;

    tempbuffer = LocalAlloc (LPTR,
                            sizeof(PortMediaInfo)
                            * entries) ;

    if(NULL == tempbuffer)
    {
        return;
    }

    pold = (struct oldPortMediaInfo *)buffer ;

    pnew = (PortMediaInfo *) tempbuffer ;

    for (i = 0; i < entries; i++, pold++, pnew++)
    {
        strcpy (pnew->PMI_Name,
                pold->PMI_Name) ;

        strcpy (pnew->PMI_MacBindingName,
                pold->PMI_MacBindingName) ;

        strcpy (pnew->PMI_DeviceType,
                pold->PMI_DeviceType) ;

        strcpy (pnew->PMI_DeviceName,
                pold->PMI_DeviceName) ;

        pnew->PMI_Usage = pold->PMI_Usage ;

        pnew->PMI_LineDeviceId = 0xffffffff ;

        pnew->PMI_AddressId = 0xffffffff ;
    }

    memcpy (buffer,
            tempbuffer,
            sizeof(PortMediaInfo) * entries) ;

    LocalFree(tempbuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\offers.h ===
DWORD
BuildOffers(
    RAS_L2TP_ENCRYPTION eEncryption,
    IPSEC_QM_OFFER * pOffers,
    PDWORD pdwNumOffers,
    PDWORD pdwFlags
    );

DWORD
BuildOptEncryption(
    IPSEC_QM_OFFER * pOffers,
    PDWORD pdwNumOffers
    );

DWORD
BuildRequireEncryption(
    IPSEC_QM_OFFER * pOffers,
    PDWORD pdwNumOffers
    );

DWORD
BuildNoEncryption(
    IPSEC_QM_OFFER * pOffers,
    PDWORD pdwNumOffers
    );


DWORD
BuildStrongEncryption(
    IPSEC_QM_OFFER * pOffers,
    PDWORD pdwNumOffers
    );

void
BuildOffer(
    IPSEC_QM_OFFER * pOffer,
    DWORD dwNumAlgos,
    DWORD dwFirstOperation,
    DWORD dwFirstAlgoIdentifier,
    DWORD dwFirstAlgoSecIdentifier,
    DWORD dwSecondOperation,
    DWORD dwSecondAlgoIdentifier,
    DWORD dwSecondAlgoSecIdentifier,
    DWORD dwKeyExpirationBytes,
    DWORD dwKeyExpirationTime
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocADsMem(
    DWORD cb
);

BOOL
FreeADsMem(
   LPVOID pMem
);

LPVOID
ReallocADsMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocADsStr(
    LPWSTR pStr
);

BOOL
FreeADsStr(
   LPWSTR pStr
);


BOOL
ReallocADsStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

#ifdef __cplusplus
}
#endif


#endif // _MEMORY_H_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\misc.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    misc.c

Abstract:

    All code corresponding to the "redial if link dropped" feature
    and other miscellaneous code lives here

Author:

    Rao Salapaka (raos) 24-July-1999

Revision History:

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <rasman.h>
#include <rasppp.h>
#include <lm.h>
#include <lmwksta.h>
#include <wanpub.h>
#include <raserror.h>
#include <media.h>
#include <mprlog.h>
#include <rtutils.h>
#include <device.h>
#include <stdlib.h>
#include <string.h>
#include <rtutils.h>
#include <userenv.h>
#include "logtrdef.h"
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "reghelp.h"
#include "ndispnp.h"
#include "lmserver.h"
#include "llinfo.h"
#include "ddwanarp.h"

#define SHELL_REGKEY    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SHELL_REGVAL    L"Shell"
#define DEFAULT_SHELL   L"explorer.exe"
#define RASAUTOUI_REDIALENTRY       L"rasautou -r -f \"%s\" -e \"%s\""

#define BINDSTRING_TCPIP        L"\\Device\\NetBT_Tcpip_"
#define BINDSTRING_NBFOUT       L"\\Device\\Nbf_NdisWanNbfOut"

typedef struct RAS_REDIAL_ARGS
{
    HANDLE hProcess;
    CHAR szPhonebook[MAX_PATH + 1];
    CHAR szEntry[MAX_PHONEENTRY_SIZE];
} RAS_REDIAL_ARGS;

VOID
RasmanTrace(
    CHAR * Format,
    ...
)
{
    va_list arglist;

    va_start(arglist, Format);

    TraceVprintfExA(TraceHandle,
                   0x00010000 | TRACE_USE_MASK | TRACE_USE_MSEC,
                   Format,
                   arglist);

    va_end(arglist);
}

WCHAR *
StrdupAtoW(
    IN LPCSTR psz
    )
{
    WCHAR* pszNew = NULL;

    if (psz != NULL) 
    {
        DWORD cb;

        cb = MultiByteToWideChar(
                    CP_UTF8, 
                    0, 
                    psz, 
                    -1, 
                    NULL, 
                    0);
                    
        pszNew = LocalAlloc(LPTR, cb * sizeof(WCHAR));
        
        if (pszNew == NULL) 
        {
            RasmanTrace("strdupAtoW: Malloc failed");
            return NULL;
        }

        cb = MultiByteToWideChar(
                    CP_UTF8,
                    0, 
                    psz, 
                    -1, 
                    pszNew, 
                    cb);
                    
        if (!cb) 
        {
            LocalFree(pszNew);
            RasmanTrace("strdupAtoW: conversion failed");
            return NULL;
        }
    }

    return pszNew;
}

DWORD
RasImpersonateUser(HANDLE hProcess)
{
    DWORD retcode = SUCCESS;
    HANDLE hToken = NULL;
    HANDLE hThread = NULL;
    HANDLE hTokenImpersonation = NULL;

    if (!OpenProcessToken(
              hProcess,
              TOKEN_ALL_ACCESS,
              &hToken))
    {
        retcode = GetLastError();
        
        RasmanTrace(
          "ImpersonateUser: OpenProcessToken failed. 0x%x",
          retcode);

        goto done;          
    }
        
    //
    // Duplicate the impersonation token.
    //
    if(!DuplicateToken(
            hToken,
            TokenImpersonation,
            &hTokenImpersonation))
    {
        retcode = GetLastError();
        
        RasmanTrace(
          "ImpersonateUser: DuplicateToken failed.0x%x",
          retcode);

        goto done;          
    }
    
    //
    // Set the impersonation token on the current
    // thread.  We are now running in the same
    // security context as the supplied process.
    //
    hThread = NtCurrentThread();
    
    retcode = NtSetInformationThread(
               hThread,
               ThreadImpersonationToken,
               (PVOID)&hTokenImpersonation,
               sizeof (hTokenImpersonation));
               
done:

    CloseHandle(hToken);
    CloseHandle(hTokenImpersonation);

    RasmanTrace("RasImpersonateUser. 0x%x", 
                retcode);

    return retcode;
}

DWORD
RasRevertToSelf()
{
    DWORD retcode = SUCCESS;

    if (!SetThreadToken(NULL, NULL)) 
    {
        retcode = GetLastError();

        //
        // Event log that thread failed to revert.
        //
        RouterLogWarning(
            hLogEvents,
            ROUTERLOG_CANNOT_REVERT_IMPERSONATION,
            0, NULL, retcode) ;

        RasmanTrace(
          "RasRevertToSelf: SetThreadToken failed (error=%d)",
          retcode);
    }

    RasmanTrace("RasRevertToSelf. 0x%x",
                retcode);

    return retcode;    
}

VOID
RedialDroppedLink(PVOID pvContext)
{
    struct RAS_REDIAL_ARGS  *pra = (RAS_REDIAL_ARGS *) pvContext;
    TCHAR                   szCmdLine[100];
    TCHAR                   *pszCmdLine = NULL;
    STARTUPINFO             StartupInfo;
    PROCESS_INFORMATION     ProcessInfo;
    HANDLE                  hToken = NULL;
    BOOL                    fImpersonate = FALSE;
    DWORD                   retcode = SUCCESS;
    WCHAR                   *pPhonebook = NULL, *pEntry = NULL;
    PVOID                   pEnvBlock = NULL;

    ASSERT(NULL != pvContext);

    RasmanTrace("RedialDroppedLink");

    //
    // Initialization of various variables.
    //
    ZeroMemory(&StartupInfo, sizeof (StartupInfo));
    
    ZeroMemory(&ProcessInfo, sizeof (ProcessInfo));
    
    StartupInfo.cb = sizeof(StartupInfo);

    StartupInfo.lpDesktop = L"winsta0\\default";

    //
    // Get WCHAR versions of the phonebook and entryname
    //
    pPhonebook = StrdupAtoW(pra->szPhonebook);

    if(NULL == pPhonebook)
    {
        goto done;
    }

    pEntry = StrdupAtoW(pra->szEntry);

    if(NULL == pEntry)
    {
        goto done;
    }
    
    //
    // Construct the command line when there
    // is not a custom dial DLL.
    //
    pszCmdLine = LocalAlloc(
                LPTR,
                ( lstrlen(RASAUTOUI_REDIALENTRY)
                + lstrlen(pPhonebook)
                + lstrlen(pEntry)
                + 1) * sizeof(TCHAR));

    if(NULL == pszCmdLine)
    {
        RasmanTrace(
         "RedialDroppedLink: failed to allocate pszCmdLine. 0x%x",
               GetLastError());

        goto done;               
    }
                            
    wsprintf(pszCmdLine,
             RASAUTOUI_REDIALENTRY, 
             pPhonebook, 
             pEntry);
    
    RasmanTrace("RedialDroppedLink: szCmdLine=%ws",
                pszCmdLine);
    
    //
    // Exec the process.
    //
    if (!OpenProcessToken(
          pra->hProcess,
          TOKEN_ALL_ACCESS,
          &hToken))
    {
        retcode = GetLastError();
        
        RasmanTrace(
          "RedialDroppedLink: OpenProcessToken failed. 0x%x",
          retcode);

        goto done;
    }


    //
    // Impersonate user
    //
    if(ERROR_SUCCESS != (retcode = RasImpersonateUser(pra->hProcess)))
    {
        RasmanTrace("RedialDroppedLink: failed to impersonate. 0x%x",
                    retcode);

        goto done;                    
    }

    fImpersonate = TRUE;

    //
    // Create an Environment block for that user
    //
    if (!CreateEnvironmentBlock(
          &pEnvBlock, 
          hToken,
          FALSE))
    {
        retcode = GetLastError();

        RasmanTrace("RedialDroppedLink: CreateEnvironmentBlock failed. 0x%x",
                     retcode);
        goto done;
    }

    if(!CreateProcessAsUser(
          hToken,
          NULL,
          pszCmdLine,
          NULL,
          NULL,
          FALSE,
          NORMAL_PRIORITY_CLASS|DETACHED_PROCESS|CREATE_UNICODE_ENVIRONMENT,
          pEnvBlock,
          NULL,
          &StartupInfo,
          &ProcessInfo))
    {
        retcode = GetLastError();
        
        RasmanTrace(
          "REdialDroppedLink: CreateProcessAsUser(%S) failed ,0x%x",
          pszCmdLine,
          retcode);

        goto done;       
    }
    
    RasmanTrace("RedialDroppedLink: started pid %d",
                ProcessInfo.dwProcessId);
                
done:

    if(fImpersonate)
    {
        (void) RasRevertToSelf();
    }

    if(NULL != pszCmdLine)
    {
        LocalFree(pszCmdLine);
    }

    if(NULL != hToken)
    {
        CloseHandle(hToken);
    }

    if(NULL != ProcessInfo.hThread)
    {
        CloseHandle(ProcessInfo.hThread);
    }

    if(NULL != pPhonebook)
    {
        LocalFree(pPhonebook);
    }

    if(NULL != pEntry)
    {
        LocalFree(pEntry);
    }

    if(NULL != pra)
    {
        CloseHandle(pra->hProcess);
        
        LocalFree(pra);
    }

    if(NULL != pEnvBlock)
    {
        DestroyEnvironmentBlock(pEnvBlock);
    }

    RasmanTrace("RedialDroppedLink done. 0x%x", retcode);

    return;
}

BOOL 
IsRouterPhonebook(CHAR * pszPhonebook)
{
    const CHAR *psz;

    BOOL fRouter = FALSE;

    if(NULL == pszPhonebook)
    {
        goto done;
    }

    psz = pszPhonebook + strlen(pszPhonebook);

    //
    // Seek back to the beginning of the filename
    //
    while(psz != pszPhonebook)
    {
        if('\\' == *psz)
        {
            break;
        }

        psz--;
    }

    if('\\' == *psz)
    {
        psz += 1;
    }

    fRouter = (0 == _stricmp(psz, "router.pbk"));

done:

    return fRouter;
}


DWORD
DwQueueRedial(ConnectionBlock *pConn)
{
    DWORD retcode = ERROR_SUCCESS;
    LIST_ENTRY *pEntry;
    ConnectionBlock *pConnT;

    struct RAS_REDIAL_ARGS *pra;
    
    RasmanTrace("DwQueueRedial");

    if(NULL == pConn)
    {
        RasmanTrace(
            "DwQueueRedial: pConn == NULL");
            
        retcode = ERROR_NO_CONNECTION;
        goto done;
    }
    else if(0 == 
        (CONNECTION_REDIALONLINKFAILURE &
        pConn->CB_ConnectionParams.CP_ConnectionFlags))
    {
        RasmanTrace(
            "DwQueueRedial: fRedialOnLinkFailure == FALSE");

        goto done;            
    }

    //
    // Check to see if this connection is being referred
    // by some other connection. In this case don't redial.
    // The outer connection will initiate the redial
    //
    for (pEntry = ConnectionBlockList.Flink;
         pEntry != &ConnectionBlockList;
         pEntry = pEntry->Flink)
    {
        pConnT =
            CONTAINING_RECORD(pEntry, ConnectionBlock, CB_ListEntry);

        if(pConnT->CB_ReferredEntry == pConn->CB_Handle)
        {
            RasmanTrace("DwQueueRedial: this conneciton is referred"
                        " not initiating redial");

            goto done;                        
        }
    }
    

    if(IsRouterPhonebook(
        pConn->CB_ConnectionParams.CP_Phonebook))
    {
        RasmanTrace(
            "DwQueueRedial: Not q'ing redial since this is router.pbk");
            
        goto done;            
    }

    pra = LocalAlloc(LPTR, sizeof(struct RAS_REDIAL_ARGS));

    if(NULL == pra)
    {
        retcode = GetLastError();
        
        RasmanTrace("DwQueueRedial Failed to allocate pra. 0x%x",
                    retcode);

        goto done;                    
    }

    //
    // Fill in the redial args block 
    //
    strcpy(pra->szPhonebook,
           pConn->CB_ConnectionParams.CP_Phonebook);

    strcpy(pra->szEntry,
           pConn->CB_ConnectionParams.CP_PhoneEntry);

    if(!DuplicateHandle(
          GetCurrentProcess(),
          pConn->CB_Process,
          GetCurrentProcess(),
          &pra->hProcess,
          0,
          FALSE,
          DUPLICATE_SAME_ACCESS))
    {
        retcode = GetLastError();
        
        RasmanTrace("DwQueueRedial: failed to duplicate handle, 0x%x",
                    retcode);

        LocalFree(pra);

        goto done;                    
    }
              
    //
    // Queue a workitem to do the redial
    //
    retcode = RtlQueueWorkItem(
                    RedialDroppedLink,
                    (PVOID) pra,
                    WT_EXECUTEDEFAULT);

    if(ERROR_SUCCESS != retcode)
    {
        goto done;
    }
               

done:

    return retcode;
}


BOOL
IsCustomDLLTrusted(
    IN LPWSTR   lpwstrDLLName
)
{
    HKEY        hKey                    = NULL;
    LPWSTR      lpwsRegMultiSz          = NULL;
    LPWSTR      lpwsRegMultiSzWalker    = NULL;
    DWORD       dwRetCode               = NO_ERROR;
    DWORD       dwNumSubKeys;
    DWORD       dwMaxSubKeySize;
    DWORD       dwMaxValNameSize;
    DWORD       dwNumValues;
    DWORD       dwMaxValueDataSize;
    DWORD       dwType;

    if ( RegOpenKey( HKEY_LOCAL_MACHINE,
                     L"SYSTEM\\CurrentControlSet\\Services\\RasMan\\Parameters",
                     &hKey) != NO_ERROR )
    {
        return( FALSE );
    }


    do
    {
        //
        // get the length of the REG_MUTLI_SZ
        //

        dwRetCode = RegQueryInfoKey( hKey, NULL, NULL, NULL, &dwNumSubKeys,
                                     &dwMaxSubKeySize, NULL, &dwNumValues,
                                     &dwMaxValNameSize, &dwMaxValueDataSize,
                                     NULL, NULL );

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        dwMaxValNameSize++;

        if ( ( lpwsRegMultiSz = LocalAlloc( LPTR, 
                            dwMaxValueDataSize ) ) == NULL )
        {
            dwRetCode = GetLastError();

            break;
        }

        //
        // Read in the path
        //

        dwRetCode = RegQueryValueEx(
                                    hKey,
                                    L"CustomDLL",
                                    NULL,
                                    &dwType,
                                    (LPBYTE)lpwsRegMultiSz,
                                    &dwMaxValueDataSize );

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        if ( dwType != REG_MULTI_SZ )
        {            

            dwRetCode = ERROR_REGISTRY_CORRUPT;

            break;
        }

        dwRetCode = ERROR_MOD_NOT_FOUND;

        //
        // See if the DLL exists in the REG_MULTI_SZ
        //

        lpwsRegMultiSzWalker = lpwsRegMultiSz;

        while( *lpwsRegMultiSzWalker != (WCHAR)NULL )
        {
            if ( _wcsicmp( lpwsRegMultiSzWalker, lpwstrDLLName ) == 0 )
            {
                dwRetCode = NO_ERROR;

                break;
            }

            lpwsRegMultiSzWalker += wcslen( lpwsRegMultiSzWalker );
        }

    } while( FALSE );

    if ( lpwsRegMultiSz != NULL )
    {
        LocalFree( lpwsRegMultiSz );
    }

    RegCloseKey( hKey );

    if ( dwRetCode != NO_ERROR )
    {
        return( FALSE );
    }
    else
    {
        return( TRUE );
    }
}

DWORD
DwGetBindString(
        WCHAR *pwszGuidAdapter,
        WCHAR *pwszBindString,
        RAS_PROTOCOLTYPE Protocol)
{
    DWORD retcode = ERROR_SUCCESS;
    
    //
    // Build the bind string
    //
    switch(Protocol)
    {
        case IP:
        {
            wcscpy(pwszBindString,BINDSTRING_TCPIP);
            wcscat(pwszBindString, pwszGuidAdapter);

            break;
        }

        case ASYBEUI:
        {
            wcscpy(pwszBindString, BINDSTRING_NBFOUT);
            wcscat(pwszBindString, 
                   pwszGuidAdapter + wcslen(L"\\DEVICE\\NDISWANNBFOUT"));
                   
            //wcscpy(pwszBindString, pwszGuidAdapter);

            break;
        }

        default:
        {
            RasmanTrace("Neither IP or ASYBEUI. failing");
                   
            retcode = E_FAIL;
            break;
        }
    }

    return retcode;    
}

DWORD
DwBindServerToAdapter(
    WCHAR *pwszGuidAdapter,
    BOOL fBind,
    RAS_PROTOCOLTYPE Protocol)
{
    DWORD retcode = SUCCESS;
    WCHAR wszBindString[MAX_ADAPTER_NAME];
    UNICODE_STRING BindString;
    UNICODE_STRING UpperLayer;
    UNICODE_STRING LowerLayer;

    RasmanTrace("DwBindServerToAdaper: fBind=%d, Protocol=0x%x",
                fBind,
                Protocol);

    ZeroMemory((PBYTE) wszBindString, sizeof(wszBindString));                

    retcode = DwGetBindString(
                        pwszGuidAdapter,
                        wszBindString,
                        Protocol);

    if(SUCCESS != retcode)
    {
        goto done;
    }

    RasmanTrace("DwBindSErverToAdapter: BindString=%ws",
                 wszBindString);
                 
    RtlInitUnicodeString(&LowerLayer, L"");
    RtlInitUnicodeString(&BindString, wszBindString);
    RtlInitUnicodeString(&UpperLayer, L"LanmanServer");

    //
    // Send the ioctl to ndis
    //
    if(!NdisHandlePnPEvent(
        TDI,                        // IN  UINT            Layer,
        (fBind) 
        ? DEL_IGNORE_BINDING
        : ADD_IGNORE_BINDING,       // IN  UINT            Operation,
        &LowerLayer,                // IN  PUNICODE_STRING LowerComponent,
        &UpperLayer,                // IN  PUNICODE_STRING UpperComponent,
        &BindString,                // IN  PUNICODE_STRING BindList,
        NULL,                       // IN  PVOID           ReConfigBuffer
        0                           // IN  UINT            ReConfigBufferSize
        ))
    {
        DWORD retcode = GetLastError();
        
        RasmanTrace(
            "DwBindServerToAdapter: NdisHandlePnPEvent failed.0x%x",
            retcode);        
    }

done:

    RasmanTrace("DwBindServerToAdapter. 0x%x",
                retcode);
    return retcode;
}

VOID
DwResetTcpWindowSize(
        CHAR *pszAdapterName)
{
    WCHAR *pwszAdapterName = NULL;

    if(NULL == pszAdapterName)
    {
        goto done;
    }

    pwszAdapterName = LocalAlloc(LPTR, sizeof(WCHAR) 
                        * (strlen(pszAdapterName) + 1));

    if(NULL == pwszAdapterName)
    {
        goto done;
    }

    mbstowcs(pwszAdapterName, pszAdapterName,
            strlen(pszAdapterName));

    (VOID) DwSetTcpWindowSize(pwszAdapterName,
                             NULL, FALSE);                

done:

    if(NULL != pwszAdapterName)
    {
        LocalFree(pwszAdapterName);
    }
    return;
}


DWORD
DwSetTcpWindowSize(
        WCHAR *pszAdapterName,
        ConnectionBlock *pConn,
        BOOL          fSet)
{
    DWORD           dwErr = ERROR_SUCCESS;
    UserData        *pUserData = NULL;
    ULONG           ulTcpWindowSize;
    UNICODE_STRING  BindString;
    UNICODE_STRING  UpperLayer;
    UNICODE_STRING  LowerLayer;
    WCHAR           *pwszRegKey = NULL;
    const WCHAR     TcpipParameters[] =
    L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\";
    HKEY            hkeyAdapter = NULL;
    WCHAR           wszBindString[MAX_ADAPTER_NAME];
    WANARP_RECONFIGURE_INFO *pReconfigInfo = NULL;
    
    GUID            guidInterface;    

    if(fSet)
    {
        if(NULL == pConn)
        {
            dwErr = E_INVALIDARG;
            goto done;
        }

        pUserData = GetUserData(&pConn->CB_UserData,
                               CONNECTION_TCPWINDOWSIZE_INDEX);

        if(NULL == pUserData)
        {
            RasmanTrace("DwSetTcpWindowSize: No window size specified");
            goto done;
        }

        if(sizeof(DWORD) != pUserData->UD_Length)
        {
            dwErr = E_INVALIDARG;
            goto done;
        }
        
        ulTcpWindowSize = (DWORD) * ((DWORD *) pUserData->UD_Data);

        //
        // Make sure the tcp window size is between 4K and 16K - per Nk
        //
        if(     (ulTcpWindowSize < 0x1000)
            || (ulTcpWindowSize > 0xffff))
        {
            RasmanTrace("DwSetTcpWindowSize: Illegal window size. 0x%x",
                        ulTcpWindowSize);

            dwErr = E_INVALIDARG;
            goto done;
        }
    }

    //
    // Write this value in registry before calling tcpip to update.
    //
    pwszRegKey = (WCHAR *) LocalAlloc(LPTR,
                        (wcslen(TcpipParameters)+wcslen(pszAdapterName)+1)
                      * sizeof(WCHAR));

    if(NULL == pwszRegKey)
    {
        dwErr = E_OUTOFMEMORY;
        goto done;
    }

    wcscpy(pwszRegKey, TcpipParameters);
    wcscat(pwszRegKey, pszAdapterName+8);

    if(ERROR_SUCCESS != (dwErr = (DWORD) RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pwszRegKey,
                        0, KEY_WRITE,
                        &hkeyAdapter)))
    {
        RasmanTrace("DwSetTcpWindowSize: OpenKey adapter failed. 0x%x",
                    dwErr);

        goto done;                    
    }

    if(fSet)
    {
        if(ERROR_SUCCESS != (dwErr = (DWORD) RegSetValueExW(
                            hkeyAdapter,
                            L"TcpWindowSize",
                            0, REG_DWORD,
                            (PBYTE) &ulTcpWindowSize,
                            sizeof(DWORD))))
        {   
            RasmanTrace("DwSetTcpWindowSize: Failed to write window size. 0x%x",
                        dwErr);

            goto done;                    
        }
    }
    else
    {
        if(ERROR_SUCCESS != (dwErr = (DWORD) RegDeleteValue(
                            hkeyAdapter,
                            L"TcpWindowSize")))
        {   
            RasmanTrace("DwSetTcpWindowSize: Failed to write window size. 0x%x",
                        dwErr);

        }

        goto done;
    }

    pReconfigInfo = LocalAlloc(LPTR, sizeof(WANARP_RECONFIGURE_INFO)
                            +sizeof(GUID));

    if(NULL == pReconfigInfo)
    {
        RasmanTrace("DwSetTcpWindowSize: failed to allocate");
        dwErr = E_OUTOFMEMORY;
        goto done;
    }
    
    (void) RegHelpGuidFromString(pszAdapterName+8, &guidInterface);
    
    pReconfigInfo->dwVersion = 1;                            
    pReconfigInfo->wrcOperation = WRC_TCP_WINDOW_SIZE_UPDATE;
    pReconfigInfo->ulNumInterfaces = 1;
    pReconfigInfo->rgInterfaces[0] = guidInterface;

    RtlInitUnicodeString(&LowerLayer, L"\\DEVICE\\NDISWANIP");
    RtlInitUnicodeString(&BindString, L"");
    RtlInitUnicodeString(&UpperLayer, L"Tcpip");

    if(!NdisHandlePnPEvent(
        NDIS,
        RECONFIGURE,
        &LowerLayer,
        &UpperLayer,
        &BindString,
        pReconfigInfo,
        sizeof(WANARP_RECONFIGURE_INFO)
        + sizeof(GUID)
        ))
    {
        DWORD dwErr = GetLastError();
        
        RasmanTrace(
            "DwSetTcpWindowSize: NdisHandlePnPEvent failed.0x%x",
            dwErr);        
    }

done:

    if(NULL != pReconfigInfo)
    {
        LocalFree(pReconfigInfo);
    }
    
    if(NULL != pwszRegKey)
    {
        LocalFree(pwszRegKey);
    }

    if(NULL != hkeyAdapter)
    {
        RegCloseKey(hkeyAdapter);
    }
    
    return dwErr;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\rasipsec.h ===
VOID
BuildOutTxFilter(
    PTRANSPORT_FILTER myOutFilter,
    GUID gPolicyID,
    BOOL bCreateMirror
    );

VOID
BuildInTxFilter(
    PTRANSPORT_FILTER myInFilter,
    GUID gPolicyID,
    BOOL bCreateMirror
    );

VOID
BuildMMAuth(
    PMM_AUTH_METHODS pMMAuthMethods,
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo,
    DWORD dwNumAuthInfos
    );


VOID
BuildQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy,
    RAS_L2TP_ENCRYPTION eEncryption,
    PIPSEC_QM_OFFER pOffers,
    DWORD dwNumOffers,
    DWORD dwFlags
    );

VOID
BuildCTxFilter(
    PTRANSPORT_FILTER myFilter,
    GUID gPolicyID,
    ULONG uDesIpAddr,
    BOOL bCreateMirror
    );

VOID
BuildOutMMFilter(
    PMM_FILTER myOutFilter,
    GUID gPolicyID,
    GUID gMMAuthID,
    BOOL bCreateMirror
    );

VOID
BuildInMMFilter(
    PMM_FILTER myInFilter,
    GUID gPolicyID,
    GUID gMMAuthID,
    BOOL bCreateMirror
    );

VOID
BuildCMMFilter(
    PMM_FILTER myFilter,
    GUID gPolicyID,
    GUID gMMAuthID,
    ULONG uDesIpAddr,
    BOOL bCreateMirror
    );

VOID
BuildMMOffers(
    PIPSEC_MM_OFFER pMMOffers,
    PDWORD pdwMMOfferCount,
    PDWORD pdwMMFlags
    );

VOID
BuildMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy,
    PIPSEC_MM_OFFER pMMOffers,
    DWORD dwMMOfferCount,
    DWORD dwMMFlags
    );

VOID
ConstructMMOffer(
    PIPSEC_MM_OFFER pMMOffer,
    ULONG uTime,
    ULONG uBytes,
    DWORD dwFlags,
    DWORD dwQuickModeLimit,
    DWORD dwDHGroup,
    ULONG uEspAlgo,
    ULONG uEspLen,
    ULONG uEspRounds,
    ULONG uAHAlgo,
    ULONG uAHLen,
    ULONG uAHRounds
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\rasipsec.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    rasipsec.c

Abstract:

    All code corresponding to the interface between ras and the
    IPSEC Policy Agent lives here

Author:

    Rao Salapaka (raos) 03-Mar-1998

Revision History:

    Abhishek (abhishev) 17-Feb-2000

--*/


#ifndef UNICODE
#define UNICODE
#endif


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <raserror.h>
#include <media.h>
#include <devioctl.h>
#include <windows.h>
#include <wincrypt.h>
#include <tchar.h>
#include <stdlib.h>
#include <string.h>
#include <mprlog.h>
#include <rtutils.h>
#include <rpc.h>
#include "logtrdef.h"
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "nouiutil.h"
#include "loaddlls.h"
#include "winsock2.h"
#include "winipsec.h"
#include "memory.h"
#include "certmgmt.h"
#include "offers.h"
#include "iphlpapi.h"
#include "iprtrmib.h"
#include "rasipsec.h"

GUID gServerQMPolicyID;
GUID gServerMMPolicyID;
GUID gServerMMAuthID;

GUID gServerTxFilterID;
GUID gServerOutTxFilterID;
GUID gServerInTxFilterID;

GUID gServerMMFilterID;
GUID gServerOutMMFilterID;
GUID gServerInMMFilterID;

DWORD g_dwProhibitIpsec = 0;

RAS_L2TP_ENCRYPTION eServerEncryption = 0;

PIPSEC_SRV_NODE gpIpSecSrvList = NULL;

#define L2TP_DEST_PORT      1701

#define IPSEC_PA_RETRY_ATTEMPTS     3

#define IPSEC_PA_RETRY_WAIT_TIME    5000

DWORD g_dwIpSecRetryAttempts;

LPWSTR gpszServFilterName = L"L2TP Server Inbound and Outbound Filter";
LPWSTR gpszServOutFilterName = L"L2TP Server Outbound Filter";
LPWSTR gpszServInFilterName = L"L2TP Server Inbound Filter";

LPWSTR gpszClntFilterName = L"L2TP Client Inbound and Outbound Filter";

LPWSTR gpszQMPolicyNameNo = L"L2TP No Encryption Quick Mode Policy";
LPWSTR gpszQMPolicyNameOpt = L"L2TP Optional Encryption Quick Mode Policy";
LPWSTR gpszQMPolicyNameReq = L"L2TP Require Encryption Quick Mode Policy";
LPWSTR gpszQMPolicyNameMax = L"L2TP Require Max Encryption Quick Mode Policy";

LPWSTR gpszServerQMPolicyName = NULL;

LPWSTR gpszMMPolicyName = L"L2TP Main Mode Policy";

LPWSTR gpszServerMMPolicyName = NULL;

BOOL gbSQMPolicyAdded = FALSE;
BOOL gbSMMPolicyAdded = FALSE;
BOOL gbSMMAuthAdded = FALSE;

HANDLE ghSTxFilter = NULL;
HANDLE ghSTxOutFilter = NULL;
HANDLE ghSTxInFilter = NULL;

HANDLE ghSMMFilter = NULL;
HANDLE ghSMMOutFilter = NULL;
HANDLE ghSMMInFilter = NULL;


/*++

Routine Description:

    Bind to the ipsec rpc server. This is temporary
    and will be removed when the ipsec people prov
    ide use with a library to initialize this stuff.

Arguments:

Return Value:

    Nothing.

--*/
DWORD APIENTRY
DwInitializeIpSec(void)
{
    DWORD dwErr = ERROR_SUCCESS;

    {

        HKEY hkey = NULL;
        LONG lr = 0;
        DWORD dwType = 0;
        DWORD dwSize = sizeof(DWORD);

        g_dwIpSecRetryAttempts = IPSEC_PA_RETRY_ATTEMPTS;

        //
        // Read the registry to see if number of ipsec
        // retry attempts is specified.
        //
        if(NO_ERROR == (lr = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\Rasman\\Parameters",
            0,
            KEY_ALL_ACCESS,
            &hkey)))
        {
            //
            // Query the value
            //
            lr = RegQueryValueEx(
                    hkey,
                    L"IpsecPARetryAttempts",
                    NULL,
                    &dwType,
                    (PBYTE) &g_dwIpSecRetryAttempts,
                    &dwSize);

            if(NO_ERROR != lr)
            {
                g_dwIpSecRetryAttempts = IPSEC_PA_RETRY_ATTEMPTS;
            }

            RegCloseKey(hkey);
        }
    }

    return dwErr;

}

/*++

Routine Description:

    Free the binding to the rpc server

Arguments:

Return Value:

    Nothing.

--*/
DWORD APIENTRY
DwUnInitializeIpSec(void)
{
    return NO_ERROR;
}

/*++

Routine Description:

    Query existing associations

Arguments:

    ppIpSecSAList - address of pointer to a SAList
                    to contain the existing SA's

Return Value:

    return values from the PA apis

--*/
DWORD
DwQueryAssociations(PIPSEC_QM_SA * ppIpSecSAList, 
                    PDWORD pdwNumQMSAs, PDWORD pdwResumeHandle)
{
    DWORD dwStatus = NO_ERROR;
    DWORD dwNumTotalQMSAs = 0;


    *ppIpSecSAList = NULL;

    TracePrintfExA(TraceHandle,
                   RASMAN_TRACE_CONNECTION,
                   "DwQueryAssociations");

    dwStatus = EnumQMSAs(
                   NULL,
                   NULL,
                   ppIpSecSAList,
                   0,
                   pdwNumQMSAs,
                   &dwNumTotalQMSAs,
                   pdwResumeHandle,
                   0
                   );

    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
           "DwQueryAssociation, rc=0x%x",
           dwStatus);

    return dwStatus;
}

/*++

Routine Description:

    Free the SA list obtained from the
    DwQueryAssociations api

Arguments:

    SA List to free

Return Value:

    Nothing.

--*/
VOID
FreeSAList(IPSEC_QM_SA * pSAList)
{
    if (pSAList) {
        SPDApiBufferFree(pSAList);
    }

    return;
}

/*++

Routine Description:

    Adds IpSec Filter

Arguments:

    ppcb - pcb of the port for which to add the
           filter

Return Value:

    ERROR_SUCCESS if successful.
    return values from PA apis

--*/
DWORD
DwAddIpSecFilter(
    pPCB ppcb,
    BOOL fServer,
    RAS_L2TP_ENCRYPTION eEncryption
    )
{

    DWORD           dwStatus        = ERROR_INVALID_PARAMETER;
    DWORD           dwFilterCount   = 0;
    DWORD           dwInfoCount     = 0;
    HRESULT         hr              = S_OK;

    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
           "AddIpSecFilter, port=%d, fServer=%d, encryption=%d",
           ppcb->PCB_PortHandle,
           fServer,
           eEncryption);

    dwStatus = DwInitializeIpSec();


    if (fServer) {

        //
        // TODO: figure out a better way of doing this
        //
        if(eServerEncryption != eEncryption)
        {
            DWORD dwNumServerFilters = dwServerConnectionCount;
            DWORD i = 0;

            TracePrintfExA( TraceHandle, RASMAN_TRACE_CONNECTION,
                    "Deleting previous filters since "
                    "ePrev != eCur (%d != %d)",
                    eServerEncryption,
                    eEncryption);

            //
            // Delte any existing filters since server
            // is plumbing a new encryption filter.
            //
            for(i = 0; i < dwNumServerFilters; i++)
            {
                dwStatus = DwDeleteServerIpSecFilter(ppcb);
            }

            //
            // Run through all the filters and reset the
            // filter present flag
            //
            for (i = 0; i < MaxPorts; i++)
            {
                if(Pcb[i] != NULL)
                {
                    Pcb[i]->PCB_fFilterPresent = FALSE;
                }
            }

        }
        else if(ppcb->PCB_fFilterPresent)
        {
            //
            // Filter is already present
            //
            TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
                   "Port %d already has a plumbed filter",
                   ppcb->PCB_PortHandle);

            dwStatus = ERROR_SUCCESS;

            goto error;
        }

        dwStatus = DwAddServerIpSecFilter(
                         ppcb,
                         eEncryption
                         );

        if(ERROR_SUCCESS == dwStatus)
        {
            ppcb->PCB_fFilterPresent = TRUE;
        }

    }else {

        dwStatus = DwAddClientIpSecFilter(
                        ppcb,
                        eEncryption
                        );
    }

    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
           "AddIpSecFilter: rc=0x%x",
           dwStatus);

    return(dwStatus);

error:

    return(dwStatus);
}

DWORD
DwGetPresharedKey(
        pPCB  ppcb,
        DWORD dwMask,
        DWORD *pcbkey,
        PBYTE *ppbkey)
{
    DWORD dwErr = NO_ERROR;
    DWORD dwID;
    GUID *pGuid = NULL;

    if(NULL == pcbkey)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    if(     (NULL != ppcb)
        &&  (NULL != ppcb->PCB_Connection))
    {
        pGuid = &ppcb->PCB_Connection->CB_GuidEntry;
    }

    //
    // Get the size of the key
    //
    dwErr = GetKey(
                NULL,
                pGuid,
                dwMask,
                pcbkey,
                NULL,
                FALSE);

    if(ERROR_BUFFER_TOO_SMALL == dwErr)
    {
        *ppbkey = LocalAlloc(LPTR, *pcbkey);
        if(NULL == *ppbkey)
        {
            dwErr = GetLastError();
            goto done;
        }

        dwErr = GetKey(
                    NULL,
                    pGuid,
                    dwMask,
                    pcbkey,
                    *ppbkey,
                    FALSE);

        //
        // Since IKE doesn't expect a NULL
        // at the end of the psk, we remove
        // the null.
        //
        if(     (*pcbkey > 2)
            &&  (UNICODE_NULL == *((WCHAR *) (*ppbkey + *pcbkey - sizeof(WCHAR)))))
        {
            *pcbkey -= sizeof(WCHAR);
        }
    }

done:
    return dwErr;
}

DWORD
DwGetMMAuthMethodsForServer(
            MM_AUTH_METHODS *pAuthMethods,
            DWORD *pdwInfoCount,
            DWORD *pcbkey,
            PBYTE *ppbkey,
            IPSEC_MM_AUTH_INFO ** ppAuthInfo)
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD cbkey = 0;
    BYTE  *pbkey = NULL;
    IPSEC_MM_AUTH_INFO *pAuthPSK = NULL;
    BOOL fMyStoreEmpty = TRUE;
    
    if(     (NULL == pAuthMethods)
        ||  (NULL == pcbkey)
        ||  (NULL == ppbkey)
        ||  (NULL == ppAuthInfo))
    {
        dwStatus = E_INVALIDARG;
        goto done;
    }

    *ppAuthInfo = NULL;
    
    memset(pAuthMethods, 0, sizeof(MM_AUTH_METHODS));
    if(UuidCreate(&pAuthMethods->gMMAuthID))
    {
        RasmanTrace("UuidCreate returned non-zero value");
    }

    if(NULL == *ppbkey)
    {
        //
        // Get the preshared key if theres one available.
        //
        dwStatus = DwGetPresharedKey(
                        NULL,
                        DLPARAMS_MASK_SERVER_PRESHAREDKEY,
                        pcbkey,
                        ppbkey);
    }                    
                
    //
    // We're using a certificate for authentication.
    // By leaving the AuthInfo empty, we specify that we want to use
    // the default machine cert.
    //
    dwStatus = GenerateCertificatesList(
                       ppAuthInfo,
                       pdwInfoCount,
                       &fMyStoreEmpty
                       );

    if(     (*pcbkey == 0)
        &&  ((ERROR_SUCCESS != dwStatus)
        ||  (0 == *pdwInfoCount)
        ||  fMyStoreEmpty))
    {
        TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
               "Failed to generate certificate list. "
               "rc=0x%x, Count=%d, MyStoreEmpty=%d",
               dwStatus,
               *pdwInfoCount,
               fMyStoreEmpty);

        if (    (0 == *pdwInfoCount)
            ||  (fMyStoreEmpty))
        {
            dwStatus = ERROR_NO_CERTIFICATE;
        }

       if (*ppAuthInfo) {

            FreeCertificatesList(
                   *ppAuthInfo,
                   *pdwInfoCount
                   );

            *ppAuthInfo = NULL;                           
       }

        goto done;
    }


    if(*pcbkey > 0)
    {   
        dwStatus = ERROR_SUCCESS;
        
        //
        // Add preshared key to the auth info
        //
        if(NULL == *ppAuthInfo)
        {
            *ppAuthInfo = LocalAlloc(LPTR, sizeof(IPSEC_MM_AUTH_INFO));
            if(NULL == *ppAuthInfo)
            {
                dwStatus = GetLastError();
                goto done;
            }
        }

        //
        // Note that ListCertChainsInStore would allocate
        // for authinfo if needed.
        //
        pAuthPSK = *ppAuthInfo + *pdwInfoCount;

        pAuthPSK->AuthMethod = IKE_PRESHARED_KEY;
        pAuthPSK->pAuthInfo = *ppbkey;
        pAuthPSK->dwAuthInfoSize = *pcbkey;

        *pdwInfoCount += 1;
    }

    BuildMMAuth(
        pAuthMethods,
        *ppAuthInfo,
        *pdwInfoCount
        );

done:
    return dwStatus;        
}

DWORD
DwUpdatePreSharedKey(
    DWORD cbkey,
    BYTE  *pbkey)
{
    DWORD retcode = ERROR_SUCCESS;
    DWORD dwInfoCount = 0;
    IPSEC_MM_AUTH_INFO *pAuthInfo = NULL;
    DWORD cbkeyp = cbkey;
    BYTE  *pbkeyp = pbkey;
    MM_AUTH_METHODS MMAuthMethods;

    if(     (cbkeyp >= 2)
        &&  (UNICODE_NULL == *((WCHAR *) 
                        (pbkeyp + cbkeyp - sizeof(WCHAR)))))
    {
        cbkeyp -= sizeof(WCHAR);
    }

    retcode = DwGetMMAuthMethodsForServer(
                    &MMAuthMethods,
                    &dwInfoCount,
                    &cbkeyp,
                    &pbkeyp,
                    &pAuthInfo);

    if(ERROR_SUCCESS != retcode)
    {
        if(     ((0 == cbkeyp)
            ||  (NULL == pbkeyp)))
        {
            RasmanTrace("DwUpdatePreSharedKey:"
                    "Failed to fetch certs and"
                    " PSK=NULL - deleting auth methods");

            retcode = DeleteMMAuthMethods(NULL, gServerMMAuthID);

            if(retcode = ERROR_IPSEC_MM_AUTH_NOT_FOUND)
            {
                //
                // The auth method is not present.
                //
                retcode = ERROR_SUCCESS;
            }
                    
        }
        
        goto done;
    }

    retcode = SetMMAuthMethods( 
                    NULL,
                    gServerMMAuthID,
                    &MMAuthMethods);

    //
    // Decrement infocount to remove the authinfo 
    // corresponding to PreSharedKey
    //
    dwInfoCount -= 1;

    if(0 != dwInfoCount)
    {
        FreeCertificatesList(pAuthInfo, dwInfoCount);
    }

done:
    return retcode;
}

DWORD
DwAddServerIpSecFilter(
    pPCB ppcb,
    RAS_L2TP_ENCRYPTION eEncryption
    )
{
    DWORD                dwStatus    = ERROR_INVALID_PARAMETER;
    IPSEC_MM_POLICY      MMPolicy;
    MM_AUTH_METHODS      MMAuthMethods;
    IPSEC_QM_POLICY      QMPolicy;
    IPSEC_MM_AUTH_INFO * pAuthInfo   = NULL;
    // IPSEC_QM_OFFER       Offers[20];
    IPSEC_QM_OFFER       *pOffers = NULL;
    TRANSPORT_FILTER     myOutFilter;
    TRANSPORT_FILTER     myInFilter;
    TRANSPORT_FILTER     myFilter;
    DWORD                dwInfoCount = 0;
    DWORD                dwOfferCount = 1;
    DWORD                dwFlags = 0;
    DWORD                dwCount = 3;
    BOOL                 fMyStoreEmpty = FALSE;
    // IPSEC_MM_OFFER       MMOffers[10];
    IPSEC_MM_OFFER       *pMMOffers = NULL;
    DWORD                dwMMOfferCount = 0;
    DWORD                dwMMFlags = 0;
    MM_FILTER            myOutMMFilter;
    MM_FILTER            myInMMFilter;
    MM_FILTER            myMMFilter;
    DWORD dwPersist = 0;
    DWORD                cbkey = 0;
    PBYTE                pbkey = NULL;
    IPSEC_MM_AUTH_INFO   *pAuthPSK = NULL;

    pOffers = LocalAlloc(LPTR, 20 * sizeof(IPSEC_QM_OFFER));
    if(NULL == pOffers)
    {
        return GetLastError();
    }

    pMMOffers = LocalAlloc(LPTR, 10 * sizeof(IPSEC_MM_OFFER));
    if(NULL == pMMOffers)
    {
        LocalFree(pOffers);
        return GetLastError();
    }

    //
    // Make a global copy for the server
    // We use this to delete two filters in
    // the RAS_L2TP_OPTIONAL_ENCRYPTION case
    //

    eServerEncryption = eEncryption;

    if (!dwServerConnectionCount) {

        switch (eEncryption) {

        case RAS_L2TP_NO_ENCRYPTION:
        case RAS_L2TP_OPTIONAL_ENCRYPTION:

            memset(&gServerQMPolicyID, 0, sizeof(GUID));
            memset(&gServerMMPolicyID, 0, sizeof(GUID));
            memset(&gServerMMAuthID, 0, sizeof(GUID));

            memset(&gServerTxFilterID, 0, sizeof(GUID));
            memset(&gServerOutTxFilterID, 0, sizeof(GUID));
            memset(&gServerInTxFilterID, 0, sizeof(GUID));

            memset(&gServerMMFilterID, 0, sizeof(GUID));
            memset(&gServerOutMMFilterID, 0, sizeof(GUID));
            memset(&gServerInMMFilterID, 0, sizeof(GUID));

            memset(&MMPolicy, 0, sizeof(IPSEC_MM_POLICY));
            if(UuidCreate(&MMPolicy.gPolicyID))
            {
                RasmanTrace("UuidCreate returned non-zero value");
            }

            memset(&QMPolicy, 0, sizeof(IPSEC_QM_POLICY));
            if(UuidCreate(&QMPolicy.gPolicyID))
            {
                RasmanTrace("UuidCreate returned non-zero value");
            }

            memset(&MMAuthMethods, 0, sizeof(MM_AUTH_METHODS));
            if(UuidCreate(&MMAuthMethods.gMMAuthID))
            {
                RasmanTrace("UuidCreate returned non-zero value");
            }


#if 0
            //
            // Get the preshared key if theres one available.
            //
            dwStatus = DwGetPresharedKey(
                            ppcb,
                            DLPARAMS_MASK_SERVER_PRESHAREDKEY,
                            &cbkey,
                            &pbkey);
                        
            //
            // We're using a certificate for authentication.
            // By leaving the AuthInfo empty, we specify that we want to use
            // the default machine cert.
            //
            dwStatus = GenerateCertificatesList(
                               &pAuthInfo,
                               &dwInfoCount,
                               &fMyStoreEmpty
                               );

            if(     (cbkey == 0)
                &&  ((ERROR_SUCCESS != dwStatus)
                ||  (0 == dwInfoCount)
                ||  fMyStoreEmpty))
            {
                TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
                       "Failed to generate certificate list. "
                       "rc=0x%x, Count=%d, MyStoreEmpty=%d",
                       dwStatus,
                       dwInfoCount,
                       fMyStoreEmpty);

                if (    (0 == dwInfoCount)
                    ||  (fMyStoreEmpty))
                {
                    dwStatus = ERROR_NO_CERTIFICATE;
                }

               if (pAuthInfo) {

                    FreeCertificatesList(
                           pAuthInfo,
                           dwInfoCount
                           );

                    pAuthInfo = NULL;                           
               }

                goto error;
            }


            if(cbkey > 0)
            {
                //
                // Add preshared key to the auth info
                //
                if(NULL == pAuthInfo)
                {
                    pAuthInfo = LocalAlloc(LPTR, sizeof(IPSEC_MM_AUTH_INFO));
                    if(NULL == pAuthInfo)
                    {
                        dwStatus = GetLastError();
                        goto error;
                    }
                }

                //
                // Note that ListCertChainsInStore would allocate
                // for authinfo if needed.
                //
                pAuthPSK = pAuthInfo + dwInfoCount;

                pAuthPSK->AuthMethod = IKE_PRESHARED_KEY;
                pAuthPSK->pAuthInfo = pbkey;
                pAuthPSK->dwAuthInfoSize = cbkey;

                dwInfoCount += 1;
            }

            BuildMMAuth(
                &MMAuthMethods,
                pAuthInfo,
                dwInfoCount
                );
#endif

            dwStatus = DwGetMMAuthMethodsForServer(
                                          &MMAuthMethods,
                                          &dwInfoCount,
                                          &cbkey,
                                          &pbkey,
                                          &pAuthInfo);

            if(ERROR_SUCCESS != dwStatus)
            {
                goto error;
            }
               
            //memset(Offers, 0, sizeof(IPSEC_QM_OFFER)*20);

            dwStatus = BuildOffers(
                           eEncryption,
                           pOffers,
                           &dwOfferCount,
                           &dwFlags
                           );

            BuildQMPolicy(
                &QMPolicy,
                eEncryption,
                pOffers,
                dwOfferCount,
                dwFlags
                );             

            //memset(MMOffers, 0, sizeof(IPSEC_MM_OFFER)*10);

            BuildMMOffers(
                pMMOffers,
                &dwMMOfferCount,
                &dwMMFlags
                );

            BuildMMPolicy(
                &MMPolicy,
                pMMOffers,
                dwMMOfferCount,
                dwMMFlags
                );
 
            //
            // Now build the filter we are interested in
            //

            memset(&myOutFilter, 0, sizeof(TRANSPORT_FILTER));
            memset(&myInFilter, 0, sizeof(TRANSPORT_FILTER));

            memset(&myOutMMFilter, 0, sizeof(MM_FILTER));
            memset(&myInMMFilter, 0, sizeof(MM_FILTER));

            //
            // This is the Outbound Filter
            //

            BuildOutTxFilter(
                &myOutFilter,
                QMPolicy.gPolicyID,
                FALSE
                );

            //
            // This is the Inbound Filter
            //
 
            BuildInTxFilter(
                &myInFilter,
                QMPolicy.gPolicyID,
                FALSE
                );

            BuildOutMMFilter(
                &myOutMMFilter,
                MMPolicy.gPolicyID,
                MMAuthMethods.gMMAuthID,
                FALSE
                );

            BuildInMMFilter(
                &myInMMFilter,
                MMPolicy.gPolicyID,
                MMAuthMethods.gMMAuthID,
                FALSE
                );
 
            do
            {
                if (!gbSMMAuthAdded) {
                    dwStatus = AddMMAuthMethods(
                                   NULL,
                                   dwPersist,
                                   &MMAuthMethods
                                   );
                    if (!dwStatus) {
                        gbSMMAuthAdded = TRUE;
                        memcpy(&gServerMMAuthID,
                               &(MMAuthMethods.gMMAuthID), sizeof(GUID));
                    }
                }

                if (!gbSMMPolicyAdded) {
                    dwStatus = AddMMPolicy(
                                   NULL,
                                   dwPersist,
                                   &MMPolicy
                                   );
                    if (!dwStatus) {
                        gbSMMPolicyAdded = TRUE;
                        memcpy(&gServerMMPolicyID,
                               &(MMPolicy.gPolicyID), sizeof(GUID));
                        gpszServerMMPolicyName = MMPolicy.pszPolicyName;
                    }
                }
               
                if (!gbSQMPolicyAdded) {
                    dwStatus = AddQMPolicy(
                                   NULL,
                                   dwPersist,
                                   &QMPolicy
                                   );
                    if (!dwStatus) {
                        gbSQMPolicyAdded = TRUE;
                        memcpy(&gServerQMPolicyID,
                               &(QMPolicy.gPolicyID), sizeof(GUID));
                        gpszServerQMPolicyName = QMPolicy.pszPolicyName;
                    }
                }

                if (!ghSTxOutFilter) {
                    dwStatus = AddTransportFilter(
                                    NULL,
                                    dwPersist,
                                    &myOutFilter,
                                    &ghSTxOutFilter
                                    );
                    if (!dwStatus) {
                        memcpy(&gServerOutTxFilterID,
                               &(myOutFilter.gFilterID), sizeof(GUID));
                    }
                }
 
                if (!ghSTxInFilter) {
                    dwStatus = AddTransportFilter(
                                    NULL,
                                    dwPersist,
                                    &myInFilter,
                                    &ghSTxInFilter
                                    );
                    if (!dwStatus) {
                        memcpy(&gServerInTxFilterID,
                               &(myInFilter.gFilterID), sizeof(GUID));
                    }
                }

                if (!ghSMMOutFilter) {
                    dwStatus = AddMMFilter(
                                    NULL,
                                    dwPersist,
                                    &myOutMMFilter,
                                    &ghSMMOutFilter
                                    );
                    if (!dwStatus) {
                        memcpy(&gServerOutMMFilterID,
                               &(myOutMMFilter.gFilterID), sizeof(GUID));
                    }
                }
 
                if (!ghSMMInFilter) {
                    dwStatus = AddMMFilter(
                                    NULL,
                                    dwPersist,
                                    &myInMMFilter,
                                    &ghSMMInFilter
                                    );
                    if (!dwStatus) {
                        memcpy(&gServerInMMFilterID,
                               &(myInMMFilter.gFilterID), sizeof(GUID));
                    }
                }
 
                dwCount += 1;

                if(ERROR_NOT_READY == dwStatus)
                {
                     Sleep(IPSEC_PA_RETRY_WAIT_TIME);
                }
            }
            while(   (ERROR_NOT_READY == dwStatus)
                 &&  (dwCount < g_dwIpSecRetryAttempts));

            //
            // Now free the certificates list.
            // we don't want to keep this around
            // we will reevaluate again
            //
 
            if (pAuthInfo) {

                dwInfoCount -= 1;

                if(cbkey > 0)
                {
                    LocalFree(pbkey);
                }
 
                FreeCertificatesList(
                        pAuthInfo,
                        dwInfoCount
                        );
            }

            break;


        case RAS_L2TP_REQUIRE_ENCRYPTION:
        case RAS_L2TP_REQUIRE_MAX_ENCRYPTION:

            memset(&gServerQMPolicyID, 0, sizeof(GUID));
            memset(&gServerMMPolicyID, 0, sizeof(GUID));
            memset(&gServerMMAuthID, 0, sizeof(GUID));

            memset(&gServerTxFilterID, 0, sizeof(GUID));
            memset(&gServerOutTxFilterID, 0, sizeof(GUID));
            memset(&gServerInTxFilterID, 0, sizeof(GUID));
 
            memset(&gServerMMFilterID, 0, sizeof(GUID));
            memset(&gServerOutMMFilterID, 0, sizeof(GUID));
            memset(&gServerInMMFilterID, 0, sizeof(GUID));
 
            memset(&MMPolicy, 0, sizeof(IPSEC_MM_POLICY));
            if(UuidCreate(&MMPolicy.gPolicyID))
            {
                RasmanTrace("UuidCreate returned non-zero value");
            }
            
 
            memset(&QMPolicy, 0, sizeof(IPSEC_QM_POLICY));
            if(UuidCreate(&QMPolicy.gPolicyID))
            {
                RasmanTrace("UuidCreate returned non-zero value");
            }
            

            memset(&MMAuthMethods, 0, sizeof(MM_AUTH_METHODS));
            if(UuidCreate(&MMAuthMethods.gMMAuthID))
            {
                RasmanTrace("UuidCreate returned non-zero value");
            }
            

            //
            // We're using a certificate for authentication.
            // By leaving the AuthInfo empty, we specify that we want to use
            // the default machine cert.
            //

            dwStatus = GenerateCertificatesList(
                                &pAuthInfo,
                                &dwInfoCount,
                                &fMyStoreEmpty
                                );

            if(     (ERROR_SUCCESS != dwStatus)
                ||  (0 == dwInfoCount)
                ||  fMyStoreEmpty)
            {
                TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
                       "Failed to generate certificate list. "
                       "rc=0x%x, Count=%d, MyStoreEmpty=%d",
                       dwStatus,
                       dwInfoCount,
                       fMyStoreEmpty);

                if (    (0 == dwInfoCount)
                    ||  (fMyStoreEmpty))
                {
                    dwStatus = ERROR_NO_CERTIFICATE;
                }

                if (pAuthInfo) {

                    FreeCertificatesList(
                            pAuthInfo,
                            dwInfoCount
                            );
                }

                goto error;
            }

            BuildMMAuth(
                &MMAuthMethods,
                pAuthInfo,
                dwInfoCount
                );
               
            //memset(Offers, 0, sizeof(IPSEC_QM_OFFER)*20);
            dwStatus = BuildOffers(
                            eEncryption,
                            pOffers,
                            &dwOfferCount,
                            &dwFlags
                            );

            BuildQMPolicy(
                &QMPolicy,
                eEncryption,
                pOffers,
                dwOfferCount,
                dwFlags
                );

            //memset(MMOffers, 0, sizeof(IPSEC_MM_OFFER)*10);

            BuildMMOffers(
                pMMOffers,
                &dwMMOfferCount,
                &dwMMFlags
                );

            BuildMMPolicy(
                &MMPolicy,
                pMMOffers,
                dwMMOfferCount,
                dwMMFlags
                );

            //
            // Now build the filter we are interested in
            //

            memset(&myFilter, 0, sizeof(TRANSPORT_FILTER));

            memset(&myMMFilter, 0, sizeof(MM_FILTER));

            BuildOutTxFilter(
                &myFilter,
                QMPolicy.gPolicyID,
                TRUE
                );

            BuildOutMMFilter(
                &myMMFilter,
                MMPolicy.gPolicyID,
                MMAuthMethods.gMMAuthID,
                TRUE
                );

            do
            {

                if (!gbSMMAuthAdded) {
                    dwStatus = AddMMAuthMethods(
                                   NULL,
                                   dwPersist,
                                   &MMAuthMethods
                                   );
                    if (!dwStatus) {
                        gbSMMAuthAdded = TRUE;
                        memcpy(&gServerMMAuthID,
                               &(MMAuthMethods.gMMAuthID), sizeof(GUID));
                    }
                }

                if (!gbSMMPolicyAdded) {
                    dwStatus = AddMMPolicy(
                                   NULL,
                                   dwPersist,
                                   &MMPolicy
                                   );
                    if (!dwStatus) {
                        gbSMMPolicyAdded = TRUE;
                        memcpy(&gServerMMPolicyID,
                               &(MMPolicy.gPolicyID), sizeof(GUID));
                        gpszServerMMPolicyName = MMPolicy.pszPolicyName;
                    }
                }
                
                if (!gbSQMPolicyAdded) {
                    dwStatus = AddQMPolicy(
                                   NULL,
                                   dwPersist,
                                   &QMPolicy
                                   );
                    if (!dwStatus) {
                        gbSQMPolicyAdded = TRUE;
                        memcpy(&gServerQMPolicyID,
                               &(QMPolicy.gPolicyID), sizeof(GUID));
                        gpszServerQMPolicyName = QMPolicy.pszPolicyName;
                    }
                }
 
                if (!ghSTxFilter) {
                    dwStatus = AddTransportFilter(
                                   NULL,
                                   dwPersist,
                                   &myFilter,
                                   &ghSTxFilter
                                   );

                    if (!dwStatus) {
                        memcpy(&gServerTxFilterID,
                               &(myFilter.gFilterID), sizeof(GUID));
                    }
                }

                if (!ghSMMFilter) {
                    dwStatus = AddMMFilter(
                                   NULL,
                                   dwPersist,
                                   &myMMFilter,
                                   &ghSMMFilter
                                   );

                    if (!dwStatus) {
                        memcpy(&gServerMMFilterID,
                               &(myMMFilter.gFilterID), sizeof(GUID));
                    }
                }

                if(ERROR_NOT_READY == dwStatus)
                {
                    Sleep(IPSEC_PA_RETRY_WAIT_TIME);
                }

                dwCount += 1;
            }
            while(  (ERROR_NOT_READY == dwStatus)
                &&  (dwCount < g_dwIpSecRetryAttempts));

            //
            // Now free the certificates list.
            // we don't want to keep this around
            // we will reevaluate again
            //

            if (pAuthInfo) {

                FreeCertificatesList(
                        pAuthInfo,
                        dwInfoCount
                        );
            }

            break;
        }

        if(ERROR_SUCCESS == dwStatus)
        {
            dwServerConnectionCount++;
        }

    } else {


        dwServerConnectionCount++;

        dwStatus = ERROR_SUCCESS;

    }

    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
           "DwAddServerIpSecFilter: rc=0x%x",
            dwStatus);

    if(NULL != pOffers)
    {
        LocalFree(pOffers);
    }

    if(NULL != pMMOffers)
    {
        LocalFree(pMMOffers);
    }

    return(dwStatus);


error:

    if(NULL != pOffers)
    {
        LocalFree(pOffers);
    }

    if(NULL != pMMOffers)
    {
        LocalFree(pMMOffers);
    }
    
    return(dwStatus);
}



DWORD
DwAddClientIpSecFilter(
    pPCB ppcb,
    RAS_L2TP_ENCRYPTION eEncryption
    )
{
    DWORD dwStatus = ERROR_INVALID_PARAMETER;
    IPSEC_QM_POLICY QMPolicy;
    IPSEC_MM_POLICY MMPolicy;
    IPSEC_MM_AUTH_INFO * pAuthInfo = NULL;
    MM_AUTH_METHODS MMAuthMethods;
    // IPSEC_QM_OFFER Offers[20];
    IPSEC_QM_OFFER *pOffers = NULL;
    TRANSPORT_FILTER myFilter;
    DWORD dwInfoCount = 0;
    DWORD dwOfferCount = 1;
    PIPSEC_SRV_NODE pClientNode = NULL;
    GUID gQMPolicyID;
    GUID gMMPolicyID;
    GUID gMMAuthID;
    GUID gTxFilterID;
    GUID gMMFilterID;
    DWORD dwFlags = 0;
    HANDLE hTxFilter = NULL;
    HANDLE hMMFilter = NULL;
    // IPSEC_MM_OFFER MMOffers[10];
    IPSEC_MM_OFFER *pMMOffers = NULL;
    DWORD dwMMOfferCount = 0;
    DWORD dwMMFlags = 0;
    MM_FILTER myMMFilter;
    PIPSEC_MM_POLICY pSPDMMPolicy = NULL;
    PIPSEC_QM_POLICY pSPDQMPolicy = NULL;
    DWORD dwPersist = 0;
    DWORD cbkey = 0;
    PBYTE pbkey = NULL;
    IPSEC_MM_AUTH_INFO *pAuthPSK = NULL;


    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
           "DwAddClientIpSecFilter, port=%d",
           ppcb->PCB_PortHandle);

    pOffers = LocalAlloc(LPTR, 20 * sizeof(IPSEC_QM_OFFER));
    if(NULL == pOffers)
    {
        RasmanTrace("DwAddclientipsecfilter: failed to alloc");
        return GetLastError();
    }

    pMMOffers = LocalAlloc(LPTR, 10 * sizeof(IPSEC_MM_OFFER));
    if(NULL == pMMOffers)
    {
        RasmanTrace("DwAddclientipsecfilter: failed to alloc");
        LocalFree(pOffers);
        return GetLastError();
        goto error;
    }


    memset(&gQMPolicyID, 0, sizeof(GUID));
    memset(&gMMPolicyID, 0, sizeof(GUID));
    memset(&gMMAuthID, 0, sizeof(GUID));

    memset(&gTxFilterID, 0, sizeof(GUID));
    memset(&gMMFilterID, 0, sizeof(GUID));

    pClientNode =  FindServerNode(
                       gpIpSecSrvList,
                       ppcb->PCB_ulDestAddr
                       );

    if (pClientNode) {

        if (eEncryption != pClientNode->eEncryption)
        {
            TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
                   "DwAddClientIpSecFilter: Already a filter"
                   " with a different encryption(%d) type exists"
                   " for ths dest address. port=%d",
                   pClientNode->eEncryption,
                   ppcb->PCB_PortHandle);
                   
            LocalFree(pOffers);                   

            return (ERROR_INVALID_PARAMETER);
        }

        TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
               "DwAddClientIpSecFilter: Filter already exists"
               " port=%d",
               ppcb->PCB_PortHandle);

        pClientNode->dwRefCount++;
        LocalFree(pOffers);
        LocalFree(pMMOffers);
        return (ERROR_SUCCESS);

    } else {

        BOOL fMyStoreEmpty;


        //
        // There was no filter plumbed, so plumb a filter
        //

        switch (eEncryption) {

        case RAS_L2TP_NO_ENCRYPTION:
        case RAS_L2TP_REQUIRE_ENCRYPTION:
        case RAS_L2TP_OPTIONAL_ENCRYPTION:
        case RAS_L2TP_REQUIRE_MAX_ENCRYPTION:
 
            memset(&MMPolicy, 0, sizeof(IPSEC_MM_POLICY));
            if(UuidCreate(&MMPolicy.gPolicyID))
            {
                RasmanTrace("UuidCreate returned non-zero value");
            }
            
 
            memset(&QMPolicy, 0, sizeof(IPSEC_QM_POLICY));
            if(UuidCreate(&QMPolicy.gPolicyID))
            {
                RasmanTrace("UuidCreate returned non-zero value");
            }
            

            memset(&MMAuthMethods, 0, sizeof(MM_AUTH_METHODS));
            if(UuidCreate(&MMAuthMethods.gMMAuthID))
            {
                RasmanTrace("UuidCreate returned non-zero value");
            }
            
            //
            // Get presharedkey
            //
            if(     (NULL != ppcb->PCB_Connection)
                &&  (CONNECTION_USEPRESHAREDKEY &
                    ppcb->PCB_Connection->
                    CB_ConnectionParams.CP_ConnectionFlags))
            {                    
                DWORD dwMask = DLPARAMS_MASK_PRESHAREDKEY;

                if(GetCurrentProcessId() == 
                    ppcb->PCB_Connection->CB_dwPid)
                {
                    dwMask = DLPARAMS_MASK_DDM_PRESHAREDKEY;
                }
                
                dwStatus = DwGetPresharedKey(
                                ppcb,
                                dwMask,
                                &cbkey,
                                &pbkey);
            }                            

            //
            // Generate certificate list only if there is no
            // pre-sharedkey for this connectoid.
            //
            if(cbkey == 0)
            {
                HCONN hConn = ppcb->PCB_Connection->CB_Handle;

                //
                // Leave submitcriticalsection before calling
                // to generate certificate list.
                //
                
                LeaveCriticalSection(&g_csSubmitRequest);
                
                //
                // We're using a certificate for authentication.
                // By leaving the AuthInfo empty, we specify that
                // we want to use the default machine cert.
                //

                dwStatus = GenerateCertificatesList(
                                    &pAuthInfo,
                                    &dwInfoCount,
                                    &fMyStoreEmpty
                                    );

                //
                // Reacquire the critical section and make sure
                // the connection is still valid.
                //
                EnterCriticalSection(&g_csSubmitRequest);

                if(NULL == FindConnection(hConn))
                {
                    RasmanTrace("DwAddClientIpSecFilter: connection 0x%x"
                                "not found", hConn);
                                
                    FreeCertificatesList(pAuthInfo, dwInfoCount);
                    dwStatus = ERROR_NO_CONNECTION;                                
                    goto error;
                }

                if(     (0 == cbkey)
                    &&  ((ERROR_SUCCESS != dwStatus)
                    ||  (0 == dwInfoCount)
                    ||  fMyStoreEmpty))
                {
                    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
                           "Failed to generate certificate list. "
                           "rc=0x%x, Count=%d, MyStoreEmpty=%d",
                           dwStatus,
                           dwInfoCount,
                           fMyStoreEmpty);

                    if (    (0 == dwInfoCount)
                        ||  (fMyStoreEmpty))
                    {
                        dwStatus = ERROR_CERT_FOR_ENCRYPTION_NOT_FOUND;
                    }

                    if (pAuthInfo) {

                        FreeCertificatesList(
                                pAuthInfo,
                                dwInfoCount
                                );
                    }


                    goto error;
                }
            }

            if(cbkey > 0)
            {
                //
                // Add preshared key to the auth info
                //
                if(NULL == pAuthInfo)
                {
                    pAuthInfo = LocalAlloc(LPTR, sizeof(IPSEC_MM_AUTH_INFO));
                    if(NULL == pAuthInfo)
                    {
                        dwStatus = GetLastError();
                        goto error;
                    }
                }

                //
                // Note that ListCertChainsInStore would allocate
                // for authinfo if needed.
                //
                pAuthPSK = pAuthInfo + dwInfoCount;

                pAuthPSK->AuthMethod = IKE_PRESHARED_KEY;
                pAuthPSK->pAuthInfo = pbkey;
                pAuthPSK->dwAuthInfoSize = cbkey;

                dwInfoCount += 1;
            }

            BuildMMAuth(
                &MMAuthMethods,
                pAuthInfo,
                dwInfoCount
                );
               
            //memset(Offers, 0, sizeof(IPSEC_QM_OFFER)*20);
            dwStatus = BuildOffers(
                            eEncryption,
                            pOffers,
                            &dwOfferCount,
                            &dwFlags
                            );

            BuildQMPolicy(
                &QMPolicy,
                eEncryption,
                pOffers,
                dwOfferCount,
                dwFlags
                );

            //memset(MMOffers, 0, sizeof(IPSEC_MM_OFFER)*10);

            BuildMMOffers(
                pMMOffers,
                &dwMMOfferCount,
                &dwMMFlags
                );

            BuildMMPolicy(
                &MMPolicy,
                pMMOffers,
                dwMMOfferCount,
                dwMMFlags
                );

            //
            // Now build the filter we are interested in
            //

            memset(&myFilter, 0, sizeof(TRANSPORT_FILTER));

            memset(&myMMFilter, 0, sizeof(MM_FILTER));

            dwStatus = AddMMAuthMethods(
                           NULL,
                           dwPersist,
                           &MMAuthMethods
                           );
            if (!dwStatus) {
                memcpy(&gMMAuthID, &MMAuthMethods.gMMAuthID, sizeof(GUID));
            }

            dwStatus = AddMMPolicy(
                           NULL,
                           dwPersist,
                           &MMPolicy
                           );
            if (!dwStatus) {
                memcpy(&gMMPolicyID, &(MMPolicy.gPolicyID), sizeof(GUID));
            }
            else {
                if (dwStatus == ERROR_IPSEC_MM_POLICY_EXISTS) {
                    dwStatus = GetMMPolicy(
                                   NULL,
                                   MMPolicy.pszPolicyName,
                                   &pSPDMMPolicy
                                   );
                    if (!dwStatus) {
                        memcpy(&gMMPolicyID, &(pSPDMMPolicy->gPolicyID), sizeof(GUID));
                        SPDApiBufferFree(pSPDMMPolicy);
                    }
                    else {
                        dwStatus = AddMMPolicy(
                                       NULL,
                                       dwPersist,
                                       &MMPolicy
                                       );
                        memcpy(&gMMPolicyID, &(MMPolicy.gPolicyID), sizeof(GUID));
                    }
                }
            }

            BuildCMMFilter(
                &myMMFilter,
                gMMPolicyID,
                MMAuthMethods.gMMAuthID,
                ppcb->PCB_ulDestAddr,
                TRUE
                );

            dwStatus = AddQMPolicy(
                           NULL,
                           dwPersist,
                           &QMPolicy
                           );
            if (!dwStatus) {
                memcpy(&gQMPolicyID, &QMPolicy.gPolicyID, sizeof(GUID));
            }
            else {
                if (dwStatus == ERROR_IPSEC_QM_POLICY_EXISTS) {
                    dwStatus = GetQMPolicy(
                                   NULL,
                                   QMPolicy.pszPolicyName,
                                   &pSPDQMPolicy
                                   );
                    if (!dwStatus) {
                        memcpy(&gQMPolicyID, &(pSPDQMPolicy->gPolicyID), sizeof(GUID));
                        SPDApiBufferFree(pSPDQMPolicy);
                    }
                    else {
                        dwStatus = AddQMPolicy(
                                       NULL,
                                       dwPersist,
                                       &QMPolicy
                                       );
                        memcpy(&gQMPolicyID, &(QMPolicy.gPolicyID), sizeof(GUID));
                    }
                }
            }

            BuildCTxFilter(
                &myFilter,
                gQMPolicyID,
                ppcb->PCB_ulDestAddr,
                TRUE
                );

            dwStatus = AddTransportFilter(
                           NULL,
                           dwPersist,
                           &myFilter,
                           &hTxFilter
                           );
            if (!dwStatus) {
                memcpy(&gTxFilterID, &(myFilter.gFilterID), sizeof(GUID));
            }

            dwStatus = AddMMFilter(
                           NULL,
                           dwPersist,
                           &myMMFilter,
                           &hMMFilter
                           );
            if (!dwStatus) {
                memcpy(&gMMFilterID, &(myMMFilter.gFilterID), sizeof(GUID));
            }

            //
            // Now free the certificates list.
            // we don't want to keep this around
            // we will reevaluate again
            //

            if (pAuthInfo) {

                

                FreeCertificatesList(
                        pAuthInfo,
                        dwInfoCount
                        );
            }

            break;


        }

        if(ERROR_SUCCESS != dwStatus)
        {
            goto error;
        }


        //
        // Successfully plumbed the policy, add this to the
        // server list
        //

        gpIpSecSrvList= AddNodeToServerList(
                            gpIpSecSrvList,
                            eEncryption,
                            ppcb->PCB_ulDestAddr,
                            MMPolicy.pszPolicyName,
                            gMMPolicyID,
                            QMPolicy.pszPolicyName,
                            gQMPolicyID,
                            gMMAuthID,
                            gTxFilterID,
                            hTxFilter,
                            gMMFilterID,
                            hMMFilter
                            );

    }

error:

    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
           "DwAddClientIpSecFilter: rc=0x%x",
           dwStatus);

    if(NULL != pOffers)
    {
        LocalFree(pOffers);
    }

    if(NULL != pMMOffers)
    {
        LocalFree(pMMOffers);
    }

    return(dwStatus);
}


/*++

Routine Description:

    Deletes ipsec filter

Arguments:

    ppcb - port for which to disable ipsec

    fServer - TRUE if Server is making this call

Return Value:

    NO_ERROR if successful
    return values from PA apis otherwise
    E_FAIL if ipsec is not initialized

--*/
DWORD
DwDeleteIpSecFilter(pPCB ppcb, BOOL fServer)
{
    DWORD dwStatus = NO_ERROR;

    dwStatus = DwInitializeIpSec();

    if (fServer) {

        TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
               "Deleting server ipsec filter on %d",
               ppcb->PCB_PortHandle);

        dwStatus = DwDeleteServerIpSecFilter(
                        ppcb
                        );
    }else {

        TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
               "Deleting client ipsec filter on %d",
               ppcb->PCB_PortHandle);

        dwStatus = DwDeleteClientIpSecFilter(
                        ppcb
                        );
    }

    return dwStatus;
}


DWORD
DwDeleteServerIpSecFilter(
    pPCB ppcb
    )
{

    DWORD dwStatus = ERROR_SUCCESS;

    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
           "DwDeleteServerIpSecFilter. port=%d,"
           "ServerConnectionCount=%d",
           ppcb->PCB_PortHandle,
           dwServerConnectionCount);

    if (dwServerConnectionCount > 1) {

        dwServerConnectionCount--;


    } else if (dwServerConnectionCount == 1) {

        switch (eServerEncryption) {

        case RAS_L2TP_NO_ENCRYPTION:
        case RAS_L2TP_OPTIONAL_ENCRYPTION:

            if (ghSTxInFilter) {
                dwStatus = DeleteTransportFilter(
                               ghSTxInFilter
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (ghSTxOutFilter) {
                dwStatus = DeleteTransportFilter(
                               ghSTxOutFilter
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (ghSMMInFilter) {
                dwStatus = DeleteMMFilter(
                               ghSMMInFilter
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (ghSMMOutFilter) {
                dwStatus = DeleteMMFilter(
                               ghSMMOutFilter
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (gbSQMPolicyAdded) {
                dwStatus = DeleteQMPolicy(
                               NULL,
                               gpszServerQMPolicyName
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (gbSMMPolicyAdded) {
                dwStatus = DeleteMMPolicy(
                               NULL,
                               gpszServerMMPolicyName
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (gbSMMAuthAdded) {
                dwStatus = DeleteMMAuthMethods(
                               NULL,
                               gServerMMAuthID
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            memset(&gServerQMPolicyID, 0, sizeof(GUID));
            memset(&gServerMMPolicyID, 0, sizeof(GUID));
            memset(&gServerMMAuthID, 0, sizeof(GUID));

            memset(&gServerTxFilterID, 0, sizeof(GUID));
            memset(&gServerOutTxFilterID, 0, sizeof(GUID));
            memset(&gServerInTxFilterID, 0, sizeof(GUID));

            memset(&gServerMMFilterID, 0, sizeof(GUID));
            memset(&gServerOutMMFilterID, 0, sizeof(GUID));
            memset(&gServerInMMFilterID, 0, sizeof(GUID));

            gpszServerQMPolicyName = NULL;
            gpszServerMMPolicyName = NULL;

            ghSTxFilter = NULL;
            ghSTxOutFilter = NULL;
            ghSTxInFilter = NULL;

            ghSMMFilter = NULL;
            ghSMMOutFilter = NULL;
            ghSMMInFilter = NULL;

            gbSQMPolicyAdded = FALSE;
            gbSMMAuthAdded = FALSE;
            gbSMMPolicyAdded = FALSE;

            dwServerConnectionCount--;

            //
            // Server Count is now 0
            //
            break;


        case RAS_L2TP_REQUIRE_ENCRYPTION:
        case RAS_L2TP_REQUIRE_MAX_ENCRYPTION:

            if (ghSTxFilter) {
                dwStatus = DeleteTransportFilter(
                               ghSTxFilter
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (ghSMMFilter) {
                dwStatus = DeleteMMFilter(
                               ghSMMFilter
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (gbSQMPolicyAdded) {
                dwStatus = DeleteQMPolicy(
                               NULL,
                               gpszServerQMPolicyName
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (gbSMMPolicyAdded) {
                dwStatus = DeleteMMPolicy(
                               NULL,
                               gpszServerMMPolicyName
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (gbSMMAuthAdded) {
                dwStatus = DeleteMMAuthMethods(
                               NULL,
                               gServerMMAuthID
                               );
            }
            if (dwStatus) {
                dwServerConnectionCount = 0;
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }


            memset(&gServerQMPolicyID, 0, sizeof(GUID));
            memset(&gServerMMPolicyID, 0, sizeof(GUID));
            memset(&gServerMMAuthID, 0, sizeof(GUID));

            memset(&gServerTxFilterID, 0, sizeof(GUID));
            memset(&gServerOutTxFilterID, 0, sizeof(GUID));
            memset(&gServerInTxFilterID, 0, sizeof(GUID));

            memset(&gServerMMFilterID, 0, sizeof(GUID));
            memset(&gServerOutMMFilterID, 0, sizeof(GUID));
            memset(&gServerInMMFilterID, 0, sizeof(GUID));

            gpszServerQMPolicyName = NULL;
            gpszServerMMPolicyName = NULL;

            ghSTxFilter = NULL;
            ghSTxOutFilter = NULL;
            ghSTxInFilter = NULL;

            ghSMMFilter = NULL;
            ghSMMOutFilter = NULL;
            ghSMMInFilter = NULL;

            gbSQMPolicyAdded = FALSE;
            gbSMMAuthAdded = FALSE;
            gbSMMPolicyAdded = FALSE;

            dwServerConnectionCount--;

            //
            // Server Count is now 0
            //
            break;

        }

    }
    else {

         TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
             "DwDeleteServerIpSecFilter: ref count = 0, rc=0x%x",
             dwStatus);

    }

    ppcb->PCB_fFilterPresent = FALSE;

    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
           "DwDeleteClientIpSecFilter: rc=0x%x",
           dwStatus);

    return dwStatus;
}


DWORD
DwDeleteClientIpSecFilter(
    pPCB ppcb
    )
{
    PIPSEC_SRV_NODE pServerNode = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    RAS_L2TP_ENCRYPTION eEncryption = 0;

    pServerNode = FindServerNode(
                      gpIpSecSrvList,
                      ppcb->PCB_ulDestAddr
                      );
    if (!pServerNode) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto error;
    }

    if (pServerNode->dwRefCount > 1) {
        pServerNode->dwRefCount--;
    } else {

        eEncryption = pServerNode->eEncryption;

        switch (eEncryption) {

        case RAS_L2TP_NO_ENCRYPTION:
        case RAS_L2TP_REQUIRE_ENCRYPTION:
        case RAS_L2TP_OPTIONAL_ENCRYPTION:
        case RAS_L2TP_REQUIRE_MAX_ENCRYPTION:


            if (pServerNode->hTxFilter) {
                dwStatus = DeleteTransportFilter(
                               pServerNode->hTxFilter
                               );
                if (dwStatus) {
                    dwStatus = ERROR_INVALID_PARAMETER;
                    break;
                }
            }

            if (pServerNode->hMMFilter) {
                dwStatus = DeleteMMFilter(
                               pServerNode->hMMFilter
                               );
                if (dwStatus) {
                    dwStatus = ERROR_INVALID_PARAMETER;
                    break;
                }
            }

            dwStatus = DeleteMMAuthMethods(
                           NULL,
                           pServerNode->gMMAuthID
                           );
            if (dwStatus) {
                dwStatus = ERROR_INVALID_PARAMETER;
                break;
            }

            if (pServerNode->pszQMPolicyName) {
                dwStatus = DeleteQMPolicy(
                               NULL,
                               pServerNode->pszQMPolicyName
                               );
                if (dwStatus) {
                    dwStatus = ERROR_INVALID_PARAMETER;
                    break;
                }
            }

            if (pServerNode->pszMMPolicyName) {
                dwStatus = DeleteMMPolicy(
                               NULL,
                               pServerNode->pszMMPolicyName
                               );
                if (dwStatus) {
                    dwStatus = ERROR_INVALID_PARAMETER;
                    break;
                }
            }

            break;

        }

        pServerNode->dwRefCount--;

        //
        // Client Count is now 0
        //

        gpIpSecSrvList = RemoveNode(
                             gpIpSecSrvList,
                             pServerNode
                             );

    }

    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
           "DwDeleteClientIpSecFilter: dwStatus=0x%x, port=%d",
           dwStatus,
           ppcb->PCB_PortHandle);

error:

    return dwStatus;
}

/*++

Routine Description:

    Determines if ipsec is enabled on the port. Currently
    all this does is enumerates all the SA in the system
    and checks to see if l2tp port is specified as dest.
    for any of the SAs. This will change once l2tp can
    pass up the tuple corresponding to the src/dest through
    tapi.


Arguments:

    ppcb - port control block for the port

    pfEnabled - pointer to a BOOL value to return the
                status of ipsec of the port in.

Return Value:

    Nothing.

--*/
DWORD
DwIsIpSecEnabled(pPCB ppcb,
                 BOOL *pfEnabled)
{
    DWORD dwStatus = NO_ERROR;

    DWORD i = 0;
    DWORD SACount = 0;
    DWORD ResumeHandle = 0;

    PIPSEC_QM_SA pSAList = NULL;

    *pfEnabled = FALSE;

    dwStatus = DwInitializeIpSec();

    do {

    dwStatus = DwQueryAssociations(&pSAList, &SACount, &ResumeHandle);

    if(     (NO_ERROR != dwStatus)
        ||  (NULL == pSAList))
    {
        goto done;
    }

    //
    // Run through the list and see if there
    // is any filter associted with port 1701
    //
    for (i = 0; i < SACount; i++)
    {
        if(L2TP_DEST_PORT ==
            pSAList[i].IpsecQMFilter.DesPort.wPort)
        {
            *pfEnabled = TRUE;
            break;
        }
    }

    SPDApiBufferFree(pSAList);

    pSAList = NULL;
    SACount = 0;

    if (*pfEnabled == TRUE) {
        break;
    }

    } while (dwStatus != ERROR_NO_DATA);

done:

    return dwStatus;
}


DWORD
DwGetIpSecInformation(pPCB  ppcb,
                      DWORD * pdwIpsecInfo)
{
    DWORD           dwErr = ERROR_SUCCESS;
    PIPSEC_QM_SA    pSAList = NULL;
    DWORD           i = 0, j = 0;
    ULONG           ulEncryptionAlgo = 0;
    DWORD SACount = 0;
    DWORD ResumeHandle = 0;


    if(NULL == pdwIpsecInfo)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    *pdwIpsecInfo = 0;

    do {

    if(NULL != pSAList)
    {
        FreeSAList(pSAList);
        pSAList = NULL;
        SACount = 0;
    }

    //
    // Query the SA's in the system
    //
    dwErr = DwQueryAssociations(&pSAList, &SACount, &ResumeHandle);

    if(     (ERROR_SUCCESS != dwErr)
        ||  (NULL == pSAList))
    {
        TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
               "QuerySA returned dwErr=0x%x, pSAList=0x%x",
               dwErr,
               pSAList);

        dwErr = E_FAIL;

        goto done;
    }

    //
    // Run through the SAList and find the SA
    // corresponding to our policy.
    //
    for (i = 0; i < SACount; i++)
    {
        if(     ((L2TP_DEST_PORT ==
                    pSAList[i].IpsecQMFilter.SrcPort.wPort)
                || (    (NULL == ppcb->PCB_Connection)
                    &&  (L2TP_DEST_PORT == 
                         pSAList[i].IpsecQMFilter.DesPort.wPort)))
            &&  (ppcb->PCB_ulDestAddr ==
                pSAList[i].IpsecQMFilter.DesAddr.uIpAddr))
        {
            break;
        }
    }

    if (i == SACount)
    {
        TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
        "No match found for the SA");

        dwErr = E_FAIL;
 
        continue;
    }

    for(j = 0; j < pSAList[i].SelectedQMOffer.dwNumAlgos; j++)
    {
        if(pSAList[i].SelectedQMOffer.Algos[j].Operation == ENCRYPTION)
        {
            break;
        }
    }


    if(j == pSAList[i].SelectedQMOffer.dwNumAlgos)
    {
        //
        // Means no encryption algorithms were
        // negotiated.
        //
        TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
               "No Encryption algorithm was returned");

        dwErr = E_FAIL;

        continue;
    }

    ulEncryptionAlgo =
        (ULONG) pSAList[i].SelectedQMOffer.Algos[j].uAlgoIdentifier;

    TracePrintfExA(TraceHandle, RASMAN_TRACE_CONNECTION,
           "ulEncryptionAlgo = %d",
           ulEncryptionAlgo);

    if(ulEncryptionAlgo == (ULONG) IPSEC_DOI_ESP_DES)
    {
        *pdwIpsecInfo |= RASMAN_IPSEC_ESP_DES;
    }
    else if(ulEncryptionAlgo == (ULONG) IPSEC_DOI_ESP_3_DES)
    {
        *pdwIpsecInfo |= RASMAN_IPSEC_ESP_3_DES;
    }

    break;

    } while (dwErr != ERROR_NO_DATA);

done:

    if(NULL != pSAList)
    {
        FreeSAList(pSAList);
    }

    return dwErr;
}


PIPSEC_SRV_NODE
AddNodeToServerList(
    PIPSEC_SRV_NODE pServerList,
    RAS_L2TP_ENCRYPTION eEncryption,
    DWORD dwIpAddress,
    LPWSTR pszMMPolicyName,
    GUID gMMPolicyID,
    LPWSTR pszQMPolicyName,
    GUID gQMPolicyID,
    GUID gMMAuthID,
    GUID gTxFilterID,
    HANDLE hTxFilter,
    GUID gMMFilterID,
    HANDLE hMMFilter
    )
{
    PIPSEC_SRV_NODE pNode = NULL;


    pNode = (PIPSEC_SRV_NODE)AllocADsMem(
                        sizeof(IPSEC_SRV_NODE)
                        );
    if (!pNode) {
        return (pServerList);

    }

    memcpy(&(pNode->gMMPolicyID), &gMMPolicyID, sizeof(GUID));
    memcpy(&(pNode->gQMPolicyID), &gQMPolicyID, sizeof(GUID));
    memcpy(&(pNode->gMMAuthID), &gMMAuthID, sizeof(GUID));
    memcpy(&(pNode->gTxFilterID), &gTxFilterID, sizeof(GUID));
    memcpy(&(pNode->gMMFilterID), &gMMFilterID, sizeof(GUID));
    pNode->dwRefCount = 1;
    pNode->dwIpAddress = dwIpAddress;
    pNode->eEncryption = eEncryption;

    if (pszQMPolicyName && *pszQMPolicyName) {
        pNode->pszQMPolicyName = AllocADsStr(
                                     pszQMPolicyName
                                     );
        if (!(pNode->pszQMPolicyName)) {
            goto error;
        }
    }

    if (pszMMPolicyName && *pszMMPolicyName) {
                
        pNode->pszMMPolicyName = AllocADsStr(
                                     pszMMPolicyName
                                     );
        if (!(pNode->pszMMPolicyName)) {
            goto error;
        }
    }

    pNode->hTxFilter = hTxFilter;
    pNode->hMMFilter = hMMFilter;

    pNode->pNext = pServerList;

    return (pNode);

error:

    if (pNode->pszQMPolicyName) {
        FreeADsStr(pNode->pszQMPolicyName);
    }

    if (pNode->pszMMPolicyName) {
        FreeADsStr(pNode->pszMMPolicyName);
    }

    if (pNode) {
        FreeADsMem(pNode);
    }

    return (pServerList);
}


PIPSEC_SRV_NODE
FindServerNode(
    PIPSEC_SRV_NODE pServerList,
    DWORD dwIpAddress
    )
{

    if (pServerList == NULL) {
        return (pServerList);
    }

    while (pServerList) {

        if (pServerList->dwIpAddress == dwIpAddress) {
            return (pServerList);
        }

        pServerList = pServerList->pNext;
    }

    return (pServerList);
}


PIPSEC_SRV_NODE
RemoveNode(
    PIPSEC_SRV_NODE pServerList,
    PIPSEC_SRV_NODE pNode
    )
{

    PIPSEC_SRV_NODE pTemp = NULL;

    if (pServerList == NULL) {
        return(NULL);
    }

    if (pNode == pServerList) {

        pServerList =  pServerList->pNext;

        if (pNode->pszQMPolicyName) {
            FreeADsStr(pNode->pszQMPolicyName);
        }

        if (pNode->pszMMPolicyName) {
            FreeADsStr(pNode->pszMMPolicyName);
        }

        FreeADsMem(pNode);

        return (pServerList);
    }

    pTemp = pServerList;

    while (pTemp->pNext != NULL) {

        if (pTemp->pNext == pNode) {

            pTemp->pNext = (pTemp->pNext)->pNext;

            if (pNode->pszQMPolicyName) {
                FreeADsStr(pNode->pszQMPolicyName);
            }

            if (pNode->pszMMPolicyName) {
                FreeADsStr(pNode->pszMMPolicyName);
            }

            FreeADsMem(pNode);

            return(pServerList);

        }

        pTemp = pTemp->pNext;
    }

    return (pServerList);
}


DWORD
MapOakleyErrorToRasError(DWORD oakleyerror)
{
    DWORD retcode;

    switch (oakleyerror)
    {
        case ERROR_SUCCESS:
        {
            retcode = ERROR_SUCCESS;
            break;
        }
        
        case ERROR_IPSEC_IKE_NO_CERT:
        case ERROR_IPSEC_IKE_INVALID_CERT_TYPE:
        case ERROR_IPSEC_IKE_NO_PRIVATE_KEY:
        case ERROR_IPSEC_IKE_NO_PUBLIC_KEY:
        {
            retcode = ERROR_OAKLEY_NO_CERT;
            break;

        }

        case ERROR_IPSEC_IKE_NO_PEER_CERT:
        {
            retcode = ERROR_OAKLEY_NO_PEER_CERT;
            break;
        }

        case ERROR_IPSEC_IKE_AUTH_FAIL:
        {
            retcode = ERROR_OAKLEY_AUTH_FAIL;
            break;
        }


        case ERROR_IPSEC_IKE_NO_POLICY:
        {
            retcode = ERROR_OAKLEY_NO_POLICY;
            break;
        }

        case ERROR_IPSEC_IKE_ATTRIB_FAIL:
        {
            retcode = ERROR_OAKLEY_ATTRIB_FAIL;
            break;
        }

        case ERROR_IPSEC_IKE_TIMED_OUT:
        case ERROR_IPSEC_IKE_DROP_NO_RESPONSE:
        {
            retcode = ERROR_OAKLEY_TIMED_OUT;
            break;
        }

        case ERROR_IPSEC_IKE_ERROR:
        {
            retcode = ERROR_OAKLEY_ERROR;
            break;
        }

        case ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR:
        case ERROR_IPSEC_IKE_NEGOTIATION_PENDING:
        default:
        {
            retcode = ERROR_OAKLEY_GENERAL_PROCESSING;
            break;
        }
    }

    return retcode;
}



DWORD
DwDoIke(pPCB ppcb, HANDLE hEvent)
{
    DWORD retcode = ERROR_SUCCESS;
    IPSEC_QM_FILTER myFilter;
    DWORD dwAddress;
    DWORD dwMask;

    RasmanTrace("DwDoIke: port=%s, hEvent=0x%x",
                ppcb->PCB_Name,
                hEvent);

    //
    // Get the address of the interface the
    // traffic is most likely to go over.
    //
    retcode = DwGetBestInterface(ppcb->PCB_ulDestAddr,
                                 &dwAddress,
                                 &dwMask);

    if(ERROR_SUCCESS != retcode)
    {
        RasmanTrace(
            "DwDoIke: failed to get interface. 0x%x",
            retcode);


        //
        // If we are unable to get a interface to tunnel
        // over, return an error that will tell the user
        // that the destination is not reachable.
        //
        retcode = ERROR_BAD_ADDRESS_SPECIFIED;            

        goto done;
    }

    memset(&myFilter, 0, sizeof(IPSEC_QM_FILTER));

    myFilter.QMFilterType = QM_TRANSPORT_FILTER;

    myFilter.SrcAddr.AddrType = IP_ADDR_UNIQUE;
    myFilter.SrcAddr.uIpAddr = (ULONG) dwAddress;
    myFilter.SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

    myFilter.DesAddr.AddrType = IP_ADDR_UNIQUE;
    myFilter.DesAddr.uIpAddr = (ULONG) ppcb->PCB_ulDestAddr;
    myFilter.DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

    myFilter.Protocol.ProtocolType = PROTOCOL_UNIQUE;
    myFilter.Protocol.dwProtocol = IPPROTO_UDP;
    myFilter.SrcPort.PortType = PORT_UNIQUE;
    myFilter.SrcPort.wPort = L2TP_DEST_PORT;
    myFilter.DesPort.PortType = PORT_UNIQUE;
    myFilter.DesPort.wPort = 0;

    myFilter.MyTunnelEndpt.AddrType = IP_ADDR_UNIQUE;
    myFilter.MyTunnelEndpt.uIpAddr = 0;
    myFilter.MyTunnelEndpt.uSubNetMask = IP_ADDRESS_MASK_NONE;

    myFilter.PeerTunnelEndpt.AddrType = IP_ADDR_UNIQUE;
    myFilter.PeerTunnelEndpt.uIpAddr = 0;
    myFilter.PeerTunnelEndpt.uSubNetMask = IP_ADDRESS_MASK_NONE;

    myFilter.dwFlags = 0;

    ppcb->PCB_hIkeNegotiation = NULL;

    retcode = IPSecInitiateIKENegotiation(
                  NULL,
                  &myFilter,
                  GetCurrentProcessId(),
                  hEvent,
                  0,
                  &(ppcb->PCB_hIkeNegotiation)
                  );

    if(ERROR_SUCCESS != retcode)
    {
        RasmanTrace(
            "DwDoIke failed to init negotiation. 0x%x",
            retcode);

        retcode = MapOakleyErrorToRasError(retcode);            

        goto done;

    }

done:

    RasmanTrace("DwDoIke: done. 0x%x",
                retcode);

    return retcode;
}


DWORD
DwQueryIkeStatus(pPCB ppcb, DWORD * pdwStatus)
{
    DWORD retcode = ERROR_SUCCESS;
    SA_NEGOTIATION_STATUS_INFO NegotiationStatus;

    memset(&NegotiationStatus, 0, sizeof(SA_NEGOTIATION_STATUS_INFO));

    RasmanTrace("DwQueryIkeStatus: %s",
                ppcb->PCB_Name);

    retcode = IPSecQueryIKENegotiationStatus(
                  ppcb->PCB_hIkeNegotiation,
                  &NegotiationStatus
                  );

    RasmanTrace(
        "DwQueryIkeStatus: Closing Negotiation handle 0x%x",
        ppcb->PCB_hIkeNegotiation);

    (VOID) IPSecCloseIKENegotiationHandle(
               ppcb->PCB_hIkeNegotiation);

    ppcb->PCB_hIkeNegotiation = NULL;               

    *pdwStatus = MapOakleyErrorToRasError(NegotiationStatus.dwError);

    RasmanTrace("DwQueryIkeStatus: retcode=0x%x, status=0x%x", 
                retcode,
                NegotiationStatus.dwError);

    if(ERROR_SUCCESS != retcode)
    {
        retcode = MapOakleyErrorToRasError(retcode);
    }

    return retcode;
}


VOID
BuildOutTxFilter(
    PTRANSPORT_FILTER myOutFilter,
    GUID gPolicyID,
    BOOL bCreateMirror
    )
{
    if(UuidCreate(&(myOutFilter->gFilterID)))
    {
        RasmanTrace("UuidCreate returned non-zero value");
    }
    
    if (!bCreateMirror) {
        myOutFilter->pszFilterName = gpszServOutFilterName;
    }
    else {
        myOutFilter->pszFilterName = gpszServFilterName;
    }

    myOutFilter->InterfaceType = INTERFACE_TYPE_ALL;
    myOutFilter->bCreateMirror = bCreateMirror;
    myOutFilter->dwFlags = 0;

    myOutFilter->SrcAddr.AddrType = IP_ADDR_UNIQUE;
    myOutFilter->SrcAddr.uIpAddr = IP_ADDRESS_ME;
    myOutFilter->SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

    myOutFilter->DesAddr.AddrType = IP_ADDR_SUBNET;
    myOutFilter->DesAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    myOutFilter->DesAddr.uSubNetMask = SUBNET_MASK_ANY;

    myOutFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    myOutFilter->Protocol.dwProtocol = IPPROTO_UDP;
    myOutFilter->SrcPort.PortType = PORT_UNIQUE;
    myOutFilter->SrcPort.wPort = 0;
    myOutFilter->DesPort.PortType = PORT_UNIQUE;
    myOutFilter->DesPort.wPort = L2TP_DEST_PORT;
    myOutFilter->InboundFilterFlag = NEGOTIATE_SECURITY;
    myOutFilter->OutboundFilterFlag = NEGOTIATE_SECURITY;
    memcpy(&(myOutFilter->gPolicyID), &(gPolicyID), sizeof(GUID));
}


VOID
BuildInTxFilter(
    PTRANSPORT_FILTER myInFilter,
    GUID gPolicyID,
    BOOL bCreateMirror
    )
{
    if(UuidCreate(&(myInFilter->gFilterID)))
    {
        RasmanTrace("UuidCreate returned non-zero value");
    }
    
    myInFilter->pszFilterName = gpszServInFilterName;
    myInFilter->InterfaceType = INTERFACE_TYPE_ALL;
    myInFilter->bCreateMirror = bCreateMirror;
    myInFilter->dwFlags = 0;

    myInFilter->SrcAddr.AddrType = IP_ADDR_SUBNET;
    myInFilter->SrcAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    myInFilter->SrcAddr.uSubNetMask = SUBNET_MASK_ANY;

    myInFilter->DesAddr.AddrType = IP_ADDR_UNIQUE;
    myInFilter->DesAddr.uIpAddr = IP_ADDRESS_ME;
    myInFilter->DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

    myInFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    myInFilter->Protocol.dwProtocol = IPPROTO_UDP;
    myInFilter->SrcPort.PortType = PORT_UNIQUE;
    myInFilter->SrcPort.wPort = L2TP_DEST_PORT;
    myInFilter->DesPort.PortType = PORT_UNIQUE;
    myInFilter->DesPort.wPort = 0;
    myInFilter->InboundFilterFlag = NEGOTIATE_SECURITY;
    myInFilter->OutboundFilterFlag = NEGOTIATE_SECURITY;
    memcpy(&(myInFilter->gPolicyID), &(gPolicyID), sizeof(GUID));
}


VOID
BuildMMAuth(
    PMM_AUTH_METHODS pMMAuthMethods,
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo,
    DWORD dwNumAuthInfos
    )
{
    pMMAuthMethods->dwFlags = 0;
    pMMAuthMethods->pAuthenticationInfo = pAuthenticationInfo;
    pMMAuthMethods->dwNumAuthInfos = dwNumAuthInfos;
}


VOID
BuildQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy,
    RAS_L2TP_ENCRYPTION eEncryption,
    PIPSEC_QM_OFFER pOffers,
    DWORD dwNumOffers,
    DWORD dwFlags
    )
{
    switch (eEncryption) {

    case RAS_L2TP_NO_ENCRYPTION:
        pQMPolicy->pszPolicyName = gpszQMPolicyNameNo;
        break;


    case RAS_L2TP_OPTIONAL_ENCRYPTION:
        pQMPolicy->pszPolicyName = gpszQMPolicyNameOpt;
        break;


    case RAS_L2TP_REQUIRE_ENCRYPTION:
        pQMPolicy->pszPolicyName = gpszQMPolicyNameReq;
        break;


    case RAS_L2TP_REQUIRE_MAX_ENCRYPTION:
        pQMPolicy->pszPolicyName = gpszQMPolicyNameMax;
        break;

    }

    pQMPolicy-> dwFlags = dwFlags;
    pQMPolicy->pOffers = pOffers;
    pQMPolicy->dwOfferCount = dwNumOffers;
}


VOID
BuildCTxFilter(
    PTRANSPORT_FILTER myFilter,
    GUID gPolicyID,
    ULONG uDesIpAddr,
    BOOL bCreateMirror
    )
{
    if(UuidCreate(&(myFilter->gFilterID)))
    {
        RasmanTrace("UuidCreate returned non-zero value");
    }
    
    myFilter->pszFilterName = gpszClntFilterName;
    myFilter->InterfaceType = INTERFACE_TYPE_ALL;
    myFilter->bCreateMirror = bCreateMirror;
    myFilter->dwFlags = 0;

    myFilter->SrcAddr.AddrType = IP_ADDR_UNIQUE;
    myFilter->SrcAddr.uIpAddr = IP_ADDRESS_ME;
    myFilter->SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

    myFilter->DesAddr.AddrType = IP_ADDR_UNIQUE;
    myFilter->DesAddr.uIpAddr = uDesIpAddr;
    myFilter->DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

    myFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    myFilter->Protocol.dwProtocol = IPPROTO_UDP;
    myFilter->SrcPort.PortType = PORT_UNIQUE;
    myFilter->SrcPort.wPort = L2TP_DEST_PORT;
    myFilter->DesPort.PortType = PORT_UNIQUE;
    myFilter->DesPort.wPort = 0;
    myFilter->InboundFilterFlag = NEGOTIATE_SECURITY;
    myFilter->OutboundFilterFlag = NEGOTIATE_SECURITY;
    memcpy(&(myFilter->gPolicyID), &(gPolicyID), sizeof(GUID));
}


VOID
BuildOutMMFilter(
    PMM_FILTER myOutFilter,
    GUID gPolicyID,
    GUID gMMAuthID,
    BOOL bCreateMirror
    )
{
    if(UuidCreate(&(myOutFilter->gFilterID)))
    {
        RasmanTrace("UuidCreate returned non-zero value");
    }
    
    if (!bCreateMirror) {
        myOutFilter->pszFilterName = gpszServOutFilterName;
    }
    else {
        myOutFilter->pszFilterName = gpszServFilterName;
    }

    myOutFilter->InterfaceType = INTERFACE_TYPE_ALL;
    myOutFilter->bCreateMirror = bCreateMirror;
    myOutFilter->dwFlags = 0;

    myOutFilter->SrcAddr.AddrType = IP_ADDR_UNIQUE;
    myOutFilter->SrcAddr.uIpAddr = IP_ADDRESS_ME;
    myOutFilter->SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

    myOutFilter->DesAddr.AddrType = IP_ADDR_SUBNET;
    myOutFilter->DesAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    myOutFilter->DesAddr.uSubNetMask = SUBNET_MASK_ANY;

    memcpy(&(myOutFilter->gPolicyID), &(gPolicyID), sizeof(GUID));
    memcpy(&(myOutFilter->gMMAuthID), &(gMMAuthID), sizeof(GUID));
}


VOID
BuildInMMFilter(
    PMM_FILTER myInFilter,
    GUID gPolicyID,
    GUID gMMAuthID,
    BOOL bCreateMirror
    )
{
    if(UuidCreate(&(myInFilter->gFilterID)))
    {
        RasmanTrace("UuidCreate returned non-zero value");
    }
    
    myInFilter->pszFilterName = gpszServInFilterName;
    myInFilter->InterfaceType = INTERFACE_TYPE_ALL;
    myInFilter->bCreateMirror = bCreateMirror;
    myInFilter->dwFlags = 0;

    myInFilter->SrcAddr.AddrType = IP_ADDR_SUBNET;
    myInFilter->SrcAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    myInFilter->SrcAddr.uSubNetMask = SUBNET_MASK_ANY;

    myInFilter->DesAddr.AddrType = IP_ADDR_UNIQUE;
    myInFilter->DesAddr.uIpAddr = IP_ADDRESS_ME;
    myInFilter->DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

    memcpy(&(myInFilter->gPolicyID), &(gPolicyID), sizeof(GUID));
    memcpy(&(myInFilter->gMMAuthID), &(gMMAuthID), sizeof(GUID));
}


VOID
BuildCMMFilter(
    PMM_FILTER myFilter,
    GUID gPolicyID,
    GUID gMMAuthID,
    ULONG uDesIpAddr,
    BOOL bCreateMirror
    )
{
    if(UuidCreate(&(myFilter->gFilterID)))
    {
        RasmanTrace("UuidCreate didn't return S_OK");
    }
    
    myFilter->pszFilterName = gpszClntFilterName;
    myFilter->InterfaceType = INTERFACE_TYPE_ALL;
    myFilter->bCreateMirror = bCreateMirror;
    myFilter->dwFlags = 0;

    myFilter->SrcAddr.AddrType = IP_ADDR_UNIQUE;
    myFilter->SrcAddr.uIpAddr = IP_ADDRESS_ME;
    myFilter->SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

    myFilter->DesAddr.AddrType = IP_ADDR_UNIQUE;
    myFilter->DesAddr.uIpAddr = uDesIpAddr;
    myFilter->DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;

    memcpy(&(myFilter->gPolicyID), &(gPolicyID), sizeof(GUID));
    memcpy(&(myFilter->gMMAuthID), &(gMMAuthID), sizeof(GUID));
}


VOID
BuildMMOffers(
    PIPSEC_MM_OFFER pMMOffers,
    PDWORD pdwMMOfferCount,
    PDWORD pdwMMFlags
    )
{
    PIPSEC_MM_OFFER pMMOffer = pMMOffers;

    ConstructMMOffer(
        pMMOffer,
        DEFAULT_MM_KEY_EXPIRATION_TIME, 0,
        0,
        0,
        DH_GROUP_2,
        IPSEC_DOI_ESP_3_DES, 0, 0,
        IPSEC_DOI_AH_SHA1, 0, 0
        );
    pMMOffer++;

    ConstructMMOffer(
        pMMOffer,
        DEFAULT_MM_KEY_EXPIRATION_TIME, 0,
        0,
        0,
        DH_GROUP_2,
        IPSEC_DOI_ESP_3_DES, 0, 0,
        IPSEC_DOI_AH_MD5, 0, 0
        );
    pMMOffer++;

    ConstructMMOffer(
        pMMOffer,
        DEFAULT_MM_KEY_EXPIRATION_TIME, 0,
        0,
        0,
        DH_GROUP_1,
        IPSEC_DOI_ESP_DES, 0, 0,
        IPSEC_DOI_AH_SHA1, 0, 0
        );
    pMMOffer++;

    ConstructMMOffer(
        pMMOffer,
        DEFAULT_MM_KEY_EXPIRATION_TIME, 0,
        0,
        0,
        DH_GROUP_1,
        IPSEC_DOI_ESP_DES, 0, 0,
        IPSEC_DOI_AH_MD5, 0, 0
        );
    pMMOffer++;

    *pdwMMOfferCount = 4;
    *pdwMMFlags = IPSEC_MM_POLICY_DISABLE_CRL;
}


VOID
ConstructMMOffer(
    PIPSEC_MM_OFFER pMMOffer,
    ULONG uTime,
    ULONG uBytes,
    DWORD dwFlags,
    DWORD dwQuickModeLimit,
    DWORD dwDHGroup,
    ULONG uEspAlgo,
    ULONG uEspLen,
    ULONG uEspRounds,
    ULONG uAHAlgo,
    ULONG uAHLen,
    ULONG uAHRounds
    )
{
    pMMOffer->Lifetime.uKeyExpirationTime = uTime,
    pMMOffer->Lifetime.uKeyExpirationKBytes = uBytes;
    pMMOffer->dwFlags = dwFlags;
    pMMOffer->dwQuickModeLimit = dwQuickModeLimit;
    pMMOffer->dwDHGroup = dwDHGroup;
    pMMOffer->EncryptionAlgorithm.uAlgoIdentifier = uEspAlgo;
    pMMOffer->EncryptionAlgorithm.uAlgoKeyLen = uEspLen;
    pMMOffer->EncryptionAlgorithm.uAlgoRounds = uEspRounds;
    pMMOffer->HashingAlgorithm.uAlgoIdentifier = uAHAlgo;
    pMMOffer->HashingAlgorithm.uAlgoKeyLen = uAHLen;
    pMMOffer->HashingAlgorithm.uAlgoRounds = uAHRounds;
}


VOID
BuildMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy,
    PIPSEC_MM_OFFER pMMOffers,
    DWORD dwMMOfferCount,
    DWORD dwMMFlags
    )
{
    pMMPolicy->pszPolicyName = gpszMMPolicyName;
    pMMPolicy->dwFlags = dwMMFlags;
    pMMPolicy->uSoftSAExpirationTime = DEFAULT_MM_KEY_EXPIRATION_TIME;
    pMMPolicy->pOffers = pMMOffers;
    pMMPolicy->dwOfferCount = dwMMOfferCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\protos.h ===
//****************************************************************************
//
//             Microsoft NT Remote Access Service
//
//             Copyright 1992-93
//
//
//  Revision History
//
//
//  6/8/92  Gurdeep Singh Pall  Created
//
//
//  Description: This file contains all prototypes used in rasman32
//
//****************************************************************************

#include "rasapip.h"

//
// rasmanss.c
//
DWORD  _RasmanInit () ;

VOID   _RasmanEngine () ;

//
// common.c
//
BOOL    ValidatePortHandle (HPORT) ;

DWORD   SubmitRequest (WORD, ...) ;

HANDLE  OpenNamedMutexHandle (CHAR *) ;

HANDLE  OpenNamedEventHandle (CHAR *) ;

HANDLE  DuplicateHandleForRasman (HANDLE, DWORD);

HANDLE  ValidateHandleForRasman (HANDLE, DWORD) ;

VOID    CopyParams (RAS_PARAMS *, RAS_PARAMS *, DWORD) ;

VOID    ConvParamPointerToOffset (RAS_PARAMS *, DWORD) ;

VOID    ConvParamOffsetToPointer (RAS_PARAMS *, DWORD) ;

VOID    FreeNotifierHandle (HANDLE) ;

VOID    GetMutex (HANDLE, DWORD) ;

VOID    FreeMutex (HANDLE) ;

//
// init.c
//
DWORD   InitRasmanService () ;

DWORD   GetNetbiosNetInfo () ;

DWORD   InitializeMediaControlBlocks () ;

DWORD   InitializePortControlBlocks () ;

DWORD   InitializeProtocolInfoStructs () ;

DWORD   RegisterLSA () ;

VOID    FormatObjectName(CHAR *, CHAR *, DWORD);

DWORD   InitializeRequestThreadResources () ;

DWORD   StartWorkerThreads () ;

DWORD   LoadMediaDLLAndGetEntryPoints (pMediaCB media) ;

DWORD   ReadMediaInfoFromRegistry (MediaEnumBuffer *) ;

DWORD   InitializePCBsPerMedia (WORD, DWORD, PortMediaInfo *) ;

DWORD   CreatePort(MediaCB *, PortMediaInfo *);

DWORD   EnablePort(HPORT);

DWORD   DisablePort(HPORT);

DWORD   RemovePort(HPORT);

pPCB    GetPortByHandle(HPORT);

pPCB    GetPortByName(CHAR *);

VOID    FreePorts(VOID);

DWORD   InitSecurityDescriptor (PSECURITY_DESCRIPTOR) ;

DWORD   InitRasmanSecurityAttribute () ;

DWORD   InitializeEndpointInfo () ;

pEndpointMappingBlock  FindEndpointMappingBlock (CHAR *) ;

DeviceInfo *AddDeviceInfo( DeviceInfo *pDeviceInfo);

DeviceInfo *GetDeviceInfo(PBYTE pbAddress, BOOL fModem);

DWORD DwStartNdiswan(VOID);

DWORD DwSetHibernateEvent(VOID);

//
// timer.c
//
DWORD   InitDeltaQueue () ;

DWORD   TimerThread (LPVOID) ;

VOID    TimerTick () ;

VOID    ListenConnectTimeout (pPCB, PVOID) ;

VOID    HubReceiveTimeout (pPCB, PVOID) ;

VOID    DisconnectTimeout (pPCB, PVOID) ;

VOID    RemoveTimeoutElement (pPCB) ;

VOID    OutOfProcessReceiveTimeout (pPCB ppcb, PVOID arg);

VOID    BackGroundCleanUp();


DeltaQueueElement* AddTimeoutElement (TIMERFUNC, pPCB, PVOID, DWORD) ;

//
// worker.c
//
DWORD   ServiceWorkRequest (pPCB) ;

DWORD   IOCPThread (LPVOID) ;

DWORD   CompleteBufferedReceive (pPCB) ;

DWORD   dwRemovePort ( pPCB, PBYTE );

DWORD   DwCloseConnection(HCONN hConn);

DWORD   RasmanWorker (ULONG_PTR ulpCompletionKey, PRAS_OVERLAPPED pOverlapped);

DWORD   DwProcessDeferredCloseConnection(
                    RAS_OVERLAPPED *pOverlapped);


#ifdef DBG

VOID    FormatAndDisplay (BOOL, PBYTE) ;

VOID    MyPrintf (char *, ... ) ;

#endif

//
// request.c
//
DWORD   RequestThread (LPWORD) ;

VOID    ServiceRequest (RequestBuffer *, DWORD) ;

VOID    DeallocateProtocolResources (pPCB) ;

VOID    EnumPortsRequest (pPCB, PBYTE);

VOID    EnumProtocols (pPCB, PBYTE) ;

VOID    GetInfoRequest (pPCB, PBYTE) ;

VOID    GetUserCredentials (pPCB, PBYTE) ;

VOID    SetCachedCredentials (pPCB ppcb, PBYTE buffer) ;

VOID    PortOpenRequest (pPCB, PBYTE) ;

VOID    PortCloseRequest (pPCB, PBYTE) ;

DWORD   PortClose(pPCB, DWORD, BOOLEAN, BOOLEAN);

VOID    PortDisconnectRequest (pPCB, PBYTE) ;

VOID    PortDisconnectRequestInternal(pPCB, PBYTE, BOOL);

VOID    PortSendRequest (pPCB, PBYTE) ;

VOID    PortReceiveRequest (pPCB, PBYTE) ;

VOID    ConnectCompleteRequest (pPCB, PBYTE) ;

VOID    DeviceListenRequest (pPCB, PBYTE) ;

VOID    PortClearStatisticsRequest (pPCB, PBYTE) ;

VOID    CallPortGetStatistics (pPCB, PBYTE) ;

VOID    CallDeviceEnum (pPCB, PBYTE) ;

VOID    DeviceConnectRequest (pPCB, PBYTE) ;

VOID    DeviceGetInfoRequest (pPCB, PBYTE) ;

VOID    DeviceSetInfoRequest (pPCB, PBYTE) ;

VOID    AllocateRouteRequest (pPCB, PBYTE) ;

VOID    DeAllocateRouteRequest (pPCB, PBYTE) ;

DWORD   DeAllocateRouteRequestCommon (HBUNDLE hbundle, RAS_PROTOCOLTYPE prottype);

VOID    ActivateRouteRequest (pPCB, PBYTE) ;

VOID    ActivateRouteExRequest (pPCB, PBYTE) ;

VOID    CompleteAsyncRequest(pPCB) ;

VOID    CompleteListenRequest (pPCB, DWORD) ;

DWORD   ListenConnectRequest (WORD, pPCB,PCHAR, PCHAR, DWORD, HANDLE) ;

VOID    CompleteDisconnectRequest (pPCB) ;

VOID    DeAllocateRouteRequest (pPCB, PBYTE) ;

VOID    AnyPortsOpen (pPCB, PBYTE) ;

VOID    PortGetInfoRequest (pPCB, PBYTE) ;

VOID    PortSetInfoRequest (pPCB, PBYTE) ;

VOID    EnumLanNetsRequest (pPCB, PBYTE) ;

VOID    CompressionGetInfoRequest (pPCB, PBYTE) ;

VOID    CompressionSetInfoRequest (pPCB, PBYTE) ;

VOID    RequestNotificationRequest (pPCB, PBYTE) ;

VOID    GetInfoExRequest (pPCB, PBYTE) ;

VOID    CancelReceiveRequest (pPCB, PBYTE) ;

VOID    PortEnumProtocols (pPCB, PBYTE) ;

VOID    SetFraming (pPCB, PBYTE) ;

DWORD   CompleteReceiveIfPending (pPCB, SendRcvBuffer *) ;

BOOL    CancelPendingReceiveBuffers (pPCB) ;

VOID    RegisterSlip (pPCB, PBYTE) ;

VOID    RetrieveUserDataRequest (pPCB, PBYTE) ;

VOID    StoreUserDataRequest (pPCB, PBYTE) ;

VOID    GetFramingEx (pPCB, PBYTE) ;

VOID    SetFramingEx (pPCB, PBYTE) ;

VOID    SetProtocolCompression (pPCB, PBYTE) ;

VOID    GetProtocolCompression (pPCB, PBYTE) ;

VOID    GetStatisticsFromNdisWan(pPCB, DWORD *) ;

VOID    GetBundleStatisticsFromNdisWan(pPCB, DWORD *) ;

VOID    GetFramingCapabilities(pPCB, PBYTE) ;

VOID    PortBundle(pPCB, PBYTE) ;

VOID    GetBundledPort(pPCB, PBYTE) ;

VOID    PortGetBundle (pPCB, PBYTE) ;

VOID    BundleGetPort (pPCB, PBYTE) ;

VOID    ReferenceRasman (pPCB, PBYTE) ;

VOID    GetDialParams (pPCB, PBYTE) ;

VOID    SetDialParams (pPCB, PBYTE) ;

VOID    CreateConnection (pPCB, PBYTE);

VOID    DestroyConnection (pPCB, PBYTE);

VOID    EnumConnection (pPCB, PBYTE);

VOID    AddConnectionPort (pPCB, PBYTE);

VOID    EnumConnectionPorts (pPCB, PBYTE);

VOID    GetConnectionParams (pPCB, PBYTE) ;

VOID    SetConnectionParams (pPCB, PBYTE) ;

VOID    GetConnectionUserData (pPCB, PBYTE) ;

VOID    SetConnectionUserData (pPCB, PBYTE) ;

VOID    GetPortUserData (pPCB, PBYTE) ;

VOID    SetPortUserData (pPCB, PBYTE) ;

VOID    GetDialParams (pPCB, PBYTE) ;

VOID    SetDialParams (pPCB, PBYTE) ;

VOID    PppStop (pPCB, PBYTE) ;

VOID    PppSrvCallbackDone (pPCB, PBYTE) ;

VOID    PppSrvStart (pPCB, PBYTE) ;

VOID    PppStart (pPCB, PBYTE) ;

VOID    PppRetry (pPCB, PBYTE) ;

VOID    PppGetInfo (pPCB, PBYTE) ;

VOID    PppChangePwd (pPCB, PBYTE) ;

VOID    PppCallback  (pPCB, PBYTE) ;

VOID    AddNotification (pPCB, PBYTE) ;

VOID    SignalConnection (pPCB, PBYTE) ;

VOID    SetDevConfig (pPCB, PBYTE) ;

VOID    GetDevConfig (pPCB, PBYTE) ;

VOID    GetTimeSinceLastActivity (pPCB, PBYTE) ;

VOID    BundleClearStatisticsRequest (pPCB, PBYTE) ;

VOID    CallBundleGetStatistics (pPCB, PBYTE) ;

VOID    CallBundleGetStatisticsEx(pPCB, PBYTE) ;

VOID    CloseProcessPorts (pPCB, PBYTE) ;

VOID    PnPControl (pPCB, PBYTE) ;

VOID    SetIoCompletionPort (pPCB, PBYTE) ;

VOID    SetRouterUsage (pPCB, PBYTE) ;

VOID    ServerPortClose (pPCB, PBYTE) ;

VOID    CallPortGetStatisticsEx(pPCB, PBYTE);

VOID    GetNdisBundleHandle(pPCB, PBYTE);

VOID    SetRasdialInfo(pPCB, PBYTE);

VOID    RegisterPnPNotifRequest( pPCB , PBYTE );

VOID    PortReceiveRequestEx ( pPCB ppcb, PBYTE buffer );

VOID    GetAttachedCountRequest ( pPCB ppcb, PBYTE buffer );

VOID    NotifyConfigChangedRequest ( pPCB ppcb, PBYTE buffer );

VOID    SetBapPolicyRequest ( pPCB ppcb, PBYTE buffer );

VOID    PppStarted ( pPCB ppcb, PBYTE buffer );

DWORD   dwProcessThresholdEvent ();

VOID    PortReceive (pPCB ppcb, PBYTE buffer, BOOL fRasmanPostingReceive);

VOID    RasmanPortReceive ( pPCB ppcb );

VOID    SendReceivedPacketToPPP( pPCB ppcb, NDISWAN_IO_PACKET *Packet );

VOID    SendDisconnectNotificationToPPP( pPCB ppcb );

VOID    SendListenCompletedNotificationToPPP ( pPCB ppcb );

VOID    RefConnection ( pPCB ppcb, PBYTE buffer );

VOID    PppSetEapInfo(pPCB ppcb, PBYTE buffer);

VOID    PppGetEapInfo(pPCB ppcb, PBYTE buffer);

VOID    SetDeviceConfigInfo(pPCB ppcb, PBYTE buffer);

VOID    GetDeviceConfigInfo(pPCB ppcb, PBYTE buffer);

VOID    FindPrerequisiteEntry(pPCB ppcb, PBYTE pbBuffer);

DWORD   DwRefConnection(ConnectionBlock **ppConn, BOOL fAddref);

VOID    PortOpenEx(pPCB ppcb, PBYTE pbBuffer);

VOID    GetLinkStats(pPCB ppcb, PBYTE pbBuffer);

VOID    GetConnectionStats(pPCB ppcb, PBYTE pbBuffer);

VOID    GetHportFromConnection(pPCB ppcb, PBYTE pBuffer);

VOID    ReferenceCustomCount(pPCB ppcb, PBYTE pBuffer);

VOID    GetHconnFromEntry(pPCB ppcb, PBYTE pBuffer);

VOID    GetConnectInfo(pPCB ppcb, PBYTE pBuffer);

VOID    GetDeviceName(pPCB ppcb, PBYTE pBuffer);

VOID    GetCalledIDInfo(pPCB ppcb, PBYTE pBuffer);

VOID    SetCalledIDInfo(pPCB ppcb, PBYTE pBuffer);

VOID    EnableIpSec(pPCB ppcb, PBYTE pBuffer);

VOID    IsIpSecEnabled(pPCB ppcb, PBYTE pBuffer);

VOID    SetEapLogonInfo(pPCB ppcb, PBYTE pBuffer);

VOID    SendNotificationRequest(pPCB ppcb, PBYTE pBuffer);

VOID    GetNdiswanDriverCaps(pPCB ppcb, PBYTE pBuffer);

VOID    GetBandwidthUtilization(pPCB ppcb, PBYTE pBuffer);

VOID    RegisterRedialCallback(pPCB ppcb, PBYTE pBuffer);

VOID    IsTrustedCustomDll(pPCB ppcb, PBYTE pBuffer);

VOID    GetCustomScriptDll(pPCB ppcb, PBYTE pBuffer);

VOID    DoIke(pPCB ppcb, PBYTE pBuffer);

VOID    QueryIkeStatus(pPCB ppcb, PBYTE pBuffer);

VOID    UnbindLMServer(pPCB ppcb, PBYTE pBuffer);

VOID    IsServerBound(pPCB ppcb, PBYTE pBuffer);

DWORD   DwGetPassword(pPCB ppcb, CHAR *pszPassword, DWORD dwPid);

VOID    SetRasCommSettings(pPCB ppcb, PBYTE pBuffer);

#if UNMAP
VOID    UnmapEndPoint(pPCB ppcb);
#endif

VOID    EnableRasAudio(pPCB ppcb, PBYTE pBuffer);

VOID    SetKeyRequest(pPCB ppcb, PBYTE pBuffer);

VOID    GetKeyRequest(pPCB ppcb, PBYTE pBuffer);

VOID    DisableAutoAddress(pPCB ppcb, PBYTE pBuffer);

VOID    GetDevConfigEx(pPCB, PBYTE) ;

VOID    SendCredsRequest(pPCB, PBYTE);

VOID    GetUnicodeDeviceName(pPCB ppcb, PBYTE pbuffer);

VOID    GetVpnDeviceNameW(pPCB ppcb, PBYTE pbuffer);

//
// dlparams.c
//
VOID    GetProtocolInfo(pPCB ppcb, PBYTE pBuffer);

DWORD   GetEntryDialParams(PWCHAR, DWORD, LPDWORD, PRAS_DIALPARAMS, DWORD);

DWORD   SetEntryDialParams(PWCHAR, DWORD, DWORD, DWORD, PRAS_DIALPARAMS);

BOOL    IsDummyPassword(CHAR *pszPassword);

DWORD   GetKey(WCHAR *pszSid, GUID *pGuid, DWORD dwMask,
               DWORD *pcbKey, PBYTE  pbKey,BOOL   fDummy);

DWORD   SetKey(WCHAR *pszSid, GUID *pGuid, DWORD dwSetMask,
               BOOL  fClear, DWORD cbKey, BYTE *pbKey);
               


//
// Dllinit.c
//
DWORD   MapSharedSpace () ;

VOID    WaitForRasmanServiceStop (char *) ;

DWORD   ReOpenSharedMappings(VOID);

VOID    FreeSharedMappings(VOID);

//
// util.c
//
DWORD   ReOpenBiplexPort (pPCB) ;

VOID    RePostListenOnBiplexPort (pPCB) ;

VOID    MapDeviceDLLName (pPCB, char *, char *) ;

pDeviceCB   LoadDeviceDLL (pPCB, char *) ;

VOID    FreeDeviceList (pPCB) ;

DWORD   AddDeviceToDeviceList (pPCB, pDeviceCB) ;

DWORD   DisconnectPort (pPCB, HANDLE, RASMAN_DISCONNECT_REASON) ;

DWORD   MakeWorkStationNet (pProtInfo) ;

VOID    RemoveWorkStationNet (pProtInfo) ;

VOID    DeAllocateRoute (Bundle *, pList) ;

DWORD   AddNotifierToList(pHandleList *, HANDLE, DWORD, DWORD);

VOID    FreeNotifierList (pHandleList *) ;

VOID    SignalNotifiers (pHandleList, DWORD, DWORD) ;

VOID    SignalPortDisconnect (pPCB, DWORD);

VOID    FreeAllocatedRouteList (pPCB) ;

BOOL    CancelPendingReceive (pPCB) ;

VOID    PerformDisconnectAction (pPCB, HBUNDLE) ;

DWORD   AllocBundle (pPCB);

Bundle  *FindBundle(HBUNDLE);

VOID    FreeBapPackets();

DWORD   GetBapPacket ( RasmanBapPacket **ppBapPacket );

VOID    FreeBundle(Bundle *);

VOID    FreeConnection(ConnectionBlock *pConn);

UserData *GetUserData (PLIST_ENTRY pList, DWORD dwTag);

VOID    SetUserData (PLIST_ENTRY pList, DWORD dwTag, PBYTE pBuf, DWORD dwcbBuf);

VOID    FreeUserData (PLIST_ENTRY pList);

PCHAR   CopyString (PCHAR);

ConnectionBlock *FindConnection(HCONN);

VOID    RemoveConnectionPort(pPCB, ConnectionBlock *, BOOLEAN);

DWORD   SendPPPMessageToRasman( PPP_MESSAGE * PppMsg );

VOID    SendPppMessageToRasmanRequest(pPCB, LPBYTE buffer);

VOID    FlushPcbReceivePackets(pPCB);

VOID    SetPppEvent(pPCB);

VOID    UnloadMediaDLLs();

VOID    UnloadDeviceDLLs();

VOID    SetPortConnState(PCHAR, INT, pPCB, RASMAN_STATE);

VOID    SetPortAsyncReqType(PCHAR, INT, pPCB, ReqTypes);

VOID    SetIoCompletionPortCommon(pPCB, HANDLE, LPOVERLAPPED, LPOVERLAPPED, LPOVERLAPPED, LPOVERLAPPED, BOOL);

VOID    AddPnPNotifierToList( pPnPNotifierList );

VOID    RemovePnPNotifierFromList(PAPCFUNC pfn);

VOID    FreePnPNotifierList ();

VOID    AddProcessInfo ( DWORD );

BOOL    fIsProcessAlive ( HANDLE );

ClientProcessBlock *FindProcess( DWORD );

BOOL    CleanUpProcess ( DWORD );

#if SENS_ENABLED
DWORD   SendSensNotification( DWORD, HRASCONN );
#endif

#if ENABLE_POWER

BOOL    fAnyConnectedPorts();

VOID    DropAllActiveConnections();

DWORD   DwSaveCredentials(ConnectionBlock *pConn);

DWORD   DwDeleteCredentials(ConnectionBlock *pConn);

#endif

DWORD   DwSendNotification(RASEVENT *pEvent);

DWORD   DwSendNotificationInternal(ConnectionBlock *pConn, RASEVENT *pEvent);

DWORD   DwSetThresholdEvent(RasmanBapPacket *pBapPacket);
DWORD   DwSetProtocolEvent();
DWORD   DwGetProtocolEvent(NDISWAN_GET_PROTOCOL_EVENT *);
DWORD   DwProcessProtocolEvent();

VOID    AdjustTimer();

DWORD   DwStartAndAssociateNdiswan();

DWORD   DwSaveIpSecInfo(pPCB ppcb);

DWORD   UnbindLanmanServer(pPCB ppcb);

DWORD   DwIsServerBound(pPCB ppcb, BOOL *pfBound);

DWORD   DwSetEvents();

CHAR*   DecodePw(CHAR* pszPassword );

CHAR*   EncodePw(CHAR *pszPassword );

DWORD   InitializeRasAudio();

DWORD   UninitializeRasAudio();

BOOL    FRasmanAccessCheck();

DWORD   DwCacheCredMgrCredentials(PPPE_MESSAGE *pMsg, pPCB ppcb);

DWORD    DwInitializeIphlp();

VOID    DwUninitializeIphlp();

DWORD   DwGetBestInterface(
                DWORD DestAddress,
                DWORD *pdwAddress,
                DWORD *pdwMask);

DWORD   DwCacheRefInterface(pPCB ppcb);

VOID    QueueCloseConnections(ConnectionBlock *pConn,
                              HANDLE hEvent,
                              BOOL   *pfQueued);

VOID    SaveEapCredentials(pPCB ppcb, PBYTE buffer);


//
// param.c
//
DWORD   GetProtocolInfoFromRegistry () ;

BOOL    ReadNetbiosInformationSection () ;

BOOL    ReadNetbiosSection () ;

VOID    FillProtocolInfo () ;

VOID    GetLanNetsInfo (DWORD *, UCHAR UNALIGNED *) ;

BOOL    BindingDisabled (PCHAR) ;

DWORD   FixPcbs();

//
// rnetcfg.c
//
DWORD dwRasInitializeINetCfg();

DWORD dwRasUninitializeINetCfg();

DWORD dwGetINetCfg(PVOID *);

DWORD dwGetMaxProtocols( WORD *);

DWORD dwGetProtocolInfo( PBYTE );

//
// rasrpcs.c
//
DWORD InitializeRasRpc( void );

void UninitializeRasRpc( void );

//
// rasipsec.c
//
DWORD DwInitializeIpSec(void);

DWORD DwUnInitializeIpSec(void);

DWORD DwAddIpSecFilter(pPCB ppcb, BOOL fServer, RAS_L2TP_ENCRYPTION eEncryption);

DWORD
DwAddServerIpSecFilter(
    pPCB ppcb,
    RAS_L2TP_ENCRYPTION eEncryption
    );

DWORD
DwAddClientIpSecFilter(
    pPCB ppcb,
    RAS_L2TP_ENCRYPTION eEncryption
    );

DWORD DwDeleteIpSecFilter(pPCB ppcb, BOOL fServer);

DWORD
DwDeleteServerIpSecFilter(
    pPCB ppcb
    );

DWORD
DwDeleteClientIpSecFilter(
    pPCB ppcb
    );

PIPSEC_SRV_NODE
AddNodeToServerList(
    PIPSEC_SRV_NODE pServerList,
    RAS_L2TP_ENCRYPTION eEncryption,
    DWORD dwIpAddress,
    LPWSTR pszMMPolicyName,
    GUID gMMPolicyID,
    LPWSTR pszQMPolicyName,
    GUID gQMPolicyID,
    GUID gMMAuthID,
    GUID gTxFilterID,
    HANDLE hTxFilter,
    GUID gMMFilterID,
    HANDLE hMMFilter
    );

PIPSEC_SRV_NODE
FindServerNode(
    PIPSEC_SRV_NODE pServerList,
    DWORD dwIpAddress
    );

PIPSEC_SRV_NODE
RemoveNode(
    PIPSEC_SRV_NODE pServerList,
    PIPSEC_SRV_NODE pNode
    );



DWORD DwIsIpSecEnabled(pPCB ppcb,
                       BOOL *pfEnabled);

DWORD DwGetIpSecInformation(pPCB ppcb, DWORD *pdwIpsecInfo);

DWORD DwDoIke(pPCB ppcb, HANDLE hEvent);
DWORD DwQueryIkeStatus(pPCB ppcb, DWORD * pdwStatus);

DWORD DwUpdatePreSharedKey(DWORD cbkey, BYTE  *pbkey);

VOID UninitializeIphlp();

//
// ep.c
//
DWORD DwEpInitialize();

VOID  EpUninitialize();

DWORD DwAddEndPointsIfRequired();

DWORD DwRemoveEndPointsIfRequired();

DWORD DwUninitializeEpForProtocol(EpProts protocol);

DWORD DwInitializeWatermarksForProtocol(EpProts protocol);

//
// misc.c
//
DWORD DwQueueRedial(ConnectionBlock *);

BOOL  IsCustomDLLTrusted(LPWSTR   lpwstrDLLName);

DWORD DwBindServerToAdapter(
                    WCHAR *pwszGuidAdapter,
                    BOOL fBind,
                    RAS_PROTOCOLTYPE Protocol);

DWORD
DwSetTcpWindowSize(
        WCHAR *pszAdapterName,
        ConnectionBlock *pConn,
        BOOL fSet);

VOID
DwResetTcpWindowSize(
        CHAR *pszAdapterName);
                    
                    
WCHAR * StrdupAtoW(LPCSTR psz);

DWORD RasImpersonateUser(HANDLE hProcess);

DWORD RasRevertToSelf();

VOID
RasmanTrace(
    CHAR * Format,
    ...
);

BOOL 
IsRouterPhonebook(CHAR * pszPhonebook);


//
// thunk.c
//
VOID ThunkPortOpenRequest(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPortDisconnectRequest(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkDeviceConnectRequest(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkGetInfoRequest(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkRequestNotificationRequest(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPortBundle(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkGetBundledPort(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPortGetBundle(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkBundleGetPort(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkCreateConnection(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkEnumConnection(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkAddConnectionPort(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkEnumConnectionPorts(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkGetConnectionParams(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkSetConnectionParams(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkGetConnectionUserData(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkSetConnectionUserData(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPppStop(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPppStart(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPppRetry(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPppGetInfo(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPppChangePwd(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPppCallback(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkAddNotification(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkSignalConnection(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkSetIoCompletionPort(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkFindPrerequisiteEntry(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPortOpenEx(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkGetLinkStats(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkGetConnectionStats(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkGetHportFromConnection(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkReferenceCustomCount(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkGetHconnFromEntry(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkSendNotificationRequest(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkDoIke(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPortSendRequest(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPortReceiveRequest(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPortReceiveRequestEx(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkRefConnection(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);

VOID ThunkPppGetEapInfo(pPCB ppcb, BYTE *pBuffer, DWORD dwBufSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\param.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name: 

    param.c

Abstract:

    Registry reading code for netbios protocol
    
Author:

    Gurdeep Singh Pall (gurdeep) 16-Jun-1992

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <raserror.h>
#include <devioctl.h>
#include <stdlib.h>
#include <string.h>
#include <media.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"

pTransportInfo	   XPortInfo = NULL ;
DWORD		       ProtocolCount ;

#if DBG
extern DWORD g_dwRasDebug;
#endif

/*++

Routine Description

    Reads the NetBIOSInformation and Netbios KEYS from the
    registry to assimilate the lananumbers, xportnames and
    wrknets information.

Arguments

Return Value
    
    SUCCESS
    ERROR_READING_PROTOCOL_INFO
--*/
DWORD
GetProtocolInfoFromRegistry ()
{
    DWORD retcode = SUCCESS;

    //
    // First parse the NetBIOSInformation key: this function
    // also allocates space for the TransportInfo structure.
    //
    if(!ReadNetbiosInformationSection ())
    {
        return E_FAIL;
    }

    //
    // Read NetBios key and fill in the xportnames into the
    // TransportInfo structure
    //
    ReadNetbiosSection ();

    //
    // Use the information collected above to fill in the
    // protocol info struct.
    //
    FillProtocolInfo () ;

    //
    // Fix the PCBs in case they are pointing to stale data
    // because of addition/removal of netbeui.
    //
    retcode = FixPcbs();    

    //
    // Free the information we saved.
    //
    if(NULL != XPortInfoSave)
    {
        LocalFree(XPortInfoSave);
        XPortInfoSave = NULL;
    }

    if(NULL != ProtocolInfoSave)
    {
        LocalFree(ProtocolInfoSave);
        ProtocolInfoSave = NULL;
    }

    MaxProtocolsSave = 0;

    return SUCCESS ;
}

/*++

Routine Description

    Because of the setup change - it reads NETBIOS section
    instead for the lana map

Arguments

Return Value
    
--*/    
BOOL
ReadNetbiosInformationSection ()
{
    HKEY    hkey    = NULL;
    WORD    i ;
    PCHAR   pvalue,
            route   = NULL;
    DWORD   type ;
    DWORD   size = 0 ;
    BOOL    fRet = TRUE;

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
        		    REGISTRY_NETBIOS_KEY_NAME,
		            &hkey))
    {		    
        fRet = FALSE;
    	goto done ;
    }

    RegQueryValueEx (hkey,
                     REGISTRY_ROUTE,
                     NULL,
                     &type,
                     NULL,
                     &size) ;

    route = (PCHAR) LocalAlloc (LPTR, size) ;
    
    if (route == NULL)
    {
        fRet = FALSE;
	    goto done ;
	}

    if (RegQueryValueEx (hkey,
                         REGISTRY_ROUTE,
                         NULL,
                         &type,
                         route,
                         &size))
    {
        fRet = FALSE;
    	goto done ;
    }

    //
    // Calculate the number of strings in the value: they
    // are separated by NULLs, the last one ends in 2 NULLs.
    //
    for (i = 0, pvalue = (PCHAR)&route[0]; *pvalue != '\0'; i++)
    {
	    pvalue += (strlen(pvalue) +1) ;
	}

    //
    // Save away the XPortInfo. We will need this in case we are
    // reinitializing the protocol info structs as a result of  
    // an adapter/device being added or removed. We might have
    // already given a pointer to this structure in RasAllocate
    // route call to PPP.
    //
    XPortInfoSave = XPortInfo;

    //
    // Now i is the number of netbios relevant routes
    // (hence lanas): Allocate memory for that many 
    // TransportInfo structs.
    //
    XPortInfo = (pTransportInfo) LocalAlloc (
                                  LPTR,
                                  sizeof(TransportInfo)
                                  * i) ;
    if (XPortInfo == NULL)
    {
        fRet = FALSE;
    	goto done ;
    }

    //
    // Now walk through the registry key and pick up the
    // LanaNum and EnumExports information by reading the
    // lanamap
    //
    for (i = 0, pvalue = (PCHAR)&route[0]; *pvalue != '\0'; i++) 
    {

        strcpy (XPortInfo[i].TI_Route, _strupr(pvalue)) ;

    	pvalue += (strlen(pvalue) +1) ;
    }

    ProtocolCount = i ;

done:
    if (hkey)
    {
        RegCloseKey (hkey) ;
    }

    if (route)            
    {
        LocalFree (route) ;
    }

    return fRet ;
}

CHAR *
pszGetSearchStr(CHAR *pszValue)
{
    CHAR *psz = NULL;

    psz = pszValue + strlen(pszValue);

    while(  (psz != pszValue)
        &&  ('_' != *psz)
        &&  ('\\' != *psz))
    {
        psz -= 1;
    }
    
    if(     ('_' == *psz)
        ||  ('\\' == *psz))
    {
        psz += 1;
    }

    return psz;
}

BOOL
XPortNameAlreadyPresent(CHAR *pszxvalue)
{
    DWORD i = ProtocolCount;

    for(i = 0; i < ProtocolCount; i++)
    {
        if(0 == _strcmpi(XPortInfo[i].TI_XportName,
                         pszxvalue))
        {
            break;
        }
    }

    return (i != ProtocolCount);
}

BOOL
ReadNetbiosSection ()
{

    HKEY    hkey = NULL;
    BYTE    buffer [1] ;
    WORD    i,j,k ;
    PCHAR   pguid, 
            routevalue, 
            xnames = NULL, 
            route = NULL, 
            xvalue,
            xnamesupr = NULL,
            xvalueupr;

    DWORD   type ;
    DWORD   size = sizeof(buffer) ;
    BOOL    fRet = TRUE;
    PBYTE   lanamap = NULL, lanamapmem = NULL;

    CHAR    *pszSearchStr = NULL;

    //
    // Open the Netbios key in the Registry
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE,
        		   REGISTRY_NETBIOS_KEY_NAME,
		           &hkey))
    {
        fRet = FALSE;
        goto done;
    }

    //
    // First read the ROUTE value
    // Get the route value size:
    //
    RegQueryValueEx (hkey,
                     REGISTRY_ROUTE,
                     NULL,
                     &type,
                     buffer,
                     &size) ;

    route = (PCHAR) LocalAlloc (LPTR, size) ;
    
    if (route == NULL)
    {
        fRet = FALSE;
	    goto done ;
	}
	
    //
    // Now get the whole string
    //
    if (RegQueryValueEx (hkey, 
                         REGISTRY_ROUTE, 
                         NULL, 
                         &type, 
                         route, 
                         &size))
    {
        fRet = FALSE;
    	goto done ;
    }

    //
    // Read the Bind value
    // Get the "Bind" line size
    //
    size = sizeof (buffer) ;
    
    RegQueryValueEx (hkey, 
                     "Bind", 
                     NULL, 
                     &type, 
                     buffer, 
                     &size) ;

    xnames = (PCHAR) LocalAlloc (LPTR, size) ;
    if (xnames == NULL)
    {
        fRet = FALSE;
	    goto done ;
	}

    xnamesupr = (PCHAR) LocalAlloc(LPTR, size);
    if(NULL == xnamesupr)
    {
        fRet = FALSE;
        goto done;
    }

    //
    // Now get the whole string
    //
    if (RegQueryValueEx (hkey, 
                         "Bind", 
                         NULL, 
                         &type, 
                         xnames, 
                         &size))
    {
        fRet = FALSE;
    	goto done;
    }

    memcpy(xnamesupr, xnames, size);

    //
    // Now get hold of the lana map:
    //
    size = 0 ;

    if (RegQueryValueEx (hkey,
                     REGISTRY_LANAMAP,
                     NULL,
                     &type,
                     NULL,
                     &size))
    {
        fRet = FALSE;
        goto done ;
    }

    lanamapmem = lanamap = (PBYTE) LocalAlloc (LPTR, size+1) ;

    if (lanamap == NULL)
    {
        fRet = FALSE;
        goto done ;
    }

    if (RegQueryValueEx (hkey,
                         REGISTRY_LANAMAP,
                         NULL,
                         &type,
                         (LPBYTE)lanamap,
                         &size))
    {
        fRet = FALSE;
        goto done ;
    }

    //
    // Now walk the two lists: For each entry in the
    // "route" value find it in the routes already 
    // collected from the NetBIOSInformation key. For
    // each route found - copy the xportname in the
    // same ordinal position in the BIND line
    //
    routevalue = (PCHAR) &route[0];
    
    for (i = 0; (*routevalue != '\0'); i++) 
    {
        lanamap = lanamapmem;
        
        xvalue = (PCHAR) &xnames[0];

        xvalueupr = (PCHAR) &xnamesupr[0];

        // DbgPrint("routevalue    = %s\n", routevalue);

        //
    	// For each route try and find it in the 
    	// TransportInfo struct:
    	//
    	for (j = 0; (*xvalue != '\0') ; j++) 
    	{

            pszSearchStr = pszGetSearchStr(_strupr(xvalueupr));

    	    //
    	    // If the same route is found in the XPortInfo
    	    // add the xportname correspondingly.
    	    //
            if(strstr(_strupr(routevalue), pszSearchStr))
            {
                if(!XPortNameAlreadyPresent(xvalue))
                {
                    strcpy(XPortInfo[i].TI_XportName, xvalue);
                    XPortInfo[i].TI_Wrknet = (DWORD) *lanamap++ ;
                    XPortInfo[i].TI_Lana   = (DWORD) *lanamap++ ;

                    // DbgPrint("pSearchStr = %s\n", pszSearchStr);
#if DBG
                    DbgPrint("%02X%02X    %s\n", 
                             XPortInfo[i].TI_Wrknet,
                             XPortInfo[i].TI_Lana,
                             XPortInfo[i].TI_XportName);
#endif

                    // DbgPrint("XPortName  = %s\n\n", XPortInfo[i].TI_XportName);

                    break;               
                }
#if DBG
                else
                {
                    DbgPrint("Transport %s already present\n",
                             xvalue);
                }
#endif
            }

            xvalue     += (strlen(xvalue) +1) ;
            xvalueupr  += (strlen(xvalueupr) + 1) ;
            lanamap += 2;
    	}

    	routevalue += (strlen(routevalue) +1) ;
    }

done:    
    if (hkey)
    {
        RegCloseKey (hkey) ;
    }

    if(NULL != lanamapmem)
    {
        LocalFree(lanamapmem);
    }

    if(NULL != xnames)
    {
        LocalFree(xnames);
    }

    if(NULL != route)
    {
        LocalFree(route);
    }

    if(NULL != xnamesupr)
    {
        LocalFree(xnamesupr);
    }
        
    return fRet ;
}

VOID
FillProtocolInfo ()
{
    WORD    i, j;
    PCHAR   phubname ;
    HKEY	hkey ;
    PCHAR    str ;
    PCHAR    ch ;

    //
    // For each entry in protocolinfo: find the xportname
    // and lana number
    //
    for (i = 0; i < MaxProtocols; i++) 
    {
        //
    	// extract the "rashub0x" from the adapter name
    	// go past the "\device\"
    	//
	    phubname = ProtocolInfo[i].PI_AdapterName + 8;
	    phubname = _strupr (phubname) ;

        //
    	// If Netbios network: Look for the route for this rashub
    	// binding and fill in the xportname and lana number if 
    	// found.
    	//
	    if (ProtocolInfo[i].PI_Type == ASYBEUI) 
    	{

            PCHAR   pszRoute;    
	
    	    for (j = 0; j < (WORD) ProtocolCount; j++) 
	        {

    	        pszRoute = _strupr (XPortInfo[j].TI_Route);

	    	    if (str = strstr (XPortInfo[j].TI_Route, phubname)) 
    	    	{
    	    	
    	    	    strcpy (ProtocolInfo[i].PI_XportName,
    	    	            XPortInfo[j].TI_XportName) ;
    	    	            
	    	        ProtocolInfo[i].PI_LanaNumber = 
	    	            (UCHAR) XPortInfo[j].TI_Lana ;
	    	            
		            if (XPortInfo[j].TI_Wrknet)
		            {
            			ProtocolInfo[i].PI_WorkstationNet = TRUE ;
            	    }
	        	    else
	        	    {
		        	    ProtocolInfo[i].PI_WorkstationNet = FALSE ;
		        	}
		        	
		            break ;
        		}
	        }
	        
            //
	        // If this adaptername is not found in XportInfo then
	        // mark the type field in the ProtocolInfo struct to be
	        // INVALID_TYPE - since we will not be able to use this
	        // anyway.
	        //
    	    if (j == (WORD) ProtocolCount)
    	    {
	        	ProtocolInfo[i].PI_Type = INVALID_TYPE ;
	        }
    	}

    }
}


VOID
GetLanNetsInfo (DWORD *count, UCHAR UNALIGNED *lanas)
{
    DWORD   i ;

    *count = 0 ;

    //
    // Run through all the protocol structs we have and pick
    // up the lana nums for the NON Rashub bound protocols -
    // if they are not disabled with remoteaccess these are
    // the lan lanas.
    //
    for (i = 0; i < ProtocolCount; i++) 
    {
    	if (    (!strstr (XPortInfo[i].TI_Route, "NDISWAN"))
            &&  (-1 != (DWORD) XPortInfo[i].TI_Lana)
    	    &&  (!BindingDisabled (XPortInfo[i].TI_XportName)))
    	{
    	    lanas[(*count)++] = (UCHAR) XPortInfo[i].TI_Lana ;
    	}
    }
}

BOOL
BindingDisabled (PCHAR binding)
{
    HKEY    hkey ;
    BYTE    buffer [1] ;
    WORD    i ;
    PCHAR   xnames, xvalue ;
    DWORD   type ;
    DWORD   size = sizeof(buffer) ;

    //
    // Open the Netbios key in the Registry
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE,
		           REGISTRY_REMOTEACCESS_KEY_NAME,
        		   &hkey))
    {        		   
    	return FALSE;
    }

    size = sizeof (buffer) ;
    RegQueryValueEx (hkey,
                     "Bind",
                     NULL,
                     &type,
                     buffer,
                     &size) ;

    xnames = (PCHAR) LocalAlloc (LPTR, size) ;
    
    if (xnames == NULL) 
    {
    	RegCloseKey (hkey) ;
	    return FALSE ;
    }

    //
    // Now get the whole string
    //
    if (RegQueryValueEx (hkey,
                         "Bind",
                         NULL,
                         &type,
                         xnames,
                         &size)) 
    {
    	RegCloseKey (hkey) ;
	    return FALSE ;
    }

    RegCloseKey (hkey) ;

    //
    // Now iterate through the list and find the
    // disabled bindings
    //
    xvalue = (PCHAR)&xnames[0];
    
    for (i = 0; *xvalue != '\0'; i++) 
    {
	    if (!_strcmpi (binding, xvalue))
	    {
	        //
            // found in the disabled list!!!!!
            //
	        return TRUE ;
	    }
	    
    	xvalue	   += (strlen(xvalue) +1) ;
    }

    return FALSE ;
}

VOID
FixList(pList *ppList, pProtInfo pInfo, pProtInfo pNewInfo)
{
    while(NULL != *ppList)
    {
        if((*ppList)->L_Element == pInfo)
        {
            if(NULL != pNewInfo)
            {
#if DBG                
                RasmanTrace(
                    "FixList: Replacing 0x%x with 0x%x",
                    (*ppList)->L_Element,
                    pNewInfo);
#endif
                (*ppList)->L_Element = pNewInfo;
            }
            else
            {
                pList plist = *ppList;
                
#if DBG                
                RasmanTrace(
                    "FixList: Freeing pList 0x%x",
                    plist);
#endif
                //
                // Means this adapter has been removed.
                // free the list entry
                //
                (*ppList) = (*ppList)->L_Next;
                LocalFree(plist);
            }
            
            goto done;
        }

        ppList = &(*ppList)->L_Next;
    }

done:    

    return;
}

DWORD
FindAndFixProtInfo(pProtInfo pInfo, DWORD index)
{
    DWORD dwErr = SUCCESS;

    DWORD i;
    
    pProtInfo pNewInfo = NULL;

    pPCB ppcb = NULL;

    LIST_ENTRY *pEntry;
    Bundle *pBundle;

    pList plist = NULL;
    pList *ppList = NULL;

    if(index < MaxProtocols)
    {
        pNewInfo = &ProtocolInfo[index];
    }

    if(     (NULL != pNewInfo)
        &&  (0 != _strcmpi(pInfo->PI_XportName,
                     pNewInfo->PI_XportName)))
    {
        pNewInfo = NULL;
    }

    if(NULL == pNewInfo)
    {
        DWORD i;

        for(i = 0; i < MaxProtocols; i++)
        {
            if(0 == _strcmpi(pInfo->PI_XportName,
                             ProtocolInfo[i].PI_XportName))
            {
                pNewInfo = &ProtocolInfo[i];
                break;
            }
        }
    }

    if(NULL != pNewInfo)
    {
        //
        // We found the protnfo struct corresponding to the
        // allocated route information we handed off to PPP.
        //
        pNewInfo->PI_Allocated = pInfo->PI_Allocated;
        pNewInfo->PI_WorkstationNet = pInfo->PI_WorkstationNet;
        pNewInfo->PI_DialOut = pInfo->PI_DialOut;
    }
    
    //
    // Now walk down the pcbs and patch them up to point to
    // the right structure. TODO: This can be further opt
    // imized by keeping a pointer to ppcb in Protinfo struct
    // in RasActivateRoute and NULL'ing out the pointer in
    // RasDeActivateRoute.
    //
    for(i = 0; i < MaxPorts; i++)
    {
        ppcb = Pcb[i];

        if(NULL == ppcb)
        {
            continue;
        }

        if(NULL != ppcb->PCB_Bindings)
        {
            ppList = &ppcb->PCB_Bindings;

            FixList(ppList, pInfo, pNewInfo);
        }
        
        if(    (NULL != ppcb->PCB_Bundle)
           &&  (NULL != ppcb->PCB_Bundle->B_Bindings))
        {
            ppList = &ppcb->PCB_Bundle->B_Bindings;

            FixList(ppList, pInfo, pNewInfo);
        }
    }        

    if (!IsListEmpty(&BundleList))
    {
        for (pEntry = BundleList.Flink;
             pEntry != &BundleList;
             pEntry = pEntry->Flink)
        {
            pBundle = CONTAINING_RECORD(pEntry, Bundle, B_ListEntry);

            ppList = &pBundle->B_Bindings;

            FixList(ppList, pInfo, pNewInfo);
        }
    }
    
    return dwErr;
}

DWORD
FixPcbs()
{
    DWORD dwErr = SUCCESS;
    DWORD i;

    //
    // Keep counters to detect if there are any allocated routes
    // handed off to PPP before we get into this.
    //
    if(     (0 == MaxProtocolsSave)
        ||  (0 == g_cNbfAllocated))
    {
        goto done;
    }

    RasmanTrace("FixPcbs: Replacing %x by %x",
             &ProtocolInfoSave,
             &ProtocolInfo);

    //
    // Walk through the old list and see if ppp had already called 
    // RasAllocateRoute. on any of them and update the state in the 
    // new XPortInfo struct if it did so.
    //
    for(i = 0; i < MaxProtocolsSave; i++)
    {
        dwErr = FindAndFixProtInfo(&ProtocolInfoSave[i], i);
    } 

done:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\offers.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    rasipsec.c

Abstract:

    All code corresponding to the interface between ras and the
    IPSEC Policy Agent lives here

Author:

    Rao Salapaka (raos) 03-Mar-1998

Revision History:

--*/

#ifndef UNICODE
#define UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <raserror.h>
#include <media.h>
#include <devioctl.h>
#include <windows.h>
#include <wincrypt.h>
#include <tchar.h>
#include <stdlib.h>
#include <string.h>
#include <mprlog.h>
#include <rtutils.h>
#include <rpc.h>
#include "logtrdef.h"
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "nouiutil.h"
#include "loaddlls.h"
#include "winsock2.h"
#include "winipsec.h"
#include "memory.h"
#include "certmgmt.h"
#include "offers.h"


#define L2TP_IPSEC_DEFAULT_BYTES     250000

#define L2TP_IPSEC_DEFAULT_TIME      3600

DWORD
BuildOffers(
    RAS_L2TP_ENCRYPTION eEncryption,
    PIPSEC_QM_OFFER pOffers,
    PDWORD pdwNumOffers,
    PDWORD pdwFlags
    )
{

    DWORD dwStatus = ERROR_SUCCESS;

    switch (eEncryption) {

    case RAS_L2TP_NO_ENCRYPTION:
        *pdwFlags = 0;
        dwStatus = BuildNoEncryption(
                        pOffers,
                        pdwNumOffers
                        );
        break;


    case RAS_L2TP_OPTIONAL_ENCRYPTION:
        dwStatus = BuildOptEncryption(
                        pOffers,
                        pdwNumOffers
                        );
        break;


    case RAS_L2TP_REQUIRE_ENCRYPTION:
        *pdwFlags = 0;
        dwStatus = BuildRequireEncryption(
                        pOffers,
                        pdwNumOffers
                        );
        break;


    case RAS_L2TP_REQUIRE_MAX_ENCRYPTION:
        *pdwFlags = 0;
        dwStatus = BuildStrongEncryption(
                        pOffers,
                        pdwNumOffers
                        );
        break;

    }

    return(dwStatus);
}


DWORD
BuildOptEncryption(
    PIPSEC_QM_OFFER pOffers,
    PDWORD pdwNumOffers
    )
/*++

    Negotiation Policy Name:                L2TP server any encryption default
    ISAKMP quick mode PFS:                  off (accepts if requested)
    Bi-directional passthrough filter:      no
    Inbound passthrough filter,
       normal outbound filter:              no
    Fall back to clear if no response:      no
    Secure Using Security Method List:      yes

    1. ESP 3_DES MD5
    2. ESP 3_DES SHA
    3. AH SHA1 with ESP 3_DES with null HMAC
    4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed
    5. AH SHA1 with ESP 3_DES SHA1, no lifetimes
    6. AH MD5  with ESP 3_DES MD5, no lifetimes

    7. ESP DES MD5
    8. ESP DES SHA1, no lifetimes
    9. AH SHA1 with ESP DES null HMAC, no lifetimes proposed
    10. AH MD5  with ESP DES null HMAC, no lifetimes proposed
    11. AH SHA1 with ESP DES SHA1, no lifetimes
    12. AH MD5  with ESP DES MD5, no lifetimes

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PIPSEC_QM_OFFER pOffer = pOffers;

    // 1. ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 2. ESP 3_DES SHA, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 3. AH SHA1 with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 5. AH SHA1 with ESP 3_DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_SHA1,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 6. AH MD5  with ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 7. ESP DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 8. ESP DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 9. AH SHA1 with ESP DES null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 10. AH MD5  with ESP DES null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 11. AH SHA1 with ESP DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_SHA1,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 12. AH MD5  with ESP DES MD5, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_MD5,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 13. ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, 0, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 14. ESP 3_DES SHA, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, 0, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 15. AH SHA

    BuildOffer(
        pOffer, 1,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 16. AH MD5

    BuildOffer(
        pOffer, 1,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    *pdwNumOffers = 16;

    return(dwStatus);
}


DWORD
BuildStrongEncryption(
    PIPSEC_QM_OFFER pOffers,
    PDWORD pdwNumOffers
    )
/*++

    Negotiation Policy Name:                L2TP server strong encryption default
    ISAKMP quick mode PFS:                  off (accepts if requested)
    Bi-directional passthrough filter:      no
    Inbound passthrough filter,
       normal outbound filter:              no
    Fall back to clear if no response:      no
    Secure Using Security Method List:      yes

    1. ESP 3_DES MD5, no lifetimes
    2. ESP 3_DES SHA, no lifetimes
    3. AH SHA1 with ESP 3_DES with null HMAC, no lifetimes proposed
    4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed
    5. AH SHA1 with ESP 3_DES SHA1, no lifetimes
    6. AH MD5  with ESP 3_DES MD5, no lifetimes

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PIPSEC_QM_OFFER pOffer = pOffers;

    // 1. ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 2. ESP 3_DES SHA, no lifetimes;

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 3. AH SHA1 with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 5. AH SHA1 with ESP 3_DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_SHA1,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 6. AH MD5  with ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );

    *pdwNumOffers  = 6;

    return(dwStatus);

}

void
BuildOffer(
    PIPSEC_QM_OFFER pOffer,
    DWORD dwNumAlgos,
    DWORD dwFirstOperation,
    DWORD dwFirstAlgoIdentifier,
    DWORD dwFirstAlgoSecIdentifier,
    DWORD dwSecondOperation,
    DWORD dwSecondAlgoIdentifier,
    DWORD dwSecondAlgoSecIdentifier,
    DWORD dwKeyExpirationBytes,
    DWORD dwKeyExpirationTime
    )
{
    memset(pOffer, 0, sizeof(IPSEC_QM_OFFER));

    pOffer->Lifetime.uKeyExpirationKBytes = dwKeyExpirationBytes;
    pOffer->Lifetime.uKeyExpirationTime = dwKeyExpirationTime;

    pOffer->dwFlags = 0;                      // No flags.
    pOffer->bPFSRequired = FALSE;             // Phase 2 PFS not required.
    pOffer->dwPFSGroup = PFS_GROUP_NONE;

    pOffer->dwNumAlgos = dwNumAlgos;

    if (dwNumAlgos >= 1) {

        pOffer->Algos[0].Operation = dwFirstOperation;
        pOffer->Algos[0].uAlgoIdentifier = dwFirstAlgoIdentifier;
        pOffer->Algos[0].uAlgoKeyLen = 64;
        pOffer->Algos[0].uAlgoRounds = 8;
        pOffer->Algos[0].uSecAlgoIdentifier = dwFirstAlgoSecIdentifier;
        pOffer->Algos[0].MySpi = 0;
        pOffer->Algos[0].PeerSpi = 0;

    }

    if (dwNumAlgos == 2) {

        pOffer->Algos[1].Operation = dwSecondOperation;
        pOffer->Algos[1].uAlgoIdentifier = dwSecondAlgoIdentifier;
        pOffer->Algos[1].uAlgoKeyLen = 64;
        pOffer->Algos[1].uAlgoRounds = 8;
        pOffer->Algos[1].uSecAlgoIdentifier = dwSecondAlgoSecIdentifier;
        pOffer->Algos[1].MySpi = 0;
        pOffer->Algos[1].PeerSpi = 0;

    }
}



DWORD
BuildNoEncryption(
    PIPSEC_QM_OFFER pOffers,
    PDWORD pdwNumOffers
    )
/*++

    Negotiation Policy Name:                L2TP server any encryption default
    ISAKMP quick mode PFS:                  off (accepts if requested)
    Bi-directional passthrough filter:      no
    Inbound passthrough filter,
       normal outbound filter:              no
    Fall back to clear if no response:      no
    Secure Using Security Method List:      yes

    1. AH SHA1
    2. AH MD5


--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PIPSEC_QM_OFFER pOffer = pOffers;

    // 1. ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, 0, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 2. ESP 3_DES SHA, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, 0, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 3. AH SHA

    BuildOffer(
        pOffer, 1,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 4. AH MD5

    BuildOffer(
        pOffer, 1,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    *pdwNumOffers = 4;

    return(dwStatus);
}



DWORD
BuildRequireEncryption(
    PIPSEC_QM_OFFER pOffers,
    PDWORD pdwNumOffers
    )
/*++

    Negotiation Policy Name:                L2TP server any encryption default
    ISAKMP quick mode PFS:                  off (accepts if requested)
    Bi-directional passthrough filter:      no
    Inbound passthrough filter,
       normal outbound filter:              no
    Fall back to clear if no response:      no
    Secure Using Security Method List:      yes

    1. ESP 3_DES MD5
    2. ESP 3_DES SHA
    3. AH SHA1 with ESP 3_DES with null HMAC
    4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed
    5. AH SHA1 with ESP 3_DES SHA1, no lifetimes
    6. AH MD5  with ESP 3_DES MD5, no lifetimes

    7. ESP DES MD5
    8. ESP DES SHA1, no lifetimes
    9. AH SHA1 with ESP DES null HMAC, no lifetimes proposed
    10. AH MD5  with ESP DES null HMAC, no lifetimes proposed
    11. AH SHA1 with ESP DES SHA1, no lifetimes
    12. AH MD5  with ESP DES MD5, no lifetimes

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PIPSEC_QM_OFFER pOffer = pOffers;

    // 1. ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 2. ESP 3_DES SHA, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 3. AH SHA1 with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 4. AH MD5  with ESP 3_DES with null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 5. AH SHA1 with ESP 3_DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_SHA1,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 6. AH MD5  with ESP 3_DES MD5, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_3_DES, HMAC_AH_MD5,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    // 7. ESP DES MD5, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_MD5,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 8. ESP DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 1,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_SHA1,
        0, 0, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 9. AH SHA1 with ESP DES null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 10. AH MD5  with ESP DES null HMAC, no lifetimes proposed

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, 0,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 11. AH SHA1 with ESP DES SHA1, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_SHA1, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_SHA1,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;


    // 12. AH MD5  with ESP DES MD5, no lifetimes

    BuildOffer(
        pOffer, 2,
        AUTHENTICATION, IPSEC_DOI_AH_MD5, 0,
        ENCRYPTION, IPSEC_DOI_ESP_DES, HMAC_AH_MD5,
        L2TP_IPSEC_DEFAULT_BYTES, L2TP_IPSEC_DEFAULT_TIME
        );
    pOffer++;

    *pdwNumOffers = 12;

    return(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\rasrpcs.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name: 

    common.c

Abstract:

    rpc server stub code
    
Author:

    Rao Salapaka (raos) 06-Jun-1997

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/
#ifndef UNICODE
#define UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <raserror.h>
#include <stdarg.h>
#include <media.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include "string.h"
#include <mprlog.h>
#include <rtutils.h>
#include "logtrdef.h"
#include "rasrpc_s.c"
#include "nouiutil.h"
#include "rasrpclb.h"



#define VERSION_40      4
#define VERSION_50      5

handle_t g_hRpcHandle = NULL;

DWORD
InitializeRasRpc(
    void
    )
{
    RPC_STATUS           RpcStatus;

        
    //
    // Ignore the second argument for now.
    //
    RpcStatus = RpcServerUseProtseqEp( TEXT("ncacn_np"),
                                        1,
                                        TEXT("\\PIPE\\ROUTER"),
                                        NULL );

    //
    // We need to ignore the RPC_S_DUPLICATE_ENDPOINT error
    // in case this DLL is reloaded within the same process.
    //
    if (    RpcStatus != RPC_S_OK 
        &&  RpcStatus != RPC_S_DUPLICATE_ENDPOINT)
    {
        return( I_RpcMapWin32Status( RpcStatus ) );
    }

    //
    // Register our interface with RPC.
    //
    RpcStatus = RpcServerRegisterIfEx(rasrpc_v1_0_s_ifspec,
                                      0,
                                      0,
                                      RPC_IF_AUTOLISTEN,
                                      RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                      NULL );

    if ( ( RpcStatus != RPC_S_OK ) || ( RpcStatus == RPC_S_ALREADY_LISTENING ) )
    {
        return( I_RpcMapWin32Status( RpcStatus ) );
    }

    return (NO_ERROR);

} 


void
UninitializeRasRpc(
    void
    )
{
    //
    // Unregister our interface with RPC.
    //
    (void) RpcServerUnregisterIf(rasrpc_v1_0_s_ifspec, 0, FALSE);

    return;
} 

//
// rasman.dll entry points.
//
DWORD APIENTRY
RasRpcSubmitRequest(
    handle_t h,
    PBYTE pBuffer,
    DWORD dwcbBufSize)
{
    //
    // Service request from the client
    //
    g_hRpcHandle = h;
    ServiceRequest ( (RequestBuffer * ) pBuffer, dwcbBufSize );
    return SUCCESS;
}

/*
DWORD
GetEnumInfo ( RequestBuffer *pLocalBuffer,
              PBYTE pBuffer, 
              PWORD pwcbSize, 
              PWORD pwcEntries )
{
    DWORD       dwErr = SUCCESS;
    REQTYPECAST *pbBuf;

    pbBuf =  (REQTYPECAST *) &pLocalBuffer->RB_Buffer;

    if (*pwcbSize >= pbBuf->Enum.size)
    {
        dwErr = pbBuf->Enum.retcode;
    }
    else
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    *pwcbSize = (WORD) pbBuf->Enum.size;

    *pwcEntries = (WORD) pbBuf->Enum.entries;

    if (SUCCESS == dwErr)
    {
        memcpy (pBuffer,
                pbBuf->Enum.buffer,
                *pwcbSize);
    }

    return dwErr;
    
} */

DWORD APIENTRY
RasRpcPortEnum(
    handle_t h,
    PBYTE pBuffer,
    PWORD pwcbPorts,
    PWORD pwcPorts)
{
    /*

    RequestBuffer *pLocalBuffer;
    DWORD dwErr         = SUCCESS;
    PBYTE pbBuf;

    pLocalBuffer = LocalAlloc (LPTR, 
                               sizeof(RequestBuffer) 
                               + REQUEST_BUFFER_SIZE );    

    if (NULL == pLocalBuffer)
    {
        dwErr = GetLastError();
        goto done;
    }

    pLocalBuffer->RB_Reqtype = REQTYPE_PORTENUM;

    //
    // Get the information
    //
    ServiceRequest(pLocalBuffer);

    dwErr = GetEnumInfo (pLocalBuffer,
                         pBuffer,
                         pwcbPorts,
                         pwcPorts);
    
done:

    if (pLocalBuffer)
    {
        LocalFree(pLocalBuffer);
    }

    return dwErr; */

#if DBG
    ASSERT(FALSE);
#endif

    UNREFERENCED_PARAMETER(h);
    UNREFERENCED_PARAMETER(pBuffer);
    UNREFERENCED_PARAMETER(pwcbPorts);
    UNREFERENCED_PARAMETER(pwcPorts);
    
    return E_FAIL;
    
} // RasRpcPortEnum


DWORD APIENTRY
RasRpcDeviceEnum(
    handle_t h,
    PCHAR pszDeviceType,
    PBYTE pDevices,
    PWORD pwcbDevices,
    PWORD pwcDevices
    )
{
    /*
    RequestBuffer   *pLocalBuffer;
    DWORD           dwErr = SUCCESS;
    REQTYPECAST     *pbBuf;

    pLocalBuffer = LocalAlloc (LPTR, 
                              sizeof(RequestBuffer)
                              + REQUEST_BUFFER_SIZE);

    if ( NULL == pLocalBuffer )
    {
        dwErr = GetLastError();
        goto done;
    }

    pLocalBuffer->RB_Reqtype = REQTYPE_DEVICEENUM;

    pbBuf = (REQTYPECAST *) &pLocalBuffer->RB_Buffer;
    
    //
    // Fill in the devicename
    //
    memcpy (pbBuf->DeviceEnum.devicetype,
            pszDeviceType,
            MAX_DEVICETYPE_NAME);

    ServiceRequest ( pLocalBuffer );             

    dwErr = GetEnumInfo (pLocalBuffer,
                         pDevices,
                         pwcbDevices,
                         pwcDevices);

    
done:

    if (pLocalBuffer)
    {
        LocalFree (pLocalBuffer);
    }

    return dwErr; 

    */

    UNREFERENCED_PARAMETER(h);
    UNREFERENCED_PARAMETER(pszDeviceType);
    UNREFERENCED_PARAMETER(pDevices);
    UNREFERENCED_PARAMETER(pwcbDevices);
    UNREFERENCED_PARAMETER(pwcDevices);

#if DBG
    ASSERT(FALSE);
#endif

    return E_FAIL;
    
} // RasRpcDeviceEnum

DWORD APIENTRY
RasRpcGetDevConfig(
    handle_t h,
    RASRPC_HPORT hPort,
    PCHAR pszDeviceType,
    PBYTE pConfig,
    PDWORD pdwcbConfig
    )
{

    /*

    RequestBuffer   *pLocalBuffer;
    DWORD           dwErr = SUCCESS;
    REQTYPECAST     *pbBuf;
    
    pLocalBuffer = LocalAlloc (LPTR,
                               sizeof(RequestBuffer) 
                               + REQUEST_BUFFER_SIZE);

    if (NULL == pLocalBuffer)
    {
        dwErr = GetLastError();

        goto done;
    }

    pLocalBuffer->RB_Reqtype = REQTYPE_GETDEVCONFIG;

    pLocalBuffer->RB_PCBIndex = hPort;

    pbBuf = ( REQTYPECAST * ) &pLocalBuffer->RB_Buffer;

    strcpy ( pbBuf->GetDevConfig.devicetype,
             pszDeviceType );

    ServiceRequest ( pLocalBuffer );

    dwErr = pbBuf->GetDevConfig.retcode;

    if (SUCCESS != dwErr)
    {
        ;
    }
        
    else if (*pdwcbConfig < pbBuf->GetDevConfig.size)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }
    else
    {
        memcpy (pConfig,
                pbBuf->GetDevConfig.config,
                pbBuf->GetDevConfig.size);
    }

    *pdwcbConfig = pbBuf->GetDevConfig.size;

done:

    if (pLocalBuffer)
    {
        LocalFree (pLocalBuffer);
    }

    return dwErr;        

    */

    UNREFERENCED_PARAMETER(h);
    UNREFERENCED_PARAMETER(hPort);
    UNREFERENCED_PARAMETER(pszDeviceType);
    UNREFERENCED_PARAMETER(pConfig);
    UNREFERENCED_PARAMETER(pdwcbConfig);

#if DBG
    ASSERT(FALSE);
#endif

    return E_FAIL;

} // RasRpcGetDevConfig

DWORD APIENTRY
RasRpcPortGetInfo(
	handle_t h,
	RASRPC_HPORT hPort,
	PBYTE pBuffer,
	PWORD pSize
	)
{
    /*
    RequestBuffer   *pLocalBuffer;
    DWORD           dwErr = SUCCESS;
    REQTYPECAST     *pbBuf;

    pLocalBuffer = LocalAlloc (LPTR,
                               sizeof(RequestBuffer)
                               + REQUEST_BUFFER_SIZE);

    if (NULL == pLocalBuffer)
    {
        dwErr = GetLastError();
        goto done;
    }

    pLocalBuffer->RB_PCBIndex = hPort;

    pLocalBuffer->RB_Reqtype = REQTYPE_PORTGETINFO;

    pbBuf = (REQTYPECAST *) &pLocalBuffer->RB_Buffer;

    ServiceRequest (pLocalBuffer);

    if (*pSize >= pbBuf->GetInfo.size)
    {
        dwErr = pbBuf->GetInfo.retcode;
    }
    else
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    *pSize = (WORD) pbBuf->GetInfo.size;

    if (dwErr == SUCCESS) 
    {   
        RASMAN_DEVICEINFO *devinfo = (RASMAN_DEVICEINFO *)
                                     pbBuf->GetInfo.buffer ;

        //
        // Convert the offset based param structure
        // into pointer based.
        //
        ConvParamOffsetToPointer (devinfo->DI_Params,
                                  devinfo->DI_NumOfParams);
                                  
        CopyParams ( devinfo->DI_Params,
                   ((RASMAN_DEVICEINFO *) pBuffer)->DI_Params,
                   devinfo->DI_NumOfParams);
                   
        ((RASMAN_DEVICEINFO*) pBuffer)->DI_NumOfParams = 
                                    devinfo->DI_NumOfParams;
    }

done:

    if (pLocalBuffer)
    {
        LocalFree (pLocalBuffer);
    }

    return dwErr;        

    */

    UNREFERENCED_PARAMETER(h);
    UNREFERENCED_PARAMETER(hPort);
    UNREFERENCED_PARAMETER(pBuffer);
    UNREFERENCED_PARAMETER(pSize);

#if DBG
    ASSERT(FALSE);
#endif

    return E_FAIL;

} // RasRpcPortGetInfo

//
// rasapi32.dll entry points.
//
DWORD
RasRpcEnumConnections(
    handle_t h,
    LPBYTE lprasconn,
    LPDWORD lpdwcb,
    LPDWORD lpdwc,
    DWORD	dwBufSize
    )
{
    ASSERT(g_pRasEnumConnections);
    return g_pRasEnumConnections((LPRASCONN)lprasconn,
                                 lpdwcb,
                                 lpdwc);

} // RasRpcEnumConnections


DWORD
RasRpcDeleteEntry(
    handle_t h,
    LPWSTR lpwszPhonebook,
    LPWSTR lpwszEntry
    )
{

    return g_pRasDeleteEntry(lpwszPhonebook,
                             lpwszEntry);

} // RasRpcDeleteEntry


DWORD
RasRpcGetErrorString(
    handle_t    h,
    UINT        uErrorValue,
    LPWSTR      lpBuf,
    DWORD       cbBuf
    )
{

    return g_pRasGetErrorString (uErrorValue,
                                 lpBuf,
                                 cbBuf );

} // RasRpcGetErrorString


DWORD
RasRpcGetCountryInfo(
    handle_t h,
    LPBYTE lpCountryInfo,
    LPDWORD lpdwcbCountryInfo
    )
{
    ASSERT(g_pRasGetCountryInfo);
    
    return g_pRasGetCountryInfo((LPRASCTRYINFO)lpCountryInfo, 
                                lpdwcbCountryInfo);
} // RasRpcGetCountryInfo

//
// nouiutil.lib entry points.
//
DWORD
RasRpcGetInstalledProtocols(
    handle_t h
)
{
    return GetInstalledProtocols();
} // RasRpcGetInstalledProtocols

DWORD
RasRpcGetInstalledProtocolsEx (
    handle_t h,
    BOOL fRouter,
    BOOL fRasCli,
    BOOL fRasSrv
    )
{
    return GetInstalledProtocolsEx ( NULL,
                                     fRouter,
                                     fRasCli,
                                     fRasSrv );
} // RasRpcGetInstalledProtocolsEx

DWORD
RasRpcGetUserPreferences(
    handle_t h,
    LPRASRPC_PBUSER pUser,
    DWORD dwMode
    )
{
    DWORD dwErr;
    PBUSER pbuser;

    //
    // Read the user preferences.
    //
    dwErr = GetUserPreferences(NULL, &pbuser, dwMode);
    if (dwErr)
    {
        return dwErr;
    }
    
    //
    // Convert from RAS format to RPC format.
    //
    return RasToRpcPbuser(pUser, &pbuser);

} // RasRpcGetUserPreferences


DWORD
RasRpcSetUserPreferences(
    handle_t h,
    LPRASRPC_PBUSER pUser,
    DWORD dwMode
    )
{
    DWORD dwErr;
    PBUSER pbuser;

    //
    // Convert from RPC format to RAS format.
    //
    dwErr = RpcToRasPbuser(&pbuser, pUser);
    if (dwErr)
    {
        return dwErr;
    }
    
    //
    // Write the user preferences.
    //
    return SetUserPreferences(NULL, &pbuser, dwMode);

} // RasRpcSetUserPreferences


UINT
RasRpcGetSystemDirectory(
    handle_t h,
    LPWSTR lpBuffer,
    UINT uSize
    )
{
    if(uSize < MAX_PATH)
    {
        return E_INVALIDARG;
    }
    
    return GetSystemDirectory(lpBuffer, uSize );
        
} // RasRpcGetSystemDirectory


DWORD
RasRpcGetVersion(
    handle_t h,
    PDWORD pdwVersion
)
{

   *pdwVersion = VERSION_501;

    return SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\rasmans.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name: 

    common.c

Abstract:

    Entry points for rasmans.dll
    
Author:

    Gurdeep Singh Pall (gurdeep) 16-Jun-1992

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rasman.h>
#include <wanpub.h>
#include <raserror.h>
#include <stdarg.h>
#include <media.h>
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include "string.h"
#include <mprlog.h>
#include <rtutils.h>
#include "logtrdef.h"

/*++

Routine Description

    Used by the RASMAN service to initialize the data/state
    in the RASMAN DLL at start up time. This should not be
    confused with the INIT code executed when any process loads
    the RASMAN DLL.

Arguments

Return Value

    SUCCESS
    Non zero - any error

--*/
DWORD
_RasmanInit( LPDWORD pNumPorts )
{
    //
    // InitRasmanService() routine is where all the
    // work is done.
    //
    return InitRasmanService( pNumPorts ) ;
}


/*++

Routine Description

    All the work done by the RASMAN process thread(s) captive in
    the RASMAN DLL is done in this call. This will only return
    when the RASMAN service is to be stopped.

Arguments

Return Value

    Nothing

--*/
VOID
_RasmanEngine()
{
    //
    // The main rasman service thread becomes the request
    // thread once the service is initialized. This call
    // will return only when the service is stopping:
    //
    RequestThread ((LPWORD)NULL) ;

    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\rasman\rasman\request.c ===
/*++

Copyright (C) 1992-98 Microsft Corporation. All rights reserved.

Module Name:

    request.c

Abstract:

    All rpc requests from rasman clients are processed here

Author:

    Gurdeep Singh Pall (gurdeep) 16-Jun-1992

Revision History:

    Miscellaneous Modifications - raos 31-Dec-1997

--*/
#define RASMXS_DYNAMIC_LINK
#define EAP_ON

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <llinfo.h>
#include <rasman.h>
#include <lm.h>
#include <lmwksta.h>
#include <wanpub.h>
#include <raserror.h>
//#include <rasarp.h>
#include <media.h>
#include <device.h>
#include <stdlib.h>
#include <string.h>
#include <rtutils.h>
#include "logtrdef.h"
#include "defs.h"
#include "structs.h"
#include "protos.h"
#include "globals.h"
#include "nouiutil.h"
#include "loaddlls.h"
#include "reghelp.h"
#include "rpc.h"
#include "rasrpc.h"
#include "rasrpclb.h"
#include "ddwanarp.h"

#include "winsock2.h"

#if SENS_ENABLED
#include "sensapip.h"
#endif

#include "mprlog.h"

#include "userenv.h"

VOID MapCookieToEndpoint (pPCB, HANDLE) ;
VOID SetRasmanServiceStopped(VOID);
VOID ProcessReceivePacket(VOID);
DWORD PostReceivePacket (VOID);

DWORD g_dwLastServicedRequest;

extern DWORD g_dwProhibitIpsec;

extern SERVICE_STATUS_HANDLE hService;


/*
BYTE  bCmp[10];
BYTE  bCmp1[11]; */


extern handle_t g_hRpcHandle;

extern EpInfo *g_pEpInfo;

extern DWORD g_dwProhibitIpsec;

extern BOOLEAN RasmanShuttingDown;
/*
BOOL g_fPostReceive = FALSE;
BOOL g_fProcessReceive = FALSE;
BOOL g_fDebugReceive = TRUE;
*/

typedef struct _REQUEST_FUNCTION
{
    REQFUNC       pfnReqFunc;
    REQFUNCTHUNK pfnReqFuncThunk;
} REQUEST_FUNCTION;

//
// This global is here because we dont want multiple assignments of
// elements -
//
REQUEST_FUNCTION RequestCallTable [MAX_REQTYPES] = {

        //REQTYPE_NONE
        {NULL, NULL},
        
        //REQTYPE_PORTOPEN
        {PortOpenRequest,  ThunkPortOpenRequest},

        //REQTYPE_PORTCLOSE
        {PortCloseRequest, NULL},

        //REQTYPE_PORTGETINFO
        {PortGetInfoRequest, NULL},

        //REQTYPE_PORTSETINFO
        {PortSetInfoRequest, NULL},

        //REQTYPE_PORTLISTEN
        {DeviceListenRequest, NULL},

        //REQTYPE_PORTSEND
        {PortSendRequest, ThunkPortSendRequest},

        //REQTYPE_PORTRECEIVE
        {PortReceiveRequest, ThunkPortReceiveRequest},

        //REQTYPE_PORTGETSTATISTICS
        {CallPortGetStatistics, NULL},

        //REQTYPE_PORTDISCONNECT
        {PortDisconnectRequest, ThunkPortDisconnectRequest},

        //REQTYPE_PORTCLEARSTATISTICS
        {PortClearStatisticsRequest, NULL},

        //REQTYPE_PORTCONNECTCOMPLETE
        {ConnectCompleteRequest, NULL},

        //REQTYPE_DEVICEENUM
        {CallDeviceEnum, NULL},

        //REQTYPE_DEVICEGETINFO
        {DeviceGetInfoRequest, NULL},

        //REQTYPE_DEVICESETINFO
        {DeviceSetInfoRequest, NULL},

        //REQTYPE_DEVICECONNECT
        {DeviceConnectRequest, ThunkDeviceConnectRequest},

        //REQTYPE_ACTIVATEROUTE
        {ActivateRouteRequest, NULL},

        //REQTYPE_ALLOCATEROUTE
        {AllocateRouteRequest, NULL},

        //REQTYPE_DEALLOCATEROUTE
        {DeAllocateRouteRequest, NULL},

        //REQTYPE_COMPRESSIONGETINFO
        {CompressionGetInfoRequest, NULL},

        //REQTYPE_COMPLRESSIONSETINFO
        {CompressionSetInfoRequest, NULL},

        //REQTYPE_PORTENUM
        {EnumPortsRequest, NULL},

        //REQTYPE_GETINFO
        {GetInfoRequest, ThunkGetInfoRequest},

        //REQTYPE_GETUSERCREDENTIALS
        {GetUserCredentials, NULL},

        //REQTYPE_PROTOCOLENUM
        {EnumProtocols, NULL},

        //REQTYPE_PORTSENDHUB
        {NULL, NULL},

        //REQTYPE_PORTRECEIVEHUB
        {NULL, NULL},

        //REQTYPE_DEVICELISTEN
        {NULL, NULL},

        //REQTYPE_NUMPORTOPEN
        {AnyPortsOpen, NULL},

        //REQTYPE_PORTINIT
        {NULL, NULL},

        //REQTYPE_REQUESTNOTIFICATION
        {RequestNotificationRequest, ThunkRequestNotificationRequest},

        //REQTYPE_ENUMLANNETS
        {EnumLanNetsRequest, NULL},

        //REQTYPE_GETINFOEX
        {GetInfoExRequest, NULL},

        //REQTYPE_CANCELRECEIVE
        {CancelReceiveRequest, NULL},

        //REQTYPE_PORTENUMPROTOCOLS
        {PortEnumProtocols, NULL},

        //REQTYPE_SETFRAMING
        {SetFraming, NULL},

        //REQTYPE_ACTIVATEROUTEEX
        {ActivateRouteExRequest, NULL},

        //REQTYPE_REGISTERSLIP
        {RegisterSlip, NULL},

        //REQTYPE_STOREUSERDATA
        {StoreUserDataRequest, NULL},

        //REQTYPE_RETRIEVEUSERDATA
        {RetrieveUserDataRequest,  NULL},

        //REQTYPE_GETFRAMINGEX
        {GetFramingEx, NULL},

        //REQTYPE_SETFRAMINGEX
        {SetFramingEx, NULL},

        //REQTYPE_GETPROTOCOLCOMPRESSION
        {GetProtocolCompression,  NULL},

        //REQTYPE_SETPROTOCOLCOMPRESSION
        {SetProtocolCompression, NULL},

        //REQTYPE_GETFRAMINGCAPABILITIES
        {GetFramingCapabilities, NULL},

        //REQTYPE_SETCACHEDCREDENTIALS
        {SetCachedCredentials, NULL},

        //REQTYPE_PORTBUNDLE
        {PortBundle, ThunkPortBundle},

        //REQTYPE_GETBUNDLEDPORT
        {GetBundledPort,  ThunkGetBundledPort},

        //REQTYPE_PORTGETBUNDLE
        {PortGetBundle, ThunkPortGetBundle},

        //REQTYPE_BUNDLEGETPORT
        {BundleGetPort, ThunkBundleGetPort},

        //REQTYPE_REFERENCERASMAN
        {ReferenceRasman, NULL},

        //REQTYPE_GETDIALPARAMS
        {GetDialParams, NULL},

        //REQTYPE_SETDIALPARAMS
        {SetDialParams, NULL},

        //REQTYPE_CREATECONNECTION
        {CreateConnection, ThunkCreateConnection},

        //REQTYPE_DESTROYCONNECTION
        {DestroyConnection, NULL},

        //REQTYPE_ENUMCONNECTION
        {EnumConnection, ThunkEnumConnection},

        //REQTYPE_ADDCONNECTIONPORT
        {AddConnectionPort, ThunkAddConnectionPort},

        //REQTYPE_ENUMCONNECTIONPORTS
        {EnumConnectionPorts, ThunkEnumConnectionPorts},

        //REQTYPE_GETCONNECTIONPARAMS
        {GetConnectionParams, ThunkGetConnectionParams},

        //REQTYPE_SETCONNECTIONPARAMS
        {SetConnectionParams, ThunkSetConnectionParams},

        //REQTYPE_GETCONNECTIONUSERDATA
        {GetConnectionUserData, ThunkGetConnectionUserData},

        //REQTYPE_SETCONNECTIONUSERDATA
        {SetConnectionUserData, ThunkSetConnectionUserData},

        //REQTYPE_GETPORTUSERDATA
        {GetPortUserData, NULL},

        //REQTYPE_SETPORTUSERDATA
        {SetPortUserData, NULL},

        //REQTYPE_PPPSTOP
        {PppStop, ThunkPppStop},

        //REQTYPE_PPPSTART
        {PppStart, ThunkPppStart},

        //REQTYPE_PPPRETRY
        {PppRetry, ThunkPppRetry},

        //REQTYPE_PPPGETINFO
        {PppGetInfo, ThunkPppGetInfo},

        //REQTYPE_PPPCHANGEPWD
        {PppChangePwd, ThunkPppChangePwd},

        //REQTYPE_PPPCALLBACK
        {PppCallback, ThunkPppCallback},

        //REQTYPE_ADDNOTIFICATION
        {AddNotification, ThunkAddNotification},

        //REQTYPE_SIGNALCONNECTION
        {SignalConnection, ThunkSignalConnection},

        //REQTYPE_SETDEVCONFIG
        {SetDevConfig, NULL},

        //REQTYPE_GETDEVCONFIG
        {GetDevConfig, NULL},

        //REQTYPE_GETTIMESINCELASTACTIVITY
        {GetTimeSinceLastActivity, NULL},

        //REQTYPE_BUNDLEGETSTATISTICS
        {CallBundleGetStatistics, NULL},

        //REQTYPE_BUNDLECLEARSTATISTICS
        {BundleClearStatisticsRequest, NULL},

        //REQTYPE_CLOSEPROCESSPORTS
        {CloseProcessPorts, NULL},

        //REQTYPE_PNPCONTROL
        {PnPControl,  NULL},

        //REQTYPE_SETIOCOMPLETIONPORT
        {SetIoCompletionPort, ThunkSetIoCompletionPort},

        //REQTYPE_SETROUTERUSAGE
        {SetRouterUsage, NULL},

        //REQTYPE_SERVERPORTCLOSE
        {ServerPortClose, NULL},

        //REQTYPE_SENDPPPMESSAGETORASMAN
        {SendPppMessageToRasmanRequest, NULL},

        //REQTYPE_PORTGETSTATISTICSEX
        {CallPortGetStatisticsEx, NULL},

        //REQTYPE_BUNDLEGETSTATISTICSEX
        {CallBundleGetStatisticsEx, NULL},

        //REQTYPE_SETRASDIALINFO
        {SetRasdialInfo, NULL},

        //REQTYPE_REGISTERPNPNOTIF
        {RegisterPnPNotifRequest, NULL},

        //REQTYPE_PORTRECEIVEREQUESTEX
        {PortReceiveRequestEx, ThunkPortReceiveRequestEx},

        //REQTYPE_GETATTACHEDCOUNT
        {GetAttachedCountRequest, NULL},

        //REQTYPE_SETBAPPOLICY
        {SetBapPolicyRequest,  NULL},

        //REQTYPE_PPPSTARTED
        {PppStarted, NULL},

        //REQTYPE_REFCONNECTION
        {RefConnection, ThunkRefConnection},

        //REQTYPE_SETEAPINFO
        {PppSetEapInfo, NULL},

        //REQTYPE_GETEAPINFO
        {PppGetEapInfo, ThunkPppGetEapInfo},

        //REQTYPE_SETDEVICECONFIGINFO
        {SetDeviceConfigInfo, NULL},

        //REQTYPE_GETDEVICECONFIGINFO
        {GetDeviceConfigInfo, NULL},

        //REQTYPE_FINDPREREQUISITEENTRY
        {FindPrerequisiteEntry, ThunkFindPrerequisiteEntry},

        //REQTYPE_PORTOPENEX
        {PortOpenEx, ThunkPortOpenEx},

        //REQTYPE_GETLINKSTATS
        {GetLinkStats,  ThunkGetLinkStats},

        //REQTYPE_GETCONNECTIONSTATS
        {GetConnectionStats, ThunkGetConnectionStats},

        //REQTYPE_GETHPORTFROMCONNECTION
        {GetHportFromConnection, ThunkGetHportFromConnection},

        //REQTYPE_REFERENCECUSTOMCOUNT
        {ReferenceCustomCount, ThunkReferenceCustomCount},

        //REQTYPE_GETHCONNFROMENTRY
        {GetHconnFromEntry, ThunkGetHconnFromEntry},

        //REQTYPE_GETCONNECTINFO
        {GetConnectInfo, NULL},

        //REQTYPE_GETDEVICENAME
        {GetDeviceName, NULL},

        //REQTYPE_GETCALLEDIDINFO
        {GetCalledIDInfo, NULL},

        //REQTYPE_SETCALLEDIDINFO
        {SetCalledIDInfo, NULL},

        //REQTYPE_ENABLEIPSEC
        {EnableIpSec, NULL},

        //REQTYPE_ISIPSECENABLED
        {IsIpSecEnabled, NULL},

        //REQTYPE_SETEAPLOGONINFO
        {SetEapLogonInfo, NULL},

        //REQTYPE_SENDNOTIFICATION
        {SendNotificationRequest, ThunkSendNotificationRequest},

        //REQTYPE_GETNDISWANDRIVERCAPS
        {GetNdiswanDriverCaps, NULL},

        //REQTYPE_GETBANDWIDTHUTILIZATION
        {GetBandwidthUtilization, NULL},

        //REQTYPE_REGISTERREDIALCALLBACK
        {RegisterRedialCallback, NULL},

        //REQTYPE_GETPROTOCOLINFO
        {GetProtocolInfo, NULL},

        //REQTYPE_GETCUSTOMSCRIPTDLL
        {GetCustomScriptDll, NULL},

        //REQTYPE_ISTRUSTEDCUSTOMDLL
        {IsTrustedCustomDll, NULL},

        //REQTYPE_DOIKE
        {DoIke, ThunkDoIke},

        //REQTYPE_QUERYIKESTATUS
        {QueryIkeStatus, NULL},     

        // REQTYPE_SETRASCOMMSETTINGS
        {SetRasCommSettings, NULL},

        //REQTYPE_ENABLERASAUDIO
        {EnableRasAudio, NULL},

        //REQTYPE_SETKEY
        {SetKeyRequest, NULL},

        //REQTYPE_GETKEY
        {GetKeyRequest, NULL},

        //REQTYPE_ADDRESSDISABLE
        {DisableAutoAddress, NULL},

        //REQTYPE_GETDEVCONFIGEX
        {GetDevConfigEx, NULL},

        //REQTYPE_SENDCREDS
        {SendCredsRequest, NULL},

        //REQTYPE_GETUNICODEDEVICENAME
        {GetUnicodeDeviceName, NULL},
    
        {GetVpnDeviceNameW, NULL},
} ;

//
// We need a handle to the RequestThread(),
// so we can wait for it to stop.
//
HANDLE hRequestThread;

VOID
UnInitializeRas()
{
    HINSTANCE hInstance = NULL;
    FARPROC pfnUninitRAS;

    if(NULL != GetModuleHandle("rasapi32.dll"))
    {
        if( (NULL == (hInstance = LoadLibrary("rasapi32.dll")))
        ||  (NULL == (pfnUninitRAS = GetProcAddress(hInstance,
                                            "UnInitializeRAS"))))
        {
            goto done;
        }

        (void) pfnUninitRAS();
    }

done:

    if(NULL != hInstance)
    {
        FreeLibrary(hInstance);
    }
}


/*++

Routine Description:

    The Request thread lives in this routine:
    This will return only when the rasman
    service is stopping.

Arguments:

Return Value:

    Nothing.

--*/
DWORD
RequestThread (LPWORD arg)
{
    DWORD       eventindex ;
    pPCB        ppcb ;
    ULONG       i ;
    BYTE        buffer [10] ;
    PRAS_OVERLAPPED pOverlapped;
    DWORD       dwBytesTransferred;
    ULONG_PTR   ulpCompletionKey;
    DWORD       dwTimeToSleepFor    = INFINITE;
    DWORD       dwTimeBeforeWait;
    DWORD       dwTimeElapsed;
    DWORD       dwEventType;
    DWORD       dwRet;
    RequestBuffer *RequestBuffer;


    //
    // Save the current thread handle so
    // we can wait for it while we are shutting
    // down.
    //
    DuplicateHandle(
      GetCurrentProcess(),
      GetCurrentThread(),
      GetCurrentProcess(),
      &hRequestThread,
      0,
      FALSE,
      DUPLICATE_SAME_ACCESS) ;

    //
    // If the number of ports configured is set to greater than
    // REQUEST_PRIORITY_THRESHOLD then the priority of this thread
    // is bumped up to a higher level: this is necessary to avoid
    // bottlenecks:
    //
    if (MaxPorts > REQUEST_PRIORITY_THRESHOLD)
    {
        SetThreadPriority (GetCurrentThread,
                           THREAD_PRIORITY_ABOVE_NORMAL) ;
    }

    //
    // The work loop for the request thread: waits here for a
    // Register for protocol change notifications if we were
    // able to start ndiswan successfully
    //
    if(INVALID_HANDLE_VALUE != RasHubHandle)
    {
        DWORD retcode;

        retcode = DwSetEvents();

        RasmanTrace("RequestThread: DwSetEvents returnd 0x%x",
                    retcode);
    }

    //
    // The work loop for the request thread: waits here for a
    // request or a timer event signalling:
    //
    for ( ; ; )
    {

        dwTimeBeforeWait = GetCurrentTime();

        //
        // Wait for some request to be put in queue
        //
        dwRet = GetQueuedCompletionStatus(hIoCompletionPort,
                                        &dwBytesTransferred,
                                        &ulpCompletionKey,
                                        (LPOVERLAPPED *) &pOverlapped,
                                        dwTimeToSleepFor);

        if (0 == dwRet)
        {
            dwRet = GetLastError();

            if( WAIT_TIMEOUT != dwRet)
            {
                RasmanTrace(
                       "%s, %d: GetQueuedCompletionStatus"
                       " Failed. GLE = %d",
                       __FILE__,
                       __LINE__,
                       dwRet);

                continue;
            }
        }

        if (WAIT_TIMEOUT == dwRet)
        {
            dwEventType = OVEVT_RASMAN_TIMER;
        }
        else
        {
            dwEventType = pOverlapped->RO_EventType;
        }

        switch (dwEventType)
        {

        case OVEVT_RASMAN_TIMER:

            EnterCriticalSection ( &g_csSubmitRequest );

            TimerTick() ;

            if (NULL == TimerQueue.DQ_FirstElement)
            {
                dwTimeToSleepFor = INFINITE;
            }
            else
            {
                dwTimeToSleepFor = 1000;
            }

            LeaveCriticalSection ( &g_csSubmitRequest );

            continue ;

        case OVEVT_RASMAN_CLOSE:
        {

            SERVICE_STATUS status;

            ZeroMemory(&status, sizeof(status));

            //
            // Call StopPPP to stop:
            //
            RasmanTrace(
                   "OVEVT_RASMAN_CLOSE. pOverlapped = 0x%x",
                    pOverlapped);

            EnterCriticalSection ( &g_csSubmitRequest );

            //
            // If rasman is already shutting down don't call
            // StopPPP as we would have already called this
            //
            if (RasmanShuttingDown)
            {
                RasmanTrace(
                       "RequestThread: Rasman is shutting down ");

                LeaveCriticalSection(&g_csSubmitRequest);
                break;
            }

            RasStopPPP (hIoCompletionPort) ;

            RasmanShuttingDown = TRUE;

            LeaveCriticalSection ( &g_csSubmitRequest );

            status.dwCurrentState = SERVICE_STOP_PENDING;

            SetServiceStatus(hService, &status);

            break ;
        }

        case OVEVT_RASMAN_FINAL_CLOSE:

            RasmanTrace(
                   "OVEVT_RASMAN_FINAL_CLOSE. pOverlapped = 0x%x",
                   pOverlapped);

#if SENS_ENABLED

            dwRet = SendSensNotification(SENS_NOTIFY_RAS_STOPPED,
                                        NULL);
            RasmanTrace(
                
                "SENS_NOTIFY_RAS_STOPPED returns 0x%08x",
                dwRet);
#endif

            g_RasEvent.Type    = SERVICE_EVENT;
            g_RasEvent.Event   = RAS_SERVICE_STOPPED;
            g_RasEvent.Service = RASMAN;

            dwRet = DwSendNotificationInternal(NULL, &g_RasEvent);

            RasmanTrace(
                   "DwSendNotificationInternal(SERVICE_EVENT STOPPED)"
                   " rc=0x%08x",
                   dwRet);

            //
            // If Ipsec is initialize uninitialize it
            //
            DwUnInitializeIpSec();

            //
            // Stop the RPC server.
            //
            UninitializeRasRpc();

            //
            // Time to shut down: Close all ports if they
            // are still open.
            //
            RasmanShuttingDown = TRUE;

            //
            // Uninitialize Ep
            //
            EpUninitialize();

            for (i = 0; i < MaxPorts; i++)
            {
                ppcb = GetPortByHandle((HPORT) UlongToPtr(i));

                if (ppcb != NULL)
                {
                    memset (buffer, 0xff, 4) ;

                    if (ppcb->PCB_PortStatus == OPEN)
                    {
                        PortCloseRequest (ppcb, buffer) ;
                    }
                }
            }

            LsaDeregisterLogonProcess (HLsa);

            CloseHandle(hIoCompletionPort);

            //
            // Unload dynamically-loaded libraries
            //
            if (hinstIphlp != NULL)
            {
                FreeLibrary(hinstIphlp);
            }

            if (hinstPpp != NULL)
            {
                FreeLibrary(hinstPpp);
            }

            UnloadMediaDLLs();
            UnloadDeviceDLLs();
            FreePorts();
            FreeBapPackets();
            UnInitializeRas();

            UnloadRasmanDll();
            UnloadRasapi32Dll();

            CloseHandle(g_hReqBufferMutex);

            CloseHandle(g_hSendRcvBufferMutex);

            //
            // Restore default control-C processing.
            //
            SetConsoleCtrlHandler(NULL, FALSE);

            //
            // Detach from trace dll
            //
            TraceDeregister(TraceHandle) ;

            //
            // Close Event Logging Handle
            //
            RouterLogDeregister(hLogEvents);

            //
            // Delete the critical section
            //
            DeleteCriticalSection ( &g_csSubmitRequest );

            DeleteCriticalSection( &PcbLock);

            if(INVALID_HANDLE_VALUE != RasHubHandle)
            {
                CloseHandle(RasHubHandle);
                RasHubHandle = INVALID_HANDLE_VALUE;
            }

            UninitializeIphlp();

            UninitializeRasAudio();

            //
            // Set the service controller status to STOPPED.
            //
            SetRasmanServiceStopped();


            return 0;  // The End.

        case OVEVT_RASMAN_RECV_PACKET:
        {
            DWORD dwRetCode = 0;
            DWORD dwBytesReceived = 0;

            EnterCriticalSection ( &g_csSubmitRequest );

            dwRetCode =
            GetOverlappedResult(RasHubHandle,
                                &ReceiveBuffers->Packet->RP_OverLapped.RO_Overlapped,
                                &dwBytesReceived,
                                FALSE);

            if (dwRetCode == FALSE) {
                  dwRetCode = GetLastError();
                    RasmanTrace(
                           "GetOverlappedResult failed. rc=0x%x",
                            dwRetCode);

            }


            ReceiveBuffers->PacketPosted = FALSE;

            if (dwBytesReceived != 0)
            {
                ProcessReceivePacket();
            }
            else
            {

                RasmanTrace(
                       "Received packet with 0 bytes!!!");

            }

            dwRetCode = PostReceivePacket();

            LeaveCriticalSection ( &g_csSubmitRequest );

            break;
        }

        case OVEVT_RASMAN_THRESHOLD:
        {

            DWORD retcode;

            RasmanTrace(
                   "OVEVT_RASMAN_THRESHOLD. pOverlapped = 0x%x",
                   pOverlapped);

            EnterCriticalSection(&g_csSubmitRequest);

            retcode = dwProcessThresholdEvent();

            LeaveCriticalSection(&g_csSubmitRequest);

            if ( retcode )
            {
                RasmanTrace( 
                        "Failed to process threshold event. %d",
                        retcode);
            }

            break;
        }

        case OVEVT_RASMAN_HIBERNATE:
        {
            DWORD retcode;

            RasmanTrace(
                   "OVEVT_RASMAN_HIBERNATE. pOverlapped = 0x%x",
                    pOverlapped);


            EnterCriticalSection(&g_csSubmitRequest);

            DropAllActiveConnections();

            //
            // Repost the irp for hibernate events
            //
            retcode = DwSetHibernateEvent();

            LeaveCriticalSection(&g_csSubmitRequest);

            break;
        }

        case OVEVT_RASMAN_PROTOCOL_EVENT:
        {
            DWORD retcode;

            RasmanTrace(
                   "OVEVT_RASMAN_PROTOCOL_EVENT. pOverlapped = 0x%x",
                   pOverlapped);

            EnterCriticalSection(&g_csSubmitRequest);

            retcode = DwProcessProtocolEvent();

            LeaveCriticalSection(&g_csSubmitRequest);

            if(SUCCESS != retcode)
            {
                RasmanTrace(
                       "DwProcessProtocolEvent failed. 0x%x",
                       retcode);
            }

            break;
        }

        case OVEVT_RASMAN_POST_RECV_PKT:
        {
            DWORD dwRetcode;
            RasmanTrace(
                
                "OVEVT_RASMAN_POST_RECV_PKT");

            EnterCriticalSection(&g_csSubmitRequest);

            dwRetcode = PostReceivePacket();

            RasmanTrace(
                
                "PostReceivePacket returned 0x%x",
                dwRetcode);

            LeaveCriticalSection(&g_csSubmitRequest);

            break;
        }

        case OVEVT_RASMAN_ADJUST_TIMER:
        {
            RasmanTrace(
                   "OVEVT_RASMAN_ADJUST_TIMER");

            break;
        }

        case OVEVT_RASMAN_DEREFERENCE_CONNECTION:
        {
            DWORD dwRetcode;
            
           RasmanTrace(
                   "OVEVT_RASMAN_DEREFERENCE_CONNECTION");

           EnterCriticalSection(&g_csSubmitRequest);                   
           
           dwRetcode = DwCloseConnection(
                            pOverlapped->RO_hInfo);

            LeaveCriticalSection(&g_csSubmitRequest);                   

            RasmanTrace(
                   "DwCloseConnection returned 0x%x",
                   dwRetcode);

            LocalFree(pOverlapped);                   

            break;                   
        }

        case OVEVT_RASMAN_DEFERRED_CLOSE_CONNECTION:
        {
            DWORD dwRetcode;

            RasmanTrace("OVEVT_RASMAN_DEFERRED_CLOSE_CONNECTION");

            EnterCriticalSection(&g_csSubmitRequest);
            dwRetcode = DwProcessDeferredCloseConnection(
                                (RAS_OVERLAPPED *)pOverlapped);
            LeaveCriticalSection(&g_csSubmitRequest);
            LocalFree(pOverlapped);
            break;
        }

		case OVEVT_DEV_IGNORED:
		case OVEVT_DEV_STATECHANGE:
		case OVEVT_DEV_ASYNCOP:
		case OVEVT_DEV_SHUTDOWN:
		case OVEVT_DEV_CREATE:
		case OVEVT_DEV_REMOVE:
		case OVEVT_DEV_RASCONFIGCHANGE:
    	{
		    EnterCriticalSection ( &g_csSubmitRequest );
		
			RasmanWorker(ulpCompletionKey,
						pOverlapped);

            LeaveCriticalSection ( &g_csSubmitRequest );

            break;
        }

        }   // switch()

        if ( NULL != TimerQueue.DQ_FirstElement )
        {
            if ( dwTimeToSleepFor == INFINITE )
            {
                dwTimeToSleepFor = 1000;
            }
            else
            {
                //
                // We did not get a timeout but do we need to call
                // the timer? Has over a second passed since we
                // called the TimerTick?
                //
                dwTimeElapsed =
                    ( GetCurrentTime() >= dwTimeBeforeWait )
                    ? GetCurrentTime() - dwTimeBeforeWait
                    : GetCurrentTime()
                    + (0xFFFFFFFF - dwTimeBeforeWait);

                if ( dwTimeElapsed >= dwTimeToSleepFor )
                {
                    EnterCriticalSection(&g_csSubmitRequest);
                    TimerTick();
                    LeaveCriticalSection(&g_csSubmitRequest);

                    if (NULL == TimerQueue.DQ_FirstElement)
                    {
                        dwTimeToSleepFor = INFINITE;
                    }
                    else
                    {
                        dwTimeToSleepFor = 1000;
                    }
                }
                else
                {
                    dwTimeToSleepFor -= dwTimeElapsed;
                }
            }
        }
    }       // for(;;)

    return 0 ;
}

const ULONG FatalExceptions[] = 
    {
    STATUS_ACCESS_VIOLATION,
    STATUS_POSSIBLE_DEADLOCK,
    STATUS_INSTRUCTION_MISALIGNMENT,
    STATUS_DATATYPE_MISALIGNMENT,
    STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_ILLEGAL_INSTRUCTION,
    STATUS_BREAKPOINT,
    STATUS_STACK_OVERFLOW
    };

const int FATAL_EXCEPTIONS_ARRAY_SIZE = 
    sizeof(FatalExceptions) / sizeof(FatalExceptions[0]);

int 
RasmanExceptionFilter (
    unsigned long ExceptionCode
    )
{
    int i;

    for (i = 0; i < FATAL_EXCEPTIONS_ARRAY_SIZE; i ++)
        {
        if (ExceptionCode == FatalExceptions[i])
            return EXCEPTION_CONTINUE_SEARCH;
        }

    return EXCEPTION_EXECUTE_HANDLER;
}

/*++

Routine Description:

    Handles the request passed to the Requestor thread:
    basically calls the approp. device and media dll
    entrypoints.

Arguments:

Return Value:

    Nothing (Since the error codes are just passed
    back in the request block;

--*/
VOID
ServiceRequest (RequestBuffer *preqbuf, DWORD dwBufSize)
{
    pPCB ppcb;
    WORD reqtype;
    DWORD exception;
    REQFUNC pfn;

    if(     (dwBufSize < (sizeof(RequestBuffer) + REQUEST_BUFFER_SIZE))
        ||  (NULL == preqbuf)
        ||  (preqbuf->RB_Reqtype >= MAX_REQTYPES))
    {
        RasmanTrace(
               "ServiceRequest: Invalid parameters in the rpc call!");
               
        goto done;               
    }

    if (RasmanShuttingDown)
    {
         RasmanTrace(
                "Rasman is shutting down!!!");

        ((REQTYPECAST *)
        preqbuf->RB_Buffer)->Generic.retcode = E_FAIL;

        goto done;
    }

    EnterCriticalSection ( &g_csSubmitRequest );

    ppcb = GetPortByHandle(UlongToPtr(preqbuf->RB_PCBIndex));

    //
    // Enter Critical Section before calling
    // to service the request
    //
    g_dwLastServicedRequest = preqbuf->RB_Reqtype;
    
    //
    // Wrap the function call in try/except. Rpc will
    // catch the exception otherwise. We want to catch
    // the exception before it gets to rpc.
    //
    __try
    {

        if(    (preqbuf->RB_Dummy != RASMAN_THUNK_VERSION)
            && (preqbuf->RB_Dummy == sizeof(DWORD))
            && (pfn = 
                 RequestCallTable[preqbuf->RB_Reqtype].pfnReqFuncThunk))
        {
            //DbgPrint("Thunking reqtype %d\n", preqbuf->RB_Reqtype);
            
            //
            // Call the thunk function if required and available
            //
            pfn(ppcb, preqbuf->RB_Buffer, dwBufSize);
        }
        else
        {
            //
            // Call the function associated with the request.
            //
            (RequestCallTable[preqbuf->RB_Reqtype].pfnReqFunc) (
                                            ppcb,
                                            preqbuf->RB_Buffer);
        }                                        
    }
    __except(RasmanExceptionFilter(exception = GetExceptionCode()))
    {
        RasmanTrace(
            "ServiceRequest: function with reqtype %d raised an exception"
            " 0x%x", 
            preqbuf->RB_Reqtype, 
            exception);
#if DBG
        DbgPrint(
            "ServiceRequest: function with reqtype %d raised an exception"
            " 0x%x",
            preqbuf->RB_Reqtype,
            exception);
            
        DebugBreak();
#endif
    }


    //
    // Leave Critical Section
    //
    LeaveCriticalSection ( &g_csSubmitRequest );

done:
    return;

}


/*++

Routine Description:

    Gets the compression level for the port.

Arguments:

Return Value:

--*/
VOID
CompressionGetInfoRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD       bytesrecvd ;
    NDISWAN_GET_COMPRESSION_INFO  compinfo ;
    DWORD       retcode = SUCCESS ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {

        if ( ppcb )
        {
            RasmanTrace (
                    "CompressionGetInfoRequest: Port %d is "
                    "unavailable",
                    ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->Generic.retcode =
                                ERROR_PORT_NOT_FOUND;

        return;
    }

    if (ppcb->PCB_ConnState != CONNECTED)
    {

        ((REQTYPECAST *)
        buffer)->Generic.retcode = ERROR_NOT_CONNECTED;

        return ;
    }

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    memset(&compinfo,
           0,
           sizeof(NDISWAN_GET_COMPRESSION_INFO));

    compinfo.hLinkHandle = ppcb->PCB_LinkHandle ;

    if (!DeviceIoControl (
            RasHubHandle,
            IOCTL_NDISWAN_GET_COMPRESSION_INFO,
            &compinfo,
            sizeof(NDISWAN_GET_COMPRESSION_INFO),
            &compinfo,
            sizeof(NDISWAN_GET_COMPRESSION_INFO),
            &bytesrecvd,
            NULL))
    {
        retcode = GetLastError () ;
    }

    if (retcode == SUCCESS)
    {
        RAS_COMPRESSION_INFO *temp ;

        //
        // Fill Send compression info
        //
        temp = &((REQTYPECAST *)buffer)->CompressionGetInfo.send;

        memcpy (temp->RCI_LMSessionKey,
                compinfo.SendCapabilities.LMSessionKey,
                MAX_SESSIONKEY_SIZE) ;

        memcpy (temp->RCI_UserSessionKey,
                compinfo.SendCapabilities.UserSessionKey,
                MAX_USERSESSIONKEY_SIZE) ;

        memcpy (temp->RCI_Challenge,
                compinfo.SendCapabilities.Challenge,
                MAX_CHALLENGE_SIZE) ;

        temp->RCI_MSCompressionType         =
                    compinfo.SendCapabilities.MSCompType ;

        temp->RCI_MacCompressionType        =
                    compinfo.SendCapabilities.CompType ;

        temp->RCI_MacCompressionValueLength =
                    compinfo.SendCapabilities.CompLength ;

        if (temp->RCI_MacCompressionType == 0)
        {
            //
            // Proprietary
            //
            memcpy (
                temp->RCI_Info.RCI_Proprietary.RCI_CompOUI,
                compinfo.SendCapabilities.Proprietary.CompOUI,
                MAX_COMPOUI_SIZE) ;

            temp->RCI_Info.RCI_Proprietary.RCI_CompSubType =
                compinfo.SendCapabilities.Proprietary.CompSubType;

            memcpy (
                temp->RCI_Info.RCI_Proprietary.RCI_CompValues,
                compinfo.SendCapabilities.Proprietary.CompValues,
                MAX_COMPVALUE_SIZE) ;
        }
        else
        {
            memcpy (
                temp->RCI_Info.RCI_Public.RCI_CompValues,
                compinfo.SendCapabilities.Public.CompValues,
                MAX_COMPVALUE_SIZE) ;
        }

        //
	    // Fill Send compression info
    	//

	    temp = &((REQTYPECAST *)buffer)->CompressionGetInfo.send;

	    memcpy (temp->RCI_LMSessionKey,
    	    	compinfo.SendCapabilities.LMSessionKey,
	        	MAX_SESSIONKEY_SIZE) ;

    	memcpy (temp->RCI_UserSessionKey,
        		compinfo.SendCapabilities.UserSessionKey,
		        MAX_USERSESSIONKEY_SIZE) ;

	    memcpy (temp->RCI_Challenge,
    	    	compinfo.SendCapabilities.Challenge,
	        	MAX_CHALLENGE_SIZE) ;

        memcpy (temp->RCI_NTResponse,
                compinfo.SendCapabilities.NTResponse,
                MAX_NT_RESPONSE_SIZE) ;

        temp->RCI_AuthType                  =
                    compinfo.SendCapabilities.AuthType;

        temp->RCI_Flags                     =
                    compinfo.SendCapabilities.Flags;

	    temp->RCI_MSCompressionType			=
	                compinfo.SendCapabilities.MSCompType ;
	
	    temp->RCI_MacCompressionType		=
	                compinfo.SendCapabilities.CompType ;
	
	    temp->RCI_MacCompressionValueLength =
	                compinfo.SendCapabilities.CompLength ;

	    if (temp->RCI_MacCompressionType == 0)
	    {
	        //
	        // Proprietary
	        //
    	    memcpy (
    	        temp->RCI_Info.RCI_Proprietary.RCI_CompOUI,
        		compinfo.SendCapabilities.Proprietary.CompOUI,
		        MAX_COMPOUI_SIZE) ;
		
        	temp->RCI_Info.RCI_Proprietary.RCI_CompSubType =
       	        compinfo.SendCapabilities.Proprietary.CompSubType;
        	
	        memcpy (
	            temp->RCI_Info.RCI_Proprietary.RCI_CompValues,
    		    compinfo.SendCapabilities.Proprietary.CompValues,
            	MAX_COMPVALUE_SIZE) ;
	    }
	    else
	    {
        	memcpy (
        	    temp->RCI_Info.RCI_Public.RCI_CompValues,
            	compinfo.SendCapabilities.Public.CompValues,
		        MAX_COMPVALUE_SIZE) ;
		}

        temp->RCI_EapKeyLength = compinfo.SendCapabilities.EapKeyLength;

        if (temp->RCI_EapKeyLength != 0)
        {
            memcpy(temp->RCI_EapKey,
                   compinfo.SendCapabilities.EapKey,
                   temp->RCI_EapKeyLength) ;
        }
		
        //
	    // Fill Receive compression info
    	//

        temp =
            &((REQTYPECAST *)buffer)->CompressionGetInfo.recv ;

        memcpy (temp->RCI_LMSessionKey,
                compinfo.RecvCapabilities.LMSessionKey,
                MAX_SESSIONKEY_SIZE) ;

        memcpy (temp->RCI_UserSessionKey,
                compinfo.RecvCapabilities.UserSessionKey,
                MAX_USERSESSIONKEY_SIZE) ;

        memcpy (temp->RCI_Challenge,
                compinfo.RecvCapabilities.Challenge,
                MAX_CHALLENGE_SIZE) ;

        memcpy (temp->RCI_NTResponse,
                compinfo.RecvCapabilities.NTResponse,
                MAX_NT_RESPONSE_SIZE) ;

        temp->RCI_AuthType                  =
                compinfo.RecvCapabilities.AuthType;

        temp->RCI_Flags                     =
                compinfo.RecvCapabilities.Flags;

	    temp->RCI_MSCompressionType 		=
	                compinfo.RecvCapabilities.MSCompType ;
	
	    temp->RCI_MacCompressionType 		=
	                compinfo.RecvCapabilities.CompType ;
	
	    temp->RCI_MacCompressionValueLength =
	                compinfo.RecvCapabilities.CompLength ;

        if (temp->RCI_MacCompressionType == 0)
        {
            //
            // Proprietary
            //
            memcpy (
                temp->RCI_Info.RCI_Proprietary.RCI_CompOUI,
                compinfo.RecvCapabilities.Proprietary.CompOUI,
                MAX_COMPOUI_SIZE) ;

            temp->RCI_Info.RCI_Proprietary.RCI_CompSubType =
                compinfo.RecvCapabilities.Proprietary.CompSubType ;

            memcpy (
                temp->RCI_Info.RCI_Proprietary.RCI_CompValues,
                compinfo.RecvCapabilities.Proprietary.CompValues,
                MAX_COMPVALUE_SIZE) ;
        }
        else
        {
            memcpy (
                temp->RCI_Info.RCI_Public.RCI_CompValues,
                compinfo.RecvCapabilities.Public.CompValues,
                MAX_COMPVALUE_SIZE) ;
        }

        temp->RCI_EapKeyLength = compinfo.RecvCapabilities.EapKeyLength;

        if (temp->RCI_EapKeyLength != 0)
        {
            memcpy(temp->RCI_EapKey,
                   compinfo.RecvCapabilities.EapKey,
                   temp->RCI_EapKeyLength) ;
        }
    }

    ((REQTYPECAST *)buffer)->CompressionGetInfo.retcode = retcode ;
}



/*++

Routine Description:

    Sets the compression level on the port.

Arguments:

Return Value:

--*/
VOID
CompressionSetInfoRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD                           bytesrecvd ;
    NDISWAN_SET_COMPRESSION_INFO    compinfo ;
    DWORD                           retcode = SUCCESS ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {

        if ( ppcb )
        {
            RasmanTrace (
                
                "CompressionSetInfoRequest: Port %d is unavailable",
                ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->CompressionSetInfo.retcode =
                                            ERROR_PORT_NOT_FOUND;

        return;
    }

    if (ppcb->PCB_ConnState != CONNECTED)
    {
        ((REQTYPECAST *)buffer)->CompressionSetInfo.retcode =
                                            ERROR_NOT_CONNECTED;
        return ;
    }

#if DBG
    ASSERT(INVALID_HANDLE_VALUE != RasHubHandle);
#endif

    if (retcode == SUCCESS)
    {

        RAS_COMPRESSION_INFO *temp ;

        //
        // Fill Send compression info
        //
        temp = &((REQTYPECAST *)buffer)->CompressionSetInfo.send;

        memset(&compinfo, 0, sizeof(compinfo));

        memcpy (compinfo.SendCapabilities.LMSessionKey,
                temp->RCI_LMSessionKey,
                MAX_SESSIONKEY_SIZE) ;

        memcpy (compinfo.SendCapabilities.UserSessionKey,
                temp->RCI_UserSessionKey,
                MAX_USERSESSIONKEY_SIZE) ;

        memcpy (compinfo.SendCapabilities.Challenge,
                temp->RCI_Challenge,
                MAX_CHALLENGE_SIZE) ;

        memcpy (compinfo.SendCapabilities.NTResponse,
                temp->RCI_NTResponse,
                MAX_NT_RESPONSE_SIZE ) ;

        compinfo.SendCapabilities.AuthType =
                        temp->RCI_AuthType;

        compinfo.SendCapabilities.Flags =
                        temp->RCI_Flags;

	    compinfo.SendCapabilities.MSCompType =
	                    temp->RCI_MSCompressionType ;

        compinfo.SendCapabilities.CompType =
                        temp->RCI_MacCompressionType ;

        compinfo.SendCapabilities.CompLength =
                        temp->RCI_MacCompressionValueLength;

        if (temp->RCI_MacCompressionType == 0)
        {
            //
            // Proprietary
            //
            memcpy (compinfo.SendCapabilities.Proprietary.CompOUI,
                    temp->RCI_Info.RCI_Proprietary.RCI_CompOUI,
                    MAX_COMPOUI_SIZE) ;

            compinfo.SendCapabilities.Proprietary.CompSubType =
                    temp->RCI_Info.RCI_Proprietary.RCI_CompSubType ;

            memcpy (compinfo.SendCapabilities.Proprietary.CompValues,
                    temp->RCI_Info.RCI_Proprietary.RCI_CompValues,
                    MAX_COMPVALUE_SIZE) ;
        }
        else
        {
            memcpy (compinfo.SendCapabilities.Public.CompValues,
                    temp->RCI_Info.RCI_Public.RCI_CompValues,
                    MAX_COMPVALUE_SIZE) ;
        }

        compinfo.SendCapabilities.EapKeyLength = temp->RCI_EapKeyLength;

        if (temp->RCI_EapKeyLength != 0)
        {
            memcpy(compinfo.SendCapabilities.EapKey,
                   temp->RCI_EapKey,
                   temp->RCI_EapKeyLength) ;
        }

        //
        // Fill recv compression info
        //
        temp = &((REQTYPECAST *)buffer)->CompressionSetInfo.recv ;

        memcpy (compinfo.RecvCapabilities.LMSessionKey,
                temp->RCI_LMSessionKey,
                MAX_SESSIONKEY_SIZE) ;

        memcpy (compinfo.RecvCapabilities.UserSessionKey,
                temp->RCI_UserSessionKey,
                MAX_USERSESSIONKEY_SIZE) ;

        memcpy (compinfo.RecvCapabilities.Challenge,
                temp->RCI_Challenge,
                MAX_CHALLENGE_SIZE) ;

        memcpy (compinfo.RecvCapabilities.NTResponse,
                temp->RCI_NTResponse,
                MAX_NT_RESPONSE_SIZE) ;

        compinfo.RecvCapabilities.AuthType =
                    temp->RCI_AuthType;

        compinfo.RecvCapabilities.Flags =
                    temp->RCI_Flags;

	    compinfo.RecvCapabilities.MSCompType =
	                temp->RCI_MSCompressionType ;

        compinfo.RecvCapabilities.CompType =
                    temp->RCI_MacCompressionType ;

        compinfo.RecvCapabilities.CompLength =
                    temp->RCI_MacCompressionValueLength  ;

        if (temp->RCI_MacCompressionType == 0)
        {
            //
            // Proprietary
            //
            memcpy (compinfo.RecvCapabilities.Proprietary.CompOUI,
                    temp->RCI_Info.RCI_Proprietary.RCI_CompOUI,
                    MAX_COMPOUI_SIZE) ;

            compinfo.RecvCapabilities.Proprietary.CompSubType =
                    temp->RCI_Info.RCI_Proprietary.RCI_CompSubType ;

            memcpy (compinfo.RecvCapabilities.Proprietary.CompValues,
                    temp->RCI_Info.RCI_Proprietary.RCI_CompValues,
                    MAX_COMPVALUE_SIZE) ;
        }
        else
        {
            memcpy (compinfo.RecvCapabilities.Public.CompValues,
                    temp->RCI_Info.RCI_Public.RCI_CompValues,
                    MAX_COMPVALUE_SIZE) ;
        }

        compinfo.RecvCapabilities.EapKeyLength = temp->RCI_EapKeyLength;

        if (temp->RCI_EapKeyLength != 0)
        {
            memcpy(compinfo.RecvCapabilities.EapKey,
                   temp->RCI_EapKey,
                   temp->RCI_EapKeyLength) ;
        }
    }

    compinfo.hLinkHandle = ppcb->PCB_LinkHandle;

    if (!DeviceIoControl (RasHubHandle,
                          IOCTL_NDISWAN_SET_COMPRESSION_INFO,
                          &compinfo,
                          sizeof(NDISWAN_SET_COMPRESSION_INFO),
                          &compinfo,
                          sizeof(NDISWAN_SET_COMPRESSION_INFO),
                          &bytesrecvd,
                          NULL))

        retcode = GetLastError () ;


    ((REQTYPECAST *)buffer)->CompressionSetInfo.retcode = retcode ;
}


/*++

Routine Description:

    Adds another notification event for the port.

Arguments:

Return Value:

--*/
VOID
RequestNotificationRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD retcode = SUCCESS;
    HANDLE handle;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus)
    {
        if ( ppcb )
        {
            RasmanTrace(
                
                "RequestNotificationRequest: Port %d is "
                "unavailable",
                ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)
        buffer)->Generic.retcode = ERROR_PORT_NOT_FOUND;

        return;
    }


    handle = ValidateHandleForRasman(
            ((REQTYPECAST*)buffer)->ReqNotification.handle,
            ((REQTYPECAST*)buffer)->ReqNotification.pid) ;

    if(SUCCESS != (retcode = AddNotifierToList(
                                &ppcb->PCB_NotifierList,
                                handle,
                                NOTIF_DISCONNECT,
                                ((REQTYPECAST*)buffer)->ReqNotification.pid)))
    {
        FreeNotifierHandle(handle);
        ((REQTYPECAST *)buffer)->Generic.retcode =  retcode;
    }
    else
    {
        ((REQTYPECAST *)buffer)->Generic.retcode = SUCCESS ;
    }
}



/*++

Routine Description:

    Calls the media dll entry point - converts
    pointers to offsets

Arguments:

Return Value:

    Nothing.
--*/
VOID
PortGetInfoRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD           retcode ;
    RASMAN_PORTINFO *info =
                    (RASMAN_PORTINFO *)
                    ((REQTYPECAST *)buffer)->GetInfo.buffer;

    DWORD           dwSize = ((REQTYPECAST *)buffer)->GetInfo.size;
    PBYTE           pBuffer;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
           RasmanTrace (
                   "PortGetInfoRequest: Port 0x%x "
                   "is unavailable",ppcb->PCB_PortHandle);
        }

        ((REQTYPECAST *)buffer)->GetInfo.retcode =
                                ERROR_PORT_NOT_FOUND;

        return;
    }


    if ( dwSize == 0 )
    {
        pBuffer = LocalAlloc ( LPTR, 0xffff );

        if ( NULL == pBuffer )
        {
            retcode = GetLastError();

            goto done;
        }

        ((REQTYPECAST*) buffer)->GetInfo.size = 0xffff ;

    }
    else
    {
        pBuffer = ((REQTYPECAST *) buffer)->GetInfo.buffer;
    }

    //
    // Make the corresponding media dll call:
    //
    retcode = PORTGETINFO((ppcb->PCB_Media),
                         INVALID_HANDLE_VALUE,
                         ppcb->PCB_Name,
                         pBuffer,
                         &((REQTYPECAST*) buffer)->GetInfo.size);
    //
    // Before passing the buffer back to the client process
    // convert pointers to offsets:
    //
    if (    dwSize
        &&  retcode == SUCCESS)
    {
        ConvParamPointerToOffset(info->PI_Params,
                                 info->PI_NumOfParams) ;
    }

done:

    if ( dwSize == 0 )
    {
        LocalFree ( pBuffer );
    }

    ((REQTYPECAST *)buffer)->GetInfo.retcode = retcode ;
}



/*++

Routine Description:

    Converts offsets to pointers - Calls the media dll
    entry point - and returns.

Arguments:

Return Value:

    Nothing.

--*/
VOID
PortSetInfoRequest (pPCB ppcb, PBYTE buffer)
{
    DWORD           retcode ;
    RASMAN_PORTINFO *info =
            &((REQTYPECAST *)buffer)->PortSetInfo.info ;

    if (    ppcb == NULL
        ||  UNAVAILABLE == ppcb->PCB_PortStatus )
    {
        if ( ppcb )
        {
            RasmanTrace(
                   "PortSetInfoRequest: port %d is unavailable",
                   ppcb->PCB_PortHandle );
        }

        ((REQTYPECAST *)buffer)->Generic.retcode =
                                        ERROR_PORT_NOT_FOUND;

        return;
    }

    //
    // Convert the offsets to pointers:
    //
    ConvParamOffsetToPointer(info->PI_Params,
                             info->PI_NumOfParams) ;

    retcode = PORTSETINFO(ppcb->PCB_Media,
              ppcb->PCB_PortIOHandle,
              info) ;

    ((REQTYPECAST *) buffer)->Generic.retcode = retcode ;
}

VOID
PortOpenEx(pPCB padding, PBYTE buffer)
{
    WORD    i ;

    DWORD   retcode = ERROR_PORT_NOT_AVAILABLE;
    
    BOOL    fDeviceFound = FALSE;

    pPCB    ppcb ;

    BOOL    fPidMatch;

    CHAR    *pszDeviceName = ((REQTYPECAST *)
                              buffer)->PortOpenEx.szDeviceName;

    DWORD   dwCounter = ((REQTYPECAST *)
                        buffer)->PortOpenEx.dwDeviceLineCounter;

    DWORD   dwFlags = ((REQTYPECAST *)
                      buffer)->PortOpenEx.dwFlags;

    DWORD   pid = ((REQTYPECAST *)
                    buffer)->PortOpenEx.pid;

    HANDLE  notifier;

    DWORD   dwCurrentCounter = 0;


    RasmanTrace(
           "PortOpenEx: %s",
           pszDeviceName);

    fPidMatch = (pid == GetCurrentProcessId());

    for(i = 0; i < MaxPorts; i++)
    {
        ppcb = Pcb[i];



#if 0
        RasmanTrace(
              "ppcb = 0x%x",
              ppcb);

        if(NULL != ppcb)
        {
            RasmanTrace(
                   "DwPortOpen: PortStatus=%d",
                   ppcb->PCB_PortStatus);

            RasmanTrace(
                   "DwPortOpen: dwFlags=%d,ConfiguredUsage=%d",
                   dwFlags,
                   ppcb->PCB_ConfiguredUsage);

            RasmanTrace(
                  "DwPortOpen: fPidMatch=%d",
                  fPidMatch);

            RasmanTrace(
                  "DwPortOpen: "
                  "ppcb->PCB_RasmanReceiveFlags&RECEIVE_PPLISTEN",
                  (ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPLISTEN));

            RasmanTrace(
                   "DwPortOpen: OpenInstances=%d",
                   ppcb->PCB_OpenInstances);

            RasmanTrace(
                   "DwPortOpen: Devicename=%s",
                   ppcb->PCB_DeviceName);

            RasmanTrace(
                   "DwPortOpen: OpenedUsage=%d",
                   ppcb->PCB_OpenedUsage);

        }

#endif
        if(     (NULL != ppcb)
            &&  (0 == _stricmp(ppcb->PCB_DeviceName, pszDeviceName)))
        {
            if(     (REMOVED != ppcb->PCB_PortStatus)
                &&  (UNAVAILABLE != ppcb->PCB_PortStatus))
            {                
                fDeviceFound = TRUE;
            }

            if(dwCounter >=
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwNumEndPoints)
            {
                retcode = ERROR_NO_MORE_ITEMS;
                break;
            }
        }

        /*
        if(     (NULL != ppcb)
            &&  (0 == _stricmp(ppcb->PCB_DeviceName, pszDeviceName))
            &&  (dwCounter >=
                ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwNumEndPoints))
        {
            retcode = ERROR_NO_MORE_ITEMS;
            break;
        }

        */

        //
        // Skip over the port if
        //
        // 1. port is not present
        // 2. port is in the process of being removed
        // 3. port has been removed
        // 4. port is not configured for what the request
        //    is being made for
        // 5. if a process other than mprouter is opening
        //    the port and  the port is not configured for
        //    CALL_OUT - only server/router opens the port
        //    for listening
        // 6. BAP is already dialed out and listening on the
        //    port.
        // 7. if the port has already been opened twice
        // 8. if the devicename of the port doesn't match
        // 9. if the port is not closed and has already been
        //    opened for dialout/dialin and again being asked
        //    to be opened for the same usage.
        //
        if(     (NULL == ppcb)
            ||  (UNAVAILABLE == ppcb->PCB_PortStatus)
            ||  (REMOVED == ppcb->PCB_PortStatus)
            ||  (0 == (dwFlags & ppcb->PCB_ConfiguredUsage))
            ||  (   !fPidMatch
                 && !(ppcb->PCB_ConfiguredUsage & CALL_OUT))
            ||  (ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPLISTEN)
            ||  (ppcb->PCB_OpenInstances >= 2)
            ||  (_stricmp(ppcb->PCB_DeviceName, pszDeviceName))
            ||  (   CLOSED != ppcb->PCB_PortStatus
                &&  (dwFlags & ppcb->PCB_OpenedUsage)))
        {
            continue;
        }

        //
        // Skip over the port if we have already seen this line
        // of the device. This is being done here to support
        // the alternates list in the connections. look at
        // the comments associated with RasDialTryNextLink
        // routine in rasdial.c
        //
        if(dwCounter >= ppcb->PCB_pDeviceInfo->rdiDeviceInfo.dwNumEndPoints)
        {
            //
            // We have tried dialing over all the lines available on
            // this device. No point in searching for lines on this
            // device.
            //
            retcode = ERROR_NO_MORE_ITEMS;
            
            break;
        }

        if(dwCounter > dwCurrentCounter)
        {
            dwCurrentCounter += 1;
            continue;
        }

        //
        // PORT IS AVAILABLE
        //
        if (ppcb->PCB_PortStatus == CLOSED)
        {
            retcode = PORTOPEN(ppcb->PCB_Media,
                                ppcb->PCB_Name,
                                &ppcb->PCB_PortIOHandle,
                                hIoCompletionPort,
                                HandleToUlong(ppcb->PCB_PortHandle));

            if(SUCCESS == retcode)
            {
                break;
            }
            else
            {
                RasmanTrace( 
                       "PortOpenEx: port %s not available. 0x%x",
                       ppcb->PCB_Name,
                       retcode);
            }
        }
        else
        {
            //
            // PORT IS BIPLEX
            //
            if (ppcb->PCB_ConnState == LISTENING)
            {
                ReOpenBiplexPort (ppcb) ;

                retcode = SUCCESS;

                break;
            }
            else
            {
                //
                // BIPLEX PORT IS NOT LISTENING
                //
                if (    (ppcb->PCB_ConnState == CONNECTED)
                    ||  (ppcb->PCB_ConnState == LISTENCOMPLETED))
                {
                    retcode = ERROR_PORT_ALREADY_OPEN ;

                    continue;
                }
                else
                {
                    //
                    // This tells us that there wasnt a listen
                    // pending when the request was cancelled.
                    //
                    FreeNotifierHandle(
                        ppcb->PCB_AsyncWorkerElement.WE_Notifier);

                    ppcb->PCB_AsyncWorkerElement.WE_Notifier =
                                            INVALID_HANDLE_VALUE;

                    ReOpenBiplexPort (ppcb) ;

                    retcode = SUCCESS;

                    break;
                }
            }
        }
    }

    //
    // If there is no error so far update our data structures,
    // the port is now OPEN:
    //
    if (retcode == SUCCESS)
    {

        HANDLE h;
        PROCESS_SESSION_INFORMATION pci;

        RasmanTrace(
               "PortOpen (%d, %s) OpenInstances = (%d)",
               ppcb->PCB_PortHandle,
               ppcb->PCB_Name,
               ppcb->PCB_OpenInstances);

        if(CLOSED == ppcb->PCB_PortStatus)
        {
            ppcb->PCB_OpenedUsage = CALL_NONE;
        }

        ppcb->PCB_PortStatus = OPEN ;

        SetPortConnState(__FILE__, __LINE__,
                        ppcb, DISCONNECTED);

        ppcb->PCB_DisconnectReason = NOT_DISCONNECTED ;

        ppcb->PCB_OpenInstances++ ;

        RasmanTrace(
                "PortOpenEx (%d) : OpenInstances = %d",
                ppcb->PCB_PortHandle,
                ppcb->PCB_OpenInstances);

        ppcb->PCB_OwnerPID = pid;

        ppcb->PCB_UserStoredBlock = NULL;

        ppcb->PCB_UserStoredBlockSize = 0 ;

        ppcb->PCB_LinkSpeed = 0 ;

        ppcb->PCB_Bundle = ppcb->PCB_LastBundle
                         = (Bundle *) NULL ;

        ppcb->PCB_Connection = NULL;

        ppcb->PCB_AutoClose  = FALSE;

        //
        // by default these handles are the same.
        // exceptions handled specifically
        //
        ppcb->PCB_PortFileHandle   = ppcb->PCB_PortIOHandle;
        ppcb->PCB_pszPhonebookPath = NULL;
        ppcb->PCB_pszEntryName     = NULL;
        ppcb->PCB_pszPhoneNumber   = NULL;
        ppcb->PCB_pCustomAuthData  = NULL;
        ppcb->PCB_pCustomAuthUserData = NULL;
        ppcb->PCB_fLogon = FALSE;
        ppcb->PCB_fFilterPresent = FALSE;
        ppcb->PCB_RasmanReceiveFlags &= ~(RECEIVE_PPPSTOPPED | RECEIVE_PPPSTARTED);


        ppcb->PCB_hEventClientDisconnect = INVALID_HANDLE_VALUE;

#if UNMAP
        ppcb->PCB_LinkHandle = INVALID_HANDLE_VALUE;
#endif        

        ppcb->PCB_ulDestAddr = 0;

        //
        // store the logonid of the owner of the pid
        // that owns the port
        //
        if(pid != GetCurrentProcessId())
        {
            h = OpenProcess(
                    PROCESS_QUERY_INFORMATION,
                    FALSE,
                    ppcb->PCB_OwnerPID);
           if (h)
            {
                if (NtQueryInformationProcess(
                        h,
                        ProcessSessionInformation,
                        &pci,
                        sizeof(PROCESS_SESSION_INFORMATION),
                        NULL) == STATUS_SUCCESS)
                {
                    ppcb->PCB_LogonId = pci.SessionId;
                }

                CloseHandle(h);
            }
        }

        //
        // Adjust the stat value for the zeroed stats
        //
        for (i = 0; i < MAX_STATISTICS; i++)
        {
            ppcb->PCB_AdjustFactor[i] = 0 ;
            ppcb->PCB_BundleAdjustFactor[i] = 0 ;
            ppcb->PCB_Stats[i] = 0 ;
        }

        ppcb->PCB_OpenedUsage |= dwFlags;

        notifier = ValidateHandleForRasman(
                            ((REQTYPECAST*)
                            buffer)->PortOpenEx.hnotifier,
                            pid);

        retcode = AddNotifierToList(&ppcb->PCB_NotifierList,
                        notifier,
                        NOTIF_DISCONNECT,
                        ((REQTYPECAST*)buffer)->PortOpen.PID);

        if(SUCCESS != retcode)
        {
            FreeNotifierHandle(notifier);
            goto done;
        }

        ((REQTYPECAST *)
        buffer)->PortOpenEx.hport = ppcb->PCB_PortHandle ;

        //
        // Initialize the port's user data list.
        //
        InitializeListHead(&ppcb->PCB_UserData);
        ppcb->PCB_SubEntry = 0;

        //
        // Handle the Reserve port case - where we
        // relinquish the port
        //
        if (((REQTYPECAST *)
            buffer)->PortOpenEx.dwOpen == FALSE)
        {
            PORTCLOSE (ppcb->PCB_Media, ppcb->PCB_PortIOHandle);
        }
    }
    else if(i == MaxPorts)
    {
        retcode = ERROR_NO_MORE_ITEMS;
    }

done:

    ((REQTYPECAST *) buffer)->PortOpenEx.retcode = retcode ;

    if(!fDeviceFound)
    {
        ((REQTYPECAST *) buffer)->PortOpenEx.dwFlags |= 
                                    CALL_DEVICE_NOT_FOUND;
    }

    RasmanTrace(
           "PortOpenEx: rc=0x%x. DeviceFound=%d", 
            retcode,
            fDeviceFound);
}


/*++

Routine Description:

    Services request to open port. The port will be
    opened if it is available, or it is confrigured
    as Biplex and is currently not connected.

Arguments:

Return Value:

    Nothing
--*/
VOID
PortOpenRequest (pPCB padding, PBYTE buffer)
{
    WORD    i ;
    DWORD   retcode = SUCCESS ;
    pPCB    ppcb ;
    HANDLE  notifier ;
    BOOL    fPidMatch;

    //
    // Try to find the port with the name specified:
    //
    ppcb = GetPortByName(((REQTYPECAST*)buffer)->PortOpen.portname);

    //
    // If port with given name not found: return error.
    //
    if (ppcb == NULL)
    {
        ((REQTYPECAST *) buffer)->PortOpen.retcode =
                                    ERROR_PORT_NOT_FOUND ;
        RasmanTrace(
               "PortOpenRequest: ERROR_PORT_NOT_FOUND %s",
                ((REQTYPECAST *)
                 buffer)->PortOpen.portname);

        return ;
    }

    RasmanTrace( "PortOpen (%d). OpenInstances = (%d)",
            ppcb->PCB_PortHandle, ppcb->PCB_OpenInstances);

    //
    // Check to see if this port is in the process of being
    // removed and fail the call if it is so.
    //
    if (UNAVAILABLE == ppcb->PCB_PortStatus)
    {
        RasmanTrace(
               "PortOpen: Port %d in the process of "
               "being removed", ppcb->PCB_PortHandle);

        ((REQTYPECAST *) buffer )->PortOpen.retcode =
                                    ERROR_PORT_NOT_FOUND;

        return;
    }

    //
    // If a client is opening the port, make sure
    // the port is configured for CALL_OUT.  These
    // checks don't have to be done under the lock,
    // since PCB_ConfiguredUsage doesn't change.
    //
    fPidMatch = ((REQTYPECAST*)buffer)->PortOpen.PID ==
                                    GetCurrentProcessId();

    if (    !fPidMatch
        &&  !(ppcb->PCB_ConfiguredUsage & CALL_OUT))
    {
        ((REQTYPECAST *) buffer)->PortOpen.retcode =
                                ERROR_PORT_NOT_AVAILABLE ;
        return ;
    }

    if ( ppcb->PCB_RasmanReceiveFlags & RECEIVE_PPPLISTEN )
    {
        ((REQTYPECAST *) buffer)->PortOpen.retcode =
                                ERROR_PORT_ALREADY_OPEN ;

        return;
    }

    if (ppcb->PCB_OpenInstances >= 2)
    {
        //
        // CANNOT OPEN MORE THAN TWICE.
        //
        retcode = ERROR_PORT_ALREADY_OPEN ;
    }
    else
    {
        //
        // PORT IS AVAILABLE
        //
        if (ppcb->PCB_PortStatus == CLOSED)
        {
            retcode = PORTOPEN(ppcb->PCB_Media,
                                ppcb->PCB_Name,
                                &ppcb->PCB_PortIOHandle,
                                hIoCompletionPort,
                                HandleToUlong(ppcb->PCB_PortHandle));
        }
        else
        {
            //
            // PORT IS BIPLEX
            //
            if (ppcb->PCB_ConnState == LISTENING)
            {
                ReOpenBiplexPort (ppcb) ;
            }
            else
            {
                //
                // BIPLEX PORT IS NOT LISTENING
                //
                if (    (ppcb->PCB_ConnState == CONNECTED)
                    ||  (ppcb->PCB_ConnState == LISTENCOMPLETED)
                    ||  (ppcb->PCB_ConnState == CONNECTING))
                {
                    RasmanTrace( "Port %s is already open for %d",
                            ppcb->PCB_Name,
                            ppcb->PCB_CurrentUsage);

                    if(     (CALL_OUT == ppcb->PCB_CurrentUsage)                            
                        &&  (   (CONNECTED == ppcb->PCB_ConnState)
                            ||  (CONNECTING == ppcb->PCB_ConnState)))
                    {
                        ppcb->PCB_OpenInstances++ ;
                        RasmanTrace( 
                               "PortOpen (%d) : OpenInstances = %d",
                               ppcb->PCB_PortHandle,
                               ppcb->PCB_OpenInstances);

                                                       
                        ((REQTYPECAST *) buffer)->PortOpen.porthandle =
                                            ppcb->PCB_PortHandle ;
                                            
                        ((REQTYPECAST *) buffer)->PortOpen.retcode =
                                        ERROR_SUCCESS;

                        return;                                        
                    }
                    else
                    {
                        retcode = ERROR_PORT_ALREADY_OPEN ;
                    }
                }
                else
                {
                    //
                    // This tells us that there wasnt a listen
                    // pending when the request was cancelled.
                    //
                    FreeNotifierHandle(
                        ppcb->PCB_AsyncWorkerElement.WE_Notifier);
                    ppcb->PCB_AsyncWorkerElement.WE_Notifier =
                                            INVALID_HANDLE_VALUE;

                    ReOpenBiplexPort (ppcb) ;
                }
            }
        }
    }

    //
    // If there is no error so far update our data structures,
    // the port is now OPEN:
    //
    if (retcode == SUCCESS)
    {
        ppcb->PCB_PortStatus = OPEN ;

        SetPortConnState(__FILE__, __LINE__, ppcb, DISCONNECTED);

        ppcb->PCB_DisconnectReason      = NOT_DISCONNECTED ;

        ppcb->PCB_OpenInstances++ ;

        RasmanTrace( "PortOpen (%d) : OpenInstances = %d",
                ppcb->PCB_PortHandle, ppcb->PCB_OpenInstances);

        ppcb->PCB_OwnerPID              =
            ((REQTYPECAST*)buffer)->PortOpen.PID;

        ppcb->PCB_UserStoredBlock       = NULL;
        ppcb->PCB_UserStoredBlockSize   = 0 ;
        ppcb->PCB_LinkSpeed             = 0 ;
        ppcb->PCB_Bundle                = ppcb->PCB_LastBundle
                                        = (Bundle *) NULL ;

        ppcb->PCB_Connection            = NULL;
        ppcb->PCB_AutoClose             = FALSE;

        //
        // by default these handles are the same.
        // exceptions handled specifically
        //
        ppcb->PCB_PortFileHandle        = ppcb->PCB_PortIOHandle;
        ppcb->PCB_pszPhonebookPath      = NULL;
        ppcb->PCB_pszEntryName          = NULL;
        ppcb->PCB_pszPhoneNumber        = NULL;
        ppcb->PCB_pCustomAuthData       = NULL;
        ppcb->PCB_pCustomAuthUserData   = NULL;
        ppcb->PCB_fLogon = FALSE;
        ppcb->PCB_LastError = SUCCESS;

        ppcb->PCB_hEventClientDisconnect = INVALID_HANDLE_VALUE;

        //
        // Adjust the stat value for the zeroed stats
        //
        for (i = 0; i < MAX_STATISTICS; i++)
        {
            ppcb->PCB_AdjustFactor[i] = 0 ;
            ppcb->PCB_BundleAdjustFactor[i] = 0 ;
            ppcb->PCB_Stats[i] = 0 ;
        }

        ppcb->PCB_CurrentUsage = CALL_NONE ;
        notifier = ValidateHandleForRasman(
                ((REQTYPECAST*)buffer)->PortOpen.notifier,
                ((REQTYPECAST*)buffer)->PortOpen.PID);

        retcode = AddNotifierToList(&ppcb->PCB_NotifierList,
                        notifier,
                        NOTIF_DISCONNECT,
                        ((REQTYPECAST*)buffer)->PortOpen.PID);

        if(SUCCESS != retcode)
        {
            FreeNotifierHandle(notifier);
            goto done;
        }

        ((REQTYPECAST *) buffer)->PortOpen.porthandle =
                                    ppcb->PCB_PortHandle ;

        //
        // Initialize the port's user data list.
        //
        InitializeListHead(&ppcb->PCB_UserData);
        ppcb->PCB_SubEntry = 0;

        //
        // Handle the Reserve port case - where we
        // relinquish the port
        //
        if (((REQTYPECAST *) buffer)->PortOpen.open == FALSE)
        {
            PORTCLOSE (ppcb->PCB_Media, ppcb->PCB_PortIOHandle) ;
        }
    }
    else
    {
        RasmanTrace(
               "PortOpen: failed to open port %s. 0x%x",
               ppcb->PCB_Name,
               retcode);
    }

done:

    ((REQTYPECAST *) buffer)->PortOpen.retcode = retcode ;
}

/*++

Routine Description:

    Closes the requested port - if a listen was pending
    on the biplex port it is reposted.  Assumes the
    port's PCB_AsyncWorkerElement.WE_Mutex has
    already been acquired.

Arguments:

Return Value:

    Status code

--*/
DWORD
PortClose(
    pPCB ppcb,
    DWORD pid,
    BOOLEAN fClose,
    BOOLEAN fServerClose
    )
{
    WORD            i ;
    BOOLEAN         fOwnerClose;
    ConnectionBlock *pConn;
    DWORD           curpid = GetCurrentProcessId();

    if(NULL == ppcb)
    {
        return ERROR_PORT_NOT_FOUND;
    }

    RasmanTrace(
        
        "PortClose: port (%d). OpenInstances = %d",
        ppcb->PCB_PortHandle,
        ppcb->PCB_OpenInstances
        );

    //
    // If we are in the process of disconnecting,
    // then we must wait for the media DLL to signal
    // completion of the disconnect request.  At that
    // time, we will complete the close of the port.
    //
    if (    ppcb->PCB_ConnState == DISCONNECTING
        &&  ppcb->PCB_AsyncWorkerElement.WE_ReqType
                            == REQTYPE_PORTDISCONNECT)
    {
        RasmanTrace(
               "PortClose: port %s in DISCONNECTING"
               " state, deferring close",
               ppcb->PCB_Name);

        ppcb->PCB_AutoClose = TRUE;

        return SUCCESS;
    }

    //
    // Ensure the port is open.  If not, return.
    //
    if (ppcb->PCB_PortStatus == CLOSED)
    {
        return SUCCESS;
    }

    //
    // If the owner is the RAS server, then only the RAS
    // server can close it.
    //
    if (    ppcb->PCB_OwnerPID == curpid
        &&  pid != curpid)
    {
        //
        // If this is a dialout connection, check to see if its
        // demand dial. Proceed if it isn't
        //
        if(     (NULL != ppcb->PCB_Connection)
            && (IsRouterPhonebook(ppcb->PCB_Connection->
                        CB_ConnectionParams.CP_Phonebook)))
            
        {
            RasmanTrace("PortClose: ACCESS_DENIED");
            return ERROR_ACCESS_DENIED;
        }
    }

    //
    // Three cases of close in case of Biplex usage (OpenInstances == 2):
    //
    // A. The client which opened the port is closing it.
    // B. The server is closing the port.
    // C. The client which opened the port is no longer aro